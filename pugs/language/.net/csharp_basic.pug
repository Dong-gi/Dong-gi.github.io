include ../../../source/skeleton.pug
+post('C#.NET', 'C#, .NET', 'C#.NET 정리')
    h1 작성 기준
    ul
        li 2022년 04월
        li .NET 6.0
        li C# 10

    h1 .NET
    div
        h2 .NET 개요
        ul
            li .NET은 (거의) 모든 플랫폼에서 구동하는 다양한 종류의 앱을 빌드하기 위한 무료 오픈 소스 개발 플랫폼
            li .NET은 다양한 구현체가 존재한다
            ul
                li 이전에 .NET Core로 불렸던 .NET 5 이상은 최신 구현으로, (거의) 모든 플랫폼에서 실행된다
                li .NET Framework는 .NET의 이전 구현으로, Windows에서만 실행된다
                li Mono는 Android, Mac, iOS, tvOS 및 watchOS에서 Xamarin 애플리케이션의 성능을 향상하는 런타임
                p Unity 엔진도 지원한다. iOS를 위한 전체 사전 컴파일(AOT; Ahead-Of-Time) 컴파일) 기능도 제공
                li UWP는 최신 Windows 앱을 빌드하는 데 사용
            li .NET 앱은 MSBuild를 사용하여 소스 코드로부터 빌드
            li MSBuild와 .NET CLI는 GitHub Actions, Azure DevOps 등의 CI/CD 환경에 사용 가능
            li NuGet은 .NET을 위해 설계된 오픈 소스 패키지 관리자
            p NuGet 패키지는 컴파일된 코드(DLL), 코드와 관련된 다른 파일 및 패키지의 버전 번호와 같은 정보가 포함된 설명이 포함된 확장명 있는 .zip파일
        div
            h3 .NET 실행 모델
            p 각 .NET 구현체는 다음을 포함한다
            ul
                li 런타임(e.g. .NET 5 CLR)
                li 클래스 라이브러리(e.g. .NET 5 기본 클래스 라이브러리)
                li 필요에 따른 애플리케이션 라이브러리(e.g. WPF, Windows Forms)
                li 개발 도구
            div
                h4.fake CLR(Common Language Runtime)
                ul
                    li .NET 앱은 CLR 환경에서 관리 코드를 실행한다
                    li CLR은 Windows, macOS, Linux 지원을 포함하는 플랫폼 간 런타임으로, 메모리 할당 및 관리(GC)를 처리하는 가상 머신이다
                    li 관리 코드란 CLR이 실행을 관리하는 코드로써, C/C++ 처럼 프로그래머가 모든 작업을 관리하는 비관리 코드와 대조된다
                h4.fake JIT(Just-In-Time) 컴파일러와 IL(Intermediate Language)
                ul
                    li 중간 언어는 고급 .NET 언어로 작성된 코드가 컴파일된 결과물로, 모든 고급 .NET 언어 및 하드웨어에 독립적이다
                    li CLR이 중간 언어를 JIT 처리하여 CPU를 위한 기계어 코드를 생성하고 실행한다
                h4.fake 비관리 리소스 작업
                ul
                    li e.g. FileStream은 관리 객체지만, 관리되지 않는 파일 핸들을 참조한다. 따라서 FileStream 사용을 마쳤다면 파일 핸들을 명시적으로 해제해야 한다
                    li 비관리 리소스를 참조하는 객체는 IDisposable 인터페이스를 구현한다. 이러한 객체를 using 문에서 사용하면 Dispose() 메서드를 자동으로 호출한다
                    +asCode('cs').
                        var iDisposable = new FileStream("./", FileMode.Open);
                        try { } finally { iDisposable.Dispose(); }

                        // 아래와 동일
                        using (iDisposable = new FileStream("./", FileMode.Open)) { }

            h3 .NET 배포 모델
            ul
                li 자체 포함
                p .NET 런타임 및 라이브러리 등을 포함한 실행 파일 생성. .NET 런타임이 없는 머신에서도 실행 가능
                li 프레임워크 종속
                p 앱과 자체 종속성만 포함하는 .dll 파일과 실행 파일 생성. 사용자가 .NET을 설치해야 실행 가능

            h3 런타임 라이브러리 확장
            p 자주 사용되는 일부 기능은 런타임 라이브러리에 포함되지는 않지만 NuGet 패키지로 제공된다
            table
                +ths('NuGet 패키지', '설명서')
                +tds('Microsoft.Extensions.Hosting', '애플리케이션 수명 관리(일반 호스트)')
                +tds('Microsoft.Extensions.DependencyInjection', 'DI(종속성 주입)')
                +tds('Microsoft.Extensions.Configuration', 'Configuration')
                +tds('Microsoft.Extensions.Logging', 'Logging')
                +tds('Microsoft.Extensions.Options', '옵션 패턴')
                +tds('Microsoft.Extensions.FileSystemGlobbing', '파일 탐색')
                +tds('Microsoft.Extensions.Http', 'HTTP')
                +tds('Microsoft.Extensions.Localization', '지역화')

        h2 .NET의 새로운 기능
        div
            h3 .NET Core 2.0
            ul
                li C# 7.1 지원
                li .NET Standard 2.0 구현

            h3 .NET Core 2.1
            ul
                li JIT 컴파일러 개선 : 계층화된 컴파일
                ol
                    li 가능한 빨리 코드를 생성하는 계층
                    li 자주 실행되는 메서드에 대한 최적화 코드를 생성하는 계층(병렬 수행)
                li 보다 메모리 효율적인 자료형 : System.Span&lt;T&gt;, System.Memory&lt;T&gt;
                p 읽기 전용 System.ReadOnlySpan&lt;T&gt;, System.ReadOnlyMemory&lt;T&gt;도 지원

            h3 .NET Core 2.2
            ul
                li EventListener 클래스를 사용하여 GC, JIT, ThreadPool 등의 런타임 모니터링 가능
                    +codeBtn('/Repositories/VisualStudio/ConsoleApp1/SimpleEventListener.cs', 'cs')
                li
                    +asA('https://github.com/dotnet/core-setup/blob/master/Documentation/design-docs/host-startup-hook.md', '호스트 시작 후크')
                    |를 사용하여 Main 메서드 실행 전 코드 삽입 가능

            h3 .NET Core 3.0
            ul
                li C# 8.0 지원
                li .NET Standard 2.1 구현
                li WPF 및 Windows Forms 지원
                li 기본 Json 라이브러리 지원 : System.Text.Json
                li HTTP/2 지원
                li System.Index, System.Range 추가
                li IEnumerable&lt;T&gt;의 비동기 버전 IAsyncEnumerable&lt;T&gt; 추가

            h3 .NET 5
            ul
                li .NET Framework 4.x와의 혼동을 피하기 위해 버전 번호 4.x 생략
                li .NET 주요 구현임을 강조하기 위해 이름에서 "Core" 삭제
                li .NET Standard를 구현하진 않지만, .NET Standard 2.1를 지원
                ul
                    li .NET Standard 2.1 이후 새로운 .NET Standard 버전은 존재하지 않는다
                    li 신규 API가 추가될 때, .NET 5+는 기능의 구현을 공유하므로 모든 .NET 5+ 앱 및 라이브러리에서 즉시 사용 가능하다
                    p 이는 .NET Standard의 사양-구현 분리 문제를 해결한다
                li C# 9 지원

            h3 .NET 6
            ul
                li C# 10 지원
                li .NET MAUI 2022년 2분기 일반 공개 예정
                li Json 라이브러리 강화
                p 유효성 검사 및 기본값 제공, 멤버 순서 지정, 스트림 직렬화/역직렬화 등
                li 우선순위 큐 PriorityQueue&lt;TElement,TPriority&gt; 추가
                li HTTP/3 Preview 지원
                li 제네릭 형식에 대한 연산자 지원(Preview)

        h2 배포 모델
        div
            h3 단일 파일 배포 및 실행 파일
            ul
                li 배포 설정 시 "Produce single file"을 설정하면 관리형 DLL을 앱과 함께 단일 실행 파일에 제공한다
                p 실행 시 관리형 DLL이 추출되어 메모리에 로드되며, 폴더로 추출되지는 않음 Since .NET 5
                li 네이티브 라이브러리를 단일 파일로 묶고 싶다면 IncludeNativeLibrariesForSelfExtract 플래그 이용
                +asCode('xml', 'project.csproj') &lt;IncludeNativeLibrariesForSelfExtract&gt;true&lt;/IncludeNativeLibrariesForSelfExtract&gt;
                li 모든 파일을 단일 파일로 묶고 싶다면 IncludeAllContentForSelfExtract 플래그 이용
                +asCode('xml', 'project.csproj') &lt;IncludeAllContentForSelfExtract&gt;true&lt;/IncludeAllContentForSelfExtract&gt;
                p 위 두 옵션은 앱 실행 시 클라이언트 머신의 디렉터리에 파일이 추출된다
                ul
                    li Linux, MacOS : $HOME/.net
                    li Windows : %TEMP%/.net
                    li DOTNET_BUNDLE_EXTRACT_BASE_DIR 환경변수로 제어 가능
                li PDB 파일을 DLL에 포함
                +asCode('xml', 'project.csproj') &lt;DebugType&gt;embedded&lt;/DebugType&gt;
                li 단일 파일 배포시 압축 Since .NET 6
                +asCode('xml', 'project.csproj') &lt;EnableCompressionInSingleFile&gt;true&lt;/EnableCompressionInSingleFile&gt;

        h2 기본 코딩 구성 요소
        div
            h3 Common Type System
            p CLR에서 사용되는 데이터 타입의 선언, 사용, 관리 방법을 정의한다

            h3 .NET의 데이터 타입
            p .NET의 모든 타입은 아래의 2가지 범주에 해당한다
            ul
                li Value type : value type의 인스턴스는 값 자체를 표현하며, value type의 인스턴스가 변수에 할당되는 경우 변수는 값의 사본을 갖는다
                li Reference type : reference type의 인스턴스는 실제 값에 대한 참조(포인터와 유사)를 표현하며, reference type의 인스턴스가 변수에 할당되는 경우 변수는 동일한 참조를 갖는다

            h3 클래스
            ul
                li 클래스는 명시적으로 지정된 다른 클래스 또는 암시적으로 System.Object에서 파생되는 참조 형식
                li 객체가 수행할 수 있는 작업과 객체에 포함되는 데이터(필드)를 정의한다.

            h3 구조체
            ul
                li 구조체는 System.ValueType에서 파생되는 값 형식
                li 값 형식이므로 생성자 호출 없이 변수 선언만으로 초기화가 진행된다. 이때 사용되는 기본 생성자는 자동으로 추가되며, 재정의할 수 없다
                p 인자를 받는 생성자를 정의할 수 있으며, 생성자는 모든 필드를 초기화해야 한다
                li .NET의 모든 기본 데이터 타입(Boolean, Int32, ...)들도 구조체로 정의된다
                li 명시적으로 다른 타입을 상속할 수 없으며, 구조체 자체도 다른 타입의 상속의 대상이 되지 않는다

            h3 열거형
            ul
                li 열거형은 System.Enum에서 파생되는 값 형식으로, 기본 정수 타입의 값들에 대해 별명을 제공한다
                li 내부 형식의 값을 형 변환 없이 열거형에 할당할 수 있다. and vice versa
                li 메서드 정의 불가, 인터페이스 구현 불가, 프로퍼티 및 이벤트 정의 불가
                li 열거형 자체는 기본 정수 타입에 대한 제네릭이므로, 열거형 정의에 형식 매개 변수를 사용할 수는 없다
                li FlagsAttribute를 이용해 비트 필드라는 특수한 형태의 열거형을 정의할 수 있다
                    +codeBtn('/Repositories/VisualStudio/ConsoleApp2/Program.cs', 'cs')

            h3 인터페이스
            ul
                li 인터페이스는 멤버와 시그니쳐만을 정의한다
                li 인터페이스의 멤버는 모두 추상 멤버이며, 생성자를 가질 수 없다
                li 필드 정의 불가, 정적 멤버 정의 불가
                li 프로퍼티 정의는 가질 수 있다. 구현은 구현 클래스에서 제공

            h3 대리자
            ul
                li 메서드를 참조할 수 있는 참조 형식
                +asCode('cs', '명명 대리자 인스턴스 생성').
                    public delegate void DoSomething();

                    public static void Main(string[] args)
                    {
                        var delegate1 = new DoSomething(() =&gt; Console.WriteLine("delegate1"));
                        delegate1.Invoke();
                    }
                li 대리자는 System.Delegate → System.MulticastDelegate를 상속한다
                li 익명 대리자 인스턴스 생성
                ol
                    li delegate 연산자 Since .NET Framework 2.0
                    +asCode('cs').
                        var arr = new int[] { 1, 2, 3, 4, 5 };
                        Console.WriteLine(arr.Where(delegate (int n) { return n % 2 == 0; }).Sum());
                    li 람다 Since C# 3.0
                    +asCode('cs').
                        var arr = new int[] { 1, 2, 3, 4, 5 };
                        Console.WriteLine(arr.Where(n => n % 2 == 0).Sum());
                li 미리 정의된 재사용 가능 대리자
                ul
                    li Action : void 리턴 메서드 참조. 매개변수 0 ~ 16개, 총 17가지
                    li Func : 결과를 반환하는 메서드 참조. 매개변수 0 ~ 16개, 총 17가지
                    li Predicate : bool을 반환하는 Func

            h3 멤버
            ul
                li 필드 : 임의 타입 변수
                li 프로퍼티 : (히든) 필드에 대한 getter/setter 메서드. 프로퍼티의 타입과 프로퍼티 내에서 참조하는 필드의 타입이 같을 필요가 없다
                li 메서드
                ul
                    li 메서드 오버로딩
                    p 메서드 시그니처는 이름과 매개 변수 목록으로 구성되며, 메서드 시그니처가 다르다면 이름이 같은 2개 이상의 메서드를 정의할 수 있다
                    li 연산자 오버로딩
                        +codeBtn('/Repositories/VisualStudio/ConsoleApp3/Program.cs', 'cs')
                li 생성자
                li 이벤트
                p 대리자를 이용한 관찰자 패턴. 간단하게 구독/해지 가능
                    +codeBtn('/Repositories/VisualStudio/ConsoleApp5/SomeTimer.cs', 'cs')
                    +codeBtn('/Repositories/VisualStudio/ConsoleApp5/Program.cs', 'cs')
                +asCode('cs').
                    public delegate void EventHandler(object? sender, EventArgs e);
                    public delegate void EventHandler&lt;TEventArgs&gt;(object? sender, TEventArgs e);
                p 이벤트 핸들러 추가/제거 작업 재정의 가능
                    +codeBtn('/Repositories/VisualStudio/ConsoleApp6/SomeTimer.cs', 'cs')
                    +codeBtn('/Repositories/VisualStudio/ConsoleApp6/Program.cs', 'cs')
                li 중첩 타입

            h3 멤버의 특성
            table
                +ths('특성', '적용 대상', '설명')
                +tds('abstract', '메서드, 프로퍼티, 이벤트', '파생 타입에서 구현 제공')
                +tds('private, family, assembly, family and assembly, family or assembly, public', '모두', '멤버 액세스 범위 제한')
                +tds('final', '메서드, 프로퍼티, 이벤트', '파생 타입에서 재정의 불가')
                +tds('initialize-only', '필드', '초기화 이후 변경 불가')
                +tds('newslot, override', '모두', '시그니처가 같은 상속된 멤버와의 상호작용. new(숨김, default, 부모 타입으로 형변환하여 숨긴 메서드 호출 가능), override(재정의)')
                +tds('virtual', '메서드, 프로퍼티, 이벤트', '파생 타입에서 다른 구현을 제공할 수 있다. 메서드의 어떤 구현을 호출할 지 결정하는 것은 런타임에 호출을 수행하는 인스턴스의 타입. 원하는 버전의 메서드를 호출하려면 해당 타입으로 변수를 캐스팅')

            h3 .NET의 타입 변환
            ul
                li 파생 클래스에서 부모 클래스로의 변환은 연산자 없이 자동 지원
                li 부모 클래스에서 파생 클래스로의 변환은 연산자를 이용해 자동 지원
                li 클래스에서 구현하는 인터페이스로의 변환은 연산자 없이 자동 지원
                li 인터페이스에서 구현 클래스로의 변환은 연산자를 이용해 자동 지원
                li 사용자 정의 암시적/명시적 타입 변환
                    +codeBtn('/Repositories/VisualStudio/ConsoleApp4/Program.cs', 'cs')

            h3 제네릭의 공변성(Covariance) 및 반공변성(Contravariance)
            ul
                li Covariance : 지정된 것보다 더 많은 파생 타입을 사용 가능
                p e.g. IEnumerable&lt;Derived&gt; 인스턴스를 IEnumerable&lt;Base&gt; 변수에 할당 가능
                li Contravariance : 지정된 것보다 더 일반적인 타입을 사용 가능
                p e.g. Action&lt;Base&gt; 인스턴스를 Action&lt;Derived&gt; 변수에 할당 가능
                li Invariance : 지정된 타입만 사용 가능
                p e.g. List&lt;Base&gt;는 List&lt;Derived&gt; 변수에 할당 불가능. and vice versa
            table
                +ths('형식', '공변 형식 매개 변수', '반공변 형식 매개 변수')
                +tds('Action<T>', '', 'Y')
                +tds('Comparison<T>', '', 'Y')
                +tds('Converter<TInput,TOutput>', 'Y', 'Y')
                +tds('Func<TResult>', 'Y', '')
                +tds('Func<T,TResult>', 'Y', 'Y')
                +tds('IComparable<T>', '', 'Y')
                +tds('Predicate<T>', '', 'Y')
                +tds('IComparer<T>', '', 'Y')
                +tds('IEnumerable<T>', 'Y', '')
                +tds('IEnumerator<T>', 'Y', '')
                +tds('IEqualityComparer<T>', '', 'Y')
                +tds('IGrouping<TKey,TElement>', 'Y', '')
                +tds('IOrderedEnumerable<TElement>', 'Y', '')
                +tds('IOrderedQueryable<T>', 'Y', '')
                +tds('IQueryable<T>', 'Y', '')

            h3 컬렉션
            table
                +tds('수행할 작업', '제네릭 컬렉션 옵션', '제네릭이 아닌 컬렉션 옵션', '스레드-안전 or 불변 컬렉션 옵션')
                +tds('키-값 쌍 저장 & 키를 통한 조회', 'Dictionary<TKey,TValue>', 'Hashtable', 'ConcurrentDictionary<TKey,TValue>, ReadOnlyDictionary<TKey,TValue>, ImmutableDictionary<TKey,TValue>')
                +tds('임의 인덱스를 이용한 조회', 'List<T>', 'Array, ArrayList', 'ImmutableList<T>, ImmutableArray')
                +tds('FIFO', 'Queue<T>', 'Queue', 'ConcurrentQueue<T>, ImmutableQueue<T>')
                +tds('LIFO', 'Stack<T>', 'Stack', 'ConcurrentStack<T>, ImmutableStack<T>')
                +tds('삽입 순서에 따른 조회', 'LinkedList<T>', '권장 사항 없음', '권장 사항 없음')
                +tds('컬렉션 변경 감시(INotifyPropertyChanged 및 INotifyCollectionChanged 구현)', 'ObservableCollection<T>', '권장 사항 없음', '권장 사항 없음')
                +tds('정렬된 컬렉션', 'SortedList<TKey,TValue>', 'SortedList', 'ImmutableSortedDictionary<TKey,TValue>, ImmutableSortedSet<T>')
                +tds('집합', 'HashSet<T>, SortedSet<T>', '권장 사항 없음', 'ImmutableHashSet<T>, ImmutableSortedSet<T>')

            h3 예외
            +asCode('cs').
                // 명시적 예외 발생
                throw e; // e는 System.Exception 및 파생 클래스의 인스턴스

                // 예외 처리
                try { } catch { } finally { }   // 임의 예외 처리
                try { } catch (Exception) { }   // 특정 예외 처리
                try { } catch { throw; }        // 호출 스택으로 예외 넘기기
                try { } catch (Exception e) { } // 특정 예외 처리. 예외 인스턴스 참조

                var flag = Random.Shared.Next() % 2 == 0;
                try { } // when 필터를 사용하는 경우, 같은 타입을 여러 번 catch 가능
                catch (Exception) when (flag) { }
                catch (Exception) when (!flag) { }

            h3 .NET의 숫자
            div
                h4.fake 정수
                table
                    +ths('형식', '크기(바이트)', '최소값', '최대값')
                    +tds('System.Int16', '2', '-32,768', '32,767')
                    +tds('System.Int32', '4', '-2,147,483,648', '2,147,483,647')
                    +tds('System.Int64', '8', '-9,223,372,036,854,775,808', '9,223,372,036,854,775,807')
                    +tds('System.SByte', '1', '-128', '127')
                    +tds('System.IntPtr(32비트 프로세스)', '4', '-2,147,483,647', '2,147,483,647')
                    +tds('System.IntPtr(64비트 프로세스)', '8', '-9,223,372,036,854,775,808', '9,223,372,036,854,775,807')
                    +tds('System.Byte', '1', '0', '255')
                    +tds('System.UInt16', '2', '0', '65,535')
                    +tds('System.UInt32', '4', '0', '4,294,967,295')
                    +tds('System.UInt64', '8', '0', '18,446,744,073,709,551,615')
                    +tds('System.UIntPtr(32비트 프로세스)', '4', '0', '4,294,967,295')
                    +tds('System.UIntPtr(64비트 프로세스)', '8', '0', '18,446,744,073,709,551,615')
                    +tds('BigInteger', '무제한', '-∞', '∞')

                h4.fake 부동소수
                p 부동소수는 NaN 및 무한대에 관한 특별한 클래스 멤버를 제공한다
                table
                    +ths('형식', '크기(바이트)', '근사 범위', '참고')
                    +tds('System.Half', '2', '±65504', 'Since .NET 5')
                    +tds('System.Single', '4', '±3.4 x 1038', '')
                    +tds('System.Double', '8', '±1.7 × 10308', '')
                    +tds('System.Decimal', '16', '±7.9228 x 1028', '')

                h4.fake 복소수
                p System.Numerics.Complex

                h4.fake SIMD(Single Instruction Multiple Data)
                ul
                    li Vector&lt;T&gt; : 고속 병렬 처리를 위한 T 타입 1차원 벡터
                    li Vector2, Vector3, Vector4 : Single 값에 대한 2~4차원 벡터
                    li Matrix3x2, Matrix4x4 : 각각 3x2, 4x4 행렬
                    li Plane : 평면
                    li Quaternion : 3차원 물리적 회전

            h3 날짜, 시간 및 표준 시간대
            ul
                li DateTime : UTC 기준 시각. 0001-01-01 00:00:00 ~ 9999-12-31 23:59:59
                p 시간은 틱이라고 하는 100나노초 단위로 측정. 시각은 1년 1월 1일 자정 이후로 경과한 틱 수
                li DateTimeOffset : DateTime + UTC로부터의 offset
                li TimeZoneInfo : 표준 시간대
                +asCode('cs').
                    Console.WriteLine(DateTime.Now);            // 2022-04-20 오후 9:06:11
                    Console.WriteLine(DateTime.UtcNow);         // 2022-04-20 오후 12:06:11

                    Console.WriteLine(DateTimeOffset.Now);      // 2022-04-20 오후 9:06:11 +09:00
                    Console.WriteLine(DateTimeOffset.UtcNow);   // 2022-04-20 오후 12:06:11 +00:00
                    Console.WriteLine(                          // 2022-04-20 오후 9:06:11 +09:00
                        new DateTimeOffset(DateTime.Now, TimeZoneInfo.Local.BaseUtcOffset));
                    Console.WriteLine(                          // 2022-04-20 오후 12:06:11 +09:00
                        new DateTimeOffset(new DateTime(DateTime.UtcNow.Ticks), TimeZoneInfo.Local.BaseUtcOffset));

                    Console.WriteLine(DateTime.Now.Ticks - DateTime.UtcNow.Ticks);              // 323999999997 = 9시간
                    Console.WriteLine(DateTimeOffset.Now.Ticks - DateTimeOffset.UtcNow.Ticks);  // 323999999942 = 9시간
                li DateOnly Since .NET 6 : 0001-01-01 ~ 9999-12-31
                li TimeOnly Since .NET 6 : 00:00:00 ~ 23:59:59

            h3 Attribute
            ol
                li 자바의 애너테이션처럼 요소를 장식한다
                    +codeBtn('/Repositories/VisualStudio/ConsoleApp7/Program.cs', 'cs')
                li 사용자 정의 특성은 System.Attribute를 상속하여 만든다
                li 명명시 Attribute를 접미하고, 실제 사용할 땐 생략 가능하다
                li 특성 적용 대상 제한 : System.AttributeUsage 생성자에 AttributeTargets 전달. 생략시 기본값은 AttributeTargets.All
                li 적용 대상 명시 : assembly, module, type, method, property, field, event, param, return, typevar

        h2 데이터 액세스
        div
            h3 LINQ; Language Itegrated Query
            ol
                li 데이터에 대한 선언적 코드
                    +codeBtn('/Repositories/VisualStudio/ConsoleApp8/Program.cs', 'cs')
                li MoreLinq 패키지에서 추가적인 편의성을 제공한다
                li ↓ 일반 구문
                +asCode('text', 'syntax').
                    from        LINQ는 from으로 시작한다
                                from의 대상은 IEnumerable&lt;T>
                                LINQ 결과도 IEnumerable&lt;T>
                    where + bool 판정식
                    orderby + 정렬 기준 [(ascending) | descending]
                    select + 결과
                +asCode('cs', '예시').
                    from mQuest in mQuests
                    where mQuest.quest_group_id.Equals(mQuestGroup.quest_group_id)
                    orderby mQuest.quest_name
                    select mQuest
                li: +asA('https://docs.microsoft.com/ko-kr/dotnet/standard/parallel-programming/introduction-to-plinq', 'PLINQ')
                ul
                    li AsParallel() : 가능한 경우 나머지 쿼리를 병렬로 실행
                    li AsSequential() : 나머지 쿼리를 순차적으로 실행
                    li AsOrdered() : 나머지 쿼리에 대해, 병렬로 실행하더라도 소스 시퀀스의 순서를 유지
                    li AsUnordered() : 나머지 쿼리에 대해 소스 시퀀스 순서와 무관하게 실행
                    li ForAll() : 순차 실행하는 foreach와 달리, 병렬로 결과 아이템 소비
                li LINQ 내에서의 변수 선언 예 : let x = 10
                li 중첩 쿼리 가능
                +asCode('cs').
                    from student in students
                    from score in student.Scores
                li Grouping 결과는 IGrouping&lt;T> 형식
                +asCode('cs').
                    from p in profiles
                    group p by p.Height &lt; 160 into lowGroup
                    select new { Key = lowGroup.Key, Profiles = lowGroup };
                li Inner Join
                +asCode('cs').
                    from a in A
                    join b in B on a.X equals b.Y
                li Outer Join
                p inner join 결과를 임시 컬렉션으로 치환하고, 임시 컬렉션의 빈 항목을 기본 값으로 채운다
                +asCode('cs').
                    from profile in profiles
                    join product in products on profile.Name equals product.Name into result
                    from product in result.DefaultIfEmpty( new Product() { Title = "없음” } )
                    select new { Name = profile.Name, Work = product.Title };
                li Expression Tree : System.Linq.Expressions
                +asCode('cs').
                    var const1 = Expression.Constant(1);
                    var param1 = Expression.Parameter(typeof(int), "x");
                    var exp = Expression.Add(const1, param1);
                    var lambda = Expression&lt;Func&lt;int, int>>.Lambda&lt;Func&lt;int, int>>(exp, new ParameterExpression[] { (ParameterExpression)param1 });
                    var compiledFunc = lambda.Compile();
                    Console.WriteLine(compiledFunc(3));

            h3: +asA('https://docs.microsoft.com/ko-kr/dotnet/standard/data/xml/', 'System.Xml')
            h3: +asA('https://docs.microsoft.com/ko-kr/dotnet/standard/data/sqlite/?tabs=netcore-cli', 'Microsoft.Data.Sqlite')
            h3: +asA('https://docs.microsoft.com/ko-kr/ef/core/', 'Entity Framework(ORM)')


    h1 문법
    div
        h2 기본 자료형
        div
            h3 숫자 리터럴
            p 16진수 표현 0xFFFF, 2진수 표현 0b1010, 구분 문자 '_' 사용 가능
            h3 문자형
            table.no-sort
                tr
                    td char
                    td 2바이트(유니코드)
                    td System.Char
                tr
                    td string
                    td 동적 크기. Indexer 구현
                    td System.String
            h3 문자열 리터럴
            ul
                li @"" : \ 이스케이프를 하지 않는다. ""로 일반 문자열의 \"를 대신할 수 있다
                li $"" Since C# 6 : 간편한 포맷 문자열을 제공한다. {
                    i 표현식
                    |[,
                    i alignment
                    |][:
                    i formatString
                    |]}
                    +codeBtn('/Repositories/VisualStudio/csharp_interpolated_string.cs', 'cs')
                li Since C# 8 : @$"", $@"" 모두 유효. 이전에는 $@""만 가능
            h3 Boolean
            p Boolean 연산 &&, ||는 Short-circuit

        h2 배열
        ul
            li 배열 초기화시 기본값으로 채워진다
            li 다차원 배열 [,] : 배열 차원 고정. 메모리 상에서는 일차원 배열처럼 존재
            li Jagged Array [][] : 배열의 차원이 가변적
            +asCode('cs').
                int[] arr1 = new int[3];
                int[] arr2 = new int[] { 1, 2, 3 };
                int[] arr3 = { 1, 2, 3 };
                int[,] arr4 = new int[2, 2];
                int[,] arr5 = new int[,] { { 1, 2 }, { 3, 4 } };

        h2 형변환
        p as 연산자를 이용한 명시적 변환은, null을 허용하는 참조 자료형만 가능하다

        h2 구문
        ul
            li if ~ else if ~ else
            li switch
            p 정수, bool, char, string, enum에 대해 동작. case문 다음이 빈 문장일 때만 break 생략 가능
            p Since C# 7.0 : null이 아닌 모든 표현식 가능
            li while, do ~ while
            li for(초기식; 조건식; 증감식)
            li foreach(var obj in IEnumerable)
            li 점프
            p break, continue, goto(관례상 레이블은 대문자로만), return, throw
            li checked/unchecked 블록
            p 기본적으로는 프로그램 실행 시 오버플로/언더플로를 무시한다
            p checked/unchecked 블록은 이를 각각 명시적인 예외로 처리/비처리 하도록 한다
            +codeBtn('/Repositories/VisualStudio/CSharp/Basic/CheckedExample.cs', 'cs', '[13, 39]')

        h2 네임스페이스
        +asCode('cs').
            namespace MyProgram.Model { }
            using System.Collections.Generic;
            using static MyProgram.Model.Constants;

    h1 객체지향
    div
        h2 클래스
        ul
            li 프로퍼티 → (히든) 필드에 대한 getter/setter 메서드
                +codeBtn('/Repositories/VisualStudio/csharp_property.cs', 'cs') ViewModel에서의 사용 예 »
            li 익명 객체 → new { PropertyName = value } : 생성 후 읽기만 가능
            li 정적 생성자 → static 클래스이름() { }
            p 첫 번째 인스턴스가 만들어지거나 정적 멤버가 참조되기 전에 자동으로 호출된다
            li partial class ClassName {} : 프로젝트 내 여러 파일에 걸쳐 클래스 작성 가능
            li 접근 제한자 → public, protected(파생 클래스까지), private, internal(같은 어셈블리), protected internal
        div
            h3 상속
            ul
                li class SubClass : BaseClass
                li interface Interface1 : Interface2
                li is 연산자로 호환 여부 확인 가능
                li this 키워드 : 클래스의 현재 인스턴스
                    br
                    |base 키워드 : 부모 클래스 메서드 또는 생성자 호출
                    +codeBtn('/Repositories/VisualStudio/csharp_base_keyword.cs', 'cs')
                li sealed 키워드 → 상속/재정의 불가
                li 부모 클래스 인스턴스를 자식 클래스로 다운캐스팅 불가
                li 모든 자료형의 조상은 System.Object : ToString(), GetType(), Equals(), GetHashCode()
                    br
                    |모든 값 형식의 조상은 System.ValueType
                    br
                    |모든 배열의 조상은 System.Array : Sort(), BinarySearch&lt;T>(), IndexOf(), ..., Length, Rank

        h2 제네릭
        ul
            li Type Bound
            +asCode('cs').
                class MyGenereic&lt;T, U> where T : struct where U : class { }
                // 값 형식         where T : struct
                // 참조 형식       where T : class
                // 기본 생성자 보유 where T : new()
                // 호환 여부 검사   where T : BaseClassName | InterfaceName | U // U는 다른 형식 매개 변수
                // where T : A[, B[, C[...]]]
            li 제네릭 별명
            +asCode('cs') using Commands = System.Collections.Generic.Dictionary&lt;string, System.Windows.Input.ICommand>;

    h1 추가 기능 ~ C# 8.0 (2019. 02. 12)
    div
        h2 타입
        ol
            li.marker BigInteger : 크기 제한없는 정수. 연산자 오버로딩 덕에 편리
            li.marker dynamic : 파이썬처럼 타입 검사를 런타임에 하여 Duck-typing을 가능하게 한다
            li.marker IntPtr : 32/64비트 프로그램에서 각각 4/8바이트. 포인터 외에 운영체제 핸들값을 저장하는 용도로도 사용
            li.marker var : 지역변수 초기화시 사용 가능한 자동형식
            li.marker Nullable&lt;T> : null을 허용하는 래퍼 클래스. int?는 Nullable&lt;int>와 동일하다
        div
            h3 튜플 : System.ValueTuple
            ul
                li 익명 튜플 : 멤버의 기본 이름은 Item1, Item2, ...
                +asCode('cs') var unnamed = ("one", "two");
                li 명명 튜플 : 컴파일하면 멤버명은 Item*으로 변경된다
                +asCode('cs') var named = (first: "one", second: "two");
                li 튜플 프로젝션 이니셜라이저 : 변수명을 자동으로 요소 이름으로 사용
                +asCode('cs') var accumulation = (count, sum);
                li Since C# 7.3 ==, != 연산자 지원(short-circuit)
                ul
                    li Nullable인 튜플이나 멤버에 대해 자동으로 변환을 수행한다
                    +asCode('cs').
                        var left = (a: 5, b: 10);
                        var right = (a: 5, b: 10);
                        (int a, int b)? nullableTuple = right;
                        Console.WriteLine(left == nullableTuple); // true
                    +asCode('cs').
                        var left = (a: 5, b: 10);
                        (int? a, int? b) nullableMembers = (5, 10);
                        Console.WriteLine(left == nullableMembers); // true
                    li 튜플 멤버에 대한 암시적 변환을 수행한다
                    +asCode('cs').
                        (long a, int b) longFirst = (5, 10);
                        (int a, long b) longSecond = (5, 10);
                        Console.WriteLine(longFirst == longSecond); // true
                li 메서드 튜플 반환
                +asCode('cs').
                    static (int Count, double Sum, double SumOfSquares) ComputeSumAndSumOfSquares(IEnumerable&lt;double> sequence) { }
                    static (int, double, double) ComputeSumAndSumOfSquares(IEnumerable&lt;double> sequence) { }
                    (int count, double sum, double sumOfSquares) = ComputeSumAndSumOfSquares(sequence);
                    (int count, var sum, var sumOfSquares) = ComputeSumAndSumOfSquares(sequence);
                    var (count, sum, sumOfSquares) = ComputeSumAndSumOfSquares(sequence);
                    var result = ComputeSumAndSumOfSquares(sequence);
                li 메서드 튜플 매개변수
                +asCode('cs').
                    public void Print((int Count, double Sum, double SumOfSquares) data) { }
                    public void Print((int, double, double) data) { }
                li out 매개변수 튜플
                +asCode('cs').
                    var dict = new Dictionary&lt;int, (int, string)>();
                    dict.TryGetValue(2, out (int num, string place) pair);
                li 튜플 분해
                +asCode('cs').
                    public class Rectangle
                    {
                        public int X { get; set; }
                        public int Y { get; set; }
                        public int Width { get; set; }
                        public int Height { get; set; }
                        public void Deconstruct(out int x, out int y, out int width, out int height)
                            => (x, y, width, height) = (X, Y, Width, Height);
                    }
                    // 또는 다른 형식에 대한 확장 메서드를 작성하여 분해를 지원할 수 있다
                    public static void Deconstruct(this Rectangle rect, out int x, out int y, out int width, out int height)
                        => (x, y, width, height) = (rect.X, rect.Y, rect.Width, rect.Height);
                    var rect = new Rectangle(1, 2, 3, 4);
                    var (_, _, w, h) = rect;

        h2 연산자
        ul
            li.marker await : 피연산자가 나타내는 비동기 작업이 완료될 때까지 바깥쪽 비동기 메서드의 평가를 일시 중단
            li.marker default(Type) : 타입에 대한 기본값/인스턴스 반환한다
            p Since C# 7.1 : default 리터럴로 기본값을 표현할 수 있다
            li.marker nameof(Identifier) : 식별자 문자열 반환
            li.marker
                |Null 조건부 연산자 ?. 및 ?[]
                +codeBtn('/Repositories/VisualStudio/CSharp/Basic/NullableExample.cs', 'cs')
            ul
                li 피연산자가 null이 아니면 멤버 액세스 ?. 또는 요소 액세스 ?[] 연산을 적용한다
                li null이면 그대로 null 반환
                li null 조건부 연산자를 연쇄적으로 이용할 때, 중간에서 null이 반환된 경우, 나머지는 처리되지 않는다
            li.marker stackalloc : 값 형식의 배열을 스택에 할당한다. fixed 문으로 고정하지 않아도 된다. 메서드 반환 시 자동 삭제된다; 임의 해제 불가
            +asCode('cs').
                int* numbers = stackalloc int[100]; // 포인터는 unsafe 컨텍스트를 사용해야 한다
                Span&lt;int> numbers = stackalloc int[100]; // Since C# 7.2 : Span, ReadOnlySpan에 할당 가능
                var idx = numbers.IndexOfAny(stackalloc[] { 1, 2, 3, 4 }); // Since C# 8.0 : 다른 식 내부에서 stackalloc 사용 가능
            li.marker ?? 연산자 : 좌측 피연산자가 null이면 우측 피연산자를 반환
            li.marker ??= 연산자 Since C# 8.0 : 왼쪽 피연산자가 null로 평가되는 경우, 오른쪽 피연산자의 값을 대입
            li.marker ^ 연산자 Since C# 8.0 : 끝부터 시작하는 인덱스
            +asCode('cs').
                // 시퀀스 길이가 length인 경우, ^1은 마지막 요소, ^length는 첫번째 요소, ^n은 length - n번째 요소
                int[] xs = new[] { 0, 10, 20, 30, 40 };
                int last = xs[^1];
            li.marker 범위 연산자 .. Since C# 8.0 : start..end // [start, end)
            ul
                li a.. == a..^0
                li ..b == 0..b
                li .. == 0..^0
            +asCode('cs').
                Console.WriteLine($"The last word is {words[^1]}");
                var lazyDog = words[^2..^0];
                var allWords = words[..]; // contains "The" through "dog"
                var firstPhrase = words[..4]; // contains "The" through "fox"
                var lastPhrase = words[6..]; // contains "the, "lazy" and "dog"
                Range phrase = 1..4;
                var text = words[phrase];

        h2 한정자
        ul
            li.marker async : 메서드, 람다식, 익명 메서드(delegate 연산자)를 비동기로 지정
            ul
                li void 리턴 : await할 수 없으며, 따라서 예외를 catch할 수 없다
                li Task, Task&lt;TResult> : await 가능
                li Since C# 7.0 : 액세스 가능한 GetAwaiter() 메서드가 있는 모든 형식 리턴 가능
                p System.Threading.Tasks.ValueTask&lt;TResult>은 패키지 System.Threading.Tasks.Extensions가 제공하는 구현
            li.marker private protected : 동일 어셈블리 내의 클래스 및 파생 클래스에서 엑세스 가능
            li.marker ref
            ul
                li ref 매개변수 : 참조 전달. 호출자 스코프의 변수를 그대로 사용하는 효과. 참조가 존재하기 위해 호출 전에 초기화 필요
                +asCode('cs') void Method(ref int refArgument)
                li ref 반환 : 참조 반환
                li ref 지역 변수 : ref 반환값으로 초기화되는 지역 변수
                p Since C# 7.3 : foreach 반복 변수는 ref 또는 ref readonly 지역 변수일 수 있다
                li ref readonly 반환 : 반환된 참조에 대한 쓰기는 비허용
            +asCode('cs').
                public ref decimal GetCurrentPrice() {
                        // ...
                        return ref DecimalArray[0];
                }
                ref decimal estValue = ref GetCurrentPrice();
                ref decimal copyValue = ref estValue;
            li.marker in 매개변수 : 참조 전달. 메서드에서 수정 불가
            li.marker out 매개변수 : 참조 전달. 호출 전에 초기화되지 않아도 되지만, 반환 전에 할당돼야 한다
            +asCode('cs').
                // 선언과 동시에 out 매개변수로 사용 가능
                int.TryParse("12", out var result);
                int.TryParse("21", out var _); // 출력 무시
            li.marker
                |ref struct : 스택에 할당되는 struct. 클래스의 멤버가 될 수 없다. 인터페이스를 구현할 수 없다
                br
                |readonly struct : 모든 필드가 readonly인 struct
            li.marker unsafe : unsafe로 한정한 타입, 메서드, 블록에서는 포인터를 사용할 수 있다
            p 컴파일 시 -unsafe 옵션을 지정해야 한다 : 비주얼 스튜디오는 "프로젝트 속성 - 빌드 - 안전하지 않은 코드 허용"
                br
                |관련 클래스 : System.Runtime.InteropServices.Marshal

        h2 메서드
        ol
            li.marker 매개변수 명시
            +asCode('cs') Divide(a: 10, b: 3, q: out q, r: out r);
            li.marker 선택적 매개변수
            +asCode('cs') Method(int a = 0, int b = 0) {}
            li.marker
                |가변 길이 매개변수 params
                +codeBtn('/Repositories/VisualStudio/CSharp/Basic/ParamsExample.cs', 'cs', '[11, 17]')
            li.marker
                |확장 메서드 : 기존 클래스에 static method 추가됨
                +codeBtn('/Repositories/VisualStudio/CSharp/Basic/ExtensionExample.cs', 'cs')
            li.marker 람다 식 사용 확장 : 생성자, 소멸자, 이벤트 add/remove, 프로퍼티 set, 인덱서 set
            li.marker 메서드 안에 지역 함수 정의 가능
            p static 지역 함수로 선언하면 외부 변수 참조 불가
            li.marker extern 메서드 : 메서드의 body가 없어도 컴파일 되도록 한다
            p 호출할 메서드가 있는 dll을 [DllImport] Attribute로 지정해주면 해당 메서드를 호출한다. http://www.pinvoke.net/
            li.marker Caller information
            +asCode('cs').
                static void Log(string text,
                                [CalleMemberName] string memberName = "",
                                [CallerFilePath] string filePath = "",
                                [CallerLineNumber] int lineNumber = 0) { }
            li Main 메서드에 async 허용

        h2 구문
        ol
            li.marker
                |인덱서 구문 : 하나 이상의 인수로 참조되는 프로퍼티. string, List&lt;T> 등은 인덱서를 구현함
                +codeBtn('/Repositories/VisualStudio/CSharp/Basic/IndexerExample.cs', 'cs')
            li.marker switch case 필터 Since C# 7.0
            +asCode('cs').
                switch(item) {
                    case 100:
                    case null:
                    case DateTime dt:
                    case int i when i > 300:
                    case var i when i.어쩌구저쩌구():
                }
            li.marker 전처리 지시문 #define, #undef, #if, #elif, #else, #endif, ..., #region, #endregion
            li.marker fixed 문 : unsafe 컨텍스트에서, GC가 변수를 재배치하지 않도록 하여 포인터의 유효함을 보장한다
        div
            h3 yield 반복기
            +asCode('cs').
                public static IEnumerable&lt;int> InfiniteSeries(int limit) {
                    var num = 0;
                    if(num &lt;= limit)
                        yield return ++start;
                    yield break;
                }
                public class Galaxies
                {
                    public IEnumerable&lt;Galaxy> NextGalaxy
                    {
                        get
                        {
                            yield return new Galaxy { Name = "Tadpole", MegaLightYears = 400 };
                            yield return new Galaxy { Name = "Pinwheel", MegaLightYears = 25 };
                            yield return new Galaxy { Name = "Milky Way", MegaLightYears = 0 };
                            yield return new Galaxy { Name = "Andromeda", MegaLightYears = 3 };
                        }
                    }
                }

        h2 App.config
        ol
            li supportedRuntime
            p 실행에 필요한 닷넷 버전 지정. 비주얼 스튜디오가 자동으로 추가해주는듯
            +codeBtn('/Repositories/VisualStudio/CSharp/Basic/App.config', 'xml') App.config »
            li appSettings
            +codeBtn('/Repositories/VisualStudio/CSharp/Basic/App.config', 'xml') App.config »
            +codeBtn('/Repositories/VisualStudio/CSharp/Basic/Program.cs', 'cs') Program.cs »

        h2 디버그 모드
        ol
            li 전처리 상수 #if DEBUG ... #endif
            li [Conditional("DEBUG")] 적용된 클래스, 메서드는 릴리스 빌드 시 포함되지 않는다
            li System.Diagnostics.Debug.WriteLine() : 디버그 출력

        h2 Reflection 리플렉션
        ul
            li AppDomain → Assembly ← Module ← Type
            p AppDomain : EXE 프로세스 내에서 CLR에 의해 구현된 격리 공간. 최초 실행 시 기본적으로 1개 생성(AppDomain.CurrentDomain).
            p static 멤버들은 AppDomain 안에서 유일하다. 프로세스의 여러 AppDomain에서 동일한 클래스를 로드했다면 static 멤버들은 각 도메인마다 하나씩 존재
            +asCode('cs').
                var appDomain = AppDomain.CreateDomain("MyDomain");
                ObjectHandle handle = appDomain.CreateInstanceFrom(dllPath, "Namespace.ClassName");
                ...
                AppDomain.Unload(appDomain);
            li Object.getType() or typeof 연산자
            li Type :: GetConstructors(), GetEvents(), GetFields(), GetMethods(), ...
            li 동적 생성 : System.Activator.CreateInstance(Type);
            li 동적 타입 정의 : System.Reflection.Emit
            ol
                li System.AppDomain.DefineDynamicAssembly()로 AssemblyBuilder 객체 획득
                li AssemblyBuilder.DefineDynamicModule()로 ModuleBuilder 획득
                li ModuleBuilder.DefineType()으로 클래스 생성(TypeBuilder)
                li TypeBuilder.DefineMethod()로 MethodBuilder 획득
                li MethodBuilder.GetILGenerator()로 ILGenerator 객체 획득
                li ILGenerator.Emit()으로 메서드 내용 추가
                li TypeBuilder.CrateType()으로 인스턴스 생성 가능

        h2 재귀 패턴 매칭 Since C# 8.0
        +asCode('cs').
            int? x = null;
            if (x is int n1)
                Console.WriteLine(n1);
            else
                Console.WriteLine("Not a int");
            x = 3;
            if (x is int n2)
                Console.WriteLine(n2);
        +asCode('cs').
            var (a, b) = (1, 2);
            switch(a, b)
            {
                case (0, _):
                    Console.WriteLine("a is 0");
                    break;
                case (1, _):
                    Console.WriteLine("a is 1");
                    break;
            }
        +asCode('cs').
            public static bool IsComplete(int n) =>
                n switch
                {
                    6 => true,
                    28 => true,
                    496 => true,
                    8128 => true,
                    33550336 => true,
                    _ => false
                };
        +asCode('cs').
            public static bool IsComplete(int n) =>
                n switch
                {
                    int x when new int[] { 6, 28, 496, 8128, 33550336 }.Contains(x) => true,
                    _ => false
                };
        +asCode('cs').
            var newState = (GetState(), action, hasKey) switch {
                (DoorState.Closed, Action.Open, _) => DoorState.Opened,
                (DoorState.Opened, Action.Close, _) => DoorState.Closed,
                (DoorState.Closed, Action.Lock, true) => DoorState.Locked,
                (DoorState.Locked, Action.Unlock, true) => DoorState.Closed,
                (var state, _, _) => state };
        +asCode('cs').
            var msg = "Hello";
            if (msg is string { Length: 5 } five)
                Console.WriteLine($"Right. {msg} is a 5 length string");
        +asCode('cs').
            public static decimal ComputeSalesTax(Address location, decimal salePrice) =>
                location switch {
                    { State: "WA" } => salePrice * 0.06M,
                    { State: "MI" } => salePrice * 0.05M,
                    _ => 0M
                };
        +asCode('cs').
            static Quadrant GetQuadrant(Point point) => point switch {
                (0, 0) => Quadrant.Origin,
                    var (x, y) when x > 0 && y > 0 => Quadrant.One,
                    var (x, y) when x &lt; 0 && y > 0 => Quadrant.Two,
                    var (x, y) when x &lt; 0 && y &lt; 0 => Quadrant.Three,
                    var (x, y) when x > 0 && y &lt; 0 => Quadrant.Four,
                    var (_, _) => Quadrant.OnBorder,
                    _ => Quadrant.Unknown
                };

    h1: +asA('https://devblogs.microsoft.com/dotnet/c-9-0-on-the-record/', 'C# 9.0')
    div
        h2 Init-only properties
        p 초기화 이후엔 프로퍼티에 할당 불가
        +asCode('C#').
            public class Person
            {
                public string? FirstName { get; init; }
                public string? LastName { get; init; }
            }

        h2 Init accessors and readonly fields
        +asCode('C#').
            public class Person
            {
                private readonly string name;

                public string Name
                {
                    get => name;
                    init => name = (value ?? "Anonymous");
                }
            }

        h2 Records
        ul
            li class 키워드 대신 record 키워드로 선언하는 경우, 유사 값-타입이 된다
            li Equals 메서드에서 값을 기반으로 비교를 수행한다
            li 다른 record를 상속할 수 있다
            li Positional records
            p Init-only properties, 생성자, deconstructor를 자동으로 생성한다
            +asCode('C#').
                public record Person(string FirstName, string LastName);

                var person = new Person("Donggi", "Kim");
                var (firstName, lastName) = person;

                // 상속
                public record Student(string FirstName, string LastName, int ID) : Person(FirstName, LastName);

        h2 Top-level programs
        p 단일 파일 프로그램에 한해, Main() 정의없이 즉시 본문 작성 가능. await 가능
        +asCode('C#').
            using System;

            Console.WriteLine("Hello World");

        h2 With-expressions
        p 변경 불가능한 데이터 인스턴스의 일부만 변경한 복제본 생성에 사용
        +asCode('C#').
            var newPerson = person with { LastName = "AI" };

        h2 Target-typed new expressions
        +asCode('C#').
            Point[] ps = { new (1, 2), new (3, 4) };

        h2 Covariant returns
        p 메서드 상속 시 리턴 타입을 더욱 좁히는 것이 허용된다
        +asCode('C#').
            class Tiger : Animal
            {
                public override Meat GetFood() => ...;
            }

    h1 .NET 정규표현식
    ul
        p Java와 동일한 부분은 생략
        li \nn 또는 \nnn : 8진수 ASCII
        li \w : \p{L} | \p{Mn} | \p{Nd} | \p{Pc}
        li \Z : \z | (?=\n)
        li (?&lt;name>X) == (?'name'X)
        ul
            li Named group
            li \k'name'역참조 가능. replace에서 ${name}참조 가능, GroupCollection의 인덱서로 참조 가능
            li 그룹 오버로딩 가능 : (?&lt;1>a)(?&lt;1>\1b) // 스택처럼 정의가 쌓이며 '-name'으로 가장 최근 정의 삭제 가능
        li.marker 균형 조정 그룹; Balancing group
        ul
            li (?&lt;name1-name2>X) == (?'name1-name2'X)
            p name1은 현재 그룹(Optional)이고, name2는 이전에 정의된 그룹. 균형 조정 그룹은 마지막(백트래킹) name2 정의를 삭제하고, name1에 name2와 name1 사이 간격을 저장한다
            +asCode('cs').
                var html = "&lt;html>&lt;body>Hello&lt;p>World&lt;/p>olleH&lt;/body>&lt;/html>Plain Text&lt;script>console.log('hello world');&lt;/script>Plain Text&lt;yes>Text&lt;/no>";
                Console.WriteLine($"All text : {html}");
                foreach (Match match in Regex.Matches(html, @"&lt;(?'tag'\w+)>(.(?&lt;!&lt;/\k&lt;tag>>))*(?'-tag'&lt;/\k&lt;tag>>)", RegexOptions.IgnoreCase))
                    Console.WriteLine($"HTML part : {match.Groups[0]}");
                // All text : &lt;html>&lt;body>Hello&lt;p>World&lt;/p>olleH&lt;/body>&lt;/html>Plain Text&lt;script>console.log('hello world');&lt;/script>Plain Text&lt;yes>Text&lt;/no>
                // HTML part : &lt;html>&lt;body>Hello&lt;p>World&lt;/p>olleH&lt;/body>&lt;/html>
                // HTML part : &lt;script>console.log('hello world');&lt;/script>
        li 옵션
        ul
            li (?imnsx-imnsx:X) // X 내에 옵션 적용/비적용. 이 자체는 캡처링 그룹이 아님
            li (?imnsx-imnsx) // 이후 식에 옵션 적용/비적용
            li System.Text.RegularExpressions.RegexOptions // Regex 생성자 또는 정적 메서드에 전체 옵션 지정
            table.no-sort
                tr
                    td IgnoreCase
                    td i
                    td 대소문자 구별X
                tr
                    td Multiline
                    td m
                    td ^, $이 \n에서도 동작
                tr
                    td ExplicitCapture
                    td n
                    td 명명된 캡처링 그룹만 유효
                tr
                    td Singleline
                    td s
                    td .이 \n포함
                tr
                    td IgnorePatternWhitespace
                    td x
                    td 이스케이프되지 않은 공백을 패턴에서 제거하고 주석을 #으로 표시 가능
                tr
                    td Compiled
                    td
                    td 어셈블리로 컴파일
                tr
                    td RightToLeft
                    td
                    td 우→좌 검색
                tr
                    td ECMAScript
                    td
                    td
                tr
                    td CultureInvariant
                    td
                    td
                tr
                    td None
                    td
                    td 옵션 없음 명시
        li (?>X) : Non-backtracking
        li.marker Replace 구문
        ul
            li $n, ${name} : 캡처링 그룹
            li $& : 전체 매칭 문자열
            li $` : 매칭 문자열 앞부분
            li $' : 매칭 문자열 뒷부분
            li $+ : 마지막 캡처링 그룹
            li $_ : 전체 입력 문자열
        li 인라인 주석 : (?#comment)
    details
        summary.marker 지원 Unicode class : \p{name} ↔ \P{name}
        table.no-sort
            tr
                th Category
                th Description
            tr
                td Lu
                td Letter, Uppercase
            tr
                td Ll
                td Letter, Lowercase
            tr
                td Lt
                td Letter, Titlecase
            tr
                td Lm
                td Letter, Modifier
            tr
                td Lo
                td Letter, Other
            tr
                td L
                td Lu + Ll + Lt + Lm + Lo
            tr
                td Mn
                td Mark, Nonspacing
            tr
                td Mc
                td Mark, Spacing Combining
            tr
                td Me
                td Mark, Enclosing
            tr
                td M
                td Mn + Mc + Me
            tr
                td Nd
                td Number, Decimal Digit
            tr
                td Nl
                td Number, Letter
            tr
                td No
                td Number, Other
            tr
                td N
                td Nd + Nl + No
            tr
                td Pc
                td Punctuation, Connector
            tr
                td Pd
                td Punctuation, Dash
            tr
                td Ps
                td Punctuation, Start[Open]
            tr
                td Pe
                td Punctuation, End[Close]
            tr
                td Pi
                td Punctuation, Initial quote
            tr
                td Pf
                td Punctuation, Final quote
            tr
                td Po
                td Punctuation, Other
            tr
                td P
                td Pc + Pd + Ps + Pe + Pi + Pf + Po
            tr
                td Sm
                td Symbol, Math
            tr
                td Sc
                td Symbol, Currency
            tr
                td Sk
                td Symbol, Modifier
            tr
                td So
                td Symbol, Other
            tr
                td S
                td Sm + Sc + Sk + So
            tr
                td Zs
                td Separator, Space
            tr
                td Zl
                td Separator, Line
            tr
                td Zp
                td Separator, Paragraph
            tr
                td Z
                td Zs + Zl + Zp
            tr
                td Cc
                td Other, Control
            tr
                td Cf
                td Other, Format
            tr
                td Cs
                td Other, Surrogate
            tr
                td Co
                td Other, Private Use
            tr
                td Cn
                td Other, Not Assigned
            tr
                td C
                td Cc + Cf + Cs + Co + Cn
        table.no-sort
            tr
                th Code point range
                th Block name
            tr
                td 0000 - 007F
                td IsBasicLatin
            tr
                td 0080 - 00FF
                td IsLatin-1Supplement
            tr
                td 0100 - 017F
                td IsLatinExtended-A
            tr
                td 0180 - 024F
                td IsLatinExtended-B
            tr
                td 0250 - 02AF
                td IsIPAExtensions
            tr
                td 02B0 - 02FF
                td IsSpacingModifierLetters
            tr
                td 0300 - 036F
                td IsCombiningDiacriticalMarks
            tr
                td 0370 - 03FF
                td IsGreek or IsGreekandCoptic
            tr
                td 0400 - 04FF
                td IsCyrillic
            tr
                td 0500 - 052F
                td IsCyrillicSupplement
            tr
                td 0530 - 058F
                td IsArmenian
            tr
                td 0590 - 05FF
                td IsHebrew
            tr
                td 0600 - 06FF
                td IsArabic
            tr
                td 0700 - 074F
                td IsSyriac
            tr
                td 0780 - 07BF
                td IsThaana
            tr
                td 0900 - 097F
                td IsDevanagari
            tr
                td 0980 - 09FF
                td IsBengali
            tr
                td 0A00 - 0A7F
                td IsGurmukhi
            tr
                td 0A80 - 0AFF
                td IsGujarati
            tr
                td 0B00 - 0B7F
                td IsOriya
            tr
                td 0B80 - 0BFF
                td IsTamil
            tr
                td 0C00 - 0C7F
                td IsTelugu
            tr
                td 0C80 - 0CFF
                td IsKannada
            tr
                td 0D00 - 0D7F
                td IsMalayalam
            tr
                td 0D80 - 0DFF
                td IsSinhala
            tr
                td 0E00 - 0E7F
                td IsThai
            tr
                td 0E80 - 0EFF
                td IsLao
            tr
                td 0F00 - 0FFF
                td IsTibetan
            tr
                td 1000 - 109F
                td IsMyanmar
            tr
                td 10A0 - 10FF
                td IsGeorgian
            tr
                td 1100 - 11FF
                td IsHangulJamo
            tr
                td 1200 - 137F
                td IsEthiopic
            tr
                td 13A0 - 13FF
                td IsCherokee
            tr
                td 1400 - 167F
                td IsUnifiedCanadianAboriginalSyllabics
            tr
                td 1680 - 169F
                td IsOgham
            tr
                td 16A0 - 16FF
                td IsRunic
            tr
                td 1700 - 171F
                td IsTagalog
            tr
                td 1720 - 173F
                td IsHanunoo
            tr
                td 1740 - 175F
                td IsBuhid
            tr
                td 1760 - 177F
                td IsTagbanwa
            tr
                td 1780 - 17FF
                td IsKhmer
            tr
                td 1800 - 18AF
                td IsMongolian
            tr
                td 1900 - 194F
                td IsLimbu
            tr
                td 1950 - 197F
                td IsTaiLe
            tr
                td 19E0 - 19FF
                td IsKhmerSymbols
            tr
                td 1D00 - 1D7F
                td IsPhoneticExtensions
            tr
                td 1E00 - 1EFF
                td IsLatinExtendedAdditional
            tr
                td 1F00 - 1FFF
                td IsGreekExtended
            tr
                td 2000 - 206F
                td IsGeneralPunctuation
            tr
                td 2070 - 209F
                td IsSuperscriptsandSubscripts
            tr
                td 20A0 - 20CF
                td IsCurrencySymbols
            tr
                td 20D0 - 20FF
                td IsCombiningDiacriticalMarksforSymbols or IsCombiningMarksforSymbols
            tr
                td 2100 - 214F
                td IsLetterlikeSymbols
            tr
                td 2150 - 218F
                td IsNumberForms
            tr
                td 2190 - 21FF
                td IsArrows
            tr
                td 2200 - 22FF
                td IsMathematicalOperators
            tr
                td 2300 - 23FF
                td IsMiscellaneousTechnical
            tr
                td 2400 - 243F
                td IsControlPictures
            tr
                td 2440 - 245F
                td IsOpticalCharacterRecognition
            tr
                td 2460 - 24FF
                td IsEnclosedAlphanumerics
            tr
                td 2500 - 257F
                td IsBoxDrawing
            tr
                td 2580 - 259F
                td IsBlockElements
            tr
                td 25A0 - 25FF
                td IsGeometricShapes
            tr
                td 2600 - 26FF
                td IsMiscellaneousSymbols
            tr
                td 2700 - 27BF
                td IsDingbats
            tr
                td 27C0 - 27EF
                td IsMiscellaneousMathematicalSymbols-A
            tr
                td 27F0 - 27FF
                td IsSupplementalArrows-A
            tr
                td 2800 - 28FF
                td IsBraillePatterns
            tr
                td 2900 - 297F
                td IsSupplementalArrows-B
            tr
                td 2980 - 29FF
                td IsMiscellaneousMathematicalSymbols-B
            tr
                td 2A00 - 2AFF
                td IsSupplementalMathematicalOperators
            tr
                td 2B00 - 2BFF
                td IsMiscellaneousSymbolsandArrows
            tr
                td 2E80 - 2EFF
                td IsCJKRadicalsSupplement
            tr
                td 2F00 - 2FDF
                td IsKangxiRadicals
            tr
                td 2FF0 - 2FFF
                td IsIdeographicDescriptionCharacters
            tr
                td 3000 - 303F
                td IsCJKSymbolsandPunctuation
            tr
                td 3040 - 309F
                td IsHiragana
            tr
                td 30A0 - 30FF
                td IsKatakana
            tr
                td 3100 - 312F
                td IsBopomofo
            tr
                td 3130 - 318F
                td IsHangulCompatibilityJamo
            tr
                td 3190 - 319F
                td IsKanbun
            tr
                td 31A0 - 31BF
                td IsBopomofoExtended
            tr
                td 31F0 - 31FF
                td IsKatakanaPhoneticExtensions
            tr
                td 3200 - 32FF
                td IsEnclosedCJKLettersandMonths
            tr
                td 3300 - 33FF
                td IsCJKCompatibility
            tr
                td 3400 - 4DBF
                td IsCJKUnifiedIdeographsExtensionA
            tr
                td 4DC0 - 4DFF
                td IsYijingHexagramSymbols
            tr
                td 4E00 - 9FFF
                td IsCJKUnifiedIdeographs
            tr
                td A000 - A48F
                td IsYiSyllables
            tr
                td A490 - A4CF
                td IsYiRadicals
            tr
                td AC00 - D7AF
                td IsHangulSyllables
            tr
                td D800 - DB7F
                td IsHighSurrogates
            tr
                td DB80 - DBFF
                td IsHighPrivateUseSurrogates
            tr
                td DC00 - DFFF
                td IsLowSurrogates
            tr
                td E000 - F8FF
                td IsPrivateUse or IsPrivateUseAreaIsPrivateUse or IsPrivateUseArea
            tr
                td F900 - FAFF
                td IsCJKCompatibilityIdeographs
            tr
                td FB00 - FB4F
                td IsAlphabeticPresentationForms
            tr
                td FB50 - FDFF
                td IsArabicPresentationForms-A
            tr
                td FE00 - FE0F
                td IsVariationSelectors
            tr
                td FE20 - FE2F
                td IsCombiningHalfMarks
            tr
                td FE30 - FE4F
                td IsCJKCompatibilityForms
            tr
                td FE50 - FE6F
                td IsSmallFormVariants
            tr
                td FE70 - FEFF
                td IsArabicPresentationForms-B
            tr
                td FF00 - FFEF
                td IsHalfwidthandFullwidthForms
            tr
                td FFF0 - FFFF
                td IsSpecials
