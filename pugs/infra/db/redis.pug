include ../../../source/skeleton.pug
+post('Redis', 'Redis', 'Redis 정리')
    h1 참고자료
    ul
        li: +asA('https://redis.io/documentation', '공식 문서')
        li: +asA('http://redisgate.kr/', '레디스 엔터프라이즈 버전')
        li: +asA('https://github.com/redis-essentials/book', 'Redis Essentials')

    h1 Redis
    ul
        li 인메모리 저장소 + 물리 장치 백업 지원
        li 메시지 브로커 기능 보유 : Pub/Sub
        li BSD 라이선스
    div
        h2 redis-server/
            +asA('https://redis.io/topics/rediscli', 'redis-cli')
        ol
            li 서버 실행
            +asCode('shell') $ redis-server --port 27017
            li 서버 접속
            +asCode('shell') $ redis-cli -p 27017
            li help
            +asCode('shell', 'redis-cli').
                > help
                > help @&lt;group>      # Redis 명령어들은 연관성에 따라 그룹에 묶여있다
                > help &lt;command>
            li 여러 키 삭제
            +asCode('shell') $ redis-cli --scan --pattern '*' | xargs redis-cli DEL

        h2 Data type
        ol
            li Binary-safe string : 임의 이진 문자열(최대 512MB)
            li List : 기본적으로 삽입 순으로 유지되는 string 연결 리스트(최대 길이 2^32 - 1)
            li Set : 순서 없는 string 집합(최대 크기 2^32 - 1)
            li Sorted set : 각 string 원소는 score라 불리는 실수 가중치(정렬키)를 가짐
            li Hash : field -&gt; value 매핑(최대 크기 2^32 - 1). 각 field, value는 모두 string
            li Bit array : string을 비트열로 다룰 수 있다
            li HyperLogLog : 집합 크기 추정에 이용되는 확률 자료형
            li Stream : append만 가능한 유사 맵

    h1: +asA('https://redis.io/commands')
    p Redis 명령어들은 연관성에 따라 하나의 그룹에 속해있다
    div
        h2 Generic
        div
            +pos('COPY')
            h3 COPY since 6.2.0
            +asCode('text', 'syntax') COPY source destination [DB destination-db-index] [REPLACE]
            ul
                li source 키의 값을 destination 키로 복사
                li 복사됐으면 1, 아니면 0 반환
                li DB : 내부 논리적 DB index
                li REPLACE : 덮어쓰기

            +pos('DEL')
            h3 DEL
            +asCode('text', 'syntax') DEL key [key ...]
            p 키를 삭제하고, 삭제된 개수 반환

            +pos('DUMP')
            h3 DUMP
            +asCode('text', 'syntax') DUMP key
            ul
                li 값을 Redis 포맷(내부 RDB 버전에 따라 인코딩 방식 결정됨)으로 직렬화하여 반환
                p expire time은 포함되지 않음
                li
                    +goto('RESTORE')
                    |로 역직렬화 가능
                +asCode('shell', 'redis-cli').
                    127.0.0.1:6379> set key1 'Hello World!'
                    OK
                    127.0.0.1:6379> dump key1
                    "\x00\x0cHello World!\t\x00\xda\xe7D\xea/\xa2\xe6\xc7"
                    127.0.0.1:6379> restore key2 0 "\x00\x0cHello World!\t\x00\xda\xe7D\xea/\xa2\xe6\xc7"
                    OK
                    127.0.0.1:6379> get key2
                    "Hello World!"

            +pos('EXISTS')
            h3 EXISTS
            +asCode('text', 'syntax') EXISTS key [key ...]
            p 존재하는 키의 개수 반환. 중복된 키는 중복 카운트 됨에 유의

            +pos('EXPIRE')
            h3 EXPIRE
            +asCode('text', 'syntax') EXPIRE key seconds [NX|XX|GT|LT]
            ul
                li 지정 시간(초) 후 키 삭제
                li 설정됐으면 1, 아니면 0반환
                li 값을 덮어쓰지 않는 명령(INCR, LPUSH, HSET)과 RENAME은 ttl 정보에 영향을 미치지 않음에 유의
                li NX : No expiry; 키에 ttl이 설정되지 않은 경우에만 설정
                li XX : Exists expiry; 키에 ttl이 설정된 경우에만 설정
                li GT : Greater than; 기존 ttl보다 큰 경우에만 설정
                li LT : Less than; 기존 ttl보다 작은 경우에만 설정
                li ttl이 없는 경우 GT, LT에서 무한으로 간주

            +pos('PEXPIRE')
            h3 PEXPIRE
            +asCode('text', 'syntax') PEXPIRE key milliseconds [NX|XX|GT|LT]
            p 밀리초 단위 EXPIRE

            +pos('EXPIREAT')
            h3 EXPIREAT
            +asCode('text', 'syntax') EXPIREAT key unix-timestamp-seconds [NX|XX|GT|LT]
            ul
                li 지정 시각 이후 키 삭제
                li 설정됐으면 1, 아니면 0반환
                li 값을 덮어쓰지 않는 명령(INCR, LPUSH, HSET)과 RENAME은 ttl 정보에 영향을 미치지 않음에 유의
                li NX : No expiry; 키에 ttl이 설정되지 않은 경우에만 설정
                li XX : Exists expiry; 키에 ttl이 설정된 경우에만 설정
                li GT : Greater than; 기존 ttl보다 큰 경우에만 설정
                li LT : Less than; 기존 ttl보다 작은 경우에만 설정
                li ttl이 없는 경우 GT, LT에서 무한으로 간주

            +pos('PEXPIREAT')
            h3 PEXPIREAT
            +asCode('text', 'syntax') PEXPIREAT key unix-time-milliseconds [NX|XX|GT|LT]
            p 밀리초 단위 EXPIREAT

            +pos('EXPIRETIME')
            h3 EXPIRETIME Since 7.0.0
            +asCode('text', 'syntax') EXPIRETIME key
            ul
                li 키가 만료되는 시각 - Unix timestamp in seconds을 반환한다
                li -1 : ttl 설정 안 된 경우
                li -2 : 키가 존재하지 않는 경우

            +pos('PEXPIRETIME')
            h3 PEXPIRETIME Since 7.0.0
            +asCode('text', 'syntax') PEXPIRETIME key
            p 밀리초 단위 EXPIRETIME

            +pos('KEYS')
            h3 KEYS
            +asCode('text', 'syntax') KEYS pattern
            ul
                li
                    span.hover-content(template-id='glob-style-pattern') pattern(GLOB style)
                    |에 일치하는 키 배열 반환
                li KEYS 명령은 사용중인 저장소가 클수록 큰 성능 저하를 발생하므로 각별히 주의

            +pos('MIGRATE')
            h3 MIGRATE
            +asCode('text', 'syntax') MIGRATE host port key|"" destination-db timeout-ms [COPY] [REPLACE] [AUTH password] [AUTH2 username password] [KEYS key [key ...]]
            ul
                li 데이터를 다른 서버로 옮긴다. DUMP + DEL + RESTORE의 조합
                li timeout-ms : MIGRATE 명령이 제한시간 안에 수행함을 의미하는 것이 아니라, 어느 단계에서든 해당 지연 시간 이상 블록되는 일이 없음을 보장
                p 시간초과가 발생하더라도 목적지에 복사된 상태일 수 있음에 유의. 반면 그 외의 에러 상황에서는 목적지에 복사되지 않은 상태임을 보장
                li COPY : 원본을 지우지 않는다
                li KEYS : 여러 개를 이동할 때, 앞부분 key를 ""로 하고 사용
                li AUTH, AUTH2 모두 목적지 서버 연결 정보로써, 필요한 것 하나만 사용

            +pos('MOVE')
            h3 MOVE
            +asCode('text', 'syntax') MOVE key db-index
            ul
                li 키를 다른 DB로 옮긴다. 이미 목적지에 key가 존재하면 옮기지 않는다 -- 이 성질을 이용하여 락을 구현할 수도 있다
                li 옮겼으면 1, 그 외엔 0 반환

            +pos('OBJECT')
            h3 OBJECT
            +asCode('text', 'syntax') OBJECT subcommand arg ... arg
            ul
                li 키에 대한 정보 획득
                li OBJECT ENCODING key : 상세 데이터 타입 반환
                li OBJECT FREQ key : 참조 빈도 반환. 메모리 정책에 따라 추적 여부가 결정됨
                li OBJECT IDLETIME key : 참조하지 않은 시간(초) 반환
                li OBJECT REFCOUNT key : 키가 참조하는 값의 개수 반환

            +pos('PERSIST')
            h3 PERSIST
            +asCode('text', 'syntax') PERSIST key
            ul
                li ttl 삭제
                li 삭제했으면 1, 아니면 0 반환

            +pos('RANDOMKEY')
            h3 RANDOMKEY
            +asCode('text', 'syntax') RANDOMKEY
            p 현재 DB에서 임의 키 반환. 없으면 nil

            +pos('RENAME')
            h3 RENAME
            +asCode('text', 'syntax') RENAME key newkey
            ul
                li key가 존재하지 않는 경우 에러 반환
                li 기존 newkey는 덮어씌어진다(암시적 DEL 수행)
                li 기존 ttl 정보는 그대로 옮겨진다
                li 클러스터 모드에서, key와 newkey는 같은 해시 슬롯에 존재해야
                li 성공 시 "OK" 반환

            +pos('RENAMENX')
            h3 RENAMENX
            +asCode('text', 'syntax') RENAMENX key newkey
            ul
                li newkey가 존재하지 않는 경우만 RENAME
                li 성공했으면 1, 아니면 0 반환

            +pos('RESTORE')
            h3 RESTORE
            +asCode('text', 'syntax') RESTORE key ttl-milliseconds serialized-value [REPLACE] [ABSTTL] [IDLETIME seconds] [FREQ frequency]
            ul
                li Redis 포맷 문자열로부터 역직렬화
                li ttl : 0이면 무기한
                li ABSTTL : 설정한 경우, ttl을 Unix timestamp로 해석한다
                li IDLETIME, FREQ : OBJECT 명령과 관계된 초기값 설정

            +pos('SCAN')
            h3 SCAN
            +asCode('text', 'syntax') SCAN cursor [MATCH pattern] [COUNT count] [TYPE type]
            ul
                li cursor가 가리키는 지점부터 약 count개의 키 중,
                    span.hover-content(template-id='glob-style-pattern') pattern(GLOB style)
                    |에 일치하는 목록을 반환한다
                li COUNT : 유저가 원하는 페이지 크기에 대한 힌트로 사용된다(기본값 10) -- 반드시 count 개가 반환되는 것이 아님. 또, 연속 순회 시 count는 자유롭게 변경해도 된다
                li cursor : 0을 지정하여 순회 시작. 응답 첫 번째 원소로 0이 아닌 cursor가 반환되고, 이를 이용해 나머지를 순회할 수 있다
                +asCode('shell', 'redis-cli').
                    127.0.0.1:6379> keys *
                    1) "key2"
                    2) "key"
                    3) "hello"
                    127.0.0.1:6379> scan 0 count 1
                    1) "2"
                    2) 1) "key2"
                       2) "key"
                    127.0.0.1:6379> scan 2 count 1
                    1) "1"
                    2) 1) "hello"
                    127.0.0.1:6379> scan 1 count 1
                    1) "0"
                    2) (empty array)
                li MATCH : 패턴 매칭은 페이지가 구성된 후 클라이언트에 응답하기 직전에 수행되므로, 순회가 종료되지 않더라도 키 목록이 비어있을 수 있다
                li TYPE : 값이 type에 해당하는 키만 검색.
                    +goto('TYPE') 명령이 반환하는 값과 일치해야 한다
                li 서버는 순회와 관련하여 상태를 저장하지 않으므로, 동시 순회 클라이언트 개수에 제한이 없고, 중간에 언제든 순회를 그만둬도 된다
                li 순회의 종료를 판단하는 기준 : 지정 cursor로부터 남은 키의 개수가 count보다 작은가?
                li 일부 복합 타입들은 특정 크기를 초과하지 않는 한 해시 테이블이 아닌 하나의 값으로 저장되므로, count보다 많은 목록이 응답될 수도 있다

            +pos('SORT')
            h3 SORT
            +asCode('text', 'syntax') SORT key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern ...]] [ASC|DESC] [ALPHA] [STORE destination]
            ul
                li list, set, sorted set 데이터를 정렬하여 획득 or 저장한다
                li 기본적으로 값의 두배 정밀도 실수 표현을 정렬 키로 한다
                li ALPHA : 문자열 정렬을 수행하고 싶은 경우
                li offset : 0부터 시작
                li BY pattern : 정렬 키 지정
                li GET # : 원소 자체도 반환
                li GET pattern : 조회 키 지정
                +asCode('shell', 'redis-cli').
                    # 학생 이름 5개 저장
                    127.0.0.1:6379> sadd student-name name5 name1 name2 name3 name4
                    (integer) 5

                    # 점수 저장
                    127.0.0.1:6379> mset name5-score 3 name1-score 10 name2-score 0 name3-score 7
                    OK

                    # 각 학생의 점수 획득(이름순)
                    127.0.0.1:6379> sort student-name get *-score alpha
                    1) "10"
                    2) "0"
                    3) "7"
                    4) (nil)
                    5) "3"

                    # 각 학생의 점수 획득(점수순)
                    127.0.0.1:6379> sort student-name by *-score get *-score desc
                    1) "10"
                    2) "7"
                    3) "3"
                    4) (nil)
                    5) "0"

                    # 원소도 같이 반환
                    127.0.0.1:6379> sort student-name by *-score get # get *-score desc
                    1) "name1"
                    2) "10"
                    3) "name3"
                    4) "7"
                    5) "name5"
                    6) "3"
                    7) "name4"
                    8) (nil)
                    9) "name2"
                    10) "0"
                li 해시 필드에 대하여, 아래와 같이 -> 표기를 이용해 BY, GET 옵션을 사용할 수 있다
                +asCode('text', 'e.g.') SORT mylist BY weight_*->fieldname GET object_*->fieldname

            +pos('SORT_RO')
            h3 SORT_RO Since 7.0.0
            +asCode('text', 'syntax') SORT_RO key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern ...]] [ASC|DESC] [ALPHA]
            p 읽기 전용 SORT : SORT 명령은 STORE 옵션으로 인해 쓰기 명령으로 분류되고, 이로 인해 읽기 전용 복제본에서 마스터 인스턴스로 명령이 항상 리디렉션되었는데, 이를 방지할 목적으로 추가되었다.

            +pos('TOUCH')
            h3 TOUCH
            +asCode('text', 'syntax') TOUCH key [key ...]
            ul
                li 마지막 접근 시각을 현재로 설정
                li 설정한 개수 반환

            +pos('TTL')
            h3 TTL
            +asCode('text', 'syntax') TTL key
            p 남은 유효 시간(초) 반환. 삭제됐으면 -2, ttl 없으면 -1

            +pos('PTTL')
            h3 PTTL
            +asCode('text', 'syntax') PTTL key
            p 밀리초 단위 TTL

            +pos('TYPE')
            h3 TYPE
            +asCode('text', 'syntax') TYPE key
            p 데이터 타입 반환; string, list, set, zset, hash, stream, none

            +pos('UNLINK')
            h3 UNLINK
            +asCode('text', 'syntax') UNLINK key [key ...]
            ul
                li 키 공간에서 키를 삭제한 개수를 반환
                li
                    +goto('DEL')
                    |과 다르게 메모리 해제를 별도 스레드에서 진행(논-블로킹)하기 때문에, 지울 개수가 많을수록 UNLINK가 더 빠르다

            +pos('WAIT')
            h3 WAIT
            +asCode('text', 'syntax') WAIT numreplicas timeout-milliseconds
            ul
                li 이전 모든 write 명령이 numreplicas개의 복제본에 도달하기까지 최대 timeout 밀리초 대기
                li 도달한 복제본 개수 반환

        h2 String
        div
            +pos('APPEND')
            h3 APPEND
            +asCode('text', 'syntax') APPEND key value
            ul
                li 키가 존재하고 값이 문자열이면 append
                li 키가 존재하고 값이 문자열이 아니면 에러
                li 키가 없으면 set
                li 연산 후의 문자열 길이 반환

            +pos('DECR')
            h3 DECR
            +asCode('text', 'syntax') DECR key
            ul
                li 주어진 키의 정수 1 감소 후 반환
                p 키가 없으면 0으로 간주
                li 값이 signed 64bit 범위 밖이면 에러

            +pos('DECRBY')
            h3 DECRBY
            +asCode('text', 'syntax') DECRBY key decrement
            ul
                li 주어진 키의 정수 decrement 감소 후 반환
                p 키가 없으면 0으로 간주
                li 값이 signed 64bit 범위 밖이면 에러

            +pos('GET')
            h3 GET
            +asCode('text', 'syntax') GET key
            ul
                li key가 없으면 nil 반환
                li key의 값이 문자열이면 해당 값 반환
                li 그 외는 에러

            +pos('GETDEL')
            h3 GETDEL
            +asCode('text', 'syntax') GETDEL key
            ul
                li GET 실행 후 DEL(key가 존재하고, 값이 string일 경우) 실행
                li GET 실행 결과 반환

            +pos('GETEX')
            h3 GETEX
            +asCode('text', 'syntax') GETEX key [EX seconds|PX milliseconds|EXAT unix-time-seconds|PXAT unix-time-milliseconds|PERSIST]
            ul
                li GET 실행 후 ttl 변경. GET 실행 결과 반환
                li EX, PX : ttl(상대 시간)
                li EXAT, PXAT : ttl(절대 시각)
                li PERSIST : ttl 제거

            +pos('GETRANGE')
            h3 GETRANGE
            +asCode('text', 'syntax') GETRANGE key start end
            ul
                li key에 대하여, 문자열의 부분 문자열 [start, end] 반환
                li 음수 인덱스 가능. 문자열 길이를 초과하는 범위는 무시

            +pos('GETSET')
            h3 GETSET; Deprecated since 6.2.0
            +asCode('text', 'syntax') GETSET key value
            ul
                li SET 실행 후, 이전 값 반환
                li Since 6.2.0 : SET 명령의 GET 옵션 사용

            +pos('INCR')
            h3 INCR
            +asCode('text', 'syntax') INCR key
            ul
                li 주어진 키의 정수 1 증가 후 반환
                p 키가 없으면 0으로 간주
                li 값이 signed 64bit 범위 밖이면 에러

            +pos('INCRBY')
            h3 INCRBY
            +asCode('text', 'syntax') INCRBY key increment
            ul
                li 주어진 키의 정수 increment 증가 후 반환
                p 키가 없으면 0으로 간주
                li 값이 signed 64bit 범위 밖이면 에러

            +pos('INCRBYFLOAT')
            h3 INCRBYFLOAT
            +asCode('text', 'syntax') INCRBYFLOAT key increment
            ul
                li 주어진 키의 실수 increment(음수 가능) 증가 후 반환
                p 키가 없으면 0으로 간주
                li 값이 double 범위 밖이면 에러

            +pos('LCS')
            h3 LCS Since 6.0.0 or 7.0.0
            +asCode('text', 'syntax').
                # Since 6.0.0
                STRALGO LCS [KEYS ...] [STRINGS ...] [LEN] [IDX] [MINMATCHLEN len] [WITHMATCHLEN]
                # Since 7.0.0
                LCS key1 key2 [LEN] [IDX] [MINMATCHLEN len] [WITHMATCHLEN]
            ul
                li 두 문자열의 LCS(Longest common subsequence)를 구한다
                +asCode('shell', 'redis-cli').
                    127.0.0.1:6379> set key1 humble-bundle
                    OK
                    127.0.0.1:6379> set key2 bundle-humble
                    OK
                    127.0.0.1:6379> stralgo lcs keys key1 key2
                    "ble-ule"
                    127.0.0.1:6379> stralgo lcs strings humble-bundle bundle-humble
                    "ble-ule"
                li LEN : 길이만을 원하는 경우
                li IDX : LCS 각 부분 시퀀스의 [시작, 종료] 위치를 역순으로 반환
                li IDX MINMATCHLEN : LCS 부분 시퀀스 중, 최소 길이를 만족하는 것만 반환
                li IDX WITHMATCHLEN : LCS 각 부분 시퀀스의 길이도 반환
                +asCode('shell', 'redis-cli').
                    127.0.0.1:6379> stralgo lcs strings humble-bundle xbundle-humble idx minmatchlen 2
                    1) "matches"
                    2) 1) 1) 1) (integer) 11
                             2) (integer) 12
                          2) 1) (integer) 12
                             2) (integer) 13
                       2) 1) 1) (integer) 4
                             2) (integer) 6
                          2) 1) (integer) 5
                             2) (integer) 7
                    3) "len"
                    4) (integer) 7

                    // 2) 1) 1) : "humble-bundle"의 "le"
                    // 2) 1) 2) : "xbundle-humble"의 "le"

            +pos('MGET')
            h3 MGET
            +asCode('text', 'syntax') MGET key [key ...]
            p 각 키에 대해 get 하여 배열로 반환
            +asCode('shell', 'redis-cli').
                127.0.0.1:27017> mget k1 k2 not_exists_key
                1) "v1"
                2) "v2"
                3) (nil)

            +pos('MSET')
            h3 MSET
            +asCode('text', 'syntax') MSET key value [key value ...]
            p 원자적으로 주어진 키-값 쌍들을 모두 설정한다

            +pos('MSETNX')
            h3 MSETNX
            +asCode('text', 'syntax') MSETNX key value [key value ...]
            p 모든 키가 신규인 경우 mset 실행하고 1 반환. 그 외엔 0 반환

            +pos('PSETEX')
            h3 PSETEX
            +asCode('text', 'syntax') PSETEX key milliseconds value
            p 밀리초 단위
                +goto('SETEX')

            +pos('SET')
            h3 SET
            +asCode('text', 'syntax') SET key value [EX seconds|PX milliseconds|EXAT unix-time-seconds|PXAT unix-time-milliseconds|KEEPTTL] [NX|XX] [GET]
            ul
                li 원자적으로 key에 대하여 value를 할당한다. 이전에 설정한 값, 유효 기간을 덮어쓴다
                li EX, PX : ttl(상대 시각)
                li EXAT, PXAT : ttl(절대 시각)
                li NX : 신규 키일 때만 설정
                li XX : 중복 키일 때만 설정
                li KEEPTTL : 이전 ttl 유지
                li GET : 이전 값 반환(없으면 nil)

            +pos('SETEX')
            h3 SETEX
            +asCode('text', 'syntax') SETEX key seconds value
            p "SET key value EX seconds"와 동일

            +pos('SETNX')
            h3 SETNX
            +asCode('text', 'syntax') SETNX key value
            ul
                li key가 존재하지 않을 경우에만 value 설정
                li 설정했으면 1, 아니면 0 반환

            +pos('SETRANGE')
            h3 SETRANGE
            +asCode('text', 'syntax') SETRANGE key offset value
            ul
                li key에 대하여, offset(0부터 시작) 위치부터 value의 길이만큼 value로 덮어쓴다
                li offset이 기존 문자열을 초과하는 경우 빈 자리는 \x00으로 채워진다
                li key가 존재하지 않는 경우, 값을 빈 문자열로 간주하고 실행한다
                li 설정 후 문자열 길이를 반환한다
                li
                    +goto('GETRANGE')
                    |와 함께 O(1) 접근 가능한 공유 배열로 이용할 수 있다
            +asCode('shell', 'redis-cli').
                127.0.0.1:27017> set msg hello
                OK
                127.0.0.1:27017> setrange msg 8 hello
                (integer) 13
                127.0.0.1:27017> get msg
                "hello\x00\x00\x00hello"

            +pos('STRLEN')
            h3 STRLEN
            +asCode('text', 'syntax') STRLEN key
            ul
                li 문자열 길이 반환
                li key가 존재하지 않으면 0
                li 값이 문자열이 아니면 에러

        h2 Bitmap
        div
            +pos('BITCOUNT')
            h3 BITCOUNT
            +asCode('text', 'syntax') BITCOUNT key [start end [BYTE|BIT]]
            ul
                li 문자열 내 set bit 개수 반환
                li start, end : 음수를 허용하는 두 인덱스로 표현되는 닫힌 구간 [start, end]으로 탐색 구간 지정 가능
                li BYTE, BIT : 탐색 구간에 사용되는 start, end의 단위 지정

            +pos('BITFIELD')
            h3 BITFIELD
            +asCode('text', 'syntax') BITFIELD key [GET encoding offset] [SET encoding offset value] [INCRBY encoding offset increment] [OVERFLOW WRAP|SAT|FAIL]
            ul
                li 문자열을 비트열로 간주하여 GET, SET, INCRBY 연산들을 수행한다
                p GET 서브 명령 실행 시, 문자열을 벗어난 범위의 비트열은 0으로 간주한다
                li encoding : 부호 있는 64비트, 부호 없는 63비트까지 가능
                p e.g. i5(부호 있는 5비트), u4(부호 없는 4비트)
                li offset : 0부터 시작하는 시작 위치. 정수만 이용하는 경우 bit단위, #를 붙이면 encoding 크기 단위
                li OVERFLOW : WRAP(default, 오버/언더플로우 비트 무시), SAT(오버/언더플로우 시 최대/최소값으로), FAIL(실패, nil 반환)
                p OVERFLOW 이후 등장하는 INCRBY 서브 명령에만 영향을 미침에 유의
                li 반환 : SET(이전 값), GET(현재 값), INCRBY(신규 값)
            +asCode('shell', 'redis-cli').
                127.0.0.1:27017> bitfield time SET u6 #0 11 SET u6 #1 33 SET u6 #2 55 GET u6 #0 GET u6 #1 GET u6 #2 INCRBY u6 #0 1 INCRBY u6 #1 1 INCRBY u6 #2 1
                1) (integer) 0
                2) (integer) 0
                3) (integer) 0
                4) (integer) 11
                5) (integer) 33
                6) (integer) 55
                7) (integer) 12
                8) (integer) 34
                9) (integer) 56

            +pos('BITFIELD_RO')
            h3 BITFIELD_RO Since 6.2.0
            +asCode('text', 'syntax') BITFIELD_RO key GET encoding offset
            p 읽기 전용 복제본에서 마스터로 명령이 리디렉션되는 것을 방지하기 위한 읽기 전용 BITFIELD

            +pos('BITOP')
            h3 BITOP
            +asCode('text', 'syntax') BITOP operation destkey key [key ...]
            p 소스 키들의 값에 대한 AND, OR, XOR, NOT 결과를 destkey에 저장한다
            +asCode('shell', 'redis-cli').
                127.0.0.1:6379> set key1 "humble-bundle"
                OK
                127.0.0.1:6379> set key2 "bundle-humble"
                OK
                127.0.0.1:6379> bitop and key3 key1 key2
                (integer) 13
                127.0.0.1:6379> get key3
                "`ul`le-`ul`le"

            +pos('BITPOS')
            h3 BITPOS
            +asCode('text', 'syntax') BITPOS key bit [start [end [BYTE|BIT]]]
            ul
                li bit와 일치하는 인덱스를 닫힌 구간 [start, end] 사이(음수 인덱스 가능)에서 구한다
                li BYTE, BIT : 탐색 구간에 사용되는 start, end의 단위 지정
                li Set bit을 못찾은 경우 -1 반환
                li 구간 지정 없이 Clear bit을 못찾은 경우 비트열 길이 반환
                p 문자열을 초과하는 부분을 0 비트열로 간주하기 때문
                li 구간 지정했지만 Clear bit을 못찾은 경우 -1 반환
            +asCode('shell', 'redis-cli').
                127.0.0.1:6379> set key "\x00\xff"
                OK
                127.0.0.1:6379> bitpos key 0
                (integer) 0
                127.0.0.1:6379> bitpos key 0 1
                (integer) 16
                127.0.0.1:6379> bitpos key 0 1 1
                (integer) -1
                127.0.0.1:6379> bitpos key 1
                (integer) 8
                127.0.0.1:6379> bitpos key 1 1
                (integer) 8

            +pos('GETBIT')
            h3 GETBIT
            +asCode('text', 'syntax') GETBIT key offset
            p offset(0부터 시작)번째 비트 반환. 문자열을 넘어선 범위는 0으로 간주

            +pos('SETBIT')
            h3 SETBIT
            +asCode('text', 'syntax') SETBIT key offset value
            p offset(0부터 시작)번째 비트를 value(0 | 1)로 변경. 이전 비트값 반환

        h2 List
        p 값은 입력된 순서대로 저장되고, 값이 하나도 없으면 키가 삭제된다
        div
            +pos('BLMOVE')
            h3 BLMOVE Since 6.2.0
            +asCode('text', 'syntax') BLMOVE source destination LEFT|RIGHT LEFT|RIGHT timeout-seconds
            ul
                li
                    +goto('LMOVE')
                    |의 블로킹 버전
                li source 리스트가 비어있는 경우, 최대 timeout만큼 대기한다

            +pos('BLMPOP')
            h3 BLMPOP Since 7.0.0
            +asCode('text', 'syntax') BLMPOP timeout-seconds numkeys key [key ...] LEFT|RIGHT [COUNT count]
            ul
                li
                    +goto('LMPOP')
                    |의 블로킹 버전
                li 모든 리스트가 비어있는 경우, 최대 timeout만큼 대기한다

            +pos('BLPOP')
            h3 BLPOP
            +asCode('text', 'syntax') BLPOP key [key ...] timeout-seconds
            ul
                li
                    +goto('LPOP')
                    |의 블로킹 버전
                p 지정한 리스트들을 순회하여, 최초로 발견된 왼쪽 값 삭제 후 반환
                li 모든 리스트가 비어있는 경우, 최대 timeout만큼 대기
                li BLPOP 경합 시 처리 우선순위에 대해서는 공식 문서 참고 :
                    +asA('https://redis.io/commands/blpop/')

            +pos('BRPOP')
            h3 BRPOP
            +asCode('text', 'syntax') BRPOP key [key ...] timeout-seconds
            ul
                li
                    +goto('RPOP')
                    |의 블로킹 버전
                li 기타 설명은
                    +goto('BLPOP')
                    |과 동일

            +pos('BRPOPLPUSH')
            h3 BRPOPLPUSH; Deprecated since 6.2.0
            +asCode('text', 'syntax') BRPOPLPUSH source destination timeout-seconds
            ul
                li
                    +goto('RPOPLPUSH')
                    |의 블로킹 버전
                li source 리스트가 비어있는 경우, 최대 timeout만큼 대기한다
                li Since 6.2.0 :
                    +goto('BLMOVE')

            +pos('LINDEX')
            h3 LINDEX
            +asCode('text', 'syntax') LINDEX key index
            p index(음수 가능) 번째 값 반환

            +pos('LMOVE')
            h3 LMOVE Since 6.2.0
            +asCode('text', 'syntax') LMOVE source destination LEFT|RIGHT LEFT|RIGHT
            p 원자적으로 source의 LEFT|RIGHT 원소를 반환한 다음 삭제하고, destination의 LEFT|RIGHT에 추가한다
            +asCode('shell', 'redis-cli').
                127.0.0.1:6379> lpush list1 x1 x2 x3
                (integer) 3
                127.0.0.1:6379> lpush list2 y1 y2 y3
                (integer) 3
                127.0.0.1:6379> lmove list1 list2 left right
                "x3"

            +pos('LMPOP')
            h3 LMPOP Since 7.0.0
            +asCode('text', 'syntax') LMPOP numkeys key [key ...] LEFT|RIGHT [COUNT count]
            p 비어있지 않은 최초 리스트에서 최대 count개 원소를 반환하고 제거

            +pos('LPUSH')
            h3 LPUSH
            +asCode('text', 'syntax') LPUSH key element [element ...]
            p 왼쪽에 값 추가. 이후 리스트 크기 반환

            +pos('RPUSH')
            h3 RPUSH
            +asCode('text', 'syntax') RPUSH key element [element ...]
            p 오른쪽에 값 추가. 이후 리스트 크기 반환

            +pos('LPUSHX')
            h3 LPUSHX
            +asCode('text', 'syntax') LPUSHX key element [element ...]
            p 리스트가 존재하면 왼쪽에 값 추가. 이후 리스트 크기 반환

            +pos('RPUSHX')
            h3 RPUSHX
            +asCode('text', 'syntax') RPUSHX key element [element ...]
            p 리스트가 존재하면 오른쪽에 값 추가. 이후 리스트 크기 반환

            +pos('LPOP')
            h3 LPOP
            +asCode('text', 'syntax') LPOP key [count]
            p 리스트 왼쪽 값 count(기본 1)개 삭제 후 반환

            +pos('RPOP')
            h3 RPOP
            +asCode('text', 'syntax') RPOP key
            p 리스트 오른쪽 값 삭제 후 반환

            +pos('LRANGE')
            h3 LRANGE
            +asCode('text', 'syntax') LRANGE key start stop
            p [start, stop] 범위의 값 반환(음수 인덱스 가능)

            +pos('LSET')
            h3 LSET
            +asCode('text', 'syntax') LSET key index element
            p index(음수 가능) 번째 값을 element로 교체

            +pos('LINSERT')
            h3 LINSERT
            +asCode('text', 'syntax') LINSERT key BEFORE|AFTER pivot element
            p pivot 전/후에 element를 삽입

            +pos('LLEN')
            h3 LLEN
            +asCode('text', 'syntax') LLEN key
            p 리스트 크기 반환

            +pos('LREM')
            h3 LREM
            +asCode('text', 'syntax') LREM key count element
            p element를 count개 삭제, count == 0이면 전부 삭제, count &lt; 0이면 오른쪽부터 삭제

            +pos('LTRIM')
            h3 LTRIM
            +asCode('text', 'syntax') LTRIM key start stop
            p [start, stop] 범위(음수 인덱스 가능)만 남기고 나머지 삭제

            +pos('RPOPLPUSH')
            h3 RPOPLPUSH; Deprecated since 6.2.0
            +asCode('text', 'syntax') RPOPLPUSH source destination
            ul
                li 원자적으로 rpop + lpush 실행
                li Since 6.2.0 :
                    +goto('LMOVE')

        h2 Set
        div
            +pos('SADD')
            h3 SADD
            +asCode('text', 'syntax') SADD key member [member ...]
            p 집합에 원소 추가. 실제 추가된 개수 반환

            +pos('SREM')
            h3 SREM
            +asCode('text', 'syntax') SREM key member [member ...]
            p 집합에서 원소 삭제. 실제 제거된 개수 반환

            +pos('SISMEMBER')
            h3 SISMEMBER
            +asCode('text', 'syntax') SISMEMBER key member
            p 집합에 포함되면 1, 아니면 0

            +pos('SCARD')
            h3 SCARD
            +asCode('text', 'syntax') SCARD key
            p 집합 크기 반환

            +pos('SMEMBERS')
            h3 SMEMBERS
            +asCode('text', 'syntax') SMEMBERS key
            p 전체 원소 반환. 집합이 클수록 느려진다

            +pos('SSCAN')
            h3 SSCAN
            +asCode('text', 'syntax') SSCAN key cursor [MATCH pattern] [COUNT count]
            p 집합이 큰 경우, 조회를 작은 단위(cursor)로 나누어 수행한다
                span.hover-content(template-id='glob-style-pattern') pattern(GLOB style)
                |이 있다면 일치하는 원소만 반환

            +pos('SRANDMEMBER')
            h3 SRANDMEMBER
            +asCode('text', 'syntax') SRANDMEMBER key [count]
            p 무작위로 count(default 1)개 반환

            +pos('SPOP')
            h3 SPOP
            +asCode('text', 'syntax') SPOP key [count]
            p 무작위로 count(default 1)개 삭제 후 반환

            +pos('SUNION')
            h3 SUNION
            +asCode('text', 'syntax') SUNION key [key ...]
            p 합집합 반환

            +pos('SINTER')
            h3 SINTER
            +asCode('text', 'syntax') SINTER key [key ...]
            p 교집합 반환

            +pos('SDIFF')
            h3 SDIFF
            +asCode('text', 'syntax') SDIFF key [key ...]
            p 차집합 반환

            +pos('SUNIONSTORE')
            h3 SUNIONSTORE
            +asCode('text', 'syntax') SUNIONSTORE destination key [key ...]
            p sunion 결과 저장

            +pos('SINTERSTORE')
            h3 SINTERSTORE
            +asCode('text', 'syntax') SINTERSTORE destination key [key ...]
            p sinter 결과 저장

            +pos('SDIFFSTORE')
            h3 SDIFFSTORE
            +asCode('text', 'syntax') SDIFFSTORE destination key [key ...]
            p sdiff 결과 저장

            +pos('SMOVE')
            h3 SMOVE
            +asCode('text', 'syntax') SMOVE source destination member
            p member가 source에 포함된다면 destination으로 이동하고 1 반환. 아니면 0

        h2 Sorted Set
        p key-value 관계에 정렬을 위한 score가 추가된다. key-(score, value), 같은 score 사이에서는 value를 기준으로 정렬된다
        div
            +pos('ZADD')
            h3 ZADD
            +asCode('text', 'syntax') ZADD key [NX|XX] [CH] [INCR] score member [score member ...]
            td
                ul
                    li NX : 멤버가 존재하면 스킵, XX : 멤버가 존재하면 score 갱신
                    li INCR : score를 덮어쓰지 않고, 값만큼 증가
                    li 리턴 : 신규로 추가된 원소 개수만(기본), score 갱신된 개수도 포함(CH)

            +pos('ZINCRBY')
            h3 ZINCRBY
            +asCode('text', 'syntax') ZINCRBY key increment member
            p 스코어를 increment만큼 증가한 뒤 반환

            +pos('ZSCORE')
            h3 ZSCORE
            +asCode('text', 'syntax') ZSCORE key member
            p 원소의 스코어 반환

            +pos('ZRANK')
            h3 ZRANK
            +asCode('text', 'syntax') ZRANK key member
            p 원소의 index(오름차순) 반환

            +pos('ZREVRANK')
            h3 ZREVRANK
            +asCode('text', 'syntax') ZREVRANK key member
            p 원소의 index(내림차순) 반환

            +pos('ZCARD')
            h3 ZCARD
            +asCode('text', 'syntax') ZCARD key
            p 집합 크기 반환

            +pos('ZCOUNT')
            h3 ZCOUNT
            +asCode('text', 'syntax') ZCOUNT key min max
            p 스코어가 [min, max]에 포함되는 원소 개수 반환. 모두 가져오려면 -inf, +inf 이용

            +pos('ZLEXCOUNT')
            h3 ZLEXCOUNT
            +asCode('text', 'syntax') ZLEXCOUNT key min max
            p 동일 스코어 상에서, 값을 기준으로 범위 안에 있는 원소 개수 반환
                br
                |  min, max 앞에 [ 또는 (를 명시해야하며, 모두 가져오려면 -, + 이용

            +pos('ZRANGE')
            h3 ZRANGE
            +asCode('text', 'syntax') ZRANGE key start stop [WITHSCORES]
            p 작은 것부터 [start, stop] 범위(음수 인덱스 가능) 원소 반환

            +pos('ZRANGEBYLEX')
            h3 ZRANGEBYLEX
            +asCode('text', 'syntax') ZRANGEBYLEX key min max [LIMIT offset count]
            p 동일 스코어 상에서, 값을 기준으로 작은 것부터 반환. min, max 앞에 [ 또는 (를 명시해야하며, 모두 가져오려면 -, + 이용

            +pos('ZRANGEBYSCORE')
            h3 ZRANGEBYSCORE
            +asCode('text', 'syntax') ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]
            p 스코어가 작은 것부터 [min, max]에 포함되는 원소 반환. 모두 가져오려면 -inf, +inf 이용. 경계값 미포함하려면 (min, (max 이용

            +pos('ZREVRANGE')
            h3 ZREVRANGE
            +asCode('text', 'syntax') ZREVRANGE key start stop [WITHSCORES]
            p 큰 것부터 [start, stop] 범위(음수 인덱스 가능) 원소 반환

            +pos('ZREVRANGEBYLEX')
            h3 ZREVRANGEBYLEX
            +asCode('text', 'syntax') ZREVRANGEBYLEX key max min [LIMIT offset count]
            p 동일 스코어 상에서, 값을 기준으로 큰 것부터 반환. min, max 앞에 [ 또는 (를 명시해야하며, 모두 가져오려면 -, + 이용

            +pos('ZREVRANGEBYSCORE')
            h3 ZREVRANGEBYSCORE
            +asCode('text', 'syntax') ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]
            p 스코어가 큰 것부터 [min, max]에 포함되는 원소 반환. 모두 가져오려면 [-inf, +inf] 이용. 경계값 미포함하려면 (min, (max 이용

            +pos('ZREM')
            h3 ZREM
            +asCode('text', 'syntax') ZREM key member [member ...]
            p 원소 삭제. 삭제된 개수 반환

            +pos('ZREMRANGEBYLEX')
            h3 ZREMRANGEBYLEX
            +asCode('text', 'syntax') ZREMRANGEBYLEX key min max
            p 동일 스코어 상에서, 값 기준으로 원소 삭제

            +pos('ZREMRANGEBYRANK')
            h3 ZREMRANGEBYRANK
            +asCode('text', 'syntax') ZREMRANGEBYRANK key start stop
            p 인덱스(음수 가능) 기준으로 원소 삭제

            +pos('ZREMRANGEBYSCORE')
            h3 ZREMRANGEBYSCORE
            +asCode('text', 'syntax') ZREMRANGEBYSCORE key min max
            p 스코어 기준으로 원소 삭제

            +pos('ZUNIONSTORE')
            h3 ZUNIONSTORE
            +asCode('text', 'syntax') ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]
            td
                ul
                    li 합집합 저장
                    li WEIGHTS : 각 스코어에 곱할 가중치
                    li AGGREGATE : SUM(스코어 합), MIN(스코어 평균), MAX(최대 스코어)

            +pos('ZINTERSTORE')
            h3 ZINTERSTORE
            +asCode('text', 'syntax') ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]
            td
                ul
                    li 교집합 저장
                    li WEIGHTS : 각 스코어에 곱할 가중치
                    li AGGREGATE : SUM(스코어 합), MIN(스코어 평균), MAX(최대 스코어)

            +pos('ZSCAN')
            h3 ZSCAN
            +asCode('text', 'syntax') ZSCAN key cursor [MATCH pattern] [COUNT count]
            p 집합이 큰 경우, 조회를 작은 단위(cursor)로 나누어 수행한다
                span.hover-content(template-id='glob-style-pattern') pattern(GLOB style)
                |이 있다면 일치하는 원소만 반환

            +pos('ZPOPMAX')
            h3 ZPOPMAX
            +asCode('text', 'syntax') ZPOPMAX key [count]
            p 큰 원소부터 pop

            +pos('ZPOPMIN')
            h3 ZPOPMIN
            +asCode('text', 'syntax') ZPOPMIN key [count]
            p 작은 원소부터 pop

            +pos('BZPOPMAX')
            h3 BZPOPMAX
            +asCode('text', 'syntax') BZPOPMAX key [key ...] timeout
            p 큰 원소부터 pop. 없으면 timeout(초)만큼 대기

            +pos('BZPOPMIN')
            h3 BZPOPMIN
            +asCode('text', 'syntax') BZPOPMIN key [key ...] timeout
            p 작은 원소부터 pop. 없으면 timeout(초)만큼 대기

        h2 Hash
        p 하나의 key에 대해 여러(40억개) field-value 쌍을 가질 수 있다
        div
            +pos('HSET')
            h3 HSET
            +asCode('text', 'syntax') HSET key field value [field value ...]
            p key에 대해 field-value 쌍 추가. 기존 value는 덮어씌어진다. 추가된 쌍의 개수 반환

            +pos('HSETNX')
            h3 HSETNX
            +asCode('text', 'syntax') HSETNX key field value
            p field가 없는 경우에만 field-value 쌍 추가. 추가된 쌍의 개수 반환

            +pos('HGET')
            h3 HGET
            +asCode('text', 'syntax') HGET key field
            p 지정한 field에 대해 value 반환. 없으면 nil

            +pos('HMGET')
            h3 HMGET
            +asCode('text', 'syntax') HMGET key field [field ...]
            p 지정한 field들에 대해 value 반환. 없으면 nil

            +pos('HDEL')
            h3 HDEL
            +asCode('text', 'syntax') HDEL key field [field ...]
            p 지정한 field들에 대해 field-value 쌍 제거. 제거된 개수 반환

            +pos('HLEN')
            h3 HLEN
            +asCode('text', 'syntax') HLEN key
            p field-value 쌍 개수

            +pos('HKEYS')
            h3 HKEYS
            +asCode('text', 'syntax') HKEYS key
            p field 목록 반환

            +pos('HVALS')
            h3 HVALS
            +asCode('text', 'syntax') HVALS key
            p value 목록 반환

            +pos('HGETALL')
            h3 HGETALL
            +asCode('text', 'syntax') HGETALL key
            p field-value 목록 반환

            +pos('HSCAN')
            h3 HSCAN
            +asCode('text', 'syntax') HSCAN key cursor [MATCH pattern] [COUNT count]
            p 일정 개수(count)씩 field-value 목록 조회
                span.hover-content(template-id='glob-style-pattern') pattern(GLOB style)
                |이 지정된 경우 field에 적용된다

            +pos('HEXISTS')
            h3 HEXISTS
            +asCode('text', 'syntax') HEXISTS key field
            p field를 포함하는지 여부 반환(0, 1)

            +pos('HINCRBY')
            h3 HINCRBY
            +asCode('text', 'syntax') HINCRBY key field increment
            p value += increment, 이전 값이 없으면 value = increment

            +pos('HINCRBYFLOAT')
            h3 HINCRBYFLOAT
            +asCode('text', 'syntax') HINCRBYFLOAT key field increment
            p value += increment, 이전 값이 없으면 value = increment

            +pos('HSTRLEN')
            h3 HSTRLEN
            +asCode('text', 'syntax') HSTRLEN key field
            p value의 바이트 길이 반환

        h2 Stream
        p 스트림 : 온도, Memory, Log 등 동종 데이터의 연속적인 발생. 이전 값을 수정하지 않고, 새로 추가되기만 한다
        ul
            li 동종 : key로 구분한다
            li 새로 추가 : 데이터의 선후 관계는 ID로 구분한다. ID가 이전보다 작으면 추가 실패. ID를 *로 지정하는 경우, 서버에서 자동으로 millisecondsTime-sequenceNumber로 할당
        div
            +pos('XADD')
            h3 XADD
            +asCode('text', 'syntax') XADD key ID field value [field value ...]
            p key에 대해 field-value 쌍 추가
                +asCode('shell', '예. 센서 데이터 추가. 최대 길이는 10').
                    xadd sensor-1 maxlen 10 * temperature 36.5

            +pos('XREAD')
            h3 XREAD
            +asCode('text', 'syntax') XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] id [id ...]
            p 지정한 id보다 큰 데이터를 count개(default 1) 반환

            +pos('XDEL')
            h3 XDEL
            +asCode('text', 'syntax') XDEL key ID [ID ...]
            p 지정한 ID의 엔트리 삭제

            +pos('XLEN')
            h3 XLEN
            +asCode('text', 'syntax') XLEN key
            p 엔트리(field-value 쌍) 개수 반환. key가 없어도 0

            +pos('XRANGE')
            h3 XRANGE
            +asCode('text', 'syntax') XRANGE key start end [COUNT count]
            p ID가 [start, end] 내에 있는 엔트리 반환. 전체를 가져오려면 -, + 이용

            +pos('XREVRANGE')
            h3 XREVRANGE
            +asCode('text', 'syntax') XREVRANGE key end start [COUNT count]
            p XRANGE의 역순

            +pos('XTRIM')
            h3 XTRIM
            +asCode('text', 'syntax') XTRIM key MAXLEN [~] count
            p 최대 count개의 엔트리만 남기고 오래된 것부터 삭제. ~를 지정한 경우, 다른 입출력에 지장이 없는 한도로 작업

            +pos('XGROUP')
            h3 XGROUP
            +asCode('text', 'syntax') XGROUP [CREATE key groupname id-or-$] [SETID key groupname id-or-$] [DESTROY key groupname] [DELCONSUMER key groupname consumername]
            ul
                li CREATE : 소비자그룹 생성
                p id를 지정한 경우 다음 엔트리부터, $를 지정한 경우 그룹 생성 직후 엔트리부터 소비
                li DESTROY : 소비자그룹 삭제
                li DELCONSUMER : 소비자 삭제
                li SETID : 소비 기준 ID 재설정

            +pos('XREADGROUP')
            h3 XREADGROUP
            +asCode('text', 'syntax') XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]
            p 소비자로써 엔트리 소비. ID 지정 대신 '>'를 이용하면 알아서 다음 엔트리를 소비한다

            +pos('XACK')
            h3 XACK
            +asCode('text', 'syntax') XACK key group ID [ID ...]
            p 소비 완료 표시

            +pos('XPENDING')
            h3 XPENDING
            +asCode('text', 'syntax') XPENDING key group [start end count] [consumer]
            p 소비중인 엔트리 반환

            +pos('XCLAIM')
            h3 XCLAIM
            +asCode('text', 'syntax') XCLAIM key group consumer min-idle-time ID [ID ...] [IDLE ms] [TIME ms-unix-time] [RETRYCOUNT count] [FORCE] [JUSTID]
            ul
                li min-idle-time(밀리초) 이상 소비중인 엔트리를 consumer가 처리
                li 기본값으로 IDLE 0이며, 따라서 동일 명령으로 다른 소비자가 동일 엔트리를 가져가지 못하게 된다
                li 처리 후 XACK로 표시해야 한다

            +pos('XINFO')
            h3 XINFO
            +asCode('text', 'syntax') XINFO [CONSUMERS key groupname] [GROUPS key] [STREAM key] [HELP]
            td:ul
                li XINFO STREAM key [FULL [COUNT count]] : 스트림 정보
                li XINFO CONSUMERS key group : 소비자 정보
                li XINFO GROUPS key : 소비자그룹 정보
                li XINFO HELP : 도움말

        +asCode().
            cluster > CLUSTER ADDSLOTS slot [slot ...]
            cluster > CLUSTER BUMPEPOCH
            cluster > CLUSTER COUNT-FAILURE-REPORTS node-id
            cluster > CLUSTER COUNTKEYSINSLOT slot
            cluster > CLUSTER DELSLOTS slot [slot ...]
            cluster > CLUSTER FAILOVER [FORCE|TAKEOVER]
            cluster > CLUSTER FLUSHSLOTS
            cluster > CLUSTER FORGET node-id
            cluster > CLUSTER GETKEYSINSLOT slot count
            cluster > CLUSTER INFO
            cluster > CLUSTER KEYSLOT key
            cluster > CLUSTER MEET ip port
            cluster > CLUSTER MYID
            cluster > CLUSTER NODES
            cluster > CLUSTER REPLICAS node-id
            cluster > CLUSTER REPLICATE node-id
            cluster > CLUSTER RESET [HARD|SOFT]
            cluster > CLUSTER SAVECONFIG
            cluster > CLUSTER SET-CONFIG-EPOCH config-epoch
            cluster > CLUSTER SETSLOT slot IMPORTING|MIGRATING|STABLE|NODE [node-id]
            cluster > CLUSTER SLAVES node-id
            cluster > CLUSTER SLOTS
            cluster > READONLY
            cluster > READWRITE
        +asCode().
            connection > AUTH password
            connection > CLIENT CACHING YES|NO
            connection > CLIENT GETNAME
            connection > CLIENT GETREDIR
            connection > CLIENT ID
            connection > CLIENT KILL [ip:port] [ID client-id] [TYPE normal|master|slave|pubsub] [ADDR ip:port] [SKIPME yes/no]
            connection > CLIENT LIST [TYPE normal|master|replica|pubsub]
            connection > CLIENT PAUSE timeout
            connection > CLIENT REPLY ON|OFF|SKIP
            connection > CLIENT SETNAME connection-name
            connection > CLIENT TRACKING ON|OFF [REDIRECT client-id] [PREFIX prefix] [BCAST] [OPTIN] [OPTOUT] [NOLOOP]
            connection > CLIENT UNBLOCK client-id [TIMEOUT|ERROR]
            connection > ECHO message
            connection > HELLO protover [AUTH username password] [SETNAME clientname]
            connection > PING [message]
            connection > QUIT
            connection > SELECT index
        +asCode().
            geo > GEOADD key longitude latitude member [longitude latitude member ...]
            geo > GEODIST key member1 member2 [m|km|ft|mi]
            geo > GEOHASH key member [member ...]
            geo > GEOPOS key member [member ...]
            geo > GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]
            geo > GEORADIUSBYMEMBER key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]
        +asCode().
            hyperloglog > PFADD key element [element ...]
            hyperloglog > PFCOUNT key [key ...]
            hyperloglog > PFMERGE destkey sourcekey [sourcekey ...]
        +asCode().
            pubsub > PSUBSCRIBE pattern [pattern ...]
            pubsub > PUBLISH channel message
            pubsub > PUBSUB subcommand [argument [argument ...]]
            pubsub > PUNSUBSCRIBE [pattern [pattern ...]]
            pubsub > SUBSCRIBE channel [channel ...]
            pubsub > UNSUBSCRIBE [channel [channel ...]]
        +asCode().
            scripting > EVAL script numkeys key [key ...] arg [arg ...]
            scripting > EVALSHA sha1 numkeys key [key ...] arg [arg ...]
            scripting > SCRIPT DEBUG YES|SYNC|NO
            scripting > SCRIPT EXISTS sha1 [sha1 ...]
            scripting > SCRIPT FLUSH
            scripting > SCRIPT KILL
            scripting > SCRIPT LOAD script
        +asCode().
            server > ACL CAT [categoryname]
            server > ACL DELUSER username [username ...]
            server > ACL GENPASS [bits]
            server > ACL LIST
            server > ACL LOAD
            server > ACL LOG [count or RESET]
            server > ACL SAVE
            server > ACL SETUSER rule [rule ...]
            server > ACL USERS
            server > ACL WHOAMI
            server > BGREWRITEAOF
            server > BGSAVE [SCHEDULE]
            server > COMMAND
            server > COMMAND COUNT
            server > COMMAND GETKEYS
            server > COMMAND INFO command-name [command-name ...]
            server > CONFIG GET parameter
            server > CONFIG RESETSTAT
            server > CONFIG REWRITE
            server > CONFIG SET parameter value
            server > DBSIZE
            server > DEBUG OBJECT key
            server > DEBUG SEGFAULT
            server > FLUSHALL [ASYNC]
            server > FLUSHDB [ASYNC]
            server > INFO [section]
            server > LASTSAVE
            server > LATENCY DOCTOR
            server > LATENCY GRAPH event
            server > LATENCY HELP
            server > LATENCY HISTORY event
            server > LATENCY LATEST
            server > LATENCY RESET [event]
            server > LOLWUT [VERSION version]
            server > MEMORY DOCTOR
            server > MEMORY HELP
            server > MEMORY MALLOC-STATS
            server > MEMORY PURGE
            server > MEMORY STATS
            server > MEMORY USAGE key [SAMPLES count]
            server > MODULE LIST
            server > MODULE LOAD path [ arg [arg ...]]
            server > MODULE UNLOAD name
            server > MONITOR
            server > PSYNC replicationid offset
            server > REPLICAOF host port
            server > ROLE
            server > SAVE
            server > SHUTDOWN [NOSAVE|SAVE]
            server > SLAVEOF host port
            server > SLOWLOG subcommand [argument]
            server > SWAPDB index1 index2
            server > SYNC
            server > TIME
        +asCode().
            transactions > DISCARD
            transactions > EXEC
            transactions > MULTI
            transactions > UNWATCH
            transactions > WATCH key [key ...]

    h1 Redis Stack
    p 레디스 서버에 여러 모듈이 추가되어 아래와 같은 기능을 지원한다
    ul
        li RediSearch : 추가 인덱싱, 쿼리 지원, 전문 검색 등 지원
        li RedisJSON : JSON 모델 지원
        li RedisGraph : 그래프 모델 지원
        li RedisTimeSeries : 기간을 이용한 쿼리, 집계 쿼리 등 지원

    +hoverTemplate()#glob-style-pattern
        ul
            li * : 임의 길이 임의 문자열
            li ? : 임의 문자 1개
            li [abc] : 문자 집합 중 1글자
            li [^abc] : 여집합 중 1글자
            li [a-z] : 문자 집합 중 1글자
