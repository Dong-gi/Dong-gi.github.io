include ../../../source/skeleton.pug

+post({
    title: 'Python 표준 라이브러리',
    description: 'Python 표준 라이브러리 정리',
    useMath: true,
})

    h1 string : 문자열 공통 연산
    div
        h2 Constants
        +asCode('python').
            string.ascii_letters   # ascii_lowercase + ascii_uppercase
            string.ascii_lowercase # 'abcdefghijklmnopqrstuvwxyz'
            string.ascii_uppercase # 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
            string.digits          # '0123456789'
            string.hexdigits       # '0123456789abcdefABCDEF'
            string.octdigits       # '01234567'
            string.punctuation     # '!"#$%&\'()*+,-./:;&lt;=>?@[\\]^_`{|}~'
            string.whitespace      # ' \t\n\r\x0b\x0c'
            string.printable       # digits + ascii_letters + punctuation + whitespace

        h2 Format String Syntax
        ul
            li replacement_field ::= "{" [field_name] ["!" conversion] [":" format_spec] "}"
            li field_name ::= arg_name ("." attribute_name | "[" element_index "]")*
            p .attribute_name → getattr(), [element_index] → __getitem__()
            li arg_name ::= [identifier | digit+]
            p identifier → 키워드 인자 참조, digit → positional 인자 참조
            +codeBtn('/Repositories/Python/Basic/format_example.py', 'python', '[1,7]')
            li attribute_name ::= identifier
            li element_index ::= digit+ | index_string
            li index_string ::= &lt;any source character except "]"> +
            li conversion ::= "r" | "s" | "a" # 각각 repr(), str(), ascii() 호출
            li format_spec ::= [[fill]align][sign][#][0][width][grouping_option][.precision][type]
            li fill ::= &lt;any character>
            li align ::= "&lt;" | ">" | "=" | "^"
            li sign ::= "+" | "-" | " "
            li '#' 옵션이 있으면 2, 8, 16진수 앞에 '0b', '0o', '0x'를 각각 붙인다
            li width ::= digit+
            li grouping_option "_" Since 3.6 | "," Since 3.1 // 십진수 1000단위 구분, 그외 4자리 구분
            li precision ::= digit+
            li type ::= "b" | "c" | "d" | "e" | "E" | "f" | "F" | "g" | "G" | "n" | "o" | "s" | "x" | "X" | "%"
            p type이 주어지지 않은(None) 경우 문자열은 's', 정수는 'd', 실수는 'g'로 간주

        h2 class string.Template(template)
        +asCode('python').
            from string import Template
            s = Template('$who likes $what')
            s.substitute(who='tim', what='kung pao')    # 'tim likes kung pao'
            Template('Give $who $100').substitute(dict(who='tim'))
            # ValueError: Invalid placeholder in string: line 1, col 11
            # $를 출력하고 싶을 땐 $$를 이용하면 된다
            Template('$who likes $what').substitute(dict(who='tim'))        # KeyError: 'what'
            Template('$who likes $what').safe_substitute(dict(who='tim'))   # 'tim likes $what'

        h2 Helper functions
        ul
            li string.capwords(s, sep=None)
            +asCode('python').
                if sep is None:
                    sep = ' '
                sep.join([word.capitalize() for word in s.split(sep=sep)])

    h1 re : 정규표현식
    div
        h2 Regular Expression Syntax
        ul
            li str과 bytes모두 지원하지만, 찾는 패턴과 대상의 타입은 일치해야 한다
            li 이스케이프하지 않는 raw string(r'')을 이용하면 편리하다
            p ↓ 자바 정규표현식과 동일한 부분은 생략했음
            li [] : 문자 집합
            ul
                li 문자열 리터럴 표준 이스케이프 \a, \b, \f, \n, \r, \t, \u Since 3.3, \U Since 3.3, \v, \x, \\를 이용할 수 있다
                li \w, \S 등의 character class는 의미를 그대로 갖는다
            li.marker (?...) : 확장 표현
            ul
                li (?#...) : 주석
                li (?aiLmsux)
                p 'a', 'i', 'L', 'm', 's', 'u', 'x'중 하나 이상 사용. 각각 re.A, re.I, re.L, re.M, re.S, re.U, re.X 플래그를 설정한다
                li (?aiLmsux-imsx:...) Since 3.7
                p '-' 이후의 옵션들은 관계된 플래그를 해제한다는 의미
                li (?P&lt;name>...)
                p Named capturing group. name은 Python 식별자 규칙을 따라야 한다
                li (?P=name) : Named capturing group에 대한 backreference
                li (?&lt;=...)
                p Positive lookbehind. (...)이 매칭하는 문자열은 고정 길이여야 한다. group 참조 가능(Since 3.5)
                li (?&lt;!...)
                p Negative lookbehind. (...)이 매칭하는 문자열은 고정 길이여야 한다
                li (?(id/name)yes-pattern|no-pattern)
                p id or name의 그룹이 매칭되면 yes-pattern을, 아니면 no-pattern을 매칭. no-pattern은 없어도 된다
            li \number # 해당 순번의 그룹에 대한 backreference. 그룹 번호는 [1, 99]
            li \A ↔ \Z # 문자열 시작 경계 매칭
            li \b ↔ \B # Word의 시작 또는 끝 경계 매칭. \w와 \W 사이의 경계로 정의된다
            li \d ↔ \D # 십진 숫자 매칭. 바이트 패턴에서는 [0-9]만 매칭
            li \s ↔ \S # 공백 문자 매칭. 바이트 패턴에서는 [ \t\n\r\f\v]만 매칭
            li \w ↔ \W # Word 문자 매칭. 바이트 패턴에서는 [a-zA-Z0-9_]만 매칭
            li Since 3.3 # \uXXXX, \UXXXX 가능
            li Since 3.8 # \N{name} 가능

        h2 Module Contents
        ul
            li Since 3.6 # Flag 상수들은 이제 RegexFlag(enum.IntFlag)의 인스턴스다
            li re.compile(pattern, flags=0)
            ul
                li re.I, re.IGNORECASE
                li re.M, re.MULTILINE
                li re.S, re.DOTALL # '.'이 newline 문자 포함하여 매칭
                li re.X, re.VERBOSE # 주석을 달아 이해하기 쉬운 패턴 작성 가능
                li re.A, re.ASCII # 유니코드 패턴에서 \w, \W, \b, \B, \d, \D, \s, \S가 아스키코드만 매칭
                li re.DEBUG # 디버그 정보 출력
        +asCode('python').
            re.search(pattern, string, flags=0)
                # 처음 매칭되는 부분 문자열에 대해 match 객체 반환. 없으면 None

            re.match(pattern, string, flags=0)
                # 문자열 시작 위치에서 매칭되면 match 객체 반환. 없으면 None
            re.fullmatch(pattern, string, flags=0)
                # Since 3.4 문자열 전체가 매칭되면 match 객체 반환. 없으면 None

            re.split(pattern, string, maxsplit=0, flags=0)
                # 매칭된 패턴들로 분리. pattern에 그룹이 있으면 매칭된 문자열들도 결과에 포함된다. 결과의 빈 문자열에 유의
                re.split(r'(.*)', '')

            re.findall(pattern, string, flags=0)
                # 문자열을 좌에서 우로 스캔하며 매칭된, 겹치지 않는 부분 문자열들을 리스트로 반환한다. 패턴에 그룹이 있는 경우 튜플로 표현된다
            re.finditer(pattern, string, flags=0)
                # findall과 동일한 방식으로 매칭하면서 match 객체를 하나씩 yield

            re.sub(pattern, repl, string, count=0, flags=0)
                # string에서 pattern에 매칭된, 겹치지 않는 부분 문자열들을 repl로 변경하여 반환. repl은 문자열이거나 함수일 수 있다
                # 문자열의 경우 backreference, \g&lt;name>, \g&lt;number> 가능. 함수의 경우 match 객체 하나를 먹고 문자열을 반환
            re.subn(pattern, repl, string, count=0, flags=0)
                # re.sub()와 같은 작업을 하고, (new_string, number_of_subs_made) 반환

            re.escape(pattern)
                # 패턴 문자열을 이스케이프. 이 결과를 패턴으로 이용하면 단 하나의 문자열만 매칭된다

            re.purge()
                # RE 캐시 삭제

        h2 Regular Expression Objects
        p 컴파일된 RE 객체는 아래의 메서드와 속성을 지원한다. 각 메서드는 re 모듈의 함수와 유사하다
        +asCode('python').
            regex.search(string[, pos[, endpos]])
                # pos가 지정되더라도 '^'는 실제 문자열 시작에만 매칭된다
                # endpos가 지정된 호출과 rx.search(string[:endpos], pos)는 동등하다

            regex.match(string[, pos[, endpos]])
            regex.fullmatch(string[, pos[, endpos]])
                # Since 3.4

            regex.split(string, maxsplit=0)

            regex.findall(string[, pos[, endpos]])
            regex.finditer(string[, pos[, endpos]])

            regex.sub(repl, string, count=0)
            regex.subn(repl, string, count=0)

            regex.flags
                # compile()에서 전달받은 플래그들과 (?...) 인라인 플래그들

            regex.groups
                # 패턴 내부 capturing group 수

            regex.groupindex
                # (?P&lt;name>)로 정의된 symbolic group 이름으로부터 그룹 숫자로의 dictionary 매핑

            regex.pattern
                # 패턴 문자열

            # Since 3.7 컴파일된 정규표현식 객체는 원자적이다
            copy.copy()
            copy.deepcopy()

        h2 Match Objects
        p 매칭이 없다면 None을 반환하므로, match 객체는 항상 True로 간주된다
        +asCode('python').
            match.expand(template)
                # sub() 메서드가 하듯이, template 내부의 \ 대체 문자열을 알맞게 변경한다. \1, \g&lt;1>, \g&lt;name>와 같은 backreference들은 각각 연관된 그룹의 내용으로 대체된다

            match.group([group1, ...])
                # 매칭된 그룹(들)을 반환한다. 여러 번 매칭된 경우 마지막 문자열이 반환된다. 지정되지 않은 경우 group1은 0(전체 매칭 문자열). (?P&lt;name>...) 그룹이 패턴에 존재하면 groupN 인자로 문자열도 가능

            match.__getitem__(g)
                # Since 3.6, == m.group(g). m[0], m[1], ...

            match.groups(default=None)
                # 각 그룹들의 매칭 문자열(없으면 default)들을 튜플로 반환한다

            match.groupdict(default=None)
                # groups()를 dictoinary로 표현

            match.start([group])
                # 그룹 시작 인덱스
            match.end([group])
                # 그룹 종료 인덱스

            match.span([group])
                # (m.start(group), m.end(group)) 반환

            match.pos
                # search(), match()에서 전달받은 탐색 시작 위치
            match.endpos
                # search(), match()에서 전달받은 탐색 종료 위치
            match.string
                # match(), search()에서 전달받은 탐색 대상 문자열

            match.lastindex
                # 마지막으로 매칭된 그룹 index. 없으면 None
            match.lastgroup
                # 마지막으로 매칭된 그룹 이름. 없으면 None
            match.re
                # RE 객체

    h1 textwrap : 텍스트 정돈
    +asCode('python').
        textwrap.wrap(text, width=70, **kwargs)
            # text의 모든 라인이 최대 width 길이가 되도록 조정한다. 라인들의 리스트를 반환한다. kwargs는 TextWrapper 속성 참고

        textwrap.fill(text, width=70, **kwargs)
            # "\n".join(wrap(text, width, kwargs))와 동일하다

        textwrap.shorten(text, width, **kwargs)
            # Since 3.4, text의 모든 공백들을 단일 스페이스로 변경하고, width길이에 맞게 자른다
            # width를 넘는 경우, 자른 자리에 placeholder를 넣은 길이가 width가 된다

        textwrap.dedent(text)
            # text 각 라인이 공통 공백으로 시작되는 경우, 이를 제거한다. ''', """리터럴 정렬에 유용

        textwrap.indent(text, prefix, predicate=None)
            # Since 3.3, 공백 이외의 문자를 포함한 모든 라인 앞에 prefix를 붙인다. predicate 함수는 각 라인을 인자로 받아 prefix를 붙일지 여부를 반환한다
    div
        h2 class textwrap.TextWrapper(**kwargs)
        +asCode('python').
            width(default 70)
                # 라인 최대 길아

            # Since 3.3, \t를 몇 개의 ' '로 교체할 지
            expand_tabs(default True)
            tabsize(default 8)

            replace_whitespace(default True)
                # \t 교체 후, wrap() 수행 전에 \s를 ' '로 교체

            drop_whitespace(default True)
                # wrap() 수행 후, indent() 수행 전에 각 라인을 trim; 단 문단 첫 공백은 예외

            initial_indent(default '')
                # 문단 첫째 줄 앞에 삽입

            subsequent_indent(default '')
                # 문단 둘째 줄부터 앞에 삽입

            break_long_words(default True)
                # False면 width보다 큰 단어는 그대로 남는다

            max_lines(default None)
                # Since 3.4

            placeholder(default '[...]')
                # Since 3.4

            wrap(text)
            fill(text)


    h1 unicodedata : 유니코드 database 표준
    +asCode('python').
        unicodedata.lookup(name)
            # 유니코드 이름에 해당하는 문자 반환. 없으면 KeyError
            # ↔ name(chr[, default])

        unicodedata.decimal(chr[, default])
            # 문자에 해당하는 integer 반환
        unicodedata.digit(chr[, default])
            # 문자에 해당하는 integer 반환
        unicodedata.numeric(chr[, default])
            # 문자에 해당하는 float 반환

        unicodedata.category(chr)
        unicodedata.bidirectional(chr)
        unicodedata.mirrored(chr) # ...

        unicodedata.normalize(form, unistr)
        unicodedata.is_normalized
            # Since 3.8
    div
        h2 유니코드 정규화
        +asA('https://ko.wikipedia.org/wiki/%EC%9C%A0%EB%8B%88%EC%BD%94%EB%93%9C_%EC%A0%95%EA%B7%9C%ED%99%94', '참고 자료')
        ul
            li NFC : 코드 포인트를 조합해서 가장 짧은 동일 문자열 생성; Normalization Form: Composition
            li NFD : 조합된 문자를 기본 문자와 결합 문자로 분리; Normalization Form: Decomposition
            +asCode('python').
                # 출처 : https://github.com/AllenDowney/fluent-python-notebooks/blob/master/04-text-byte/sanitize.py
                import unicodedata
                import string
                def shave_marks(txt):
                    '''라틴 기반 문자에서 발음 구별 기호 제거'''
                    norm_txt = unicodedata.normalize('NFD', txt)
                    latin_base = False
                    keepers = []
                    for c in norm_txt:
                        if unicodedata.combining(c) and latin_base:
                            continue
                        keepers.append(c)
                        if not unicodedata.combining(c):
                            latin_base = c in string.ascii_letters
                    return unicodedata.normalize('NFC', ''.join(keepers))
            li NFKC : Normalization Form: Compatibility (K) Composition
            li NFKD : Normalization Form: Compatibility (K) Decomposition
            p 호환 분해 예 : ½(U+00BD) → '1/2', 마이크로(U+00B5) → 뮤(U+03BC)


    h1 struct : 이진 데이터 패킹/언패킹
    p struct는 bytes 객체로 표현된 C 구조체와 Python 값 사이의 변환을 지원한다
    +asCode('python').
        struct.pack(fmt, v1, v2, ...)
            # 포맷 문자열 fmt에 따라 v1, v2, ... 들을 포장한 bytes 객체 반환
        struct.pack_into(fmt, buffer, offset, v1, v2, ...)
            # pack의 결과를 쓰기 가능한 buffer의 offset 위치에 쓴다

        struct.unpack(fmt, buffer)
            # 포맷 문자열 fmt에 따라 포장된 buffer를 풀어 값의 튜플로 반환
        struct.unpack_from(fmt, buffer, offset=0)
        struct.iter_unpack(fmt, buffer
            # Since 3.4, unpack 순회하는 iterator 반환. buffer 크기는 반드시 fmt의 정수배 == calcsize(fmt)

        struct.calcsize(fmt)
            # format 표현에 필요한 바이트 크기
    div
        h2 Format String
        li Byte Order, Size, and Alignment
        table.w3-table-all.w3-card.w3-small
            tr
                th Char
                th Byte order
                th Size
                th Alignment
            tr
                td @(default)
                td native
                td native
                td native
            tr
                td =
                td native
                td standard
                td none
            tr
                td &lt;
                td little-endian
                td standard
                td none
            tr
                td >
                td big-endian
                td standard
                td none
            tr
                td !
                td network(=big-endian)
                td standard
                td none
        ul
            li Native byte order : 호스트 시스템으로 결정
            li Native size, alignment : C 컴파일러의 sizeof로 결정
            p 정렬을 위해 패딩 바이트(0)들이 첨가될 수 있다
        li Format Character
        table.w3-table-all.w3-card.w3-small
            tr
                th Char
                th C type
                th Python type
                th Standard size
            tr
                td x
                td pad byte
                td no value
                td
            tr
                td c
                td char
                td bytes of length 1
                td 1
            tr
                td b
                td signed char
                td integer
                td 1
            tr
                td B
                td unsigned char
                td integer
                td 1
            tr
                td ?
                td _Bool
                td bool
                td 1
            tr
                td h
                td short
                td integer
                td 2
            tr
                td H
                td unsigned short
                td integer
                td 2
            tr
                td i
                td int
                td integer
                td 4
            tr
                td I
                td unsigned int
                td integer
                td 4
            tr
                td l
                td long
                td integer
                td 4
            tr
                td L
                td unsigned long
                td integer
                td 4
            tr
                td q
                td long long
                td integer
                td 8
            tr
                td Q
                td unsigned long long
                td integer
                td 8
            tr
                td n Since 3.3
                td ssize_t
                td integer
                td @에서만 가능
            tr
                td N Since 3.3
                td size_t
                td integer
                td @에서만 가능
            tr
                td e Since 3.6
                td 반배 정밀도 부동소수
                td float
                td 2
            tr
                td f
                td float
                td float
                td 4
            tr
                td d
                td double
                td float
                td 8
            tr
                td s
                td char[]
                td bytes
                td
            tr
                td p
                td char[]
                td bytes
                td
            tr
                td P
                td void*
                td integer
                td @,=에서만 가능
        ul
            li 포맷 문자 앞에 정수가 오면 반복을 의미한다. 예. '4h'는 'hhhh'와 동일하다
            li 포맷 문자 사이의 공백은 무시한다. 단, 반복을 나타내는 정수와 포맷 문자 사이에는 공백이 허용되지 않는다
            li s의 경우 앞에 오는 정수는 반복이 아닌 바이트 크기다(없으면 1로 간주). 패킹 과정에서 크기를 맞추기 위해 문자열이 잘리거나 null 바이트가 포함될 수 있다. 0s는 빈 문자열 하나를 의미한다
            li p는 파스칼 문자열로, 첫 바이트는 문자열의 길이(~255)를 나타낸다
    div
        h2 class struct.Struct(format)
        p 이 클래스 인스턴스를 생성하든, 모듈 함수를 호출하든 최근 사용된 포맷 문자열 일부는 캐시된다
        +asCode('python').
            pack(v1, v2, ...)
            pack_into(buffer, offset, v1, v2, ...)

            unpack(buffer)
            unpack_from(buffer, offset=0)

            iter_unpack(buffer) # Since 3.4
            format, size


    h1 datetime : 단순 시간 표현
    +asCode('python').
        datetime.MINYEAR == 1
        datetime.MAXYEAR == 9999
    div
        h2 class datetime.date : year, month, day
        ul
            li class datetime.date(year, month, day)
            p 인스턴스는 변경 불가능 + 해시 가능하다
            li 클래스 메서드
            +asCode('python').
                date.today()
                    #date.fromtimestamp(time.time())와 동일
                date.fromtimestamp(timestamp)
                    # 1970 ~ 2038년 외의 경우 에러발생 가능
                date.fromordinal(ordinal)
                    # ordinal[1, date.max.toordinal()]. 1년 1월 ordinal == 1
                date.fromisoformat(date_string)
                    # Since 3.7, 'YYYY-MM-DD'
                date.fromisocalendar(year, week, day)
                    # Since 3.8
            li 클래스 속성
            +asCode('python').
                date.min == date(MINYEAR, 1, 1)
                date.max == date(MAXYEAR, 12, 31)
                date.resolution == timedelta(days=1)
            li 인스턴스 속성(읽기 전용)
            +asCode('python').
                year    # [MINYEAR, MAXYEAR]
                month   # [1, 12]
                day     # [1, 해당 연월의 일수]
            li 지원 연산
            +asCode('python').
                date2 = date1 + timedelta
                date2 = date1 - timedelta
                timedelta = date1 - date2
                # 산술 비교
            li 인스턴스 메서드
            +asCode('python').
                replace(year=self.year, month=self.month, day=self.day)
                timetuple()
                    # time.struct_time을 반환한다
                toordinal()
                    # ordinal 반환
                weekday()
                    # 월요일(0) ~ 일요일(6)
                isoweekday()
                    # 월요일(1) ~ 일요일(7)
                isocalendar()
                    # (ISO year, ISO week number, ISO weekday) 튜플 반환
                isoformat()
                    # 'YYYY-MM-DD' 반환
                __str__()
                    # str(d) == d.isoformat()
                __format__(format)
                    # == strftime(format) : 문자열 format에 따라 변환
        h2 class datetime.time : hour, minute, second, microsecond, tzinfo
        ul
            li class datetime.time(hour=0, minute=0, second=0, microsecond=0, tzinfo=None, *, fold=0)
            ul
                li 인스턴스는 변경 불가능 + 해시 가능하다
                li fold Since 3.6 : 0 or 1
                p 서머 타임이나 윤초 적용처럼, 특정 시각이 2가지로 해석되는 경우의 선후 관계를 나타낸다. 예를 들어 0은 서머 타임 적용 전 8시, 1은 서머 타임 적용 후 8시를 나타낼 수 있다
            li 클래스 메서드
            ul
                li classmethod time.fromisoformat(time_string) Since 3.7
                ul
                    li HH[:MM[:SS[.fff[fff]]]][+HH:MM[:SS[.ffffff]]]
                    li time.isoformat()의 역함수로 설계되었기에 모든 ISO 8601 포맷을 인식하지는 못한다
            li 클래스 속성
            +asCode('python').
                min == time(0, 0, 0, 0)
                max == time(23, 59, 59, 999999)
                resolution == timedelta(microseconds=1)
            li 인스턴스 속성(읽기 전용)
            p hour, minute, second, microsecond, tzinfo, fold(의미는 ↑ 생성자 참고) Since 3.6
            li 지원 연산 : 산술 비교
            ul
                li naive한 객체는 동등 비교에서 True를 반환하지 않는다
                li Boolean 평가 시 항상 True로 간주된다; 3.5 이전에는 UTC 자정을 false로 간주했다
            li 인스턴스 메서드
            ul
                li replace(hour=self.hour, minute=self.minute, second=self.second, microsecond=self.microsecond, tzinfo=self.tzinfo, *, fold=0)
                li time.isoformat(timespec='auto')
                table.w3-table-all.w3-card.w3-small
                    tr
                        td Format
                        td Case
                    tr
                        td HH:MM:SS.ffffff
                        td microsecond > 0
                    tr
                        td HH:MM:SS
                        td microsecond == 0
                    tr
                        td HH:MM:SS.ffffff+HH:MM[:SS[.ffffff]]
                        td utcoffset() != None
                    tr
                        td HH:MM:SS+HH:MM[:SS[.ffffff]]
                        td microsecond == 0 and utcoffset() != None
                table.w3-table-all.w3-card.w3-small
                    tr
                        td Format
                        td timespec
                    tr
                        td 'seconds' # microsecond == 0
                            br
                            |'microseconds' # microsecond > 0
                        td 'auto'
                    tr
                        td HH
                        td 'hours'
                    tr
                        td HH:MM
                        td 'minutes'
                    tr
                        td HH:MM:SS
                        td 'seconds'
                    tr
                        td HH:MM:SS.sss
                        td 'milliseconds'
                    tr
                        td HH:MM:SS.ffffff
                        td 'microseconds'
            +asCode('python').
                __str__() == isoformat()
                strftime(format)
                __format__(format) == strftime(format)
        h2 class datetime.datetime : date + time
        ul
            li datetime은 date를 상속
            li class datetime.datetime(year, month, day, hour=0, minute=0, second=0, microsecond=0, tzinfo=None, *, fold=0)
            ul
                li 인스턴스는 변경 불가능 + 해시 가능하다
                li fold Since 3.6 : 0 or 1
                p 서머 타임이나 윤초 적용처럼, 특정 시각이 2가지로 해석되는 경우의 선후 관계를 나타낸다. 예를 들어 0은 서머 타임 적용 전 8시, 1은 서머 타임 적용 후 8시를 나타낼 수 있다
            li 클래스 메서드
            +asCode('python').
                datetime.now(tz=None)
                datetime.combine(date, time, tzinfo=self.tzinfo)
                    # tzinfo Since 3.6 : 지정되지 않은 경우, time.tzinfo가 사용된다
                datetime.fromisoformat(date_string) Since 3.7
            ul
                li YYYY-MM-DD[*HH[:MM[:SS[.fff[fff]]]][+HH:MM[:SS[.ffffff]]]] // *는 임의 1글자
                li datetime.isoformat()의 역함수로 설계되었기에 모든 ISO 8601 포맷을 인식하지는 못한다
            +asCode('python').
                datetime.strptime(date_string, format)
                    # == datetime(*(time.strptime(date_string, format)[0:6]))
            li 클래스 속성
            +asCode('python').
                min == datetime(MINYEAR, 1, 1, tzinfo=None)
                max == datetime(MAXYEAR, 12, 31, 23, 59, 59, 999999, tzinfo=None)
                resolution == timedelta(microseconds=1)
            li 인스턴스 속성(읽기 전용)
            p year, month, day, hour, minute, second, microsecond, tzinfo, fold(의미는 ↑ 생성자 참고) Since 3.6
            li 지원 연산
            +asCode('python').
                datetime2 = datetime1 + timedelta
                datetime2 = datetime1 - timedelta
                timedelta = datetime1 - datetime2
                # 산술비교
            li 인스턴스 메서드
            ul
                li tzinfo가 설정되지 않은 naive한 datetime이 UTC로 잘 작동하기 위해서는 timezone.utc로 설정해야 한다
                li date() + time, timetz
                li astimezone(tz=None)
                p 동일한 UTC 시각을 다른 시간대로 변환하여 반환한다
        h2 class datetime.timedelta : date, time, datetime 사이의 microsecond 차이
        ul
            li class datetime.timedelta(days=0, seconds=0, microseconds=0, milliseconds=0, minutes=0, hours=0, weeks=0)
            li 차분 대상의 타임존 유무 여부는 timedelta 값에 영향을 끼치지 않는다
            li 클래스 속성
            +asCode('python').
                timedelta.min == timedelta(-999999999)
                timedelta.max == timedelta(days=999999999, seconds=86399, microseconds=999999)
                timedelta.resolution == timedelta(microseconds=1)
            li 인스턴스 속성(읽기 전용)
            +asCode('python').
                days         # [-999999999, 999999999]
                seconds      # [0, 86400)
                microseconds # [0, 1000000)
            li 지원 연산
            +asCode('python').
                t1 + t2
                t1 - t2
                t1 * num # round even
                t1 / t2

                t1 / num # round even
                t1 // int
                t1 // t2
                t1 % t2

                divmod(t1, t2)
                +t1
                -t1
                abs(t)

                str(t)
                repr(t)
                # 산술 비교
                # 동등 비교
            li 인스턴스 메서드
            +asCode('python').
                timedelta.total_seconds()
                    # Since 3.2, td / timedelta(seconds=1)과 동일
        h2 class datetime.tzinfo : 타임존 ABC
        ul
            li dt : datetime | time
            li utcoffset(dt)
            ul
                li UTC와 현지 시각의 차이(timedelta) 반환
                li DST(daylight saving time) 값이 있다면 합산하여 반환함이 바람직하다
                li utcoffset()이 None을 반환하지 않으면 dst()도 그러해야 한다
            li dst(dt)
            p timedelta로 반환. 모르면 None. 비활성화면 timedelta(0) 반환
            li tzname(dt)
            li fromutc(dt)
            p datetime.astimezone()에서 호출한다. 이때 dt.tzinfo == slef이고 dt의 시각은 UTC므로, 오차를 더해 반환(dt + dt.utcoffset())하면 된다
        h2 class datetime.timezone Since 3.2 : tzinfo 구현체
        ul
            li class datetime.timezone(offset, name=None)
            ul
                li 인스턴스는 변경 불가능 + 해시 가능하다
                li timezone 클래스는 tzinfo의 서브클래스
                li 고정된 UTC offset을 표현하며, 변경 불가능하다
        h2 strftime(), strptime() 사양
        table.w3-table-all.w3-card.w3-small
            tr
                th Directive
                th 의미
            tr
                td %a
                td 요일명 - 약어 - 로캐일 적용
            tr
                td %A
                td 요일명 - 풀네임 - 로캐일 적용
            tr
                td %w
                td 요일 - 0(일요일) ~ 6(토요일)
            tr
                td %d
                td 일 - zero-pad : 01 ~ 31
            tr
                td %b
                td 월 - 약어 - 로캐일 적용
            tr
                td %B
                td 월 - 풀네임 - 로캐일 적용
            tr
                td %m
                td 월 - zero-pad : 01 ~ 12
            tr
                td %y
                td 년 - 세기 제외, zero-pad : 00 ~ 99
            tr
                td %Y
                td 년 - 세기 포함, zero-pad : 0001 ~ 9999
            tr
                td %H
                td 시(24h) - zero-pad : 00 ~ 23
            tr
                td %I
                td 시(12h) - zero-pad : 01 ~ 12
            tr
                td %p
                td AM or PM - 로캐일 적용
            tr
                td %M
                td 분 - zero-pad : 00 ~ 59
            tr
                td %S
                td 초 - zero-pad : 00 ~ 59
            tr
                td %f
                td 마이크로초 - zero-pad : 000000 ~ 999999
            tr
                td %z
                td UTC 차이 : +HHMM or -HHMM
            tr
                td %Z
                td Timezone 이름
            tr
                td %j
                td 일 - 연중 n번째, zero-pad : 001 ~ 366
            tr
                td %U
                td 주(일요일 기준) - 연중 n번째, zero-pad : 00 ~ 53
            tr
                td %W
                td 주(월요일 기준) - 연중 n번째, zero-pad : 00 ~ 53
            tr
                td %c
                td 날짜와 시각 표현 - 로캐일 적용
            tr
                td %x
                td 날짜 표현 - 로캐일 적용
            tr
                td %X
                td 시각 표현 - 로캐일 적용
            tr
                td %%
                td 리터럴 '%'
            tr
                td %G
                td 년 - 세기 포함, ISO 8601 : 0001 ~ 9999
            tr
                td %u
                td 요일 - 1(월요일) ~ 7(일요일), ISO 8601
            tr
                td %V
                td 주(월요일 기준) - 연중 n번째, ISO 8601 : 01 ~ 53
                    br
                    |01번째 주는 1월 4일을 포함


    h1 calendar : 달력 연산
    div
        h2 calendar
        ul
            li 모듈 함수
            +asCode('python').
                calendar.setfirstweekday(weekday) + firstweekday()
                    # 0 = calendar.MONDAY ~ 6 = calendar.SUNDAY
                calendar.isleap(year)
                    # 윤년인지 여부 반환
                calendar.leapdays(y1, y2)
                    # [y1, y2) 중 윤년의 수 반환
                calendar.weekday(year, month, day)
                    # 0 ~ 6 반환. 1970년 이전은 부정확
                calendar.weekheader(n)
                    # 주의 요일명들을 n글자씩 자른 헤더를 반환
                calendar.monthrange(year, month)
                    # 해당 년월의 첫번째 요일(0~6)과 일수를 반환. 1970년 이전은 부정확
                calendar.timegm(tuple)
                    # calendar와 관계있지는 않다. time.gmtime()의 역함수로, time.gmtime()을 인자로 넘기면 POSIX 인코딩된 Unix timestamp 값이 반환된다
            li 모듈 속성
            +asCode('python').
                calendar.day_name
                    # 현재 로캐일의 요일명 배열
                calendar.day_abbr
                    # 현재 로캐일의 축약 요일명 배열
                calendar.month_name
                    # 현재 로캐일의 월명 배열. 길이 13이며, 1부터 12까지 이용
                calendar.month_abbr
                    # 현재 로캐일의 축약 월명 배열. 길이 13이며, 1부터 12까지 이용
        h2 class calendar.Calendar
        ul
            li class calendar.Calendar(firstweekday=0)
            p 월요일(0)이 첫번째. setfirstweekday()로 변경 가능
            li 인스턴스 메서드
            +asCode('python').
                iterweekdays()
                     # 요일에 대한 iterator 반환
                itermonthdates(year, month)
                     # 해당 월의 1일과 말일을 포함하는 전체 주를 하루씩(datetime.date) 순회하는 iterator 반환
                itermonthdays(year, month)
                     # 해당 월의 1일과 말일을 포함하는 전체 주를 하루씩(day) 순회하는 iterator 반환. 해당 월에 포함되지 않는 날짜들은 0
                itermonthdays2(year, month)
                     # 해당 월의 1일과 말일을 포함하는 전체 주를 하루씩(day, weekday) 순회하는 iterator 반환. 해당 월에 포함되지 않는 day는 0
                itermonthdays3(year, month) Since 3.7
                     # 해당 월의 1일과 말일을 포함하는 전체 주를 하루씩(year, month, day) 순회하는 iterator 반환
                itermonthdays4(year, month) Since 3.7
                     # 해당 월의 1일과 말일을 포함하는 전체 주를 하루씩(year, month, day, weekday) 순회하는 iterator 반환
                monthdatescalendar(year, month)
                     # 해당 월의 1일과 말일을 포함하는 전체 주를 리스트로 반환. 리스트 각 요소는 datetime.date 7개를 갖는 리스트
                monthdayscalendar(year, month)
                     # 해당 월의 1일과 말일을 포함하는 전체 주를 리스트로 반환. 리스트 각 요소는 날짜 7개를 갖는 리스트. 해당 월에 포함되지 않는 날짜들은 0
                monthdays2calendar(year, month)
                     # 해당 월의 1일과 말일을 포함하는 전체 주를 리스트로 반환. 리스트 각 요소는 (day, weekday) 7개를 갖는 리스트. 해당 월에 포함되지 않는 day는 0
                yeardatescalendar(year, width=3)
                     # 가공하기 쉬운 형태로 1년을 반환한다. 예를 들어 yeardatescalendar(2017)은 4(=12/width) x 3(=width) x ? x 7의 리스트로 반환된다
                     # 전체 12개월을 4행 3열로 표현한 것으로, 각 월은 ?개 주로 구성되고, 각 주는 7개의 datetime.date 객체 리스트로 구성된다
                yeardayscalendar(year, width=3)
                     # yeardatescalendar()와 비슷. 각 주는 날짜들의 리스트. 각 월에 포함되지 않는 날짜들은 0
                yeardays2calendar(year, width=3)
                     # yeardatescalendar()와 비슷. 각 주는 (day, weekday)의 리스트. 각 월에 포함되지 않는 day는 0
        h2 class calendar.TextCalendar
        ul
            li class calendar.TextCalendar(firstweekday=0)
            p calendar.Calendar를 상속한다
            li class calendar.LocaleTextCalendar(firstweekday=0, locale=None)
            p formatweekday(), formatmonthname()은 현재 로캐일을 지정된 로캐일로 잠시 변경한다. 이는 전체 프로세스가 공유하므로, 스레드-안전하지 않다
            li 인스턴스 메서드
            +asCode('python').
                formatmonth(theyear, themonth, w=0, l=0)
                    # 해당 년월의 문자열 달력 반환. w는 각 일의 너비(가운데 정렬), l은 각 주의 라인 수
                formatyear(theyear, w=2, l=1, c=6, m=3)
                    # m열의 달력을 반환한다. w는 각 일의 너비(가운데 정렬), l은 각 주의 라인 수, c는 month column 사이의 공백 수
        h2 class calendar.HTMLCalendar
        ul
            li class calendar.HTMLCalendar(firstweekday=0)
            p calendar.Calendar를 상속한다
            li class calendar.LocaleHTMLCalendar(firstweekday=0, locale=None)
            p formatweekday(), formatmonthname()은 현재 로캐일을 지정된 로캐일로 잠시 변경한다. 이는 전체 프로세스가 공유하므로, 스레드-안전하지 않다
            li 클래스 속성
            ul
                li 여러 클래스를 지정하기 위해 'mon day w3-blue'와 같은 할당 가능
                li cssclasses
                p 각 요일에 추가되는 클래스. 기본값 ["mon", "tue", "wed", "thu", "fri", "sat", "sun"]
                li cssclass_noday Since 3.7
                p 각 월의 시작과 끝에 존재할 수 있는 빈칸들에 추가되는 클래스. 기본값 'noday'
                li cssclasses_weekday_head Since 3.7
                p 테이블 헤더 행에 사용할 요일 클래스. 기본값 cssclasses
                li cssclass_month_head Since 3.7
                p 기본값 'month'
                li cssclass_month Since 3.7
                p 각 월의 테이블에 추가될 클래스. 기본값 'month'
                li cssclass_year, cssclass_year_head Since 3.7
                p 기본값 'year'
            li 인스턴스 메서드
            ul
                li formatmonth(theyear, themonth, withyear=True)
                p 해당 년월의 달력을 HTML table로 반환. withyear가 True면 헤더에 포함
                li formatyear(theyear, width=3)
                p 해당 년의 달력을 HTML table로 반환. width는 각 행의 월 수
                li formatyearpage(theyear, width=3, css='calendar.css', encoding=None)


    h1 collections : 컨테이너
    div
        h2 class ChainMap(_collections_abc.MutableMapping) Since 3.3
        ul
            li class collections.ChainMap(*maps)
            ul
                li 여러 dict, 매핑을 한데 모아 갱신 가능한 view를 만든다
                li maps : 뷰 내부의 리스트로 저장된다. ─ self.maps = list(maps) or [{}]
                li __setitem__, __delitem__, popitem(), pop(), clear()는 self.maps[0]에만 적용된다
            li maps : __getitem__에서 리스트 순서대로 탐색하며, 변경 가능하다
            li new_child(m=None)
            p x.new_child(m) == ChainMap(m if m != None else {}, *x.maps)
            li parents
            p x.super() == ChainMap(*x.maps[1:])
        h2 class Counter(dict) Since 3.1
        ul
            li class collections.Counter([iterable-or-mapping])
            ul
                li def __init__(self, iterable=None, /, **kwds)
                p self.update(iterable, **kwds)
                li Counter는 없는 키에 대하여 KeyError를 발생하지 않고, 새로운 키를 추가하고 0을 반환한다
            li elements()
            p 각 원소들을 각 카운트만큼 반복하는 iterator를 반환한다
            li most_common([n])
            p 가장 많은 n개의 원소들을 개수와 함께 반환한다
            li update([iterable-or-mapping]) ↔ subtract()
            ul
                li ('gallahad') # iterable 각 요소 1씩 카운트
                li ({'red': 4, 'blue': 2}) # 각 value만큼 카운트
                li (cats=4, dogs=8) # 각 value만큼 카운트
        h2 deque
        ul
            li class collections.deque([iterable[, maxlen]])
            ul
                li iterable이 존재하면 좌→우 순서대로 append()
                li 스레드-안전, 메모리 효율적인 O(1)에 근접한 기능을 제공
                li list도 비슷한 기능을 제공하나, 고정 길이 연산에 적합하며, 길이가 바뀌는 연산은 O(n) 메모리 이동이 발생
                li maxlen이 주어졌다면 추가적인 삽입은 반대쪽 원소의 제거와 동시에 일어난다. 최근 n개만 관심 있는 경우 등에 유용
            li 삽입
            ul
                li append(x) + appendleft
                li extend(iterable) + extendleft
                li insert(i, x) Since 3.5
            li 삭제
            ul
                li clear()
                li pop() + popleft
                li remove(value)
            li copy() Since 3.5 : 얕은 복사
            li count(x) Since 3.2
            li index(x[, start[, stop]]) Since 3.5
            li reverse() Since 3.2 : 제자리에서 순서를 변경하고 None 반환
            li rotate(n=1) : n번 우로 이동(d.appendleft(d.pop())). 음수면 좌로 이동
            li maxlen Since 3.1 : 없으면 None
            p 이외에 iteration, pickling(Python 객체 직렬화), len(d), reversed(d), copy.copy(d), copy.deepcopy(d), in 연산자, index 접근(느림) 지원
            li Since 3.5 : __add__(), __mul__(), __imul__() 지원
        h2 defaultdict
        ul
            li class collections.defaultdict([default_factory[, ...]])
            ul
                li dict을 상속한다
                li 무인자 함수 default_factory(기본값 None)로 기본값을 제공한다
                p 예. 기본값으로 리스트 사용 → defaultdict(list)
                li 나머지 인자는 dict의 생성자에서 받아들이는 것과 동일하다
            li __missing__(key)
            p default_factory가 None이면 KeyError, 아니면 default_factory 호출
            li default_factory
        h2 namedtuple
        ul
            li collections.namedtuple(typename, field_names, *, rename=False, defaults=None, module=None)
            ul
                li 이름이 typename인 tuple의 서브클래스를 반환. 인스턴스들은 유용한 docstring과 __repr__()을 갖는다
                li filed_names
                p _fields 속성. 문자열의 시퀀스거나, 'x y'또는 'x, y'처럼 분리한 단일 문자열일 수 있다
                li rename Since 3.1
                p True면 유효하지 않은 필드명은 '_1'처럼 인덱스 이름으로 설정된다
                li defaults Since 3.7
                p _field_defaults 속성. None 아니면 iterable을 제공. 기본값의 수는 필드보다 적어도 되지만, 기본값을 갖는 필드들은 우측부터임에 유의
                li module Since 3.6
                p __module__ 속성
            li classmethod somenamedtuple._make(iterable)
            li somenamedtuple._asdict() : OrderedDict 반환
            li somenamedtuple._replace(**kwargs)
            p 값을 변경한 새 튜플 반환
            li getattr(somenamedtuple, 'attr_name') 가능
            li somenamedtuple(**somedict) 가능
            li class Sub(somenamedtuple): 가능
            li Since 3.5 : 생성된 클래스의 __doc__ 속성 쓰기 가능
        h2 class OrderedDict(dict) Since 3.1
        ul
            li class collections.OrderedDict([items])
            li popitem(last=True)
            li move_to_end(key, last=True) Since 3.2
            p last=True면 우측 끝으로, 아니면 왼쪽 끝으로
            li OrderedDict 객체끼리의 비교는 순서가 중요하지만, 다른 Mapping 객체와의 비교에서는 순서 상관없다
            li Since 3.5 : OrderedDict의 items, keys, values view들이 reversed() 지원
        h2 class UserDict(_collections_abc.MutableMapping)
        p dict를 상속하기 쉽게 만든 래퍼 클래스. self.data에 실제 dict가 존재
        h2 class UserList(_collections_abc.MutableSequence)
        p list를 상속하기 쉽게 만든 래퍼 클래스. self.data에 실제 list가 존재
        h2 class UserString(_collections_abc.Sequence)
        p str을 상속하기 쉽게 만든 래퍼 클래스. self.data에 실제 str이 존재


    h1 collections.abc : 컨테이너 ABC
    table.w3-table-all.w3-card.w3-small
        tr
            th ABC
            th 상속
            th Abstract Methods
            th Mixin Methods(재정의 안 해도 괜찮)
        tr
            td Container
            td
            td
                span.hover-content(template-id='template-python-collections-abc-contains') __contains__
            td
        tr
            td Hashable
            td
            td
                span.hover-content(template-id='template-python-collections-abc-hash') __hash__
            td
        tr
            td
                span.hover-content(template-id='template-python-collections-abc-iterable') Iterable
            td
            td
                span.hover-content(template-id='template-python-collections-abc-iter') __iter__
            td
        tr
            td Iterator
            td Iterable
            td
                span.hover-content(template-id='template-python-collections-abc-next') __next__
            td
                span.hover-content(template-id='template-python-collections-abc-iter') __iter__
        tr
            td Reversible
            td Iterable
            td
                span.hover-content(template-id='template-python-collections-abc-reversed') __reversed__
            td
        tr
            td Generator
            td Iterator
            td
                span.hover-content(template-id='template-python-collections-abc-send') send
                |,
                span.hover-content(template-id='template-python-collections-abc-throw') throw
            td
                span.hover-content(template-id='template-python-collections-abc-close') close
                |,
                span.hover-content(template-id='template-python-collections-abc-iter') __iter__
                |,
                span.hover-content(template-id='template-python-collections-abc-next') __next__
        tr
            td Sized
            td
            td
                span.hover-content(template-id='template-python-collections-abc-len') __len__
            td
        tr
            td Callable
            td
            td
                span.hover-content(template-id='template-python-collections-abc-call') __call__
            td
        tr
            td Collection Since 3.6
            td Sized, Iterable, Container
            td
                span.hover-content(template-id='template-python-collections-abc-contains') __contains__
                |,
                span.hover-content(template-id='template-python-collections-abc-iter') __iter__
                |,
                span.hover-content(template-id='template-python-collections-abc-len') __len__
            td
        tr
            td Sequence
            td Reversible, Collection
            td
                span.hover-content(template-id='template-python-collections-abc-getitem') __getitem__
                |,
                span.hover-content(template-id='template-python-collections-abc-len') __len__
            td
                span.hover-content(template-id='template-python-collections-abc-contains') __contains__
                |,
                span.hover-content(template-id='template-python-collections-abc-iter') __iter__
                |,
                span.hover-content(template-id='template-python-collections-abc-reversed') __reversed__
                |, index, count
        tr
            td MutableSequence
            td Sequence
            td
                span.hover-content(template-id='template-python-collections-abc-getitem') __getitem__
                |,
                span.hover-content(template-id='template-python-collections-abc-setitem') __setitem__
                |,
                span.hover-content(template-id='template-python-collections-abc-delitem') __delitem__
                |,
                span.hover-content(template-id='template-python-collections-abc-len') __len__
                |, insert
            td Sequence 상속 메서드, append, reverse, extend, pop, remove, and __iadd__
        tr
            td ByteString
            td Sequence
            td
                span.hover-content(template-id='template-python-collections-abc-getitem') __getitem__
                |,
                span.hover-content(template-id='template-python-collections-abc-len') __len__
            td Sequence 상속 메서드
        tr
            td Set
            td Collection
            td
                span.hover-content(template-id='template-python-collections-abc-contains') __contains__
                |,
                span.hover-content(template-id='template-python-collections-abc-iter') __iter__
                |,
                span.hover-content(template-id='template-python-collections-abc-len') __len__
            td __le__, __lt__, __eq__,__ne__, __gt__, __ge__,__and__, __or__, __sub__, __xor__, isdisjoint
        tr
            td MutableSet
            td Set
            td
                span.hover-content(template-id='template-python-collections-abc-contains') __contains__
                |,
                span.hover-content(template-id='template-python-collections-abc-iter') __iter__
                |,
                span.hover-content(template-id='template-python-collections-abc-len') __len__
                |, add, discard
            td Set 상속 메서드, clear, pop, remove,__ior__, __iand__, __ixor__, __isub__
        tr
            td Mapping
            td Collection
            td
                span.hover-content(template-id='template-python-collections-abc-getitem') __getitem__
                |,
                span.hover-content(template-id='template-python-collections-abc-iter') __iter__
                |,
                span.hover-content(template-id='template-python-collections-abc-len') __len__
            td
                span.hover-content(template-id='template-python-collections-abc-contains') __contains__
                |, keys, items,values, get, __eq__, __ne__
        tr
            td MutableMapping
            td Mapping
            td
                span.hover-content(template-id='template-python-collections-abc-getitem') __getitem__
                |,
                span.hover-content(template-id='template-python-collections-abc-setitem') __setitem__
                |,
                span.hover-content(template-id='template-python-collections-abc-delitem') __delitem__
                |,
                span.hover-content(template-id='template-python-collections-abc-iter') __iter__
                |,
                span.hover-content(template-id='template-python-collections-abc-len') __len__
            td Mapping 상속 메서드, pop, popitem, clear, update, setdefault
        tr
            td MappingView
            td Sized
            td
            td
                span.hover-content(template-id='template-python-collections-abc-len') __len__
        tr
            td ItemsView
            td MappingView, Set
            td
            td
                span.hover-content(template-id='template-python-collections-abc-contains') __contains__
                |,
                span.hover-content(template-id='template-python-collections-abc-iter') __iter__
        tr
            td KeysView
            td MappingView, Set
            td
            td
                span.hover-content(template-id='template-python-collections-abc-contains') __contains__
                |,
                span.hover-content(template-id='template-python-collections-abc-iter') __iter__
        tr
            td ValuesView
            td MappingView, Collection
            td
            td
                span.hover-content(template-id='template-python-collections-abc-contains') __contains__
                |,
                span.hover-content(template-id='template-python-collections-abc-iter') __iter__
        tr
            td Awaitable
            td
            td __await__
            td
        tr
            td Coroutine
            td Awaitable
            td send, throw
            td close
        tr
            td AsyncIterable
            td
            td __aiter__
            td
        tr
            td AsyncIterator
            td AsyncIterable
            td __anext__
            td __aiter__
        tr
            td AsyncGenerator
            td AsyncIterator
            td asend, athrow
            td aclose, __aiter__, __anext__
    p Set, MutableSet 믹스인 사용 시 유의사항
    ol
        li 몇몇 함수들은 iterable로부터 새로운 집합을 만들 필요가 있다. 이에 ClassName(iterable) 또는 @classmethod _from_iterable()이 필요
        li 집합 비교 연산을 재정의하려는 경우, __le__(), __ge__()만 재정의하면 된다
        li Set 믹스인은 집합에 대한 해시를 반환하는 _hash()를 기본 제공한다. 만약 집합이 해시-가능하고 불변하다면 Hashable도 상속하여 __hash__ = Set._hash 설정하면 된다
    +hoverTemplate()#template-python-collections-abc-contains
        |object.__contains__(self, item) : item을 포함하는지 여부
    +hoverTemplate()#template-python-collections-abc-hash
        |object.__hash__(self) : 해시값(int)
    +hoverTemplate()#template-python-collections-abc-len
        |object.__len__(self) : 아이템 개수
    +hoverTemplate()#template-python-collections-abc-call
        |object.__call__(self[, args...])
    +hoverTemplate()#template-python-collections-abc-iterable
        ul
            li isinstance(obj, Iterable) : Iterable로 등록되었거나 __iter__()를 가지면 True
            li iter(obj) :
                span.hover-content(template-id='template-python-collections-abc-getitem') __getitem__
                |()으로 순회하는 클래스도 감지 가능. 순회 가능하지 않으면 예외 발생
    +hoverTemplate()#template-python-collections-abc-iter
        |object.__iter__(self) : 컨테이너 순회를 위한 새 Iterator 인스턴스를 반환한다. Iterator 서브클래스는 self를 반환하면 된다
    +hoverTemplate()#template-python-collections-abc-reversed
        |object.__reversed__(self) : 반대 순서의 iterable 객체 반환
    +hoverTemplate()#template-python-collections-abc-next
        ul
            li iterator.__next__() : 다음 아이템 반환. 없으면 raise StopIteration
            li generator.__next__() : 제너레이터 함수 실행 시작/재개. yield문의 판정값은 항상 None. yield 없이 종료되면 자동으로 raise StopIteration
            li 보통 __next__()는 직접 호출하기보다는 for 루프, 내장 함수 next()의 호출로 암시적으로 호출된다
    +hoverTemplate()#template-python-collections-abc-send
        |generator.send(value) : 제너레이터 함수 실행 시작/재개
        ul
            li send()로 제너레이터 함수를 최초 실행하는 경우 value는 반드시 None이어야 한다. ← 대기중인 yield문이 없기 때문
            li value는 yield문의 판정값이 된다
            li 다음 yield 값은 send()의 리턴값이 된다
    +hoverTemplate()#template-python-collections-abc-throw
        |generator.throw(type[, value[, traceback]])
        ul
            li 현재 대기중인 yield 문의 위치에서 예외를 던진다
            li 예외를 잡은 다음의 yield값은 throw()의 리턴값이 된다
            li 더 이상의 yield 없이 종료되면 자동으로 raise StopIteration
            li 제너레이터에서 전달한 예외를 잡지 않거나 다른 예외를 던진 경우, 호출자에게 전달된다
    +hoverTemplate()#template-python-collections-abc-close
        |generator.close()
        ul
            li 현재 대기중인 yield 문의 위치에서 GeneratorExit 예외를 던진다
            li 예외를 잡고 종료하거나, 이미 종료됐거나, 예외를 잡지 않고 GeneratorExit를 던진 경우 close()는 종료된다
            li 제너레이터가 값을 yield하는 경우, RuntimeError가 발생한다
            li 제너레이터가 다른 예외를 던지는 경우, 호출자에게 전달된다
    +hoverTemplate()#template-python-collections-abc-getitem
        |object.__getitem__(self, key)
        ul
            li 식 self[key] 평가 시 호출된다
            li Sequence 타입의 경우 key는 정수 또는 slice 인스턴스여야 한다
            li __getitem__()을 이용하는 믹스인들은 그 성능이 종속됨에 유의
    +hoverTemplate()#template-python-collections-abc-setitem
        |object.__setitem__(self, key)
        ul
            li self[key]로 대입 시 호출된다
            li 유의사항은 __getitem__()과 동일
            li 값의 추가/변경이 필요한 경우에만 구현함이 바람직하다
    +hoverTemplate()#template-python-collections-abc-delitem
        |object.__delitem__(self, key)
        ul
            li self[del] 삭제 시 호출된다
            li 유의사항은 __getitem__()과 동일
            li 값의 제거가 필요한 경우에만 구현함이 바람직하다


    h1 heapq : 우선순위 큐
    ul
        li 부모 노드 &lt; 자식 노드인 힙을 이용한 큐
        li 인덱스 접근 heap[i] 가능
        p
            strong heapq 모듈은 명시적인 클래스를 제공하지 않음에 유의
            |  → 리스트 자체를 힙처럼 이용한다
        li 우선순위 큐 구현 시 유의사항
        ol
            li 우선순위가 동일할 때, 힙에 들어온 순서가 영향을 끼치는 지 여부
            p 예. 노드 속성에 삽입 순서를 추가
            li 이미 삽입된 노드의 우선순위가 도중에 변경된 경우 위치를 어떻게 옮길 것인지
            p 예. 기존 노드는 비활성화 처리하고, 새로 힙에 추가
    +asCode('python').
        heapq.heapify(x)
            # 리스트 x를 힙으로 제자리(in-place) 변환
        heapq.heappush(heap, item)
        heapq.heappop(heap)
            # heap[0] 노드를 제거하고 반환한다
        heapq.heappushpop(heap, item)
            # push 후 pop
        heapq.heapreplace(heap, item)
            # pop 후 push
        heapq.merge(*iterables, key=None, reverse=False)
            # 미리 오름차순 정렬된 여러 Iterable에 대해, 크기순으로 하나씩 순회하는 새 Iterable을 반환한다. reverse=True인 경우, 입력 Iterable들은 내림차순 정렬돼있어야 한다

        heapq.nsmallest(n, iterable, key=None) == sorted(iterable, key=key)[:n]
        heapq.nlargest(n, iterable, key=None) == sorted(iterable, key=key, reverseTrue)[:n]


    h1 bisect : 리스트 정렬 유지 삽입
    p 이분법을 이용하여, 리스트 정렬 순서를 유지한 채 삽입할 수 있도록 도와준다
    +asCode('python').
        bisect.bisect_left(a, x, lo=0, hi=len(a))
            # x를 삽입하기 적절한 위치 i를 반환한다
            #    all(val &lt; x for val in a[lo:i]), all(val >= x for val in a[i:hi]) 모두 성립한다
            # a : 대상 리스트
            # x : 삽입할 값
            # lo, hi : 검색 구간

        bisect.bisect_right(a, x, lo=0, hi=len(a))
            # all(val &lt;= x for val in a[lo:i]), all(val > x for val in a[i:hi])
            # == bisect.bisect

        bisect.insort_left(a, x, lo=0; hi=len(a))
            # == a.insert(bisect.bisect_left(a, x, lo, hi), x)
        bisect.insort_right(a, x, lo=0, hi=len(a))
            # == bisect.insort


    h1 array : 고효율 숫자 배열
    ul
        li list와 유사하게 동작하지만, 원소의 타입은 하나로 제한된다
        li 배열 생성 시 타입을 지정한다
    table.w3-table-all.w3-card.w3-small
        tr
            th Code
            th C type
            th Python type
            th Size
        tr
            td 'b'
            td signed char
            td int
            td 1
        tr
            td 'B'
            td unsigned char
            td int
            td 1
        tr
            td 'h'
            td signed short
            td int
            td 2
        tr
            td 'H'
            td unsigned short
            td int
            td 2
        tr
            td 'i'
            td signed int
            td int
            td 2
        tr
            td 'I'
            td unsigned int
            td int
            td 2
        tr
            td 'l'
            td signed long
            td int
            td 4
        tr
            td 'L'
            td unsigned long
            td int
            td 4
        tr
            td 'q'
            td signed long long
            td int
            td 8
        tr
            td 'Q'
            td unsigned long long
            td int
            td 8
        tr
            td 'f'
            td float
            td float
            td 4
        tr
            td 'd'
            td double
            td float
            td 8
    div
        h2 class array.array
        ul
            li class array.array(typecode[, initializer])
            p initializer : list, bytes-like object, iterable 중 하나를 보내면 fromlist(), frombytes() 등으로 초기화된다
            li 모듈 속성
            ol
                li array.typecodes
                p 유효 타입 코드들로 구성된 문자열
            li 인스턴스 속성(읽기 전용)
            ol
                li array.typecode
                li array.itemsize : 요소 하나의 바이트 크기
            li 인스턴스 메서드
            +asCode('python').
                array.buffer_info()
                    # (address, length) 반환. 반환된 값은 배열이 삭제되지 않고, 길이가 변경되지 않은 동안 유효
                array.byteswap()
                    # 배열 각 요소들의 바이트 순서를 뒤집는다. array.itemsize가 1, 2, 4, 8인 경우만 작동
                array.extend(iterable)
                    # 배열 끝에 순서대로 추가. 인자가 배열인 경우, 타입이 동일해야만 작동한다
                array.fromfile(f, n)
                    # ↔ tofile(f)
                    # file 인스턴스 f로부터 n개의 machine value를 읽어 배열의 끝에 순서대로 추가. 요소가 n개보다 적은 경우 배열에 추가는 되지만 EOFError 발생
                array.frombytes(s)
                    # Since 3.2 ↔ tobytes()
                    # 문자열을 machine value로 읽어 배열 끝에 순서대로 추가
                array.fromlist(list) ↔ tolist()
                    # list 전체 요소의 타입이 삽입 가능하다면, 순서대로 배열 끝에 추가
                array.index(x)
                array.count(x)
                array.remove(x)
                array.insert(i, x)
                array.pop([i])
                array.reverse()


    h1 weakref : 약한 참조
    ul
        li 직접적인 약한 참조 생성이 불가능한 list, dict 등의 내장 자료형은 상속함으로써 약한 참조 가능하게 만들 수 있다
        li CPython : tuple, int 등은 상속해도 약한 참조 불가능하다
        li referent ::= 약한 참조가 참조하는 객체
    div
        h2 class weakref.ref
        ul
            li class weakref.ref(object[, callback])
            ol
                li object에 대한 약한 참조를 반환한다
                li object가 무효하게 되면 약한 참조는 None을 반환한다
                li callback이 제공된 경우, object가 해제될 때 호출된다
                li 동일 객체에 대해 여러 약한 참조가 만들어진 경우, callback은 최신 것부터 순서대로 호출된다
                li object가 해시 가능하면 약한 참조도 그러하다
                p object가 유효한 동안 약한 참조에 대해 hash()가 호출된 경우, 반환된 값은 object가 해제되도 유지된다
                li 약한 참조 사이의 동등 비교가 가능하다
                p referent가 해제된 경우엔 두 약한 참조의 referent가 동일한 경우에만 True
                li 이 클래스는 상속 가능하다
            li __callback__ Since 3.4
            p 읽기 전용 속성
        h2 class weakref.WeakKeyDictionary + WeakValueDictionary
        ul
            li class weakref.WeakKeyDictionary([dict])
            ol
                li key를 약하게 참조하는 Mapping 클래스
                li key가 무효하게 되면 해당 entry는 제거된다
                li WeakKeyDictionary 순회 중 매핑 크기가 변경되는 경우 엔트리가 사라지는 마법이 발생할 수 있다
            li WeakKeyDictionary.keyrefs()
            li WeakValueDictionary.valuerefs()
        h2 class weakref.WeakSet
        ul
            li class weakref.WeakSet([elements])
            ol
                li 원소를 약하게 참조하는 Set 클래스
                li 원소가 무효하게 되면 집합에서 제거된다
        h2 class weakref.WeakMethod Since 3.4
        ul
            li class weakref.WeakMethod(method)
            ol
                li 인스턴스 메서드를 위한 weakref.ref 서브클래스
                li 반환된 약한 참조를 호출하면 method가 반환된다
        h2 class weakref.finalize
        ul
            li class weakref.finalize(obj, func, *args, **kwargs)
            ol
                li obj가 쓰레기 수집되면 호출될 소멸자를 반환한다
                p 따라서 func, args, kwargs는 obj의 참조를 갖지 않아야 한다
                li 소멸자는 단 한번만 호출 가능하며, 결과로 func(*args, **kwargs)를 반환한다. 그 외엔 None
            li alive
            p 소멸자의 유효 여부
            li __call__()
            p 수동 호출. alive가 True면 False로 설정하고 func(*args, **kwargs) 반환. 그 외엔 None
            li detach()
            p alive가 True면 False로 설정하고 (obj, func, args, kwargs) 반환. 그 외엔 None
            li peek()
            p alive가 True면 (obj, func, args, kwargs) 반환. 그 외엔 None
            li atexit Since 3.4
            p 쓰기 가능 boolean 속성. true인 경우 프로그램 정상 종료 시 호출된다
        h2 모듈 속성, 함수
        ul
            li weakref.proxy(object[, callback])
            ol
                li object에 대한 프록시를 반환한다. callback은 weakref.ref의 것과 동일한 의미다
                li 참조 시마다 object를 가져오는 weakref.ref와 다르게, 프록시는 그 자체로써 취급되며, 따라서 확장이 용이하다
                li object가 callable인지 여부에 따라 반환되는 프록시의 타입은 CallableProxyType, ProxyType 둘 중 하나가 된다
            li weakref.getweakrefcount(object)
            p object에 대한 약한 참조, 프록시의 개수를 반환
            li weakref.getweakrefs(object)
            p object에 대한 약한 참조, 프록시들을 list로 반환
            li weakref.ReferenceType : 약한 참조 객체임을 나타내는 타입
            li weakref.ProxyType : Non callable 객체에 대한 프록시 객체임을 나타내는 타입
            li weakref.CallableProxyType : Callable 객체에 대한 프록시 객체임을 나타내는 타입
            li weakref.ProxyTypes : 가능한 모든 프록시 타입을 포함한 Sequence


    h1 types : 동적 타입 생성
    div
        h2 Coroutine Utility Functions
        p types.coroutine(gen_func) : generator 함수를 기반으로 한 coroutine 함수 반환


    h1 copy
    ol
        li copy.copy(x) : 얕은 복사
        li copy.deepcopy(x[, memo])
        p memo 딕셔너리에 등록된 객체들은 복사 시 건너뛴다


    h1 enum
    ul
        li enum 클래스는 그 자체로 순회 가능하다
        li enum 클래스 멤버는 해시 가능하다
    ol
        li class enum.Enum : 베이스 클래스
        +asCode('python').
            class RGB(enum.Enum):
                R = enum.auto()
                G = enum.auto()
                B = enum.auto()
            print(RGB(2) == RGB.B)
            print(RGB['B'] == RGB.B)
            print(RGB.B.name == 'B')
            print(RGB.B.value == 2)
        ul
            li Enum 클래스 자체도 callable이다
            +asCode('python').
                Animal = Enum('Animal', 'ANT BEE CAT DOG')
                # 이렇게 생성한 enum 클래스의 모듈을 특정할 수 없는 경우, pickling/unpickling 불가
        li class enum.IntEnum : int 상속
        li class enum.IntFlag Since 3.6 : int 상속 + 비트 연산 가능
        li class enum.Flag Since 3.6 : 비트 연산 가능
        li class enum.auto Since 3.6 : 자동 할당
        p auto의 동작은 _generate_next_value_(name, start, count, last_values)를 재정의하여 변경할 수 있다
        li enum.unique() : 일대일 대응 검증 클래스 데커레이터


    h1 math, cmath
    div
        h2 math : 실함수
        table.w3-table-all.w3-card.w3-small
            tr
                th 함수
                th 기능
            tr
                td ceil(x)
                td x보다 작지 않은 최소 정수. 식[\lceil{x}\rceil]식
            tr
                td floor(x)
                td x보다 크지 않은 최대 정수. 식[\lfloor{x}\rfloor]식
            tr
                td trunc(x)
                td 정수부 반환
            tr
                td modf(x)
                td x의 (소수부, 정수부) 반환
            tr
                td comb(n, k)
                td 조합. 식[\begin{pmatrix}n \\ r\end{pmatrix}={n! \over r!(n-r)!}]식
            tr
                td perm(n, k=None)
                td 순열. 식[{}_n P_{k}={n! \over (n-k)!}]식
            tr
                td copysign(x, y)
                td 식[|x| {y \over |y|}]식
            tr
                td fabs(x)
                td |x|
            tr
                td factorial(x)
                td x가 음이 아닌 정수일 때만 x!
            tr
                td fmod(x, y)
                td C 라이브러리대로 동작
                    br
                    ||x - n*y| &lt; |y|를 만족하는 정수 n을 찾고 그 나머지(부호는 x와 동일)를 반환
            tr
                td remainder(x, y) Since 3.7
                td x / y 값을 half-even으로 반올림한 정수 n에 대하여, x - n*y 반환. 정밀도는 IEEE-754
            tr
                td frexp(x)
                td 식[x = m2^e]식를 만족하는 실수 m, 정수 e의 튜플 반환. x != 0이면 식[0.5 \le |m| &lt; 1]식
            tr
                td ldexp(x, i)
                td Inverse of frexp(), 식[x2^i]식
            tr
                td fsum(iterable)
                td 정밀도는 IEEE-754, 반올림 모드는 half-even
            tr
                td prod(iterable, *, start=1) Since 3.8
                td iterable 모두 곱하여 반환
            tr
                td gcd(a, b) Since 3.5
                td 0이 아닌 정수 a, b에 대해, 양의 최대공약수 반환
            tr
                td isclose(a, b, *, rel_tol=1e-09, abs_tol=0.0) Since 3.5
                td a, b가 충분히 가까운지 여부
                    br
                    |rel_tol는 절대값이 더 큰쪽에 적용될 최대 허용 오차 비율
            tr
                td isfinite(x)
                td NaN, infinity가 아닌지 여부
            tr
                td isinf(x)
                td infinity인지 여부
            tr
                td isnan(x)
                td NaN인지 여부
            tr
                td exp(x)
                td 식[e^x]식, math.e ** x보다 정확
            tr
                td expm1(x) Since 3.2
                td exp(x)-1보다 정확한 식[e^x-1]식
            tr
                td log(x[, base])
                td base 기본값은 e
            tr
                td log1p(x)
                td 식[\operatorname{ln}(1+x)]식
            tr
                td log2(x) Since 3.3
                td log(x, 2)보다 정확한 식[\log_{2}x]식
            tr
                td log10(x)
                td log(x, 10)보다 정확한 식[\log_{10}x]식
            tr
                td pow(x, y)
                td 정수 거듭제곱엔 **가 정확
            tr
                td sqrt(x)
                td 식[\sqrt{x}]식
            tr
                td isqrt(x) Since 3.8
                td 식[\lfloor \sqrt{n} \rfloor]식. 식[\lceil \sqrt{n} \rceil]식를 원한다면 1 + isqrt(n-1)
            tr
                td dist(p, q) Since 3.8
                td 같은 차원의 두 점 p, q 사이의 거리 반환
            tr
                td sin(x), cos(x), tan(x), asin(x), acos(x), atan(x)
                td 삼각함수 및 역삼각함수
            tr
                td atan2(y, x)
                td atan(y / x)
            tr
                td sinh(x), cosh(x), tanh(x), asinh(x), acosh(x), atanh(x)
                td 쌍곡선함수 및 역쌍곡선함수
            tr
                td degrees(x)
                td 라디안 x를 육십분법으로
            tr
                td radians(x)
                td 육십분법 x를 라디안으로
            tr
                td hypot(*coordinates)
                td Euclidean norm; sqrt(sum(x**2 for x in coordinates))
            tr
                td 이하 생략
                td
        h2 cmath : 복소함수
        p int, float, complex 및 __complex__() 소지 객체, __float__() 소지 객체들이 인자로 가능하다
        table.w3-table-all.w3-card.w3-small
            tr
                th 함수
                th 기능
            tr
                td phase(x)
                td == atan2(x.imag, x.real)
            tr
                td polar(x)
                td == (abs(x), phase(x))
            tr
                td rect(r, phi)
                td polar의 역함수. == r * (math.cos(phi)) + math.sin(phi) * 1j
            tr
                td 이하 생략
                td


    h1 decimal : 정확한 10진수 연산
    ul
        li 유효숫자 개념을 고려한다. 기본 유효숫자는 28자리며, 변경 가능하다. decimal.getcontext().prec = 999999
        li 반올림 모드 : decimal.ROUND_DOWN, ROUND_05UP, ROUND_UP, ROUND_HALF_DOWN, ROUND_HALF_EVEN, ROUND_HALF_UP, ROUND_FLOOR, ROUND_CEILING
        li 생성자에서는 유효숫자의 제한이 없으며, 따라서 반올림도 수행되지 않는다
        li (-7) % 4 == 1, Decimal(-7) % Decimal(4) == Decimal(-3)
        li -7 // 4 == -2, Decimal(-7) // Decimal(4) == Decimal(-1)
    div
        h2 class decimal.Decimal
        ul
            li Decimal 인스턴스는 불변 객체다. 각 연산마다 새 Decimal 인스턴스가 생성된다
            li class decimal.Decimal(value="0", context=None)
            p 문자열, 튜플(sign_number, tuple_of_digits, int_exponent)로도 생성 가능
            li 인스턴스 메서드
            ul
                li adjusted() : 최고 자리수(10^n)의 자리값(n)을 반환
                li as_integer_ratio() Since 3.6 : 기약분수의 (분자, 분모) 반환
                li as_tuple() : (sign, digits, exponent)
                li copy_abs(), copy_negate(), copy_sign(other, context=None)
                li quantize(exp, rounding=None, context=None)
                p Decimal('7.325').quantize(Decimal('.01'), rounding=ROUND_DOWN) == Decimal('7.32')
                li 이하 생략


    h1 random, secrets : 난수
    div
        h2 random : 암호적으로 안전하지 않은 의사 난수 생성기
        ul
            li Bookkeeping functions
            ul
                li seed(a=None, version=2) : 시드 설정. a를 지정하지 않은 경우 시스템 시각 사용
                li getrandbits(k) : k개 비트로 구성된 int 반환
            li Functions for integers
            ul
                li randrange(stop), randrange(start, stop[, step])
                li randint(a, b)
            li Functions for sequences
            ul
                li choice(seq)
                li choices(population, weights=None, *, cum_weights=None, k=1) Since 3.6
                ul
                    li weights : population 각 요소별 가중치
                    li cum_weights : population 각 요소별 누적 가중치
                    li k : 뽑을 요소 수. 복원 추출
                li shuffle(x[, random])
                p x를 제자리에서 섞는다. random은 [0.0, 1.0)을 반환하는 무인자 함수
                li sample(population, k) : 비복원 추출
            li Real-valued distributions
            ul
                li random() : [0.0, 1.0)
                li uniform(a, b) : [a, b]
                li gauss(mu, sigma)
                li gammavariate(alpha, beta)
                li betavariable(alpha, beta)
                li 이하 생략
        h2 secrets Since 3.6 : 암호적으로 안전한 난수 생성기
        ul
            li randbits(k)
            li randbelow(n) : [0, n)
            li choice(sequence)
            li token_bytes([nbytes=None]), token_hex([nbytes=None]), token_urlsafe([nbytes=None])


    h1 statistics : 통계
    ul
        li 별다른 표시가 없다면 각 함수들은 int, float, Decimal, Fraction 모두 인자로 지원
        p 다른 타입들을 인자로 이용하려는 경우 map() 따위로 조정 필요
        li 대표값
        ul
            li mean(data) : 산술 평균. data는 Iterable
            li fmean(data) : 빠른 float 산술 평균. data는 Iterable
            li geometric_mean(data) Since 3.8 : 기하 평균. data는 Iterable
            li harmonic_mean(data) Since 3.6 : 조화 평균. data는 Iterable
            li median(data) : 중앙값. data는 Iterable
            +asCode('python').
                median([1, 3, 5, 7]) == 4.0
                median_low([1, 3, 5, 7]) == 3
                median_high([1, 3, 5, 7]) == 5
            li median_grouped(data, interval=1)
            +asCode('python').
                median = L + interval*(N/2 - CF)/F
                # L = the lower limit of the median interval
                # N = the total number of data points
                # CF = the number of data points below the median interval
                # F = the number of data points in the median interval
            li mode(data) : 최빈값. data는 이산하다고 가정되는 Iterable. data 요소의 타입은 제한되지 않는다
            li multimode(data) Since 3.8 : 최빈값 리스트 반환
            li quantiles(data, *, n=4, method='exclusive') Since 3.8
            p data를 n개 구간으로 나누어, 각 구간이 모두 같은 개수의 표본을 갖도록 하는 구분점들의 리스트를 반환한다
        li 분산
        ul
            li pstdev(data, mu=None) : 표준편차
            li pvariance(data, mu=None) : 분산
            li stdev(data, xbar=None) : 표본표준편차
            li variance(data, xbar=None) : 표본분산
        h2 class statistics.NormalDist
        ul
            li statistics.NormalDist(mu=0.0, sigma=1.0)
            li classmethod from_samples(data)
            li 이하 생략


    h1 itertools
    ul
        li starmap(function, iterable)
        p (function(*args) for args in iterable)과 의미상 동일
        li accumulate(iterable[, func, *, initial=None]) Since 3.2
        p 연산을 누적하여 최종 결과를 반환한다. 기본 연산은 +
        li chain(*iterables)
        p 전체 iterables를 순서대로 순회하는 Iterator 반환
        li chain.from_iterable(iterable)
        p iterable은 Iterable로 구성된 Iterable. 기능은 chain()과 동일
        li tee(iterable, n=2)
        p iterable의 요소를 순회하는 n개의 독립적인 Iterator 반환
        li zip_longest(*iterables, fillvalue=None)
        p 내장함수 zip()과 다르게 모든 iterables의 순회가 끝날때까지 순회. 값이 없는 경우 fillvalue 사용
        li combinations(iterable, r)
        p iterable 요소로 구성할 수 있는 크기 r의 조합(비복원 추출)을 순회하는 Iterator 반환. 실제 값이 같지만 위치가 다른 두 요소를 다르다고 간주함에 유의
        li combinations_with_replacement(iterable, r)
        p iterable 요소로 구성할 수 있는 크기 r의 조합(복원 추출)을 순회하는 Iterator 반환. 실제 값이 같지만 위치가 다른 두 요소를 다르다고 간주함에 유의
        li permutations(iterable, r=None)
        p iterable 요소로 구성할 수 있는 크기 r(기본값 len(iterable))의 순열(비복원 추출). 실제 값이 같지만 위치가 다른 두 요소를 다르다고 간주함에 유의
        li count(start=0, step=1)
        p step씩 증가하는 무한 등차수열
        li cycle(iterable)
        p iterable 요소를 무한히 반복하는 Iterator 반환
        li repeat(object[, times])
        p object를 times번 순회하는 Iterator 반환. times가 지정되지 않은 경우 무한 반복. 불필요한 동일 객체를 여러번 만들지 않게 해준다
        li product(*iterables, repeat=1)
        p 순서쌍을 순회하는 Iterator 반환. 예를 들어 product(i1, i2) == ((x, y) for x in i1 for y in i2)
        li islice(iterable, stop)
            br
            |islice(iterable, start, stop[, step])
        ol
            li 지정된 범위에 속하는 요소들만 순회하는 Iterator 반환
            li 일반적인 슬라이스와 달리 음수 인덱싱을 지원하지 않는다
            li stop이 None이면 iterable 끝까지 평가
        li dropwhile(predicate, iterable)
        p predicate을 만족하지 않는 선두 요소들은 순회 생략
        li takewhile(predicate, iterable)
        p predicate을 만족하는 선두 요소들만 순회
        li filterfalse(predicate, iterable)
        p predicate을 만족하지 않는 요소들만 순회
        li compress(data, selectors)
        p 의미상 (d for d, s in zip(data, selectors) if s)과 동일
        li groupby(iterable, key=None)
        ul
            li key : 각 요소에 대해 그루핑 키를 계산하는 함수. 없으면 lambda x: x가 이용된다
            li iterable이 key에 대해 정렬되어 있다면, SQL의 group by와 같은 효과를 얻을 수 있다
            li groupby로 반환되는 객체는 (group_key, group_iterable)을 순회하는 Iterator
        +asCode('python').
            [(x[0], [y for y in x[1]]) for x in itertools.groupby([1, 2, 2, 3, 3, 3, 1, 1, 1, 1])]
                # [(1, [1]), (2, [2, 2]), (3, [3, 3, 3]), (1, [1, 1, 1, 1])]

            [(x[0], [y for y in x[1]]) for x in itertools.groupby([1, 2, 2, 3, 3, 3, 1, 1, 1, 1], key=lambda x: x%2)]
                # [(1, [1]), (0, [2, 2]), (1, [3, 3, 3, 1, 1, 1, 1])]


    h1 functools : 고계함수
    ul
        li @cached_property(func) Since 3.8
        ul
            li 인스턴스 메서드를 동일한 이름의 프로퍼티로 만든다
            p 따라서 인스턴스의 __dict__에 접근할 수 있어야 한다
            li 최초 프로퍼티 접근 시 실행된 반환값이 프로퍼티의 값으로 고정된다
        li cmp_to_key(func) Since 3.2
        p 인자 2개를 먹고 int를 반환하는 비교 함수를 인자 1개를 먹고 정렬키를 반환하는 함수로 변환해 반환한다
        li @lru_cache(user_function)
            br
            |@lru_cache(maxsize=128, typed=False)
        ul
            li 메서드 인자에 대한 리턴값을 캐시해준다
            p 메서드 모든 인자는 해시 가능해야 한다
            li 메서드 인자의 순서에 유의
            p f(a=1, b=2)와 f(b=2, a=1)의 호출을 서로 다르다고 간주할 수 있다
            li maxsize는 2의 거듭제곱일 때 최고 성능으로 작동된다. None이면 무제한
            li typed가 True인 경우, f(3)과 f(3.0)은 서로 다른 캐시 아이템이 된다
            li 래핑된 함수는 cache_info() 메서드를 가지며, 이는 캐시 적중률, 실패율 등을 반환한다
            li 래핑된 함수는 cache_clear() 메서드를 가지며, 이는 캐시 상태를 초기화한다
            li 래핑된 함수는 __wrapped__ 속성으로 기존 함수를 보존한다
            p 따라서 같은 함수에 대해 여러 캐시를 두게 할 수도 있다
        li @total_ordering Since 3.2
        ul
            li 클래스에 비교연산을 일부만 정의하면 나머지는 자동으로 채워준다
            p __lt__(), __le__(), __gt__(), __ge__() 중 하나는 필수, __eq__()가 필요할 수도
        li partial(func, /, *args, **keywords)
        ul
            li 인자 일부를 고정시킨 부분 함수를 반환한다
            li func, args, keywords 각각은 반환된 객체의 속성이 된다
            li 부분 함수 호출에 제공된 positional 인자들은 args 뒤에 순서대로 붙고, keyword 인자들은 keywords를 override한다
        li class partialmethod(func, /, *args, **keywords) Since 3.4
        p 메서드의 인자 일부를 고정시켜 반환한다. func는 descriptor 또는 callable
        li reduce(function, iterable[, initializer])
        li @singledispatch
        p 함수의 오버로딩을 가능하게 해준다. 최소 한 개의 positional 인자가 필요하며, 이 인자의 타입을 기준으로 호출을 나눈다
            +codeBtn('/Repositories/Python/Library/functools_singledispatch.py', 'python') 예시 코드 »
        li class singledispatchmethod(func) Since 3.8
        p 메서드의 오버로딩을 가능하게 해준다. @singledispatch 참고
        li update_wrapper(wrapper, wrapped, assigned=WRAPPER_ASSIGNMENTS, updated=WRAPPER_UPDATES)
            br
            |@wraps(wrapped, assigned=WRAPPER_ASSIGNMENTS, updated=WRAPPER_UPDATES)
        p 래핑된 함수를 래핑 전 함수처럼 보이도록 변경한다
            +codeBtn('/Repositories/Python/Library/functools_wraps.py', 'python') 예시 코드 »


    h1 operator : 표준 연산
    ul
        li 파이썬 표준 연산자들에 대응하는 함수들을 제공한다
        p 많은 경우 lt(a, b), __lt__(a, b)처럼 '__'가 붙은 것과 붙지 않은 것 모두 제공한다
        li 비교 연산
        p lt(a, b), le(a, b), eq(a, b), ne(a, b), ge(a, b), gt(a, b)
        li 논리 연산
        p not(obj), truth(obj), is_(a, b) # a is b, is_not(a, b) # a is not b
        li 산수 연산
        p abs(obj), add(a, b), and_(a, b), fllordiv(a, b), index(a), inv(obj) == invert(obj), lshift(a, b), mod(a, b), mul(a, b), matmul(a, b) # a @ b, neg(obj), or_(a, b), pos(obj), pow(a, b), rshift(a, b), sub(a, b), truediv(a, b), xor(a, b)
        li Sequence 연산
        p concat(a, b), contains(a, b), countOf(a, b), delitem(a, b), getitem(a, b), indexOf(a, b), setitem(a, b, c), length_hint(obj, default=0)
        li Lookup
        p attrgetter(attr), attrgetter(*attrs), itemgetter(item), itemgetter(*items), methodcaller(name, /, *args, **kwargs)
        li 복합 연산
        p iadd, iand, iconcat, ifllordiv, ilshift, imod, imul, imatmul, ior, ipow, irshift, isub, itruediv, ixor
    table.w3-table-all.w3-card.w3-small
        tr
            th Operation
            th Syntax
            th Function
        tr
            td Addition
            td a + b
            td add(a, b)
        tr
            td Concatenation
            td seq1 + seq2
            td concat(seq1, seq2)
        tr
            td Containment Test
            td obj in seq
            td contains(seq, obj)
        tr
            td Division
            td a / b
            td truediv(a, b)
        tr
            td Division
            td a // b
            td floordiv(a, b)
        tr
            td Bitwise And
            td a & b
            td and_(a, b)
        tr
            td Bitwise Exclusive Or
            td a ^ b
            td xor(a, b)
        tr
            td Bitwise Inversion
            td ~ a
            td invert(a)
        tr
            td Bitwise Or
            td a | b
            td or_(a, b)
        tr
            td Exponentiation
            td a ** b
            td pow(a, b)
        tr
            td Identity
            td a is b
            td is_(a, b)
        tr
            td Identity
            td a is not b
            td is_not(a, b)
        tr
            td Indexed Assignment
            td obj[k] = v
            td setitem(obj, k, v)
        tr
            td Indexed Deletion
            td del obj[k]
            td delitem(obj, k)
        tr
            td Indexing
            td obj[k]
            td getitem(obj, k)
        tr
            td Left Shift
            td a &lt;&lt; b
            td lshift(a, b)
        tr
            td Modulo
            td a % b
            td mod(a, b)
        tr
            td Multiplication
            td a * b
            td mul(a, b)
        tr
            td Matrix Multiplication
            td a @ b
            td matmul(a, b)
        tr
            td Negation (Arithmetic)
            td - a
            td neg(a)
        tr
            td Negation (Logical)
            td not a
            td not_(a)
        tr
            td Positive
            td + a
            td pos(a)
        tr
            td Right Shift
            td a >> b
            td rshift(a, b)
        tr
            td Slice Assignment
            td seq[i:j] = values
            td setitem(seq, slice(i, j), values)
        tr
            td Slice Deletion
            td del seq[i:j]
            td delitem(seq, slice(i, j))
        tr
            td Slicing
            td seq[i:j]
            td getitem(seq, slice(i, j))
        tr
            td String Formatting
            td s % obj
            td mod(s, obj)
        tr
            td Subtraction
            td a - b
            td sub(a, b)
        tr
            td Truth Test
            td obj
            td truth(obj)
        tr
            td Ordering
            td a &lt; b
            td lt(a, b)
        tr
            td Ordering
            td a &lt;= b
            td le(a, b)
        tr
            td Equality
            td a == b
            td eq(a, b)
        tr
            td Difference
            td a != b
            td ne(a, b)
        tr
            td Ordering
            td a >= b
            td ge(a, b)
        tr
            td Ordering
            td a > b
            td gt(a, b)


    h1 shutil : 고수준 파일 연산
    ul
        li make_archive(base_name, format[, root_dir[, base_dir[, verbose[, dry_run[, owner[, group[, logger]]]]]]])
        ul
            li base_name : 확장자 미포함 압축 파일 path
            li format : 'zip', 'tar', 'gztar', 'bztar', 'xztar'
            li root_dir : 압축 파일의 최상위 디렉터리. 기본값은 현재 디렉터리
            li base_dir : 압축 시작 디렉터리. 기본값은 현재 디렉터리
            li shutil.make_archive 이벤트 발생
        li get_archive_formats()
        p 가능한 압축 포맷 반환
        li unpack_archive(filename[, extract_dir[, format]])
        li get_unpack_formats()
        li copyfileobj(fsrc, fdst[, length])
        ul
            li fsrc : file-like source
            p 주의. fsrc의 현재 위치부터 복사를 시작함
            li fdst : file-like destination
            li length : buffer size
        li copyfile(src, dst, *, follow_symlinks=True)
        ul
            li src : path-like source
            li dst : path-like destination
            p 붙여넣을 파일명을 정확히 포함해야 한다
            li shutil.copyfile 이벤트 발생
        li copymode(src, dst, *, follow_symlinks=True)
        ul
            li 파일 권한 비트 복사
            li src : path-like source
            li dst : path-like destination
            li shutil.copymode 이벤트 발생
        li copystat(src, dst, *, follow_symlinks=True)
        ul
            li 파일 권한 비트, 마지막 접근 시각, 마지막 수정 시각 등 복사
            li src : path-like source
            li dst : path-like destination
            li shutil.copystat 이벤트 발생
        li copy(src, dst, *, follow_symlinks=True)
        ul
            li copyfile + copymode
            p copyfile과 다르게 dst는 디렉터리를 가리켜도 된다
            li shutil.copyfile, shutil.copymode 이벤트 발생
        li copy2(src, dst, *, follow_symlinks=True)
        ul
            li copyfile + copystat
            p copyfile과 다르게 dst는 디렉터리를 가리켜도 된다
            li shutil.copyfile, shutil.copystat 이벤트 발생
        li copytree(src, dst, symlinks=False, ignore=None, copy_function=copy2, ignore_cangling_symlinks=False, dirs_exist_ok=False)
        ul
            li dirs_exist_ok : 붙여넣을 디렉터리의 일부가 이미 존재해도 괜찮은지
            li ignore : 디렉터리, os.listdir()를 인자로 받아 생략할 이름들의 집합을 반환하는 함수
            li shutil.copytree 이벤트 발생
        li ignore_patterns(*patterns)
        p glob-style 패턴들을 인자로 받아 copytree()의 ignore에 사용할만한 함수를 반환
        li rmtree(path, ignore_errors=False, onerror=None)
        p shutil.rmtree 이벤트 발생
        li move(src, dst, copy_function=copy2)
        p 파일 또는 디렉터리를 옮긴다. shutil.move 이벤트 발생
        li chown(path, user=None, group=None)
        p shutil.chown 이벤트 발생
        li which(cmd, mode=os.F_OK | os.X_OK, path=None)
        p cmd를 실행하게 될 실행 파일의 path 반환. 없으면 None
