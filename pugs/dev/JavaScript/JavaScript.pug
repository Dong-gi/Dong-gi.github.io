include ../../../source/skeleton.pug

+post({
    title: 'JavaScript',
    description: 'JavaScript(ECMAScript) 정리',
})

    h1 자료
    ul
        li: +asA('https://developer.mozilla.org/en-US/docs/Learn/JavaScript', 'MDN > JavaScript 배우기')
        li: +asA('https://web.dev/learn/javascript', 'web.dev > JavaScript 배우기')

    h1 JavaScript 역사
    div
        h2 참고자료
        ul
            li: +asA('https://dzone.com/articles/a-brief-history-of-javascript')
            li: +asA('https://en.wikipedia.org/wiki/JavaScript')

        h2 현재
        p JavaScript는 ECMAScript 표준을 준수하는 고급 프로그래밍 언어로, JIT 컴파일로 실행되는 스크립트 언어

        h2 넷스케이프의 창조
        ul
            li 1995년. 동적 웹 콘텐츠 개발을 위해 DOM과 상호작용할 수 있는 프로그래밍 언어를 추가하기 위한 결정이 이루어졌다
            li 넷스케이프의 "브라우저를 위한 Scheme" 개발 프로젝트에 JavaScript의 아버지 Brendan Eich도 있었다
            p Scheme은 Lisp의 방언 중 하나
            ul
                li 당시 이미 넷스케이프와 썬 마이크로시스템즈는 브라우저에서 Java를 사용(자바 애플릿)할 수 있도록 계약을 체결하려는 시점이었다
                li 따라서 새로운 언어(개발명 Mocha)를 추가하는 목적은 프로그램 개발이 아니라, HTML 안에서 동적으로 애니메이션 추가, 디자인 변경 등을 수행하는 것(작은 스크립팅 작업)이었으며, 전문 개발자가 아닌 HTML을 작성할 줄 아는 디자이너와 같은 사람들이 타깃 유저층이었다
                li 즉, Mocha는 Java의 스크립팅 동반자가 되어야 했다. 이를 위해 Java와 유사한 구문들이 채택되었고, Scheme으로부터 멀어진 모습을 갖게 되었다
            li 1995년 9월 베타 출시하면서 LiveScript로 이름 변경
            li 1995년 12월 정식 출시하면서 JavaScript로 이름 변경 (썬 마이크로시스템즈와 합의)

        h2 마이크로소프트의 채택
        ul
            li 1995년 인터넷 익스플로러(IE)를 출시한 뒤 넷스케이프와 브라우저 전쟁을 벌였다
            li 1996년 8월 넷스케이프의 스크립트 인터프리터를 리버스 엔지니어링하여 자체 인터프리터 JScript를 출시
            p 상표권 문제가 될 수 있기 때문에 "Java"를 그대로 사용하지 않았다
            li 두 브라우저의 스크립트 엔진 구현이 달랐기 때문에, 같은 코드가 서로 다르게 보이는 일이 잦았다
            p 불행히도 IE가 독점적인 위치를 차지하는 동안, 개발자는 IE를 위한 특별한 처리를 해줘야 했다

        h2 표준화 시도
        ul
            li 1996년 11월 넷스케이프는 브라우저 공급업체가 준수할 수 있는 표준 사양의 출발점으로 JavaScript를 ECMA International에 제출
            li 1997년 6월 첫 번째 ECMAScript 발표
            p 마찬가지로 상표권 문제가 있으므로 "Java"를 그대로 사용하지 않음. 이제 JavaScript는 상업적 이름일 뿐
            li 1998년 6월 ECMAScript 2 발표
            p ECMAScript와 JavaScript용 ISO 표준(ISO/IEC 16262) 사이의 불일치를 수정
            li 1999년 12월 ECMAScript 3 발표
            p 정규식, try/catch 블록, in 및 instanceof 연산자 등 추가

        h2 ECMAScript 3.1과 4
        div
            p ECMAScript 4에 대한 작업은 버전 3이 출시되자마자 시작되었는데, 위원회에 강한 의견 차이가 대두되었다
            ul
                li JavaScript가 대규모 애플리케이션을 개발할 수 있는 강력한 언어가 되기 위해 새로운 기능이 필요하다
                p vs
                li 그러한 변경 사항은 JavaScript에 적합하지 않다
            p 버전 4에 대한 작업은 2003년 잠시 중단되었다가, 2005년 AJAX와 XMLHttpRequest의 영향으로 새 버전에 대한 관심이 높아지면서 작업이 재개되었다. 개발이 절정에 달했을 때 버전 4에는 다음과 같은 기능들이 포함되었다
            ul
                li 클래스, 인터페이스, 구조체, 사용자 정의 타입, 파라미터화된 타입
                li 패키지, 네임스페이스
                li 반복자, 생성자
                li 선택적 타입 주석, 선택적 정적 타입 체크
                li ...
            p 버전 4를 개발하는 위원회는 Adobe, Mozilla, Opera(비공식 자격), Microsoft로 구성되었는데, 대부분의 표준이 결정된 상태에서 Yahoo가 참여했다. 영향력 있는 JavaScript 개발자 Doug Crockford이 Yahoo에서 보낸 사람이었는데, 그는 버전 4의 많은 변경 사항에 대해 강력히 반대 의사를 표명했고 Microsoft로부터 강력한 지지를 받았다. 결국 버전 4 개발은 지지부진해졌고, Crockford는 모두가 동의할 수 있는 -- 구문 변경 없는 실용적인 개선사항만 담은 새로운 표준을 추진했고, 이것이 ECMAScript 3.1이다
            p 2008년 오슬로에서 열린 회의에서 ECMAScript 3.1과 4의 미래가 결정되었다
            ul
                li 모든 구성원의 협력으로 ES3.1 완성에 집중
                li 이후 ES4보다는 완화된 의미론적 및 구문론적 혁신에 대해 협력
                li 패키지, 네임스페이스 등 웹에 적합하지 않은 제안은 제외

            h3 ActionScript
            ul
                li ActionScript는 ECMAScript 4 초안을 기반으로 하는 언어로, Adobe는 이를 Flash 제품군의 일부로 구현해 출시했다
                li 때문에 Adobe는 ECMAScript 4를 강력히 지지했고, 채택을 위해 엔진을 오픈 소스(Tamarin)로 출시하기도 했다

        h2 ECMAScript 5
        ul
            li ECMAScript 4는 이미 8년의 개발을 거쳐 특정 변형으로 인식되었으므로, 혼동을 피하기 위해 ECMAScript 3.1의 이름은 ECMAScript 5로 변경되었다
            li 2009년 출시된 ES5는 가장 많이 지원되는 JavaScript 버전 중 하나가 되었고, 많은 트랜스파일러의 기본 컴파일 대상이 되었다
            p Firefox 4 (2011), Chrome 19 (2012), Safari 6 (2012), Opera 12.10 (2012) 및 Internet Explorer 10 (2012)에서 전적으로 지원
            li 수정사항
            ul
                li Getter/setter
                li 배열 및 객체 리터럴에서 후행 쉼표
                li 예약어를 프로퍼티 이름으로 허용
                li 신규 Object 메서드 : create, defineProperty, keys, seal, freeze, ...
                li 신규 Array 메서드 : isArray, indexOf, every, some, map, filter, reduce, ...
                li 신규 Date 메서드 : toISOString, now, toJSON
                li String.prototype.trim 추가
                li JSON
                li 불변 전역 객체 : undefined, NaN, Infinity
                li Strict 모드
                li ...

        h2 ECMAScript 6 (2015) : 범용 언어
        ul
            li ECMAScript 4에서 폐기되지 않은 아이디어는 ECMAScript Harmony에서 새롭게 제안되었고, ECMAScript 2015로 이름이 바뀐 ECMAScript 6는 이러한 구문 변경이 필요한 업데이트를 담고 있다
            p 이러한 구문 변경들은 브라우저 공급업체들이 모두 지원하기까지 상당한 시간이 소요됐고, 이로 인해 ECMAScript 2015 출시 이후 트랜스파일러의 사용이 크게 증가했다
            li ECMAScript 2015 수정사항
            ul
                li let, const 변수 선언
                li 화살표 함수와 this 키워드
                li 클래스
                li 객체 리터럴 개선 : 계산된 키 사용, 더 짧은 메서드 정의 등
                li 템플릿 문자열
                li Promise
                li 생성자, iterable, 반복자, for..of 구문
                li 신규 컬렉션 : Set, Map, WeakSet, WeakMap
                li 배열 해체 할당
                li ...

    h1 식별자
    ol
        li 식별자 : '_', '$' 허용
            +codeBtn('/Repositories/JavaScript/Basic/type.js', 'javascript', '[1,1]')
        li 변수 선언
        ul
            li let 식별자;
            p 일반적인 지역변수와 동일. 선언된 순간부터 해당 코드 블록이 끝날때까지 유효. 중첩된 코드 블록에서 같은 식별자의 변수를 선언하여 밖의 변수를 가릴 수 있다
                +codeBtn('/Repositories/JavaScript/Basic/type.js', 'javascript', '[2,2]')
            li var 식별자;
            p 선언 전에 참조하는 경우, 선언을 끌어올려 undefined를 할당해준다. 함수 스코프에서 동작하지만, 중첩된 코드 블록에서 재정의하여 가릴 수 없다
        li 상수 선언 : const 식별자;
            +codeBtn('/Repositories/JavaScript/Basic/type.js', 'javascript', '[4,4]')

    h1 자료형
    ul
        li Object
        ol
            li 객체 리터럴 : {}
            li delete 키워드로 프로퍼티 제거 가능
            li JSON.stringify(), JSON.parse(), Object.keys()
                +codeBtn('/Repositories/JavaScript/Basic/type.js', 'javascript', '[11,15]')
        li String
        ol
            li 문자 리터럴 : \xFF, \uFFFF
            li 문자열 리터럴 : '', "", ``(문자열 템플릿)
                +codeBtn('/Repositories/JavaScript/Basic/type.js', 'javascript', '[4,5,17,17]')
        li Number
        ol
            li IEEE-764 double-precision 부동소수
            li 숫자 리터럴 : 999, 0o777, 0xFFF, 0.999, 0.999E-9
            li 숫자 상수 : Infinity, -Infinity, NaN, Number.EPSILON, Number.MAX_VALUE, Number.MAX_SAFE_INTEGER
            li Number(), parseInt(), parseFloat(), number.toString(radix)
        li Boolean
        p Boolean() : "", 0, NaN, null, undefined == false, 그 외 == true
        li Undefined
        li Null
        li Symbol
        p ES6부터 도입된 타입. 그 무엇과도 같지 않은 유일한 토큰을 나타낸다
            +codeBtn('/Repositories/JavaScript/Basic/type.js', 'javascript', '[7,9]')
        li 배열 : []
        p 자바스크립트의 배열은 모두 동적 배열. 변수와 마찬가지로 타입을 가리지 않는다
            +codeBtn('/Repositories/JavaScript/Basic/array.js', 'javascript')
        li Map
        +asCode('javascript').
            new Map(iterable: Iterable&lt;readonly [K, V]>)
            new Map(entries?: readonly (readonly [K, V])[])
            set(key, value), get(key), has(key)
            delete(key), clear()
            size, keys(), values(), entries()
        li WeakMap
        p 키는 반드시 객체여야 하며, 키는 GC 대상이 된다. 따라서 객체가 살아있는 동안에 참조해야 하는 고유값들을 저장하기에 좋다
        li Set
        +asCode('javascript').
            new Set(iterable?: Iterable&lt;any>)
            new Set(values?: readonly T[])
            add(value), has(value), ...
        li WeakSet
        p 값은 반드시 객체여야 하며, GC 대상이 된다

    h1 연산자
    ol
        li Boolean 연산자 : !, &&, ||
        p &&, ||는 short circuit 연산
        li 비트 연산자 : ~, &, |, ^, &lt;&lt;, >>, >>>
        li ,연산자 : 순서대로 평가하여 마지막 표현식의 결과가 할당됨
            +codeBtn('/Repositories/JavaScript/Basic/syntax.js', 'javascript', '[9,10]')
        li in 연산자 : 객체에 해당 프로퍼티가 존재하는지 여부 반환
            +codeBtn('/Repositories/JavaScript/Basic/syntax.js', 'javascript', '[12,12]')
        p 객체에 직접 정의된 프로퍼티는 hasOwnProperty() 메서드 이용
        li instanceof 연산자 : 객체 호환 여부 반환
        li 해체 할당; Destructuring Assignment
        p
            +codeBtn('/Repositories/JavaScript/Basic/syntax.js', 'javascript', '[15,22]') 배열 해체 할당 »
            +codeBtn('/Repositories/JavaScript/Basic/syntax.js', 'javascript', '[26,29]') 배열 연속 해체 »
            +codeBtn('/Repositories/JavaScript/Basic/syntax.js', 'javascript', '[33,36]') 다차원 배열 해체 »
            +codeBtn('/Repositories/JavaScript/Basic/syntax.js', 'javascript', '[40,47]') 확산 연산자 »
            +codeBtn('/Repositories/JavaScript/Basic/syntax.js', 'javascript', '[51,65]') 객체 해체 할당 »
            +codeBtn('/Repositories/JavaScript/Basic/syntax.js', 'javascript', '[69,71]') 객체 메서드 해체 할당 »

    h1 Syntax
    ol
        li if...[else if...][else...]
        li while, do...while
        li for
            +codeBtn('/Repositories/JavaScript/Basic/syntax.js', 'javascript', '[1,7]')
        li switch : 조건으로 변수가 아닌 일반 표현식도 가능
        li for(let attr in obj) {} : 객체 프로퍼티 순회
        li for(let name of iterable) {} : 배열, Iterable 객체 순회
        li with(obj) : 스코프 고정
        li try ~ catch ~ finally
        p 예외 처리. throw는 임의의 타입을 던질 수 있다. try 뒤에 catch 또는 finally가 하나라도 있어야 한다

    h1 Function
    ol
        li 오버로딩 불가. 함수 호출 시 매개변수 길이 불일치해도 됨
        li arguments 객체를 통해 매개변수에 접근.(람다는 불가능)
        li 매개변수에 기본값 설정 가능
        li 매개변수도 해체, 확산 연산자 사용 가능
        li 명시하지 않은 경우, 함수의 기본 반환값은 undefined
        li 함수가 호출하는 지점보다 나중에 정의되어 있는 경우, 함수 선언이 위로 끌어올려진다
        li 함수의 컨텍스트(this) 지정
        +asCode('javascript').
            hello.apply({name: "Donggi"}, ["2018-08-08"]); // apply(호출자, 매개변수 배열)
            hello.call({name: "Donggi"}, "2018-08-08");    // call(호출자, 매개변수)
            // 확산 연산자 ...을 이용하면 call로 apply와 같은 효과를 낼 수 있다
            let helloKim = hello.bind({name: "Kim"});      // 함수 호출자 영구 고정
        li 함수 표현식 let f = function functionName() {}
        li 익명 함수 let f = function () {}
        li 화살표 표기법 let f = () => {}
        li 클로저 Closure
        p 함수 할당에 의해 접근할 수 있는 스코프가 늘어나는 것
            +codeBtn('/Repositories/JavaScript/Basic/function.js', 'javascript', '[2,8]')
        li 즉시 실행 함수 표현 IIFE; Immediately Invoked Function Expression
            +codeBtn('/Repositories/JavaScript/Basic/function.js', 'javascript', '[12,17]')

    h1 Class
    ol
        li 클래스는 본질적으로 함수다. 단순히 문법적 편의성이 더해졌을 뿐
        p
            +codeBtn('/Repositories/JavaScript/Basic/class.js', 'javascript', '[1,15]') 클래스 정의 예 »
            +codeBtn('/Repositories/JavaScript/Basic/class.js', 'javascript', '[18,19]') 상속 예 »
            +codeBtn('/Repositories/JavaScript/Basic/class.js', 'javascript', '[22,39]') 믹스인 예 »
        li 전역 객체
        p Object, Array, String, Global, Math
            br
            |Global 객체를 직접 획득하는 건 불가능 : isNaN(), isFinite(), parseInt(), parseFloat(), encodeURI(), encodeURIComponent(), eval()
        li Private 멤버
        p #으로 시작되는 프로퍼티, 메서드는 객체 외부에서 접근할 수 없다
        li 객체 보호
        +asCode('javascript').
            Object.freeze()            // 객체 동결. 읽기만 가능
            Object.seal()              // 객체 봉인. 기존 프로퍼티 값은 수정 가능
            Object.preventExtensions() // 객체 확장 금지. 새 프로퍼티 추가만 금지
        p: +codeBtn('/Repositories/JavaScript/Basic/class.js', 'javascript', '[42,70]') 접근자 프로퍼티 + 객체 보호 예 »
    div
        h2 프록시
        p
            +asA('https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler#Methods', '참고자료')
            +codeBtn('/Repositories/JavaScript/Basic/class.js', 'javascript', '[73,85]') 프록시 예 »
        +table()
            tr
                th getPrototypeOf()
                td A trap for Object.getPrototypeOf
            tr
                th setPrototypeOf()
                td A trap for Object.setPrototypeOf
            tr
                th isExtensible()
                td A trap for Object.isExtensible
            tr
                th preventExtensions()
                td A trap for Object.preventExtensions
            tr
                th getOwnPropertyDescriptor()
                td A trap for Object.getOwnPropertyDescriptor
            tr
                th defineProperty()
                td A trap for Object.defineProperty
            tr
                th has()
                td A trap for the in operator
            tr
                th get()
                td A trap for getting property values
            tr
                th set()
                td A trap for setting property values
            tr
                th deleteProperty()
                td A trap for the delete operator
            tr
                th ownKeys()
                td A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols
            tr
                th apply()
                td A trap for a function call
            tr
                th construct()
                td A trap for the new operator

    h1 Iterator, Generator
    p 해체 할당과 마찬가지로 파이썬에서 가져온 아이디어들 중 하나
        +codeBtn('/Repositories/JavaScript/Basic/iterator.js', 'javascript') 이터레이션 프로토콜 예 »
        +codeBtn('/Repositories/JavaScript/Basic/generator.js', 'javascript') 제너레이터 예 »
    ul
        li 파이썬과 마찬가지로 제어권을 주고받는 데 제너레이터를 사용한다
        li yield 키워드를 사용하는 모든 함수는 제너레이터 함수다
        li 제너레이터 함수를 호출하면 제너레이터 객체를 받는다
        li 제너레이터의 실행을 재개하는 3가지 메서드 : next(), send(), throw()

    h1 비동기 처리
    ol
        li 전통적 방식 : 콜백
        p setTimeout(), setInterval(), clearInterval()
            br
            |Error-first Callback : 콜백 첫번째 매개변수를 err로 사용하는 것
            br
            |Callback Hell : 연속적으로 콜백이 다른 콜백을 호출하여 관리하기 어려워지는 상황
        li Promise
        p 실행의 종료를 보장. 실행 상태(성공, 실패)에 따라 다른 콜백을 적절히 호출. 적절한 예외 처리도 지원 가능
            br
            |Promise의 생성은 resolve, reject 콜백을 매개변수로 받는 함수를 작성하기만 하면 된다
            +codeBtn('/Repositories/JavaScript/Basic/promise.js', 'javascript') promise.js »
            br
            |Promise.all(), Promise.race(), ...
        li async, await
        p 함수 정의 앞에 async 키워드를 사용하면 함수 내에서 await를 사용할 수 있다. 이때, 함수는 Promise가 결정될 때까지 일시 중지
            +codeBtn('/Repositories/JavaScript/Basic/async.js', 'javascript') async.js »

    h1 정규표현식
    ul
        li 정규표현식(RegExp) 리터럴 /X/
        p /123/gm과 new RegExp('123', 'gm')는 의미적으로 동일하다
        li Flag : g(global), i(ignoreCase), m(multiline), s(.이 newline도 매칭 Since ES2018)
        p global 플래그를 이용하는 경우, RegExp.lastIndex로 검색 위치를 기록하며, 해당 위치부터 재탐색한다
            |따라서 global RegExp에 동일 문자열을 반복적으로 test()하는 경우 true, false가 토글되는 현상을 경험할 수도 있다
        p ↓ 자바와 동일한 부분은 생략했음
        li Greedy 수량사
        p ?, *, +, {n}, {n, }, {n, m}
        li replace()에서의 backreference
        ul
            li $& 일치 문자열
            +asCode('javascript') '1 12 123 1234'.replace(/1/gm, '[$&]') // "[1] [1]2 [1]23 [1]234"
            li $` 앞부분
            +asCode('javascript') '1 12 123 1234'.replace(/1/gm, '[$`]') // "[] [1 ]2 [1 12 ]23 [1 12 123 ]234"
            li $' 뒷부분
            +asCode('javascript') '1 12 123 1234'.replace(/1/gm, "[$']") // "[ 12 123 1234] [2 123 1234]2 [23 1234]23 [234]234"
        li 관련 메서드
        ul
            li RegExp#test() : 패턴이 검색되는지 여부
            li RegExp#exec() : 매칭되는 인덱스들을 배열로 반환
                |매칭 시작 index, 검색 텍스트 input 프로퍼티를 가진다. [i] 접근으로 캡처 그룹을 가져올 수 있다
            +asCode('javascript') /1/gm.exec('1 12 123') // ["1", index: 0, input: "1 12 123", groups: undefined]
            li String#search(regexp) : 처음 매칭된 인덱스 반환
            li String#match(regexp) : 매칭되는 모든 부분문자열 반환
            li String#replace(regexp, replaceValue) : 매칭된 부분문자열을 replaceValue로 치환
            li String#split(regexp, limit) : 매칭된 문자열을 분리

    h1 버전별 신규 기능
    div
        h2 참고자료
        ul
            li: +asA('https://ecma-international.org/publications-and-standards/standards/ecma-262/')
                p 공식 문서 최상단 "Introduction"에서 버전별 주요 변경 사항이 정리되어 있다

        h2 ES2015, ES6
        div
            h3 Tagged template literal
            div
                p Tag function을 이용하여 문자열 보간 작업을 사용자 정의할 수 있다
                    +codeBtn({
                        path: '/Repositories/JavaScript/snippet/240314-162705.js',
                        lan: 'javascript',
                        title: '예시 코드'
                    })
                p 문자열이 아닌 걸 반환해도 된다
                    +codeBtn({
                        path: '/Repositories/JavaScript/snippet/240314-165131.js',
                        lan: 'javascript',
                        title: '예시 코드'
                    })
                p 언어 자체에 내장된 tag function도 있다
                +asCode('JavaScript') String.raw`C:\Development\profile\about.html`

        h2 ES2016
        ul
            li 지수 연산자 **
            li Array.prototype.includes

        h2 ES2017
        ul
            li async function 정의 지원
            li Object.values, Object.entries, Object.getOwnPropertyDescriptors
        div
            h3 Shared Memory, Atomics
            ul
                li Atomics는 원자적 연산을 위한 함수들을, Shared Memory는 이를 위한 공유 메모리를 정의한다
                li 원자적 연산은 Java의 volatile 변수처럼, CPU 코어 수준으로 병렬 실행을 동기화한다
                li 공유 메모리 구현체는 SharedArrayBuffer인데, 브라우저에서는 기본적으로 비활성화되어 있으므로 사용하기 위해선 명시적인 설정이 필요하다
            +codeBtn({ path: '/Repositories/Single/202506/09-1435.js', lan: 'JavaScript', title: '예시 코드' })

        h2 ES2018
        ul
            li 정규표현식 기능 추가
                p dotAll flag(/s), named capture groups, Unicode property escapes, look-behind assertions
        div
            h3 비동기 반복자
            p 비동기 반복자는 Promise를 반환하는 반복자
            +asCode('JavaScript').
                const asyncIterator = (async function* () {
                  yield 1;
                  yield 2;
                  yield 3;
                })();
                (async () => {
                  for await (const value of asyncIterator) {
                    console.log(value);
                  }
                })();

            h3 객체 해체 할당
            p Object rest and spread properties
            +asCode('JavaScript').
                const obj = {
                x: [1, 2, 3],
                y: { a: 4, b: 5, c: 6 },
                z: [7, 8, 9]
                }
                const { x: [x1, ...xRest], y: { a: y1, ...yRest }, ...objRest } = obj
                console.info(x1)        // 1
                console.info(xRest)     // [2, 3]
                console.info(y1)        // 4
                console.info(yRest)     // {b: 5, c: 6}
                console.info(objRest)   // {"z": [7, 8, 9]}

        h2 ES2019
        ul
            li Array.prototype.flat, flatMap
            li Object.fromEntries
            li String.prototype.trimStart, trimEnd
            li Array.prototype.sort는 이제 stable (정렬 키가 동일한 두 요소의 순서는 정렬 후에도 유지)
            li JSON.stringify는 입력과 무관하게 well-formed UTF-8 문자열을 반환

        h2 ES2020
        div
            h3 Optional chaining (?.)
            ul
                li ?. 연산자를 이용하여 객체의 속성을 접근하거나 함수를 호출할 수 있다
                li 이 연산자로 접근하려는 객체나 호출하려는 함수가 undefined나 null인 경우, 연산은 단락되고 undefined를 반환한다
            
            h3 Nullish coalescing operator (??)
            p 연산자 좌변이 null 또는 undefined인 경우, 연산자 우변을 반환한다

            h3 import()
            p import .. from ... 구문과 다르게, 런타임에 변수를 이용해 모듈을 로드한다

            h3 matchAll() for Strings
            p 전체 문자열에서 정규표현식 매칭을 수행한 결과를 반환한다 -- 기존엔 전문검색을 위해 루프를 실행해야 했다

            h3 Promise.allSettled()
            p Promise.all()은 일부가 실패한 경우 아래 2가지가 불가능했는데, allSettled()는 모두 가능하다
                +codeBtn({
                    path: '/Repositories/JavaScript/snippet/240314-190540.js',
                    lan: 'javascript',
                    title: '예시 코드'
                })
            ul
                li 성공한 Promise의 반환값 획득
                li 2번째 이후로 실패한 Promise의 에러 획득

            h3 BigInt
            p #[+asInlineCode('Number.MAX_SAFE_INTEGER', 'javascript')]보다 큰 정수도 정확히 보존하는 정수 자료형

            h3 globalThis
            p 실행 환경(브라우저, Node, Deno, ...)과 무관하게 전역 컨텍스트를 통한 변수 접근 방법 제공

            h3 import.meta
            p ES 모듈을 이용하는 경우, #[+asInlineCode('import.meta.url', 'javascript')]를 이용해 모듈 URL 획득 가능

            h3 export * as newName from 'module'
            p 모듈의 defaults를 다시 노출하기만 할 때 편의 제공
        
        h2 ES2021
        ul
            li replaceAll() for Strings
            li Promise.any()
            li AggregateError : 여러 에러를 한 번에 표현
            li ??=, &amp;&amp;=, ||= 연산자 추가
            li WeakRef : 약한 참조 지원
            li FinalizationRegistry : 지정한 객체가 GC로 정리된 경우 호출. #[+asA('https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry#notes_on_cleanup_callbacks', '단, 이에 의존하면 안 됨')]
            li 1_000처럼 리터럴 자리 구분 가능

        h2 ES2022
        ul
            li 에러 원인을 cause 프로퍼티에 설정 가능
            li Array.prototype.at() : 음수 인덱스도 지원하는 원소 접근 메서드
        div
            h3 모듈 최상위 레벨 await 가능
            +asCode('JavaScript').
                import ...

                await loadSecrets()
                await readyDB()

            h3 클래스 정의 관련
            ul
                li static 프로퍼티와 메서드 정의 가능
                li constructor() 바깥의 클래스 body에서 프로퍼티 정의 가능
                li 프로퍼티 또는 accessor 식별자를 #으로 시작하면 private
            
            h3 정규표현식 /d 플래그 추가
            p 패턴 전체 및 각 캡처링 그룹에 대한 시작/끝 위치를 indices 속성에 제공
            +asCode('JavaScript').
                /(aa)(bb)/d.exec('aaabbbccc').indices
                /*
                [
                    [1, 5],
                    [1, 3],
                    [3, 5]
                ]
                */

        h2 WHATWG 2022
        div
            h3: +asA('https://developer.mozilla.org/en-US/docs/Web/API/Window/structuredClone', 'structuredClone(value[, options])')
            p 객체 깊은 복사 지원
        
        h2 ES2023
        ul
            li 배열에 findLast(), findLastIndex() 추가
            li 스크립트 첫 줄에 #!(Hashbang; Shebang) 지원
        div
            h3 원본 수정 없이 사본을 반환하는 배열 메서드
            ul
                li with(index, value) : 지정한 index 원소로 value를 갖는 사본 반환
                li toSorted(compareFn?) : 정렬된 사본 반환
                li toReversed() : 원소가 역순인 사본 반환
                li toSpliced(...) : splice(...)를 수행한 사본 반환

        h2 ES2024
        ul
            li 정규표현식 /v 플래그 추가
            li Object.groupBy, Map.groupBy를 이용한 집계
            li String.prototype.isWellFormed, toWellFormed 추가
        div
            h3 Promise.withResolvers()
            p Promise 객체의 상태 천이를 Promise 정의 바깥에서 하고 싶을 때
            +asCode('JavaScript').
                let resolver, rejector
                const promise = new Promise((resolve, reject) => {
                    resolver = resolve
                    rejector = reject
                })
            p 위와 같은 코드를 아래와 같이 축약할 수 있다
            +asCode('JavaScript') const { promise, resolve, reject } = Promise.withResolvers()

        h2 ES2025
        div
            h3: +asA('https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import/with', 'import 속성 지정')
            p 예를 들어, 클라이언트는 아래와 같이 JSON을 기대했지만
            +asCode('JavaScript') import config from 'https://xxx/config.json'
            p 서버가 JSON이 아닌 실행 가능한 JavaScript 코드를 응답하면 의도치 않게 해당 코드가 실행되는 문제가 있었다. 이제는 속성을 지정하여 이러한 경우 명시적으로 오류를 발생할 수 있다
            +asCode('JavaScript').
                import styles from "https://example.com/styles.css" with { type: "css" };
                import data from "https://example.com/data.json" with { type: "json" };
