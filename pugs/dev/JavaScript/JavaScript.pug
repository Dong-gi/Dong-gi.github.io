include ../../../source/skeleton.pug

+post({
    title: 'JavaScript',
    description: 'JavaScript(ECMAScript) 정리',
})

    h1 자료
    ul
        li: +asA('https://developer.mozilla.org/en-US/docs/Learn/JavaScript', 'MDN > JavaScript 배우기')
        li: +asA('https://web.dev/learn/javascript', 'web.dev > JavaScript 배우기')
        li: +asA('https://exploringjs.com/', 'Exploring JavaScript')

    h1 JavaScript 역사
    div
        h2 참고자료
        ul
            li: +asA('https://dzone.com/articles/a-brief-history-of-javascript')
            li: +asA('https://en.wikipedia.org/wiki/JavaScript')

        h2 현재
        p JavaScript는 ECMAScript 표준을 준수하는 고급 프로그래밍 언어로, JIT 컴파일로 실행되는 스크립트 언어

        h2 넷스케이프의 창조
        ul
            li 1995년. 동적 웹 콘텐츠 개발을 위해 DOM과 상호작용할 수 있는 프로그래밍 언어를 추가하기 위한 결정이 이루어졌다
            li 넷스케이프의 "브라우저를 위한 Scheme" 개발 프로젝트에 JavaScript의 아버지 Brendan Eich도 있었다
            p Scheme은 Lisp의 방언 중 하나
            ul
                li 당시 이미 넷스케이프와 썬 마이크로시스템즈는 브라우저에서 Java를 사용(자바 애플릿)할 수 있도록 계약을 체결하려는 시점이었다
                li 따라서 새로운 언어(개발명 Mocha)를 추가하는 목적은 프로그램 개발이 아니라, HTML 안에서 동적으로 애니메이션 추가, 디자인 변경 등을 수행하는 것(작은 스크립팅 작업)이었으며, 전문 개발자가 아닌 HTML을 작성할 줄 아는 디자이너와 같은 사람들이 타깃 유저층이었다
                li 즉, Mocha는 Java의 스크립팅 동반자가 되어야 했다. 이를 위해 Java와 유사한 구문들이 채택되었고, Scheme으로부터 멀어진 모습을 갖게 되었다
            li 1995년 9월 베타 출시하면서 LiveScript로 이름 변경
            li 1995년 12월 정식 출시하면서 JavaScript로 이름 변경 (썬 마이크로시스템즈와 합의)

        h2 마이크로소프트의 채택
        ul
            li 1995년 인터넷 익스플로러(IE)를 출시한 뒤 넷스케이프와 브라우저 전쟁을 벌였다
            li 1996년 8월 넷스케이프의 스크립트 인터프리터를 리버스 엔지니어링하여 자체 인터프리터 JScript를 출시
            p 상표권 문제가 될 수 있기 때문에 "Java"를 그대로 사용하지 않았다
            li 두 브라우저의 스크립트 엔진 구현이 달랐기 때문에, 같은 코드가 서로 다르게 보이는 일이 잦았다
            p 불행히도 IE가 독점적인 위치를 차지하는 동안, 개발자는 IE를 위한 특별한 처리를 해줘야 했다

        h2 표준화 시도
        ul
            li 1996년 11월 넷스케이프는 브라우저 공급업체가 준수할 수 있는 표준 사양의 출발점으로 JavaScript를 ECMA International에 제출
            li 1997년 6월 첫 번째 ECMAScript 발표
            p 마찬가지로 상표권 문제가 있으므로 "Java"를 그대로 사용하지 않음. 이제 JavaScript는 상업적 이름일 뿐
            li 1998년 6월 ECMAScript 2 발표
            p ECMAScript와 JavaScript용 ISO 표준(ISO/IEC 16262) 사이의 불일치를 수정
            li 1999년 12월 ECMAScript 3 발표
            p 정규식, try/catch 블록, in 및 instanceof 연산자 등 추가

        h2 ECMAScript 3.1과 4
        div
            p ECMAScript 4에 대한 작업은 버전 3이 출시되자마자 시작되었는데, 위원회에 강한 의견 차이가 대두되었다
            ul
                li JavaScript가 대규모 애플리케이션을 개발할 수 있는 강력한 언어가 되기 위해 새로운 기능이 필요하다
                p vs
                li 그러한 변경 사항은 JavaScript에 적합하지 않다
            p 버전 4에 대한 작업은 2003년 잠시 중단되었다가, 2005년 AJAX와 XMLHttpRequest의 영향으로 새 버전에 대한 관심이 높아지면서 작업이 재개되었다. 개발이 절정에 달했을 때 버전 4에는 다음과 같은 기능들이 포함되었다
            ul
                li 클래스, 인터페이스, 구조체, 사용자 정의 타입, 파라미터화된 타입
                li 패키지, 네임스페이스
                li 반복자, 생성자
                li 선택적 타입 주석, 선택적 정적 타입 체크
                li ...
            p 버전 4를 개발하는 위원회는 Adobe, Mozilla, Opera(비공식 자격), Microsoft로 구성되었는데, 대부분의 표준이 결정된 상태에서 Yahoo가 참여했다. 영향력 있는 JavaScript 개발자 Doug Crockford이 Yahoo에서 보낸 사람이었는데, 그는 버전 4의 많은 변경 사항에 대해 강력히 반대 의사를 표명했고 Microsoft로부터 강력한 지지를 받았다. 결국 버전 4 개발은 지지부진해졌고, Crockford는 모두가 동의할 수 있는 -- 구문 변경 없는 실용적인 개선사항만 담은 새로운 표준을 추진했고, 이것이 ECMAScript 3.1이다
            p 2008년 오슬로에서 열린 회의에서 ECMAScript 3.1과 4의 미래가 결정되었다
            ul
                li 모든 구성원의 협력으로 ES3.1 완성에 집중
                li 이후 ES4보다는 완화된 의미론적 및 구문론적 혁신에 대해 협력
                li 패키지, 네임스페이스 등 웹에 적합하지 않은 제안은 제외

            h3 ActionScript
            ul
                li ActionScript는 ECMAScript 4 초안을 기반으로 하는 언어로, Adobe는 이를 Flash 제품군의 일부로 구현해 출시했다
                li 때문에 Adobe는 ECMAScript 4를 강력히 지지했고, 채택을 위해 엔진을 오픈 소스(Tamarin)로 출시하기도 했다

        h2 ECMAScript 5
        ul
            li ECMAScript 4는 이미 8년의 개발을 거쳐 특정 변형으로 인식되었으므로, 혼동을 피하기 위해 ECMAScript 3.1의 이름은 ECMAScript 5로 변경되었다
            li 2009년 출시된 ES5는 가장 많이 지원되는 JavaScript 버전 중 하나가 되었고, 많은 트랜스파일러의 기본 컴파일 대상이 되었다
            p Firefox 4 (2011), Chrome 19 (2012), Safari 6 (2012), Opera 12.10 (2012) 및 Internet Explorer 10 (2012)에서 전적으로 지원
            li 수정사항
            ul
                li Getter/setter
                li 배열 및 객체 리터럴에서 후행 쉼표
                li 예약어를 프로퍼티 이름으로 허용
                li 신규 Object 메서드 : create, defineProperty, keys, seal, freeze, ...
                li 신규 Array 메서드 : isArray, indexOf, every, some, map, filter, reduce, ...
                li 신규 Date 메서드 : toISOString, now, toJSON
                li String.prototype.trim 추가
                li JSON
                li 불변 전역 객체 : undefined, NaN, Infinity
                li Strict 모드
                li ...

        h2 ECMAScript 6 (2015) : 범용 언어
        ul
            li ECMAScript 4에서 폐기되지 않은 아이디어는 ECMAScript Harmony에서 새롭게 제안되었고, ECMAScript 2015로 이름이 바뀐 ECMAScript 6는 이러한 구문 변경이 필요한 업데이트를 담고 있다
            p 이러한 구문 변경들은 브라우저 공급업체들이 모두 지원하기까지 상당한 시간이 소요됐고, 이로 인해 ECMAScript 2015 출시 이후 트랜스파일러의 사용이 크게 증가했다
            li ECMAScript 2015 수정사항
            ul
                li let, const 변수 선언
                li 화살표 함수와 this 키워드
                li 클래스
                li 객체 리터럴 개선 : 계산된 키 사용, 더 짧은 메서드 정의 등
                li 템플릿 문자열
                li Promise
                li 생성자, iterable, 반복자, for..of 구문
                li 신규 컬렉션 : Set, Map, WeakSet, WeakMap
                li 배열 해체 할당
                li ...

    h1 변수와 식별자
    ol
        li 식별자
            ul
                li '_', '$'를 식별자로 이용할 수 있다
                    +asCode('JavaScript') const _ = 123
                li 다른 프로그래밍 언어들과 마찬가지로 예약어를 변수 식별자로 사용할 수 없다 -- 하지만 객체 속성으로는 사용할 수 있다
                    +asCode('JavaScript') const o = { if: 123, default: 456 }

        li var 변수
            ul
                li let, const가 도입되기 전까진 유일한 변수 선언 구문이었다. 현대 개발에선 const &gt; let 사용이 권장된다
                li var 변수는 선언된 함수 스코프 내에서 유효하다
                li 호이스팅 : 선언한 위치 전에도 변수를 참조할 수 있다(값은 undefined)

        li let 변수
            ul
                li var 대신 일반적인 지역변수 키워드로 이용된다
                li var 변수와 달리 선언 이전에 참조할 수 없고, 변수는 선언된 블록 스코프 내에서 유효하다

        li const 변수
            ul
                li 선언과 동시에 값을 초기화하고, 이후 다른 값으로 덮어쓸 수 없다. 따라서 상수라고 한다
                li let과 마찬가지로 선언된 블록 스코프 내에서 유효하다

    h1 자료형(type)
    div
        h2 원시 타입
        ul
            li 원시 타입의 가장 큰 특징은 값의 불변성이다. 123, 'abc', true 등의 값 자체를 다른 것으로 변경할 수 없다.
            li 변수로 원시 타입 내용을 전달할 때는 값 자체가 복사된다
            li JavaScript는 원시 타입도 객체와 동등한 1급 시민이다
                ul
                    li Object 타입 변수로 모든 객체를 참조할 수 있지만 원시 타입 값을 직접 저장할 수 없는 Java와 달리, JavaScript 변수는 (구별 없이) 모든 타입을 직접 지원한다
                    li Wrapper 클래스로 변환해 메서드를 호출하는 Java와 다르게, 원시 타입 변수로부터 직접 전용 메서드 호출 가능

        div
            h3 undefined
            ul
                li 변수에 값이 할당되지 않았음 또는 객체에 속성이 존재하지 않음을 의미한다
                li Java의 경우 변수는 그 타입에 따라 정해진 기본값을 갖는다 -- 객체는 null, 정수는 0, ...
                    p JavaScript 변수는 정의할 때 타입을 지정하지 않으므로, 원시 타입도 객체도 아닌, 아무것도 할당되지 않은 상태를 표현하기 위해 undefined를 도입했다

            h3 null
            p 객체가 에상되는 변수/속성에 의도적으로 값이 할당되지 않았음을 의미한다

            h3 Boolean
            ul
                li 논리값 표현을 위한 타입으로, true/false 2가지가 있다
                li Boolean()를 이용해 모든 변수를 boolean 값으로 변환할 수 있다

            h3 Number
            ul
                li IEEE-754 부동소수(double) 표현을 위한 타입으로, bigint 도입 전에는 유일한 숫자 타입이었다
                li 주요 JavaScript 엔진들은 최적화를 위해 작은 정수들을 내부적으로 별도 타입으로 취급한다
                li 숫자 리터럴 표현 시 읽기 편하도록 중간에 '_'를 추가할 수 있다. 예. 1_234_00
                li 숫자 리터럴로 과학적 표기법을 지원한다. 예. 1.5e11
                li 정수 리터럴 표현에서는 다양한 진법을 지원한다
                    ul
                        li 0b101 : 2진법
                        li 0o77 : 8진법
                        li 0xff : 16진법

            h3 Bigint
            ul
                li 정밀도 제한 없이 정수를 표현한다
                li 하나의 산술 연산자로 Bigint와 Number 모두를 처리할 순 없다
                    p 연산 결과로 Bigint, Number 중 어떤 게 반환돼야 하는지에 대한 설득력 있는 규칙이 없으므로, 개발자가 의도에 맞게 직접 형 변환을 해야한다

            h3 String
            ul
                li JavaScript는 단일 문자를 위한 전용 타입 없이 모두 UTF-16 포맷 문자열로 취급한다
                    ul
                        li Code point : 각 유니코드 문자마다 주어진 ID (21비트)
                        li Code unit : code point를 표현하기 위한 개별 UTF-16 값 (16비트)
                            ul
                                li 현재 유니코드는 2^16개 문자씩 구별된 총 17개 평면으로 구성
                                li 다국어 기본 평면(0번) 문자에 대해 UTF-16은 하나의 code unit만 사용
                                li 그 외 문자에 대해 UTF-16은 2개의 code unit을 사용 (high/low surrogate들이 각각 10비트씩 표현)
                        li Grapheme cluster : 여러 code point가 모여 하나의 활자를 표현하는 경우가 있다
                            +asCode('JavaScript') [...'😵‍💫'] // ['😵', '‍', '💫']
                li 문자 리터럴 : 'a', '\x61', '\u0061'
                li 문자열 리터럴 : 'abc', "abc", `abc`(문자열 템플릿)
                li split(''), slice()는 code unit 단위로 동작,
                    |<br>[...str]은 -- #[+asA('https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/Symbol.iterator', 'Symbol.iterator')]를 이용하여 code point 단위로 동작
                    +asCode('JavaScript').
                        '😵‍💫'.split('')  // ['\uD83D', '\uDE35', '‍', '\uD83D', '\uDCAB']
                        [...'😵‍💫']       // ['😵', '‍', '💫']

            h3 Symbol
            ul
                li ES6부터 도입된 타입. 그 무엇과도 같지 않은 유일한 토큰을 나타낸다
                    +asCode('JavaScript') Symbol('xxx') !== Symbol('xxx')
                li 단, Symbol.for()를 이용해 전역적으로 재사용할 수도 있다
                    +asCode('JavaScript') Symbol.for('xxx') === Symbol.for('xxx')

        h2 객체 타입
        ul
            li 객체 타입은 값 자체를 변경할 수 있다. 자유롭게 속성을 추가/변경/삭제할 수 있다.
            li 변수로 객체를 전달할 때는 참조가 복사된다
        div
            h3 Object
            p 보통 객체 리터럴 표현 {} 을 이용해 생성한다
        
            h3 Array
            ul
                li 배열 리터럴 표현 [] 또는 Array 생성자를 이용해 생성한다
                li Java와 다르게 원소 타입을 강제하지 않고, 배열 길이도 가변적이다

            h3 Map
            +asCode('JavaScript').
                new Map(iterable: Iterable&lt;readonly [K, V]>)
                new Map(entries?: readonly (readonly [K, V])[])
                set(key, value), get(key), has(key)
                delete(key), clear()
                size, keys(), values(), entries()

            h3 WeakMap
            p 키는 반드시 객체여야 하며, 키는 GC 대상이 된다. 따라서 객체가 살아있는 동안에 참조해야 하는 고유값들을 저장하기에 좋다
            
            h3 Set
            +asCode('JavaScript').
                new Set(iterable?: Iterable&lt;any>)
                new Set(values?: readonly T[])
                add(value), has(value), ...
            
            h3 WeakSet
            p 값은 반드시 객체여야 하며, GC 대상이 된다

    h1 연산자
    ol
        li Boolean 연산자 : !, &amp;&amp;, ||
        p &amp;&amp;, ||는 short circuit 연산
        li 비트 연산자 : ~, &amp;, |, ^, &lt;&lt;, >>, >>>
        li ,연산자 : 순서대로 평가하여 마지막 표현식의 결과가 할당됨
            +asCode('JavaScript').
                const n = (1, 2, 3, 4, 5)
                console.log(n === 5)
        li in 연산자 : 객체에 해당 프로퍼티가 존재하는지 여부 반환 -- 프로토타입 체인도 검사
            +asCode('JavaScript').
                console.log('alert' in globalThis) // true
                console.log('a' in { __proto__: { __proto__: { a: 1 } } }) // true
            p 프로토타입으로 상속하지 않고 객체에 직접 정의된 프로퍼티를 검사하는 방법
                ul
                    li Object.keys() : enumerable 설정된 string 속성 키 목록 반환
                    li Object.getOwnPropertyNames() : enumerable 설정과 무관하게 string 속성 키 목록 반환
                    li Object.getOwnPropertySymbols() : enumerable 설정과 무관하게 symbol 속성 키 목록 반환
                    li Reflect.ownKeys() : enumerable 설정과 무관하게 string + symbol 속성 키 목록 반환
        li instanceof 연산자 : 객체 호환 여부 반환
        li 해체 할당; Destructuring Assignment
            p
                +codeBtn('/Repositories/JavaScript/Basic/syntax.js', 'JavaScript', '[15,22]') 배열 해체 할당 »
                +codeBtn('/Repositories/JavaScript/Basic/syntax.js', 'JavaScript', '[26,29]') 배열 연속 해체 »
                +codeBtn('/Repositories/JavaScript/Basic/syntax.js', 'JavaScript', '[33,36]') 다차원 배열 해체 »
                +codeBtn('/Repositories/JavaScript/Basic/syntax.js', 'JavaScript', '[40,47]') 확산 연산자 »
                +codeBtn('/Repositories/JavaScript/Basic/syntax.js', 'JavaScript', '[51,65]') 객체 해체 할당 »
                +codeBtn('/Repositories/JavaScript/Basic/syntax.js', 'JavaScript', '[69,71]') 객체 메서드 해체 할당 »

    h1 제어 구문
    ol
        li if...[else if...][else...]
        li while, do...while
        li for(초기식; 조건식; 증감식)
        li switch : 분기 조건으로 변수가 아닌 일반 표현식도 가능
        li for(let attr in obj) {} : 객체 프로퍼티 순회
        li for(const name of iterable) {} : Iterable 객체 순회
        li with(obj) : 스코프 고정
        li try ~ [catch] ~ [finally] : catch, finally 중 적어도 하나는 있어야 한다
        li break with label : 임의 블록을 탈출할 수 있다
            +asCode('JavaScript').
                someLabel: {
                    let a = Math.random()
                    if (a < 0.5) {
                        break someLabel
                    }
                    console.log(a)
                }

    h1 함수
    ul
        li ES6 전에는 function 키워드로 정의하는 함수만 존재했지만, ES6부터는 기능별로 전용 구문이 추가되었으므로 이를 이용함이 권장된다
        li 명시하지 않은 경우, 함수 반환값은 undefined
        li 매개변수에 기본값 설정 가능 + 해체, 확산 연산자 사용 가능
            +asCode('JavaScript').
                function avg(...numArr) {
                    let sum = 0
                    numArr.forEach(x => sum += x)
                    return sum / numArr.length
                }
                console.log(avg(1, 2, 3, 4))

                function xxxx({ a = 1, b = 2 } = {}) {
                    console.log({a, b})
                }
                xxxx()
        li 함수 컨텍스트(this) 지정
            +asCode('JavaScript').
                function hello(today) {
                    console.log(`Hello ${this.name}! Today is ${today}`)
                }
                hello.apply({name: "Donggi"}, ["2018-08-08"])   // apply(호출자, 매개변수 배열)
                hello.call({name: "Donggi"}, "2018-08-08")      // call(호출자, 매개변수1, ...)
                hello.bind({name: "Donggi"})("2018-08-08")      // 함수 호출자 및 매개변수 고정
        li 코드 동적 실행
            +asCode('JavaScript').
                const sum = new Function("a", "b", "return a + b")
                console.log(sum(2, 6))

    div
        h2 일반 함수
        +asCode('JavaScript').
            // ES6 전
            function add(x, y) {
                return x + y
            }
            // ES6
            const add = (x, y) => x + y

        h2 메서드
        +asCode('JavaScript').
            // ES6 전
            const o = {
                name: 'Bob',
                print: function() {
                    console.log(`I'm ${this.name}`)
                }
            }
            // ES6
            const o = {
                name: 'Bob',
                print() {
                    console.log(`I'm ${this.name}`)
                }
            }

            o.print()

        h2 생성자
        +asCode('JavaScript').
            // ES6 전
            function Animal(name) {
                this.name = name
            }
            // ES6
            class Animal {
                constructor(name) {
                    this.name = name
                }
            }

            const alice = new Animal('Alice')
            console.log(alice instanceof Animal)    // true

    h1 모듈
    ul
        li ES6에서 실행 환경 -- 브라우저, 서버 -- 에 관계없이 사용 가능한 내장 모듈 사양이 도입되었으므로, 이를 사용하는 것이 권장된다
        li 보통 모듈은 소스 코드 파일에 작성되고
            ul
                li export를 통해 외부에서 이용할 모듈 내 구성 요소를 지정한다
                li import를 통해 외부에서 가져올 모듈 내 구성 요소를 지정한다
                li 한 모듈이 여러 모듈에서 참조되더라도, 해당 모듈은 한 번만 평가된다 -- 싱글톤이다
        li 모듈 로드는 다음과 같이 2단계로 나뉘므로, 모듈 간 순환 의존성 있더라도 문제 없다
            ol
                li 모듈 간 의존성을 따라가면서 export ~ import 관계를 평가
                li 로드된 모듈들의 body 실행
            +codeBtn({path:'/Repositories/Node/module-251113/a.js', lan:'JavaScript'})
            +codeBtn({path:'/Repositories/Node/module-251113/b.js', lan:'JavaScript'})
            +asCode('shell').
                $ node a.js
                b.js body start
                a() called
                a.js body start
                b() called

                $ node b.js
                a.js body start
                b() called
                b.js body start
                a() called
            p 단, 초기화되지 않은 요소를 참조하면 런타임 에러가 발생한다
                +codeBtn({path:'/Repositories/Node/module-251113/a2.js', lan:'JavaScript'})
                +codeBtn({path:'/Repositories/Node/module-251113/b2.js', lan:'JavaScript'})
            +asCode('shell').
                $ node a2.js
                b2.js body start
                a2() called
                a2.js body start
                b2() called#0
                b2() called#1

                $ node b2.js
                a2.js body start
                file://xxx/b2.js:8
                    console.log(`b2() called#${count++}`);
                                ^

                ReferenceError: Cannot access 'count' before initialization
                    at b2 (file://xxx/b2.js:8:17)
                    at file://xxx/a2.js:4:1
                    at ModuleJob.run (node:internal/modules/esm/module_job:271:25)
                    at async onImport.tracePromise.__proto__ (node:internal/modules/esm/loader:547:26)
                    at async asyncRunEntryPointWithESMLoader (node:internal/modules/run_main:116:5)
        li import() 연산자를 통해 필요에 따라 동적으로 모듈을 가져올 수도 있다
            p 연산자와 다르게 import()가 함수라면, 상대 경로를 이용하기 위해 호출자 모듈의 URL을 명시적으로 전달해야 한다

    h1 클래스
    ol
        li 클래스는 본질적으로 함수다. 단순히 문법적 편의성이 더해졌을 뿐
        p
            +codeBtn('/Repositories/JavaScript/Basic/class.js', 'JavaScript', '[1,15]') 클래스 정의 예 »
            +codeBtn('/Repositories/JavaScript/Basic/class.js', 'JavaScript', '[18,19]') 상속 예 »
            +codeBtn('/Repositories/JavaScript/Basic/class.js', 'JavaScript', '[22,39]') 믹스인 예 »

        li Private 멤버
            ul
                li #으로 시작되는 멤버는 클래스와 객체 내부에서 오로지 . 연산자를 이용해서만 접근 가능하다
                li 생성자 말고는 모두 private 설정 가능
                li 선언과 동시에 초기화하거나, 초기화하기 전에 미리 선언해야 한다

        li 객체 보호
        +asCode('JavaScript').
            Object.preventExtensions() // 객체 확장 방지. 새 프로퍼티를 추가하거나 프로토타입을 변경할 수 없음
            Object.seal()              // 객체 봉인. 확장 방지 + 모든 프로퍼티의 configurable 값을 false로 설정
            Object.freeze()            // 객체 동결. 봉인 + 모든 프로퍼티의 writable 값을 false로 설정
        p: +codeBtn('/Repositories/JavaScript/Basic/class.js', 'JavaScript', '[42,70]') 접근자 프로퍼티 + 객체 보호 예 »

    h1 프록시
    div
        +asA('https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler#Methods', '참고자료')
        +codeBtn('/Repositories/JavaScript/Basic/class.js', 'JavaScript', '[73,85]') 프록시 예 »
    +table()
        tr
            th getPrototypeOf()
            td A trap for Object.getPrototypeOf
        tr
            th setPrototypeOf()
            td A trap for Object.setPrototypeOf
        tr
            th isExtensible()
            td A trap for Object.isExtensible
        tr
            th preventExtensions()
            td A trap for Object.preventExtensions
        tr
            th getOwnPropertyDescriptor()
            td A trap for Object.getOwnPropertyDescriptor
        tr
            th defineProperty()
            td A trap for Object.defineProperty
        tr
            th has()
            td A trap for the in operator
        tr
            th get()
            td A trap for getting property values
        tr
            th set()
            td A trap for setting property values
        tr
            th deleteProperty()
            td A trap for the delete operator
        tr
            th ownKeys()
            td A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols
        tr
            th apply()
            td A trap for a function call
        tr
            th construct()
            td A trap for the new operator

    h1 Iterator, Generator
    p 해체 할당과 마찬가지로 파이썬에서 가져온 아이디어들 중 하나
        +codeBtn('/Repositories/JavaScript/Basic/iterator.js', 'JavaScript') 이터레이션 프로토콜 예 »
        +codeBtn('/Repositories/JavaScript/Basic/generator.js', 'JavaScript') 제너레이터 예 »
    ul
        li 파이썬과 마찬가지로 제어권을 주고받는 데 제너레이터를 사용한다
        li yield 키워드를 사용하는 모든 함수는 제너레이터 함수다
        li 제너레이터 함수를 호출하면 제너레이터 객체를 받는다
        li 제너레이터의 실행을 재개하는 3가지 메서드 : next(), send(), throw()

    h1 비동기 처리
    ol
        li 전통적 방식 : 콜백
        p setTimeout(), setInterval(), clearInterval()
            br
            |Error-first Callback : 콜백 첫번째 매개변수를 err로 사용하는 것
            br
            |Callback Hell : 연속적으로 콜백이 다른 콜백을 호출하여 관리하기 어려워지는 상황
        li Promise
        p 실행의 종료를 보장. 실행 상태(성공, 실패)에 따라 다른 콜백을 적절히 호출. 적절한 예외 처리도 지원 가능
            br
            |Promise의 생성은 resolve, reject 콜백을 매개변수로 받는 함수를 작성하기만 하면 된다
            +codeBtn('/Repositories/JavaScript/Basic/promise.js', 'JavaScript') promise.js »
            br
            |Promise.all(), Promise.race(), ...
        li async, await
        p 함수 정의 앞에 async 키워드를 사용하면 함수 내에서 await를 사용할 수 있다. 이때, 함수는 Promise가 결정될 때까지 일시 중지
            +codeBtn('/Repositories/JavaScript/Basic/async.js', 'JavaScript') async.js »

    h1 정규표현식
    ul
        li 정규표현식(RegExp) 리터럴 /X/
        p /123/gm과 new RegExp('123', 'gm')는 의미적으로 동일하다
        li Flag : g(global), i(ignoreCase), m(multiline), s(.이 newline도 매칭 Since ES2018)
        p global 플래그를 이용하는 경우, RegExp.lastIndex로 검색 위치를 기록하며, 해당 위치부터 재탐색한다
            |따라서 global RegExp에 동일 문자열을 반복적으로 test()하는 경우 true, false가 토글되는 현상을 경험할 수도 있다
        p ↓ 자바와 동일한 부분은 생략했음
        li Greedy 수량사
        p ?, *, +, {n}, {n, }, {n, m}
        li replace()에서의 backreference
        ul
            li $& 일치 문자열
            +asCode('JavaScript') '1 12 123 1234'.replace(/1/gm, '[$&]') // "[1] [1]2 [1]23 [1]234"
            li $` 앞부분
            +asCode('JavaScript') '1 12 123 1234'.replace(/1/gm, '[$`]') // "[] [1 ]2 [1 12 ]23 [1 12 123 ]234"
            li $' 뒷부분
            +asCode('JavaScript') '1 12 123 1234'.replace(/1/gm, "[$']") // "[ 12 123 1234] [2 123 1234]2 [23 1234]23 [234]234"
        li 관련 메서드
        ul
            li RegExp#test() : 패턴이 검색되는지 여부
            li RegExp#exec() : 매칭되는 인덱스들을 배열로 반환
                |매칭 시작 index, 검색 텍스트 input 프로퍼티를 가진다. [i] 접근으로 캡처 그룹을 가져올 수 있다
            +asCode('JavaScript') /1/gm.exec('1 12 123') // ["1", index: 0, input: "1 12 123", groups: undefined]
            li String#search(regexp) : 처음 매칭된 인덱스 반환
            li String#match(regexp) : 매칭되는 모든 부분문자열 반환
            li String#replace(regexp, replaceValue) : 매칭된 부분문자열을 replaceValue로 치환
            li String#split(regexp, limit) : 매칭된 문자열을 분리

    h1 버전별 신규 기능
    div
        h2 참고자료
        ul
            li: +asA('https://ecma-international.org/publications-and-standards/standards/ecma-262/')
                p 공식 문서 최상단 "Introduction"에서 버전별 주요 변경 사항이 정리되어 있다

        h2 ES2015, ES6
        div
            h3 Tagged template literal
            div
                p Tag function을 이용하여 문자열 보간 작업을 사용자 정의할 수 있다
                    +codeBtn({
                        path: '/Repositories/JavaScript/snippet/240314-162705.js',
                        lan: 'JavaScript',
                        title: '예시 코드'
                    })
                p 문자열이 아닌 걸 반환해도 된다
                    +codeBtn({
                        path: '/Repositories/JavaScript/snippet/240314-165131.js',
                        lan: 'JavaScript',
                        title: '예시 코드'
                    })
                p 언어 자체에 내장된 tag function도 있다
                +asCode('JavaScript') String.raw`C:\Development\profile\about.html`

        h2 ES2016
        ul
            li 지수 연산자 **
            li Array.prototype.includes() : 배열이 특정 원소를 포함하는지 여부 반환

        h2 ES2017
        ul
            li async function 정의, await 비동기 호출 지원
            li Object.values() : 객체의 순회 가능한 모든 값을 배열로 반환
            li Object.entries() : 객체의 순회 가능한 모든 [키, 값]쌍을 배열로 반환
            li Object.getOwnPropertyDescriptors() : 객체의 모든 프로퍼티 반환
                p 예. Object.assign()이 순회 가능한 프로퍼티만 복사하는 반면, 아래 코드는 모든 프로퍼티를 얕게 복사한다
                +asCode('JavaScript').
                    Object.create(
                        Object.getPrototypeOf(obj),
                        Object.getOwnPropertyDescriptors(obj),
                    )
            li String.prototype.padStart(), padEnd() 추가
        div
            h3 Shared Memory, Atomics
            ul
                li Atomics는 원자적 연산을 위한 함수들을, Shared Memory는 이를 위한 공유 메모리를 정의한다
                li 원자적 연산은 Java의 volatile 변수처럼, CPU 코어 수준으로 병렬 실행을 동기화한다
                li 공유 메모리 구현체는 SharedArrayBuffer인데, 브라우저에서는 기본적으로 비활성화되어 있으므로 사용하기 위해선 명시적인 설정이 필요하다
            +codeBtn({ path: '/Repositories/Single/202506/09-1435.js', lan: 'JavaScript', title: '예시 코드' })

        h2 ES2018
        ul
            li Promise.prototype.finally() : Promise 상태가 무엇으로 천이되든 무관하게 실행되는 블록
        div
            h3 비동기 반복자
            p 비동기 반복자는 Promise를 반환하는 반복자
            +asCode('JavaScript').
                const asyncIterator = (async function* () {
                  yield 1;
                  yield 2;
                  yield 3;
                })();
                (async () => {
                  for await (const value of asyncIterator) {
                    console.log(value);
                  }
                })();

            h3 객체 해체 할당 + 나머지 속성
            +asCode('JavaScript').
                const obj = {
                    x: [1, 2, 3],
                    y: { a: 4, b: 5, c: 6 },
                    z: [7, 8, 9]
                }
                const {
                    x: [x1, ...xRest],
                    y: { a: y1, ...yRest },
                    ...objRest
                } = obj
                console.info(x1)        // 1
                console.info(xRest)     // [2, 3]
                console.info(y1)        // 4
                console.info(yRest)     // {b: 5, c: 6}
                console.info(objRest)   // {"z": [7, 8, 9]}

            h3 정규표현식 기능 추가
            ul
                li RegExp.prototype.dotAll
                    p s 플래그를 이용해 생성한 정규표현식은 이 속성이 true로 설정된다. 특수 문자 .이 line terminator에도 매칭된다 (U+000A, U+000D, U+2028, U+2029)
                    +asCode('JavaScript').
                        /.+/.exec('abc\ndef')[0]    // 'abc'
                        /.+/s.exec('abc\ndef')[0]   // 'abc\ndef'
                li Named capture groups
                    +asCode('JavaScript').
                        /^(?&lt;id&gt;[a-zA-Z0-9._%+-]+)@(?&lt;domain&gt;[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})$/.exec('test-id@example.com').groups
                            // {id: 'test-id', domain: 'example.com'}
                li RegExp.prototype.unicode
                    ul
                        li u 플래그를 이용해 생성한 정규표현식은 이 속성이 true로 설정된다
                        li \u{1234}, \p{UnicodePropertyValue}를 이용해 유니코드 문자를 매칭할 수 있다
                        li Surrogate pair를 한 문자로 취급한다
                            +asCode('JavaScript').
                                /[😄]/.test(String.fromCodePoint('😄'.codePointAt(0)))  // true
                                /[😄]/.test(String.fromCodePoint('😄'.codePointAt(1)))  // true
                                /[😄]/u.test(String.fromCodePoint('😄'.codePointAt(0))) // true
                                /[😄]/u.test(String.fromCodePoint('😄'.codePointAt(1))) // false
                li Look-behind assertions
                    ul
                        li (?&lt;=y)x : positive lookbehind
                        li (?&lt;!y)x : negative lookbehind

        h2 ES2019
        ul
            li Array.prototype.flat() : 배열 차원 평탄화
            li Array.prototype.flatMap() : map()과 flat()을 순서대로 적용한 것과 같은 결과
            li Object.fromEntries() : Iterable&lt;[key, value]&gt;로부터 객체 생성 -- Array, Map, 또는 사용자 정의 iterable
            li String.prototype.trimStart(), trimEnd() 추가
            li 배열 정렬 메서드 -- sort()는 이제 stable (정렬 키가 동일한 두 요소의 순서는 정렬 후에도 유지)
            li JSON.stringify()는 입력과 무관하게 well-formed UTF-8 문자열을 반환
            li 필요 없다면 catch 블록 파라미터 생략 가능
            li Symbol.prototype.description getter 추가
            li Function.prototype.toString() : 함수가 ECMAScript로 정의된 경우, 함수 본문 반환

        h2 ES2020
        ul
            li import() : import .. from ... 구문과 다르게, 런타임에 동적으로 모듈 로드
            li import.meta : ES 모듈을 이용하는 경우, #[+asInlineCode('import.meta.url', 'JavaScript')]를 이용해 모듈 URL 획득 가능
            li export * as newName from 'module' : 모듈의 defaults를 다시 노출하기만 할 때 편의 제공
            li BigInt : #[+asInlineCode('Number.MAX_SAFE_INTEGER', 'JavaScript')]보다 큰 정수도 정확히 보존하는 정수 자료형
            li String.prototype.matchAll() : g 플래그를 켠 정규표현식의 모든 매치 결과를 순회할 수 있는 iterator 반환 -- 기존엔 전문검색을 위해 루프를 실행해야 했다
            li globalThis : 실행 환경(브라우저, Node, Deno, ...)과 무관하게 전역 컨텍스트를 통한 변수 접근 방법 제공
        div
            h3 Optional chaining (?.)
            ul
                li ?. 연산자를 이용하여 객체의 속성을 접근하거나 메서드를 호출할 수 있다
                li 이 연산자로 접근하려는 객체나 호출하려는 함수가 undefined나 null인 경우, 연산은 단락되고 undefined를 반환한다
            
            h3 Nullish coalescing operator (??)
            p 연산자 좌변이 null 또는 undefined인 경우, 연산자 우변을 반환한다

            h3 Promise.allSettled()
            p Promise.all()은 일부가 실패한 경우 아래 2가지가 불가능했는데, allSettled()는 모두 가능하다
                +codeBtn({
                    path: '/Repositories/JavaScript/snippet/240314-190540.js',
                    lan: 'JavaScript',
                    title: '예시 코드'
                })
            ul
                li 성공한 Promise의 반환값 획득
                li 2번째 이후로 실패한 Promise의 에러 획득
        
        h2 ES2021
        ul
            li String.prototype.replaceAll() : 정규표현식 모든 매칭에 대해 치환
            li Promise.any() : 여러 Promise 중 하나라도 완료되면 반환
            li AggregateError : 여러 에러를 한 번에 표현
            li ??=, &amp;&amp;=, ||= 논리 연산자 추가
            li WeakRef : 약한 참조 생성 ~ GC 수집 후 커스텀 finalizer 실행
                p FinalizationRegistry : 지정한 객체가 GC로 정리된 경우 호출. #[+asA('https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry#notes_on_cleanup_callbacks', '단, 이에 의존하면 안 됨')]
            li 1_000처럼 리터럴 자리 구분 가능

        h2 ES2022
        ul
            li 에러 원인을 cause 프로퍼티에 설정 가능
            li Array.prototype.at(), String.prototype.at() : 음수 인덱스도 지원하는 원소 접근 메서드
            li Object.hasOwn(obj, propKey) : Object.prototype.hasOwnProperty()의 안전한 버전
        div
            h3 모듈 최상위 레벨 await 가능
            +asCode('JavaScript').
                import ...

                await loadSecrets()
                await readyDB()

            h3 클래스 정의 관련
            ul
                li static 프로퍼티, 메서드, 초기화 블록 정의 가능
                li constructor() 바깥의 클래스 body에서 프로퍼티 정의 가능
                li 프로퍼티 또는 accessor 식별자를 #으로 시작하면 private
            
            h3 정규표현식 d 플래그 추가
            p 패턴 전체 및 각 캡처링 그룹에 대한 시작/끝 위치를 indices 속성에 제공
            +asCode('JavaScript').
                /(aa)(bb)/d.exec('aaabbbccc').indices
                /*
                [
                    [1, 5],
                    [1, 3],
                    [3, 5]
                ]
                */

        h2 WHATWG 2022
        div
            h3: +asA('https://developer.mozilla.org/en-US/docs/Web/API/Window/structuredClone', 'structuredClone(value[, options])')
            p 객체 깊은 복사 지원
        
        h2 ES2023
        ul
            li 배열에 findLast(), findLastIndex() 추가
            li 스크립트 첫 줄에 #!(Hashbang; Shebang) 지원
            li WeakMap 키로 non-registered symbol 사용 가능 -- Symbol.for()로 생성한 건 불가능
        div
            h3 원본 수정 없이 사본을 반환하는 배열 메서드
            ul
                li with(index, value) : 지정한 index 원소로 value를 갖는 사본 반환
                li toSorted(compareFn?) : 정렬된 사본 반환
                li toReversed() : 원소가 역순인 사본 반환
                li toSpliced(...) : splice(...)를 수행한 사본 반환

        h2 ES2024
        ul
            li Object.groupBy(), Map.groupBy()를 이용한 집계 결과 생성
            li String.prototype.isWellFormed, toWellFormed 추가
        div
            h3 Promise.withResolvers()
            p Promise 객체의 상태 천이를 Promise 정의 바깥에서 하고 싶을 때
            +asCode('JavaScript').
                let resolver, rejector
                const promise = new Promise((resolve, reject) => {
                    resolver = resolve
                    rejector = reject
                })
            p 위와 같은 코드를 아래와 같이 축약할 수 있다
            +asCode('JavaScript') const { promise, resolve, reject } = Promise.withResolvers()

            h3 RegExp.prototype.unicodeSets
            ul
                li v 플래그를 이용해 생성한 정규표현식은 이 속성이 true로 설정된다
                li v 플래그는 유니코드 관련 기능을 활성화하는 u 플래그의 업그레이드 버전인데, 구문 해석 방식이 다르기 때문에 두 플래그를 모두 설정하면 SyntaxError가 발생한다
                li u 플래그에 비해 character class [...], [^...] 에 다음의 기능들이 추가된다
                    ul
                        li 추가적인 집합 연산 사용 가능
                            ul
                                li [operand1&amp;&amp;operand2] : 교집합
                                li [operand1--operand2] : 차집합
                                li 연산자를 한 번에 2개 이상 적용하는 것은 불가능하지만, nested 표기를 이용하면 쉽게 달성할 수 있다
                                    p 한편, 단순 나열은 합집합 연산을 의미하므로 [AB--C]도 유효하지 않으며, [A[B--C]]와 같이 사용해야 한다
                        li [\q{substring}]으로 유니코드 리터럴 지정 가능. 내부에선 | 연산자만 이용 가능
                        li \p 이스케이프로 RGI_Emoji와 같은 더 다양한 유니코드 클래스 집합 지정 가능
                li i 플래그에서 \P{property} 평가가 달라진다
                    ul
                        li #[+asInlineCode("/\P{Lowercase_Letter}/iu.test('a') === true", 'JavaScript')]
                            p u 모드에서는 case-folding이 여집합 구성 후에 발생한다
                            ol
                                li Lowercase_Letter에 대한 여집합이 생성된다 : uppercase + caseless
                                li i 플래그를 위해 집합의 소문자 버전이 생성된다 : lowercase + caseless
                                li 입력 문자열은 패턴 매칭 전에 소문자 버전으로 변환된다
                                li 'a'는 패턴을 만족하므로 true 반환
                        li #[+asInlineCode("/\P{Lowercase_Letter}/iv.test('a') === false", 'JavaScript')]
                            p v 모드에서는 case-folding이 여집합 구성 전에 발생한다
                            ol
                                li Lowercase_Letter에 대한 소문자 버전 집합이 생성된다 : lowercase
                                li 대문자를 포함하지 않는 여집합이 생성된다 : caseless
                                li 입력 문자열은 패턴 매칭 전에 소문자 버전으로 변환된다
                                li 'a'는 패턴을 만족하지 않으므로 false 반환
                li i 플래그에서 character class complement syntax [^...] 에 대한 해석이 달라진다
                    ul
                        li #[+asInlineCode("/[^\P{Lowercase_Letter}]/iu.test('A') === false", 'JavaScript')]
                            p u 모드에서는 패턴을 반대로 평가한다
                            ol
                                li Lowercase_Letter에 대한 여집합이 생성된다 : uppercase + caseless
                                li i 플래그를 위해 집합의 소문자 버전이 생성된다 : lowercase + caseless
                                li 입력 문자열은 패턴 매칭 전에 소문자 버전으로 변환된다
                                li 'a'는 패턴을 만족하므로 false -- [^...]는 패턴을 매치 결과를 뒤집는다
                        li #[+asInlineCode("/[^\P{Lowercase_Letter}]/iv.test('A') === true", 'JavaScript')]
                            p v 모드에서는 패턴을 반대로 평가하는 대신 여집합을 구성한다
                            ol
                                li Lowercase_Letter에 대한 소문자 버전 집합이 생성된다 : lowercase
                                li 대문자를 포함하지 않는 여집합이 생성된다 : caseless
                                li 대문자를 포함하지 않는 여집합이 생성된다 : lowercase -- \P와 [^...]는 서로 상쇄된다
                                li 입력 문자열은 패턴 매칭 전에 소문자 버전으로 변환된다
                                li 'a'는 패턴을 만족하므로 true
                li v 모드가 grapheme cluster를 한 문자로 취급하지는 않는다. 여전히 코드 포인트의 모음으로 취급한다
                    +asCode('JavaScript').
                        /😵‍💫/.test('😵‍💫')     // true
                        /😵‍💫/v.test('😵‍💫')    // true

                        /[😄-😛]/.test("😑")    // SyntaxError: Invalid regular expression: /[😄-😛]/: Range out of order in character class
                        /[😄-😛]/v.test("😑")   // true

                        /[😵‍💫]/.test('😵‍💫'.charAt(3))                             // true
                        /[😵‍💫]/v.test('😵‍💫'.charAt(3))                            // false
                        /[😵‍💫]/v.test(String.fromCodePoint('😵‍💫'.codePointAt(3))) // true

            h3 가변 길이 ArrayBuffer 지원
            ul
                li 처음부터 변경 가능하도록 생성
                    +asCode('JavaScript').
                        buf = new ArrayBuffer(4, { maxByteLength: 8 })
                        console.log(buf.byteLength) // 4

                        buf.resize(8)
                        console.log(buf.byteLength) // 8
                li 사용 도중 1회적으로 변경
                    +asCode('JavaScript').
                        buf = new ArrayBuffer(4)
                        console.log(buf.byteLength)     // 4

                        newBuf = buf.transfer(8)
                        console.log(buf.detached)       // true
                        console.log(newBuf.byteLength)  // 8

        h2 ES2025
        div
            h3: +asA('https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import/with', 'import 속성 지정')
            p 예를 들어, 클라이언트는 아래와 같이 JSON을 기대했지만
            +asCode('JavaScript') import config from 'https://xxx/config.json'
            p 서버가 JSON이 아닌 실행 가능한 JavaScript 코드를 응답하면 의도치 않게 해당 코드가 실행되는 문제가 있었다. 이제는 속성을 지정하여 이러한 경우 명시적으로 오류를 발생할 수 있다
            +asCode('JavaScript').
                import styles from "https://example.com/styles.css" with { type: "css" }
                import("https://example.com/data.json", { with { type: "json" } })

            h3: +asA('https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Iterator#iterator_helper_methods')
            p Iterator helper method는 기존 iterator를 이용하는 새로운 iterator helper object를 반환한다. 두 iterator의 진행도는 동기화되며, 독립적으로 진행되지 않는다
            ul
                li drop(limit) : 최초 limit개의 요소 순회 생략
                li every(callbackFn) : 모든 요소가 조건을 만족하면 true
                li filter(callbackFn) : 조건에 맞는 요소만 순회
                li find(callbackFn) : 조건에 맞는 첫 번째 요소를 반환
                li flatMap(callbackFn) : iterator 또는 iterable을 반환하여 차원 평탄화
                li forEach(callbackFn) : 모든 요소 소비
                li map(callbackFn) : 요소를 변환하여 순회
                li reduce(callbackFn[, initialValue]) : 모든 요소를 소비하여 결과값 축약
                li some(callbackFn) : 일부 요소가 조건을 만족하면 true
                li take(limit) : 최초 limit개의 요소만 순회

            h3 Iterator 유틸리티 추가
            ul
                li Iterator.prototype.toArray() : 하는 일은 Array.from(iterator), [...iterator]와 동일
                li Iterator.from(object)
                    ul
                        li object가 iterable인 경우 : 해당 객체의 [Symbol.iterator]()를 순회에 이용하는 새로운 iterator 반환
                        li object가 iterator인 경우 : 해당 객체 그대로 반환
                        li 그 외의 경우 : 해당 객체(iterator로 간주)를 감싼 새 Iterator 객체 반환 -- 사용시 런타임 에러 발생 가능
                li new Iterator() : Iterator를 상속하여 순회 알고리즘 직접 구현 가능. Generator를 이용하는 구현과 다르게, Iterator의 모든 헬퍼 메서드 이용 가능

            h3 집합 연산 추가
            ul
                li difference(other) : 차집합 반환
                li intersection(other) : 교집합 반환
                li isDisjointFrom(other) : 교집합이 0인지 검사
                li isSubsetOf(other) : 부분집합인지 검사
                li isSupersetOf(other) : other를 모두 포함하는지 검사
                li symmetricDifference(other) : 대칭차집합 반환
                li union(other) : 합집합 반환

            h3 정규식 업데이트
            ul
                li RegExp.escape()
                    p RegExp 생성자에 그대로 사용할 수 있는 문자열 반환
                    +asCode('JavaScript').
                        txt = `abc!@#$%^&*(){}[]'";`
                        new RegExp(RegExp.escape(txt)).test(txt)    // true

                li Flag modifier
                    p 정규식 특정 파트에 대해서만 추가로 플래그를 켜거나 끄는 게 가능
                    ul
                        li (?flags1:pattern) : flags1에 지정한 플래그들을 추가로 적용
                        li (?flags1-flags2:pattern) : flags1에 지정한 플래그들을 추가로 적용 + flags2에 지정한 플래그들은 적용하지 않음

                li 중복 명명된 캡처링 그룹 허용
                    +asCode('JavaScript').
                        txt = 'aabbbcccc'
                        regex = /(?&lt;chars>a+)|(?&lt;chars>b+)/g
                        console.log(regex.exec(txt), regex.exec(txt))
                    +w3img('/imgs/202507/Screenshot 2025-07-23 at 6.19.03 PM.png')

            h3 Promise.try()
            p 가능한 모든 형태의 함수 호출을 Promise로 변환
            +asCode('JavaScript').
                Promise.try(func)
                Promise.try(func, arg1)
                Promise.try(func, arg1, arg2)
                Promise.try(func, arg1, arg2, /* …, */ argN)

            h3 Float16 지원
            p 16비트 float 사용으로 오히려 연산 성능 저하를 경험할 수 있다. 16비트 연산에 최적화된 플랫폼에서 사용하는 것이 권장된다
            ul
                li Math.f16round()
                li Float16Array
                li DataView.prototype.getFloat16(), setFloat16()
