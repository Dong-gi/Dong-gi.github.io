include ../../../source/skeleton.pug

+post({
    title: 'PostgreSQL SQL',
    description: 'PostgreSQL에서 사용하는 SQL 정리',
})

    h1 SQL Syntax
    div
        h2 Lexical Structure
        ul
            li.marker 식별자와 키워드
            ol
                li select, from : 키워드
                li "select" : ""로 감싼 식별자. U&"d\0061t\+000061"처럼 유니코드 코드 포인트를 이용할 수 있다
                li table_name : Unquoted 식별자. 대소문자를 구별하지 않는다
                p select라는 이름의 컬럼을 가져오려면 select "select" from table_name;처럼 이용한다. 그로지 말자...
            li.marker 상수
            ol
                li 문자열 상수 : '문자열'
                li 달러 인용 문자열 상수 : 달러 인용 문자열은 이스케이프되지 않는다
                +asCode('sql').
                    $$Dianne's horse$$, $SomeTag$Dianne's horse$SomeTag$
                    CREATE OR REPLACE FUNCTION change_inaba_name() RETURNS TRIGGER AS $$
                    BEGIN
                        NEW.status_text = REPLACE(NEW.status_text, 'イナバ', '이나바');
                        RETURN NEW;
                    END;
                    $$ LANGUAGE plpgsql;

        h2 Value Expressions
        div
            h3 열 참조
            +asCode('sql').
                -- correlation은 테이블 이름이나 alias
                correlation.columnname
            h3 위치 매개변수 : 함수 정의의 매개변수 위치를 이용해 변수 참조
            +asCode('sql').
                -- 문자열을 2번 반복해서 반환하는 함수
                CREATE OR REPLACE FUNCTION test(text) RETURNS text AS $body$ SELECT $1 || $1 $body$ LANGUAGE sql;
            h3 배열 요소 참조
            +asCode('sql').
                -- subscript는 integer 값을 내는 표현식
                expression[subscript]
                expression[lower_subscript:upper_subscript]
            h3 필드 선택
            +asCode('sql').
                -- 특정 행의 열 참조. expression은 row type 또는 열집합
                expression.fieldname
                -- 일반적으로 expression은 괄호로 감싸져야 하지만, 테이블이나 위치 매개변수의 경우 생략할 수 있다
                -- .*로 모든 필드를 얻을 수 있다
            h3 집계 함수 호출
            ol
                li 집계 함수(aggregate function)란 여러 입력 행들을 하나의 결과행으로 줄이는 함수
                li 집계 함수 호출 형태
                +asCode('sql').
                    aggregate_name (expression [ , ... ] [ order_by_clause ] ) [ FILTER ( WHERE filter_clause ) ]
                    -- default로 ALL이므로 아래와 동일
                    aggregate_name (ALL expression [ , ... ] [ order_by_clause ] ) [ FILTER ( WHERE filter_clause ) ]

                    aggregate_name (DISTINCT expression [ , ... ] [ order_by_clause ] ) [ FILTER ( WHERE filter_clause ) ]

                    -- ↓ 보통 count에서만 사용되는 형태
                    aggregate_name ( * ) [ FILTER ( WHERE filter_clause ) ]

                    -- expression은 집계 함수나 윈도우 함수 호출을 포함하지 않아야 한다
                    aggregate_name ( [ expression [ , ... ] ] ) WITHIN GROUP ( order_by_clause ) [ FILTER ( WHERE filter_clause ) ]

                    -- 복수의 인자를 받는 집계 함수에서는 ORDER BY 절이 전체 인자가 끝나고 등장해야 한다
                    SELECT string_agg(str, ',' ORDER BY str) FROM table;

                    -- 실제 호출 예
                    SELECT count(*) AS unfiltered, count(*) FILTER (WHERE num &lt; 5) AS filtered FROM generate_series(1,10) AS num;
                li: +asA('http://postgresql.kr/docs/9.6/functions-aggregate.html', '내장 집계 함수 목록')
            h3 윈도우 함수 호출
            ol
                li 윈도우 함수는 집계 함수와 비슷하지만, 입력 행들이 결과에 그대로 나타난다
                li 윈도우 함수 호출 형태
                +asCode('sql').
                    function_name ([expression [, expression ... ]]) [ FILTER ( WHERE filter_clause ) ] OVER window_name
                    function_name ([expression [, expression ... ]]) [ FILTER ( WHERE filter_clause ) ] OVER ( window_definition )
                    function_name ( * ) [ FILTER ( WHERE filter_clause ) ] OVER window_name
                    function_name ( * ) [ FILTER ( WHERE filter_clause ) ] OVER ( window_definition )
                li window_name ::= WINDOW 절로 정의된 윈도우 이름
                p OVER window_name과 OVER (window_name)은 다르다. 후자의 경우 윈도우 정의를 복사하여 적용하며, frame 절을 포함하는 경우 수행되지 않는다
                li window_definition ::=
                +asCode('sql').
                    [ existing_window_name ]
                    -- PARTITION BY 옵션은 행 그룹을 만든다. GROUP BY와 달리 출력-열이나 숫자를 지정할 수 없다
                    [ PARTITION BY expression [, ...] ]
                    -- ORDER BY 절도 마찬가지로 출력-열이나 숫자를 지정할 수 없다
                    [ ORDER BY expression [ ASC | DESC | USING operator ] [ NULLS { FIRST | LAST } ] [, ...] ]
                    [ frame_clause ]
                li frame_clause
                ol
                    p frame_clause는 윈도우 함수가 전체 파티션이 아닌, 현재까지의 파티션을 대상으로 계산을 수행하게 한다
                    li { RANGE | ROWS } frame_start -- default로 frame_end는 CURRENT ROW
                    li { RANGE | ROWS } BETWEEN frame_start AND frame_end
                    p ↑ UNBOUNDED PRECEDING으로 지정된 frame_start는 파티션의 첫 행, UNBOUNDED FOLLOWING으로 지정된 frame_end는 파티션 마지막 행을 의미한다
                li frame_start, frame_end
                ol
                    li UNBOUNDED PRECEDING
                    li CURRENT ROW
                    li UNBOUNDED FOLLOWING
                    p ↓ value PRECEDING, FOLLOWING은 ROWS 모드에서만 사용 가능하고, 현재 행을 전후로 하여 프레임 크기를 설정한다
                    li value PRECEDING
                    li value FOLLOWING
                li frame_exclusion
                ol
                    li EXCLUDE CURRENT ROW
                    li EXCLUDE GROUP
                    li EXCLUDE TIES
                    li EXCLUDE NO OTHERS
                li expression은 윈도우 함수 호출을 포함하지 않아야 한다
                li: +asA('http://postgresql.kr/docs/9.6/functions-window.html#FUNCTIONS-WINDOW-TABLE', '내장 윈도우 함수 목록')
            h3 Collation Expressions
            +asCode('sql').
                -- 로캐일에 따른 정렬
                SELECT * FROM tbl WHERE ... ORDER BY a COLLATE "C"; -- 결과 정렬
                SELECT * FROM tbl WHERE a > 'foo' COLLATE "C";   -- 입력 정렬
                SELECT * FROM tbl WHERE a COLLATE "C" > 'foo';   -- 입력 정렬
                SELECT * FROM tbl WHERE (a > 'foo') COLLATE "C"; -- 에러. 연산 결과인 boolean은 non-collatable
            ol
                p LC_COLLATE를 설정하여 기본 로캐일에 따른 정렬을 수행하게 할 수 있다
                li 데이터베이스 최초 생성 시 LC_COLLATE 변수 값을 'C'로 설정
                li 기존 데이터베이스를 dump하고, LC_COLLATE를 'C'로 설정한 데이터베이스를 만들어 복구
                +asCode('sql').
                    db_name=# DROP DATABASE [db_name];
                    db_name=# CREATE DATABASE [db_name] LC_COLLATE 'C';
                    -- 데이터베이스는 생성될 때 기본적으로 template1 데이터베이스를 복제하여 생성된다. 하지만 이는 로캐일이 이미 설정되어 충돌하여 에러가 발생할 수 있다
                    db_name=# CREATE DATABASE [db_name] TEMPLATE template0 LC_COLLATE 'C';
            h3 Scalar Subqueries : 한 행 또는 한 컬럼을 반환하는, 괄호에 감싸인 SELECT 쿼리
            +asCode('sql') SELECT name, (SELECT max(pop) FROM cities WHERE cities.state = states.name) FROM states;
            h3 배열 생성자
            +asCode('sql').
                SELECT ARRAY[1,2,3+4];
                SELECT ARRAY[1,2,22.7]::integer[];
                -- 빈 배열도 형식은 필요
                SELECT ARRAY[]::integer[];
                SELECT ARRAY[ARRAY[1,2], ARRAY[3,4]];
                SELECT ARRAY(SELECT oid FROM pg_proc WHERE proname LIKE 'bytea%');
                CREATE TABLE arr(f1 int[], f2 int[]);
                INSERT INTO arr VALUES (ARRAY[[1,2],[3,4]], ARRAY[[5,6],[7,8]]);
            h3 행 생성자
            +asCode('sql').
                SELECT ROW(1,2.5,'this is a test');
                SELECT ROW(t.*, 42) FROM t; -- t는 행 값
                SELECT ROW(t.*, 42) FROM (SELECT ROW(1,2.5,'this is a test')) as t;
                CREATE TABLE mytable(f1 int, f2 float, f3 text);
                CREATE OR REPLACE FUNCTION getf1(mytable) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;
                -- No cast needed since only one getf1() exists
                SELECT getf1(ROW(1,2.5,'this is a test'));
                CREATE TYPE myrowtype AS (f1 int, f2 text, f3 numeric);
                CREATE OR REPLACE FUNCTION getf1(myrowtype) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;
                -- Now we need a cast to indicate which function to call:
                SELECT getf1(ROW(1,2.5,'this is a test')::mytable);
                SELECT getf1(CAST(ROW(11,'this is a test',2.5) AS myrowtype));
            h3 Expression Evaluation Rules
            ol
                li SELECT true OR somefunc();와 SELECT somefunc() OR ture; 모두 somefunc()가 호출되지 않는다. short-circuit 연산과는 다르다
                li SELECT ... WHERE CASE WHEN x > 0 THEN y/x > 1.5 ELSE false END;
                li SELECT CASE WHEN x > 0 THEN x ELSE 1/0 END FROM tab;
                p 주의. IMMUTABLE 함수는 값이 먼저 평가되기 때문에, 실제로 x가 항상 0보다 크더라도 1/0이 미리 평가되어 에러가 발생한다
                    +asA('http://postgresql.kr/docs/current/xfunc-volatility.html', 'xfunc-volatility')

        h2 함수 호출
        +asCode('sql').
            -- PostgreSQL의 함수의 인자는 이름과 위치 둘 다로 참조할 수 있다
            CREATE FUNCTION concat_lower_or_upper(a text, b text, uppercase boolean DEFAULT false) RETURNS text AS $$
                SELECT CASE
                    WHEN $3 THEN UPPER($1 || ' ' || $2)
                    ELSE LOWER($1 || ' ' || $2)
                END;
            $$ LANGUAGE SQL IMMUTABLE STRICT;
        ol
            li Using Positional Notation
            +asCode('sql') SELECT concat_lower_or_upper('Hello', 'World');
            li Using Named Notation
            +asCode('sql') SELECT concat_lower_or_upper(a => 'Hello', b => 'World');
            li Using Mixed Notation
            p 키워드 인자는 나머지보다 뒤에 위치해야 한다
            +asCode('sql') SELECT concat_lower_or_upper('Hello', 'World', uppercase => true);

    h1 Data Definition
    div
        h2 Default Values
        +asCode('sql').
            -- 기본값에 표현식을 사용할 수 있다. 가장 흔히 쓰이는 것은 timestamp 열이 CURRENT_TIMESTAMP 값을 갖게 하는 것
            CREATE TABLE products (
                product_no integer DEFAULT nextval('products_product_no_seq'),
                ...
            );
        h2 Constraints
        ol
            li.marker Check Constraints
            +asCode('sql').
                CREATE TABLE products ( product_no integer, price numeric CHECK (price > 0) );

                -- 식별자를 줄 수 있다
                CREATE TABLE products ( product_no integer, price numeric CONSTRAINT positive_price CHECK (price > 0) );

                -- 여러 열을 체크할 수 있다
                CREATE TABLE products (
                    product_no integer,
                    name text,
                    price numeric CHECK (price > 0),
                    discounted_price numeric CHECK (discounted_price > 0), CHECK (price > discounted_price)
                );

                -- 열 삽입 제약 조건을 테이블 제약 조건으로 사용할 수 있다
                CREATE TABLE products (
                    product_no integer,
                    name text,
                    price numeric CHECK (price > 0),
                    discounted_price numeric,
                    CHECK (discounted_price > 0 AND price > discounted_price)
                );
            li.marker Not-Null Constraints
            +asCode('sql') CREATE TABLE products ( product_no integer NOT NULL, price numeric );
            li.marker Unique Constraints
            +asCode('sql').
                CREATE TABLE products ( product_no integer UNIQUE, price numeric );
                CREATE TABLE products ( product_no integer, price numeric, UNIQUE (product_no) );
                CREATE TABLE example ( a integer, b integer, c integer, UNIQUE (a, c) );
                -- 식별자를 부여할 수 있다
                CREATE TABLE products ( product_no integer CONSTRAINT must_be_different UNIQUE, price numeric );
            li.marker Primary Keys
            +asCode('sql') CREATE TABLE example ( a integer, b integer, c integer, PRIMARY KEY (a, c) );
            li.marker Foreign Keys
            +asCode('sql').
                CREATE TABLE orders (
                    order_id integer PRIMARY KEY,
                    product_no integer REFERENCES products (product_no),
                    quantity integer
                );
                CREATE TABLE t1 (
                    a integer PRIMARY KEY,
                    b integer,
                    c integer,
                    FOREIGN KEY (b, c) REFERENCES other_table (c1, c2)
                );
                -- 외래키와 기본키 혼용
                CREATE TABLE order_items (
                    product_no integer REFERENCES products,
                    order_id integer REFERENCES orders,
                    quantity integer,
                    PRIMARY KEY (product_no, order_id)
                );
            li.marker 무결성 제약 : ON DELETE, ON UPDATE에 사용
            +asCode('sql').
                CREATE TABLE order_items (
                    product_no integer REFERENCES products ON DELETE RESTRICT, -- 참조하는 행이 삭제되지 않음
                    order_id integer REFERENCES orders ON DELETE CASCADE, -- 참조하는 행이 삭제되면 같이 삭제됨
                    quantity integer,
                    PRIMARY KEY (product_no, order_id)
                );
        h2 System Columns
        p oid : object_id. 테이블을 WITH OIDS로 생성하거나, default with oids이 설정된 경우 생성되는 열. 타입 이름도 oid
            +asA('http://postgresql.kr/docs/9.6/ddl-system-columns.html')
        h2 Modifying Tables
        ol
            li.marker Adding a Column
            +asCode('sql').
                ALTER TABLE products ADD COLUMN description text;
                ALTER TABLE products ADD COLUMN description text CHECK (description != '');
            li.marker Removing a Column
            +asCode('sql').
                ALTER TABLE products DROP COLUMN description;
                -- 외래키로 참조중인 경우, 제약을 명시해줘야 반영된다
                ALTER TABLE products DROP COLUMN description CASCADE;
            li.marker Adding a Constraint
            +asCode('sql').
                ALTER TABLE products ADD CHECK (name != '');
                ALTER TABLE products ADD CONSTRAINT some_name UNIQUE (product_no);
                ALTER TABLE products ADD FOREIGN KEY (product_group_id) REFERENCES product_groups;
                ALTER TABLE products ALTER COLUMN product_no SET NOT NULL;
            li.marker Removing a Constraint
            +asCode('sql').
                ALTER TABLE products DROP CONSTRAINT some_name;
                ALTER TABLE products ALTER COLUMN product_no DROP NOT NULL;
            li.marker Changing a Column's Default Value
            +asCode('sql').
                ALTER TABLE products ALTER COLUMN price SET DEFAULT 7.77;
                ALTER TABLE products ALTER COLUMN price DROP DEFAULT;
            li.marker Changing a Column's Data Type
            +asCode('sql').
                ALTER TABLE products ALTER COLUMN price TYPE numeric(10,2);
                -- 기존 값이 새로운 타입으로 암묵적으로 변환된다면 위의 것으로 충분. 복잡한 변환을 명시하려면 USING 절을 추가 사용
            li.marker Renaming a Column
            +asCode('sql') ALTER TABLE products RENAME COLUMN product_no TO product_number;
            li.marker Renaming a Table
            +asCode('sql') ALTER TABLE products RENAME TO items;
        h2 Privileges
        p 권한 : SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER, CREATE, CONNECT, TEMPORARY, EXECUTE, USAGE &lt;&lt; ALL
        +asCode('sql').
            GRANT UPDATE ON table_name TO username;
            REVOKE ALL ON table_name FROM username;
            GRANT SELECT ON ALL TABLES IN SCHEMA public TO user;
            GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO user;
        h2
            |Row Security Policies
            +asA('http://postgresql.kr/docs/current/ddl-rowsecurity.html', 'ddl-rowsecurity')
        +asCode('sql').
            -- 관리자 그룹에 속한 사용자가, 자신과 관련한 행만 접근
            CREATE TABLE accounts (manager text, company text, contact_email text);
            ALTER TABLE accounts ENABLE ROW LEVEL SECURITY;
            CREATE POLICY account_managers ON accounts TO managers USING (manager = current_user);
        h2 Schemas
        +asCode('sql').
            CREATE SCHEMA myschema; -- Schema의 테이블은 schema.table 또는 database.schema.table로 접근
            CREATE TABLE myschema.mytable ( ... );
            DROP SCHEMA myschema;
            DROP SCHEMA myschema CASCADE; -- 포함된 내용도 삭제
            -- 모든 새 데이터베이스는 public이라는 스키마를 갖고 있다. 따라서 아래 두 문장은 서로 같다
            CREATE TABLE products ( ... );
            CREATE TABLE public.products ( ... );
        h2 Table Partitioning
        ul
            li 개요
            ol
                li Table partitioning : 논리적으로 하나인 거대한 테이블을 물리적으로 여러 개로 쪼개 저장하는 것
                li Range partitioning : 중복되지 않는 열 집합의 구간들로 분할
                li List partitioning : 명시적인 키값 리스트로 분할
                li Hash partitioning : 모듈로 n 공간에서 키값의 나머지가 같은 것들로 분할
                li 상속을 이용한 파티셔닝 : 자식 테이블은 추가적인 컬럼을 가질 수 있으며, 다중 상속도 가능하다
            li 파티셔닝
            p CHECK, NOT NULL 제약 조건은 파티션 테이블에 상속된다. NO INHERIT 마킹된 CHECK 제약조건은 제외
            +asCode('sql').
                create table api_access_log ( account_id int, access_time datetime, request_uri text ) partition by range(access_time);
                create table api_access_log_201901 partition of api_access_log for values from ('2019-01-01') to ('2019-02-01');
                -- 파티션 테이블을 파티셔닝할 수 있다
                create table api_access_log_201901 partition of api_access_log for values from ('2019-01-01') to ('2019-02-01') partition by range(account_id % 100);
            li.marker 주의
            ol
                li 값 변경으로 인해 행이 한 파티션에서 다른 파티션으로 이동되는 경우, 예약된 UPDATE, DELETE 작업이 실패할 수 있다
                li BEFORE ROW 트리거는 각 파티션 테이블에 따로 정의해야 한다
            li.marker Partition Pruning
            ol
                li SET enable_partition_pruning = on;로 옵션을 켤 수 있다. 켜 있는 게 디폴트
                li 가지치기 옵션이 켜있는 경우, 파티셔닝된 테이블의 정의(인덱스의 정의가 아니라)를 살펴, 스캔하지 않아도 되는 테이블들은 제외한다
                li 가지치기 시점 : 쿼리 플랜 초기화 시, 쿼리 플랜 실행 중(Append 노드 타입에 한하여)

    h1 Data Manipulation
    ol
        li Inserting Data, Updating Data, Deleting Data
        p DB - PostgreSQL 시작하기 - SQL 언어 참고
        li Returning Data From Modified Rows
        +asCode('sql').
            INSERT INTO users (firstname, lastname) VALUES ('Joe', 'Cool') RETURNING id;
            UPDATE products SET price = price * 1.10 WHERE price &lt;= 99.99 RETURNING name, price AS new_price;
            DELETE FROM products WHERE obsoletion_date = 'today' RETURNING *;

    h1 Queries
    div
        h2 Table Expressions
        div
            h3 FROM 절
            ul
                li 일반
                +asCode('sql') FROM table_reference [, table_reference [, ...]]
                li.marker Cartesian product(Cross join)
                +asCode('sql') FROM T1 CROSS JOIN T2
                p 또는 콤마로 구분
                +asCode('sql') FROM T1, T2
                li.marker 판별식을 이용한 조인
                +asCode('sql') FROM T1 { [INNER] | { LEFT | RIGHT | FULL } [OUTER] } JOIN T2 ON boolean_expression
                p 두 테이블에 대해 판별식이 참일 경우에만 결과 행으로 반환된다
                li.marker 컬럼 셋을 이용한 조인
                +asCode('sql') FROM T1 { [INNER] | { LEFT | RIGHT | FULL } [OUTER] } JOIN T2 USING ( join column list )
                p 두 테이블의 컬럼 셋이 일치하는 경우에만 결과 행으로 반환된다
                li.marker 자연 조인
                +asCode('sql') FROM T1 NATURAL { [INNER] | { LEFT | RIGHT | FULL } [OUTER] } JOIN T2
                p 두 테이블의 공통된 컬럼 리스트를 USING한 것과 동일한 결과를 산출한다
                li 테이블 별명
                +asCode('sql') FROM table_reference [AS] alias
                p 셀프 조인을 위해선 필수적으로 사용된다. 모호함을 피하기 위해 괄호를 이용할 수도 있다
                +asCode('sql') SELECT * FROM (my_table AS a CROSS JOIN my_table) AS b ...
                p 컬럼에도 별명을 붙일 수 있다
                +asCode('sql') FROM table_reference [AS] alias ( column1 [, column2 [, ...]] )
                li 서브쿼리 사용을 위한 별명
                +asCode('sql') FROM (SELECT * FROM table1) AS alias
                li Table function에 별명 사용
                +asCode('sql').
                    -- Table function : 행 집합을 반환하는 함수
                    CREATE TABLE foo (fooid int, foosubid int, fooname text);
                    CREATE FUNCTION getfoo(int) RETURNS SETOF foo AS $$ SELECT * FROM foo WHERE fooid = $1; $$ LANGUAGE SQL;
                    SELECT * FROM getfoo(1) AS t1;
                li LATERAL 서브쿼리
                p 키워드 좌측의 테이블들을 참조할 수 있다
                +asCode('sql').
                    -- unknown_log 테이블로부터 각 로그의 첫 30글자, 삽입 시각, 로그 길이를 가져오기
                    SELECT substring(log.log, 1, 30), log.insert_datetime, len FROM unknown_log log LEFT JOIN LATERAL LENGTH(log.log) len ON true;
                    -- LEFT JOIN ON true == CROSS JOIN. 사실 LATERAL 빼도 잘 동작하며, 실제로 사용할 일이 있을진 모르겠음...
            h3 WHERE 절
            ol
                li.marker GROUPING SETS
                p 한 테이블에 대해 같은 조건으로 여러 그룹에 대해 SELECT해야하는 경우, 이를 한 번에 질의할 수 있다
                +asCode('sql').
                    -- 브랜드별 판매량, 사이즈별 판매량, 전체 판매량 각각이 한 테이블에 모두 표시된다
                    SELECT brand, size, sum(sales) FROM items_sold GROUP BY GROUPING SETS ((brand), (size), ());
                li.marker GROUP BY CUBE ( a, b )
                p a, b의 파워 셋에 대해 질의한 것과 같다. ((), (a), (b), (a, b))
                li.marker GROUP BY ROLLUP ( a, b )
                p 공집합부터 a, b를 순서대로 추가한 집합들에 대해 질의한 것과 같다. ((), (a), (a, b))
                li CUBE, ROLLUP의 요소로 리스트가 올 수 있다
                p ROLLUP(a, (b, c)) == ((), (a), (a, b, c))
                li 여러 그루핑 조건을 같이 쓰는 경우, 마지막 조건에 대해 cross product가 이루어진다
                +asCode('sql').
                    GROUP BY a, CUBE (b, c), GROUPING SETS (d, e)
                    -- ((a, d), (a, e), (a, b, d), (a, b, e), ..., (a, b, c, e))
                li GROUP BY 절에서 행 생성자의 이용은 ROW(a, b)를 통해 할 수 있다
        h2 Select Lists
        +asCode('sql') SELECT DISTINCT select_list ...
        p 각 열집합에 대해 고유한 행들만 선택한다
        +asCode('sql') SELECT DISTINCT ON (expression [, expression ...]) select_list ...
        p 모든 행에 대해 expression이 평가된다. 두 행의 모든 평가값이 같은 경우 두 행은 같다고 간주한다

        h2 Combining Queries
        +asCode('sql').
            query1 UNION [ALL] query2
            query1 INTERSECT [ALL] query2
            query1 EXCEPT [ALL] query2

        h2 Sorting Rows
        ul
            +asCode('sql') ORDER BY sort_expression1 [ASC | DESC] [NULLS { FIRST | LAST }] [, sort_expression2 ...]
            li ASC, DESC : 기본값은 ASC
            li NULLS FIRST, NULLS LAST
            p null값에 대한 정렬 순서를 의미하며, 기본값은 ASC의 경우 NULLS LAST, DESC의 경우 NULLS FIRST

        h2 LIMIT and OFFSET
        ul
            +asCode('sql') SELECT select_list FROM table_expression [ ORDER BY ... ] [ LIMIT { number | ALL } ] [ OFFSET number ]
            li LIMIT : 출력 행의 개수 제한
            li OFFSET : 산출된 순서대로 n개 행을 출력하지 않고 무시

        h2 VALUES Lists
        ul
            li VALUES ( expression [, ...] ) [, ...]
            +asCode('sql') SELECT * FROM (VALUES (1, 'one'), (2, 'two'), (3, 'three')) AS t (num,letter);
            li 실제 디스크 상에 테이블을 만들지 않으면서 상수 테이블을 만드는 방법
            li 문법적으로 "SELECT select_list FROM table_expression"과 동일하게 취급된다

        h2 WITH Queries
        div
            h3 SELECT in WITH
            ul
                li 여러 개의 SELECT 서브 쿼리를 날리는 대신 WITH을 이용하여 분리할 수 있다
                +asCode('sql') with tmp1 AS (SELECT ...), tmp2 AS (SELECT ...) SELECT ... WHERE tmp1...
                li RECURSIVE를 이용하여 iteration 연산이 가능하다
                ol
                    p.marker 연산 순서
                    li non-recursive 부분을 계산한다. UNION을 위해 (not UNION ALL) 중복되는 행을 제거한다. 남은 행들을 결과에 포함시키고, 임시 작업 테이블로 설정한다
                    li 작업 테이블이 빌 때까지 아래를 반복한다
                    ol
                        li recursive 부분을 계산하고, 작업 테이블 내용을 덮어쓴다. UNION을 위해 (not UNION ALL) 중복된 행(이전 결과와도 비교)들을 제거한다. 남은 행들을 결과에 포함시키고, 임시 중간 테이블로 설정한다
                        li 작업 테이블의 내용을 중간 테이블 내용으로 대체한다. 중간 테이블은 비운다
                    +asCode('sql').
                        -- 10~100의 합계
                        WITH RECURSIVE t(n) AS ( VALUES (10) UNION SELECT n+1 FROM t WHERE n &lt; 100 )
                        SELECT sum(n) FROM t;
                    +table()
                        tr
                            th t
                            th working_table
                        tr
                            td empty
                            td empty
                        tr
                            td 10
                            td 10
                        tr
                            td 10, 11
                            td 11
                        tr
                            td 10, 11, 12
                            td 12
                        tr
                            td ...
                            td ...
                        tr
                            td 10, 11, 12, 13, ..., 100
                            td 100
                        tr
                            td 10, 11, 12, 13, ..., 100
                            td empty
                li RECURSIVE 연산은 계층 구조나 트리 형태의 데이터에 유용하다
                +asCode('sql').
                    WITH RECURSIVE search_graph(id, link, data, depth) AS (
                        SELECT g.id, g.link, g.data, 1 FROM graph g
                    UNION ALL
                        SELECT g.id, g.link, g.data, sg.depth + 1 FROM graph g, search_graph sg WHERE g.id = sg.link
                    ) SELECT * FROM search_graph;

            h3 Data-Modifying Statements in WITH
            p INSERT, UPDATE, DELETE를 WITH과 함께 사용할 수 있다
            +asCode('sql').
                WITH moved_rows AS ( DELETE FROM products WHERE isnert_datetime &lt; '2010-11-01' RETURNING * )
                INSERT INTO products_log SELECT * FROM moved_rows;

    h1 Data Types
    div
        h2 Numeric Types
        +table()
            tr
                th Name
                th Size
                th Description
            tr
                td smallint, int2
                td 2 bytes
                td signed integer
            tr
                td integer, int, int4
                td 4 bytes
                td signed integer
            tr
                td bigint, int8
                td 8 bytes
                td signed integer
            tr
                td decimal(p, s), numeric(p, s)
                td variable
                td 임의 개수의 유효숫자와 소수 정밀도를 가진 10진수
            tr
                td real, float4
                td 4 bytes
                td IEEE 754 단일 정밀도 부동소수(최소 유효숫자 6자리)
            tr
                td double precision, float8
                td 8 bytes
                td IEEE 754 배 정밀도 부동소수(최소 유효숫자 15자리)
            tr
                td smallserial, serial2
                td 2 bytes
                td 자동 증가 정수
            tr
                td serial, serial4
                td 4 bytes
                td 자동 증가 정수
            tr
                td bigserial, serial8
                td 8 bytes
                td 자동 증가 정수
        ul
            li decimal, numeric
            ol
                li p(precision) : 유효숫자 수
                li s(scale) : 소수 정밀도
                p 예. 3.141592의 precision = 7, scale = 6
                    br
                    |정수는 scale = 0인 numeric으로 간주해도 무방
                li NUMERIC(precision) : scale = 0
                li NUMERIC : 임의 유효숫자, 소수 정밀도의 10진수 모두 저장 가능
                p 무한히 큰 수를 지원하진 않는다. 소수점 전 131072 자리, 소수점 후 16383 자리까지 지원
                li 'NaN' 상수 지원
                p 'NaN'에 대한 연산 결과는 'NaN'
                li Rounding mode
                p numeric 타입의 반올림은 0에서 멀어지는 방향으로 이루어진다
            li real, double precision
            p 'NaN', 'Infinity', '-Infinity' 상수 지원
            li serial
            p serial 타입은 1부터 시작하여 자동으로 1씩 증가하는 정수에 대한 표현 편의를 제공한다. 9.6 버전에서는 sequence를 이용함으로써 구현한다

        h2 Character Types
        +table()
            tr
                th Name
                th Description
            tr
                td character [ (n) ], char [ (n) ]
                td 고정 길이(n) 문자열. 스페이스가 덧붙여진다
            tr
                td character varying [ (n) ], varchar [ (n) ]
                td 가변 길이(최대 n) 문자열
            tr
                td text
                td 가변 길이 문자열

        h2 Binary Data Type : bytea
        ol
            li 로캐일에 의존하지 않는 이진 문자열을 표현한다
            li bytea의 출력에는 'hex', 'escape' 두 가지 방식(bytea_output)이 있으며, 기본값은 'hex'로 설정되어 있다
            ul
                li hex : 각 바이트를 16진수 2자리로 표현. 예. '\xDEADBEEF'
                li escape : 출력 가능 아스키 문자(32 ~ 126)는 있는 그대로, 백슬래시는 \\, 그 외는 \xxx로 표현한다. 예. 'abc klm *\251T'

        h2 Date/Time Types
        +table()
            tr
                th Name
                th Size
                th Description
                td Range
                td Resolution
            tr
                td timestamp [ (p) ] [ without time zone ]
                td 8 bytes
                td date and time (no time zone)
                td 4713 BC ~ 294276 AD
                td 1μs
            tr
                td timestamp [ (p) ] with time zone, timestamptz
                td 8 bytes
                td date and time, including time zone
                td 4713 BC ~ 294276 AD
                td 1μs
            tr
                td date
                td 4 bytes
                td date
                td 4713 BC ~ 5874897 AD
                td 1 day
            tr
                td interval [ fields ] [ (p) ]
                td 16 bytes
                td time span
                td -178000000 years ~ 178000000 years
                td 1μs
            tr
                td time [ (p) ] [ without time zone ]
                td 8 bytes
                td time of day (no time zone)
                td 00:00:00 ~ 24:00:00
                td 1μs
            tr
                td time [ (p) ] with time zone, timetz
                td 12 bytes
                td time of day, with time zone
                td 00:00:00+1459 ~ 24:00:00-1459
                td 1μs
        ul
            li p
            p 초 단위 소수 precision. 0 ~ 6까지 가능하며, 기본값은 없다(설정되지 않은 상태).
            li interval field
            p YEAR, MONTH, DAY, HOUR, MINUTE, SECOND, YEAR TO MONTH, DAY TO HOUR, DAY TO MINUTE, DAY TO SECOND, HOUR TO MINUTE, HOUR TO SECOND, MINUTE TO SECOND
            li.marker Special Date/Time Input String
            +table()
                tr
                    th String
                    th Valid Types
                    th Description
                tr
                    td epoch
                    td date, timestamp
                    td 1970-01-01 00:00:00+00 (Unix system time zero)
                tr
                    td infinity
                    td date, timestamp
                    td later than all other time stamps
                tr
                    td -infinity
                    td date, timestamp
                    td earlier than all other time stamps
                tr
                    td now
                    td date, time, timestamp
                    td current transaction's start time
                tr
                    td today
                    td date, timestamp
                    td midnight today
                tr
                    td tomorrow
                    td date, timestamp
                    td midnight tomorrow
                tr
                    td yesterday
                    td date, timestamp
                    td midnight yesterday
                tr
                    td allballs
                    td time
                    td 00:00:00.00 UTC

        h2 boolean, bool
        ol
            li TRUE, 't', 'true', 'y', 'yes', 'on', '1'
            li FALSE, 'f', 'false', 'n', 'no', 'off', '0'

        h2 Enumerated Types
        +asCode('sql') CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy'); -- 대소문자 구분한다

        h2 Geometric Types
        +table()
            tr
                th Name
                th Size
                th Description
                th Representation
            tr
                td point
                td 16 bytes
                td xy 좌표계 상의 점
                td (x, y)
            tr
                td line
                td 32 bytes
                td 직선
                td {A, B, C} // Ax + By + C = 0또는 직선 상의 두 점을 콤마로 구분하여 제공
            tr
                td lseg
                td 32 bytes
                td 선분
                td ((x1, y1), (x2, y2))
            tr
                td box
                td 32 bytes
                td 모든 변이 축과 평행한 직사각형
                td ((x1, y1), (x2, y2))
            tr
                td path
                td 16n bytes
                td Closed path
                td ((x1, y1), ...)
            tr
                td path
                td 16n bytes
                td Open path
                td [(x1, y1), ...]
            tr
                td polygon
                td 40+16n bytes
                td Polygon
                td ((x1, y1), ...)
            tr
                td circle
                td 24 bytes
                td Circle
                td &lt;(x, y), r>

        h2 JSON Types : json, jsonb
        ul
            li jsonb : 이진 포맷으로 저장하여 입력 시 조금 느리지만, 처리는 json보다 빠르다
            li 배열 포함 여부 확인 예. SELECT '[1, 2, 3]'::jsonb @> '[3, 1]'::jsonb;
            li 배열 원소 존재 유무 확인 예. SELECT '["foo", "bar", "baz"]'::jsonb ? 'bar';
            li key의 존재 유무 확인 예. SELECT '{"foo": "bar"}'::jsonb ? 'foo';
            li key로 접근 예. select '{"key":"value"}'::jsonb -> 'key';

        h2 Array
        ul
            li 배열 타입 정의
            p PostgreSQL은 배열 크기를 제한하지 않는다
            +asCode('sql').
                create table test( nums integer[] );
                create table test( nums integer ARRAY );
                create table test( matrix integer[][] );
            li 배열 표현
            +asCode('sql').
                insert into test values( '{1, 2, 3, 4}'::int[] ); -- insert시엔 ::int[]같은 캐스팅 생략 가능
                insert into test values( ARRAY[[1, 2], [3, 4]] ); -- 배열 생성자는 애초에 배열을 반환하므로 캐스팅 불필요
            li.marker 배열 참조
            ol
                li 원소 참조 arr[idx]
                li 슬라이스 arr[start : end]
                p 모든 차원을 슬라이스한다고 간주된다. arr[1:2][2]는 arr[1:2][1:2]와 같다
                li 배열 차원 반환 array_dims()
                li 지정된 차원에 대해 배열 크기 반환 array_length()
                li 전체 원소 수 반환 cardinality()
                li 현재 배열 크기보다 큰 인덱스에 값을 할당하는 경우, 중간은 null로 채워진다
                li 배열 연결
                ul
                    li 연산자 || : n차원 배열과 n차원 배열의 연결 또는 n차원 배열에 n-1차원 배열(값)을 추가해준다
                    li array_prepend() : 1차원 배열 앞에 원소를 추가한다
                    li array_append() : 1차원 배열 뒤에 원소를 추가한다
                    li array_cat() : 다차원 배열들에 대해 || 연산과 같은 작업을 한다. 단, 배열만 인자로 사용 가능하다. 0차원 값은 안 된다
            li.marker 배열 검색
            ul
                li 배열의 원소 중 하나라도 100
                +asCode('sql') SELECT ... WHERE 100 = ANY(arr);
                li 배열의 원소 모두가 100
                +asCode('sql') SELECT ... WHERE 100 = ALL(arr);
                li generate_subscripts() : 주어진 배열과 차원에 대해 subscript의 집합을 반환한다
                +asCode('sql').
                    SELECT generate_subscripts('{{"1,1","1,2"},{"2,1","2,2"},{"3,1","3,2"}}'::text[][], 1) AS s;
                    -- 1차원 subscripts → 1, 2, 3
                    SELECT generate_subscripts('{{"1,1","1,2"},{"2,1","2,2"},{"3,1","3,2"}}'::text[][], 2) AS s;
                    -- 2차원 subscripts → 1, 2
                    -- 배열 펼치기
                    WITH arr AS (SELECT '{{"1,1","1,2"},{"2,1","2,2"},{"3,1","3,2"}}'::text[][] AS arr),
                        dims AS (SELECT arr, s1, s2, arr[s1][s2] FROM arr, generate_subscripts(arr, 1) AS s1, generate_subscripts(arr, 2) AS s2)
                    SELECT * FROM dims;
            li: +asA('http://postgresql.kr/docs/current/functions-array.html', 'functions-array.html')

        h2 Composite Types
        ol
            +asCode('sql') CREATE TYPE complex AS ( r float4, i float4 );
            li 테이블을 만들면 그와 동일한 이름의 타입이 생성된다
            +asCode('sql').
                CREATE TABLE m_item ( item_id int, name text );
                CREATE TABLE t_user_item ( user_id bigint, item m_item, count int );
            li Literal composite value
            p 포맷 : '( val1 , val2 , ... )'
            +asCode('sql') INSERT INTO table_name (complex_column_name) VALUES((1.1,2.2));
            li SET 바로 다음엔 괄호가 없어도 되지만, 등호 다음엔 필요하다
            +asCode('sql') UPDATE table_name SET complex_column.r = (complex_column).r + 1 WHERE ...;

        h2 Range Types
        ol
            li int4range — Range of integer
            li int8range — Range of bigint
            li numrange — Range of numeric
            li tsrange — Range of timestamp without time zone
            li tstzrange — Range of timestamp with time zone
            li daterange — Range of date
            +asA('http://postgresql.kr/docs/current/functions-range.html#RANGE-OPERATORS-TABLE', 'RANGE-OPERATORS-TABLE')
            +asA('http://postgresql.kr/docs/current/functions-range.html#RANGE-FUNCTIONS-TABLE', 'RANGE-FUNCTIONS-TABLE')

        h2 Domain Types
        p 기저 타입을 토대로 제약을 추가하여 새로 정의하는 타입
        +asCode('sql') CREATE DOMAIN non_negative_int AS integer CHECK (VALUE >= 0);

    h1 Functions and Operations
    div
        h2 Logical Operators
        ol
            li AND, OR, NOT
            li NULL도 논리 상태로 이용한다
            ul
                li TRUE AND NULL == NULL
                li FALSE AND NULL == FALSE
                li TRUE OR NULL == TRUE
                li FALSE OR NULL == NULL
                li NULL AND NULL == NULL OR NULL == NOT NULL == NULL
        h2 Comparison Functions and Operators
        ol
            li &lt;, >, &lt;=, >=, =, &lt;> or !=
            li a [NOT] BETWEEN x AND y
            p a [NOT] BETWEEN SYMMETRIC x AND y : x, y 대소관계를 판별하여 적절히 비교한다
            li a IS DISTINCT FROM b
            p a != b과 같지만 null을 일반적인 값으로 취급한다는 차이가 있다
            li expression IS [NOT] NULL
            li boolean_expression IS [NOT] TRUE // FALSE, UNKNOWN

        h2 Mathematical Functions and Operators
        ol
            li +, -, *, /, %, @(절댓값)
            li ^(거듭제곱), |/(제곱근), ||/(삼중근), !(팩토리얼, 후위), !!(팩토리얼, 전위)
            li 비트 연산자 &, |, #(XOR), ~, &lt;&lt;, >>
            li abs(x), sqrt(x), cbrt(x), ceil(x), floor(x), exp(x), div(x, y), round(x, y), ...
            li random() : x ∈ [0.0, 1.0), setseed(dp) : dp ∈ [-1.0, 1.0]

        h2 String Functions and Operators
        div
            h3 문자열 변형
            ul
                li 문자열 연결 연산자 ||
                p 비문자열도 피연산자 중 한쪽이 될 수 있다
                li lower(string) : 소문자 문자열로 변환
                li upper(string) : 대문자 문자열로 변환
                li initcap(string) : 각 단어의 첫 글자만 대문자가 되도록 변환
                li split_part(string, delimiter, n) : 구분자로 문자열을 분할하여 n번째 문자열 반환
                li concat(param1 [, param2 [,...]]) : 각 인자들을 한 문자열로 합쳐 반환한다. null은 무시한다
                li concat_ws(sep, param1 [, param2 [,...]]) : sep를 구분자로 하여 접합한다
                li format(formatstr [, formatarg [,...]]) : C의 printf와 유사
                li left(string, n), right(string, n)
                li lpad(string, length [, fill_string]), rpad(string, length [, fill_string])
                p fill_string 기본값은 스페이스
                li quote_ident(string) : ""로 감싼 문자열 표현 반환
                li quote_literal(param), quote_nullable(param) : ''로 감싼 문자열 표현 반환
                li repeat(string, number)
                li reverse(string)

            h3 문자열 길이 관련
            ul
                li bit_length(string) : 문자열 비트 수
                li octet_length(string) : 문자열 바이트 수
                li char_length(string) : 문자열 문자 수
                li character_length(string) : 문자열 문자 수
                li length(string) : 문자열 문자 수
                li length(string | bytea, encoding) : 문자열 문자 수

            h3 검색
            ol
                li replace(src_string, target_string, dest_string)
                li position(substring in string) : substring의 위치 반환
                li substring(string [from int] [for int])
                li substring(string from pattern) : POSIX 정규표현식
                li substring(string from pattern for escape) : SQL 정규표현식
                li trim([leading | trailing | both] [characters] from string)
                li regexp_match(string, pattern[, flags]) Since PostgreSQL 10
                p POSIX 정규표현식. 첫 번째 매칭 문자열 배열 반환. 패턴에 그룹이 없으면 전체 매칭 문자열이, 그룹이 있으면 각 그룹에 매칭되는 부분 문자열들이 배열의 원소가 된다
                li regexp_matches(string, pattern[, flags])
                p POSIX 정규표현식. 매칭 문자열 배열로 이루어진 행집합을 반환한다. 전체 문자열 매칭을 위해 'g' 플래그를 이용해야 한다
                p PostgreSQL 10 이전 버전에서 regexp_match와 같은 결과를 얻기 위한 서브쿼리 트릭
                +asCode('sql') SELECT ..., (SELECT regexp_matches(str, pattern)) FROM table...
                li regexp_split_to_array(string, pattern[, flags])
                p POSIX 정규표현식. 매칭 문자열을 구분자로 하여 분리한 부분 문자열들로 구성된 배열 반환. 문자열 시작, 끝의 길이 0 매칭 문자열은 무시된다
                li regexp_split_to_table(string, pattern[, flags])
                p POSIX 정규표현식. 매칭 문자열을 구분자로 하여 분리한 부분 문자열들로 구성된 테이블 반환. 문자열 시작, 끝의 길이 0 매칭 문자열은 무시된다
                li regexp_replace(string, pattern, replacement[, flags]) : POSIX 정규표현식
                li starts_with(string, prefix)
                li translate(string, from, to)
                p 문자열 각 문자에 대하여, from[i]에 일치하는 문자를 to[i]로 교체한다

            h3 인코딩 관련
            ol
                li pg_client_encoding() : 현재 인코딩 이름 반환
                li ascii(string)
                p 첫 글자의 아스키 코드값을 반환한다. UTF8 문자열의 경우 유니코드 코드 포인트를 반환한다
                li chr(int)
                p 주어진 코드값에 대한 문자를 반환한다. UTF8 문자에 대해서는 유니코드 코드 포인트를 인자로 전달하고, 그 외의 경우엔 아스키 코드를 인자로 전달해야 한다. 0은 입력으로 허용되지 않는다
                li convert(string | bytea, src_encoding, dest_encoding)
                p 가능한 빌트인 변환 목록 :
                    +asA('http://postgresql.kr/docs/current/functions-string.html#CONVERSION-NAMES', '#CONVERSION-NAMES')
                li convert_from(string | bytea, src_encoding) : dest_encoding = DB 인코딩
                li convert_to(string | bytea, dest_encoding) : src_encoding = DB 인코딩
                li to_ascii(string [, encoding]
                p LATIN1, LATIN2, LATIN9, WIN1250문자열을 아스키 문자열로 변환
                li to_hex(number) : 16진수 표현 문자열 반환
                li decode(string, format), encode(string, format)
                p 지원 format : base64, hex, escape
                p Data Types - Binary Data Types - escape 참고
                li set_bit(string, offset, newvalue), set_byte(string, offset, newvalue)
                li md5(string), sha256(bytea), sha512(bytea)

        h2 Bit String Operators
        +table()
            tr
                th Operator
                th Description
                th Example
                th Result
            tr
                td ||
                td concatenation
                td B'10001' || B'011'
                td 10001011
            tr
                td &
                td bitwise AND
                td B'10001' & B'01101'
                td 00001
            tr
                td |
                td bitwise OR
                td B'10001' | B'01101'
                td 11101
            tr
                td #
                td bitwise XOR
                td B'10001' # B'01101'
                td 11100
            tr
                td ~
                td bitwise NOT
                td ~ B'10001'
                td 01110
            tr
                td &lt;&lt;
                td bitwise shift left
                td B'10001' &lt;&lt; 3
                td 01000
            tr
                td >>
                td bitwise shift right
                td B'10001' >> 2
                td 00100

        h2 Pattern matching
        div
            h3 LIKE
            ol
                li 전체 문자열이 패턴과 일치하는지 여부를 판별한다
                li Syntax
                +asCode('sql') string [NOT] LIKE pattern [ESCAPE escape-character]
                li pattern
                ul
                    li '_' : 임의의 1글자
                    li '%' : 연속적인 임의의 0개 이상 글자
                    li 'string' : 'string' 자체
                li ESCAPE
                p '%', '_'의 이스케이핑을 끄고 싶을 때 : ESCAPE ''
                li 기타
                p PostgreSQL 고유의 ILIKE : 대소문자 구별없는 LIKE
                p LIKE = ~~, ILIKE = ~~*, NOT LIKE = !~~, NOT ILIKE = !~~*

            h3 SIMILAR TO 정규표현식
            ol
                li LIKE와 비슷하나, 패턴으로 SQL 표준 정규표현식을 이용한다
                p LIKE와 마찬가지로 전체 문자열이 패턴과 일치해야 한다
                li Syntax
                +asCode('sql') string [NOT] SIMILAR TO pattern [ESCAPE escape-character]
                li pattern
                ol
                    li '_'와 '%'는 LIKE와 같은 의미를 지닌다
                    li sub1 | sub2 : sub1 또는 sub2
                    li * : 0 or more
                    li + : 1 or more
                    li ? : 0 or 1
                    li {m} : exactly m times
                    li {m, } : m or more
                    li {m, n} : m~n times
                    li () : 그루핑
                    li [] : 글자 집합

            h3 POSIX 정규표현식
            div
                h4 용어
                ol
                    li RE; 정규표현식 : 정규표현식은 |로 구분되는 브랜치들로 구성된다. 임의의 브랜치와 일치하는 부분 문자열은 매칭 결과가 된다
                    li Branch : 브랜치는 quantified atom 또는 constraint들로 구성된다. 구성요소 순서대로 매칭을 시도하며, 빈 브랜치는 빈 문자열과 매칭된다
                    li Quantified atom : quantifier가 붙은 atom
                    li Constraint : 길이 0인 문자열이 매칭되지만, 특별한 위치와 의미를 지닌다
                h4 연산자
                ol
                    li ~ : case sensitive match
                    li ~* : case insensitive match
                    li !~ : case sensitive 'not' match
                    li !~* : case insensitive 'not' match
                h4 Atom
                ol
                    li (re) : 정규표현식 re를 매칭하며, 그루핑 번호가 붙는다
                    li (?:re) : re에 대해 매칭은 하지만, 그루핑 번호는 붙지 않는다(non-capturing set)
                    li . : 임의의 문자에 매칭
                    li [chars] : 문자 집합 임의의 문자에 매칭
                    li \k : k는 non-alphanumeric 문자. 예. \\는 백슬래시 문자 자체에 매칭된다
                    li \c : c는 alphanumeric 문자. 이스케이핑된다
                    li { : 뒤에 숫자가 오는 경우 정규표현식 quantifier가 된다
                    li x : 문자 x 자체에 매칭된다
                h4 Quantifier
                ol
                    li * : 0 or more
                    li + : 1 or more
                    li ? : 0 or 1
                    li {m} : exactly m times
                    li {m, } : m or more
                    li {m, n} : m~n times
                    li *? : non-greedy version of *
                    li +? : non-greedy version of +
                    li ?? : non-greedy version of ?
                    li {m}? : non-greedy version of {m}
                    li {m,}? : non-greedy version of {m,}
                    li {m,n}? : non-greedy version of {m,n}
                h4 Constraint
                ol
                    li ^ : 문자열의 시작에 매칭된다
                    li $ : 문자열의 끝에 매칭된다
                    li (?=re) : positive lookahead. 매칭된 부분문자열의 시작부터 재탐색한다
                    +asCode('sql').
                        -- 예. 아이디는 영문 대소문자와 숫자로만 구성할 수 있으며, 첫 글자는 숫자가 될 수 없다
                        SELECT 'awef79' ~ '(?=^[a-zA-Z])(?=^[a-zA-Z0-9]+$)'; -- t
                        SELECT '79awef' ~ '(?=^[a-zA-Z])(?=^[a-zA-Z0-9]+$)'; -- f
                    li (?!re) : negative lookahead. 매칭된 부분문자열의 시작이 아닌 위치부터 재탐색한다
                    li (?&lt;=re) : positive lookahead. 매칭된 부분문자열의 끝부터 재탐색한다
                    li (?&lt;!re) : negative lookahead. 매칭된 부분문자열의 끝이 아닌 위치부터 재탐색한다
                    p Lookahead와 lookbehind는 back reference를 포함할 수 없으며, 모든 괄호는 non-capturing으로 간주된다
                h4 문자 이스케이프
                ol
                    li \a(alert character), \b(backspace), \f, \n, \r, \t, \v(수직 탭), \0
                    li \B : \\
                    li \cX : X는 임의 문자. 하위 5개 비트가 같고 나머지 비트가 모두 0
                    li \uFFFF, \UFFFFFFFF : 유니코드 코드포인트. DB 인코딩에 따라 달라진다...
                    li \xFFF, \xy(8진수 2개), \xyz(8진수 3개)
                h4 클래스 약어 이스케이프
                p alnum, alpha, blank, cntrl, digit, graph, lower, print, punct, space, upper, xdigit
                ol
                    li \d : [[:digit:]]
                    li \s : [[:space:]]
                    li \w : [[:alnum:]_] // underscore included
                    li \D : [^[:digit:]]
                    li \S : [^[:space:]]
                    li \W : [^[alnum:]_] // underscore included
                h4 Constraint 이스케이프
                ol
                    li \A : 문자열 시작, \Z : 문자열 끝
                    p ^, $와 다르게 멀티 라인 처리 지원 x
                    li \m : 단어 시작
                    li \M : 단어 끝
                    li \y : 단어 시작 또는 끝
                    li \Y : not \y
                h4 Back reference
                p \m[nn] : m은 nonzero digit. n은 추가적인 자릿수
                h4 Option letter
                p 정규표현식 플래그에 사용되는 문자들은 아래와 같다
                ol
                    li c : 대소문자 구분 (overrides operator type)
                    li i : 대소문자 구분 x (overrides operator type)
                    li s : 멀티 라인 처리 x. (default)
                    li n, m : 멀티 라인 처리
                    li p : 부분적 멀티 라인 처리. ^와 $는 멀티 라인 처리 x
                    li w : 부분적 멀티 라인 처리. ^와 $는 멀티 라인 처리 o

        h2 Formatting Functions
        ol
            +asA('http://postgresql.kr/docs/current/functions-formatting.html', 'functions-formatting.html')
            li to_char()
            li to_date()
            li to_number()
            li to_timestamp()

        h2 Date/Time Functions and Operators
        div
            h3 Date/Time Operators
            +table()
                tr
                    th Operator
                    th Example
                    th Result
                tr
                    td +
                    td date '2001-09-28' + integer '7'
                    td date '2001-10-05'
                tr
                    td +
                    td date '2001-09-28' + interval '1 hour'
                    td timestamp '2001-09-28 01:00:00'
                tr
                    td +
                    td date '2001-09-28' + time '03:00'
                    td timestamp '2001-09-28 03:00:00'
                tr
                    td +
                    td interval '1 day' + interval '1 hour'
                    td interval '1 day 01:00:00'
                tr
                    td +
                    td timestamp '2001-09-28 01:00' + interval '23 hours'
                    td timestamp '2001-09-29 00:00:00'
                tr
                    td +
                    td time '01:00' + interval '3 hours'
                    td time '04:00:00'
                tr
                    td -
                    td - interval '23 hours'
                    td interval '-23:00:00'
                tr
                    td -
                    td date '2001-10-01' - date '2001-09-28'
                    td integer 3
                tr
                    td -
                    td date '2001-10-01' - integer '7'
                    td date '2001-09-24'
                tr
                    td -
                    td date '2001-09-28' - interval '1 hour'
                    td timestamp '2001-09-27 23:00:00'
                tr
                    td -
                    td time '05:00' - time '03:00'
                    td interval '02:00:00'
                tr
                    td -
                    td time '05:00' - interval '2 hours'
                    td time '03:00:00'
                tr
                    td -
                    td timestamp '2001-09-28 23:00' - interval '23 hours'
                    td timestamp '2001-09-28 00:00:00'
                tr
                    td -
                    td interval '1 day' - interval '1 hour'
                    td interval '1 day -01:00:00'
                tr
                    td -
                    td timestamp '2001-09-29 03:00' - timestamp '2001-09-27 12:00'
                    td interval '1 day 15:00:00'
                tr
                    td *
                    td 900 * interval '1 second'
                    td interval '00:15:00'
                tr
                    td *
                    td 21 * interval '1 day'
                    td interval '21 days'
                tr
                    td *
                    td double precision '3.5' * interval '1 hour'
                    td interval '03:30:00'
                tr
                    td /
                    td interval '1 hour' / double precision '1.5'
                    td interval '00:40:00'
                tr
                    td overlaps
                    td (date '2000-01-01', date '2000-12-31') overlaps (date '2000-07-07', date '2000-08-08')
                    td t
                tr
                    td overlaps
                    td (date '2000-01-01', make_interval(years => 1)) overlaps (date '2000-07-07', date '2000-08-08')
                    td t

            h3 Date/Time Functions
            +table()
                tr
                    th Function
                    th Return Type
                    th Description
                    th Example
                    th Result
                tr
                    td clock_timestamp()
                    td timestamptz
                    td(colspan='3') 현재 timestamp. 클록 기준
                tr
                    td timeofday()
                    td text
                    td(colspan='3') 현재 시각(clock_timestamp)을 문자열로 반환
                tr
                    td current_date
                    td date
                    td(colspan='3') 현재 date. 트랜잭션 시작 기준
                tr
                    td current_time
                    td timetz
                    td(colspan='3') 현재 time. 트랜잭션 시작 기준. CURRENT_TIME(precision) 가능
                tr
                    td current_timestamp
                    td timestamptz
                    td(colspan='3') 현재 timestamp. 트랜잭션 시작 기준. CURRENT_TIMESTAMP(precision) 가능
                tr
                    td localtime
                    td time
                    td(colspan='3') 현재 time. 트랜잭션 시작 기준. LOCALTIME(precision) 가능
                tr
                    td localtimestamp
                    td timestamp
                    td(colspan='3') 현재 timestamp. 트랜잭션 시작 기준. LOCALTIMESTAMP(precision) 가능
                tr
                    td now()
                    td timestamptz
                    td(colspan='3') 현재 timestamp. 트랜잭션 시작 기준
                tr
                    td statement_timestamp()
                    td timestamptz
                    td(colspan='3') 현재 timestamp. 현재 문장 실행 기준
                tr
                    td transaction_timestamp()
                    td timestamptz
                    td(colspan='3') 현재 timestamp. 트랜잭션 시작 기준
                tr
                    td make_date(year int, month int, day int)
                    td date
                    td date 생성
                    td make_date(2013, 7, 15)
                    td 2013-07-15
                tr
                    td make_interval(years int DEFAULT 0, months int DEFAULT 0, weeks int DEFAULT 0, days int DEFAULT 0, hours int DEFAULT 0, mins int DEFAULT 0, secs double precision DEFAULT 0.0)
                    td interval
                    td interval 생성
                    td make_interval(days => 10)
                    td 10 days
                tr
                    td make_time(hour int, min int, sec double precision)
                    td time
                    td time 생성
                    td make_time(8, 15, 23.5)
                    td 08:15:23.5
                tr
                    td make_timestamp(year int, month int, day int, hour int, min int, sec double precision)
                    td timestamp
                    td timestamp 생성
                    td make_timestamp(2013, 7, 15, 8, 15, 23.5)
                    td 2013-07-15 08:15:23.5
                tr
                    td make_timestamptz(year int, month int, day int, hour int, min int, sec double precision, [timezone text])
                    td timestamptz
                    td timestamp 생성. timezone 생략시 현재 설정 사용
                    td make_timestamptz(2013, 7, 15, 8, 15, 23.5)
                    td 2013-07-15 08:15:23.5+01
                tr
                    td to_timestamp(double precision)
                    td timestamptz
                    td Convert Unix epoch (seconds since 1970-01-01 00:00:00+00) to timestamp
                    td to_timestamp(1284352323)
                    td 2010-09-13 04:32:03+00
                tr
                    td at time zone
                    td timestamptz
                    td Convert timestamp to timestamptz
                        +asA('https://en.wikipedia.org/wiki/List_of_tz_database_time_zones', 'wiki/List_of_tz')
                    td timestamp '2000-01-01 00:00:00' at time zone 'Asia/Seoul'
                    td 1999-12-31 07:00:00-08
                tr
                    td age(timestamp,timestamp)
                    td interval
                    td 연월일로 표기되는 두 시각 사이의 차이. 부정확
                    td age(timestamp '2001-04-10', timestamp '1957-06-13')
                    td 43 years 9 mons 27 days
                tr
                    td age(timestamp)
                    td interval
                    td 현재 date로부터 뺀다. = age(current_date::timestamp, from)
                    td age(timestamp '1957-06-13')
                    td 43 years 8 mons 3 days
                tr
                    td date_part(text,timestamp)
                    td float8
                    td = extract
                    td date_part('hour', timestamp '2001-02-16 20:38:40')
                    td 20
                tr
                    td date_part(text,interval)
                    td float8
                    td = extract
                    td date_part('month', interval '2 years 3 months')
                    td 3
                tr
                    td extract(field from timestamp)
                    td float8
                    td Get subfield
                    td extract(hour from timestamp '2001-02-16 20:38:40')
                    td 20
                tr
                    td extract(field from interval)
                    td float8
                    td Get subfield
                    td extract(month from interval '2 years 3 months')
                    td 3
                tr
                    td extract, date_part field
                    td(colspan='4') century, day, decade, dow(day of the week), doy(day of the year), epoch(number of seconds sinse 1970-01-01 00:00:00 UTC), hour, isodow(day of the week), isoyear(ISO 8601 week-numbering), microseconds, millenium, milliseconds, minute, month, quarter, second, timezone, timezone_hour, timezone_minute, week(ISO 8601 week-numbering), year
                tr
                    td isfinite(date)
                    td boolean
                    td Test for finite date (not +/-infinity)
                    td isfinite(date '2001-02-16')
                    td true
                tr
                    td isfinite(timestamp)
                    td boolean
                    td Test for finite time stamp (not +/-infinity)
                    td isfinite(timestamp '2001-02-16 21:28:30')
                    td true
                tr
                    td isfinite(interval)
                    td boolean
                    td Test for finite interval
                    td isfinite(interval '4 hours')
                    td true
                tr
                    td date_trunc(text,timestamp)
                    td timestamp
                    td Truncate to specified precision
                    td date_trunc('hour', timestamp '2001-02-16 20:38:40')
                    td 2001-02-16 20:00:00
                tr
                    td date_trunc(text,interval)
                    td interval
                    td Truncate to specified precision
                    td date_trunc('hour', interval '2 days 3 hours 40 minutes')
                    td 2 days 03:00:00
                tr
                    td date_trunc field
                    td(colspan='4') microseconds, milliseconds, second, minute, hour, day, week, month, quarter, year, decade, century, millenium
                tr
                    td justify_days(interval)
                    td interval
                    td Adjust interval so 30-day time periods are represented as months
                    td justify_days(interval '35 days')
                    td 1 mon 5 days
                tr
                    td justify_hours(interval)
                    td interval
                    td Adjust interval so 24-hour time periods are represented as days
                    td justify_hours(interval '27 hours')
                    td 1 day 03:00:00
                tr
                    td justify_interval(interval)
                    td interval
                    td Adjust interval using justify_days and justify_hours, with additional sign adjustments
                    td justify_interval(interval '1 mon -1 hour')
                    td 29 days 23:00:00

        h2 JSON Functions and Operators
        div
            +asA('http://postgresql.kr/docs/current/functions-json.html', 'functions-json.html')
            h3 json and jsonb Operators
            +table()
                tr
                    th Operator
                    th Right Operand Type
                    th Description
                    th Example
                    th Example Result
                tr
                    td ->
                    td int
                    td Get JSON array element(인덱스는 0부터 시작. 음수면 뒤에서부터)
                    td '[{"a":"foo"},{"b":"bar"},{"c":"baz"}]'::json->2
                    td {"c":"baz"}
                tr
                    td ->
                    td text
                    td Get JSON object field by key
                    td '{"a": {"b":"foo"}}'::json->'a'
                    td {"b":"foo"}
                tr
                    td ->>
                    td int
                    td Get JSON array element as text
                    td '[1,2,3]'::json->>2
                    td 3
                tr
                    td ->>
                    td text
                    td Get JSON object field as text
                    td '{"a":1,"b":2}'::json->>'b'
                    td 2
                tr
                    td #>
                    td text[]
                    td Get JSON object at specified path
                    td '{"a": {"b":{"c": "foo"}}}'::json#>'{a,b}'
                    td {"c": "foo"}
                tr
                    td #>>
                    td text[]
                    td Get JSON object at specified path as text
                    td '{"a":[1,2,3],"b":[4,5,6]}'::json#>>'{a,2}'
                    td 3

        h2 Sequence Manipulation Functions
        ol
            li currval(regclass) : 지정된 sequence의 가장 최근 반환된 nextval
            li lastval() : 가장 최근 반환된 임의 sequence의 nextval
            li nextval(regclass) : sequence를 증가시키고 반환
            li setval(regclass, bigint) : sequence의 현재값 설정
            p regclass는 pg_class 시스템 카탈로그에 저장된 sequence의 OID며, 이를 직접 찾을 필요는 없다. '' 사이에 식별자를 넣어주면 알아서 변환해준다

        h2 Conditional Expressions
        ol
            li case
            +asCode('sql') case when condition then result [when ...] [else result] end
            li coalesce
            +asCode('sql') coalesce(value [, ...])
            p 처음으로 등장하는 non-null값을 반환한다. 모두 null이면 최종적으로 null이 반환된다
            li nullif
            +asCode('sql') nullif(value1, value2)
            p value1과 value2가 같으면 null 반환. 다르면 value1 반환
            li greatest
            +asCode('sql') greatest(value [, ...])
            li least
            +asCode('sql') least(value [, ...])

        h2 Subquery Expressions
        ol
            li exists
            p exists(subquery) : 서브쿼리가 한 행 이상 반환하면 true, 아니면 false
            li in
            p expression in (subquery) : expression 판별값이 subquery 결과 중에 있으면 true, 아니면 false
            li not in
            li any, some
            +asCode('sql').
                expression operator any (subquery)
                expression operator some (subquery)
            p subquery는 하나의 컬럼만 반환해야 한다. expression 판별값이 subquery 결과 중에 하나라도 operator를 만족하면 true
            li all
            +asCode('sql') expression operator all (subquery)
            li Single-row Comparison
            p row_constructor operator (subquery) : subquery는 row_constructor와 같은 개수의 컬럼을 반환해야 한다

        h2 Series Generating Functions
        ol
            li generate_series(start, stop)
            li generate_series(start, stop, step)
            li generate_series(start, stop interval)

        h2 System Information Functions
        +asA('http://postgresql.kr/docs/current/functions-info.html', 'functions-info.html')

    h1 동시성 제어
    div
        h2 소개
        ol
            li PostgreSQL은 다중버전 모델 MVCC(Multiversion Concurrency Control)을 이용해서 동시성 처리를 관리한다
            p 각 트랜잭션의 시작을 기점으로 자료를 각각의 스냅샷(데이터베이스 버전)으로 처리해서 세션이 사용한다. 이렇게 하면 최소한의 잠금을 사용하여 트랜잭션 격리가 이루어진다
            li MVCC와 별개로 개발자가 이용할 수 있는 테이블, 행 단위 잠금 기능을 제공한다

        h2 트랜잭션 격리
        ul
            li SQL 표준 트랜잭션 격리 수준; Transaction Isolation Level
            ul
                li dirty read : 다른 트랜잭션이 아직 커밋하지 않은 자료도 읽을 수 있다
                li nonrepeatable read : 다른 트랜잭션이 커밋한 자료를 읽을 수 있다. 다음 읽기 시도시 해당 트랜잭션이 값을 변경했다면 변경된 값을 읽는다
                li phantom read : 다른 트랜잭션이 커밋한 자료를 읽을 수 있다. 다음 읽기 시도 시, 최초 읽은 값 그대로 보여준다
                li serialization anomaly
                ol
                    li let result ::= 트랜잭션 그룹에 대한 최종 실행 성공 상태
                    li let possibleResults ::= 각 트랜잭션을 하나씩 순서대로 실행하는 모든 경우에 대해, 각 실행 성공 상태 리스트
                    li 직렬화 이상 == result not in possibleResults
            li.marker PostgreSQL 트랜잭션 격리 수준
            p 트랜잭션 격리 수준을 설정하려면 SET TRANSACTION 명령을 이용한다. PostgreSQL은 MVCC 모델을 이용하기 때문에, Read uncommitted는 Read committed처럼 작동한다
            +table()
                tr
                    th 격리 수준
                    th Dirty Read
                    th Nonrepeatable Read
                    th Phantom Read
                    th Serialization Anomaly
                tr
                    td Read uncommitted
                    td 허용, PG에서는 없음
                    td 가능
                    td 가능
                    td 가능
                tr
                    td Read committed
                    td 불가능
                    td 가능
                    td 가능
                    td 가능
                tr
                    td Repeatable read
                    td 불가능
                    td 불가능
                    td 허용, PG에서는 없음
                    td 가능
                tr
                    td Serializable
                    td 불가능
                    td 불가능
                    td 불가능
                    td 불가능
        div
            h3 Read Committed 격리 수준
            ol
                li PostgreSQL 기본 격리 수준
                li for update/share 절 없는 select 쿼리는 쿼리 실행 전 마지막으로 커밋된 자료를 읽는다
                p 다른 트랜잭션과 분리된 스냅샷을 이용하므로, select 쿼리 실행 중 다른 트랜잭션이 변경하여 커밋한 자료는 읽을 수 없다. 이때, 같은 select 쿼리가 다시 호출되는 경우 변경 커밋된 자료를 가져온다
                p 현재 트랜잭션에서 업데이트한 자료는 커밋되지 않았더라도 다시 읽을 때 갱신된 값으로 가져온다
                li update, delete, select for update/share 쿼리는 타깃 행을 찾는 것까지는 select 쿼리와 동일하다
                p 실행 시각을 기준으로 발견한 타깃 행이 변경/삭제/잠금 중인 경우 커밋이나 롤백되기를 기다린다. 행이 변경된 경우 where 절이 재평가되고 갱신된 행을 대상으로 쿼리 실행, 삭제된 경우 무시, 롤백된 경우 기존 행을 대상으로 쿼리가 실행된다
            h3 Repeatable Read 격리 수준
            ol
                li 트랜잭션 실행 전 마지막으로 커밋된 자료만을 본다
                p 물론 현재 트랜잭션에서 업데이트한 자료는 커밋되지 않았더라도 다시 읽을 때 갱신된 값으로 가져온다
                li update, delete, select for update/share 쿼리는 타깃 행을 찾는 것까지는 select 쿼리와 동일하다
                p 실행 시각을 기준으로 발견한 타깃 행이 변경/삭제/잠금 중인 경우 커밋이나 롤백되기를 기다린다. 롤백된 경우 기존 행에 대해 쿼리가 실행되고, 변동이 있다면 에러를 발생하고 롤백한다. ← Repeatable Read 트랜잭션은 트랜잭션 시작 이후 다른 트랜잭션에 의해 변경된 행을 갱신하거나 잠글 수 없다
                li 따라서 update 트랜잭션은 응용 수준에서 트랜잭션 직렬화 실패에 대한 대응이 필요하다
                p 읽기만 하는 트랜잭션은 직렬화 실패가 일어날 수 없다
                li 트랜잭션 시작 시각을 기준으로 DB에 대한 엄격한 정적 뷰를 보장하지만, 동시 실행되는 트랜잭션에 의해 일부 불일치가 발생할 수 있다
                p 예를 들어 다른 트랜잭션에서 여러 연관 테이블의 행들을 순차적으로 업데이트하는 와중에 읽기를 수행하는 경우, 시간적으로는 일관적이지만, 논리적으로는 일관적이지 않은 데이터를 읽게될 수 있다
            h3 Serializable 격리 수준
            ol
                li 커밋된 모든 트랜잭션들을 하나씩 순차적으로 실행한다
                li 이걸로 모든 이상 발생 가능성이 차단되는 것이 아니기 떄문에, 여전히 트랜잭션 직렬화 실패에 대한 대응이 필요하다
                li 성능을 위한 유의사항
                ul
                    li 가능한 경우 READ ONLY 명시
                    li 기본으로 잠금을 제공하므로 select for update/share 구문은 필요없다
                    li 페이지 수준 predicate 잠금이 여러 개 필요하지만 메모리 부족으로 릴레이션 수준의 잠금이 걸리는 경우, 최대 잠금 수 설정을 조정한다
                    +asA('http://postgresql.kr/docs/current/runtime-config-locks.html#GUC-MAX-PRED-LOCKS-PER-TRANSACTION', 'GUC-MAX-PRED-LOCKS-PER-TRANSACTION')
                    li 릴레이션 수준 잠금이 설정되는 것을 방지하기 위해 인덱스 스캔을 이용한다

        h2 Explicit Locking
        ol
            li Table-level Locks
            p 아래 표는 테이블 수준 잠금의 종류와, 각 요청된 잠금 수준에 대해 이미 설정된 잠금으로 인해 요청이 처리되지 않는 경우를 보여준다. 테이블 잠금은 LOCK 명령어로 획득할 수 있다
            +table().w3-centered
                tr
                    th(rowspan='2') Requested Lock Mode
                    th(colspan='8') Current Lock Mode
                tr
                    th ACCESS SHARE
                    th ROW SHARE
                    th ROW EXCLUSIVE
                    th SHARE UPDATE EXCLUSIVE
                    th SHARE
                    th SHARE ROW EXCLUSIVE
                    th EXCLUSIVE
                    th ACCESS EXCLUSIVE
                tr
                    td ACCESS SHARE
                    td(colspan='7')
                    td X
                tr
                    td ROW SHARE
                    td(colspan='6')
                    td X
                    td X
                tr
                    td ROW EXCLUSIVE
                    td(colspan='4')
                    td X
                    td X
                    td X
                    td X
                tr
                    td SHARE UPDATE EXCLUSIVE
                    td(colspan='3')
                    td X
                    td X
                    td X
                    td X
                    td X
                tr
                    td SHARE
                    td(colspan='2')
                    td X
                    td X
                    td
                    td X
                    td X
                    td X
                tr
                    td SHARE ROW EXCLUSIVE
                    td(colspan='2')
                    td X
                    td X
                    td X
                    td X
                    td X
                    td X
                tr
                    td EXCLUSIVE
                    td
                    td X
                    td X
                    td X
                    td X
                    td X
                    td X
                    td X
                tr
                    td ACCESS EXCLUSIVE
                    td X
                    td X
                    td X
                    td X
                    td X
                    td X
                    td X
                    td X
            ol
                li ACCESS SHARE
                p select 명령이 이 잠금을 필요로 한다. 테이블을 읽기만 하는 쿼리들은 보통 이 잠금 수준에서 동작한다
                li ROW SHARE
                p select for update, select for share 명령이 이 잠금을 필요로 한다
                li ROW EXCLUSIVE
                p update, delete, insert 명령이 이 잠금을 필요로 한다. 테이블 데이터를 수정하는 쿼리들은 보통 이 잠금 수준에서 동작한다
                li SHARE UPDATE EXCLUSIVE
                p Acquired by VACUUM (without FULL), ANALYZE, CREATE INDEX CONCURRENTLY, CREATE STATISTICS and ALTER TABLE VALIDATE and other ALTER TABLE variants
                li SHARE
                p Acquired by CREATE INDEX (without CONCURRENTLY)
                li SHARE ROW EXCLUSIVE
                p Acquired by CREATE COLLATION, CREATE TRIGGER, and many forms of ALTER TABLE
                li EXCLUSIVE
                p Acquired by REFRESH MATERIALIZED VIEW CONCURRENTLY
                li ACCESS EXCLUSIVE
                p Acquired by the DROP TABLE, TRUNCATE, REINDEX, CLUSTER, VACUUM FULL, and REFRESH MATERIALIZED VIEW (without CONCURRENTLY) commands
            li.marker Row-level Lock Modes
            p 행 수준 잠금은 자동적으로 설정되고 해제된다
            ol
                li FOR UPDATE
                p select한 행들을 변경을 위해 잠근다. 다른 트랜잭션의 잠금, 변경, 삭제를 막는다
                li FOR NO KEY UPDATE
                p FOR UPDATE와 비슷. select for key share 명령은 막지 않는다
                li FOR SHARE
                p FOR NO KEY UPDATE와 비슷. 공유된 잠금을 설정하며, select for share, select for key share 명령은 막지 않는다
                li FOR KEY SHARE
                p FOR SHARE와 비슷. select for no key update 명령은 막지 않는다

    h1 Performance Tips
    ul
        li Populating a Database
        ol
            li 여러 insert 명령이 순차적으로 실행되는 경우, autocommit 기능을 끄고 마지막에 한꺼번에 커밋하는 것이 좋다
            p SQL 명령문에서 BEGIN, COMMIT 명령으로 트랜잭션을 수행하는 것과 동일하다
            li 여러 행 데이터를 입력하는 경우, COPY 명령을 이용하는 것이 좋다
            li 테이블을 최초로 생성하면서 데이터를 입력하는 경우, 인덱스를 제거하고 나중에 다시 만드는 것이 좋다
            li 일시적으로 maintenance_work_mem, max_wal_size 설정을 높인다
            li pg_dump는 위에 적힌 것을 비롯한 여러 성능 향상 기법들을 이용한다
        li Non-Durable Settings
        p 데이터베이스의 안정성이 필요없는 경우 아래와 같이 성능 위주의 설정이 가능하다
        ol
            li DB 클러스터를 RAM 디스크에 둔다
            li fsync, synchronous commit, full page writes 설정을 끈다
            li max_wal_size, checkpoint_timeout 설정을 높인다
            li 테이블 생성 시 UNLOGGED를 설정한다
