include ../../../source/skeleton.pug

+post({
    title: 'PostgreSQL 설명서',
    description: 'PostgreSQL 공식 문서 중 일부 발췌',
})

    h1: +asA('https://www.postgresql.org/docs/current/legalnotice.html', 'Legal Notice; 법적 고지')
    p PostgreSQL Database Management System (also known as Postgres, formerly known as Postgres95)
    p Portions Copyright © 1996-2025, PostgreSQL Global Development Group
    p Portions Copyright © 1994, The Regents of the University of California
    p Permission to use, copy, modify, and distribute this software and its documentation for any purpose, without fee, and without a written agreement is hereby granted, provided that the above copyright notice and this paragraph and the following two paragraphs appear in all copies.
    p IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    p THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON AN “AS-IS” BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.

    h1 시작하기 전에
    ul
        li 최신 공식 문서 : #[+asA('https://www.postgresql.org/docs/current/index.html')]
        li 별도 표기가 없다면, 이 문서는 PostgreSQL 18 문서 내용임
        li 출시 노트 : #[+asA('https://www.postgresql.org/docs/release/')]
        li PostgreSQL은 캘리포니아 대학교 버클리 컴퓨터과학부에서 개발한 POSTGRES 버전 4.2를 기반으로 개발되고, 오픈소스로 관리 중인 객체-관계형 데이터베이스 관리 시스템(ORDBMS)이다. 뛰어난 성능과 확장성으로 여러 분야에서 애용하고 있다

    h1 SQL
    div
        h2 구문
        div
            h3 어휘 구조
            ul
                li 키워드 : 고정된 의미를 갖는 토큰
                li 식별자 : 명령에 따라 테이블, 열, 객체 이름을 나타내는 토큰. 단순히 이름(name)이라고 부르기도 한다
                    ul
                        li 키워드로 예약된 토큰을 식별자로 사용하려면 ""로 감쌀 필요가 있다
                        li 식별자 크기 제한은 기본 63바이트
                        li ""로 감싼 식별자는 대소문자를 구별한다 -- 이 안에서 "를 나타내려면 ""를 사용
                li 주석 : 입력에 포함된 주석은 공백처럼 취급된다
                    ul
                        li -- 한 줄 주석
                        li /* 여러 줄 주석 */
                li 상수
                    ul
                        li 문자열 : '임의 문자열' -- 이 안에서 '를 나타내려면 ''를 사용
                        li C 스타일 이스케이프 문자열 : e'임의 문자열' 또는 E'임의 문자열' -- 이 안에서 \를 나타내려면 \\를 사용
                            ul
                                li \n : 줄바꿈
                                li \t : 탭
                        li 유니코드 이스케이프 문자열 : u&amp;'임의 문자열' 또는 U&amp;'임의 문자열'
                            ul
                                li 유니코드 지정 : \xxxx, \+xxxxxx
                                li \ 외의 이스케이프 문자 지정 예 : U&amp;'d!0061t!+000061' UESCAPE '!'
                        li $로 감싼 문자열 : $$임의 문자열$$ 또는 $tag_name$임의 문자열$tag_name$
                        li 비트열 : b'0101' 또는 B'0101' 또는 x'xxxx' 또는 X'xxxx'
                        li 숫자 : 소수점이나 지수가 없는 정수는 크기가 맞는 경우 integer 또는 bigint로 간주된다. 그 외 모든 숫자는 numeric 타입으로 간주된다
                            ul
                                li 소수점 허용 : 123.456
                                li 지수 표기 허용 : 0.123e3
                                li 정수에 한하여 2, 8, 16진수 표기 허용 : 0b101, 0o101, 0x101
                                li 구분자 허용 : 123_456.123_456
                        li 임의 유형 상수 : 이는 형 변환이 아니라, 문자열로 표현된 리터럴에 대해 처음으로 타입을 할당하는 것
                            ul
                                li type 'string'
                                li 'string'::type
                                li cast('string' as type)

            h3 값 표현식
            ul
                li 열 참조 : table_name.column_name
                li 위치 매개변수 : SQL 함수 또는 준비된 쿼리에서 $n으로 n번째 인자 참조
                li 배열 원소 선택 : expression[i], expression[start:end]
                li 필드 선택 : expression.field_name
                li 연산자 호출 : expression operator expression 또는 operator expression
                li 함수 호출 : function_name([expression [, expression ... ]])
                li 형 변환 : cast(expression as type) 또는 expression::type
                li 정렬 방식 지정 : expression COLLATE collation
                li 스칼라 서브쿼리 : 괄호 안의 SELECT 쿼리로, 정확히 한 개 행, 한 개 열을 반환                
            div
                h4 집계 표현식
                div
                    +asCode('sql', 'syntax').
                        aggregate_name (expression [ , ... ] [ order_by_clause ] ) [ FILTER ( WHERE filter_clause ) ]
                        aggregate_name (DISTINCT expression [ , ... ] [ order_by_clause ] ) [ FILTER ( WHERE filter_clause ) ]
                        aggregate_name ( * ) [ FILTER ( WHERE filter_clause ) ]
                        aggregate_name ( [ expression [ , ... ] ] ) WITHIN GROUP ( order_by_clause ) [ FILTER ( WHERE filter_clause ) ]
                    ul
                        li 집계 함수는 여러 입력 행들을 (그룹 당) 하나의 행으로 줄인다
                        li 별도 명시가 없는 한 집계 함수는 null을 집계에서 제외한다
                        li 입력 행 순서가 결과에 중요한 경우를 위해 선택적으로 order by 절을 지원한다
                        li 한편 최빈값, 중앙값을 찾는 것과 같은 ordered-set 집계는 order by 절이 필수다
                            +asCode('sql').
                                # with guild_player (guild_id, coin) as ( values
                                    (1, 10),
                                    (1, 50),
                                    (1, 20),
                                    (2, 10),
                                    (2, 40)
                                )
                                select
                                    guild_id,
                                    percentile_cont(0.5) within group (order by coin) as median_coin
                                from guild_player
                                group by 1;

                                 guild_id | median_coin 
                                ----------+-------------
                                        1 |          20
                                        2 |          25
                                (2 rows)
                h4 윈도 함수 호출
                div
                    +asCode('sql', 'syntax').
                        function_name ([expression [, expression ... ]]) [ FILTER ( WHERE filter_clause ) ] OVER window_name
                        function_name ([expression [, expression ... ]]) [ FILTER ( WHERE filter_clause ) ] OVER ( window_definition )
                        function_name ( * ) [ FILTER ( WHERE filter_clause ) ] OVER window_name
                        function_name ( * ) [ FILTER ( WHERE filter_clause ) ] OVER ( window_definition )

                    +asCode('sql', 'window_definition').
                        [ existing_window_name ]
                        [ PARTITION BY expression [, ...] ]
                        [ ORDER BY expression [ ASC | DESC | USING operator ] [ NULLS { FIRST | LAST } ] [, ...] ]
                        [ frame_clause ]

                    +asCode('sql', 'frame_clause').
                        { RANGE | ROWS | GROUPS } frame_start [ frame_exclusion ]
                        { RANGE | ROWS | GROUPS } BETWEEN frame_start AND frame_end [ frame_exclusion ]

                    +asCode('sql', 'frame_start 또는 frame_end').
                        UNBOUNDED PRECEDING
                        offset PRECEDING
                        CURRENT ROW
                        offset FOLLOWING
                        UNBOUNDED FOLLOWING

                    +asCode('sql', 'frame_exclusion').
                        EXCLUDE NO OTHERS   -- 기본 동작. 아무 행도 제외하지 않음
                        EXCLUDE CURRENT ROW -- 현재 행만 제외
                        EXCLUDE GROUP       -- 현재 행 + 피어 행 제외
                        EXCLUDE TIES        -- 피어 행들 제외

                    ul
                        li 윈도 함수는 집계 함수와 달리 입력 행들을 하나의 출력 행으로 축소하지 않는다. 각 행은 결과행에 유지되고, 지정한 파티션과 프레임에 한정한 집계 결과를 추가로 포함한다
                        li 윈도 함수는 다른 절들이 모두 처리된 후 실행되기 때문에 SELECT 또는 ORDER BY 절에서만 사용할 수 있다. 이로 인해 윈도 함수 안에 집계 함수를 포함하는 것이 가능하다 -- 그 반대는 불가능
                        li OVER (window_name ...)은 정의를 복사하여 수정하는 것을 의미한다
                        li PARTITION BY 절이 없는 경우, 모든 행을 포함하는 단일 파티션으로 처리된다
                        li 프레임을 지정해 각 입력 행마다 얼마큼의 행들을 집계에 이용할 지 지정할 수 있다
                            ul
                                li 피어 행 : 정렬키가 동일한 행
                                li ROWS 모드
                                    ul
                                        li 프레임 크기는 정확히 행 단위로 계산
                                        li 피어 행을 자동으로 포함하는 일은 없다
                                        li offset을 이용하는 경우 : 음이 아닌 정수로 행 개수를 지정
                                li RANGE 모드
                                    ul
                                        li 프레임 크기는 정렬키 구간에 따라 가변적
                                        li 구간 내 피어 행 자동 포함
                                        li offset을 이용하는 경우 : ORDER BY 절이 지정한 단일 컬럼에 대하여, 음이 아닌 값으로 최대 차이를 지정
                                li GROUPS 모드
                                    ul
                                        li 프레임 크기는 피어 그룹 단위로 계산
                                        li 피어 행 자동 포함
                                        li offset을 이용하는 경우 : 음이 아닌 정수로 피어 그룹 개수를 지정
                                li 프레임 정의가 생략된 경우, RANGE UNBOUNDED PRECEDING이 이용된다
                                li frame_end가 생략된 경우, CURRENT ROW로 설정된다
                                li ORDER BY 절이 없는 경우, 파티션 내 모든 행들은 서로의 피어다
                            +asCode('sql').
                                create temp table nums (n) as
                                values (1), (5), (10), (1), (5), (10);
                            +asCode('sql', 'order by 없음 + 프레임 정의 없음').
                                # select n, sum(n) over () from nums;
                                 n  | sum 
                                ----+-----
                                  1 |  32
                                  5 |  32
                                 10 |  32
                                  1 |  32
                                  5 |  32
                                 10 |  32
                                (6 rows)
                            +asCode('sql', 'order by 있음 + 프레임 정의 없음').
                                # select n, sum(n) over (order by n) from nums;
                                 n  | sum 
                                ----+-----
                                  1 |   2
                                  1 |   2
                                  5 |  12
                                  5 |  12
                                 10 |  32
                                 10 |  32
                                (6 rows)
                            +asCode('sql', 'ROWS 모드').
                                # select n, sum(n) over (order by n rows 2 preceding) from nums;
                                 n  | sum 
                                ----+-----
                                  1 |   1
                                  1 |   2
                                  5 |   7
                                  5 |  11
                                 10 |  20
                                 10 |  25
                                (6 rows)
                            +asCode('sql', 'RANGE 모드').
                                # select n, sum(n) over (order by n range 4 preceding) from nums;
                                 n  | sum 
                                ----+-----
                                  1 |   2
                                  1 |   2
                                  5 |  12
                                  5 |  12
                                 10 |  20
                                 10 |  20
                                (6 rows)
                            +asCode('sql', 'GROUPS 모드').
                                # select n, sum(n) over (order by n groups 1 preceding) from nums;
                                 n  | sum 
                                ----+-----
                                  1 |   2
                                  1 |   2
                                  5 |  12
                                  5 |  12
                                 10 |  30
                                 10 |  30
                                (6 rows)
                h4 배열 생성자
                ul
                    li array[1, 2, 3]
                    li array[1, 2, 3]::bigint[]
                    li array[array[array[1, 2, 3]]]::bigint[] -- 형 변환은 내부에 자동 전파
                    li array[array[1, 2, 3], array[4, 5, 6]] -- 다차원 배열의 경우, 각 차원의 내부 배열들은 모두 동일한 크기를 가져야 한다
                    li array(select n from generate_series(1, 3) as x(n)) -- 단일 열을 반환하는 서브쿼리로부터 배열 생성 가능

                h4 행 생성자
                ul
                    li row value (composite value라고도 함)를 생성하는 표현식
                    li row 키워드와 0개 이상의 표현식으로 구성된다 : row(1, true, 'text')
                    li 목록에 표현식이 2개 이상 있으면 키워드는 생략 가능하다 : (1, true, 'text')
                    li 행 생성자는 row_value.* 구문을 포함할 수 있다
                        +asCode('sql') select (row_number() over (), t.*) from pg_stat_activity t;
                    li 행 생성자는 다른 행 값을 포함할 수 있다
                        +asCode('sql') select (t, row(t.*)) from pg_stat_activity t;
                    li 기본적으로 생성된 값은 익명 레코드 형식이지만, 필요한 경우 명명된 타입으로 변환 가능
                        +asCode('sql').
                            create table my_table(f1 int, f2 text);

                            create function get_f1(my_table) returns int as 'select $1.f1' language sql;

                            select get_f1((1, 'text'));

                            create type my_row_type as (f1 int, f2 text);

                            create function get_f1(my_row_type) returns int as 'SELECT $1.f1' language sql;

                            select get_f1((1, 'text')); -- ERROR:  function get_f1(record) is not unique
                            select get_f1((1, 'text')::my_table);
                            select get_f1((1, 'text')::my_row_type);

                h4 표현식 평가 규칙
                ul
                    li 표현식이 평가되는 순서는 정의되지 않았고, 쿼리 실행 계획에 따라 얼마든지 변경될 수 있다. 이는 가장 간단한 사례에서도 발생하는데, true or func()와 func() or true 양쪽 모두에서 func()는 실행되지 않을 수 있다
                    li 예외적으로 case 구문은 표현식들을 순차적으로 평가함이 강제되지만, 그럼에도 불구하고 문제가 발생하는 경우들이 있다
                        ul
                            li 상수 평가에서 에러 발생하는 경우 : case when x > 0 then x else 1/0 end
                            li 집계 함수에서 에러 발생하는 경우 : case when min(employees) > 0 then avg(expenses / employees) end

            h3 함수 호출
            ul
                li 위치 표기법 : func(val1, val2)
                li 이름 표기법 : func(arg1 => val1, arg2 => val2)
                    p "=>" 대신 이전 버전의 ":="도 지원됨
                li 혼합 표기법 : func(val1, val2, arg3 => val3)

        h2 데이터 정의
        div
            h3 ID 열
            ul
                li 값이 암묵적인 시퀀스로부터 자동 생성되는 열
                    +asCode('sql').
                        # create temp table order_history (
                            order_no    bigint generated always as identity primary key,
                            created_at  timestamptz default current_timestamp
                        );

                        # insert into order_history values (default, default) returning *;

                         order_no |          created_at           
                        ----------+-------------------------------
                                1 | 2026-01-02 13:53:42.781017+09
                        (1 row)
                li ID 열은 자동적으로 not null
                li 테이블 상속에서 자식 테이블의 ID 열은 부모의 것을 상속하지 않는다
                li 개별 파티션은 파티션된 테이블의 ID 열을 상속한다

            h3 생성된 열
            ul
                li 다른 열들로부터 파생되는 열. 단, 이미 파생된 열을 정의에 사용할 수는 없다
                +asCode('sql').
                    # create temp table player (
                        purchase_amount int not null,
                        vip_level       int generated always as (case
                                            when purchase_amount > 10000 then 3
                                            when purchase_amount > 5000 then 2
                                            when purchase_amount > 1000 then 1
                                            else 0
                                        end)
                    );

                    # insert into player values (5555, default) returning *;

                     purchase_amount | vip_level 
                    -----------------+-----------
                                5555 |         2
                    (1 row)

                    INSERT 0 1
                li 기본적으로는 열을 읽을 떄마다 새로 계산되지만 (virtual), 실제로 디스크에 저장하도록 할 수도 있다 (stored)
                li 테이블 상속에서 부모 열이 생성된 열이면 자식 열도 동일한 유형이어야 하지만, 표현식은 다를 수 있다
                li create table ... partition of로 생성하는 경우, 정의는 자동으로 복사된다
                li alter table ... attach partition으로 붙이는 경우엔 표현식이 다를 수 있다
                li 생성된 열은 별도 접근 권한을 가질 수 있다
                li before 트리거가 실행된 후에 업데이트되고, before 트리거 안에서는 접근이 허용되지 않는다

            h3 시스템 열
            ul
                li tableoid : 행이 속한 테이블의 oid. pg_class와 조인하여 파티션된 테이블이나 상속 계층 상의 테이블을 쉽게 식별 가능
                li xmin : 이 행을 삽입한 트랜잭션 ID
                li cmin : 삽입 트랜잭션 내 명령 ID
                li xmax : 이 행에 대한 삭제 트랜잭션 ID. 0인 경우 행이 삭제되지 않음이 확실하지만, 삭제 트랜잭션이 커밋되지 않았거나 롤백된 경우에도 0이 아닌 값으로 남는다
                li ctid : 현재 물리적 위치

            h3 행 보안
            ul
                li BYPASSRLS 속성을 가진 슈퍼유저와 역할은 항상 행 보안을 우회한다
                li 테이블 소유자도 기본적으로 행 보안을 우회하지만, 명령 실행 시 force row level security를 지정하면 행 보안을 적용받을 수 있다
                li 기본키, 고유키 등의 무결성 검사는 항상 행 보안을 우회한다

            h3 테이블 상속
            ul
                li 상속 관계는 나중에 추가할 수도 있다
                li only 키워드를 지원하는 명령어들은 이를 이용하여 자식 테이블들은 제외하고 지정한 테이블에만 명령을 적용할 수 있다
                li 기본키, 고유키 등의 제약사항은 자식 테이블들을 고려하지 않는다

            h3 테이블 파티셔닝
            ul
                li 파티셔닝을 테이블을 물리적으로 쪼갠다
                li 일반적으로 파티셔닝의 효과적이려면 테이블 크기가 서버의 물리적 메모리 용량을 초과해야 한다
                li 일반 테이블을 나중에 파티션 테이블로 바꾸거나, 그 반대로 변환하는 것은 지원되지 않는다. 한편 파티션을 붙였다 떼는 건 자유롭게 가능하다
                    p 파티션을 나중에 추가할 때, 이미 행이 많이 있다면 성능을 위해 다음 사항들을 미리 만들어두는 게 좋다
                        ul
                            li 파티션 조건과 일치하는 check 제약 조건
                            li 파티션 테이블에 정의된 인덱스 정의와 일치하는 인덱스
                li 파티션된 테이블에 기본 파티션이 있는 경우, 앞으로 연결될 파티션들을 제외하는 check 제약 조건을 생성하는 것이 성능상 좋다
                li 범위를 이용해 파티션을 정의하는 경우, 상한은 배타적으로 적용된다
                    +asCode('sql').
                        create table xxx_2404 partition of xxx for values from ('2024-04-01') to ('2024-05-01');
                        create table xxx_2405 partition of xxx for values from ('2024-05-01') to ('2024-06-01');
                li 파티션 자체를 파티션 테이블로 정의해 추가로 쪼갤 수도 있다
                li 파티션된 테이블에 대해 인덱스를 생성할 때 concurrently 한정자를 사용할 수 없다
                    ol
                        li create index on only 구문을 이용해 인덱스가 유효하지 않은 상태로 생성
                        li 개별 파티션들에 대해 create index ... concurrently 실행
                        li alter index ... attach partition을 이용해 인덱스 연결
                        li 모든 파티션 인덱스가 연결되면 부모 인덱스는 자동으로 유효한 것으로 간주
                    p 이 기법은 unique, primary key 제약 조건에도 사용할 수 있다: alter table only ... add unique
                li 파티션 수가 많다고 항상 좋지도 않고, 파티션 수가 적다고 항상 나쁜 것도 아니다 -- 사용 사례에 맞는 설계를 해야 한다

        h2 데이터 조작
        div
            h3 INSERT
            ul
                li 모든 열을 기본값으로 설정해 행을 삽입하는 경우 다음과 같은 쿼리를 이용할 수 있다
                    +asCode('sql') insert into table_name default values;
                li 쿼리 결과를 삽입에 이용할 수 있다
                    +asCode('sql') insert into table_name (col1, col2) select ...

            h3 조작한 행 데이터 반환
            ul
                li insert, update, delete, merge에 대해 선택적으로 returning 절을 이용해 수정 직후 select 가능
                    p 트리거가 있는 경우, returning이 조회하는 데이터는 트리거가 수정 완료한 행
                li merge의 경우 원본 행, 삽입/업데이트/삭제한 행 데이터 모두 획득 가능
                li 어떤 경우든 old.col_name으로 이전 버전 데이터 획득 가능

        h2 쿼리
        div
            h3 Table expression
            div
                h4 Joined table
                ul
                    li 구문
                        +asCode('sql').
                            T1 cross join T2
                            T1         { [inner] | { left | right | full } [outer] } join T2 on boolean_expression
                            T1         { [inner] | { left | right | full } [outer] } join T2 using ( join_column_list )
                            T1 natural { [inner] | { left | right | full } [outer] } join T2
                        ul
                            li 괄호를 이용하여 조인 순서를 제어할 수 있다. 괄호가 없는 경우 왼쪽에서 오른쪽으로 중첩된다
                            li using을 이용하는 경우, 출력은 중복되는 열을 제거한다 : 공통 열, 나머지 T1 열, 나머지 T2 열
                            li natural은 using의 축약형으로, 두 테이블에서 공통적으로 나타나는 모든 열 이름으로 구성된 using과 동일하다
                            li 조인 조건은 조인 대상을 필터링하기 위한 것으로 조인 전에 처리된다

                    li cross join
                        ul
                            li T1과 T2의 모든 행 조합(데카르트 곱) 포함
                            li from t1 cross join t2는 다음 표현들과 동일하다
                                ul
                                    li from t1 inner join t2 on true
                                    li from t1, t2
                        +asCode('sql').
                            # create temp table a (a) as values ('a1'), ('a2');

                            # create temp table b (b) as values ('b1'), ('b2'), ('b3');

                            # create temp table c ( c text );

                            # select * from a cross join b;
                             a  | b  
                            ----+----
                             a1 | b1
                             a1 | b2
                             a1 | b3
                             a2 | b1
                             a2 | b2
                             a2 | b3
                            (6 rows)

                            # select * from a, c;
                             a | c 
                            ---+---
                            (0 rows)

                    li (inner) join : 조인 조건을 만족하는 T1, T2의 행 조합
                        +asCode('sql').
                            # with
                            # a (a) as ( values ('a1'), ('a2'), ('a4') ),
                            # b (b) as ( values ('b1'), ('b1+'), ('b2'), ('b3') )
                            # select * from a join b on regexp_match(a, $$\d+$$) = regexp_match(b, $$\d+$$);
                             a  | b  
                            ----+----
                             a1 | b1
                             a1 | b1+
                             a2 | b2
                            (3 rows)

                    li left (outer) join : 조건을 만족하지 않는 T1 행도 포함
                        +asCode('sql').
                            # \pset null '(null)'
                            # with
                            # a (a) as ( values ('a1'), ('a2'), ('a4') ),
                            # b (b) as ( values ('b1'), ('b1+'), ('b2'), ('b3') )
                            # select * from a left join b on regexp_match(a, $$\d+$$) = regexp_match(b, $$\d+$$);
                             a  |  b  
                            ----+-----
                             a1 | b1
                             a1 | b1+
                             a2 | b2
                             a4 | (null)
                            (4 rows)

                    li right (outer) join : 조건을 만족하지 않는 T2 행도 포함
                        +asCode('sql').
                            # \pset null '(null)'
                            # with
                            # a (a) as ( values ('a1'), ('a2'), ('a4') ),
                            # b (b) as ( values ('b1'), ('b1+'), ('b2'), ('b3') )
                            # select * from a right join b on regexp_match(a, $$\d+$$) = regexp_match(b, $$\d+$$);
                               a    |  b  
                            --------+-----
                             a1     | b1
                             a1     | b1+
                             a2     | b2
                             (null) | b3
                            (4 rows)

                    li full (outer) join : 조건을 만족하지 않는 T1, T2 행 각각 포함
                        +asCode('sql').
                            # \pset null '(null)'
                            # with
                            # a (a) as ( values ('a1'), ('a2'), ('a4') ),
                            # b (b) as ( values ('b1'), ('b1+'), ('b2'), ('b3') )
                            # select * from a full join b on regexp_match(a, $$\d+$$) = regexp_match(b, $$\d+$$);
                               a    |   b    
                            --------+--------
                             a1     | b1
                             a1     | b1+
                             a2     | b2
                             (null) | b3
                             a4     | (null)
                            (5 rows)

                h4 Table and column alias
                p 별칭 정의 후엔 쿼리에서 원래 이름으로 참조할 수 없다

                h4 Subquery
                ul
                    li 파생 테이블을 지정하는 서브쿼리는 괄호로 감싸야 한다
                    li select 명령 대신 values 목록으로 서브쿼리를 구성할 수도 있다
                        +asCode('sql').
                            # select * from (values ('a', 1), ('a', 2)) as x(a, b);
                             a | b 
                            ---+---
                             a | 1
                             a | 2
                            (2 rows)

                h4 Table function
                ul
                    li 테이블 함수는 행 집합을 생성하는 함수
                    li 구문
                        +asCode('sql').
                            function_call                       [with ordinality] [[as] table_alias [(column_alias, [, ...])]]
                            rows from( function_call [, ... ] ) [with ordinality] [[as] table_alias [(column_alias, [, ...])]]
                    li with ordinality : 마지막에 bigint 타입의 ordinality 열이 추가되어 행 번호를 표시한다
                    li 특수 테이블 함수 unnest는 임의 개수의 배열 매개변수로 호출할 수 있는데, 개별 배열에 대해 unnest가 호출되고 rows from 구문으로 결합한 것처럼 동작한다
                        +asCode('sql').
                            # \pset null '(null)'
                            # select * from unnest('{1, 2, 3}'::int[], '{a, b}'::text[]) with ordinality as x (a, b);
                             a |   b    | ordinality 
                            ---+--------+------------
                             1 | a      |          1
                             2 | b      |          2
                             3 | (null) |          3
                            (3 rows)

                            # select * from rows from(
                            #     unnest('{1, 2, 3}'::int[]),
                            #     unnest('{a, b}'::text[])
                            # ) with ordinality as x (a, b, c);
                             a |   b    | c 
                            ---+--------+---
                             1 | a      | 1
                             2 | b      | 2
                             3 | (null) | 3
                            (3 rows)
                    li 테이블 및 열 별칭을 지정하지 않으면, 함수 이름이 이용된다
                    li 호출 방식에 따라 다른 열 집합을 반환하는 경우, 출력 행 구조를 쿼리에 지정해야 한다
                        +asCode('sql').
                            create extension dblink;

                            select *
                            from dblink('dbname=wiz', 'select pid, usename, query from pg_stat_activity')
                                as x(pid int, usename text, query text)
                            where query != '';
                        +asCode('sql').
                            # \pset null '(null)'
                            # select *
                            # from rows from (
                            #     json_to_recordset('[{"a":40,"b":"foo"},{"a":"100","b":"bar"}]') as (a int, b text),
                            #     generate_series(1, 3)
                            # ) as x(x, y, z)
                            # order by 3;
                               x    |   y    | z 
                            --------+--------+---
                                 40 | foo    | 1
                                100 | bar    | 2
                             (null) | (null) | 3
                            (3 rows)

                h4 lateral 서브쿼리
                ul
                    li 기본적으로 서브쿼리는 독립적으로 평가되므로 from 절의 다른 테이블을 참조할 수 없다
                    li from 절의 서브쿼리 앞에 lateral 키워드를 붙이는 경우, from 절에서 해당 서브쿼리보다 앞에 있는 테이블의 열을 참조할 수 있다
                    li 테이블 함수는 항상 그보다 앞에 있는 테이블의 열을 참조할 수 있으므로 lateral 키워드 명시는 선택 사항이다

                h4 where 절
                p from 절 처리가 완료된 후, 생성된 가상 테이블의 각 행이 검색 조건과 일치하는지 검사한다 -- 결과가 false거나 null이면 출력 테이블에서 삭제된다

                h4 group by, having 절
                ul
                    li where 필터를 통과한 뒤의 테이블을 group by 절을 이용해 그룹화할 수 있다
                        p 한편 전체 테이블이 한 개 그룹이라면 group by 생략 가능
                    li having 절을 이용해 그룹에 대한 필터링을 수행할 수 있다
                    li grouping sets : group by를 여러 번 수행하고 이어붙인 것과 같다
                        +asCode('sql').
                            # \pset null '(null)'
                            # with tmp (a, b) as ( values ('a', 'b') )
                            # select a, b
                            # from tmp
                            # group by grouping sets (a, b);
                               a    |   b    
                            --------+--------
                             a      | (null)
                             (null) | b
                            (2 rows)
                    li cube : 가능한 모든 부분집합(멱집합; power set)에 대해 질의한 것과 같다
                        +asCode('sql').
                            -- cube(a, b) = grouping sets((), (a), (b), (a, b))
                            # \pset null '(null)'
                            # with tmp (a, b) as ( values ('a', 'b') )
                            # select a, b
                            # from tmp
                            # group by cube (a, b);
                               a    |   b    
                            --------+--------
                             (null) | (null)
                             a      | b
                             a      | (null)
                             (null) | b
                            (4 rows)
                    li rollup : 공집합부터 요소들을 순서대로 추가한 집합들에 대해 질의한 것과 같다
                        +asCode('sql').
                            -- rollup(a, b) = grouping sets((), (a), (a, b))
                            # \pset null '(null)'
                            # with tmp (a, b) as ( values ('a', 'b') )
                            # select a, b
                            # from tmp
                            # group by rollup (a, b);
                               a    |   b    
                            --------+--------
                             (null) | (null)
                             a      | b
                             a      | (null)
                            (3 rows)
                    li cube, rollup의 요소로 리스트를 지정할 수 있다
                        +asCode('sql').
                            -- rollup(a, (b, c)) == grouping sets((), (a), (a, b, c))
                            # \pset null '(null)'
                            # with tmp (a, b, c) as ( values ('a', 'b', 'c') )
                            # select a, b, c
                            # from tmp
                            # group by rollup (a, (b, c));
                               a    |   b    |   c    
                            --------+--------+--------
                             (null) | (null) | (null)
                             a      | b      | c
                             a      | (null) | (null)
                            (3 rows)
                    li grouping sets의 요소로 cube, rollup을 사용할 수 있다
                    li distinct를 이용해 그룹 집합에 대한 중복을 제거할 수 있다
                        +asCode('sql').
                            # \pset null '(null)'
                            # with tmp (a, b, c) as ( values ('a', 'b', 'c') )
                            # select a, b, c
                            # from tmp
                            # group by distinct grouping sets (cube(a, b), rollup(b, c))
                            # order by 1, 2, 3;
                               a    |   b    |   c    
                            --------+--------+--------
                             a      | b      | (null)
                             a      | (null) | (null)
                             (null) | b      | c
                             (null) | b      | (null)
                             (null) | (null) | (null)
                            (5 rows)
                    li 하나의 group by에 여러 그룹화 항목이 나열되는 경우, 최종 목록은 각 항목들에 대한 곱집합이다
                        +asCode('sql').
                            # \pset null '(null)'
                            # with tmp (a, b, c, d) as ( values ('a', 'b', 'c', 'd') )
                            # select a, b, c, d
                            # from tmp
                            # group by cube (a, b), cube (c, d)
                            # order by 1, 2, 3, 4;
                               a    |   b    |   c    |   d    
                            --------+--------+--------+--------
                             a      | b      | c      | d
                             a      | b      | c      | (null)
                             a      | b      | (null) | d
                             a      | b      | (null) | (null)
                             a      | (null) | c      | d
                             a      | (null) | c      | (null)
                             a      | (null) | (null) | d
                             a      | (null) | (null) | (null)
                             (null) | b      | c      | d
                             (null) | b      | c      | (null)
                             (null) | b      | (null) | d
                             (null) | b      | (null) | (null)
                             (null) | (null) | c      | d
                             (null) | (null) | c      | (null)
                             (null) | (null) | (null) | d
                             (null) | (null) | (null) | (null)
                            (16 rows)

                h4 윈도 함수 처리
                ul
                    li 윈도 함수는 위 그룹화와 having 필터링이 모두 수행된 후 실행된다
                    li 쿼리 결과는 윈도 함수에 정의된 순서에 따라 정렬되긴 하지만, 이에 의존하는 것은 권장되지 않는다. 정렬된 결과가 필요한 경우 최상위 order by 절을 명시하는 것이 권장된다

            h3 Select list
            ul
                li 컬럼 이름 대신 *를 이용해 모든 컬럼을 순서대로 선택 가능
                li 열 이름에 지정한 별칭은 후속 처리 -- order by 절 포함 -- 에 사용 가능
                li select distinct를 이용해 중복 행 제거 가능. 이때 null도 하나의 고윳값으로 취급
                li (비표준) select distinct on (expression [, ...])를 이용해 사용자 정의 기준으로 중복 행 제거 가능

            h3 쿼리 결합
            ul
                li query1 union [all] query2 : 합집합
                li query1 intersect [all] query2 : 교집합
                li query1 except [all] query2 : 차집합
                li all을 지정하지 않는 경우 distinct와 마찬가지로 중복된 행을 제거한다
                li 괄호 없이 나열되는 경우, intersect가 union/except보다 먼저 평가된다

            h3 order by
            p null은 기본적으로 null이 아닌 값보다 큰 것처럼 정렬된다

            h3 values list
            ul
                li 디스크에 쓰지 않고 사용할 수 있는 상수 테이블을 생성한다
                li 기본적으로 column1, column2, ... 이름을 할당하지만, 이는 SQL 표준이 아니므로 호환을 위해 재정의하는 것이 좋다
                li 구문적으로 #[+asInlineCode('values (expression [, ...]) [, ...]', 'sql')]는 #[+asInlineCode('select select_list from table_expression', 'sql')]과 동일하게 취급된다
                    ul
                        li select가 나타날 수 있는 모든 곳에 사용될 수 있다
                        li 뒤에 order by, limit 등을 붙일 수 있다
                    +asCode('sql').
                        # values (1), (3), (2) order by 1 limit 2;
                         column1 
                        ---------
                               1
                               2
                        (2 rows)

                        # create table table_name (num) as values (1), (3), (2);
                        SELECT 3

                        # insert into table_name values (1), (2), (3);
                        INSERT 0 3

                        # select * from (values (1), (3), (2)) as x(num);
                         num 
                        -----
                           1
                           3
                           2
                        (3 rows)

                        # with tmp(num) as (values (1), (2), (3))
                        # (select * from tmp) union
                        # (values (1), (4));
                         num 
                        -----
                           1
                           3
                           4
                           2
                        (4 rows)

            h3 with 쿼리 (CTE; Common Table Expression)
            ul
                li 하나의 쿼리 실행 중에만 존재하는 임시 테이블을 정의하는 방법을 제공한다
                li select, insert, update, delete, merge 명령을 with 절의 보조문으로 사용할 수 있다
                    +asCode('sql').
                        with temp_name as (
                            보조문
                        )
                        부모_쿼리
                li recursive 한정자를 이용하면 쿼리가 직접 출력을 참조하는 반복 연산이 가능하다
                    ol
                        li non-recursive 부분을 계산한다. UNION을 위해 (not UNION ALL) 중복되는 행을 제거한다. 남은 행들을 결과에 포함시키고, 임시 작업 테이블로 설정한다
                        li 작업 테이블이 빌 때까지 아래를 반복한다
                            ol
                                li recursive 부분을 계산하고, 작업 테이블 내용을 덮어쓴다. UNION을 위해 (not UNION ALL) 중복된 행(이전 결과와도 비교)들을 제거한다. 남은 행들을 결과에 포함시키고, 임시 중간 테이블로 설정한다
                                li 작업 테이블의 내용을 중간 테이블 내용으로 대체한다. 중간 테이블은 비운다
                    +asCode('sql').
                        -- 10 ~ 100의 합계
                        with recursive t(n) as (
                            (values (10))
                            union all
                            (select n+1 from t where 100 > n)
                        )
                        select sum(n) from t;
                    +table()
                        tr
                            th t
                            th working_table
                        tr
                            td empty
                            td empty
                        tr
                            td 10
                            td 10
                        tr
                            td 10, 11
                            td 11
                        tr
                            td 10, 11, 12
                            td 12
                        tr
                            td ...
                            td ...
                        tr
                            td 10, 11, 12, 13, ..., 100
                            td 100
                        tr
                            td 10, 11, 12, 13, ..., 100
                            td empty
                li 일반적으로 with 쿼리는 이후 몇 번 참조되든지 한 번만 평가되는 대신, 메인 쿼리의 제약 조건이 최적화에 고려되지 않는다
                    ul
                        li 하지만 with 쿼리가 재귀적이지 않고, 부작용이 없고, 한 번만 참조된다면 메인 쿼리와 통합되어 동시에 최적화된다
                        li not materialized를 지정하면 with 쿼리가 메인 쿼리에 통합되어 동시에 최적화되도록 할 수 있다
                            +asCode('sql').
                                with x as not materialized (
                                    select * from big_table
                                )
                                select * from x as t1 join x as t2 on t1.id = t2.parent
                                where t2.id = 123;

        h2 데이터 유형
        div
            h3 숫자
            +table()
                +ths('name', 'storage size', 'description', 'range')
                +tds('smallint', '2 바이트', '정수', '-32768 ~ +32767')
                +tds('integer', '4 바이트', '정수', '-2147483648 ~ +2147483647')
                +tds('bigint', '8 바이트', '정수', '-9223372036854775808 ~ +9223372036854775807')
                +tds('decimal, numeric', '가변', '사용자 지정 정밀도. 유리수', '소수점 앞 최대 131072자리, 소수점 뒤 최대 16383자리')
                +tds('real', '4 바이트', '부동 소수', '소수점 6자리 정밀도')
                +tds('double precision', '8 바이트', '부동 소수', '소수점 15자리 정밀도')
            ul
                li numeric(precision, scale=0) : 최대 precision(1 ~ 1000)개 유효숫자, 최대 scale개 소수점 자릿수(-1000 ~ 1000)
                    p SQL 표준은 scale 값으로 0 ~ precision만 허용함에 유의
                li numeric : precision, scale 모두 지정하지 않으면 표에 기재된 최대 제약 조건을 갖는다
                    p 제약 조건 없는 numeric은 무한대('Infinity', '-Infinity')를 저장할 수 있다
                li 가까운 짝수로 반올림하는 real, double precision과 다르게 numeric은 0에서 멀어지는 방향으로 이루어진다

            h3 이진 데이터
            p SQL 표준의 BLOB과 유사한 타입을 bytea로 지원한다

            h3 날짜/시간
            ul
                li time, timestamp, interval은 초 단위 소수점 정밀도(0~6) 지정 가능
                li 유효한 타임스탬프 입력 : 날짜 + 시간 + [시간대] + [AD|BC]
                    ul
                        li timestamp 타입에 대해선 입력의 시간대 표시를 무시한다
                        li timestamptz 타입에 대해선 시각을 UTC로 변환하여 저장한다
                li 특수 날짜/시간 입력 문자열
                    p 'now', 'today' 등을 사용한 저장된 쿼리는 해당 시각을 계속 재사용하기 때문에, SQL 함수를 이용하는 것이 권장된다. 예. 'tomorrow'::date 대신 CURRENT_DATE + 1
                    +table()
                        +ths('input string', 'valid types', 'description')
                        +tds('epoch', 'date, timestamp', 'Unix time zero')
                        +tds('infinity', 'date, timestamp, interval', '다른 모든 타임스탬프보다 나중')
                        +tds('-infinity', 'date, timestamp, interval', '다른 모든 타임스탬프보다 이전')
                        +tds('now', 'date, time, timestamp', '트랜잭션 시작 시각')
                        +tds('today', 'date, timestamp', '오늘 자정')
                        +tds('tomorrow', 'date, timestamp', '내일 자정')
                        +tds('yesterday', 'date, timestamp', '어제 자정')
                        +tds('allballs', 'time', '00:00:00.00 UTC')
                li interval 입력 : '[@] quantity unit [quantity unit...] [ago]'
                    ul
                        li @ : 장식 옵션
                        li quantity : 음수 허용
                        li unit : microsecond, millisecond, second, minute, hour, day, week, month, year, decade, century, millennium
                        li ago : 지정 시 모든 quantity 부호를 뒤집는다
                        li 일부 간략한 표기 지원 : '일 시간:분:초', '년-월'

            h3 열거형
            +asCode('sql').
                CREATE TYPE enum_name AS ENUM ('value1', 'value2')
                ALTER TYPE enum_name ADD VALUE [ IF NOT EXISTS ] 'new value' [ { BEFORE | AFTER } 'neighbor value' ]
                ALTER TYPE enum_name RENAME VALUE 'old value' TO 'new value'

                # select * from pg_enum;
                  oid  | enumtypid | enumsortorder | enumlabel 
                -------+-----------+---------------+-----------
                 16566 |     16564 |             1 | value1
                 16568 |     16564 |             2 | value2
                 16569 |     16564 |           1.5 | value3
                (3 rows)

            h3 텍스트 검색
            ul
                li tsvector : 정렬된 어휘소 목록. 정렬과 중복 제거는 자동으로 수행되지만, 정규화는 자동으로 수행되지 않는다
                    +asCode('sql').
                        # select 'SQL 표준의 BLOB과 유사한 타입을 bytea로 지원한다'::tsvector;
                                                    tsvector                            
                        ----------------------------------------------------------------
                         'BLOB과' 'SQL' 'bytea로' '유사한' '지원한다' '타입을' '표준의'
                        (1 row)

                        # select to_tsvector('SQL 표준의 BLOB과 유사한 타입을 bytea로 지원한다');
                                                         to_tsvector                                  
                        ------------------------------------------------------------------------------
                         'blob과':3 'bytea로':6 'sql':1 '유사한':4 '지원한다':7 '타입을':5 '표준의':2
                        (1 row)
                li tsquery : 어휘소 검색 정보
                    ul
                        li a &amp; b : a and b
                        li a | b : a or b
                        li !a : not a
                        li a &lt;-&gt; b : a followed by b
                        li a &lt;N&gt; b : a followed by b within N distance
                            p N = 0인 경우 : 두 패턴이 동일한 단어에 매칭돼야함
                        li 접두어 매칭 : 'xxx:*'::tsquery
                        li 정규화 : to_tsquery('original query')
                            +asCode('sql').
                                # SELECT to_tsvector( 'postgraduate' ) @@ to_tsquery( 'postgres:*' );
                                 ?column? 
                                ----------
                                 t
                                (1 row)

                                # SELECT to_tsvector( 'postgraduate' ), to_tsquery( 'postgres:*' );
                                  to_tsvector  | to_tsquery 
                                ---------------+------------
                                 'postgradu':1 | 'postgr':*
                                (1 row)

            h3 JSON
            ul
                li json : 입력 텍스트 그대로 저장. JSON 연산 시 매번 파싱 필요
                li jsonb : 바이너리로 저장. JSONB 연산 매우 빠름
                    p 전용 인덱스 지원
                    ul
                        li create index ... using gin (jsonb_col) : 키-존재 연산자 ?, ?|, ?&amp;, 포함 연산자 @>, jsonpath 일치 연산자 @?, @@ 연산자 지원
                        li using gin (jsonb_col jsonb_path_ops) : @>, @?, @@ 연산자만 지원하지만, 크기가 훨씬 작고 검색 성능도 더 좋다(지원하는 연산자에 한해)
                        li using gin ((jsonb_col -> 'prop')) : 보다 좋은 성능을 위해 인덱스 범위를 좁힐 수 있다
                li jsonb 첨자를 이용한 할당 시, 경로가 정의되지 않은 경우 첨자가 암시하는 유형의 빈 값인 것처럼 진행된다
                    +asCode('sql').
                        # create temp table test (x) as ( values (null::jsonb), ('{}'::jsonb) );
                        SELECT 2
                        
                        # update test set x['a'][1]['b'] = '1' returning *;
                                    x            
                        -------------------------
                         {"a": [null, {"b": 1}]}
                         {"a": [null, {"b": 1}]}
                        (2 rows)

                        UPDATE 2
                li jsonpath (SQL/JSON path)
                    ul
                        li variable
                            ul
                                li $ : 쿼리 대상 객체
                                li $varname : 함수 인자로 설정한 변수
                                li @ : 경로 매칭 후 필터 표현식에서 참조하는 결과 객체
                        li accessor
                            ul
                                li .key, ."$varname" : 특정 속성 접근
                                li .* : 전체 멤버 접근
                                li .** : 재귀적으로 전체 멤버 접근
                                    +asCode('sql').
                                        # select jsonb_path_query('{"a":{"b":{"c":1}}}', '$.*');
                                         jsonb_path_query 
                                        ------------------
                                         {"b": {"c": 1}}
                                        (1 row)

                                        # select jsonb_path_query('{"a":{"b":{"c":1}}}', '$.**');
                                            jsonb_path_query    
                                        ------------------------
                                         {"a": {"b": {"c": 1}}}
                                         {"b": {"c": 1}}
                                         {"c": 1}
                                         1
                                        (4 rows)

                                        # select jsonb_path_query('[1,[2,[3]]]', '$.*');
                                         jsonb_path_query 
                                        ------------------
                                        (0 rows)

                                        # select jsonb_path_query('[1,[2,[3]]]', '$.**');
                                         jsonb_path_query 
                                        ------------------
                                         [1, [2, [3]]]
                                         1
                                         [2, [3]]
                                         2
                                         [3]
                                         3
                                        (6 rows)
                                li .**{level}, .**(start to end) : 지정 레벨(0부터 시작) 순회 결과만 반환
                                li [subscript, ...] : 배열 요소 접근
                                    +asCode('sql').
                                        # select jsonb_path_query('[1,2,3,4,5]', '$[0, last, 2 to last-1]');
                                         jsonb_path_query 
                                        ------------------
                                         1
                                         5
                                         3
                                         4
                                        (4 rows)
                                li [*] : 배열 모든 요소 접근
                        li operator and method
                            p jsonpath 평가 결과에 대해 추가 연산을 수행할 수 있다
                            ul
                                li JavaScript 산술 연산 : +, -, *, /, %
                                li value.type() : JSON 타입 반환
                                li value.size() : 배열이 아니어도 1 반환됨에 유의
                                    +asCode('sql').
                                        # select jsonb_path_query('[]', '$.size()'), jsonb_path_query('[1,2,3]', '$.size()'), jsonb_path_query('{}', '$.size()');
                                         jsonb_path_query | jsonb_path_query | jsonb_path_query 
                                        ------------------+------------------+------------------
                                         0                | 3                | 1
                                        (1 row)
                                li value.boolean() : boolean, string, numeric에 한해 boolean 변환
                                    +asCode('sql').
                                        # select jsonb_path_query('[0, 1, false, true, "FalsE", "TruE"]', '$[*].boolean()');
                                         jsonb_path_query 
                                        ------------------
                                         false
                                         true
                                         false
                                         true
                                         false
                                         true
                                        (6 rows)
                                li value.string() : boolean, number, string, datetime을 string으로 변환
                                li value.double() : number, string을 number로 변환. 기타 bigint(), decimal(), integer(), numeric() 지원
                                li number값 전용 함수 : ceiling(), floor(), abs()
                                li string값 전용 함수 : date(), timestamp(), timestamp_tz() 등
                                li object.keyvalue() : 키-값 쌍 해체
                                    +asCode('sql').
                                        # select jsonb_path_query('[{"a":1},{"a":1},{"b":{"c":2}}]', '$[*].keyvalue()');
                                                     jsonb_path_query              
                                        -------------------------------------------
                                         {"id": 16, "key": "a", "value": 1}
                                         {"id": 40, "key": "a", "value": 1}
                                         {"id": 64, "key": "b", "value": {"c": 2}}
                                        (3 rows)
                        li filter ::= ? (condition)
                            ul
                                li SQL/JSON은 부울 대수로 3상태를 가진다 : true, false, unknown
                                li 동등 비교 : ==, !=, &lt;&gt;
                                li 대소 비교 : &lt;, &lt;=, &gt;, &gt;=
                                li 부울 대수 연산 : &amp;&amp;, ||, !, is unknown
                                    +asCode('sql').
                                        # select jsonb_path_query('[-1,1,"a"]', '$[*] ? ((@ > 0) is unknown)');
                                         jsonb_path_query 
                                        ------------------
                                         "a"
                                        (1 row)
                                li 패턴 매칭
                                    ul
                                        li 정규표현식 : string_value like_regex pattern_string [flag flag_string]
                                        li 접두 문자열 검사 : string_value starts with prefix_string
                                        li jsonpath 검사 : exists(path_expression)
                        li 필터는 조건을 만족하는 항목들을 반환하며, 일반 표현식으로 연결될 수 있다
                            +asCode('sql').
                                # select jsonb_path_query('[
                                #   { "ISBN": "ISBN1", "title": "title1", "authors": ["author1", "author2"], "publishAt": "2000-01-01T00:00:00Z"},
                                #   { "ISBN": "ISBN2", "title": "title2", "authors": ["author3"], "publishAt": "2010-01-01T00:00:00Z"},
                                #   { "ISBN": "ISBN3", "title": "title1", "authors": ["author2"], "publishAt": "2020-01-01T00:00:00Z"}
                                # ]', '$[*] ? (@.publishAt.timestamp_tz() > "2009-12-31 18:00:00+09".timestamp_tz()) ? (exists(@.authors[*] ? (@ == "author3"))).ISBN');
                                 jsonb_path_query 
                                ------------------
                                 "ISBN2"
                                (1 row)
                        li PostgreSQL은 필터에서만 predicate을 이용할 수 있는 SQL/JSON과 다르게, path 자체에서도 허용한다. 이 경우 path 매칭 결과는 단일 boolean 값이다
                            +asCode('sql').
                                # select jsonb_path_query('[1,2,3]', '$[*] > 2'), jsonb_path_query('[1,2,3]', '$[*] > 4'), jsonb_path_query('{}', '$[*] > 2');
                                 jsonb_path_query | jsonb_path_query | jsonb_path_query 
                                ------------------+------------------+------------------
                                 true             | false            | null
                                (1 row)

            h3 배열
            ul
                li create table에서 지정한 배열의 길이, 차원 수는 현재 구현에서 무시된다
                li 배열 입력 : '{ val1 delimiter val2 delimiter ... }'
                    ul
                        li delimiter : box 형식에는 ';', 그 외 형식에는 ',' 사용
                        li 개별 값은 ""로 감쌀 수 있다
                li 배열 첨자는 1부터 시작
                    p 실제 배열 크기를 벗어나는 경우, 오류 대신 null 반환
                li [lower-bound:upper-bound]의 범위 접근(slice)도 가능하다
                    ul
                        li 연속되는 첨자 중 하나라도 slice면, 모든 첨자를 slice로 취급한다
                        li lower-bound, upper-bound는 생략 가능
                li 첨자가 1부터 시작하지 않는 배열도 허용된다
                    +asCode('sql').
                        # create temp table test (x) as (values ('{}'::int[]), ('{1,2}'::int[]), ('[-3:-2]={1,2}'::int[]) );
                        SELECT 3

                        # update test set x[3:4] = '{3,4}'::int[] returning *, x[-3:4];
                                          x                   |               x               
                        --------------------------------------+-------------------------------
                         [3:4]={3,4}                          | {3,4}
                         {1,2,3,4}                            | {1,2,3,4}
                         [-3:4]={1,2,NULL,NULL,NULL,NULL,3,4} | {1,2,NULL,NULL,NULL,NULL,3,4}
                        (3 rows)

                        UPDATE 3
                li 배열 연결
                    +pos('배열 연결')
                    ul
                        li N차원 배열에 N-1차원 요소를 연결하는 경우, N차원 배열의 lower bound는 유지된다
                        li N차원 배열 2개를 연결하는 경우, 왼쪽 배열의 lower bound가 유지된다
                    +asCode('sql').
                        # select 1 || '[0:1]={2,3}'::int[] || 4;
                            ?column?     
                        -----------------
                         [0:3]={1,2,3,4}
                        (1 row)

                        # select '[3:4]={3,4}'::int[] || '[0:1]={0,1}'::int[];
                            ?column?     
                        -----------------
                         [3:6]={3,4,0,1}
                        (1 row)
                    p 미묘한 차이점
                    +asCode('sql').
                        # select array_cat('[2:3]={1,2}'::int[], null);
                          array_cat  
                        -------------
                         [2:3]={1,2}
                        (1 row)

                        # select array_append('[2:3]={1,2}'::int[], null);
                           array_append   
                        ------------------
                         [2:4]={1,2,NULL}
                        (1 row)

                        # select '[2:3]={1,2}'::int[] || null;
                          ?column?   
                        -------------
                         [2:3]={1,2}
                        (1 row)

                        # select '[2:3]={1,2}'::int[] || null::int;
                             ?column?     
                        ------------------
                         [2:4]={1,2,NULL}
                        (1 row)

            h3 복합 타입
            ul
                li 기존 타입들을 결합하여 새로운 타입을 만들 수 있다. not null 같은 제약조건을 포함할 수 없다
                    +asCode('sql').
                        # create type complex as ( r float, i float );
                        CREATE TYPE

                        # select (row(1, null)::complex).*;
                         r |   i    
                        ---+--------
                         1 | (null)
                        (1 row)
                li 테이블을 만들면 기본적으로 동일 이름의 복합 타입이 만들어진다. not null 같은 제약조건은 무시된다
                    +asCode('sql').
                        # \pset null '(null)'
                        # create table test ( a int primary key, b boolean not null );
                        CREATE TABLE
                        
                        # select (row(null, null)::test).*;
                           a    |   b    
                        --------+--------
                         (null) | (null)
                        (1 row)

                        # insert into test values (1, false);
                        INSERT 0 1

                        # select test from test;
                         test  
                        -------
                         (1,f)
                        (1 row)
                li 복합 타입 참조는 테이블 참조와의 모호함을 피하기 위해 항상 ()를 사용하는 것이 좋다
                    p 행 수정 시 set 뒤의 열 이름에서는 불필요하다(넣을 수도 없다)
                li 비용이 비싼 함수는 쿼리 당 1번만 호출하도록 해야 한다
                    +asCode('sql').
                        # \pset null '(null)'
                        # create table test ( a int primary key, b boolean not null );
                        CREATE TABLE

                        # insert into test values (1, false);
                        INSERT 0 1

                        # create or replace function func(t test) returns test as $$
                        # begin
                        #     raise notice using message = 'func called';
                        #     t.a = t.a + 1;
                        #     t.b = not(t.b);
                        #     return t;
                        # end;
                        # $$ language plpgsql;
                        CREATE FUNCTION

                        # select (func(test)).* from test;
                        -- 또는 select (func(test.*)).* from test;
                        -- 또는 select (test.func).* from test;
                        NOTICE:  func called
                        NOTICE:  func called
                         a | b 
                        ---+---
                         2 | t
                        (1 row)

                        # select (x).* from test, lateral func(test) as x;
                        NOTICE:  func called
                         a | b 
                        ---+---
                         2 | t
                        (1 row)

            h3 범위 타입
            ul
                li 모든 범위 타입은 대응하는 다중 범위 타입이 있다 : 연속하지 않는 범위 목록
                li integer에 대한 범위 : int4range, int4multirange
                li bigint에 대한 범위 : int8range, int8multirange
                li numeric에 대한 범위 : numrange, nummultirange
                li timestamp에 대한 범위 : tsrange, tsmultirange
                li timestamptz에 대한 범위 : tstzrange, tstzmultirange
                li date에 대한 범위 : daterange, datemultirange
                li 상/하한을 명시하지 않으면 +/-무한대를 의미한다
                li 아무것도 포함하지 않는 빈 범위 예. 'empty'::int4range
            +asCode('sql').
                # select '[1, 4)'::int4range @> 1, '[1, 4)'::int4range @> 4;
                 ?column? | ?column? 
                ----------+----------
                 t        | f
                (1 row)
            +asCode('sql', '범위에 대한 제약 조건').
                CREATE TABLE reservation (
                    during tsrange,
                    EXCLUDE USING GIST (during WITH &&)
                );

                CREATE EXTENSION btree_gist;
                CREATE TABLE room_reservation (
                    room text,
                    during tsrange,
                    EXCLUDE USING GIST (room WITH =, during WITH &&)
                );

            h3 도메인 타입
            p 다른 기본 타입에 대한 부분 집합으로 정의하는 사용자 정의 형식
            +asCode('sql') CREATE DOMAIN posint AS integer CHECK (VALUE > 0);

            h3 의사 타입
            p 열 타입으로 사용할 순 없지만 함수 인자 또는 반환 타입으로 사용 가능
            ul
                li any : 임의 유형
                li anyarray : 임의 배열
                li record : 임의 행
                li trigger : 트리거 함수의 반환 타입
                li void : 반환 없음
                li unknown : 타입이 정해지지 않은 리터럴
                li 등등

        h2 함수와 연산자
        div
            h3 논리 연산자
            +asCode('sql').
                # with tmp1 (x) as ( values (true), (false), (null) ),
                # tmp2 as ( select t1.x, t2.x y from tmp1 t1, tmp1 t2 )
                # select x, y, x and y as "x and y", x or y as "x or y", not x as "not x"
                # from tmp2 order by x desc nulls last, y desc nulls last;
                   x    |   y    | x and y | x or y | not x  
                --------+--------+---------+--------+--------
                 t      | t      | t       | t      | f
                 t      | f      | f       | t      | f
                 t      | (null) | (null)  | t      | f
                 f      | t      | f       | t      | t
                 f      | f      | f       | f      | t
                 f      | (null) | f       | (null) | t
                 (null) | t      | (null)  | t      | (null)
                 (null) | f      | f       | (null) | (null)
                 (null) | (null) | (null)  | (null) | (null)
                (9 rows)

            h3 비교 함수 및 연산자
            ul
                li null을 비교 가능한 값으로 취급하지 않는 경우, 비교 연산자는 두 피연산자 중 하나라도 null이면 null을 반환
                li &lt;&gt;는 같지 않음을 비교하는 SQL 표준 표기로, !=는 구문 분석 단계에서 &lt;&gt;로 변환된다
                li 비교 술어
                    ul
                        li a between b and c : a &gt;= b and a &lt; c와 동일하다
                        li a not between b and c
                        li a between symmetric b and c : a가 b와 c 사이의 중간값인지? b와 c의 대소 관계는 결과와 무관하다
                        li a not between symmetric b and c
                        li a is distinct from b : a와 b가 같은지? null도 비교 가능한 값으로 처리
                        li a is not distinct from b
                        li a is [not] null
                        li boolean is [not] true, is [not] false, is [not] unknown

            h3 수학 함수 및 연산자
            ul
                li a / b, div(a, b) : 정수에 대한 나눗셈 결과는 0에 가깝게 소수점이 버려진다
                li a % b, mod(a, b) : 정수 modulo 연산
                li a ^ b, power(a, b) : a의 b 제곱
                li |/a, sqrt(a) : 제곱근
                li ||/a, cbrt(a) : 세제곱근
                li @a, abs(a) : 절댓값
                li a &amp; b : 비트 and
                li a | b : 비트 or
                li a # b : 비트 xor
                li ~a : 비트 not
                li a &lt;&lt; b : 비트 shift left
                li a &gt;&gt; b : 비트 shift right
                li ceil(a) : a 이상의 최소 정수
                li gcd(a, b) : 최대공약수
                li 등등

            h3 문자열 함수 및 연산자
            ul
                li a || b : 문자열 연결
                li concat(val1[, val2 ...]) : null을 제외한 모든 인자의 텍스트 표현 연결
                li concat_ws(seperator, val1[, val2 ...]) : with seperator
                li a ^@ b, starts_with(a, b) : a는 b로 시작하는지?
                li a like pattern : 전체 a가 pattern과 일치하는지? 패턴에 %(임의 길이 문자열), _(임의 1개 문자) 사용 가능
                    ul
                        li a ~~ b, a like b
                        li a !~~ b, a not like b
                        li a ~~* b, a ilike b
                        li a !~~* b, a not ilike b
                li regexp_like(a, pattern[, flags]) : POSIX 패턴이 매칭되는지?
                    ul
                        li a ~ b, regexp_like(a, b)
                        li a ~* b, regexp_like(a, b, 'i')
                        li a !~ b, not(regexp_like(a, b))
                        li a !~* b, not(regexp_like(a, b, 'i'))
                li regexp_match, regexp_matches(a, pattern[, flags]) : 패턴 매칭 결과 반환
                li trim([leading | trailing | both] [characters] from string) : 공백(또는 지정 characters) 제거
                li string is [not] [NFC | NFD | NFKC | NFKD] normalized : UTF-8 유니코드 정규화 테스트
                li substring(string [from start] [for count]) : [시작 위치]와 [문자 개수]로 부분 문자열 추출
                li left(string, n), right(string, n) : n에 음수 사용 가능
                li substring(string from pattern) : POSIX 정규표현식에 일치하는 첫 번째 문자열 반환
                li 등등

            h3 날짜/시간 함수 및 연산자
            ul
                li +, * 연산자는 교환 법칙이 성립한다
                    ul
                        li date + integer → date
                        li date - date → integer
                        li date + interval → timestamp
                        li date + time → timestamp
                        li interval + interval → interval
                        li timestamp + interval → timestamp
                        li timestamp - timestamp → interval
                        li time + interval → time
                        li time - time → interval
                        li -interval → interval
                        li interval * double precision → interval
                li isfinite( date | timestamp | interval )
                li make_date / interval / time / timestamp / timestamptz
                li to_timestamp(double) : 초 단위 Unix 타임스탬프를 timestamptz로 변환
                li 일광 절약 시간제가 적용되는 시간대에 대해 '1 day'::interval, '24 hour'::interval을 더하고 뺀 결과는 다를 수 있다
                li extract(field from source)
                    ul
                        li day : day of the month (1~31)
                        li dow : day of the week 일요일(0) ~ 토요일(6)
                        li isodow : 월요일(1) ~ 일요일(7)
                        li doy : day of the year (1~366)
                        li epoch : 초 단위 Unix timestamp
                        li timezone : 초 단위 offset
                        li 등등
                li date_trunc(field, source[, timezone]) : 지정한 정밀도 미만의 값 버림
                li at time zone
                    ul
                        li timestamp at time zone x → timestamptz : 벽시계 값에 시간대 부여
                        li timestamptz at time zone x → timestamp : 동일한 시각을 지정한 시간대에서 볼 때 읽히는 벽시계 값 반환
                li 현재 날짜/시간
                    ul
                        li 현재 트랜잭션 시작 시각 : current_date / time / time(precision) / timestamp /timestamp(precision)
                        li current_timestamp = transaction_timestamp() = now()
                        li statement_timestamp() : 명령 수신 시각
                        li clock_timestamp() : 현재 시각

            h3 enum 함수
            ul
                li enum_range(x) : 정의된 순서대로 값 배열 반환
                li enum_range(x, y) : 정의된 순서대로, x ~ y 사이 값 배열 반환. x/y에 null을 설정하면 lower/upper bound 없는 걸로 간주

            h3 기하 함수 및 연산자
            p 평행 이동, 충돌 감지, 특성값 추출 등

            h3 네트워크 주소 함수 및 연산자
            p 서브넷 마스크 평가 등

            h3 텍스트 검색 함수 및 연산자
            ul
                li tsvector @@ tsquery, tsquery @@ tsvector : 벡터가 쿼리에 매칭되는지?
                li text @@ tsquery : to_tsvector(text)가 쿼리에 매칭되는지?
                li ts_rank, ts_rank_cd(vector, query) : 벡터가 쿼리에 얼마나 매칭되는지?
                li tsvector || tsvector : 벡터 결합
                li tsquery &amp;&amp; tsquery : 쿼리 and
                li tsquery || tsquery : 쿼리 or
                li !!tsquery : 쿼리 not
                li tsquery &lt;-&gt; tsquery, tsquery_phrase(query1, query2) : query1 바로 뒤에 query2가 이어지는 쿼리 반환
                li tsquery_phrase(query1, query2, distance) : query1과 query2 거리가 distance인 쿼리 반환
                li tsquery @&gt; tsquery : 후자의 모든 어휘소가 전자에 존재하는지?
                li tsquery &lt;@ tsquery : 전자의 모든 어휘소가 후자에 존재하는지?
                li array_to_tsvector(text[]) : 입력 문자열을 별도 처리 없이 그대로 어휘소로 사용
                li to_tsquery([ config regconfig, ] query text) : 입력 문자열을 정규화하여 tsquery로 변환
                li to_tsvector([ config regconfig, ] document text) : 입력 문자열을 정규화하고 위치 정보를 포함한 tsvector로 변환
                li tsvector_to_array(tsvector) → text[] : 어휘소 배열 반환
                li unnest(tsvector) → setof record( lexeme text, positions smallint[], weights text )

            h3 JSON 함수 및 연산자
            ul
                li json/jsonb -> integer : 배열 요소 추출. 음수 인덱스 지원
                li json/jsonb ->> integer : text로 추출
                li json/jsonb -> text : 객체 필드 추출
                li json/jsonb ->> text : text로 추출
                li json/jsonb #> text[] : 지정 경로의 값 추출
                li json/jsonb #>> text[] : text로 추출
                li jsonb @> jsonb : 전자가 후자를 모두 포함하는지?
                li jsonb &lt;@ jsonb : 후자가 전자를 모두 포함하는지?
                    ul
                        li 스칼라 : 값이 같은지?
                        li 배열 : 모든 원소를 갖는지?
                        li 객체 : 모든 키-값 쌍을 가지는지?
                li jsonb ? text : 해당 텍스트를 객체의 키 또는 배열 요소로 갖는지?
                li jsonb ?| text[] : 텍스트 배열 중 하나라도 객체의 키 또는 배열 요소로 존재하는지?
                li jsonb ?&amp; text[] : 텍스트 배열의 모든 텍스트가 객체의 키 또는 배열 요소로 존재하는지?
                li jsonb || jsonb : 객체의 경우 Object.assign(전자, 후자). 그 외의 경우 배열 접합으로 처리
                li jsonb - text : 객체의 경우 해당하는 키-값 쌍 삭제. 배열의 경우 일치하는 요소 전부 삭제
                li jsonb - text[] : 배열 각 텍스트에 대해 jsonb - text 수행한 것과 동일
                li jsonb - integer : 배열의 지정 인덱스(음수 가능) 요소 삭제
                li jsonb #- text[] : 지정 경로의 필드 또는 배열 요소 삭제
                li json/jsonb 생성
                    ul
                        li to_json, to_jsonb(any) : 일부 타입에 대해선 에러가 발생하는 형변환과 달리, 타입이 정해진 모든 값에 대해 성공
                        li json_array(any[, ...]) : JSON 배열 생성
                        li json_array(query) : 단일 열을 반환하는 SELECT 쿼리 결과로부터 JSON 배열 생성
                        li json_build_object, jsonb_build_object(key, value[, key, value ...]) : 키-값 쌍으로 객체 생성
                        li json_object(key {value|:} value[, ...]) : 키-값 쌍으로 객체 생성
                            +asCode('sql') select json_object(1 value 2,3:4)
                        li json_object, jsonb_object(text[]) : 키-값 쌍으로 객체 생성
                        li json_object, jsonb_object(keys text[], values text[]) : 키-값 쌍으로 객체 생성
                li json/jsonb 처리
                    ul
                        li json[b]_typeof(json[b]) : JSON 값 유형 반환
                        li jsonb_set(target jsonb, path text[], new_value jsonb[, create_if_missing boolean]) : jsonb 변경
                        li json[b]_to_record(json[b]) as x(col type[, ...]) → record : 객체를 행으로 변환
                        li json[b]_array_elements(json[b]) → setof json[b] : 배열을 행집합으로 확장
                        li json[b]_array_elements_text(json[b]) → setof text : 배열을 text 행집합으로 확장
                        li json[b]_array_length(json) : 배열 길이
                        li json[b]_each(json) → setof record(key text, value json[b]) : 객체를 키-값 행집합으로 확장
                        li json[b]_each_text(json) → setof record(key text, value text) : 객체를 키-값(text) 행집합으로 확장
                        li 등등
                li jsonpath 관련
                    ul
                        li jsonb_path_query(target jsonb, path jsonpath[, vars jsonb]) → setof jsonb : 경로 매칭 결과 행집합으로 반환
                        li jsonb_path_query_array(target jsonb, path jsonpath[, vars jsonb]) → jsonb : 경로 매칭 결과 jsonb 배열로 반환
                        li jsonb_path_query_first(target jsonb, path jsonpath[, vars jsonb]) → jsonb : 첫 번째 경로 매칭 결과 반환
                        li json_query(json[b], jsonpath [passing value as varname [, ...]][ returning data_type ][생략]) : 경로 매칭 결과 jsonb 또는 지정 타입으로 반환
                        li json_value(json[b], jsonpath [passing value as varname [, ...]][ returning data_type ][생략]) : 경로 매칭 결과가 단일 스칼라 값이라면 text 또는 지정 타입으로 반환
                            +asCode('sql').
                                # select jsonb_path_query('[1,2,3,4,5]', '$[*] ? ($min &lt;= @ &amp;&amp; @ &lt;= $max)', '{"min":2, "max":4}');
                                 jsonb_path_query 
                                ------------------
                                 2
                                 3
                                 4
                                (3 rows)

                                # select jsonb_path_query_array('[1,2,3,4,5]', '$[*] ? ($min &lt;= @ &amp;&amp; @ &lt;= $max)', '{"min":2, "max":4}');
                                 jsonb_path_query_array 
                                ------------------------
                                 [2, 3, 4]
                                (1 row)

                                # select jsonb_path_query_first('[1,2,3,4,5]', '$[*] ? ($min &lt;= @ &amp;&amp; @ &lt;= $max)', '{"min":2, "max":4}');
                                 jsonb_path_query_first 
                                ------------------------
                                 2
                                (1 row)

                                # select json_query('[1,2,3,4,5]'::json, '$[*] ? ($min &lt;= @ &amp;&amp; @ &lt;= $max)' passing 2 as min, 4 as max with conditional wrapper);
                                 json_query 
                                ------------
                                 [2, 3, 4]
                                (1 row)

                                # select json_value('[1,2,3,4,5]'::json, '$[2]');
                                 json_value 
                                ------------
                                 3
                                (1 row)
                        li json_exists(json[b], jsonpath [passing value as varname [, ...]]) : 지정 경로에 해당하는 항목이 있는지?
                            +asCode('sql').
                                # select n, json_exists('[1,2,3]'::json, '$[*] ? (@ >= $x)' passing n as x) from generate_series(1, 5) as tmp (n);
                                 n | json_exists 
                                ---+-------------
                                 1 | t
                                 2 | t
                                 3 | t
                                 4 | f
                                 5 | f
                                (5 rows)
                        li jsonb @? jsonpath : 지정 경로에 해당하는 항목이 있는지? SQL/JSON 표준 jsonpath 이용
                        li jsonb @@ jsonpath : 지정 경로에 해당하는 항목이 있는지? PostgreSQL 전용 predicate jsonpath 이용
                            +asCode('sql').
                                # select '[1,2,3]'::jsonb @? '$[*] ? (@ > 0)', '[1,2,3]'::jsonb @? '$[*] ? (@ > 3)';
                                 ?column? | ?column? 
                                ----------+----------
                                 t        | f
                                (1 row)

                                # select '[1,2,3]'::jsonb @@ '$[*] > 0', '[1,2,3]'::jsonb @@ '$[*] > 3';
                                 ?column? | ?column? 
                                ----------+----------
                                 t        | f
                                (1 row)
                        li jsonb_path_exists(target jsonb, path jsonpath[, vars jsonb]) : 지정 경로에 해당하는 항목이 있는지? SQL/JSON 표준 jsonpath 이용
                        li jsonb_path_match(target jsonb, path jsonpath[, vars jsonb]) : 지정 경로에 해당하는 항목이 있는지? PostgreSQL 전용 predicate jsonpath 이용

            h3 시퀀스 함수
            ul
                li nextval(regclass) : 시퀀스를 진행시키고 값을 반환
                li currval(regclass) : 현재 세션에서 nextval을 호출한 적이 있는 경우, 마지막으로 획득한 값 반환
                li lastval() : 현재 세션에서 마지막으로 호출한 nextval 반환값 그대로 반환
                li setval(regclass, bigint) : 시퀀스 현재 값 변경

            h3 조건 표현문
            ul
                li case when condition then result [when ...] [else result] end
                li coalesce(value[, ...]) : null이 아닌 첫 번째 매개변수 반환
                li nullif(value1, value2) : value1 = value2면 null 반환. 아니면 value1 반환
                li greatest(value[, ...]) : 가장 큰 값 반환
                li least(value[, ...]) : 가장 작은 값 반환

            h3 배열 함수 및 연산자
            ul
                li unnest(arr[, arr [...]]) : 배열을 행 집합으로 확장
                li arr @> arr : 후자의 모든 원소가 전자에서도 등장하는지?
                li arr &lt;@ arr
                li arr &amp;&amp; arr : 두 배열 중 공통 원소가 하나라도 존재하는지?
                li #[+goto('배열 연결')] : x || x, array_cat(x, x), array_append(arr, x), array_prepend(x, arr)
                li array_fill(x, lengthArr[, lowerBoundArr]) : 주어진 상수로 채운 배열 생성
                li cardinality(arr) : 전체 요소 개수 반환
                li array_dims(arr) : 배열 차원에 대한 text 표기 반환
                li array_ndims(arr) : 차원 수 반환
                li array_length(arr, dim) : 지정 차원의 길이 반환. 지정 차원에 해당하는 원소가 없으면 null
                li array_lower(arr, dim) : 지정 차원의 lower bound 반환
                li array_upper(arr, dim)
                li array_position(arr, x[, start]) : 1차원 배열에서, 지정 값이 발견되는 최초 subscript 반환(비교는 is not distinct from으로 수행)
                li array_positions(arr, x) : 1차원 배열에서, 지정 값이 발견되는 모든 subscript 배열 반환(비교는 is not distinct from으로 수행)
                li array_remove(arr, x) : 1차원 배열에서, 지정 값 모두 제거(비교는 is not distinct from으로 수행)
                li array_replace(arr, x, y) : n차원 배열에서, 지정 값 모두 교체
                li array_reverse(arr) : 첫 번째 차원을 뒤집은 배열 반환
                li array_sample(arr, n) : 비복원 추출 수행
                li array_shuffle(arr)
                li array_to_string(arr, delimiter[, null_string])

            h3 range/multirange 함수 및 연산자
            ul
                li range @> range, range @> x : 전자가 후자를 포함하는지?
                li range &lt;@ range, x &lt;@ range
                li range &amp;&amp; range : 겹치는 원소가 하나라도 존재하는지?
                li range &lt;&lt; range : 전자가 엄격하게 후자의 왼쪽에 있는지?
                li range >> range
                li range &amp;&lt; range : 전자의 상한이 후자보다 크지 않으면 true
                li range &amp;> range : 전자의 하한이 후자보다 작지 않으면 true
                    +asCode('sql').
                        # select '(1, 10]'::numrange &amp;> '[1, 10]'::numrange;
                         ?column? 
                        ----------
                         t
                        (1 row)

                        # select '[1, 10]'::numrange &amp;> '(1, 10]'::numrange;
                         ?column? 
                        ----------
                         f
                        (1 row)
                li range -|- range : 두 범위가 빈틈없이 이어지는지?
                    +asCode('sql').
                        # select '(3, 10]'::numrange -|- '[1, 3]'::numrange;
                         ?column? 
                        ----------
                         t
                        (1 row)

                        # select '[3, 10]'::numrange -|- '[1, 3]'::numrange;
                         ?column? 
                        ----------
                         f
                li range + range : 범위 합치기. 두 범위 사이에 간격이 있으면 에러 발생
                li range_merge(range, range) : 두 범위를 모두 포함하는 최소 범위 반환
                li range * range : 공통 범위 추출
                li range - range : 전자에서 공통 범위 제거
                li isempty(range) : 빈 범위인지?
                li lower(range) : 하한 반환
                li lower_inc(range) : lower(range)가 범위에 포함되는지?
                    +asCode('sql').
                        # select lower('(1, 3)'::int4range), lower_inc('(1, 3)'::int4range);
                         lower | lower_inc 
                        -------+-----------
                             2 | t
                        (1 row)

                        # select lower('(1, 3)'::numrange), lower_inc('(1, 3)'::numrange);
                         lower | lower_inc 
                        -------+-----------
                             1 | f
                        (1 row)
                li lower_inf(range) : 하한이 무한대인지?
                li unnest(multirange) : range 행집합으로 확산
                li 등

            h3 집계 함수
            ul
                li any_value(x) : non-null인 값 하나
                li max(x) : 최댓값
                li min(x) : 최솟값
                li mode() within group (order by x) : 최빈값
                li avg(x) : 모든 non-null값에 대한 산술 평균
                li percentile_disc(percent or percent_agg) within group (order by x) : 지정 백분율의 자료 검색 -- 없으면 가장 가까운 자료
                li percentile_cont(percent or percent_agg) within group (order by x) : 지정 백분율의 자료 검색 -- 없으면 보간
                    +asCode('sql').
                        # select percentile_disc('{0.3,0.6,0.9}'::float[]) within group (order by n)
                        # from (values (1), (3), (10), (100)) as x(n);
                         percentile_disc 
                        -----------------
                         {3,10,100}
                        (1 row)

                        # select percentile_cont('{0.3,0.6,0.9}'::float[]) within group (order by n)
                        # from (values (1), (3), (10), (100)) as x(n);
                         percentile_cont 
                        -----------------
                         {2.8,8.6,73}
                        (1 row)
                li rank(y) within group (order by x) : y가 x들 중에선 몇 등인지? 동점이 존재하는 경우, 피어 그룹의 첫 번째 행 번호와 같다
                li dense_rank(y) within group (order by x) : y가 x들 중에선 몇 등인지? 피어 그룹 단위로 카운트
                li percent_rank(y) within group (order by x) : (rank() - 1) / (전체 행 개수 - 1)
                li cume_dist(y) within group (order by x) : (y이하 행 개수) / (전체 행 개수)
                    +asCode('sql').
                        # select
                        #   n1,
                        #   rank(n1) within group (order by n2),
                        #   dense_rank(n1) within group (order by n2),
                        #   percent_rank(n1) within group (order by n2),
                        #   cume_dist(n1) within group (order by n2)
                        # from
                        #   (values (0), (10), (20), (30)) as x1(n1),
                        #   (values (10), (20), (10)) as x2(n2)
                        # group by n1;
                         n1 | rank | dense_rank |    percent_rank    | cume_dist 
                        ----+------+------------+--------------------+-----------
                          0 |    1 |          1 |                  0 |      0.25
                         10 |    1 |          1 |                  0 |      0.75
                         20 |    3 |          2 | 0.6666666666666666 |         1
                         30 |    4 |          3 |                  1 |         1
                        (4 rows)
                li corr(y, x) : 상관 계수
                li stddev(x) : 표준 편차
                li variance(x) : 분산

                li count(*) : 행 개수
                li count(x) : non-null인 행 개수

                li bit_and, bit_or, bit_xor(x) : 모든 non-null 값에 대해 한 번씩 비트 연산 수행
                li bool_and(x) : 모든 non-null 값이 true면 true
                li bool_or(x) : non-null 값이 하나라도 true면 true

                li string_agg(x, delimiter) : 문자열 하나로 축약

                li array_agg(x [order by sort_columns]) : 모든 값을 담은 배열
                li json[b]_agg(x [order by sort_columns]) : 모든 값을 담은 JSON[B] 배열
                li json[b]_agg_strict(x [order by sort_columns]) : 모든 non-null 값을 담은 JSON[B] 배열
                li json[b]_object_agg(key, value [order by sort_columns]) : 모든 행을 하나의 JSON[B] 객체로 축약 -- 키는 null 비허용(에러)
                li json[b]_object_agg_strict(key, value [order by sort_columns]) : value가 non-null인 모든 행을 하나의 JSON[B] 객체로 축약 -- 키는 null 비허용(에러)
                li json[b]_object_agg_unique[_strict] : 중복 키 발견 시 에러 발생

                li grouping (group_by_expression) : 복잡한 grouping sets을 이용하는 경우, 어떤 그룹에 대한 집계인지 쉽게 식별 가능하도록 전용 컬럼 추가
                    +asCode('sql').
                        # select grouping(a, b, c), a, b, c
                        # from (values ('a', 'b', 'c')) as x(a, b, c)
                        # group by cube (a, b, c)
                        # order by 1;
                         grouping | a | b | c 
                        ----------+---+---+---
                                0 | a | b | c
                                1 | a | b | 
                                2 | a |   | c
                                3 | a |   | 
                                4 |   | b | c
                                5 |   | b | 
                                6 |   |   | c
                                7 |   |   | 
                        (8 rows)
                li 등

            h3 윈도 함수
            ul
                li row_number() : 행 번호
                li rank() : 순위. 동점이 존재하는 경우, 피어 그룹의 첫 번째 행 번호
                li dense_rank() : 피어 그룹 단위 순위
                li percent_rank() : (rank - 1) / (전체 행 개수 - 1)
                li cume_dist() : (동점 이하의 모든 행 개수) / (전체 행 개수)
                li ntile(n) : 정렬된 파티션을 크기가 균일한 n개 버킷으로 나눌 때, 행이 할당된 버킷 번호
                li lag(value[, offset[, default]]) : offset 전의 행 참조
                li lead(value[, offset[, default]]) : offset 후의 행 참조
                    +asCode('sql').
                        # select n, lag(n, 1, 0) over win, lead(n, 1, 0) over win
                        # from (values (1),(3),(2)) as t(n)
                        # window win as (order by n);
                         n | lag | lead 
                        ---+-----+------
                         1 |   0 |    2
                         2 |   1 |    3
                         3 |   2 |    0
                        (3 rows)
                li first_value(value) : 첫 번째 행 참조
                li last_value(value) : 마지막 행 참조
                li nth_value(value, n) : n번째 행 참조

            h3 merge 지원 함수
            ul
                li merge_action() : merge 명령 returning 절에서 사용하면 'INSERT' | 'UPDATE' | 'DELETE' 설정

            h3 서브쿼리 표현
            ul
                li exists(subquery) : 서브쿼리가 행을 하나라도 발견하는지?
                li expression [not] in (subquery) : expression 평가값이 서브쿼리 결과에 포함 [안] 하는지?
                li expression operator {any | some} (subquery) : 주어진 연산자가 true를 반환하는 행이 하나라도 있는지?
                li expression operator all (subquery) : 주어진 연산자가 모든 행에 대해 true를 반환하는지?
                li row_constructor operator (subquery) : 행이 일치하는지?

            h3 행, 배열을 이용한 비교
            ul
                li expression [not] in (value[, ...]) : expression 평가값이 나열된 값 중에 존재 [안] 하는지?
                li expression operator {any | some} (array) : 주어진 연산자가 true를 반환하는 배열 요소가 하나라도 있는지?
                li expression operator all (array) : 주어진 연산자가 모든 배열 요소에 대해 true를 반환하는지?
                li row_constructor operator row_constructor : 컬럼 순서대로 operator 평가(short-circuit)

            h3 집합 반환 함수
            ul
                li generate_series(start, stop[, step]) → setof (integer | bigint | numeric | timestamp | timestamptz)
                li with ordinality : 행 번호 부여
                    +asCode('sql').
                        # select * from generate_series(
                        #   '2025-11-01 00:00:00 America/Los_Angeles',
                        #   '2025-11-04 00:00:00 America/Los_Angeles',
                        #   '1 day'::interval,
                        #   'America/Los_Angeles'
                        # ) with ordinality as tmp(t, n);
                                   t            | n 
                        ------------------------+---
                         2025-11-01 16:00:00+09 | 1
                         2025-11-02 16:00:00+09 | 2
                         2025-11-03 17:00:00+09 | 3
                         2025-11-04 17:00:00+09 | 4
                        (4 rows)

            h3 시스템 함수
            ul
                li current_query() : 현재 실행 중인 쿼리
                li current_user : 현재 실행 유저
                li pg_backend_pid() : 쿼리 실행 pid
                li has_column_privilege([user, ]table, column, privilege)
                li pg_typeof(x) : 타입 반환
                li to_regclass(text), to_regtype(text) 등 : 테이블 등의 이름을 이용해 관련 OID 반환
                li pg_cancel_backend(pid) : 쿼리 실행 취소
                li pg_terminate_backend(pid) : 쿼리 실행 종료
                li 등

        h2 인덱스
        ul
            li B-tree 인덱스를 정의하면서 고유성을 강제할 수 있다. 예를 들어
                +asCode('sql') create unique index test_lower_col1_idx on test1 (lower(col1))
                |는 col1 값이 대소문자 구별 없이 동일한 행이 2개 이상 존재하는 걸 효율적으로 방지할 수 있다

            li 가능하다면 부분 인덱스 조건은 쿼리 where 조건에서 그대로 등장해야 한다. 그렇지 않으면 인덱스가 사용되지 않을 수 있다
                ul
                    li PostgreSQL에는 서로 다른 형태로 작성된 표현식이 수학적으로 동등한지 인식하는 기능은 없다
                    li 조건식 매칭은 쿼리 실행 시간이 아니라 쿼리 계획 시간에 이루어지기 때문에, x > ? 같은 준비된 쿼리는 실제 매개변수가 2여도 x > 2 조건의 인덱스를 사용하지 않는다

            li 부분 인덱스는 파티셔닝 대용으로 적합하지 않다 : 시스템이 부분 인덱스 간 관계를 따로 이해하고 있지 않으므로, 쿼리에 적용 가능한지 여부를 일일이 검사해야 한다

            li 인덱스 정의에만 존재하는 컬럼을 SELECT하는 경우, 인덱스 정보만으로 결과를 구성하는 index-only scan이 발생할 수 있다.
                p 단, 행이 실제로 유효하다는 것을 확인하기 때문에 행이 빈번히 수정되는 경우엔 표준 인덱스 스캔에 비해 성능 이점이 없다

        h2 전문 검색
        ul
            li 가장 일반적인 전문 검색은 쿼리를 만족하는 자연어 문서를 식별하고, 유사도 순으로 정렬하는 것
            li 쿼리와 유사도 정의는 유연하며, 가장 간단한 검색에서 쿼리는 단어 집합, 유사도는 쿼리 단어의 등장 빈도를 의미한다
            li 각 문서는 사전 처리되어 색인된 상태로 저장되고, 나중에 검색에 이용된다
                ul
                    li 문서를 토큰으로 파싱 : 숫자, 단어, 이메일 등으로 분류
                    li 토큰을 어휘소(lexeme)로 정규화 : 소문자로 통일, 접미사를 제거하고 어간만 남기기, 불용어(stop words, 너무 흔해서 검색에 불필요한 단어) 제거
            li 쉬운 사용자 정의 전문 검색을 위해, PostgreSQL은 다음 데이터베이스 객체들로 검색을 구성할 수 있게 한다
                ul
                    li Text search parser : 문서를 토큰으로 분해하고 분류한다
                    li Text search dictionary : 토큰을 정규화된 형태로 변환하고 불용어를 제거한다
                    li Text search template : 검색 사전의 기본 기능. (사전은 템플릿과 이에 대한 매개변수 집합을 지정한다)
                    li Text search configuration : 검색에 사용할 파서와 사전 집합을 선택한 것
        div
            h3 테이블과 인덱스
            ul
                li
                    +asCode('sql') CREATE INDEX pgweb_idx ON pgweb USING GIN (to_tsvector('english', body));
                    p 이 경우, 인덱스 정의에 매개변수 2개를 받는 함수를 이용했기 때문에, 쿼리가 인덱스를 사용하도록 하려면 역시 2개 매개변수를 이용한 함수가 포함돼야 한다
                li
                    +asCode('sql').
                        ALTER TABLE pgweb ADD COLUMN body_vec tsvector GENERATED ALWAYS AS (to_tsvector('english', body)) STORED;
                        CREATE INDEX pgweb_idx ON pgweb USING GIN (body_vec);
                    p 이 경우, 디스크를 좀 더 차지하지만 매 쿼리마다 인덱스 사용을 위해 검색 구성을 지정할 필요가 없다

            h3 텍스트 검색 제어
            ul
                li 문서 분석
                    p to_tsvector([config,] document) 함수는 내부적으로 파서를 호출하여 문서를 토큰으로 분해하고, 토큰 유형을 할당한다. 개별 토큰들에 대해 일련의 사전들이 검사되는데, 토큰 유형에 따라 어떤 사전들이 이용될 지 달라진다
                    ul
                        li 예. rats는 사전 중 하나가 복수형으로 인식하므로 rat으로 정규화된다
                        li 예. a, on 등은 너무 자주 등장하는 불용어로 등재되었으므로 무시된다
                        li 예. 공백, 마침표는 어떤 사전에도 실려있지 않으므로 무시된다
                    p 구조화된 문서로부터 tsvector를 생성하는 권장 에시 (기본 가중치 레이블은 D)
                    +asCode('sql').
                        setweight(to_tsvector(coalesce(title,'')), 'A')    ||
                        setweight(to_tsvector(coalesce(keyword,'')), 'B')  ||
                        setweight(to_tsvector(coalesce(abstract,'')), 'C') ||
                        setweight(to_tsvector(coalesce(body,'')), 'D')
                li 쿼리 분석
                    ul
                        li to_tsquery([config,] query_text)는 AND, OR, FOLLOWED BY 연산자로 구분되지 않은 토큰에 대해 구문 오류 발생
                            p 함수들 중 가장 큰 유연성 제공 : tsquery 연산자, 가중치 레이블 등 사용 가능
                        li plainto_tsquery([config,] query_text)는 텍스트를 정규화한 뒤 남은 토큰 사이마다 AND 연산자 삽입
                        li phraseto_tsquery([config,] query_text)는 텍스트를 정규화한 뒤 남은 토큰 사이마다 &lt;N&gt; 연산자 삽입
                        li websearch_to_tsquery([config,] query_text)는 웹 검색과 같은 쿼리 생성
                            ul
                                li or : OR 연산자로 변환
                                li - : NOT 연산자로 변환
                                li 일반 텍스트 : plainto_tsquery()로 처리한 것처럼 AND 연산자 삽입
                                li "인용문" : phraseto_tsquery()로 처리한 것처럼 FOLLOWED BY 연산자 삽입
                li 검색 순위
                    ul
                        li ts_rank([weights float4[],] vector tsvector, query tsquery [, normalization integer]) : 일치하는 어휘소(lexeme) 빈도 기준
                        li ts_rank_cd(...) : 어휘소 간 근접성을 추가로 고려. 따라서 어휘소 위치 정보가 없는 입력에 대해 0 반환
                        li weights : {D-weight, C-weight, B-weight, A-weight} 순서대로 지정하고, 기본값은 {0.1, 0.2, 0.4, 1.0}
                        li normalization : 예. 검색어가 5번 포함된 100 / 1000 단어짜리 문서를 얼마나 다르게 취급할지?
                            p 여러 정렬 조건을 사용하려는 경우 2|4처럼 지정
                            ul
                                li 0(기본) : 문서 길이 무시
                                li 1 : rank를 (1 + log(document_length))로 나눔
                                li 2 : rank를 document_length로 나눔
                                li 4 : rank를 범위 간 조화 평균으로 나눔. ts_rank_cd에만 유효
                                li 8 : rank를 문서 내 고유 단어 수로 나눔
                                li 16 : rank를 (1 + log(문서 내 고유 단어 수))로 나눔
                                li 32 : rank를 (1 + rank)로 나눔

            h3 사전
            ul
                li 필터링 사전 : 원래 토큰을 새 토큰으로 교체하여 후속 사전으로 전달
                li 불용어 처리 : 정규화 후 불용어 목록을 확인할 지, 그 반대 순서로 할 지는 사전마다 다름
                li simple 사전 : 토큰을 소문자로 변환한 후 불용어 파일과 비교. 불용어가 아닌 단어는 인식하지 못한 것으로 간주하여 다음 사전으로 전달
                li 동의어 사전 : 예. Paris가 pari로 축소되는 것을 방지하기 위해 동의어 사전에 Paris paris 줄을 추가하고 먼저 토큰 처리
                li 유의어 사전 : 단어만 대체하는 동의어 사전과 다르게 구문 대체 지원. 구문 내에서 불용어는 ?로 지시
                li Ispell 사전 : 어간 추출 지원. 표준 PostgreSQL 배포판에 포함되어 있지는 않음

        h2 동시성 제어
        div
            h3 트랜잭션 격리
            ul
                li 트랜잭션 격리로 배제하려는 현상:
                    ul
                        li dirty read
                            ul
                                li 다른 트랜잭션이 아직 커밋하지 않은 변경사항을 읽는 현상
                        li nonrepeatable read
                            ul
                                li 트랜잭션 시작 후 다른 트랜잭션이 커밋한 변경사항을 읽는 현상
                                li 최초 읽기 후 다음 읽기 사이에 다른 트랜잭션이 변경을 커밋한 경우, 다시 변경된 값을 읽는다
                        li phantom read
                            ul
                                li 트랜잭션 시작 후 다른 트랜잭션이 커밋한 변경사항을 읽는 현상
                                li 최초 읽기 후 다음 읽기 사이에 다른 트랜잭션이 변경을 커밋한 경우, 최초 읽은 값 그대로 보여준다
                        li serialization anomaly
                            ol
                                li let result ::= 트랜잭션 그룹에 대한 최종 실행 성공 상태
                                li let possibleResults ::= 각 트랜잭션을 하나씩 순서대로 실행하는 모든 경우에 대해, 각 실행 성공 상태 리스트
                                li 직렬화 이상 ::= result not in possibleResults
                li 트랜잭션 격리 수준
                    p 트랜잭션 격리 수준을 설정하려면 SET TRANSACTION 명령을 이용한다. PostgreSQL은 MVCC 모델을 이용하기 때문에, Read uncommitted는 Read committed처럼 작동한다
                    +table()
                        tr
                            th 격리 수준
                            th Dirty Read
                            th Nonrepeatable Read
                            th Phantom Read
                            th Serialization Anomaly
                        tr
                            td Read uncommitted
                            td 가능, PG에서는 불가능
                            td 가능
                            td 가능
                            td 가능
                        tr
                            td Read committed
                            td 불가능
                            td 가능
                            td 가능
                            td 가능
                        tr
                            td Repeatable read
                            td 불가능
                            td 불가능
                            td 가능, PG에서는 불가능
                            td 가능
                        tr
                            td Serializable
                            td 불가능
                            td 불가능
                            td 불가능
                            td 불가능
            div
                h4 Read Committed 격리 수준
                ul
                    li PostgreSQL 기본 격리 수준
                    li for update/share 절 없는 select
                        ul
                            li 쿼리 실행 전 마지막으로 커밋된 자료를 읽는다
                    li update, delete, select for update/share
                        ul
                            li 타깃 행을 찾는 것까지는 select 쿼리와 동일하다
                            li 발견한 타깃 행이 변경/삭제/잠금 중인 경우 커밋이나 롤백되기를 기다린다
                                ul
                                    li 롤백된 경우 : 기존 행을 대상으로 쿼리 실행
                                    li 커밋된 경우 : 행이 삭제되지 않았다면 where 절이 재평가되고, 여전히 조건을 충족한다면 갱신된 행을 대상으로 쿼리 실행
                    li insert on conflict do update
                        ul
                            li 다른 트랜잭션이 동일한 고윳값의 행 삽입을 선점한 경우, 커밋이나 롤백되기를 기다린다
                                ul
                                    li 롤백된 경우 : 삽입 실행
                                    li 커밋된 경우 : 업데이트 실행
                    li insert on conflict do nothing
                        ul
                            li 다른 트랜잭션이 동일한 고윳값의 행 삽입을 선점한 경우, 커밋이나 롤백되기를 기다린다
                                ul
                                    li 롤백된 경우 : 삽입 실행
                    li merge
                        ul
                            li insert와 update 모두 사용하는 경우
                                ul
                                    li insert on conflict do update와 유사하게 동시 트랜잭션의 커밋이나 롤백을 대기하지만, insert나 update가 반드시 실행되지는 않는다
                            li update 또는 delete 수행하려는 행을 다른 트랜잭션이 변경을 위해 선점한 경우, 커밋 또는 롤백되기를 기다린다
                                ul
                                    li 롤백된 경우 : 하려던 작업 수행
                                    li 커밋된 경우 : merge 조건 재평가 후 맞는 작업 수행
                            li insert 실행 시 고유성 위반 오류 발생 가능 -- merge 조건 다시 평가 안 함
                    li 발생 가능한 anomaly 예시
                        +asCode('sql').
                            session1=# begin;
                            BEGIN

                            session1=*# update test set num = num + 1;
                            UPDATE 2

                            session2=# select * from test;
                             num 
                            -----
                               1
                               2
                            (2 rows)

                            session2=# delete from test where num = 2;

                            session1=*# commit;
                            COMMIT

                            DELETE 0

                            session2=# select * from test;
                             num 
                            -----
                               2
                               3
                            (2 rows)
                h4 Repeatable Read 격리 수준
                ul
                    li 모든 명령
                        ul
                            li 트랜잭션 실행 시점 -- 정확히는 트랜잭션 내의 첫 번째 비-트랜잭션-제어 명령의 시작 시점의 스냅샷을 참조한다
                            li 따라서 동일한 select는 자체 트랜잭션에서 데이터를 변경하지 않는 한 항상 동일한 데이터를 참조한다
                            li 다른 트랜잭션이 아직 커밋하지 않은 데이터, 트랜잭션 실행 중 다른 트랜잭션이 커밋한 사항은 절대 볼 수 없다
                    li 트랜잭션 시작 후 다른 트랜잭션이 커밋한 행을 변경하거나 잠글 수 없다. 이 경우 직렬화 오류가 발생하므로, 호출자는 적절한 재시도 로직을 갖춰야 한다
                        +asCode() ERROR:  could not serialize access due to concurrent update
                    li update, delete, merge, select for update/share
                        ul
                            li 타깃 행을 찾는 것까지는 select 쿼리와 동일하다
                            li 발견한 타깃 행이 변경/삭제/잠금 중인 경우 커밋이나 롤백되기를 기다린다
                                ul
                                    li 롤백된 경우 : 기존 행에 대해 쿼리 실행
                                    li 커밋된 경우 : 직렬화 에러 발생
                h4 Serializable 격리 수준
                ul
                    li 커밋된 모든 트랜잭션들을 하나씩 순차적으로 실행한다
                    li 이걸로 모든 이상 발생 가능성이 차단되는 것은 아니므로, 여전히 직렬화 실패에 대한 대응이 필요하다
                    li 성능을 위한 유의사항
                        ul
                            li 가능한 경우 READ ONLY 명시
                            li 쿼리가 빈번하게 실행되는 경우, 동시 연결 수 주의
                            li 명시적 잠금 사용 제거 -- 트랜잭션 격리로 인해 자동으로 보장됨
                            li 페이지 수준 predicate 잠금이 여러 개 필요하지만 메모리 부족으로 릴레이션 수준의 잠금이 걸리는 경우, 최대 잠금 수 설정 조정
                            li 순차적 스캔은 릴레이션 수준 잠금이 필요하므로, 되도록 인덱스 스캔을 이용하도록 조정

            h3 명시적 잠금
            div
                h4 테이블 수준 잠금
                ul
                    li PostgreSQL에서 자동으로 사용되는 잠금 모드 목록. 이름에 "ROW"가 있어도 테이블 수준 잠금임
                        ul
                            li ACCESS SHARE (AccessShareLock)
                                ul
                                    li 테이블을 읽기만 하는 select 명령이 획득
                            li ROW SHARE (RowShareLock)
                                ul
                                    li select for update
                                    li select for no key update
                                    li select for share
                                    li select for key share
                            li ROW EXCLUSIVE (RowExclusiveLock)
                                ul
                                    li update
                                    li delete
                                    li insert
                                    li merge
                            li SHARE UPDATE EXCLUSIVE (ShareUpdateExclusiveLock)
                                ul
                                    li 스키마 동시 변경, 동시 vacuum 실행으로부터 테이블 보호
                                    li vacuum (without full)
                                    li analyze
                                    li create index concurrently
                                    li create statistics
                                    li comment on
                                    li reindex concurrently
                                    li 일부 alter index
                                    li 일부 alter table
                            li SHARE (ShareLock)
                                ul
                                    li 동시 데이터 변경으로부터 테이블 보호
                                    li create index (without concurrently)
                            li SHARE ROW EXCLUSIVE (ShareRowExclusiveLock)
                                ul
                                    li 동시 데이터 변경으로부터 테이블 보호
                                    li create trigger
                                    li 일부 alter table
                            li EXCLUSIVE (ExclusiveLock)
                                ul
                                    li refresh materialized view concurrently
                            li ACCESS EXCLUSIVE (AccessExclusiveLock)
                                ul
                                    li 잠금 소유자를 제외한 모든 테이블 접근 차단
                                    li drop table
                                    li truncate
                                    li reindex
                                    li cluster
                                    li vacuum full
                                    li refresh materialized view (without concurrently)
                                    li 일반 alter index
                                    li 일반 alter table
                    li LOCK 명령어로 명시적인 잠금을 획득할 수 있다
                    li 아래 표는 테이블에 이미 특정 수준의 잠금이 존재하는 상태에서, 신규 잠금을 동시에 획득할 수 없는 경우를 보여준다
                        +table().w3-centered
                            tr
                                th(rowspan='2') Requested Lock Mode
                                th(colspan='8') Existing Lock Mode
                            +ths('ACCESS SHARE','ROW SHARE','ROW EXCLUSIVE','SHARE UPDATE EXCLUSIVE','SHARE','SHARE ROW EXCLUSIVE','EXCLUSIVE','ACCESS EXCLUSIVE')
                            +tds('ACCESS SHARE', '', '', '', '', '', '', '', 'X')
                            +tds('ROW SHARE', '', '', '', '', '', '', 'X', 'X')
                            +tds('ROW EXCLUSIVE', '', '', '', '', 'X', 'X', 'X', 'X')
                            +tds('SHARE UPDATE EXCLUSIVE', '', '', '', 'X', 'X', 'X', 'X', 'X')
                            +tds('SHARE', '', '', 'X', 'X', '', 'X', 'X', 'X')
                            +tds('SHARE ROW EXCLUSIVE', '', '', 'X', 'X', 'X', 'X', 'X', 'X')
                            +tds('EXCLUSIVE', '', 'X', 'X', 'X', 'X', 'X', 'X', 'X')
                            +tds('ACCESS EXCLUSIVE', 'X', 'X', 'X', 'X', 'X', 'X', 'X', 'X')

                h4 행 수준 잠금
                ul
                    li 한 트랜잭션 안에서는 동일한 행에 대해 충돌하는 잠금을 동시에 보유할 수 있다. 한 트랜잭션 안의 서로 다른 하위 트랜잭션들 사이에서도 가능하다
                    li PostgreSQL에서 자동으로 사용되는 잠금 모드 목록
                        ul
                            li FOR UPDATE
                                ul
                                    li 행을 수정하기 위해 잠근다
                                    li 다른 트랜잭션이 행을 잠그거나, 수정하거나, 삭제할 수 없다
                                    li select for update
                                    li delete
                                    li 일부 update : 고유 인덱스가 있는 컬럼 수정 시
                            li FOR NO KEY UPDATE
                                ul
                                    li FOR UPDATE보다 좀 더 약하다 : 행의 고유성을 유지하는 변경을 위해 사용
                                    li FOR UPDATE 잠금을 획득하지 않는 모든 update는 이 잠금을 획득
                            li FOR SHARE
                                ul
                                    li 행을 읽기 위해 + 그 동안 행이 변경되지 않도록 잠근다
                            li FOR KEY SHARE
                                ul
                                    li 행을 읽기 위해 + 그 동안 행의 고유성은 변경되지 않도록 잠근다
                    li 아래 표는 행에 이미 특정 수준의 잠금이 존재하는 상태에서, 신규 잠금을 동시에 획득할 수 없는 경우를 보여준다
                        +table().w3-centered
                            tr
                                th(rowspan='2') Requested Lock Mode
                                th(colspan='8') Existing Lock Mode
                            +ths('FOR KEY SHARE', 'FOR SHARE', 'FOR NO KEY UPDATE', 'FOR UPDATE')
                            +tds('FOR KEY SHARE', '', '', '', 'X')
                            +tds('FOR SHARE', '', '', 'X', 'X')
                            +tds('FOR NO KEY UPDATE', '', 'X', 'X', 'X')
                            +tds('FOR UPDATE', 'X', 'X', 'X', 'X')

                h4 Advisory Lock
                ul
                    li 세션 또는 트랜잭션 수준의 잠금을 지원한다. 잠금의 의미는 애플리케이션이 알아서 부여해 사용한다
                        ul
                            li 특정 컬럼을 물리적으로 조작하는 것보다 빠르다
                            li 테이블 크기를 증가시키지 않는다
                            li 세션/트랜잭션 종료 시 자동으로 정리된다
                    li 세션 수준 배타적 잠금 획득 : pg_advisory_lock(key bigint) → void
                        p 필요하다면 획득할 때까지 대기한다
                    li 세션 수준 배타적 잠금 획득 시도 : pg_try_advisory_lock(key bigint) → boolean
                        p 대기하지 않는다
                    li 세션 수준 배타적 잠금 해제 : pg_advisory_unlock(key bigint) → boolean
                        p 잠금을 보유한 세션이 호출한 경우에만 true 반환
                    li 세션 수준 공유 잠금 획득 : pg_advisory_lock_shared(key bigint) → void
                        p 필요하다면 획득할 때까지 대기한다
                    li 세션 수준 공유 잠금 획득 시도 : pg_try_advisory_lock_shared(key bigint) → boolean
                        p 대기하지 않는다
                    li 세션 수준 공유 잠금 해제 : pg_advisory_unlock_shared(key bigint) → boolean
                        p 잠금을 보유한 세션이 호출한 경우에만 true 반환
                    li 모든 세션 수준 잠금 해제 : pg_advisory_unlock_all() → void
                        p 세션 종료 시 자동으로 호출된다
                    li 트랜잭션 수준 배타적 잠금 획득 : pg_advisory_xact_lock(key bigint) → void
                        p 필요하다면 획득할 때까지 대기한다
                    li 트랜잭션 수준 배타적 잠금 획득 시도 : pg_try_advisory_xact_lock(key bigint) → boolean
                        p 대기하지 않는다
                    li 트랜잭션 수준 공유 잠금 획득 : pg_advisory_xact_lock_shared(key bigint) → void
                        p 필요하다면 획득할 때까지 대기한다
                    li 트랜잭션 수준 공유 잠금 획득 시도 : pg_try_advisory_xact_lock_shared(key bigint) → boolean
                        p 대기하지 않는다

        h2 성능 팁
        div
            h3 explain 사용
            ul
                li 쿼리 실행 계획은 트리 구조로 표현된다. 말단 잎은 원시 행을 반환하는 스캔 노드다
                li 비용은 쿼리 계획과 무관한 부분에 대해선 추정하지 않는다
                    ul
                        li 예. select는 쿼리 계획과 무관하게 최종적으로 동일한 행집합을 반환할 것이므로, 결과 크기에 따른 IO 비용에는 무관심
                        li 예. insert/update/delete 등은 쿼리 계획과 무관하게 동일한 행들을 수정할 것이므로, 변경을 위한 IO 비용에는 무관심
                li explain 기본 출력은 각 노드에 대해 텍스트를 한 줄씩 포함한다
                    p 예: (cost=0.29..4143.45 rows=15906 width=475)
                    ul
                        li 0.29 : 예상 초기 비용. 출력 시작하기 전까지 소요된 시간. 예를 들어, 하위 노드의 출력을 정렬하는데 소요된 비용이 추가된다
                        li 4143.45 : 예상 총 비용. 사용 가능한 모든 행이 검색된다는 가정 하에 산출. 실제로는 limit 사용 등으로 더 빨리 중단될 수 있다
                        li rows : 이 노드가 출력할 것으로 예상되는 행 수
                        li width : 이 노드가 출력할 것으로 예상되는 행의 평균 바이트 크기
                li analyze는 무작위 표본을 이용하므로, analyze 실행마다 explain의 추정치가 변경될 수 있다
                li 순차 스캔은 기본적으로 랜덤 스캔보다 
                li limit 사용으로 계획이 달라지는 예시
                    ul
                        li limit 없는 경우
                            p 두 인덱스 각각 조회한 뒤 조합하는 게 효율적이라고 판단
                            +asCode('sql').
                                EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 100 AND unique2 > 9000;

                                                                     QUERY PLAN
                                -------------------------------------------------------------------------------------
                                 Bitmap Heap Scan on tenk1  (cost=25.07..60.11 rows=10 width=244)
                                   Recheck Cond: ((unique1 &lt; 100) AND (unique2 > 9000))
                                   ->  BitmapAnd  (cost=25.07..25.07 rows=10 width=0)
                                         ->  Bitmap Index Scan on tenk1_unique1  (cost=0.00..5.04 rows=100 width=0)
                                               Index Cond: (unique1 &lt; 100)
                                         ->  Bitmap Index Scan on tenk1_unique2  (cost=0.00..19.78 rows=999 width=0)
                                               Index Cond: (unique2 > 9000)
                        li limit 있는 경우
                            p BitmapAnd 연산(비용 25.07) 후 limit 처리하는 것보다는, 인덱스는 하나만 조회하고 나머지 조건은 필터로 이용하는 게 더 저렴하다고 평가 &lt;- 전체 10개 중 2개만 출력할 것이므로 최종 비용은 1/5(=14.28)
                            +asCode('sql').
                                EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 100 AND unique2 > 9000 LIMIT 2;

                                                                     QUERY PLAN
                                -------------------------------------------------------------------------------------
                                 Limit  (cost=0.29..14.28 rows=2 width=244)
                                   ->  Index Scan using tenk1_unique2 on tenk1  (cost=0.29..70.27 rows=10 width=244)
                                         Index Cond: (unique2 > 9000)
                                         Filter: (unique1 &lt; 100)
                li materialize 예시
                    p outer join 처리를 위해 tenk1 각 행에 대해 tenk2를 매번 읽는 대신, 한 번 읽은 tenk2 데이터를 메모리에 저장하고 이후 재사용
                    +asCode('sql').
                        EXPLAIN SELECT *
                        FROM tenk1 t1, tenk2 t2
                        WHERE t1.unique1 &lt; 10 AND t2.unique2 &lt; 10 AND t1.hundred &lt; t2.hundred;

                                                                 QUERY PLAN
                        ---------------------------------------------------------------------------------------------
                         Nested Loop  (cost=4.65..49.36 rows=33 width=488)
                           Join Filter: (t1.hundred &lt; t2.hundred)
                           ->  Bitmap Heap Scan on tenk1 t1  (cost=4.36..39.38 rows=10 width=244)
                                 Recheck Cond: (unique1 &lt; 10)
                                 ->  Bitmap Index Scan on tenk1_unique1  (cost=0.00..4.36 rows=10 width=0)
                                       Index Cond: (unique1 &lt; 10)
                           ->  Materialize  (cost=0.29..8.51 rows=10 width=244)
                                 ->  Index Scan using tenk2_unique2 on tenk2 t2  (cost=0.29..8.46 rows=10 width=244)
                                       Index Cond: (unique2 &lt; 10)

            h3 explain analyze
            ul
                li analyze 옵션을 이용하면 실제로 쿼리를 실행하여 예측치의 정확도를 평가할 수 있다 -- 따라서 실제로 적용되길 원하지 않는 쿼리는 트랜잭션으로 감싸 롤백해야 한다
                li actual time과 cost는 단위가 다르므로 직접 비교하기에 적절하지 않고, 일반적으로는 추정된 행 수가 실제와 얼마나 근접한 지를 확인한다
                li 노드가 여러번 실행되는 경우, loops에 실제 실행 횟수, actual time과 rows에는 평균값이 표시된다
            +asCode('sql').
                EXPLAIN ANALYZE SELECT *
                FROM tenk1 t1, tenk2 t2
                WHERE t1.unique1 &lt; 10 AND t1.unique2 = t2.unique2;

                                                                           QUERY PLAN
                ---------------------------------------------------------------------------------------------------------------------------------
                 Nested Loop  (cost=4.65..118.50 rows=10 width=488) (actual time=0.017..0.051 rows=10.00 loops=1)
                   Buffers: shared hit=36 read=6
                   ->  Bitmap Heap Scan on tenk1 t1  (cost=4.36..39.38 rows=10 width=244) (actual time=0.009..0.017 rows=10.00 loops=1)
                         Recheck Cond: (unique1 &lt; 10)
                         Heap Blocks: exact=10
                         Buffers: shared hit=3 read=5 written=4
                         ->  Bitmap Index Scan on tenk1_unique1  (cost=0.00..4.36 rows=10 width=0) (actual time=0.004..0.004 rows=10.00 loops=1)
                               Index Cond: (unique1 &lt; 10)
                               Index Searches: 1
                               Buffers: shared hit=2
                   ->  Index Scan using tenk2_unique2 on tenk2 t2  (cost=0.29..7.90 rows=1 width=244) (actual time=0.003..0.003 rows=1.00 loops=10)
                         Index Cond: (unique2 = t1.unique2)
                         Index Searches: 10
                         Buffers: shared hit=24 read=6
                 Planning:
                   Buffers: shared hit=15 dirtied=9
                 Planning Time: 0.485 ms
                 Execution Time: 0.073 ms

            h3 쿼리 플래너가 이용하는 통계 정보
            ul
                li pg_class : 테이블과 인덱스의 총 항목 수(reltuples), 디스크 페이지 수(relpages) 등
                li pg_stats : 컬럼 통계. 최빈값, 고윳값 비율(n_distinct), 물리적-논리적 배치 상관도(correlation) 등
                li 쿼리 플래너는 일반적으로 각 컬럼은 독립이라고 가정한다. 다변량 통계를 수행하도록 할 수 있지만, 쿼리 계획이 실제와 크게 동떨어져 잘못된 계획이 실행되는 경우에만 생성함이 바람직하다
                    ul
                        li create statistics stat_name (dependencies) on col1, col2 from table_name : 컬럼 간 상관계수 계산
                        li create statistics stat_name (ndistinct) on col1, col2 from table_name : 다변량 고윳값 개수 계산
                        li create statistics stat_name (mcv) on col1, col2 from table_name : 다변량 최빈값 계산

    h1 서버 관리
    div
        h2 정기적인 데이터베이스 관리 작업
        div
            h3 청소
            ul
                li vacuum은 사용되지 않는 행 버전을 제거하고 해당 공간을 재사용 가능하다고 표시한다. 때문에 테이블이 차지하는 공간은 실행 전후 별 차이가 없다
                li 반면 vacuum full은 적극적으로 용량을 압축하므로 테이블 크기가 최소화되지만, 시간이 오래 걸리고 테이블에 대해 다른 작업이 수행될 수 없다 (AccessExclusiveLock)
                li pg_repack 확장을 이용하면 배타적 잠금을 최소화하면서 bloat을 제거할 수 있다

            h3 재색인
            ul
                li B-트리 인덱스의 페이지가 완전히 빈 경우만 재사용을 위해 회수된다. 대부분의 키가 삭제된 경우 reindex 실행으로 공간 효율성을 높일 수 있다
                li B-트리 인덱스는 새로 구축한 경우, 논리적으로 인접한 페이지가 물리적으로도 인접한 경우가 많으므로 접근 속도도 좀 더 빠르다

        h2 누적 통계 시스템
        ul
            li pg_stat_activity :  서버 프로세스 당 한 줄
            li pg_stat_subscription :  구독 당 한 줄
            li pg_stat_subscription_stats :  구독 당 한 줄
            li pg_stat_replication_slots :  복제 슬롯 당 한 줄
            li pg_stat_progress_analyze :  analyze 실행하는 백엔드 당 한 줄
            li pg_stat_progress_vacuum :  vacuum 실행하는 백엔드 당 한 줄
            li pg_stat_progress_create_index :  인덱스 (재)생성하는 백엔드 당 한 줄
            li pg_stat_database :  데이터베이스 당 한 줄
            li pg_stat_all_tables :  테이블 당 한 줄
            li pg_stat_all_indexes :  인덱스 당 한 줄

        h2 WAL (Write-Ahead Logging)
        ul
            li 데이터 무결성을 보장하는 표준 방법. 데이터 변경은 해당 변경 사항을 담은 WAL 레코드가 영구 저장소에 플러시된 후에만 기록한다
            li 드라이브가 실제 영구 저장소에 쓰지 않고 캐시에만 기록했음에도 OS에 쓰기 성공 시그널을 보내는 경우엔 데이터 손실 가능성이 존재한다
            li 극미량의 데이터 손실이 허용되는 경우, 트랜잭션에서 비동기 커밋을 활성화(synchronous_commit 조정)하여 WAL 레코드를 디스크에 기록하기 전에 성공을 반환할 수 있다

        h2 논리적 복제
        ul
            li 논리적 복제는 복제 식별자(보통 기본키)를 이용해 변경 사항을 전파한다
            li pub/sub (게시/구독) 모델을 사용한다. 구독하는 테이블을 다시 게시할 수도 있다
            li 논리적 복제의 전형적인 절차 : 게시자 테이블의 스냅샷을 구독자 데이터베이스로 복사 -&gt; 스냅샷 이후 변경 사항 지속적으로 적용
        div
            h3 게시
            ul
                li 하나의 게시는 하나의 데이터베이스 안에서 존재한다
                li 게시는 테이블 (그룹)에서 발생한 변경 사항 집합이며, 트리거와 유사한 필터링으로 전파할 변경사항을 조정할 수 있다
                    ul
                        li 어떤 테이블들에 대해 추적할지?
                        li 어떤 작업 -- insert, update, delete, truncate -- 들을 추적할지?
                        li 어떤 행들을 추적할지? 단, truncate는 행 필터가 적용되지 않는다
                            p update 작업에 대해,
                            ul
                                li 이전/신규 버전 행 모두가 필터를 만족하는 경우 : update로 전파
                                li 이전/신규 버전 행 모두가 필터를 만족하지 않는 경우 : 무시
                                li 이전/신규 버전 행 하나만 필터를 만족하는 경우 : insert 또는 delete로 전파
                        li 어떤 컬럼들을 전파할지?
                li 삽입 연산만 전파한다면, 소스 테이블에 고유키가 없어도 된다
                li 스키마 정의 변경은 전파되지 않는다
                li 관련 설정
                    ul
                        li wal_level = logical
                        li max_replication_slots : 최대 동시 활성 구독 수 + 테이블 초기 복제를 위한 여유 개수
                        li max_wal_senders : max_replication_slots + 동시 연결된 물리적 복제본 수

            h3 구독
            ul
                li 하나의 구독은 다른 데이터베이스 내 하나 이상의 게시와 연결된다
                li 각 구독은 하나의 복제 슬롯을 이용해 변경 사항을 수신한다. 단, 초기 테이블 동기화에는 추가(임시) 슬롯이 이용될 수 있다
                li 구독 삭제 후 동일한 정의로 다시 만들어도 동기화 정보는 손실된다
                li 테이블 이름과 열 이름이 일치해야 복제가 수행된다
                li 구독사항에 대해 충돌이 발생하는 경우, 사용자가 수동으로 충돌을 해결해야만 복제가 재개되는 경우가 있다
                    ul
                        li 데이터를 변경하여 수신한 변경사항과 충돌하지 않도록 하거나
                        li 충돌한 트랜잭션을 강제로 건너뛰게 할 수 있다
                li 기본적으로 구독자에서는 트리거와 규칙이 실행되지 않지만, 초기 테이블 동기화는 copy 명령처럼 구현되어 삽입 트리거가 실행된다
                li 관련 설정
                    ul
                        li max_active_replication_origins : 구독 개수 + 테이블 초기 복제를 위한 여유 개수
                        li max_logical_replication_workers : 구독 개수 + 테이블 복제 작업자 수
                        li max_worker_processes : 최소 max_logical_replication_workers + 1
                        li max_sync_workers_per_subscription : 테이블 초기 복사의 병렬 처리량 제어
                        li max_parallel_apply_workers_per_subscription : streaming = parallel을 이용한 구독의 병렬 처리량 제어

            h3: +asA('https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/AuroraPostgreSQL.MajorVersionUpgrade.html', 'AWS Aurora 인스턴스 복제 + 논리적 복제 예')
            ol
                li 테이블 데이터를 처음부터 논리적 복제로 동기화하는 대신, 좀 더 빠른 인스턴스 복제 기능을 이용해 특정 스냅샷부터의 변경사항만 논리적 복제로 동기화
                li 아래의 모든 작업은 슈퍼유저(예. postgres)로 실행한다
                li 블루 환경 &gt; 데이터베이스에 복제 슬롯 생성
                    +asCode('sql').
                        create publication publication_name for all tables;
                        select pg_create_logical_replication_slot('replication_slot_name', 'pgoutput');
                li 그린 환경 &gt; 생성 완료 후 복제 슬롯 상태 기록
                    +asCode('sql').
                        select aurora_volume_logical_start_lsn();
                        aurora_volume_logical_start_lsn 
                        ---------------------------------
                        0/CEDFF50
                        (1 row)
                li 그린 환경 &gt; 복제 슬롯 삭제
                    +asCode('sql') select pg_drop_replication_slot('replication_slot_name');
                li 그린 환경 &gt;  원하는 작업(예. 메이저 버전 업그레이드: 약 15분) 적용
                li 그린 환경 &gt; 구독 생성
                    +asCode('sql').
                        create subscription subscription_name 
                        connection 'postgres://postgres:xxx@dbms-url/db_name' publication publication_name 
                        with (copy_data = false, create_slot = false, enabled = false, connect = true, slot_name = 'replication_slot_name');

                        -- 복제 소스 확인
                        select * from pg_replication_origin;
                         roident |  roname   
                        ---------+-----------
                               1 | pg_274489
                        (1 row)

                        -- 이미 복제한 만큼 구독 조정
                        select pg_replication_origin_advance('pg_274489', '0/CEDFF50');

                        -- 논리적 복제 시작
                        alter subscription subscription_name enable;

                        -- 복제 모니터링
                        select
                          slot_name,
                          active,
                          pg_size_pretty(pg_wal_lsn_diff(pg_current_wal_lsn(), confirmed_flush_lsn)) diff_size
                        from pg_replication_slots;

                        select * from pg_stat_subscription;
                li 그린 환경 &gt; 최신 사항까지 모두 복제 완료된 경우, 시퀀스 조정
                    +asCode('sql') alter sequence seq_name restart with 1234567;
                li 모든 DB 사용 서비스, 그린 환경 이용하도록 재시작
                li 그린 환경 &gt; 서비스 재시작 완료 후, 구독 제거
                    +asCode('sql').
                        alter subscription subscription_name disable;
                        drop subscription subscription_name;
                li 그린 환경 &gt; 읽기 인스턴스 추가
                li 블루 환경 &gt; 사용량 0 확인 후, 최종 제거

    h1 서버 프로그래밍
    div
        h2 SQL 확장하기
        div
            h3 사용자 정의 함수
            ul
                li: +goto('쿼리 언어 함수')
                li: +goto('절차적 언어 함수')
                li: +goto('내부 함수')
                li: +goto('C 언어 함수')
            div
                h4 Function Volatility Category
                ul
                    li 최적의 함수 실행 성능을 위해, 가능한 가장 엄격한 값을 함수 정의 시 지정해야 한다
                    li STABLE, IMMUTABLE의 '불변 보장'은 개발자가 해야 한다. 옵티마이저는 그러한 보장이 있다는 가정 하에 최적화를 진행한다
                    li STABLE, IMMUTABLE 함수 안의 모든 쿼리들은 함수 실행 시점의 MVCC 스냅샷을 본다
                    li VOLATILE : 기본값
                        ul
                            li 데이터베이스를 수정하는 등 무엇이든 가능하다
                            li 동일한 인자로 함수를 호출해도 경우에 따라 다른 결과를 반환할 수 있다
                            li 옵티마이저는 함수 동작에 어떠한 가정도 하지 않는다
                    li STABLE
                        ul
                            li 데이터베이스를 수정할 수 없다
                            li 단일 문장의 모든 행에 대해, 동일한 인자로 호출하는 것은 같은 결과를 반환함을 보장한다
                            li 옵티마이저는 함수 호출 횟수를 최적화할 수 있다
                    li IMMUTABLE
                        ul
                            li 데이터베이스를 수정할 수 없다
                            li 동일한 인자의 호출은 영원히 동일한 결과를 반환함을 보장한다
                            li 옵티마이저는 행을 탐색하는 것보다 먼저 상수 호출을 평가할 수 있다
            
                h4 Parallel Safety Property
                ul
                    li 병렬 쿼리에서의 함수 사용이 예상되는 경우, 병렬 안전성 속성을 설정해야 한다
                    li PARALLEL UNSAFE : 기본값. 병렬 쿼리에서 실행 금지 -&gt; 순차 실행 강제
                    li PARALLEL RESTRICTED : parallel group leader 프로세스에서만 실행 가능
                    li PARALLEL SAFE : parallel group worker 프로세스에서도 실행 가능

            h3 사용자 정의 프로시저
            p 프로시저는 함수와 유사하지만 아래와 같은 차이점이 있다. 차이점들을 제외하면 프로시저 정의는 함수 정의와 동일하다
            ul
                li 프로시저 호출은 값을 반환하지 않는다. 필요한 경우 출력 매개변수를 통해 전달할 수는 있다
                li 프로시저는 call 명령을 이용해 독립적으로 호출된다
                li 명시적인 트랜잭션 블록에서 실행되지 않았다면, 프로시저 실행 도중 커밋이나 롤백할 수 있다 -- 이후 자동으로 새 트랜잭션이 시작된다
                    p 함수는 쿼리 또는 DML 명령의 일부로 호출되므로 그렇게 할 수 없다

            h3 쿼리 언어 함수
            ul
                li SQL 함수는 임의의 SQL 문들을 실행하고, 마지막 쿼리 결과를 반환한다
                    ul
                        li void 반환 함수가 아니라면, 함수의 마지막 문은 행을 반환하는 것만 이용 가능하다
                        li 비-집합을 반환하는 경우, 마지막 쿼리 결과의 첫 번째 행이 반환된다
                        li 마지막 쿼리가 반환하는 행이 없는 경우, null이 반환된다
                    +asCode('sql').
                        # -- void 반환 함수는 null을 반환
                        # create function func() returns void as $$
                        select generate_series(2, 5);
                        $$ language sql;

                        # select func();
                          func  
                        --------
                         (null)
                        (1 row)

                        # -- non-set 반환 함수는 마지막 쿼리 결과의 첫 번째 행을 반환
                        # create function func() returns int as $$
                        select 1;
                        select generate_series(2, 5);
                        $$ language sql;

                        # select func();
                         func 
                        ------
                            2
                        (1 row)

                        # -- 행집합 반환은 setof 표기를 이용해 지정 가능
                        # create function func() returns setof record as $$
                        select *, * from generate_series(2, 5);
                        $$ language sql;

                        # select * from func() as t(num1 int, num2 int);
                         num1 | num2 
                        ------+------
                            2 |    2
                            3 |    3
                            4 |    4
                            5 |    5
                        (4 rows)

                        # -- 행집합 반환은 table 표기를 이용해 지정 가능
                        # create function func() returns table (f1 int, f2 int) as $$
                        select *, * from generate_series(2, 5);
                        $$ language sql;

                        # select (func()).f1;
                         f1 
                        ----
                          2
                          3
                          4
                          5
                        (4 rows)
                        
                        # select * from func();
                         f1 | f2 
                        ----+----
                          2 |  2
                          3 |  3
                          4 |  4
                          5 |  5
                        (4 rows)

                        # -- 마지막 쿼리 결과가 비어있다면 null이 반환된다
                        # create or replace function func() returns int as $$
                        select generate_series(2, 1);
                        $$ language sql;

                        # select func();
                          func  
                        --------
                         (null)
                        (1 row)

                li 함수 인자는 이름이나 숫자 중 아무거나 이용해 참조 가능하다
                    ul
                        li 이름을 이용해 참조하려면 당연히 함수 정의 시 이름을 지정해야 한다
                        li SQL 문에서 열 이름과 충동하는 경우 열 이름이 우선이므로, #[+asInlineCode('funcion_name.argument_name')]과 같이 지정해야 한다
                    +asCode('sql').
                        # create or replace function func(num1 int, int) returns text as $$
                        select num1 || ',' || $1 || ',' || $2
                        $$ language sql;

                        # select func(1, 2);
                         func  
                        -------
                         1,1,2
                        (1 row)

                li 반환 타입을 returns로 지정하는 대신, 매개변수를 out, inout으로 표시할 수 있다. 단, 행집합을 반환하는 경우엔 반환 타입을 명시해야 한다
                    +asCode('sql').
                        # create function func(inout int) as $$
                        select $1 * 2
                        $$ language sql;
                        
                        # select func(2);
                         func 
                        ------
                            4
                        (1 row)

                        # create function func(int, out txt1 text, out text) as $$
                        select $1, $1 * 2
                        $$ language sql;
                        
                        # select * from func(2);
                         txt1 | column2 
                        ------+---------
                         2    | 4
                        (1 row)

                        # create function func(inout int, out int) returns setof record as $$
                        select x, $1 * x from generate_series(1, 3) x
                        $$ language sql;

                        # select * from func(2);
                         column1 | column2 
                        ---------+---------
                               1 |       2
                               2 |       4
                               3 |       6
                        (3 rows)

                li 1개 이상의 동일 타입 인자를 받는 함수를 간편하게 정의할 수 있다
                    +asCode('sql').
                        # create function func(variadic int[]) returns table (min int, max int) as $$
                        select min(num), max(num) from unnest($1) x(num)
                        $$ language sql;
                        
                        # select * from func(1, 3, 2);
                         min | max 
                        -----+-----
                           1 |   3
                        (1 row)

                        # select * from func(array[1, 3, 2]);
                        ERROR:  function func(integer[]) does not exist
                        LINE 1: select * from func(array[1, 3, 2]);
                                              ^
                        HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
                        
                        # select * from func(variadic array[1, 3, 2]);
                         min | max 
                        -----+-----
                           1 |   3
                        (1 row)

                li 매개변수 기본값을 설정할 수 있다
                    +asCode('sql').
                        # create function func(int, int=2, int default 3) returns text as $$
                        select $1 || ',' || $2 || ',' || $3
                        $$ language sql;

                        # select func(1);
                         func  
                        -------
                         1,2,3
                        (1 row)

                li 행집합을 반환하는 함수를 select list에 이용하는 것은, from 절에서 lateral 구문으로 함수를 호출하는 것과 거의 동일하다
                    ul
                        li 함수 호출이 빈 집합을 반환한 경우 결과에서 제외된다
                        li 함수 호출이 둘 이상인 경우, 각 함수의 i번째 결과를 모은 행들이 생성된다
                    +asCode('sql').
                        # create function func(inout int) returns setof int as $$
                        select generate_series(1, $1)
                        $$ language sql;

                        # select n, func(n) from generate_series(0, 2) n;
                         n | func 
                        ---+------
                         1 |    1
                         2 |    1
                         2 |    2
                        (3 rows)

                        # select n, func(n), func(n+1) from generate_series(0, 2) n;
                         n |  func  | func 
                        ---+--------+------
                         0 | (null) |    1
                         1 |      1 |    1
                         1 | (null) |    2
                         2 |      1 |    1
                         2 |      2 |    2
                         2 | (null) |    3
                        (6 rows)

            h3 절차적 언어 함수
            p 절차적 언어는 PostgreSQL 서버에 내장되지 않고, 모듈을 통해 제공되는 언어의 통칭이다

            h3 내부 함수
            p PostgreSQL 서버에 정적으로 링크된 C 언어 함수. 사용자는 이러한 내부 함수에 대한 별칭을 만들 수 있다

            h3 C 언어 함수
            p 사용자 정의 C 함수는 동적으로 로드 가능한 객체로 컴파일되어 서버에서 필요에 따라 로드한다

        h2 트리거
        ul
            li 트리거는 테이블 삽입/갱신/삭제 이벤트 전후에 행당 한 번 또는 쿼리당 한 번 실행하도록 설정할 수 있다
                p 쿼리를 기준으로 실행하는 경우, 해당 쿼리가 실제로는 테이블에 아무 영향을 미치지 않은 경우에도 트리거는 실행됨에 유의해야 한다
            li SQL 함수로는 트리거 함수를 작성할 수 없다
                ul
                    li 문장 수준 트리거는 항상 null을 반환해야 한다
                    li 행 수준 after 트리거의 반환값은 무시된다
                    li 행 수준 before 트리거가 null을 반환하는 경우, 해당 행에 대한 삽입/갱신/삭제 작업을 건너뛴다
                        p 외래키 제약 조건으로 인한 update/delete를 취소하는 경우 참조 무결성이 손상될 수 있음에 유의해야 한다
                    li 행 수준 insert/update 트리거가 반환하는 행이 실제 삽입/갱신에 사용된다
                    li 행에 대한 작업을 변경 없이 그대로 적용하고자 하는 경우
                        ul
                            li before insert 트리거는 NEW를 반환
                            li before update 트리거는 NEW를 반환
                            li before delete 트리거는 OLD를 반환
                    li 행 수준 before 트리거의 NEW 행은 생성된 컬럼이 설정되지 않은 상태임에 유의해야 한다
            li 트리거는 호출 문장과 동일한 트랜잭션의 일부로 실행된다
            li on conflict do update 절이 있는 경우 update 영향과 무관하게 update 트리거가 항상 실행되므로, insert 트리거와 update 트리거를 모두 정의했다면 멱등성에 유의해야 한다
            li 상속 또는 파티셔닝 계층 구조에서 부모 테이블을 대상으로 실행된 쿼리는
                ul
                    li 자식 테이블의 문장 수준 트리거 이벤트를 발생하지 않는다
                    li 자식 테이블의 행 수준 트리거 이벤트는 발생한다
            li update로 행이 파티션1에서 파티션2로 이동하는 경우
                ul
                    li 파티션1의 행 수준 before update 트리거 실행
                    li 파티션1의 행 수준 before delete 트리거 실행
                    li 파티션1의 행 수준 after delete 트리거 실행
                    li 파티션2의 행 수준 before insert 트리거 실행
                    li 파티션2의 행 수준 after insert 트리거 실행
                    li 문장 수준 트리거는 update 트리거만 실행된다
            li merge 실행하는 경우
                ul
                    li merge action이 실제로 실행됐는지와 무관하게, 액션이 나열된 순서대로 해당하는 문장 수준 insert, update, delete 트리거가 모두 실행된다
                    li 행 수준 트리거는 실제 실행된 액션에 해당하는 것만 실행된다
            li 트리거 실행이 before/after 어느 쪽이든 상관없다면, before로 정의하는 것이 작업 정보를 쿼리 끝까지 보관할 필요가 없어지므로 조금 더 효율적이다
        div
            h3 트리거 함수 안에서의 가시성
            ul
                li 문장 수준 트리거의 가시성은 직관과 동일하다. 쿼리의 영향은 after 트리거에서만 보인다
                li 어떠한 쿼리가 여러 행의 before 트리거를 촉발한 경우, 해당 함수의 쿼리들은
                    ul
                        li 이미 처리 완료된 이전 행들에 대해선 새로운 버전을 확인
                        li 아직 처리되지 않은 행들에 대해선 이전 버전을 확인

        h2 이벤트 트리거
        ul
            li 이벤트 트리거는 데이터베이스 전체에 적용되어 DDL 실행도 감지할 수 있다
            li SQL 함수로는 작성할 수 없다
            li 대기 서버에서도 발생하는 이벤트(예. 로그인)의 경우, 쓰기 작업을 하지 않아야 함에 유의해야 한다

        h2 PL/pgSQL
    
    h1 참고자료
    div
        h2 SQL 명령
    
    h1 내부 구조
    div
        h2 시스템 카탈로그
    
    h1 부록
    div
        h2 Date/Time 지원

