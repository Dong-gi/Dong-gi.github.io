include ../../../source/skeleton.pug

+post({
    title: 'Redis',
    description: 'Redis 정리',
})

    h1 참고자료
    ul
        li: +asA('https://redis.io/documentation', '공식 문서')
        li: +asA('http://redisgate.kr/', '레디스 엔터프라이즈 버전')
        li: +asA('https://github.com/redis-essentials/book', 'Redis Essentials')

    h1 Redis
    ul
        li 인메모리 저장소 + 물리 장치 백업 지원
        li 메시지 브로커 기능 보유 : Pub/Sub
        li BSD 라이선스
    div
        h2 redis-server/
            +asA('https://redis.io/topics/rediscli', 'redis-cli')
        ol
            li 서버 실행
            +asCode('shell') $ redis-server --port 27017
            li 서버 접속
            +asCode('shell') $ redis-cli -p 27017
            li help
            +asCode('shell', 'redis-cli').
                > help
                > help @&lt;group>      # Redis 명령어들은 연관성에 따라 그룹에 묶여있다
                > help &lt;command>
            li 여러 키 삭제
            +asCode('shell') $ redis-cli --scan --pattern '*' | xargs redis-cli DEL
            li 키 공간 이벤트 구독 가능
            p 키 공간 이벤트는 기본적으로 발행되지 않으므로, 서버 설정을 변경해야 한다.
                +asA('https://redis.io/docs/manual/keyspace-notifications/', '참고 자료')

        h2 Data type
        ol
            li Binary-safe string : 임의 이진 문자열(최대 512MB)
            li List : 기본적으로 삽입 순으로 유지되는 string 연결 리스트(최대 길이 2^32 - 1)
            p 블로킹 vs 논-블로킹 = 처리(e.g. 삭제) 후 반환 vs 반환 후 처리
            li Set : 순서 없는 string 집합(최대 크기 2^32 - 1)
            li Sorted set : 각 string 원소는 score라 불리는 실수 가중치(정렬키)를 가짐
            p 같은 score 사이에서는 value를 기준으로 정렬된다
            li Hash : field -&gt; value 매핑(최대 크기 2^32 - 1). 각 field, value는 모두 string
            li Bit array : string을 비트열로 다룰 수 있다
            li HyperLogLog : 집합 크기 추정에 이용되는 확률 자료형
            li Stream : append만 가능한 유사 hash
            ul
                li stream entry는 1개 이상의 field-value 쌍으로 구성된다
                li stream entry의 선후 관계는 ID로 구분한다. ID가 이전보다 작으면 추가 실패. ID를 *로 지정하는 경우, 서버에서 자동으로 millisecondsTime-sequenceNumber로 할당
                ul
                    li 현재 시각이 이전 entry의 시각보다 작은 경우, 이전 entry의 시각을 사용하고 sequenceNumber만 증가한다
                    li 123-* 처럼 sequenceNumber만 자동 할당할 수도 있다
                li 3가지 방식으로 entry를 획득할 수 있다
                ul
                    li ID 범위를 이용해 질의 :
                        +goto('XRANGE')
                        +goto('XREVRANGE')
                    li 새로 도착하는 entry 질의 :
                        +goto('XREAD')
                        +goto('XREADGROUP')
                    ul
                        li 블로킹 list 연산과 달리, 새로 도착한 entry는 기본적으로 모든 대기 중인 클라이언트에 전달된다
                        li 발송 후 즉시 삭제하는 Pub/Sub 서비스와 달리, entry는 명시적인 삭제 요청이 없는 한 영구적으로 스트림에 남는다
                        li 소비자 그룹을 이용해 그룹 내 소비자들이 서로 다른 entry를 독립적으로 처리할 수 있다

    h1 Commands
    p 참고 자료 : #[+asA('https://redis.io/commands')]. Redis 명령어들은 연관성에 따라 하나의 그룹에 속해있다
    div
        h2 Generic
        div
            h3 COPY since 6.2.0
            +asCode('text', 'syntax') COPY source destination [DB destination-db-index] [REPLACE]
            ul
                li source 키의 값을 destination 키로 복사
                li 복사됐으면 1, 아니면 0 반환
                li DB : 내부 논리적 DB index
                li REPLACE : 덮어쓰기

            h3 DEL
            +asCode('text', 'syntax') DEL key [key ...]
            p 키를 삭제하고, 삭제된 개수 반환

            h3 DUMP
            +asCode('text', 'syntax') DUMP key
            ul
                li 값을 Redis 포맷(내부 RDB 버전에 따라 인코딩 방식 결정됨)으로 직렬화하여 반환
                p expire time은 포함되지 않음
                li
                    +goto('RESTORE')
                    |로 역직렬화 가능
                +asCode('shell', 'redis-cli').
                    127.0.0.1:6379> set key1 'Hello World!'
                    OK
                    127.0.0.1:6379> dump key1
                    "\x00\x0cHello World!\t\x00\xda\xe7D\xea/\xa2\xe6\xc7"
                    127.0.0.1:6379> restore key2 0 "\x00\x0cHello World!\t\x00\xda\xe7D\xea/\xa2\xe6\xc7"
                    OK
                    127.0.0.1:6379> get key2
                    "Hello World!"

            h3 EXISTS
            +asCode('text', 'syntax') EXISTS key [key ...]
            p 존재하는 키의 개수 반환. 중복된 키는 중복 카운트 됨에 유의

            h3 EXPIRE
            +asCode('text', 'syntax') EXPIRE key seconds [NX|XX|GT|LT]
            ul
                li 지정 시간(초) 후 키 삭제
                li 설정됐으면 1, 아니면 0반환
                li 값을 덮어쓰지 않는 명령(INCR, LPUSH, HSET)과 RENAME은 ttl 정보에 영향을 미치지 않음에 유의
                li NX : No expiry; 키에 ttl이 설정되지 않은 경우에만 설정
                li XX : Exists expiry; 키에 ttl이 설정된 경우에만 설정
                li GT : Greater than; 기존 ttl보다 큰 경우에만 설정
                li LT : Less than; 기존 ttl보다 작은 경우에만 설정
                li ttl이 없는 경우 GT, LT에서 무한으로 간주

            h3 PEXPIRE
            +asCode('text', 'syntax') PEXPIRE key milliseconds [NX|XX|GT|LT]
            p 밀리초 단위 EXPIRE

            h3 EXPIREAT
            +asCode('text', 'syntax') EXPIREAT key unix-timestamp-seconds [NX|XX|GT|LT]
            ul
                li 지정 시각 이후 키 삭제
                li 설정됐으면 1, 아니면 0반환
                li 값을 덮어쓰지 않는 명령(INCR, LPUSH, HSET)과 RENAME은 ttl 정보에 영향을 미치지 않음에 유의
                li NX : No expiry; 키에 ttl이 설정되지 않은 경우에만 설정
                li XX : Exists expiry; 키에 ttl이 설정된 경우에만 설정
                li GT : Greater than; 기존 ttl보다 큰 경우에만 설정
                li LT : Less than; 기존 ttl보다 작은 경우에만 설정
                li ttl이 없는 경우 GT, LT에서 무한으로 간주

            h3 PEXPIREAT
            +asCode('text', 'syntax') PEXPIREAT key unix-time-milliseconds [NX|XX|GT|LT]
            p 밀리초 단위 EXPIREAT

            h3 EXPIRETIME Since 7.0.0
            +asCode('text', 'syntax') EXPIRETIME key
            ul
                li 키가 만료되는 시각 - Unix timestamp in seconds을 반환한다
                li -1 : ttl 설정 안 된 경우
                li -2 : 키가 존재하지 않는 경우

            h3 PEXPIRETIME Since 7.0.0
            +asCode('text', 'syntax') PEXPIRETIME key
            p 밀리초 단위 EXPIRETIME

            h3 KEYS
            +asCode('text', 'syntax') KEYS pattern
            ul
                li <span class="hover-content" template-id="glob-style-pattern">GLOB style pattern</span>에 일치하는 키 배열 반환
                li KEYS 명령은 사용중인 저장소가 클수록 큰 성능 저하를 발생하므로 각별히 주의

            h3 MIGRATE
            +asCode('text', 'syntax') MIGRATE host port key|"" destination-db timeout-ms [COPY] [REPLACE] [AUTH password] [AUTH2 username password] [KEYS key [key ...]]
            ul
                li 데이터를 다른 서버로 옮긴다. DUMP + DEL + RESTORE의 조합
                li timeout-ms : MIGRATE 명령이 제한시간 안에 수행함을 의미하는 것이 아니라, 어느 단계에서든 해당 지연 시간 이상 블록되는 일이 없음을 보장
                p 시간초과가 발생하더라도 목적지에 복사된 상태일 수 있음에 유의. 반면 그 외의 에러 상황에서는 목적지에 복사되지 않은 상태임을 보장
                li COPY : 원본을 지우지 않는다
                li KEYS : 여러 개를 이동할 때, 앞부분 key를 ""로 하고 사용
                li AUTH, AUTH2 모두 목적지 서버 연결 정보로써, 필요한 것 하나만 사용

            h3 MOVE
            +asCode('text', 'syntax') MOVE key db-index
            ul
                li 키를 다른 DB로 옮긴다. 이미 목적지에 key가 존재하면 옮기지 않는다 -- 이 성질을 이용하여 락을 구현할 수도 있다
                li 옮겼으면 1, 그 외엔 0 반환

            h3 OBJECT
            +asCode('text', 'syntax') OBJECT subcommand arg ... arg
            ul
                li 키에 대한 정보 획득
                li OBJECT ENCODING key : 상세 데이터 타입 반환
                li OBJECT FREQ key : 참조 빈도 반환. 메모리 정책에 따라 추적 여부가 결정됨
                li OBJECT IDLETIME key : 참조하지 않은 시간(초) 반환
                li OBJECT REFCOUNT key : 키가 참조하는 값의 개수 반환

            h3 PERSIST
            +asCode('text', 'syntax') PERSIST key
            ul
                li ttl 삭제
                li 삭제했으면 1, 아니면 0 반환

            h3 RANDOMKEY
            +asCode('text', 'syntax') RANDOMKEY
            p 현재 DB에서 임의 키 반환. 없으면 nil

            h3 RENAME
            +asCode('text', 'syntax') RENAME key newkey
            ul
                li key가 존재하지 않는 경우 에러 반환
                li 기존 newkey는 덮어씌어진다(암시적 DEL 수행)
                li 기존 ttl 정보는 그대로 옮겨진다
                li 클러스터 모드에서, key와 newkey는 같은 해시 슬롯에 존재해야
                li 성공 시 "OK" 반환

            h3 RENAMENX
            +asCode('text', 'syntax') RENAMENX key newkey
            ul
                li newkey가 존재하지 않는 경우만 RENAME
                li 성공했으면 1, 아니면 0 반환

            h3 RESTORE
            +asCode('text', 'syntax') RESTORE key ttl-milliseconds serialized-value [REPLACE] [ABSTTL] [IDLETIME seconds] [FREQ frequency]
            ul
                li Redis 포맷 문자열로부터 역직렬화
                li ttl : 0이면 무기한
                li ABSTTL : 설정한 경우, ttl을 Unix timestamp로 해석한다
                li IDLETIME, FREQ : OBJECT 명령과 관계된 초기값 설정

            h3 SCAN
            +asCode('text', 'syntax') SCAN cursor [MATCH pattern] [COUNT count] [TYPE type]
            ul
                li cursor가 가리키는 지점부터 약 count개의 키 중, <span class="hover-content" template-id="glob-style-pattern">GLOB style pattern</span>에 일치하는 목록을 반환한다
                li COUNT : 유저가 원하는 페이지 크기에 대한 힌트로 사용된다(기본값 10) -- 반드시 count 개가 반환되는 것이 아님. 또, 연속 순회 시 count는 자유롭게 변경해도 된다
                li cursor : 0을 지정하여 순회 시작. 응답 첫 번째 원소로 0이 아닌 cursor가 반환되고, 이를 이용해 나머지를 순회할 수 있다
                +asCode('shell', 'redis-cli').
                    127.0.0.1:6379> keys *
                    1) "key2"
                    2) "key"
                    3) "hello"
                    127.0.0.1:6379> scan 0 count 1
                    1) "2"
                    2) 1) "key2"
                       2) "key"
                    127.0.0.1:6379> scan 2 count 1
                    1) "1"
                    2) 1) "hello"
                    127.0.0.1:6379> scan 1 count 1
                    1) "0"
                    2) (empty array)
                li MATCH : 패턴 매칭은 페이지가 구성된 후 클라이언트에 응답하기 직전에 수행되므로, 순회가 종료되지 않더라도 키 목록이 비어있을 수 있다
                li TYPE : 값이 type에 해당하는 키만 검색.
                    +goto('TYPE') 명령이 반환하는 값과 일치해야 한다
                li 서버는 순회와 관련하여 상태를 저장하지 않으므로, 동시 순회 클라이언트 개수에 제한이 없고, 중간에 언제든 순회를 그만둬도 된다
                li 순회의 종료를 판단하는 기준 : 지정 cursor로부터 남은 키의 개수가 count보다 작은가?
                li 일부 복합 타입들은 특정 크기를 초과하지 않는 한 해시 테이블이 아닌 하나의 값으로 저장되므로, count보다 많은 목록이 응답될 수도 있다

            h3 SORT
            +asCode('text', 'syntax') SORT key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern ...]] [ASC|DESC] [ALPHA] [STORE destination]
            ul
                li list, set, sorted set 데이터를 정렬하여 획득 or 저장한다
                li 기본적으로 값의 두배 정밀도 실수 표현을 정렬 키로 한다
                li ALPHA : 문자열 정렬을 수행하고 싶은 경우
                li offset : 0부터 시작
                li BY pattern : 정렬 키 지정
                li GET # : 원소 자체도 반환
                li GET pattern : 조회 키 지정
                +asCode('shell', 'redis-cli').
                    # 학생 이름 5개 저장
                    127.0.0.1:6379> sadd student-name name5 name1 name2 name3 name4
                    (integer) 5

                    # 점수 저장
                    127.0.0.1:6379> mset name5-score 3 name1-score 10 name2-score 0 name3-score 7
                    OK

                    # 각 학생의 점수 획득(이름순)
                    127.0.0.1:6379> sort student-name get *-score alpha
                    1) "10"
                    2) "0"
                    3) "7"
                    4) (nil)
                    5) "3"

                    # 각 학생의 점수 획득(점수순)
                    127.0.0.1:6379> sort student-name by *-score get *-score desc
                    1) "10"
                    2) "7"
                    3) "3"
                    4) (nil)
                    5) "0"

                    # 원소도 같이 반환
                    127.0.0.1:6379> sort student-name by *-score get # get *-score desc
                    1) "name1"
                    2) "10"
                    3) "name3"
                    4) "7"
                    5) "name5"
                    6) "3"
                    7) "name4"
                    8) (nil)
                    9) "name2"
                    10) "0"
                li 해시 필드에 대하여, 아래와 같이 -> 표기를 이용해 BY, GET 옵션을 사용할 수 있다
                +asCode('text', 'e.g.') SORT mylist BY weight_*->fieldname GET object_*->fieldname

            h3 SORT_RO Since 7.0.0
            +asCode('text', 'syntax') SORT_RO key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern ...]] [ASC|DESC] [ALPHA]
            p 읽기 전용 SORT : SORT 명령은 STORE 옵션으로 인해 쓰기 명령으로 분류되고, 이로 인해 읽기 전용 복제본에서 마스터 인스턴스로 명령이 항상 리디렉션되었는데, 이를 방지할 목적으로 추가되었다.

            h3 TOUCH
            +asCode('text', 'syntax') TOUCH key [key ...]
            ul
                li 마지막 접근 시각을 현재로 설정
                li 설정한 개수 반환

            h3 TTL
            +asCode('text', 'syntax') TTL key
            p 남은 유효 시간(초) 반환. 삭제됐으면 -2, ttl 없으면 -1

            h3 PTTL
            +asCode('text', 'syntax') PTTL key
            p 밀리초 단위 TTL

            h3 TYPE
            +asCode('text', 'syntax') TYPE key
            p 데이터 타입 반환; string, list, set, zset, hash, stream, none

            h3 UNLINK
            +asCode('text', 'syntax') UNLINK key [key ...]
            ul
                li 키 공간에서 키를 삭제한 개수를 반환
                li
                    +goto('DEL')
                    |과 다르게 메모리 해제를 별도 스레드에서 진행(논-블로킹)하기 때문에, 지울 개수가 많을수록 UNLINK가 더 빠르다

            h3 WAIT
            +asCode('text', 'syntax') WAIT numreplicas timeout-milliseconds
            ul
                li 이전 모든 write 명령이 numreplicas개의 복제본에 도달하기까지 최대 timeout 밀리초 대기
                li 도달한 복제본 개수 반환
                li timeout == 0이면 무기한 대기 가능

        h2 String
        div
            h3 APPEND
            +asCode('text', 'syntax') APPEND key value
            ul
                li 키가 존재하고 값이 문자열이면 append
                li 키가 존재하고 값이 문자열이 아니면 에러
                li 키가 없으면 set
                li 연산 후의 문자열 길이 반환

            h3 DECR
            +asCode('text', 'syntax') DECR key
            ul
                li 주어진 키의 정수 1 감소 후 반환
                p 키가 없으면 0으로 간주
                li 값이 signed 64bit 범위 밖이면 에러

            h3 DECRBY
            +asCode('text', 'syntax') DECRBY key decrement
            ul
                li 주어진 키의 정수 decrement 감소 후 반환
                p 키가 없으면 0으로 간주
                li 값이 signed 64bit 범위 밖이면 에러

            h3 GET
            +asCode('text', 'syntax') GET key
            ul
                li key가 없으면 nil 반환
                li key의 값이 문자열이면 해당 값 반환
                li 그 외는 에러

            h3 GETDEL
            +asCode('text', 'syntax') GETDEL key
            ul
                li GET 실행 후 DEL(key가 존재하고, 값이 string일 경우) 실행
                li GET 실행 결과 반환

            h3 GETEX
            +asCode('text', 'syntax') GETEX key [EX seconds|PX milliseconds|EXAT unix-time-seconds|PXAT unix-time-milliseconds|PERSIST]
            ul
                li GET 실행 후 ttl 변경. GET 실행 결과 반환
                li EX, PX : ttl(상대 시간)
                li EXAT, PXAT : ttl(절대 시각)
                li PERSIST : ttl 제거

            h3 GETRANGE
            +asCode('text', 'syntax') GETRANGE key start end
            ul
                li key에 대하여, 문자열의 부분 문자열 [start, end] 반환
                li 음수 인덱스 가능. 문자열 길이를 초과하는 구간은 무시

            h3 GETSET; Deprecated since 6.2.0
            +asCode('text', 'syntax') GETSET key value
            ul
                li SET 실행 후, 이전 값 반환
                li Since 6.2.0 : SET 명령의 GET 옵션 사용

            h3 INCR
            +asCode('text', 'syntax') INCR key
            ul
                li 주어진 키의 정수 1 증가 후 반환
                p 키가 없으면 0으로 간주
                li 값이 signed 64bit 범위 밖이면 에러

            h3 INCRBY
            +asCode('text', 'syntax') INCRBY key increment
            ul
                li 주어진 키의 정수 increment 증가 후 반환
                p 키가 없으면 0으로 간주
                li 값이 signed 64bit 범위 밖이면 에러

            h3 INCRBYFLOAT
            +asCode('text', 'syntax') INCRBYFLOAT key increment
            ul
                li 주어진 키의 실수 increment(음수 가능) 증가 후 반환
                p 키가 없으면 0으로 간주
                li 값이 double 범위 밖이면 에러

            h3 LCS Since 6.0.0 or 7.0.0
            +asCode('text', 'syntax').
                # Since 6.0.0
                STRALGO LCS [KEYS ...] [STRINGS ...] [LEN] [IDX] [MINMATCHLEN len] [WITHMATCHLEN]
                # Since 7.0.0
                LCS key1 key2 [LEN] [IDX] [MINMATCHLEN len] [WITHMATCHLEN]
            ul
                li 두 문자열의 LCS(Longest common subsequence)를 구한다
                +asCode('shell', 'redis-cli').
                    127.0.0.1:6379> set key1 humble-bundle
                    OK
                    127.0.0.1:6379> set key2 bundle-humble
                    OK
                    127.0.0.1:6379> stralgo lcs keys key1 key2
                    "ble-ule"
                    127.0.0.1:6379> stralgo lcs strings humble-bundle bundle-humble
                    "ble-ule"
                li LEN : 길이만을 원하는 경우
                li IDX : LCS 각 부분 시퀀스의 [시작, 종료] 위치를 역순으로 반환
                li IDX MINMATCHLEN : LCS 부분 시퀀스 중, 최소 길이를 만족하는 것만 반환
                li IDX WITHMATCHLEN : LCS 각 부분 시퀀스의 길이도 반환
                +asCode('shell', 'redis-cli').
                    127.0.0.1:6379> stralgo lcs strings humble-bundle xbundle-humble idx minmatchlen 2
                    1) "matches"
                    2) 1) 1) 1) (integer) 11
                             2) (integer) 12
                          2) 1) (integer) 12
                             2) (integer) 13
                       2) 1) 1) (integer) 4
                             2) (integer) 6
                          2) 1) (integer) 5
                             2) (integer) 7
                    3) "len"
                    4) (integer) 7

                    // 2) 1) 1) : "humble-bundle"의 "le"
                    // 2) 1) 2) : "xbundle-humble"의 "le"

            h3 MGET
            +asCode('text', 'syntax') MGET key [key ...]
            p 각 키에 대해 get 하여 배열로 반환
            +asCode('shell', 'redis-cli').
                127.0.0.1:27017> mget k1 k2 not_exists_key
                1) "v1"
                2) "v2"
                3) (nil)

            h3 MSET
            +asCode('text', 'syntax') MSET key value [key value ...]
            p 원자적으로 주어진 키-값 쌍들을 모두 설정한다

            h3 MSETNX
            +asCode('text', 'syntax') MSETNX key value [key value ...]
            p 모든 키가 신규인 경우 mset 실행하고 1 반환. 그 외엔 0 반환

            h3 PSETEX
            +asCode('text', 'syntax') PSETEX key milliseconds value
            p 밀리초 단위
                +goto('SETEX')

            h3 SET
            +asCode('text', 'syntax') SET key value [EX seconds|PX milliseconds|EXAT unix-time-seconds|PXAT unix-time-milliseconds|KEEPTTL] [NX|XX] [GET]
            ul
                li 원자적으로 key에 대하여 value를 할당한다. 이전에 설정한 값, 유효 기간을 덮어쓴다
                li EX, PX : ttl(상대 시각)
                li EXAT, PXAT : ttl(절대 시각)
                li NX : 신규 키일 때만 설정
                li XX : 중복 키일 때만 설정
                li KEEPTTL : 이전 ttl 유지
                li GET : 이전 값 반환(없으면 nil)

            h3 SETEX
            +asCode('text', 'syntax') SETEX key seconds value
            p "SET key value EX seconds"와 동일

            h3 SETNX
            +asCode('text', 'syntax') SETNX key value
            ul
                li key가 존재하지 않을 경우에만 value 설정
                li 설정했으면 1, 아니면 0 반환

            h3 SETRANGE
            +asCode('text', 'syntax') SETRANGE key offset value
            ul
                li key에 대하여, offset(0부터 시작) 위치부터 value의 길이만큼 value로 덮어쓴다
                li offset이 기존 문자열을 초과하는 경우 빈 자리는 \x00으로 채워진다
                li key가 존재하지 않는 경우, 값을 빈 문자열로 간주하고 실행한다
                li 설정 후 문자열 길이를 반환한다
                li
                    +goto('GETRANGE')
                    |와 함께 O(1) 접근 가능한 공유 배열로 이용할 수 있다
            +asCode('shell', 'redis-cli').
                127.0.0.1:27017> set msg hello
                OK
                127.0.0.1:27017> setrange msg 8 hello
                (integer) 13
                127.0.0.1:27017> get msg
                "hello\x00\x00\x00hello"

            h3 STRLEN
            +asCode('text', 'syntax') STRLEN key
            ul
                li 문자열 길이 반환
                li key가 존재하지 않으면 0
                li 값이 문자열이 아니면 에러

        h2 Bitmap
        div
            h3 BITCOUNT
            +asCode('text', 'syntax') BITCOUNT key [start end [BYTE|BIT]]
            ul
                li 문자열 내 set bit 개수 반환
                li start, end : 음수를 허용하는 두 인덱스로 표현되는 닫힌 구간 [start, end]으로 탐색 구간 지정 가능
                li BYTE, BIT : 탐색 구간에 사용되는 start, end의 단위 지정

            h3 BITFIELD
            +asCode('text', 'syntax') BITFIELD key [GET encoding offset] [SET encoding offset value] [INCRBY encoding offset increment] [OVERFLOW WRAP|SAT|FAIL]
            ul
                li 문자열을 비트열로 간주하여 GET, SET, INCRBY 연산들을 수행한다
                p GET 서브 명령 실행 시, 문자열을 벗어난 구간의 비트열은 0으로 간주한다
                li encoding : 부호 있는 64비트, 부호 없는 63비트까지 가능
                p e.g. i5(부호 있는 5비트), u4(부호 없는 4비트)
                li offset : 0부터 시작하는 시작 위치. 정수만 이용하는 경우 bit단위, #를 붙이면 encoding 크기 단위
                li OVERFLOW : WRAP(default, 오버/언더플로우 비트 무시), SAT(오버/언더플로우 시 최대/최소값으로), FAIL(실패, nil 반환)
                p OVERFLOW 이후 등장하는 INCRBY 서브 명령에만 영향을 미침에 유의
                li 반환 : SET(이전 값), GET(현재 값), INCRBY(신규 값)
            +asCode('shell', 'redis-cli').
                127.0.0.1:27017> bitfield time SET u6 #0 11 SET u6 #1 33 SET u6 #2 55 GET u6 #0 GET u6 #1 GET u6 #2 INCRBY u6 #0 1 INCRBY u6 #1 1 INCRBY u6 #2 1
                1) (integer) 0
                2) (integer) 0
                3) (integer) 0
                4) (integer) 11
                5) (integer) 33
                6) (integer) 55
                7) (integer) 12
                8) (integer) 34
                9) (integer) 56

            h3 BITFIELD_RO Since 6.2.0
            +asCode('text', 'syntax') BITFIELD_RO key GET encoding offset
            p 읽기 전용 복제본에서 마스터로 명령이 리디렉션되는 것을 방지하기 위한 읽기 전용 BITFIELD

            h3 BITOP
            +asCode('text', 'syntax') BITOP operation destkey key [key ...]
            p 소스 키들의 값에 대한 AND, OR, XOR, NOT 결과를 destkey에 저장한다
            +asCode('shell', 'redis-cli').
                127.0.0.1:6379> set key1 "humble-bundle"
                OK
                127.0.0.1:6379> set key2 "bundle-humble"
                OK
                127.0.0.1:6379> bitop and key3 key1 key2
                (integer) 13
                127.0.0.1:6379> get key3
                "`ul`le-`ul`le"

            h3 BITPOS
            +asCode('text', 'syntax') BITPOS key bit [start [end [BYTE|BIT]]]
            ul
                li bit와 일치하는 인덱스를 닫힌 구간 [start, end] 사이(음수 인덱스 가능)에서 구한다
                li BYTE, BIT : 탐색 구간에 사용되는 start, end의 단위 지정
                li Set bit을 못찾은 경우 -1 반환
                li 구간 지정 없이 Clear bit을 못찾은 경우 비트열 길이 반환
                p 문자열을 초과하는 부분을 0 비트열로 간주하기 때문
                li 구간 지정했지만 Clear bit을 못찾은 경우 -1 반환
            +asCode('shell', 'redis-cli').
                127.0.0.1:6379> set key "\x00\xff"
                OK
                127.0.0.1:6379> bitpos key 0
                (integer) 0
                127.0.0.1:6379> bitpos key 0 1
                (integer) 16
                127.0.0.1:6379> bitpos key 0 1 1
                (integer) -1
                127.0.0.1:6379> bitpos key 1
                (integer) 8
                127.0.0.1:6379> bitpos key 1 1
                (integer) 8

            h3 GETBIT
            +asCode('text', 'syntax') GETBIT key offset
            p offset(0부터 시작)번째 비트 반환. 문자열을 넘어선 구간은 0으로 간주

            h3 SETBIT
            +asCode('text', 'syntax') SETBIT key offset value
            p offset(0부터 시작)번째 비트를 value(0 | 1)로 변경. 이전 비트값 반환

        h2 List
        div
            h3 BLMOVE Since 6.2.0
            +asCode('text', 'syntax') BLMOVE source destination LEFT|RIGHT LEFT|RIGHT timeout-seconds
            ul
                li
                    +goto('LMOVE Since 6.2.0')
                    |의 블로킹 버전
                li source 리스트가 비어있는 경우, 최대 timeout만큼 대기한다
                p timeout == 0이면 무기한 대기 가능

            h3 BLMPOP Since 7.0.0
            +asCode('text', 'syntax') BLMPOP timeout-seconds numkeys key [key ...] LEFT|RIGHT [COUNT count]
            ul
                li
                    +goto('LMPOP Since 7.0.0')
                    |의 블로킹 버전
                li 모든 리스트가 비어있는 경우, 최대 timeout만큼 대기한다
                p timeout == 0이면 무기한 대기 가능

            h3 BLPOP
            +asCode('text', 'syntax') BLPOP key [key ...] timeout-seconds
            ul
                li
                    +goto('LPOP')
                    |의 블로킹 버전
                p 지정한 리스트들을 순회하여, 최초로 비어있지 않은 리스트의 왼쪽 값 삭제 후 반환
                li 모든 리스트가 비어있는 경우, 최대 timeout만큼 대기
                p timeout == 0이면 무기한 대기 가능
                li BLPOP 경합 시 처리 우선순위에 대해서는 공식 문서 참고 :
                    +asA('https://redis.io/commands/blpop/')

            h3 BRPOP
            +asCode('text', 'syntax') BRPOP key [key ...] timeout-seconds
            ul
                li
                    +goto('RPOP')
                    |의 블로킹 버전
                li 기타 설명은
                    +goto('BLPOP')
                    |과 동일

            h3 BRPOPLPUSH; Deprecated since 6.2.0
            +asCode('text', 'syntax') BRPOPLPUSH source destination timeout-seconds
            ul
                li
                    +goto('RPOPLPUSH; Deprecated since 6.2.0')
                    |의 블로킹 버전
                li source 리스트가 비어있는 경우, 최대 timeout만큼 대기한다
                p timeout == 0이면 무기한 대기 가능
                li Since 6.2.0 :
                    +goto('BLMOVE Since 6.2.0')

            h3 LINDEX
            +asCode('text', 'syntax') LINDEX key index
            p index(음수 가능) 번째 값 반환

            h3 LINSERT
            +asCode('text', 'syntax') LINSERT key BEFORE|AFTER pivot element
            ul
                li pivot 전|후에 element를 삽입
                li 삽입 후 리스트 크기 반환. key가 존재하지 않는 경우 0. pivot을 찾지 못한 경우 -1

            h3 LLEN
            +asCode('text', 'syntax') LLEN key
            p 리스트 크기 반환. key가 존재하지 않는 경우 0

            h3 LMOVE Since 6.2.0
            +asCode('text', 'syntax') LMOVE source destination LEFT|RIGHT LEFT|RIGHT
            p 원자적으로 source의 LEFT|RIGHT 원소를 반환한 다음 삭제하고, destination의 LEFT|RIGHT에 추가한다
            +asCode('shell', 'redis-cli').
                127.0.0.1:6379> lpush list1 x1 x2 x3
                (integer) 3
                127.0.0.1:6379> lpush list2 y1 y2 y3
                (integer) 3
                127.0.0.1:6379> lmove list1 list2 left right
                "x3"

            h3 LMPOP Since 7.0.0
            +asCode('text', 'syntax') LMPOP numkeys key [key ...] LEFT|RIGHT [COUNT count]
            p 비어있지 않은 최초 리스트의 왼쪽|오른쪽에서 최대 count개 원소를 반환하고 제거

            h3 LPOP
            +asCode('text', 'syntax') LPOP key [count]
            p 리스트 왼쪽 값 count(기본 1)개 삭제 후 반환

            h3 LPOS Since 6.0.6
            +asCode('text', 'syntax') LPOS key element [RANK rank] [COUNT num-matches] [MAXLEN len]
            ul
                li 리스트에서 element의 위치 반환. 없으면 nil
                li RANK : rank번째(1부터 시작)로 찾은 위치 반환
                p rank로 음수도 가능하며, '-'는 탐색 순서가 반대(tail to head)임을 지시한다
                li COUNT : 최대 num-matches개의 위치 반환
                ul
                    li 탐색 순서를 반대로 하고 싶다면 rank -1 지정
                    li num-matches가 0이면 구간 전체 탐색
                    li 하나도 못 찾은 경우, nil이 아니라 빈 배열 반환
                li MAXLEN : 최대 len개의 원소만 비교

            h3 LPUSH
            +asCode('text', 'syntax') LPUSH key element [element ...]
            p 왼쪽에 값 추가. 이후 리스트 크기 반환

            h3 LPUSHX
            +asCode('text', 'syntax') LPUSHX key element [element ...]
            p 리스트가 존재하면 왼쪽에 값 추가. 이후 리스트 크기 반환

            h3 LRANGE
            +asCode('text', 'syntax') LRANGE key start stop
            p [start, stop] 구간의 값 반환(음수 인덱스 가능)

            h3 LREM
            +asCode('text', 'syntax') LREM key count element
            ul
                li element를 count개 삭제, count == 0이면 전부 삭제, count &lt; 0이면 오른쪽부터 삭제
                li 삭제한 개수 반환

            h3 LSET
            +asCode('text', 'syntax') LSET key index element
            p index(음수 가능) 번째 값을 element로 교체

            h3 LTRIM
            +asCode('text', 'syntax') LTRIM key start stop
            p [start, stop] 구간(음수 인덱스 가능)만 남기고 나머지 삭제

            h3 RPOP
            +asCode('text', 'syntax') RPOP key [count]
            p 리스트 오른쪽 값 count개(기본 1) 삭제 후 반환

            h3 RPOPLPUSH; Deprecated since 6.2.0
            +asCode('text', 'syntax') RPOPLPUSH source destination
            ul
                li 원자적으로 rpop + lpush 실행
                li Since 6.2.0 :
                    +goto('LMOVE Since 6.2.0')

            h3 RPUSH
            +asCode('text', 'syntax') RPUSH key element [element ...]
            p 오른쪽에 값 추가. 이후 리스트 크기 반환

            h3 RPUSHX
            +asCode('text', 'syntax') RPUSHX key element [element ...]
            p 리스트가 존재하면 오른쪽에 값 추가. 이후 리스트 크기 반환

        h2 Set
        div
            h3 SADD
            +asCode('text', 'syntax') SADD key member [member ...]
            p 집합에 원소 추가. 실제 추가된 개수 반환

            h3 SCARD
            +asCode('text', 'syntax') SCARD key
            p 집합 크기 반환

            h3 SDIFF
            +asCode('text', 'syntax') SDIFF key [key ...]
            p 차집합 반환; SDIFF s1 s2 s3 ... == s1 - s2 - s3 - ...

            h3 SDIFFSTORE
            +asCode('text', 'syntax') SDIFFSTORE destination key [key ...]
            p
                +goto('SDIFF')
                |결과 destination에 저장(덮어쓰기)

            h3 SINTER
            +asCode('text', 'syntax') SINTER key [key ...]
            p 교집합 반환

            h3 SINTERCARD Since 7.0.0
            +asCode('text', 'syntax') SINTERCARD numkeys key [key ...] [LIMIT limit]
            p
                +goto('SINTER')
                |의 크기 반환

            h3 SINTERSTORE
            +asCode('text', 'syntax') SINTERSTORE destination key [key ...]
            p
                +goto('SINTER')
                |결과 destination에 저장(덮어쓰기)

            h3 SISMEMBER
            +asCode('text', 'syntax') SISMEMBER key member
            p 집합에 포함되면 1, 아니면 0

            h3 SMEMBERS
            +asCode('text', 'syntax') SMEMBERS key
            p 전체 원소 반환

            h3 SMISMEMBER Since 6.2.0
            +asCode('text', 'syntax') SMISMEMBER key member [member ...]
            p 각 원소에 대하여
                +goto('SISMEMBER')
                |를 실행한 결과 배열 반환

            h3 SMOVE
            +asCode('text', 'syntax') SMOVE source destination member
            p member가 source에 포함된다면 destination으로 이동하고 1 반환. 아니면 0

            h3 SPOP
            +asCode('text', 'syntax') SPOP key [count]
            p 무작위로 count(기본 1)개 삭제 후 반환

            h3 SRANDMEMBER
            +asCode('text', 'syntax') SRANDMEMBER key [count]
            p 무작위로 count(기본 1)개 원소 반환. 음수를 지정한 경우, 중복이 허용된다

            h3 SREM
            +asCode('text', 'syntax') SREM key member [member ...]
            p 집합에서 원소 삭제. 실제 제거된 개수 반환

            h3 SSCAN
            +asCode('text', 'syntax') SSCAN key cursor [MATCH pattern] [COUNT count]
            p 집합에 대한
                +goto('SCAN')

            h3 SUNION
            +asCode('text', 'syntax') SUNION key [key ...]
            p 합집합 반환

            h3 SUNIONSTORE
            +asCode('text', 'syntax') SUNIONSTORE destination key [key ...]
            p
                +goto('SUNION')
                |결과 destination에 저장(덮어쓰기)

        h2 Sorted Set
        div
            h3 BZMPOP Since 7.0.0
            +asCode('text', 'syntax') BZMPOP timeout-seconds numkeys key [key ...] MIN|MAX [COUNT count]
            ul
                li
                    +goto('ZMPOP Since 7.0.0')
                    |의 블로킹 버전
                li 모든 sorted set이 비어있는 경우, 최대 timeout만큼 대기
                p timeout == 0이면 무기한 대기 가능

            h3 BZPOPMAX
            +asCode('text', 'syntax') BZPOPMAX key [key ...] timeout
            ul
                li
                    +goto('ZPOPMAX')
                    |의 블로킹 버전
                li 비어있지 않은 최초의 sorted set에서 가장 높은 score를 가진 원소 반환
                li 모든 sorted set이 비어있는 경우, 최대 timeout만큼 대기
                p timeout == 0이면 무기한 대기 가능
                li 경합 시 처리 우선순위에 대해서는 BLPOP 문서 참고 :
                    +asA('https://redis.io/commands/blpop/')

            h3 BZPOPMIN
            +asCode('text', 'syntax') BZPOPMIN key [key ...] timeout
            ul
                li
                    +goto('ZPOPMIN')
                    |의 블로킹 버전
                li 비어있지 않은 최초의 sorted set에서 가장 낮은 score를 가진 원소 반환
                li 모든 sorted set이 비어있는 경우, 최대 timeout만큼 대기
                p timeout == 0이면 무기한 대기 가능
                li 경합 시 처리 우선순위에 대해서는 BLPOP 문서 참고 :
                    +asA('https://redis.io/commands/blpop/')

            h3 ZADD
            +asCode('text', 'syntax') ZADD key [NX|XX] [GT|LT] [CH] [INCR] score member [score member ...]
            ul
                li 기본 동작 : 원소가 이미 존재하는 경우, 지정된 score로 새로 삽입한다. 새로 추가된 원소의 개수를 반환한다
                p score로 -inf, +inf 가능
                li NX : 원소가 이미 존재하는 경우 스킵
                li XX : 원소가 존재하지 않는 경우 스킵
                li LT : 기존 score &lt;= 새 score인 경우 스킵
                li GT : 기존 score &gt;= 새 score인 경우 스킵
                li CH : score가 갱신된 원소 개수를 포함하여 반환한다
                li INCR : score를 덮어쓰지 않고, 값만큼 증가
                p 갱신된 score를 반환한다. 없으면 nil

            h3 ZCARD
            +asCode('text', 'syntax') ZCARD key
            p 집합 크기 반환

            h3 ZCOUNT
            +asCode('text', 'syntax') ZCOUNT key min max
            p <span class="hover-content" template-id="zset-score-range">score 구간</span>에 포함되는 원소 개수 반환

            h3 ZDIFF Since 6.2.0
            +asCode('text', 'syntax') ZDIFF numkeys key [key ...] [WITHSCORES]
            ul
                li 차집합 반환; ZDIFF 3 s1 s2 s3 == s1 - s2 - s3
                li WITHSCORES : 반환 배열의 각 원소 뒤에 score가 포함된다

            h3 ZDIFFSTORE Since 6.2.0
            +asCode('text', 'syntax') ZDIFFSTORE destination numkeys key [key ...]
            ul
                li
                    +goto('ZDIFF Since 6.2.0')
                    |결과를 destination에 저장한다(덮어쓰기)
                li 결과 집합 크기를 반환한다

            h3 ZINCRBY
            +asCode('text', 'syntax') ZINCRBY key increment member
            ul
                li score를 increment만큼 증가한 뒤 반환
                li 원소가 존재하지 않는 경우, increment를 score로 하여 원소 추가
                li 키가 존재하지 않는 경우, 새 sorted set 생성

            h3 ZINTER Since 6.2.0
            +asCode('text', 'syntax') ZINTER numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX] [WITHSCORES]
            ul
                li 교집합 반환
                li WEIGHTS : 각 집합 score 가중치(기본 1)
                li AGGREGATE : score 집계 함수(기본 SUM)
                li WITHSCORES : 반환 배열의 각 원소 뒤에 score가 포함된다

            h3 ZINTERCARD Since 7.0.0
            +asCode('text', 'syntax') ZINTERCARD numkeys key [key ...] [LIMIT limit]
            ul
                li
                    +goto('ZINTER Since 6.2.0')
                    |결과 집합 크기를 반환한다
                li LIMIT : 결과 집합 크기가 limit(기본 0; 무제한)에 도달하면 더 계산하지 않음

            h3 ZINTERSTORE
            +asCode('text', 'syntax') ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]
            ul
                li
                    +goto('ZINTER Since 6.2.0')
                    |결과를 destination에 저장한다(덮어쓰기)
                li 결과 집합 크기를 반환한다

            h3 ZLEXCOUNT
            +asCode('text', 'syntax') ZLEXCOUNT key min max
            p <span class="hover-content" template-id="zset-lexicographical-range">사전적 구간</span> 안에 있는 원소 개수 반환

            h3 ZMPOP Since 7.0.0
            +asCode('text', 'syntax') ZMPOP numkeys key [key ...] MIN|MAX [COUNT count]
            ul
                li 주어진 key 중 처음으로 비어있지 않은 sorted set으로부터 최대 count(기본 1)개의 원소를 제거하고, score와 함께 반환한다
                li MIN|MAX : score 낮은|높은 순으로 제거

            h3 ZMSCORE Since 6.2.0
            +asCode('text', 'syntax') ZMSCORE key member [member ...]
            p 각 원소에 대해
                +goto('ZSCORE')
                |실행한 결과 배열 반환

            h3 ZPOPMAX
            +asCode('text', 'syntax') ZPOPMAX key [count]
            p score가 큰 원소부터 제거하여 score와 함께 반환

            h3 ZPOPMIN
            +asCode('text', 'syntax') ZPOPMIN key [count]
            p score가 작은 원소부터 제거하여 score와 함께 반환

            h3 ZRANDMEMBER Since 6.2.0
            +asCode('text', 'syntax') ZRANDMEMBER key [count [WITHSCORES]]
            ul
                li 임의 원소 count(기본 1)개 반환
                li count가 음수인 경우, 중복이 허용된다
                li WITHSCORES : score가 함께 반환된다

            h3 ZRANGE
            +asCode('text', 'syntax') ZRANGE key min max [BYSCORE|BYLEX] [REV] [LIMIT offset count] [WITHSCORES]
            ul
                li 지정한 구간에 포함되는 원소를 오름차순으로 반환
                li: b 모든 원소의 score가 동일하지 않으면, BYLEX 결과가 제대로 정렬되지 않음
                +asCode('shell', 'redis-cli').
                    127.0.0.1:6379> zrange ss1 0 -1 withscores
                    1) "m3"
                    2) "1"
                    3) "m6"
                    4) "123"
                    5) "m1"
                    6) "124"
                    127.0.0.1:6379> zrange ss1 - + bylex
                    1) "m3"
                    2) "m6"
                    3) "m1"
                    127.0.0.1:6379> zrange ss1 + - bylex rev
                    1) "m1"
                    2) "m6"
                    3) "m3"
                li (미지정)|BYSCORE|BYLEX : rank(==index, 음수 허용) 구간|<span class="hover-content" template-id="zset-score-range">score 구간</span>|<span class="hover-content" template-id="zset-lexicographical-range">사전적 구간</span>
                li REV : 내림차순 탐색
                p <b>주의</b>. BYSCORE, BYLEX에서는 min, max의 위치가 변경돼야 한다...
                li LIMIT : SQL의 LIMIT limit OFFSET offset과 유사한 옵션. count가 음수인 경우, offset 이후 모든 원소를 반환한다

            h3 ZRANGEBYLEX; Deprecated Since 6.2.0
            +asCode('text', 'syntax') ZRANGEBYLEX key min max [LIMIT offset count]
            p Since 6.2.0 :
                +goto('ZRANGE')
                |with BYLEX

            h3 ZRANGEBYSCORE; Deprecated Since 6.2.0
            +asCode('text', 'syntax') ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]
            p Since 6.2.0 :
                +goto('ZRANGE')
                |with BYSCORE

            h3 ZRANGESTORE Since 6.2.0
            +asCode('text', 'syntax') ZRANGESTORE dst src min max [ BYSCORE | BYLEX] [REV] [LIMIT offset count]
            p
                +goto('ZRANGE')
                |결과를 dst에 저장한다(덮어쓰기)

            h3 ZRANK
            +asCode('text', 'syntax') ZRANK key member
            p 원소의 index(0부터 시작, 오름차순) 반환. 없으면 nil

            h3 ZREM
            +asCode('text', 'syntax') ZREM key member [member ...]
            p 원소 삭제. 삭제된 개수 반환

            h3 ZREMRANGEBYLEX
            +asCode('text', 'syntax') ZREMRANGEBYLEX key min max
            p <span class="hover-content" template-id="zset-lexicographical-range">사전적 구간</span>의 원소 삭제. 삭제된 개수 반

            h3 ZREMRANGEBYRANK
            +asCode('text', 'syntax') ZREMRANGEBYRANK key start stop
            p rank(==index, 음수 허용) 구간의 원소 삭제. 삭제된 개수 반환

            h3 ZREMRANGEBYSCORE
            +asCode('text', 'syntax') ZREMRANGEBYSCORE key min max
            p <span class="hover-content" template-id="zset-score-range">score 구간</span>의 원소 삭제. 삭제된 개수 반

            h3 ZREVRANGE; Deprecated Since 6.2.0
            +asCode('text', 'syntax') ZREVRANGE key start stop [WITHSCORES]
            p Since 6.2.0 :
                +goto('ZRANGE')
                |with REV

            h3 ZREVRANGEBYLEX; Deprecated Since 6.2.0
            +asCode('text', 'syntax') ZREVRANGEBYLEX key max min [LIMIT offset count]
            p Since 6.2.0 :
                +goto('ZRANGE')
                |with BYLEX REV

            h3 ZREVRANGEBYSCORE; Deprecated Since 6.2.0
            +asCode('text', 'syntax') ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]
            p Since 6.2.0 :
                +goto('ZRANGE')
                |with BYSCORE REV

            h3 ZREVRANK
            +asCode('text', 'syntax') ZREVRANK key member
            p 원소의 index(0부터 시작, 내림차순) 반환. 없으면 nil

            h3 ZSCAN
            +asCode('text', 'syntax') ZSCAN key cursor [MATCH pattern] [COUNT count]
            p sorted set에 대한
                +goto('SCAN')

            h3 ZSCORE
            +asCode('text', 'syntax') ZSCORE key member
            p 원소의 score 반환. 없으면 nil

            h3 ZUNION Since 6.2.0
            +asCode('text', 'syntax') ZUNION numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM | MIN | MAX] [WITHSCORES]
            ul
                li 합집합 반환
                li WEIGHTS : 각 집합 score 가중치(기본 1)
                li AGGREGATE : score 집계 함수(기본 SUM)
                li WITHSCORES : 반환 배열의 각 원소 뒤에 score가 포함된다

            h3 ZUNIONSTORE
            +asCode('text', 'syntax') ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]
            ul
                li
                    +goto('ZUNION Since 6.2.0')
                    |결과를 destination에 저장한다(덮어쓰기)
                li 결과 집합 크기를 반환한다

        h2 Hash
        div
            h3 HDEL
            +asCode('text', 'syntax') HDEL key field [field ...]
            p 지정한 field 제거. 제거된 개수 반환

            h3 HEXISTS
            +asCode('text', 'syntax') HEXISTS key field
            p field를 포함하면 1, 그 외엔 0 반환

            h3 HGET
            +asCode('text', 'syntax') HGET key field
            p 지정한 field의 value 반환. 없으면 nil

            h3 HGETALL
            +asCode('text', 'syntax') HGETALL key
            p 전체 field-value 목록 반환

            h3 HINCRBY
            +asCode('text', 'syntax') HINCRBY key field increment
            p value += increment, 값이 없으면 value = increment로 신규 설정. 변경된 value 반환

            h3 HINCRBYFLOAT
            +asCode('text', 'syntax') HINCRBYFLOAT key field increment
            p value += increment, 값이 없으면 value = increment로 신규 설정. 변경된 value 반환

            h3 HKEYS
            +asCode('text', 'syntax') HKEYS key
            p 전체 field 목록 반환

            h3 HLEN
            +asCode('text', 'syntax') HLEN key
            p 전체 field-value 쌍 개수 반환

            h3 HMGET
            +asCode('text', 'syntax') HMGET key field [field ...]
            p 지정 field들에 대해
                +goto('HGET')
                |실행한 결과 배열 반환

            h3 HRANDFIELD Since 6.2.0
            +asCode('text', 'syntax') HRANDFIELD key [count [WITHVALUES]]
            ul
                li 최대 count개의 임의 field 반환
                li count가 음수인 경우, 중복이 허용된다
                li WITHVALUES : value를 함께 반환한다

            h3 HSCAN
            +asCode('text', 'syntax') HSCAN key cursor [MATCH pattern] [COUNT count]
            p hash에 대한
                +goto('SCAN')

            h3 HSET
            +asCode('text', 'syntax') HSET key field value [field value ...]
            p key에 field-value 쌍 추가. 기존 value는 덮어씌어진다. 추가된 쌍의 개수 반환

            h3 HSETNX
            +asCode('text', 'syntax') HSETNX key field value
            p field가 없는 경우에만 field-value 쌍 추가하고 1 반환. 그 외 0 반환

            h3 HSTRLEN
            +asCode('text', 'syntax') HSTRLEN key field
            p value의 바이트 길이 반환

            h3 HVALS
            +asCode('text', 'syntax') HVALS key
            p 전체 value 목록 반환

        h2 Stream
        div
            h3 XACK
            +asCode('text', 'syntax') XACK key group id [id ...]
            p 소비자 그룹에서 특정 entry들을 소비 완료했음을 지시

            h3 XADD
            +asCode('text', 'syntax') XADD key [NOMKSTREAM] [MAXLEN | MINID [=|~] threshold [LIMIT count]] *|id field value [field value ...]
            ul
                li 새 entry 추가. field-value 쌍은 순서를 유지하여 저장되고, 클라이언트에도 동일한 순서로 전달된다
                li 추가된 entry의 id를 반환한다
                li NOMKSTREAM : key에 스트림이 존재하지 않으면 무시
                li 나머지 옵션은
                    +goto('XTRIM')
                    |참고

            h3 XAUTOCLAIM Since 6.2.0
            +asCode('text', 'syntax') XAUTOCLAIM key group consumer min-idle-time start [COUNT count] [JUSTID]
            p 개념적으로 XPENDING 후 XCLAIM을 호출한 것과 동일하다

            h3 XCLAIM
            +asCode('text', 'syntax') XCLAIM key group consumer min-idle-time id [id ...] [IDLE ms] [TIME unix-time-milliseconds] [RETRYCOUNT count] [FORCE] [JUSTID]
            ul
                li 지정한 id들에 대하여, min-idle-time 밀리초 이상 소비 완료 대기 중인 entry를 획득한다
                li IDLE : 대기 시간 재설정. 기본값은 0이며, 따라서 동일 명령으로 다른 소비자가 동일 entry를 가져가지 못하게 된다
                li TIME : 절대값(마지막 entry 배달 시각)을 이용해 대기 시간 재설정
                li RETRYCOUNT : 배달 카운터 재설정
                li FORCE : 소비 완료 대기 중이지 않은 entry도 처리
                li JUSTID : entry의 id만 반환. 배달 카운터를 증가하지 않는다

            h3 XDEL
            +asCode('text', 'syntax') XDEL key id [id ...]
            ul
                li 지정 entry 삭제. 삭제된 개수 반환
                li 현재까지는 entry 삭제가 즉시 메모리 반환을 의미하지 않는다 -> macro-node의 모든 entry가 삭제 상태가 될 때 정리

            h3 XGROUP
            div
                h4.fake CREATE
                +asCode('text', 'syntax') XGROUP CREATE key groupname id|$ [MKSTREAM] [ENTRIESREAD entries_read]
                ul
                    li 소비자그룹 생성. 이미 동일 이름의 그룹이 존재하면 에러
                    li id|$ : 지정 id 다음 엔트리부터 소비|그룹 생성 직후 엔트리부터 소비
                    li MKSTREAM : key에 스트림이 없으면 생성

                h4.kafe CREATECONSUMER Since 6.2.0
                +asCode('text', 'syntax') XGROUP CREATECONSUMER key groupname consumername
                p 소비자 명시적으로 생성

                h4.fake DELCONSUMER
                +asCode('text', 'syntax') XGROUP DELCONSUMER key groupname consumername
                p 소비자 삭제

                h4.fake DESTROY
                +asCode('text', 'syntax') XGROUP DESTROY key groupname
                p 소비자그룹 삭제

                h4.fake HELP
                +asCode('text', 'syntax') XGROUP HELP
                p 도움말 반환

                h4.fake SETID
                +asCode('text', 'syntax') XGROUP SETID key groupname id|$ [ENTRIESREAD entries_read]
                p 소비 기준 id 재설정

            h3 XINFO
            div
                h4.fake CONSUMERS
                +asCode('text', 'syntax') XINFO CONSUMERS key groupname
                ul
                    li 소비자 정보 반환
                    li name : 이름
                    li pending : 소비 완료 대기 entry 개수
                    li idle : 마지막 통신 이후 ms

                h4.fake GROUPS
                +asCode('text', 'syntax') XINFO GROUPS key
                ul
                    li 소비자 그룹 정보 반환
                    li name : 이름
                    li consumers : 소비자 수
                    li pending 전체 소비 완료 대기 entry 개수
                    li last-delivered-id : 마지막으로 배달된 entry의 id
                    li entries-read : 그룹이 읽은 entry 개수(부정확)
                    li lag : 배달 대기 중인 entry 개수, 아래의 경우 일반 연산이 처리되기 전까지 nil이 반환될 수 있다
                    ul
                        li 그룹이 임의 last-delivered-id로 생성된 경우
                        li 그룹의 last-delivered-id와 스트림의 last-generated-id 사이의 entry가 삭제된 경우

                h4.fake HELP
                +asCode('text', 'syntax') XINFO HELP
                p 도움말 반환

                h4.fake STREAM
                +asCode('text', 'syntax') XINFO STREAM key [FULL [COUNT count]]
                ul
                    li 스트림 정보 반환
                    li length : entry 개수
                    li radix-tree-keys : 하위 데이터 구조에 존재하는 키의 수
                    li radix-tree-nodes : 하위 데이터 구조에 존재하는 노드 수
                    li groups : 그룹 개수
                    li last-generated-id : 마지막으로 추가된 entry의 id
                    li max-deleted-entry-id : 삭제된 entry 중 최대 id
                    li entries-added : 스트림에 현재까지 추가된 entry 개수
                    li first-entry : 첫 번째 entry의 id
                    li last-entry : 마지막 entry의 id
                    li FULL : entries, groups 정보 포함. count 기본값은 10

            h3 XLEN
            +asCode('text', 'syntax') XLEN key
            p entry 개수 반환. key가 없어도 0

            h3 XPENDING
            +asCode('text', 'syntax') XPENDING key group [[IDLE min-idle-time] start end count [consumer]]
            ul
                li key group만 지정한 경우
                p [소비 완료 대기 entry 개수, 최소 id, 최대 id, [소비 완료 대기 중인 소비자, 해당 소비자에 대해 대기 중인 entry 개수] ...] 반환
                li 그 외의 경우
                p [[소비 완료 대기 중인 entry id, 소비자 이름, 배달 완료 후 시간(ms), 배달 횟수] ...] 반환

            h3 XRANGE
            +asCode('text', 'syntax') XRANGE key start end [COUNT count]
            ul
                li id가 [start, end] 내에 있는 엔트리 반환
                li 열린 구간을 지시하려면 '('를 접두에 붙이면 된다
                li 전체를 가져오려면 start, end로 -, + 각각 이용
                li COUNT : 최대 count 개만 반환

            h3 XREAD
            +asCode('text', 'syntax') XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] id [id ...]
            ul
                li 각 스트림에서 지정한 id보다 큰 entry를 count(기본 1)개 반환
                li BLOCK : 모든 스트림이 비어있는 경우, 최대 milliseconds 만큼 대기
                li BLOCK ... $ : 명령 이후 도착하는 것만 반환

            h3 XREADGROUP
            +asCode('text', 'syntax') XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] id [id ...]
            ul
                li 소비자로써 엔트리 소비 지시
                li
                    +goto('XREAD')
                    |와 겹치는 옵션은 동일한 의미를 가진다
                li NOACK : XACK가 필요없다 -> 메시지 전달 즉시 소비 완료한 걸로 간주한다
                li entry id로 '>'를 이용하면 알아서 다음 entry를 획득한다

            h3 XREVRANGE
            +asCode('text', 'syntax') XREVRANGE key end start [COUNT count]
            p
                +goto('XRANGE')
                |의 역순

            h3 XTRIM
            +asCode('text', 'syntax') XTRIM key MAXLEN|MINID [=|~] threshold [LIMIT count]
            ul
                li 필요한 경우 오래된 entry들을 삭제
                li MAXLEN : 크기가 threshold를 초과하는 경우 삭제
                li MINID : threshold보다 작은 id의 entry 삭제
                p XTRIM mystream MINID 649085820 -> id가 649085820-0보다 작은 entry들을 삭제한다
                li MAXLEN ~ : 다른 입출력에 지장이 없도록 어느 정도의 오차를 허용
                li LIMIT : 최대 count개만 제거

        h2 Pub/Sub
        div
            h3 PSUBSCRIBE
            +asCode('text', 'syntax') PSUBSCRIBE pattern [ pattern ...]
            p <span class="hover-content" template-id="glob-style-pattern">GLOB style pattern</span>에 일치하는 채널들 구독

            h3 PUBLISH
            +asCode('text', 'syntax') PUBLISH channel message
            p 메시지 발행

            h3 PUBSUB
            div
                h4.fake CHANNELS
                +asCode('text', 'syntax') PUBSUB CHANNELS [pattern]
                p 채널 목록 반환

                h4.fake HELP
                +asCode('text', 'syntax') PUBSUB HELP
                p 도움말 반환

                h4.fake NUMPAT
                +asCode('text', 'syntax') PUBSUB NUMPAT
                p
                    +goto('PSUBSCRIBE')
                    |로 구독 중인 패턴 개수 반환

                h4.fake NUMSUB
                +asCode('text', 'syntax') PUBSUB NUMSUB [channel [channel ...]]
                p 구독자 수 반환

                h4.fake SHARDCHANNELS Since 7.0.0
                +asCode('text', 'syntax') PUBSUB SHARDCHANNELS [pattern]
                p 샤드 채널 목록 반환

                h4.fake SHARDNUMSUB Since 7.0.0
                +asCode('text', 'syntax') PUBSUB SHARDNUMSUB [channel [channel ...]]
                p 샤드 채널 구독자 수 반환

            h3 PUNSUBSCRIBE
            +asCode('text', 'syntax') PUNSUBSCRIBE [pattern [pattern ...]]
            p 구독 취소

            h3 SPUBLISH Since 7.0.0
            +asCode('text', 'syntax') SPUBLISH channel message
            p 샤드 채널에 메시지 발행

            h3 SSUBSCRIBE Since 7.0.0
            +asCode('text', 'syntax') SSUBSCRIBE channel [channel ...]
            p 샤드 채널 구독

            h3 SUBSCRIBE
            +asCode('text', 'syntax') SUBSCRIBE channel [channel ...]
            p 채널 구독

            h3 SUNSUBSCRIBE Since 7.0.0
            +asCode('text', 'syntax') SUNSUBSCRIBE [channel [channel ...]]
            p 샤드 채널 구독 취소

            h3 UNSUBSCRIBE
            +asCode('text', 'syntax') UNSUBSCRIBE [channel [channel ...]]
            p 구독 취소


    h1 Redis Stack
    p 레디스 서버에 여러 모듈이 추가되어 아래와 같은 기능을 지원한다
    ul
        li RediSearch : 추가 인덱싱, 쿼리 지원, 전문 검색 등 지원
        li RedisJSON : JSON 모델 지원
        li RedisGraph : 그래프 모델 지원
        li RedisTimeSeries : 기간을 이용한 쿼리, 집계 쿼리 등 지원

    +hoverTemplate()#glob-style-pattern
        ul
            li * : 임의 길이 임의 문자열
            li ? : 임의 문자 1개
            li [abc] : 문자 집합 중 1글자
            li [^abc] : 여집합 중 1글자
            li [a-z] : 문자 집합 중 1글자

    +hoverTemplate()#zset-score-range
        ul
            li 기본적으로 min max는 닫힌 구간 [min, max]를 의미한다
            li 열린 구간 표현을 위해 '('를 이용할 수 있다
            p e.g. (10 (20
            li -inf, +inf를 min, max로 이용할 수 있다

    +hoverTemplate()#zset-lexicographical-range
        ul
            li 구간 표현 시 min, max 앞에 [ 또는 (를 명시해야한다
            p e.g. [hello (world
            li 특별히 -, +를 무한대 표현으로 이용할 수 있다
            p e.g. - (world
