include ../../../source/skeleton.pug

+post({
    title: 'Spring Framework',
    description: 'Spring Framework 코어 정리',
})

    h1 Spring Framework
    div
        +asA('https://spring.io/projects/spring-framework#learn', 'spring-framework#learn')
        +asA('https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/index.html', 'spring-framework-reference')
        +asA('https://docs.spring.io/spring-framework/docs/current/javadoc-api/', 'javadoc-api')
        h2 Overview
        ul
            li 상용 Java 앱 개발을 위한 JavaEE 대안 프레임워크. 다른 JVM 언어 ─ Groovy, Kotlin ─ 도 지원한다
            p JavaEE보다 신규 사양의 결정, 신규 기능의 추가가 빠르다
            li Spring Framework 5에 추가된 WebFlux는 서블릿 컨테이너 대신 Netty 등의 리액티브 스트림 서버를 이용한다
            li Spring Framework는 순환적인 패키지 참조가 없는, 고도로 표준화된 코드를 유지한다
            li 빠른 시작
            +asA('https://start.spring.io/', 'Spring Boot initializer')
            +asA('https://spring.io/guides#topical-guides')

    h1 Core
    div
        h2 IoC Container
        div
            h3 Introduction
            ul
                li Dependency란?
                p 객체가 정상적인 작동을 위해 필요로 하는 다른 객체

                li IoC(Inversion of Control), DI(Dependency Injection)란?
                ul
                    li 객체 인스턴스화, 프로퍼티 설정을 Spring IoC 컨테이너가 대신 해준다
                    li 의존성을 컨테이너가 주입(DI)한다
                    li 의존성을 외부에서 설정하므로 제어의 역전(IoC)이 존재한다

                li Bean이란?
                p Spring IoC 컨테이너가 관리하는 인스턴스. 그 외 임의 인스턴스를 지칭해도 무방

                li 연관 패키지
                p org.springframework.beans, org.springframework.context

                li ApplicationContext → BeanFactory 인터페이스
                ul
                    li BeanFactory : 임의 타입 객체를 관리할 수 있는, DI 관련 최상위 인터페이스
                    li ApplicationContext : AOP, 이벤트 발행 등 상용 애플리케이션에 쓰일 특징을 추가로 주입한다

            h3 Container Overview
            p ApplicationContext는 메타데이터(XML, Java annotation Since 2.5, Java code Since 3.0)에 기술된 대로 클래스를 인스턴스화하고, 의존성을 주입한다
            ol
                li IoC 메타데이터 작성
                li IoC Container 인스턴스화
                li IoC Container 이용
            div
                h4 XML 메타데이터
                ul
                    li ClassPathXmlApplicationContext : 클래스 패스 상의 메타데이터 파일 이용
                    +asCode('java') new ClassPathXmlApplicationContext("beans/Beans12.xml")
                    li FileSystemXmlApplicationContext : 파일 시스템 상의 메타데이터 파일 이용
                    +asCode('java') new FileSystemXmlApplicationContext("src/main/resource/anno01.xml")
                    li GenericXmlApplicationContext Since 3.0
                    p ClassPathXmlApplicationContext, FileSystemXmlApplicationContext 두 경우 모두 포함
                    +asCode('java').
                        new GenericXmlApplicationContext(
                            "classpath:beans/Beans*.xml",
                            "file:src/main/resource/anno*.xml"
                        )
                    li WebApplicationContext : web.xml 이용
                div
                    h5.fake 최상위 &lt;beans> 안에 필요한 &lt;bean>들을 정의한다
                    +asCode('xml').
                        &lt;beans xmlns="http://www.springframework.org/schema/beans"
                            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                            xsi:schemaLocation="http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">
                            &lt;bean id="hello" class="io.github.donggi.bean.Hello"/>
                        &lt;/beans>
                    h5.fake 다른 xml 포함
                    +asCode('xml').
                        &lt;beans>
                            &lt;import resource="other.xml"/>
                            &lt;import resource="dir/other.xml"/>
                        &lt;/beans>
                    p ↑ resource의 경로는 '/'로 시작하더라도 항상 현재 디렉터리에 대한 상대경로로 해석된다

                h4 Groovy DSL 메타데이터
                +asCode('groovy', 'services.groovy').
                    beans {
                        myService(MyService) {
                            msg = "Hello World"
                        }
                    }
                +asCode('java') var context = new GenericGroovyApplicationContext("services.groovy");

                h4 GenericApplicationContext - 메타데이터 혼용
                +asCode('java').
                    var context = new GenericApplicationContext();
                    new XmlBeanDefinitionReader(context).loadBeanDefinitions("services.xml", "daos.xml");
                    new GroovyBeanDefinitionReader(context).loadBeanDefinitions("services.groovy", "daos.groovy");
                    context.refresh();

            h3 Bean Overview
            table.w3-table-all.w3-card.w3-small
                caption 빈을 정의하는 요소 
                    +asA('https://docs.spring.io/spring/docs/5.3.0-SNAPSHOT/javadoc-api/org/springframework/beans/factory/config/BeanDefinition.html')
                +tds('Class')
                +tds('Name')
                +tds('Scope')
                +tds('Constructor arguments')
                +tds('Properties')
                +tds('Autowiring mode')
                +tds('Lazy initialization mode')
                +tds('Initialization method')
                +tds('Destruction method')
            div
                h4 Naming Beans
                ul
                    li 모든 빈은 이름을 가지며, 지정하지 않더라도 자동 할당된다
                    li XML에서 빈 이름은 id 또는 name 속성으로 정의할 수 있다
                    p id는 컨테이너 전체에 걸쳐 고유해야 하며, name은 여러 이름을 ',', ';', ' '로 구분하여 설정할 수 있다
                    li 동일한 빈을 여러 이름으로 접근할 수 있다
                    +asCode('xml').
                        &lt;alias name="originalName" alias="alias1"/>
                        &lt;alias name="originalName" alias="alias2"/>
                h4 Instantiating Beans
                ul
                    li 빈 클래스로 static 클래스 지정 가능
                    +asCode('xml') &lt;bean class="com.example.SomeThing$OtherThing"/>
                    li 팩터리 메서드 지정 가능
                    +asCode('xml').
                        &lt;bean class="..." factory-method="newInstance"/>
                        &lt;bean factory-bean="beanName" factory-method="newInstance"/>
                    li 생성된 빈의 실제 타입은 BeanFactory#getType 메서드로 획득할 수 있다
            h3 Dependency Injection
            ul
                li A가 B에 의존하고, 둘 사이에 순환 의존성이 존재하지 않는다면, A에 B가 주입되기 전에 B가 완전히 초기화됨이 보장된다
                li.marker 생성자 주입 // 팩터리 메서드 인자도 동일한 태그를 사용한다
                +asCode('xml').
                    &lt;constructor-arg index="0" type="java.lang.String" name="msg" value="Hell World"/>
                    &lt;constructor-arg value="Hell World"/>
                    &lt;constructor-arg ref="beanName"/>
                    &lt;constructor-arg>
                        &lt;ref bean="beanName"/>
                    &lt;/constructor-arg>
                ul
                    li index, type, name은 모호성을 피하기 위해 사용하는 옵션 프로퍼티이며, name을 이용하는 경우 debug 컴파일하거나, 
                        +asA('https://docs.oracle.com/javase/8/docs/api/java/beans/ConstructorProperties.html')
                        |를 이용해 이름을 탐색할 수 있게 해야한다
                    li constructor-arg를 이용한 생성자 주입 예
                    +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/bean/Hello17.java', 'java', [7]) Bean
                    +codeBtn('/Repositories/STS/app2/src/main/resource/Beans25.xml', 'xml') XML
                    +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/bean/Hello17Test.java', 'java', [8]) Context
                    li xmlns:c를 이용한 생성자 주입 예
                    ul
                        li 생성자 인자 이름을 알 수 있는 경우 예 : 
                            +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/bean/Hello17.java', 'java', [7]) Bean
                            +codeBtn('/Repositories/STS/app2/src/main/resource/Beans26.xml', 'xml') XML
                            +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/bean/Hello17Test2.java', 'java', [8]) Context
                        li 생성자 인자 이름을 알 수 없는 경우 예 : 
                            +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/bean/Hello17.java', 'java', [7]) Bean
                            +codeBtn('/Repositories/STS/app2/src/main/resource/Beans32.xml', 'xml') XML
                            +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/bean/Hello17Test4.java', 'java', [8]) Context

                li.marker 세터 주입
                +asCode('xml').
                    &lt;property name="message" value="Hello"/>
                    &lt;property name="message" ref="beanName"/>
                    &lt;property name="message">
                        &lt;ref bean="beanName"/>
                    &lt;/property>
                    &lt;property name="message">
                        &lt;bean class="java.lang.String" c:original="빈 메시지 2"/>
                    &lt;/property>
                ul
                    li 인자 없는 생성자 또는 팩터리 메서드 호출 뒤, 세터를 호출하여 의존성을 주입한다
                    li property를 이용한 세터 주입 예
                    +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/bean/Hello1.java', 'java', [5]) Bean
                    +codeBtn('/Repositories/STS/app2/src/main/resource/Beans1.xml', 'xml') XML
                    +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/bean/Hello1Test.java', 'java', [8]) Context
                    li xmlns:p를 이용한 세터 주입 예
                    +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/bean/Hello1.java', 'java', [5]) Bean
                    +codeBtn('/Repositories/STS/app2/src/main/resource/Beans5.xml', 'xml') XML
                    +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/bean/Hello1Test2.java', 'java', [8]) Context

                li.marker 기타 의존성 주입
                table.w3-table-all.w3-card.w3-small
                    +ths('종류', '예시 코드')
                    tr
                        td 익명 빈 생성
                        td
                            +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/bean/Hello17.java', 'java', [7]) Bean
                            +codeBtn('/Repositories/STS/app2/src/main/resource/Beans27.xml', 'xml') XML
                            +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/bean/Hello17Test3.java', 'java', [8]) Context
                    tr
                        td 의존 빈 주입
                        td property, constructor-arg 태그 안에서 이용하는 bean 태그들은 id, name이 필요없으며, 지정해도 무시된다
                            +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/bean/Hello1.java', 'java', [5]) Bean1
                            +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/bean/Hello17.java', 'java', [7]) Bean2
                            +codeBtn('/Repositories/STS/app2/src/main/resource/Beans7.xml', 'xml') XML
                            +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/bean/Hello4Test3.java', 'java', [8]) Context
                    tr
                        td 의존 컬렉션 주입
                        td 자바 기본 타입 및 String은 문자열로부터 알아서 변환되어 주입된다
                            |  반면 배열, List, Properties, Map 등은 전용 태그를 이용하거나, 다른 팩터리 메서드를 빌려 설정해야 한다
                            +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/bean/Hello5.java', 'java', [10]) Bean
                            +codeBtn('/Repositories/STS/app2/src/main/resource/Beans8.xml', 'xml') XML
                            +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/bean/Hello5Test.java', 'java', [11]) Context
                    tr
                        td 팩터리를 통한 의존 컬렉션 주입
                        td
                            +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/bean/Hello5.java', 'java', [10]) Bean
                            +codeBtn('/Repositories/STS/app2/src/main/resource/Beans10.xml', 'xml') XML
                            +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/bean/Hello5Test3.java', 'java', [11]) Context
                    tr
                        td xmlns:util을 이용한 의존 컬렉션 주입
                        td
                            +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/bean/Hello5.java', 'java', [10]) Bean
                            +codeBtn('/Repositories/STS/app2/src/main/resource/Beans9.xml', 'xml') XML
                            +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/bean/Hello5Test2.java', 'java', [11]) Context
                    tr
                        td parent 속성을 통한 상속
                        td
                            p 값 상속 예 : 
                                +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/bean/Hello1.java', 'java', [5]) Bean
                                +codeBtn('/Repositories/STS/app2/src/main/resource/Beans11.xml', 'xml') XML
                                +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/bean/Hello1Test3.java', 'java', [8]) Context
                            p 컬렉션 상속(merge="true") 예 : 
                                +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/bean/Hello5.java', 'java', [10]) Bean
                                +codeBtn('/Repositories/STS/app2/src/main/resource/Beans31.xml', 'xml') XML
                                +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/bean/Hello5Test4.java', 'java', [11]) Context
                    tr
                        td parent context를 이용한 상속
                        td
                            +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/bean/Hello18.java', 'java', [3]) Interface
                            +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/bean/Hello18Impl.java', 'java', [5]) Impl
                            +codeBtn('/Repositories/STS/app2/src/main/resource/Beans29.xml', 'xml') parent XML
                            +codeBtn('/Repositories/STS/app2/src/main/resource/Beans30.xml', 'xml') child XML
                            +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/bean/Hello18Test.java', 'java', [8]) Context
                    tr
                        td lookup-method를 통한 프록시
                        td
                            ul
                                +pos('lookup-method')
                                li name : 재정의할 메서드 이름 → private X, void 반환 X, 메서드 매개변수 X, final X
                                li bean : 재정의한 메서드에서 반환할 객체
                                +codeBtn('/Repositories/STS/app2/src/main/resource/Beans19.xml', 'xml') XML
                                +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/bean/Beans19Test.java', 'java', [11]) Context
                    tr
                        td replaced-method를 통한 프록시
                        td
                            ul
                                li name : 재정의할 메서드 이름
                                li replacer : MethodReplacer 구현체
                                +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/bean/Hello22.java', 'java', [5]) Bean
                                +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/bean/Hello22Replacement.java', 'java', [10]) MethodReplacer
                                +codeBtn('/Repositories/STS/app2/src/main/resource/Beans36.xml', 'xml') XML
                                +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/bean/Hello22Test.java', 'java', [8]) Context
                    tr
                        td Compound property name을 이용한 내부 빈 속성 설정
                        td
                            +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/bean/Hello19.java', 'java', [5]) Bean
                            +codeBtn('/Repositories/STS/app2/src/main/resource/Beans33.xml', 'xml') XML
                            +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/bean/Hello19Test.java', 'java', [8]) Context
                    tr
                        td
                            +pos('depends-on')
                            |depends-on을 이용한 빈 생성 순서 설정
                        td has-a 관계보다 약한 의존 관계에서, depends-on을 이용해 특정 빈이 먼저 생성되도록 강제할 수 있다
                            |  양쪽 빈 모두 싱글톤인 경우, 객체 소멸 순서도 정해진다
                            +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/bean/Hello20.java', 'java', [5]) Bean
                            +codeBtn('/Repositories/STS/app2/src/main/resource/Beans34.xml', 'xml') XML
                            +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/bean/Hello20Test.java', 'java', [10]) Context
                    tr
                        td lazy-init을 이용한 빈 생성 늦추기
                        td
                            +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/bean/Hello21.java', 'java', [5]) Bean
                            +codeBtn('/Repositories/STS/app2/src/main/resource/Beans35.xml', 'xml') XML
                            +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/bean/Hello21Test.java', 'java', [10]) Context
            div
                h4 Autowire
                ul
                    li IoC 컨테이너가 관리중인 빈들을 자동으로 주입하도록 구성할 수 있다. XML에서는 bean 태그의 autowire 속성으로 제어하며, 아래 4가지 모드가 가능하다
                    table.w3-table-all.w3-card.w3-small
                        +ths('mode', '설명')
                        +tds('no', '기본 설정. 모든 의존성은 명시되어야 한다.')
                        +tds('byName', '이름이 일치하는 빈을 주입한다')
                        +tds('byType', '타입이 일치하는 빈을 주입한다. 일치하는 빈이 2개 이상이면 에러, 0개면 미설정')
                        +tds('constructor', '생성자에 적용되는 byType')
                    li 명시된 의존성은 항상 autowire보다 우선이며, 자바 기본 타입은 autowire 할 수 없다
                    li bean 정의 시 autowire-candidate 속성을 false로 하면, type 매치 주입물이 되지 않는다
                    li beans 정의 시 default-autowire-candidates를 이용해 autowire 주입물을 제한할 수 있다
                    +asCode('xml') &lt;beans ... default-autowire-candidates="*Service,*Dao" />
                    li bean 정의 시 primary 속성을 true로 하면, 최우선 autowire 주입물이 된다
                    li 예시 
                        +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/bean/Hello15.java', 'java', [7]) Bean1
                        +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/bean/Hello16.java', 'java', [7]) Bean2
                        +codeBtn('/Repositories/STS/app2/src/main/resource/Beans12.xml', 'xml') XML
                        +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/bean/Hello15Test3.java', 'java', [8]) Context

            h3 Bean Scope
            ul
                li 빈의 유효 기간을 설정할 수 있다. 아래 6가지는 빈 설정 시 기본으로 이용할 수 있는 목록이다
                table.w3-table-all.w3-card.w3-small
                    +ths('Scope', '설명')
                    +tds('singleton', '기본값. 컨테이너에서 하나의 인스턴스만 생성')
                    +tds('prototype', '빈 요청마다 새 인스턴스 생성. 컨테이너는 prototype 빈의 일부 lifecycle만 관리하며, 생성 이후 lifecycle은 클라이언트가 책임져야 한다')
                    +tds('request', 'HTTP 요청마다 새 인스턴스 생성. Web 관련 ApplicationContext에서 지정 가능')
                    +tds('session', 'HTTP 세션마다 새 인스턴스 생성. Web 관련 ApplicationContext에서 지정 가능')
                    +tds('application', 'ServletContext마다 새 인스턴스 생성. Web 관련 ApplicationContext에서 지정 가능')
                    +tds('websocket', 'WebSocket마다 새 인스턴스 생성. Web 관련 ApplicationContext에서 지정 가능')
                li Spring 3.0부터 스레드 단위로 인스턴스를 생성하는 SimpleThreadScope가 추가되었다
                p ConfigurableBeanFactory.registerScope(String, Scope) 또는 CustomScopeConfigurer로 사용 가능
                +pos('scope 예')
                li request, session, application 예
                +codeBtn('/Repositories/STS/ioc-example/src/main/java/io/github/donggi/example/entity/PerApp.java', 'java', [8]) Bean per App
                +codeBtn('/Repositories/STS/ioc-example/src/main/java/io/github/donggi/example/entity/PerRequest.java', 'java', [8]) Bean per Request
                +codeBtn('/Repositories/STS/ioc-example/src/main/java/io/github/donggi/example/entity/PerSession.java', 'java', [8]) Bean per Session
                +codeBtn('/Repositories/STS/ioc-example/src/main/java/io/github/donggi/example/controller/ScopeController.java', 'java', [27,40,42,55]) Controller
                li 기본적으로 빈에 주입된 의존 객체는 컨테이너에 의해 다시 설정되지 않는다
                p 만일 스코프가 더 좁은 빈을 의존하지만 참조 시마다 새로운 인스턴스가 필요한 경우, 해당 메서드를 재정의하거나, aop:scoped-proxy를 이용하면 된다
                    |  AOP proxy 인스턴스는 직렬화 가능하며, 직렬화 전 참조 객체와 역직렬화 후 참조 객체는 동일하다
                p 다른 방법으로 ObjectFactory#getObject(), ObjectProvider(→ ObjectFactory)의 getIfAvailable(), getIfUnique()을 이용할 수도 있다
                p
                    span.hover-content(template-id='template-jsr330') JSR-330
                    |에서는 Provider가 위와 비슷한 기능을 제공한다
                table.w3-table-all.w3-card.w3-small
                    tr
                        td 아무 설정 없는 예
                        td
                            +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/bean/Hello15.java', 'java', [7]) Bean1
                            +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/bean/Hello16.java', 'java', [7]) Bean2
                            +codeBtn('/Repositories/STS/app2/src/main/resource/Beans20.xml', 'xml') XML
                            +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/bean/Hello15Test.java', 'java', [8]) Context
                    tr
                        td 메서드 재정의 예
                        td
                            +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/bean/Hello15.java', 'java', [7]) Bean1
                            +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/bean/Hello16.java', 'java', [7]) Bean2
                            +codeBtn('/Repositories/STS/app2/src/main/resource/Beans37.xml', 'xml') XML
                            +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/bean/Hello15Test5.java', 'java', [8]) Context
                    tr
                        td aop:scoped-proxy 예
                        td
                            +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/bean/Hello15.java', 'java', [7]) Bean1
                            +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/bean/Hello16.java', 'java', [7]) Bean2
                            +codeBtn('/Repositories/STS/app2/src/main/resource/Beans21.xml', 'xml') XML
                            +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/bean/Hello15Test4.java', 'java', [8]) Context
                    tr
                        td Custom Scope 예
                        td
                            +codeBtn('/Repositories/STS/ioc-example/src/main/java/io/github/donggi/example/entity/PerMinute.java', 'java', [8]) Bean per Minute
                            +codeBtn('/Repositories/STS/ioc-example/src/main/java/io/github/donggi/example/scope/MinuteScope.java', 'java', [10]) Custom Scope
                            +codeBtn('/Repositories/STS/ioc-example/src/main/java/io/github/donggi/example/config/MinuteBeanFactoryPostProcessor.java', 'java', [9]) PostBeanProcessor
                            +codeBtn('/Repositories/STS/ioc-example/src/main/java/io/github/donggi/example/config/AppConfig.java', 'java', [7]) AppConfig
                            +codeBtn('/Repositories/STS/ioc-example/src/main/java/io/github/donggi/example/controller/ScopeController.java', 'java', [57,70]) Controller
                            p aop:scoped-proxy 설정을 하고 싶다면 @Scope의 proxyMode 변수를 설정
                            ul
                                li NO : default. 프록시 없음
                                li INTERFACES : 인터페이스 프록시 생성. JDK 동적 프록시 이용
                                li TARGET_CLASS : 클래스 프록시 생성. CGLIB 이용

            h3 Bean 커스터마이징
            div
                h4 Lifecycle Callback
                ul
                    li InitializingBean, DisposableBean 예 
                        +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/bean/Hello2.java', 'java', [8]) Bean
                        +codeBtn('/Repositories/STS/app2/src/main/resource/Beans2.xml', 'xml') XML
                        +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/bean/Hello2Test.java', 'java', [8]) Context
                    li Lifecycle 예 
                        +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/bean/Hello29.java', 'java', [8]) Bean
                        +codeBtn('/Repositories/STS/app2/src/main/resource/Beans46.xml', 'xml') XML
                        +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/bean/Hello29Test.java', 'java', [8]) Context
                    li init-method, destroy-method 예 
                        +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/bean/Hello3.java', 'java', [5]) Bean
                        +codeBtn('/Repositories/STS/app2/src/main/resource/Beans3.xml', 'xml') XML
                        +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/bean/Hello3Test.java', 'java', [8]) Context
                    li destroy-method로 (inferred)를 설정하면 public close() 또는 shutdown()을 찾아 실행한다 
                        +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/bean/Hello23.java', 'java', [5]) Bean
                        +codeBtn('/Repositories/STS/app2/src/main/resource/Beans38.xml', 'xml') XML
                        +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/bean/Hello23Test.java', 'java', [8]) Context
                    li default-init-method, default-destroy-method 예 
                        +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/bean/Hello24.java', 'java', [3]) Bean
                        +codeBtn('/Repositories/STS/app2/src/main/resource/Beans39.xml', 'xml') XML
                        +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/bean/Hello24Test.java', 'java', [8]) Context
                    li JSR-250 : @PostConstruct, @PreDestroy 예 
                        +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/anno/Anno21.java', 'java', [8]) Bean
                        +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/anno/Anno21Test.java', 'java', [8]) Context
                    li 위 설정들은 중복이 가능하며, 서로 다른 메서드들로 설정된 경우 아래 순서대로 실행된다
                    ul
                        li @PostConstruct → InitializingBean → init-method
                        li @PreDestroy → DisposableBean → destroy-method
                    li ConfigurableApplicationContext#registerShutdownHook 예 
                        +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/bean/Hello4Test.java', 'java', [9]) Context
                h4 Aware
                ul
                    li ApplicationContextAware 인터페이스를 구현한 경우, 빈 생성 후 어떤 컨텍스트가 만들었는지 알 수 있다. 
                        +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/bean/Hello25.java', 'java', [9]) Bean
                        +codeBtn('/Repositories/STS/app2/src/main/resource/Beans40.xml', 'xml') XML
                        +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/bean/Hello25Test.java', 'java', [8]) Context
                    li BeanNameAware 인터페이스를 구현한 경우, 빈 생성 후 어떤 이름으로 만들었는지 알 수 있다. 
                        +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/bean/Hello26.java', 'java', [6]) Bean
                        +codeBtn('/Repositories/STS/app2/src/main/resource/Beans41.xml', 'xml') XML
                        +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/bean/Hello26Test.java', 'java', [8]) Context
                table.w3-table-all.w3-card.w3-small
                    caption: +asA('https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aware-list')
                    +ths('interface', '주입물')
                    +tds('ApplicationEventPublisherAware', 'ApplicationEventPublisher')
                    +tds('BeanClassLoaderAware', 'ClassLoader')
                    +tds('BeanFactoryAware', 'BeanFactory')
                    +tds('LoadTimeWeaverAware', 'LoadTimeWeaver')
                    +tds('MessageSourceAware', 'MessageSource')
                    +tds('ResourceLoaderAware', 'ResourceLoader')
                    +tds('ServletConfigAware', 'ServletConfig')
                    +tds('ServletContextAware', 'ServletContext')

            h3 컨테이너 확장
            p ApplicationContext를 직접 상속하지 않고, 여러 인터페이스 구현체를 등록함으로써 기능 확장이 가능하다
            ul
                li BeanPostProcessor 
                    +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/bean/Hello27.java', 'java', [8]) Bean
                    +codeBtn('/Repositories/STS/app2/src/main/resource/Beans42.xml', 'xml') XML
                    +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/bean/Hello27Test.java', 'java', [8]) Context
                p 인스턴스 생성 후, 초기화 콜백 호출 전/후 작업을 추가할 수 있다. 여러 BeanPostProcessor를 등록하는 경우, order 속성(Ordered 인터페이스)으로 실행 순서를 제어할 수 있다
                p ApplicationContext#addBeanPostProcessor를 이용해 직접 등록하는 경우, Ordered 인터페이스를 구현해도 무시하며, 직접 등록된 순서대로 실행된다. 자동으로 탐색된 다른 BeanPostProcessor들보다 항상 먼저 실행된다
                li BeanFactoryPostProcessor
                p 빈을 생성하기 전에 컨테이너 관련 설정을 변경할 수 있다. 여러 BeanFactoryPostProcessor를 등록하는 경우, order 속성(Ordered 인터페이스)으로 순서를 제어할 수 있다
                ul
                    li PropertySourcesPlaceholderConfigurer 예 
                        +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/bean/Hello1.java', 'java', [5]) Bean1
                        +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/bean/Hello17.java', 'java', [7]) Bean2
                        +codeBtn('/Repositories/STS/app2/src/main/resource/Beans43.xml', 'xml') XML
                        +codeBtn('/Repositories/STS/app2/src/main/resource/beans43-1.properties', 'properties') properties1
                        +codeBtn('/Repositories/STS/app2/src/main/resource/beans43-2.properties', 'properties') properties2
                        +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/bean/Hello17Test5.java', 'java', [8]) Context
                    li PropertyOverrideConfigurer 예 
                        +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/bean/Hello1.java', 'java', [5]) Bean1
                        +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/bean/Hello17.java', 'java', [7]) Bean2
                        +codeBtn('/Repositories/STS/app2/src/main/resource/Beans44.xml', 'xml') XML
                        +codeBtn('/Repositories/STS/app2/src/main/resource/beans43-1.properties', 'properties') properties1
                        +codeBtn('/Repositories/STS/app2/src/main/resource/beans43-2.properties', 'properties') properties2
                        +codeBtn('/Repositories/STS/app2/src/main/resource/beans44.properties', 'properties') properties3
                        +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/bean/Hello17Test6.java', 'java', [8]) Context
                li FactoryBean 예 
                    +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/bean/Hello28.java', 'java', [6]) Bean
                    +codeBtn('/Repositories/STS/app2/src/main/resource/Beans45.xml', 'xml') XML
                    +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/bean/Hello28Test.java', 'java', [8]) Context
                p 빈 생성 절차를 XML보다 Java로 표현하는 것이 효율적인 경우, FactoryBean을 컨테이너에 등록할 수 있다

            h3 Annotation Configuration
            ul
                li XML Configuration과 같이 이용하는 경우, Annotation 기반 처리가 먼저 이뤄짐에 유의
                li context:annotation-config 
                    +codeBtn('/Repositories/STS/app2/src/main/resource/anno01.xml', 'xml') XML
                p ↑ 컨테이너에 등록된 빈에 대하여 애너테이션 처리
                li context:component-scan 
                    +codeBtn('/Repositories/STS/app2/src/main/resource/anno02.xml', 'xml') XML
                p ↑ 기준 패키지의 모든 클래스를 탐색하여 자동으로 빈 등록, DI, 기타 애너테이션 처리
                li XML을 아예 사용하지 않고도 구성 가능하다 
                    +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/anno/Anno02.java', 'java', [11]) Bean
                    +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/anno/Anno02Test2.java', 'java', [14]) Context
                li @Autowired, @Inject, @Value, @Resource는 BeanPostProcessor 구현체가 처리하므로, 사용자 정의 BeanPostProcessor 또는 BeanFactoryPostProcessor 클래스 안에서 해당 애너테이션들을 적용할 수 없다. 대신 @Bean을 이용해야 한다
                li Since JDK 9 : 스캔 대상 패키지가 module-info에서 exports 됐는지, non-public 메서드를 호출해야 되는 패키지가 opens(exports 말고) 됐는지 확인 필요
            table.w3-table-all.w3-card.w3-small
                +ths('Annotation', '대응 코드', '예시 코드')
                tr
                    td @Component
                    td xml: bean
                    td: ul
                        li 해당 타입이 빈 생성 대상임을 나타낸다
                        li value로 빈 이름을 설정할 수 있다. ""(default)면 자동 할당
                        li @Repository : Persistence layer
                        li @Service : Service layer
                        li @Controller : Presentation layer
                        li @Configuration : @Bean 메서드들을 갖는 구성 클래스
                        p @Configuration 클래스 안에서 형제 @Bean 메서드 호출은 의존 관계의 정의를 의미한다 
                            +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/anno/Anno26.java', 'java', [6]) Configuration
                            +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/anno/Anno26Test.java', 'java', [8]) Context
                        li @RestController = @Controller + @ResponseBody
                        li 기타 사용자 정의 애너테이션도 가능
                tr
                    td @Bean
                    td xml: bean
                    td: ul
                        li 팩터리 메서드에 적용하여 빈 생성 대상임을 나타낸다
                        li static 메서드에 적용하는 경우 프록시를 통하지 않고 호출된다
                        li name으로 빈 별명을 설정할 수 있다
                        li initMethod를 설정할 수 있다 ← 메서드 바디에서 호출하면 되므로 쓸 일은 별로 없을듯
                        li destroyMethod를 설정할 수 있다
                        p 기본값은 "(inferred)"로, 자동으로 public close() 또는 shutdown()을 찾아 실행한다. 아무것도 호출하고 싶지 않다면 ""로 설정하면 된다
                        p JNDI로 가져온 리소스 ─ 특히 DataSource들은 외부에서 생애가 관리되므로 destroyMethod="" 설정함이 바람직하다
                tr
                    td @Conditional
                    td
                    td Condition 인터페이스 구현체를 지정하여, @Component, @Configuration, @Bean 초기화를 진행할 지 여부를 미리 판단한다
                tr
                    td
                        +pos('@Profile')
                        |@Profile
                    td xml: beans profile=""
                    td @Conditional(value=org.springframework.context.annotation.ProfileCondition.class)
                        br
                        |→ active profile을 기준으로 초기화 진행 여부를 판단한다
                        +goto('profile 표현식')
                tr
                    td @Autowired
                    td xml: autowire
                    td: ul
                        li 적용 위치 : CONSTRUCTOR, FIELD, METHOD, PARAMETER
                        li CONSTRUCTOR 적용 예 
                            +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/anno/Anno03.java', 'java', [12]) Bean
                            +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/anno/Anno03Test.java', 'java', [8]) Context
                        p Since 4.3 : 기본 생성자가 없으면서 여러 생성자가 존재하는 경우에만 생성자에 @Autowired 적용 필요
                        li FIELD 적용 예 
                            +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/anno/Anno01.java', 'java', [6]) Bean
                            +codeBtn('/Repositories/STS/app2/src/main/resource/anno01.xml', 'xml') XML
                            +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/anno/Anno01Test.java', 'java', [8]) Context
                        li 특정 타입 T의 배열(T[])/컬렉션(Collection&lt;T>)/맵(Map&lt;String, T>에 적용한 경우, 해당 타입의 모든 빈을 목록으로 설정해준다
                        p 타깃 타입이 org.springframework.core.Ordered를 구현했거나, @Order, @Priority를 갖고 있으면 정렬하여 설정해준다
                        ul
                            li Array FIELD 적용 예 
                                +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/anno/Anno02.java', 'java', [11]) Bean
                                +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/anno/Anno02Test.java', 'java', [10]) Context
                            li Set FIELD 적용 예 
                                +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/anno/Anno05.java', 'java', [14]) Bean
                                +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/anno/Anno05Test.java', 'java', [10]) Context
                            li Map FIELD 적용 예 
                                +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/anno/Anno06.java', 'java', [13]) Bean
                                +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/anno/Anno06Test.java', 'java', [8]) Context
                        li required = false
                        ul
                            li FIELD, METHOD에 required = false 적용 예 
                                +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/anno/Anno07.java', 'java', [14]) Bean
                                +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/anno/Anno07Test.java', 'java', [8]) Context
                            p 의존 객체가 하나라도 누락되면 호출을 생략한다. → 따라서 기본값 그대로 남는다
                            li 팩터리 메서드, CONSTRUCTOR에 required = false 적용
                            p 배열, Collection, Map인자로 매칭되는 빈이 없는 경우, empty 인스턴스를 넘겨 호출한다
                            li ↑ 이는 @Autowired가 없는 단일 생성자를 갖는 일반 클래스에도 적용된다 
                                +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/anno/Anno08.java', 'java', [9]) Bean
                                +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/anno/Anno08Test.java', 'java', [10]) Context
                        li METHOD 적용 예 
                            +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/anno/Anno04.java', 'java', [12]) Bean
                            +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/anno/Anno04Test.java', 'java', [8]) Context
                        li 인자가 있든 없든 호출되길 원한다면 Optional 또는 @Nullable(Since 5.0)을 이용하면 된다 
                            +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/anno/Anno09.java', 'java', [11]) Bean
                            +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/anno/Anno09Test.java', 'java', [8]) Context
                        li 아래의 인터페이스 및 연관 구현 클래스에 대한 @Autowired 필드는 실행 환경에 따라 적절히 주입된다
                        p BeanFactory, ApplicationContext, Environment, ResourceLoader, ApplicationEventPublisher, MessageSource
                tr
                    td @Primary
                    td xml: primary="true"
                    td 특정 빈을 우선적으로 주입하도록 설정한다 
                        +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/anno/Anno10.java', 'java', [14]) Bean
                        +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/anno/Anno10Test.java', 'java', [8]) Context
                tr
                    td @Qualifier
                    td xml: qualifier value="xxx"
                        br
                        |xml: qualifier type="x.y.Z" value="xxx"
                    td: ul
                        li 빈을 구별할 수 있는 값을 설정한다. 빈 이름은 default qualifier로 이용됨에 유의. 
                            +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/anno/Anno11.java', 'java', [13]) Bean
                            +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/anno/Anno11Test.java', 'java', [8]) Context
                        li Qualifier는 고유할 필요가 없으며, 배열/컬렉션/맵 주입 시 qualifier가 일치하는 모든 빈들이 멤버로 할당된다
                        li @Autowired와 같이 사용하는 경우, 타입 기반 매칭이 먼저 수행됨에 유의. Qualifier 매칭만 수행하려는 경우 JSR-250의 @Resource를 이용할 것
                        li 사용자 정의 @Qualifier를 이용할 수 있다 
                            +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/anno/Anno12.java', 'java', [19]) Bean
                            +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/anno/Anno12Test.java', 'java', [8]) Context
                        li 사용자 정의 @Qualifier는 값 없이도 빈 특정이 가능할 수 있다 
                            +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/anno/Anno13.java', 'java', [17]) Bean
                            +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/anno/Anno13Test.java', 'java', [8]) Context
                        li 사용자 정의 @Qualifier는 다른 타입 속성들을 가질 수 있다 
                            +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/anno/Anno14.java', 'java', [17]) Bean
                            +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/anno/Anno14Test.java', 'java', [8]) Context
                        li Generic도 일종의 타입 Qualifier로 이용할 수 있다
                            +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/anno/Anno15.java', 'java', [11]) Bean
                            +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/anno/Anno15Test.java', 'java', [8]) Context
                tr
                    td @Resource
                    td xml: ref="beanName"
                    td: ul
                        li 빈 이름을 기준으로 주입한다 
                            +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/anno/Anno16.java', 'java', [12]) Bean
                            +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/anno/Anno16Test.java', 'java', [8]) Context
                        li name 속성을 지정하지 않으면 field 또는 parameter 이름을 기준으로 찾는다
                        li 이름을 기준으로 찾지 못하면 타입을 기준으로 다시 찾는다 
                            +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/anno/Anno17.java', 'java', [12]) Bean
                            +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/anno/Anno17Test.java', 'java', [8]) Context
                tr
                    td @Value
                    td xml: context:property-placeholder
                        +pos('property-placeholder')
                    td: ul
                        li 외부 *.properties 파일 기반으로 값 주입 
                            +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/anno/Anno18.java', 'java', [10]) Bean
                            +codeBtn('/Repositories/STS/app2/src/main/resource/anno18.properties', 'properties') properties
                            +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/anno/Anno18Test.java', 'java', [8]) Context
                        li @Bean static 메서드로 PropertySourcesPlaceholderConfigurer 인스턴스를 반환하면 커스터마이징 가능하다
                        li Spring Boot 애플리케이션은 기본적으로 application.properties, application.yml 파일을 읽는 PropertySourcesPlaceholderConfigurer 빈을 갖는다
                        li 프로퍼티 문자열 → Java Type으로의 변환
                        p BeanPostProcessor는 ConversionService를 이용해 타입 변환을 수행한다. 커스텀 컨버터를 등록하면 사용자 정의 타입으로의 변환도 가능하다 
                            +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/anno/Anno19.java', 'java', [14]) Bean
                            +codeBtn('/Repositories/STS/app2/src/main/resource/anno19.properties', 'properties') properties
                            +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/anno/Anno19Test.java', 'java', [8]) Context
                        li SpEL 표현식도 가능하다 
                            +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/anno/Anno20.java', 'java', [10]) Bean
                            +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/anno/Anno20Test.java', 'java', [8]) Context
                tr
                    td @PostConstruct
                    td xml: init-method
                    td 빈 생성 후 호출 
                        +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/anno/Anno21.java', 'java', [8]) Bean
                        +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/anno/Anno21Test.java', 'java', [8]) Context
                tr
                    td @PreDestroy
                    td xml: destroy-method
                    td 빈 소멸 시 호출
                        +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/anno/Anno21.java', 'java', [8]) Bean
                        +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/anno/Anno21Test.java', 'java', [8]) Context
                tr
                    td @ComponentScan
                    td xml: context:component-scan base-package=""
                    td: ul
                        li 스캔 범위를 확장한다 
                            +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/anno/Anno22.java', 'java', [6]) Configuration
                            +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/rare/Rare1.java', 'java', [5]) Bean
                            +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/anno/Anno22Test.java', 'java', [9]) Context
                        li includeFilters == xml: context:include-filter 
                        p ↑ 명시적으로 매칭되는 클래스만 스캔
                        li excludeFilters == xml: context:exclude-filter
                        p ↑ 매칭되는 클래스는 스캔 제외
                        li useDefaultFilters=false == xml: use-default-filters="false"
                        p ↑ @Component, @Repository, @Service 등을 자동으로 찾지 않는다
                        li 필터 종류
                        ul
                            li annotation(default) : 타입에 특정 애너테이션이 붙어있는지? 
                                +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/anno/Anno23.java', 'java', [11]) Configuration
                            li assignable : 특정 타입으로 할당 가능한지? 
                                +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/anno/Anno23.java', 'java', [11]) Configuration
                            li aspectj : 클래스 경로가 AspectJ 표현식에 일치하는지? 
                                +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/anno/Anno24.java', 'java', [8]) Configuration
                            +asCode('gradle', 'AspectJ 관련 jar들을 포함해야 한다. Spring Boot 예') implementation 'org.springframework.boot:spring-boot-starter-aop'
                            li regex : 클래스 경로가 정규표현식에 일치하는지? 
                                +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/anno/Anno24.java', 'java', [8]) Configuration
                            li custom : TypeFilter 구현 클래스 지정 
                                +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/anno/Anno25.java', 'java', [8]) Configuration
                                +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/scan/ScanFilter.java', 'java', [9]) TypeFilter
                                +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/anno/Anno25Test.java', 'java', [8]) Context
                        li nameGenerator == xml: name-generator
                        p 스프링 기본 네이밍이 맞지 않는 경우 BeanNameGenerator 구현체를 직접 제공해도 된다. 특히 같은 이름의 클래스가 여러 패키지에 존재하는 경우, 클래스 풀네임을 이름으로 제공하는 FullyQualifiedAnnotationBeanNameGenerator(Since 5.2.3)도 고려해봄직하다
                        li scopeResolver == xml: scope-resolver
                        p 애너테이션 기반 스코핑이 불충분하다면, 직접 ScopeMetadataResolver 구현체를 제공할 수 있다
                        li scopedProxy == xml: scoped-proxy
                        p singleton 외 스코프 빈에 대한 기본 프록시 설정 가능
                        ul
                            li NO : default. 프록시 없음
                            li INTERFACES : 인터페이스 프록시 생성. JDK 동적 프록시 이용
                            li TARGET_CLASS : 클래스 프록시 생성. CGLIB 이용
                tr
                    td @Inject
                    td @Autowired
                    td
                        span.hover-content(template-id='template-jsr330') JSR-330
                        ul
                            li @Autowire와 마찬가지로 필드, 메서드, 생성자에 적용 가능 
                                +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/jsr330/Anno01.java', 'java', [9]) Configuration
                                +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/jsr330/Anno01Test.java', 'java', [8]) Context
                            li @Named로 이름 지정 가능 
                                +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/jsr330/Anno02.java', 'java', [10]) Configuration
                                +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/jsr330/Anno02Test.java', 'java', [8]) Context
                            p @Named는 주입/생성 빈 이름 모두에 사용할 수 있다
                            li Provider를 이용하여 지연된 접근, 짧은 scope 빈 접근 가능 
                                +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/jsr330/Anno03.java', 'java', [12]) Configuration
                                +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/jsr330/Anno03Test.java', 'java', [10]) Context
                            li Optional 또는 @Nullable도 사용 가능 
                                +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/jsr330/Anno04.java', 'java', [13]) Configuration
                                +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/jsr330/Anno04Test.java', 'java', [8]) Context
                tr
                    td @Named, @ManagedBean
                    td @Component
                    td 
                        span.hover-content(template-id='template-jsr330') JSR-330
                        |  타입에 적용하는 경우 자동 생성 대상임을 나타낸다. 속성으로 이름을 지정하지 않는 경우 자동으로 할당된다
                tr
                    td @Singleton
                    td @Scope("singleton")
                    td 
                        span.hover-content(template-id='template-jsr330') JSR-330
                        |의 기본 scope는 prototype이지만, 스프링 컨테이너는 singleton으로 처리한다. 따라서 이 애너테이션은 사용자 정의 스코프 정의에만 이용하면 된다
                tr
                    td @Qualifier, @Named
                    td @Qualifier
                    td 
                        span.hover-content(template-id='template-jsr330') JSR-330
                        |  javax.inject.Qualifier는 사용자 정의 Qualifier를 위해 존재하며, @Named는 String qualifier 구현체로 이용할 수 있다
                tr
                    td @Import, @ImportResource
                    td xml: import
                    td: ul
                        li @Import : @Configuration에서 다른 @Configuration 임포트 
                            +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/anno/Anno27.java', 'java', [7]) Configuration
                            +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/anno/Anno27Test.java', 'java', [8]) Context
                        +asCode('java').
                            @Configuration
                            @Import({OtherConfiguration.class})
                            public class MyConfiguration {}
                        li @ImportResource : @Configuration 다른 xml 임포트 
                            +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/anno/Anno28.java', 'java', [7]) Configuration
                            +codeBtn('/Repositories/STS/app2/src/main/resource/anno28.xml', 'xml') XML
                            +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/anno/Anno28Test.java', 'java', [8]) Context
                        +asCode('java').
                            @Configuration
                            @ImportResource("file:src/main/resource/otherConfig.xml")
                            public class MyConfiguration {}

                            @Configuration
                            @ImportResource("classpath:/otherConfig.xml")
                            public class MyConfiguration {}
                        li xml에서 @Configuration 임포트는 context:component-scan, context:component-scan 또는 그냥 bean 이용
                tr
                    td @DependsOn
                    td xml: depends-on
                    td: +goto('depends-on')
                tr
                    td @lookup
                    td xml: lookup-method
                    td: +goto('lookup-method')
                tr
                    td @RequestScope
                    td xml: scope="request"
                    td: +goto('scope 예')
                tr
                    td @SessionScope
                    td xml: scope="session"
                    td: +goto('scope 예')
                tr
                    td @ApplicationScope
                    td xml: scope="application"
                    td: +goto('scope 예')
                tr
                    td @Description
                    td xml: description
                    td 빈에 대한 설명(Optional)
                tr
                    td @EnableLoadTimeWeaving
                    td xml: context:load-time-weaver
                    td LoadTimeWeaverAware를 구현한 빈은 LoadTimeWeaver 인스턴스를 인자로 받는다
                        +goto('Spring AOP')

            h3 Environment
            ul
                li Environment 인터페이스는 profile, properties 정보를 컨테이너에 제공한다
                +pos('profile 표현식')
                li Profile 표현에 !(not), &amp;(and), |(or) 가능. 
                    +goto('@Profile')
                p 예. production &amp; (us-east | eu-central)
                    br
                    |xml 표현식에서 !는 가능하지만 &amp;, |는 포함할 수 없다. 대신 beans profiles=""를 중첩하여 &amp; 효과를 얻을 수는 있다
                li Profile 활성화
                +asCode('java').
                    context.getEnvironment().setDefaultProfiles("profile1", "profile2")
                    context.getEnvironment().setActiveProfiles("profile1", "profile2")
                +asCode('shell') $ env "spring.profiles.active=profile1,profile2"
                +asCode('shell') $ java ... -Dspring.profiles.active="profile1,profile2"
                li 제공할 수 있는 properties 타입
                p properties 파일, JNDI, Servlet context parameter, Properties 인스턴스, Map 인스턴스
                li StandardEnvironment(→ AbstractEnvironment) 기본으로 포함되는 properties 항목들
                p JVM system properties (System.getProperties()) + 환경 변수 (System.getenv()). 시스템 속성이 환경 변수보다 우선 검색된다
                li StandardServletEnvironment(→ StandardEnvironment) 추가 제공 properties
                p Servlet config + Servlet context parameter + JndiPropertySource(Optional).
                    br
                    |우선 순위 : ServletConfig ← ServletContext parameter ← JNDI ← JVM system properties ← 환경 변수
                li PropertySource 추가
                +asCode('java', '수동 추가').
                    var sources = context.getEnvironment().getPropertySources();
                    sources.addFirst(new PropertySource(...));
                    sources.addLast(new PropertySource(...));
                    // ResourcePropertySource, PropertiesPropertySource 등 이용
                +asCode('java', '자동 추가').
                    @Configuration
                    @PropertySource("classpath:io/github/donggi/${spring.profiles.active:localhost}.properties")
                    @PropertySource(value="classpath:io/github/donggi/more/${spring.profiles.active:localhost}.properties", ignoreResourceNotFound=true)
                    public class AppConfig {}

            h3 ApplicationContext 추가 기능
            div
                h4 국제화; ApplicationContext → MessageSource
                ul
                    li HierarchicalMessageSource 인터페이스는 부모의 것을 상속한다
                    li 문자열 획득
                    +asCode('java').
                        String getMessage(String code, Object[] args[, String default], Locale loc)
                        String getMessage(MessageSourceResolvable resolvable, Locale locale)
                    li MessageSource 탐색
                    ol
                        li ApplicationContext는 자동으로 "messageSource" 이름의 MessageSource 빈을 찾는다
                        li 없는 경우 부모 컨텍스트에서 해당하는 빈을 찾는다
                        li 없는 경우 DelegatingMessageSource 인스턴스로 설정
                    li MessageSource 구현 클래스
                    ul
                        li StaticMessageSource : 코드로 등록
                        li ResourceBundleMessageSource : 리소스 파일 로드
                        li ReloadableResourceBundleMessageSource : 주기적으로 리소스 파일 변경 확인(classpath: 리소스 제외)
                    li *.properties 네이밍 규칙
                    ul
                        li Locale ENGLISH = createConstant("en", ""); → xxx_en.properties
                        li Locale US = createConstant("en", "US"); → xxx_en_US.properties
                    li 예시 코드 
                        +codeBtn('/Repositories/STS/ioc-example/src/main/java/io/github/donggi/example/config/I18nConfig.java', 'java', [8]) Configuration
                        +codeBtn('/Repositories/STS/ioc-example/src/main/resources/i18n/templates_en.properties', 'properties') templates_en.properties
                        +codeBtn('/Repositories/STS/ioc-example/src/main/resources/i18n/templates_ko.properties', 'properties') templates_ko.properties
                        +codeBtn('/Repositories/STS/ioc-example/src/test/java/io/github/donggi/example/config/I18nTests.java', 'java', [11]) Test
                h4 이벤트 Pub/Sub
                ul
                    li 이벤트 정의 : ApplicationEvent
                    li 이벤트 리스너 : ApplicationListener 또는 @EventListener(Since 4.2)
                    li 내장 이벤트
                    table.w3-table-all.w3-card.w3-small
                        +ths('Event', '요약')
                        +tds('ContextRefreshedEvent', 'ApplicationContext 초기화 또는 갱신(refresh) 완료')
                        +tds('ContextStartedEvent', 'ConfigurableApplicationContext#start()')
                        +tds('ContextStoppedEvent', 'ConfigurableApplicationContext#stop()')
                        +tds('ContextClosedEvent', 'ConfigurableApplicationContext#close() 또는 JVM 종료')
                        +tds('RequestHandledEvent', 'HTTP 요청 처리 완료')
                        +tds('ServletRequestHandledEvent', 'RequestHandledEvent + 서블릿 정보')
                    li 예시 
                        +codeBtn('/Repositories/STS/ioc-example/src/main/java/io/github/donggi/example/event/MyEvent1.java', 'java', [7]) Event
                        +codeBtn('/Repositories/STS/ioc-example/src/main/java/io/github/donggi/example/event/MyEvent1Publisher.java', 'java', [7]) Publisher
                        +codeBtn('/Repositories/STS/ioc-example/src/main/java/io/github/donggi/example/event/MyEvent1Listener1.java', 'java', [8]) Listener
                        +codeBtn('/Repositories/STS/ioc-example/src/test/java/io/github/donggi/example/event/Event1Tests.java', 'java', [8]) Test
                    li @EventListener 예시 
                        +codeBtn('/Repositories/STS/ioc-example/src/main/java/io/github/donggi/example/event/MyEvent2.java', 'java', [7]) Event
                        +codeBtn('/Repositories/STS/ioc-example/src/main/java/io/github/donggi/example/event/MyEvent2Publisher.java', 'java', [7]) Publisher
                        +codeBtn('/Repositories/STS/ioc-example/src/main/java/io/github/donggi/example/event/MyEvent2Listener1.java', 'java', [8]) Listener1
                        +codeBtn('/Repositories/STS/ioc-example/src/main/java/io/github/donggi/example/event/MyEvent2Listener2.java', 'java', [8]) Listener2
                        +codeBtn('/Repositories/STS/ioc-example/src/test/java/io/github/donggi/example/event/Event2Tests.java', 'java', [8]) Test
                    li 이벤트 핸들러가 다른 이벤트를 반환하는 경우, 해당 이벤트가 발행된다. 이벤트에 대한 컬렉션을 반환하면, 각각이 모두 발행된다
                    p 단, @Async 메서드는 수동으로 발행해야 한다
                    li @Order로 리스너 호출 순서를 제어할 수 있다
                    li @EventListener > condition에 사용 가능한 SpEL 이벤트 메타데이터
                    table.w3-table-all.w3-card.w3-small
                        +ths('code', 'description')
                        +tds('#root.event, event', 'ApplicationEvent 인스턴스')
                        +tds('#root.args, args', '메서드 파라미터 배열')
                        +tds('#name, #a0, #p0', '이름 또는 인덱스로 지정한 메서드 파라미터')
                h4 ApplicationContext → ResourceLoader
                ul
                    li Resource ::= java.net.URL을 포함한 클래스 패스 또는 파일 시스템 상의 리소스
                    li ApplicationContext는 그 자체로 ResourceLoader며, 저수준 Resource 획득을 쉽게 해준다
                    li ResourceLoaderAware를 구현한 빈들은 초기화 시 ApplicationContext를 ResourceLoader로 전달받는다
                    li ClassPathXmlAPplicationContext에 간단한 경로로 리소스를 질의하는 경우, 클래스 패스 상의 리소스를 찾는다
                    p 애매한 경우, 명시적으로 classpath:, file: 등 URL을 지정해야 한다

        h2 Resources
        div
            h3 Resource
            +asCode('java').
                boolean             exists()            // 리소스의 실재 여부는 이 메서드로 확인해야 한다
                boolean             isReadable()
                boolean             isOpen()            // InputStream이 이미 열렸는지 여부
                                                        // true면 InputStream을 한 번만 읽고 닫아야 한다
                boolean             isFile()

                URL                 getURL()
                URI                 getURI()
                File                getFile()
                    long            contentLength()
                    long            lastModified()
                    String          getFilename()
                    String          getDescription()

                InputStream         getInputStream()    // from InputStreamSource
                                                        // 매 호출마다 새로운 InputStream을 반환한다고 가정해도 된다
                ReadableByteChannel readableChannel()   // Channels.newChannel(getInputStream())

                Resource            createRelative(String relativePath)
            h3 내장 Resource 구현클래스
            ul
                li UrlResource
                p classpath:, file:, http:, ftp: 등 일반적인 스킴 모두 지원
                li ClassPathResource
                p 클래스패스 상의 리소스
                li FileSystemResource
                p 파일 시스템 상의 리소스
                li ServletContextResource
                p 웹앱 루트 디렉터리를 기준으로 한 상대 경로 상의 리소스
                li InputStreamResource
                p 지정 IputStream으로부터 Resource 생성. isOpen()이 true를 반환한다. 다른 구현체를 이용할 수 있다면 그쪽을 사용하는 편이 좋다
                li ByteArrayResource
                p 주어진 byte 배열로부터 Resource 생성. 여러번 읽기 가능
            h3 ResourceLoader
            +asCode('java').
                static String       CLASSPATH_URL_PREFIX    // "classpath:"

                ClassLoader         getClassLoader()
                Resource            getResource(String location)
                    // 스킴을 지정하지 않은 경우, 각 ApplicationContext 구현체는 서로 다른 Resource를 찾아 반환한다
                    // 예. ClassPathXmlApplicationContext -> ClassPathResource
                    // 예. FileSystemXmlApplicationContext  -> FileSystemResource
                    // 예. WebApplicationContext -> ServletContextResource
            h3 Resource 주입
            ul
                li XML Configuration에서, Resource 타입 property의 value로 URL 문자열이 가능하다
                li 일반적으로 ApplicationContext 생성자 자체도 URL 문자열 (배열)로 초기화 가능하다
                li ClassPathXmlApplicationContext 생성자에 클래스와 파일명 배열을 같이 보내면, 자동으로 클래스 위치에서 파일을 찾는다
                li ApplicationContext 생성자 및 PathMatcher 유틸리티 클래스는 와일드카드를 사용할 수 있다
                ul
                    li "file:C:/some/path/*-context.xml", "classpath*:com/mycompany/**/applicationContext.xml"
                    li XML관련 ApplicationContext는 "classpath*:" 접두를 사용할 수 있다. 의미는 모든 클래스패스 리소스 검색
                    +asCode('java') new ClassPathXmlApplicationContext("classpath*:conf/appContext.xml");
                    p 내부적으로 ClassLoader.getResources()를 이용한다. jar 파일에서 리소스를 로드하는 경우, getClass().getClassLoader().getResources()를 직접 호출했을 때와 비교하여 차이가 있으면 서버 설정을 조정하거나 해야 한다
                    li "jar:" 리소스들은 java.net.JarURLConnection을 필요로 하기 때문에, 일부 환경에서 실패할 수 있음에 유의
                li 이전 버전과의 호환성을 위해, FileSystemApplicationContext 자체가 ResourceLoader 역할을 하는 경우, 절대 경로도 상대 경로로 해석함에 유의
                p 절대 경로로 리소스를 지정하려면 "file:///path/file.ext" 처럼 "file:" 접두를 사용해 UrlResource로 가져오도록 해야 한다

        h2 데이터 검증, 바인딩, 타입 변환
        div
            h3 Validator를 이용한 검증
            +asCode('java').
                boolean supports(Class&lt;?&gt; clazz)
                    // 전형적으로 MyTargetClass.class.isAssignableFrom(clazz)
                void validate(Object target, Errors errors)
                    // Errors.reject*()를 이용해 오류 정보 전달
                    // Errors의 각 거부 항목들은 이름-에러코드 쌍으로 구성된다. 예. ("x", "is.null")
                    // DefaultMessageCodesResolver는 에러 정보를 토대로 새 에러코드도 등록한다
                    //      예. ("x", "is.null") → is.null.x, is.null.float, is.null
                    //      이를 이용해 MessageSource로부터 보다 적절한 메시지를 가져올 수 있다
                    // ValidationUtils를 이용하면 구현에 도움이 된다
            ul
                li 예시 코드 
                    +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/anno/Anno29.java', 'java', [19]) Bean
                    +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/anno/anno29_ko.properties', 'properties') message
                    +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/anno/Anno29Test.java', 'java', [8]) Context
                li Spring MVC 예 
                    +codeBtn('/Repositories/STS/mvc-java18/src/main/java/io/github/donggi/mvc/config/AppConfig.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/mvc-java18/src/main/java/io/github/donggi/mvc/controller/Login.java', 'java', [21], true)
                    +codeBtn('/Repositories/STS/mvc-java18/src/main/java/io/github/donggi/mvc/validator/LoginRequestValidator.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/mvc-java18/src/main/resources/i18n/msg.properties', 'properties', null, true)
            h3 애너테이션 기반 검증
            ul
                li
                    +asA('https://beanvalidation.org/', 'Java Bean Validation API')
                    +pos('Bean Validation')
                    |예 
                    +codeBtn('/Repositories/STS/spring-core/src/main/java/io/github/donggi/bean/Test2Bean.java', 'java', [9]) Bean1
                    +codeBtn('/Repositories/STS/spring-core/src/main/java/io/github/donggi/bean/Test2Bean2.java', 'java', [10]) Bean2
                    +codeBtn('/Repositories/STS/spring-core/src/main/java/io/github/donggi/bean/Test2Bean3.java', 'java', [8]) Bean3
                    +codeBtn('/Repositories/STS/spring-core/src/main/java/io/github/donggi/anno/Test2Constraint.java', 'java', [14]) Test2Constraint
                    +codeBtn('/Repositories/STS/spring-core/src/main/java/io/github/donggi/config/Test2Config.java', 'java', [14]) Config
                    +codeBtn('/Repositories/STS/spring-core/src/test/java/io/github/donggi/Test2.java', 'java', [17]) Test
            h3 BeanWrapper의 프로퍼티 주입
            ul
                li BeanWrapper는 단일/벌크 프로퍼티 설정을 위한 연산을 정의하며, BeanWrapperImpl은 가장 기본적으로 사용되는 구현 클래스다
                +asCode('java').
                    var person = new BeanWrapperImpl(new Person());
                    person.setPropertyValue("name", "my name");
                    var realPerson = person.getWrappedInstance();
                li 프로퍼티 경로는 구분자를 이용한 무제한 확장이 가능하다
                table.w3-table-all.w3-card.w3-small
                    +tds('prop', 'prop 이름의 필드를 가리킨다. 접근 메서드는 getProp() or isProp(), setProp()')
                    +tds('prop1.prop2', 'prop1 필드의 prop2 필드. 접근 메서드는 getProp1().getProp2() or getProp1().isProp2(), getProp1().setProp2()')
                    +tds('prop[2]', 'prop 이름의 배열, List, 기타 ordered collection')
                    +tds('prop[key]', 'prop 이름의 Map')
            h3 PropertyEditor의 Object ↔ String 변환
            ul
                li Something 클래스와 같은 패키지에 PropertyEditor를 구현한 SomethingEditor가 존재하면 자동으로 사용된다
                p 예시 코드 
                    +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/anno/Anno30.java', 'java', [8]) Bean
                    +codeBtn('/Repositories/STS/app2/src/main/java/io/github/donggi/anno/Anno30DataEditor.java', 'java', [5]) Editor
                    +codeBtn('/Repositories/STS/app2/src/test/java/io/github/donggi/anno/Anno30Test.java', 'java', [8]) Context
                li 내장 PropertyEditor 구현체
                table.w3-table-all.w3-card.w3-small
                    +ths('Class', '설명')
                    +tds('ByteArrayPropertyEditor', 'String → byte[]. BeanWrapperImpl 기본 등록')
                    +tds('ClassEditor', 'String(클래스 경로) ↔ Class. BeanWrapperImpl 기본 등록')
                    +tds('FileEditor', 'String(파일 경로) → File. BeanWrapperImpl 기본 등록')
                    +tds('InputStreamEditor', 'String(리소스 경로) → InputStream. BeanWrapperImpl 기본 등록; InputStream을 알아서 닫아주지는 않는다')
                    +tds('LocaleEditor', 'String ↔ Locale. BeanWrapperImpl 기본 등록')
                    +tds('PropertiesEditor', 'String → Properties. BeanWrapperImpl 기본 등록')
                    +tds('URLEditor', 'String → URL. BeanWrapperImpl 기본 등록')

                    +tds('CustomBooleanEditor', 'String ↔ Boolean. BeanWrapperImpl 기본 등록 & 덮어쓰기 가능')
                    +tds('CustomNumberEditor', 'String ↔ Number. BeanWrapperImpl 기본 등록 & 덮어쓰기 가능')

                    +tds('CustomCollectionEditor', 'source Collection → target Collection')
                    +tds('CustomDateEditor', 'String ↔ Date. 커스텀 DateFormat 사용 가능.')
                    +tds('PatternEditor', 'String ↔ Pattern')
                    +tds('StringTrimmerEditor', 'String → Trimmed string. (Option) "" → null')
                li 사용자 정의 PropertyEditor를 BeanWrapper 또는 IoC container에 등록하여 사용할 수 있다
                +asCode('java', 'SomethingEditor.java').
                    public class SomethingEditor extends PropertyEditorSupport {
                        public void setAsText(String text) {
                            setValue(new Something(text));
                        }
                    }
                ul
                    li CustomEditorConfigurer 이용 : 중첩 프로퍼티 설정도 해준다
                    +asCode('xml', 'config.xml').
                        &lt;bean class="org.springframework.beans.factory.config.CustomEditorConfigurer">
                            &lt;property name="customEditors">
                                &lt;map>
                                    &lt;entry key="package.Something" value="package.SomethingEditor"/>
                                &lt;/map>
                            &lt;/property>
                        &lt;/bean>
                    +asCode('java', 'Config.java').
                        @Bean
                        public CustomEditorConfigurer customEditorConfigurer() {
                            var c = new CustomEditorConfigurer();
                            var map = new HashMap&lt;Class&lt;?>, Class&lt;? extends PropertyEditor>>();
                            map.put(Something.class, SomethingEditor.class);
                            c.setCustomEditors(map);
                            return c;
                        }
                    li PropertyEditorRegistrar 이용 : 사용 시마다 새 PropertyEditor 인스턴스를 만들기 때문에 동기화 걱정 없음
                    +asCode('java', 'CustomPropertyEditorRegistrar.java').
                        public class CustomPropertyEditorRegistrar implements PropertyEditorRegistrar {
                            public void registerCustomEditors(PropertyEditorRegistry registry) {
                                registry.registerCustomEditor(Something.class, new SomethingEditor());
                            }
                        }
                    +asCode('java', 'Config.java').
                        @Bean
                        public PropertyEditorRegistrar customPropertyEditorRegistrar() {
                            return new CustomPropertyEditorRegistrar();
                        }
                        @Bean
                        public CustomEditorConfigurer customEditorConfigurer() {
                            var c = new CustomEditorConfigurer();
                            c.setPropertyEditorRegistrars(new PropertyEditorRegistrar[] { customPropertyEditorRegistrar() });
                            return c;
                        }
                    li ConfigurableBeanFactory.registerCustomEditor()
            h3 타입 변환
            ul
                li core.convert 서브 패키지는 타입 변환 시스템을 제공한다. PropertyEditor 대신 이용해도 좋다
                +asCode('java', 'interface Converter<S, T>') T convert(S source);
                ul
                    li source는 non-null임이 보장된다
                    li 실패한 경우 IllegalArgumentException을 던지면 된다
                    li convert 메서드는 스레드-안전해야 한다
                    li core.convert.support 서브 패키지에서 여러 범용 컨버터를 제공한다
                li 동일 소스로부터 여러 타입으로의 변환이 필요한 경우 ConverterFactory를 이용하면 좋다
                +asCode('java', 'interface ConverterFactory<S, R>') &lt;T extends R&gt; Converter&lt;S, T&gt; getConverter(Class&lt;T&gt; targetType);
                li n:m 변환을 한번에 지원하려면 GenericConverter가 유용할 수 있다
                +asCode('java', 'interface GenericConverter').
                    Set&lt;ConvertiblePair&gt; getConvertibleTypes();
                    Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);
                +asCode('java', 'TypeDescriptor 헬퍼 메서드').
                    List&lt;Integer&gt; list;
                    conversionService.convert(list,
                            TypeDescriptor.forObject(input),                                                // List&lt;Integer>
                            TypeDescriptor.collection(List.class, TypeDescriptor.valueOf(String.class)))    // List&lt;String>
                li ConditionalGenericConverter : 특정 조건을 만족할 때만 변환
                +asCode('java', 'interface ConditionalConverter') boolean matched(TypeDescriptor sourceType, TypeDescriptor targetType);
                li 각 컨버터는 ConversionService 뒤에서 실행된다
                +asCode('java', 'interface ConversionService').
                    boolean canConvert(Class&lt;?> sourceType, Class&lt;?> targetType);
                    &lt;T> T convert(Object source, Class&lt;T> targetType);
                    boolean canConvert(TypeDescriptor sourceType, TypeDescriptor targetType);
                    Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);
                ul
                    li 대부분의 ConversionService 구현 클래스들은 ConverterRegistry 역시 구현하며, 이를 통해 컨버터를 등록할 수 있다
                    li core.convert.support 서브 패키지에서 일반적인 GenericConversionService 클래스를 제공한다
                    li core.convert.support 서브 패키지에서 ConversionService 생성을 위한 ConversionServiceFactory 클래스를 제공한다
                    li IoC 컨테이너에 설정된 ConversionService는 관리되는 임의 빈에서 직접 사용할 수 있다
                +asCode('xml', '기본 ConversionService 등록') &lt;bean class="org.springframework.context.support.ConversionServiceFactoryBean"/>
                +asCode('xml', '기본 + 사용자 컨버터 추가').
                    &lt;bean class="org.springframework.context.support.ConversionServiceFactoryBean">
                        &lt;property name="converters">
                            &lt;set>
                                &lt;bean class="example.MyCustomConverter"/>
                            &lt;/set>
                        &lt;/property>
                    &lt;/bean>
            h3 Field Formatting
            +asCode('java').
                interface Formatter&lt;T&gt; extends Printer&lt;T&gt;, Parser&lt;T&gt; {}
                interface Printer&lt;T&gt; {
                    String print(T fieldValue, Locale locale);
                }
                interface Parser&lt;T&gt; {
                    T parse(String clientValue, Locale locale) throws ParseException;
                }
            ul
                li Formatter는 스레드-안전해야 한다
                li format 서브 패키지에서 여러 Formatter 구현체를 제공한다
                p NumberStyleFormatter, PercentStyleFormatter, DateFormatter, ...
                li FormatterRegistry, FormatterRegistrar : 포매터 등록을 위한 인터페이스
                +asA('https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/web.html#mvc-config-conversion')
                li Annotation-driven Formatting
                p AnnotationFormatterFactory를 이용한다. 예시 코드 
                    +codeBtn('/Repositories/STS/spring-core/src/main/java/io/github/donggi/bean/Test1Bean.java', 'java', [10]) Bean
                    +codeBtn('/Repositories/STS/spring-core/src/main/java/io/github/donggi/anno/Test1FormatAnnotationFormatterFactory.java', 'java', [16]) FormatterFactory
                    +codeBtn('/Repositories/STS/spring-core/src/main/java/io/github/donggi/config/Test1Config.java', 'java', [14]) Config
                    +codeBtn('/Repositories/STS/spring-core/src/test/java/io/github/donggi/Test1.java', 'java', [16]) Test

        h2 SpEL; Spring Expression Language
        div
            h3 표현식 평가
            +asCode('java').
                var parser = new SpelExpressionParser();
                var exp = parser.parseeExpression("'Hello World'");
                exp = parser.parseeExpression("'Hello World'.concat('!')");          // concat()
                exp = parser.parseeExpression("'Hello World'.bytes");                // getBytes()
                exp = parser.parseeExpression("new String('Hello World').bytes.length");

                parser.parseExpression("name").getValue(String.class);               // get result value as String
                parser.parseExpression("name").getValue(obj);                        // get obj.name via obj.getName()
                parser.parseExpression("name == 'Bob'").getValue(obj, Boolean.class) // get (obj.getName().equals("Bob"))
            p 속도 향상을 위해 컴파일러를 켤 수 있다
            +asCode('java').
                new SpelParserConfiguration(SpelCompilerMode.IMMEDIATE, ...);
                // OFF(default), IMMEDIATE(즉시 컴파일), MIXED(나중에 컴파일, 컴파일 표현식 실패 시 다시 인터프리팅 해석)
                // 또는 시스템 속성 spring.expression.compiler.mode=off|immediate|mixed 로도 설정 가능

                // 4.1 제약사항
                // * 할당 문장 사용 불가
                // * Conversion service 의존 문장 사용 불가
                // * 사용자 정의 resolver, accessor 사용 불가
                // * Selection, projection  불가
            h3 빈 정의 표현식
            p
                strong &#x23;{ 표현식 }
                |으로 빈을 정의할 수 있다
            +asCode('xml').
                &lt;property value="&#x23;{ T(java.lang.Math).random() * 100 }"/>
                &lt;!-- 컨텍스트 상에 정의된 다른 모든 빈을 참조할 수 있다 -->
                &lt;property value="&#x23;{ systemProperties['user.region'] }"/>
                &lt;property value="&#x23;{ myBean.someProp }"/>
            +asCode('java') @Value("&#x23;{ systemProperties['user.region'] }")
            h3 표현식 문법
            div
                h4 Literal
                +asCode().
                    &#x23;{ 'Text' }
                    &#x23;{ '3.14e+15' }
                    &#x23;{ '0x7fff' }
                    &#x23;{ 'true' }
                    &#x23;{ 'null' }
                h4 Properties, Arrays, Lists, Maps, Indexers
                +asCode().
                    &#x23;{ list[3].arr[3][3] }
                    &#x23;{ map['key'] }
                    &#x23;{ {1, 2, 3} }                    // inline list
                    &#x23;{ {} }                           // empty list
                    &#x23;{ {num: 1, date: '2020-02-02'} } // inline map
                    &#x23;{ {:} }                          // empty map
                    &#x23;{ new int[] {1, 2, 3} }          // 배열 생성자 호출 가능
                h4 Operators
                +asCode().
                    &#x23;{ 2 > null == true }                       // null은 다른 모든 것보다 작다고 간주
                    &#x23;{ 2 gt null eq true }
                        // lt(&lt;), gt(>), le(&lt;=), ge(>=), eq(==), ne(!=), div(/), mod(%), not(!), and(&amp;&amp;), or(||)
                    &#x23;{ 'text' instanceof T(java.lang.String) }  // 기본 타입들은 모두 래핑됨에 유의
                    &#x23;{ 'text' matches '^\\w+$' }
                    &#x23;{ T(java.math.RoundingMode).CEILING }      // static 멤버 접근 가능
                    &#x23;{ name?:'Anonymous' }                      // name != null ? name : "Anonymous"
                    &#x23;{ bean?.prop }                             // Null safe navigation
                h4 Variables, Functions
                +asCode().
                    &#x23;{ &#x23;variable }   // 변수 참조
                    &#x23;{ &#x23;this }       // 현재 컨텍스트
                    &#x23;{ &#x23;root }       // 루트 컨텍스트
                    &#x23;{ &#x23;funcName() } // 사용자 정의 함수 호출
                h4 Selection, Projection
                +asCode().
                    ${ collection.?[num > 123] } // selection
                    ${ collection.![num + 123] } // projection

        h2 Spring AOP
        +pos('Spring AOP')
        div
            h3 AOP 개념
            ol
                li Aspect : 횡단 관심사. 로깅/보안 등, 여러 객체를 가로질러 공통적으로 사용되는 모듈/기능
                li Join Point : Aspect 실행 지점
                li Advice : Join Point에서 실행되는 코드
                li Pointcut : 일치하는 Join Point에 대한
                    +asA('https://www.eclipse.org/aspectj/doc/next/progguide/semantics-pointcuts.html', '정규 표현식')
                |Advice는 Pointcut과 연관되며, 일치하는 모든 Join Point에서 실행된다
                li Weaving : Advice 코드를 삽입
                |세 가지 Weaving 방식 : 컴파일 타임 위빙, 클래스 로드 타임 위빙, 런타임 위빙

            h3 Spring AOP
            ul
                li Spring은 프록시를 만들어 Aspect의 실행을 삽입한다
                p 따라서 final이거나, 정의되지 않은 메서드는 Aspect 삽입이 불가능하다
                li JDK 프록시는 public 인터페이스 메서드만, CGLIB 프록시는 public, protected 인터페이스/클래스 메서드에 삽입 가능
                +asCode('java', 'CGLIB 고정 - java') @EnableAspectJAutoProxy(proxyTargetClass=true)
                +asCode('xml','CGLIB 고정 - xml').
                    &lt;aop:config proxy-target-class="true">&lt;/aop:config>
                    &lt;aop:aspectj-autoproxy proxy-target-class="true"/>
                li 프록시가 새 인터페이스를 구현하도록 변경(Introduction)하는 것은 가능하다
                li Aspect 적용 순서 정의
                p @Order(xml에서는 order 속성)를 적용하거나 Ordered 인터페이스 구현

                li.marker 지원하는 advice
                table.w3-table-all.w3-card.w3-small
                    +ths('종류','aop 태그','적용 시점')
                    +tds('Before','aop:before','메서드 실행 전')
                    +tds('After Returning','aop:after-returning','메서드 정상 종료 후')
                    +tds('After Throwing','aop:after-throwing','메서드 예외 throw시 적용')
                    +tds('After','aop:after','after-returning + after-throwing')
                    +tds('Around','aop:around','before + after')
                li.marker 지원하는 pointcut 지시자
                table.w3-table-all.w3-card.w3-small
                    +ths('Designator', '설명')
                    +tds('bean', '특정 빈에 정의된 메서드 호출. id or name 지정. 와일드카드 * 사용 가능')
                    +tds('execution', '특정 메서드 호출')
                    +tds('within', '특정 타입들에 정의된 메서드 호출')
                    +tds('this', '특정 타입 AOP 프록시 인스턴스에 정의된 메서드 호출')
                    +tds('target', '특정 타입 인스턴스에 정의된 메서드 호출')
                    +tds('args', '인자가 특정 타입 인스턴스들인 메서드 호출')
                    +tds('@annotation', '특정 애너테이션이 붙은 메서드 호출')
                    +tds('@within', '특정 애너테이션이 타입들에 정의된 메서드 호출')
                    +tds('@target', '특정 애너테이션이 붙은 클래스 인스턴스에 정의된 메서드 호출')
                    +tds('@args', '인자에 특정 애너테이션이 붙은 메서드 호출')
                ul
                    li Pointcut 표현식에 &amp;&amp;, ||, ! 사용 가능
                    li Pointcut 표현식에 이름 사용 가능
                    +asCode('java').
                        @Pointcut("execution(public * *(..))")
                        private void anyPublicOperation() {} 
                        @Pointcut("within(com.xyz.someapp.trading..*)")
                        private void inTrading() {} 
                        @Pointcut("anyPublicOperation() &amp;&amp; inTrading()")
                        private void tradingOperation() {} 
                    li public Pointcut 표현식은 외부에서도 이용 가능하므로, 정의를 중앙화할 수 있다
                    li execution 표현식
                    +asCode().
                        execution(modifires-pattern? return-type-pattern declaring-type-pattern?name-pattern(param-pattern) throws-pattern?)
                            return-type-pattern     *는 임의 반환 타입에 매칭
                            declaring-type-pattern  메서드가 정의된 타입 지정. 마지막은 '.'으로 끝나야 한다
                            name-pattern            메서드 이름 지정
                            param-pattern           ()는 무인자, (..)는 임의 타입 및 길이 인자, (*)는 해당 자리의 임의 타입 인자
                li.marker 각 advice별 예시 코드(XML)
                table.w3-table-all.w3-card.w3-small
                    tr
                        td Before
                        td
                            +codeBtn('/Repositories/Eclipse/spring-aop/src/main/java/io/github/donggi/advice/BeforeAdvice.java', 'java', [7]) Advice
                            +codeBtn('/Repositories/Eclipse/spring-aop/src/test/resources/beans/Beans2.xml', 'xml') Config
                            +codeBtn('/Repositories/Eclipse/spring-aop/src/test/java/io/github/donggi/advice/BeforeAdviceTest.java', 'java', [7]) Test
                            br
                            |Before advice에서 예외를 던지면 실제 메서드는 호출되지 않는 효과가 있다
                    tr
                        td After returning
                        td
                            +codeBtn('/Repositories/Eclipse/spring-aop/src/main/java/io/github/donggi/advice/AfterAdvice.java', 'java', [3]) Advice
                            +codeBtn('/Repositories/Eclipse/spring-aop/src/test/resources/beans/Beans3.xml', 'xml') Config
                            +codeBtn('/Repositories/Eclipse/spring-aop/src/test/java/io/github/donggi/advice/AfterAdviceTest.java', 'java', [7]) Test
                    tr
                        td After throwing
                        td
                            +codeBtn('/Repositories/Eclipse/spring-aop/src/main/java/io/github/donggi/advice/AfterAdvice2.java', 'java', [3]) Advice
                            +codeBtn('/Repositories/Eclipse/spring-aop/src/test/resources/beans/Beans4.xml', 'xml') Config
                            +codeBtn('/Repositories/Eclipse/spring-aop/src/test/java/io/github/donggi/advice/AfterAdviceTest2.java', 'java', [7]) Test
                    tr
                        td After
                        td
                            +codeBtn('/Repositories/Eclipse/spring-aop/src/main/java/io/github/donggi/advice/AfterAdvice3.java', 'java', [5]) Advice
                            +codeBtn('/Repositories/Eclipse/spring-aop/src/test/resources/beans/Beans5.xml', 'xml') Config
                            +codeBtn('/Repositories/Eclipse/spring-aop/src/test/java/io/github/donggi/advice/AfterAdviceTest3.java', 'java', [7]) Test
                    tr
                        td Around
                        td
                            +codeBtn('/Repositories/Eclipse/spring-aop/src/main/java/io/github/donggi/advice/TimerAdvice.java', 'java', [5]) Advice
                            +codeBtn('/Repositories/Eclipse/spring-aop/src/test/resources/beans/Beans1.xml', 'xml') Config
                            +codeBtn('/Repositories/Eclipse/spring-aop/src/test/java/io/github/donggi/advice/TimerAdviceTest.java', 'java', [7]) Test
                li.marker 각 advice별 예시 코드(@Aspect)
                +asCode('java', '@Aspect 켜기 - Java').
                    @Configuration
                    @EnableAspectJAutoProxy
                +asCode('xml', '@Aspect 켜기 - XML') &lt;aop:aspectj-autoproxy/>
                table.w3-table-all.w3-card.w3-small
                    tr
                        td Before
                        td
                            +codeBtn('/Repositories/Eclipse/spring-aop/src/main/java/io/github/donggi/aspect/BeforeAspect.java', 'java', [9]) Aspect
                            +codeBtn('/Repositories/Eclipse/spring-aop/src/test/resources/beans/Beans7.xml', 'xml') Config
                            +codeBtn('/Repositories/Eclipse/spring-aop/src/test/java/io/github/donggi/advice/BeforeAdviceTest2.java', 'java', [7]) Test
                    tr
                        td After Returning
                        td
                            +codeBtn('/Repositories/Eclipse/spring-aop/src/main/java/io/github/donggi/aspect/AfterAspect.java', 'java', [7]) Aspect
                            +codeBtn('/Repositories/Eclipse/spring-aop/src/test/resources/beans/Beans8.xml', 'xml') Config
                            +codeBtn('/Repositories/Eclipse/spring-aop/src/test/java/io/github/donggi/advice/AfterAdviceTest4.java', 'java', [7]) Test
                    tr
                        td After Throwing
                        td
                            +codeBtn('/Repositories/Eclipse/spring-aop/src/main/java/io/github/donggi/aspect/AfterAspect2.java', 'java', [7]) Aspect
                            +codeBtn('/Repositories/Eclipse/spring-aop/src/test/resources/beans/Beans9.xml', 'xml') Config
                            +codeBtn('/Repositories/Eclipse/spring-aop/src/test/java/io/github/donggi/advice/AfterAdviceTest5.java', 'java', [7]) Test
                    tr
                        td After
                        td
                            +codeBtn('/Repositories/Eclipse/spring-aop/src/main/java/io/github/donggi/aspect/AfterAspect3.java', 'java', [7]) Aspect
                            +codeBtn('/Repositories/Eclipse/spring-aop/src/test/resources/beans/Beans10.xml', 'xml') Config
                            +codeBtn('/Repositories/Eclipse/spring-aop/src/test/java/io/github/donggi/advice/AfterAdviceTest6.java', 'java', [7]) Test
                    tr
                        td Around
                        td
                            +codeBtn('/Repositories/Eclipse/spring-aop/src/main/java/io/github/donggi/aspect/AroundAspect.java', 'java', [8]) Aspect
                            +codeBtn('/Repositories/Eclipse/spring-aop/src/test/resources/beans/Beans6.xml', 'xml') Config
                            +codeBtn('/Repositories/Eclipse/spring-aop/src/test/java/io/github/donggi/advice/TimerAdviceTest2.java', 'java', [7]) Test
                li.marker execution 외 Pointcut 예시 코드
                table.w3-table-all.w3-card.w3-small
                    tr
                        td args XML 설정 예
                        td
                            +codeBtn('/Repositories/Eclipse/spring-aop/src/main/java/io/github/donggi/advice/BeforeAdvice2.java', 'java', [5]) Advice
                            +codeBtn('/Repositories/Eclipse/spring-aop/src/test/resources/beans/Beans11.xml', 'xml') Config
                            +codeBtn('/Repositories/Eclipse/spring-aop/src/test/java/io/github/donggi/advice/BeforeAdviceTest3.java', 'java', [7]) Test
                    tr
                        td args @Aspect 설정 예
                        td
                            +codeBtn('/Repositories/Eclipse/spring-aop/src/main/java/io/github/donggi/aspect/BeforeAspect2.java', 'java', [7]) Aspect
                            +codeBtn('/Repositories/Eclipse/spring-aop/src/test/resources/beans/Beans12.xml', 'xml') Config
                            +codeBtn('/Repositories/Eclipse/spring-aop/src/test/java/io/github/donggi/advice/BeforeAdviceTest4.java', 'java', [7]) Test
                    tr
                        td execution + args 예
                        td
                            +asCode('java', '즉시 이용').
                                @Before("com.xyz.myapp.SystemArchitecture.dataAccessOperation() &amp;&amp; args(account,..)")
                                public void validateAccount(Account account) { ... }
                            +asCode('java', 'Pointcut 지정').
                                @Pointcut("com.xyz.myapp.SystemArchitecture.dataAccessOperation() &amp;&amp; args(account,..)")
                                private void accountDataAccessOperation(Account account) {}

                                @Before("accountDataAccessOperation(account)")
                                public void validateAccount(Account account) { ... }
                    tr
                        td Generic args 예
                        td: +asCode('java').
                            public interface Sample&lt;T> {
                                void sampleGenericMethod(T param);
                                void sampleGenericCollectionMethod(Collection&lt;T> param);
                            }

                            @Before("execution(* ..Sample+.sampleGenericMethod(*)) &amp;&amp; args(param)")
                            public void beforeSampleMethod(MyType param) { ... } // ← 가능

                            @Before("execution(* ..Sample+.sampleGenericCollectionMethod(*)) &amp;&amp; args(param)")
                            public void beforeSampleMethod(Collection&lt;MyType> param) { ... } // ← 불가능
                li.marker Aspect 인스턴스화 종류
                ul
                    li default. 싱글톤
                    li perthis : 대상 메서드를 실행하는 프록시 인스턴스(this)마다 프록시 생성
                    +asCode('java').
                        @Aspect("perthis(com.xyz.myapp.SystemArchitecture.businessService())")
                        public class MyAspect { }
                    li pertarget : 대상 메서드를 실행하는 실제 인스턴스(target)마다 프록시 생성

        h2 Null-safety
        ul
            li @Nullable : 파리미터, 반환값, 필드가 null일 수 있음
            li @NonNull : 파리미터, 반환값, 필드가 null일 수 없음
            li @NonNullApi : 패키지 수준으로 파라미터, 반환값에 @NonNull 기본 적용
            li @NonNullFields : 패키지 수준으로 필드에 @NonNull 기본 적용

        h2 Data Bufferes and Codecs Since 5.0
        p java.nio 패키지에서 Buffer를 제공하지만, 여러 라이브러리들은 그전부터 자체적인 버퍼 api를 정의해 사용해왔다. 스프링은 이러한 불일치를 해소하기 위해 추상화된 API를 제공한다
        ul
            li DataBufferFactory
            p 2가지 방법으로 버퍼 생성이 가능하다. WebFlux에서는 ServerHttpResponse, ClientHttpRequest를 통해 팩터리에 접근한다
            ol
                li 새로운 버퍼를 생성. 최초 크기 지정 가능
                li 기존 byte[], java.nio.ByteBuffer를 래핑하여 생성
            li DataBuffer
            p java.nio.ByteBuffer와 유사한 기능에 더해 아래의 장점을 갖는다
            ul
                li flip() 사용없이 서로 다른 위치에 대해 읽기/쓰기 가능
                li 자동으로 capacity 증가
                li 버퍼에 대한 ByteBuffer, InputStream, OutputStream 뷰 제공
            li PooledDataBuffer
            p Direct 버퍼의 생성/소멸 시간이 Non-direct 버퍼에 비해 길다는 단점을 해소하기 위해 만들어졌다
                br
                |→ 버퍼에 대한 참조 카운터를 유지함으로써 버퍼를 재활용할 수 있게 해준다
                br
                |retain()으로 참조를 얻고, release()로 반환 → DataBufferUtils에서 편의 메서드 제공
            li DataBUfferUtils
            ul
                li 복사없이 두 버퍼를 하나로 연결하는 기능 제공
                li InputStream, Channel -> Flux&lt;DataBuffer> 변환, Publisher&lt;DataBuffer> -> OutputStream, Channel 변환 제공
                li PooledDataBuffer 획득/반환
            li Codecs
            ul
                li Encoder : Publisher&lt;T> -> Flux&lt;DataBuffer> 변환
                li Decoder : Publisher&lt;DataBuffer> -> Flux&lt;T> 변환
                li spring-core 모듈은 byte[], ByteBuffer, DataBuffer, Resource, String에 대한 인코더/디코더 구현을 제공한다
                li spring-web 모듈은 Jackson JSON, Jackson Smile, JAXB2 등에 대한 인코더/디코더 구현을 제공한다
            li DataBuffer 주의사항
            p 버퍼를 사용한 후엔 반드시 잘 반환해야 한다
            ul
                li Decoder가 각 버퍼를 읽고 바로 반환하는 경우 DataBufferUtils.release() 이용
                li Decoder가 Flux, Mono의 연산 ─ flatMap, reduce, filter, skip 등 ─ 을 이용하는 경우, 체인에 doOnDiscard(PooledDataBuffer.class, DataBufferUtils::release)를 결합하여 버퍼가 버려지기 전에 반환되도록 해야한다
                li 그 외의 경우, Decoder는 모든 읽기를 마치거나, 에러/취소 신호를 받는 경우 버퍼를 반환해야 한다
                li DataBufferUtils의 join, skipUntilByteCount, takeUntilByteCount는 decoder가 이용해도 안전하다
                li Encoder의 경우, 쓰기 작업에 예외가 발생한 경우 버퍼를 반환해야 한다

    details
        summary Spring 트랜잭션 사용하기
        ul
            li 관련 클래스
            p AbstractPlatformTransactionManager ← DataSourceTransactionManager(JDBC), HibernateTransactionManager, JtaTransactionManager
            li 예시 코드
            +codeBtn('/Repositories/Eclipse/spring-transaction/pom.xml', 'xml') pom.xml »
            +codeBtn('/Repositories/Eclipse/spring-transaction/src/main/resources/applicationContext.xml', 'xml') applicationContext.xml »
            +codeBtn('/Repositories/Eclipse/spring-transaction/src/main/java/io/github/donggi/service/NameService.java', 'java') NameService.java »
            +codeBtn('/Repositories/Eclipse/spring-transaction/src/test/java/Test.java', 'java') Test.java »
    hr
    details
        summary Spring JUnit
        +codeBtn('/Repositories/Eclipse/spring-transaction/src/test/java/Test.java', 'java') 예시 코드 1 »
        +codeBtn('/Repositories/Eclipse/spring-mvc/src/test/java/Test.java', 'java') 예시 코드 2 »
    hr
    details
        summary Spring Boot
        ul
            li 라이브러리 버전 관리, 로깅, DataSource 등의 일반적인 설정을 자동화하고, 사용자는 필요한 부분만 변경하면 된다
            li 톰캣 등 WAS 내장하여 실행 가능
            li 모듈화된 기능들을 
                +asA('https://start.spring.io/', '조합')
                |하여 빠르게 신규 프로젝트 시작 가능
        details
            summary Spring Boot Web Microservice
            ol
                li 예시 코드
                +codeBtn('/Repositories/STS/rest-microservice/pom.xml', 'xml') pom.xml
                +codeBtn('/Repositories/STS/rest-microservice/src/main/java/io/github/donggi/controller/HelloController.java', 'java') HelloController.java
                +codeBtn('/Repositories/STS/rest-microservice/src/test/java/io/github/donggi/controller/HelloControllerTest.java', 'java') HelloControllerTest.java
                li 스프링 부트 마이크로서비스는 실행에 필요한 모든 의존 라이브러리, HTTP 리스너 등을 하나의 jar로 패키징한다
                +w3img('/imgs/20191006_180335.png')
                +w3img('/imgs/20191006_180348.png')
                +w3img('/imgs/20191006_180401.png')
                li mvn install하면 bootJar가 빌드된다
                    br
                    |java -jar target/rest-microservice-0.0.1-SNAPSHOT.jar
        details
            summary Gradle 프로젝트 빌드 및 실행
            ol
                li bootRun 실행
                |gradle app-name:bootRun -Pprofile=dev
                li bootJar 빌드
                |gradle app-name:bootJar -x test
                li bootJar 실행
                |java -jar -Dspring.profiles.active=dev app-name.jar
            p multi project 구조에서 bootJar 빌드에 실패하는 경우
            ul
                li: +asA('https://stackoverflow.com/questions/47598848/spring-boot-multi-module-project-with-gradle-doesnt-build')
                li 부트 프로젝트가 아닌 프로젝트들에는 아래처럼 설정
                +asCode('gradle').
                    bootJar {
                        enabled = false
                    }

                    jar {
                        enabled = true
                    }

        details(open='')
            summary application.properties 서버 포트 지정
            |server.port=18080
            br
            |tomcatPort=18009
            br
            |tomcatRedirectPort=18443
        details
            summary Spring Config Server
            ol
                li Config Server 선택
                +w3img('/imgs/20191009_095724.png')
                li 예시 코드
                +codeBtn('/Repositories/STS/config-server/src/main/resources/bootstrap.properties', 'text') bootstrap.properties
                +codeBtn('/Repositories/STS/config-server/src/main/java/io/github/donggi/ConfigServerApplication.java', 'java') @EnableConfigServer
                +codeBtn('/Repositories/Config/webapp.properties', 'text') webapp.properties
                p 설정 저장소는 .properties나 .yml 파일들을 이루어진 디렉터리로, Git, Subversion, 로컬 디렉터리 모두 가능하다
                p 설정 저장소에 있는 application.properties 또는 .yml은 공통 설정으로써 모든 config 클라이언트에게 전달된다
                p Basic 인증 추가 : spring-boot-starter-security 의존성 추가하고 security.user.name, security.user.password 설정
                li 접근 예
                |http://localhost:28888/webapp/default
                br
                |http://localhost:28888/webapp/default/master/test.xml
                ul
                    li /{application}/{profile}[/{label}]
                    li /{application}-{profile}.yml
                    li /{label}/{application}-{profile}.yml
                    li /{application}-{profile}.properties
                    li /{label}/{application}-{profile}.properties
                    +w3img('/imgs/20191009_115402.png')
                li 갱신 : http://localhost:28888/actuator/refresh
        details
            summary Spring Config Client
            ol
                li Config Client, Actuator 선택
                +w3img('/imgs/20191009_124833.png')
                li 예시 코드
                +codeBtn('/Repositories/Config/config-client.properties', 'text') config-client.properties
                +codeBtn('/Repositories/STS/config-client/src/main/resources/bootstrap.properties', 'text') bootstrap.properties
                +codeBtn('/Repositories/STS/config-client/src/main/java/io/github/donggi/controller/HelloController.java', 'java') HelloController.java
                p bootstrap.properties 파일은 application.properties 보다 먼저 로딩된다
                li 접근 예 http://localhost:18888/hello
                +w3img('/imgs/20191009_122755.png')
                li 갱신 : POST http://localhost:18888/actuator/refresh
                |http://localhost:18888/actuator/에 접속했을 때 /refresh가 보이지 않는다면 management.security.enabled=false, management.endpoints.web.exposure.include=* 2개 설정 확인
                +w3img('/imgs/20191009_124710.png')
                +w3img('/imgs/20191009_124647.png')
            h2 설정 새로고침
            ul
                li 대상 컴포넌트에 @RefreshScope 적용
                p 새로고침 이벤트(RefreshScopeRefreshed)가 발생할 때마다 대상 컴포넌트는 설정을 새로 읽는다 <- 기본적으로 빈을 폐기하고 새로 생성한다
                li RefreshScopeRefreshed 이벤트는 스프링 부트 actuator가 제공하는 http://127.0.0.1/refresh에 본문없는 POST 요청을 보내는 걸로 가능하다
                p 또는 spring-cloud-bus를 이용해 자동화할 수 있다 <- 내부적으로 스프링 클라우드 스트림(RabbitMQ, Apache Kafka 등의 추상화) 이용
        details
            summary Spring Security
            h2 AuthenticationManager
            ul
                li 인증 처리
                +asCode('java').
                    public interface AuthenticationManager {
                        Authentication authenticate(Authentication authentication) throws AuthenticationException;
                        // 성공하면 authenticated 속성이 true로 설정
                        // 유효하지 않으면 throw
                        // 결정할 수 없으면 return null
                    }
                li ProviderManager &lt;- AuthenticationManager 구현체
                p 실제 인증은 AuthenticationProvider 체인에 위임한다
                li AuthenticationProvider : 지원하는 타입에 한해 인증 처리
                li DaoAuthenticationProvider <- DB를 이용하는 ProviderManager
                p UserDetailsService 인터페이스에 인증을 위임한다
                +asCode('java').
                    public interface UserDetailsService {
                        UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;
                        // UserDetails는 유저 아이디, 패스워드, 권한 등을 캡슐화
                    }
            h2 AccessDecisionManager
            ul
                li 인가 처리
                +asCode('java').
                    public interface AccessDecisionManager {
                        void decide(Authentication authentication, Object context, Collection&lt;ConfigAttribute> configAttributes)
                        // context는 요청 대상
                        boolean supports(ConfigAttribute attribute)
                        boolean supports(Class&lt;?> clazz)
                    }
                li 실제 인가는 AccessDecisionVoter에 위임한다
                +asCode('java').
                    public interface AccessDecisionVoter&lt;S> {
                        int ACCESS_GRANTED = 1;
                        int ACCESS_ABSTAIN = 0;
                        int ACCESS_DENIED = -1;

                        int vote(Authentication authentication, S object, Collection&lt;ConfigAttribute> attributes)
                        boolean supports(ConfigAttribute attribute)
                        boolean supports(Class&lt;?> clazz)
                    }
            p /api/**를 처리하는 보안 필터는 /**를 처리하는 보안 필터보다 먼저 처리돼야 한다
        ol
            li @Async
            |메서드를 스프링이 관리하는 ThreadExecutor에서 비동기적으로 실행하는 프록시를 생성한다
            +codeBtn('/Repositories/STS/web-app/src/main/java/io/github/donggi/WebAppApplication.java', 'java') @EnableAsync »
            +codeBtn('/Repositories/STS/web-app/src/main/java/io/github/donggi/controller/SleepController.java', 'java') @Async »
            li @Scheduled
            |메서드를 명시적으로 호출하지 않아도 스케쥴대로 실행된다
            +codeBtn('/Repositories/STS/web-app/src/main/java/io/github/donggi/WebAppApplication.java', 'java') @EnableScheduling »
            +codeBtn('/Repositories/STS/web-app/src/main/java/io/github/donggi/controller/HelloController.java', 'java') @Scheduled »

    +hoverTemplate()#template-jsr330
        p 별도 jar 포함 필요
        +asCode('xml').
            &lt;dependency>
                &lt;groupId>javax.inject&lt;/groupId>
                &lt;artifactId>javax.inject&lt;/artifactId>
                &lt;version>1&lt;/version>
            &lt;/dependency>
        +asCode('gradle') implementation 'javax.inject:javax.inject:1'
