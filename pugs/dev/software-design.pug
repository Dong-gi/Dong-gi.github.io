include ../../source/skeleton.pug

+post({
    title: '(소프트웨어) 디자인',
    description: '소프트웨어 아키텍처, 디자인 패턴, 리팩터링 등 설계 관련 토픽 정리',
})

    h1 참고 도서
    .w3-row
        .w3-col.s2.w3-center
            +w3img('https://image.yes24.com/goods/59566585/L', '도서 이미지')&attributes({style: 'max-height:210px'})
        .w3-col.s10
            table.no-sort
                +tds('표제/저자사항', '데이터 중심 애플리케이션 설계 / 마틴 클레프만')
                +tds('ISBN 정보', '979-11-5839-098-3 (93000)')
                +tds('발행사항', '위키북스 , 발행일 : 2018.04.12')

    h1 CAP 정리와 PACELC 정리
    div
        p 참고 문헌 : #[+asA('https://dl.acm.org/doi/10.1145/3197406.3197420', 'Proving PACELC')]
        p #[+asA('https://en.wikipedia.org/wiki/CAP_theorem', 'CAP 정리')] 또는 브루어(Brewer)의 정리는 분산 시스템이 다음 3가지를 모두 보장할 수 없다는 것을 명시한다
        ul
            li 일관성(Consistency)
            p 잘못된 응답을 생성하지 않는다 -- 모든 읽기 요청은 어느 노드에서 처리됐는지와 무관하게 가장 최근 쓰기 결과나 오류를 응답 받는다
            li 가용성(Availability)
            p 모든 요청은 응답받는다 -- 노드 자체에 장애가 발생하지 않는 한, 노드는 수신한 요청에 대해 응답을 반환한다
            li 파티션 내성(Partition Tolerance)
            p 노드 간 통신이 실패해도 시스템은 계속 운영된다
        p 분산 시스템은 필연적으로 여러 노드들이 서로 통신하며 운영되는데, 광역 네트워크 장애로 인해 시스템이 내부적으로는 통신이 가능하지만 서로 간에는 통신이 불가능한 파티션 현상이 발생하는 경우, 일관성과 가용성을 모두 만족시킬 수는 없다는 의미다.
        p 어떤 시스템을 AP, CP, CA 중 하나로 분류할 수 있다는 오해를 불러 일으키는 점, 파티션이 발생하지 않은 경우에 대한 설명이 부족한 점을 보충하는 #[+asA('https://en.wikipedia.org/wiki/PACELC_theorem', 'PACELC 정리')]가 이후 등장했다.
        +w3img('/d2/3.svg', 'PACELC에서 설명하는 트레이드오프')&attributes({style: 'max-height: 50vh; border: solid'})
        ul
            li 네트워크 파티션이 발생하지 않은 경우 : 시스템은 지연 시간과 일관성 중 어떤 것을 우선할 것인지 선택해야 한다
            p 예를 들어, 모든 노드에 트랜잭션이 전파된 뒤 응답할 것인지? 일부에만 전파되어도 응답할 것인지?
            li 네트워크 파티션이 발생한 경우 : 시스템은 일관성과 가용성 중 어떤 것을 우선할 것인지 선택해야 한다
            p 예를 들어, 파티션 그룹들이 모두 요청을 처리하고 각각 그룹 내부적으로만 트랜잭션을 전파한 뒤 응답할 것인지? 파티션 그룹들 중 하나만 요청을 처리하도록 강제할 것인지?
        p 구체적으로는
        ul
            li PA/EL : 항상 일관성을 경시한다
            li PA/EC : 정상 상태에서는 일관성을, 파티션 상태에서는 가용성을 우선한다
            li PC/EL : 정상 상태에서는 지연 시간을, 파티션 상태에서는 일관성을 우선한다
            li PC/EC : 항상 일관성을 우선한다

    h1 기술 부채
    ol
        li 기술 부채
        p 개발자가 임시방편을 선택하면 기술은 부채를 지게 된다. 누적된 기술 부채가 너무 커서 제품을 포기해야 하는 상황을 기술 파산이라고 한다
        li 기술 부채 요소
        p 코드 부채, 설계 부채, 테스트 부채, 문서 부채

    h1 데이터베이스
    div
        h2 데이터 모델
        ul
            li 네트워크 모델 : 데이터를 하나의 큰 트리 -- 계층 구조로 표현하려고 했지만, 다대다 관계의 표현에 적절하지 않음
            li 관계형 : 기존 사용 사례 + 다대다 관계를 적절히 처리할 수 있어 널리 채택됨
            li NoSQL : 관계형 모델로 효율적으로 처리할 수 없는 문제를 해결하기 위해 등장
            ul
                li 문서 데이터베이스 : 문서 단위로 데이터(보통 자유 형식)를 저장하고, 문서 간 관계는 거의 없는 사용 사례에 적합
                li 그래프 데이터베이스 : 모든 것이 잠재적으로 관계를 가질 수 있는 사용 사례에 적합
        p 한편, 주요 관계형 데이터베이스에 JSON 지원이 추가되기도 하고, 문서 데이터베이스에서 집계 쿼리와 유사한 기능을 제공하기도 한다.
        p 문서 데이터베이스는 스키마리스로 불리기도 하는데, 데이터를 읽는 코드는 어느 정도 구조를 가정하기 때문에 오해의 소지가 있다. 대신 아래와 같이 구분하는 것이 좋다
        ul
            li 쓰기 스키마(schema-on-write) : Java, C#등이 정적(컴파일 타임) 타입 검사를 수행하듯, 검증된 데이터만 쓰기 허용
            li 읽기 스키마(schema-on-read) : 스크립트 언어들의 동적(런타임) 타입과 유사하게, 읽어온 데이터의 구조는 암묵적

        h2 컬럼 지향 저장소
        p 데이터베이스의 2가지 주요 사용 사례는 아래와 같다
        table
            +ths('특성', 'OLTP(Online transaction processing)', 'OLAP(Online analytic processing)')
            +tds('주요 요청자', '고객(엔드 유저)', '데이터 분석가(직원)')
            +tds('읽기 패턴', '질의 당 적은 수의 레코드, 키 기준', '많은 레코드의 적은 수의 컬럼에 대한 집계')
            +tds('쓰기 패턴', '사용자 요청에 따라 낮은 지연으로 임의 위치에 수행', '대규모 불러오기 또는 이벤트 스트림')
            +tds('데이터 표현', '데이터의 최신 상태', '시간에 따른 이벤트 이력')
            +tds('데이터셋 크기', 'GB ~ TB', 'TB ~ PB')
        p 비즈니스 의사 결정에 중요한 OLAP 시스템으로 컬럼 지향 저장소가 출시되어 활발히 이용되고 있다
        ul
            li OLTP 데이터베이스들이 로우 지향 방식으로 데이터를 배치하는 반면, 컬럼 지향 저장소는 각 컬럼들만을 (따로=파티셔닝) 모아 저장한다 -- 대신 로우를 합성해낼 수 있도록 저장 순서를 유지한다
            li 칼럼의 고유값의 수는 로우 수에 비해 상당히 작은 -- 값의 중복이 많은 경향이 있어 압축에 유리하다


    h1 디자인 패턴
    ol
        li Abstract Factory
        p 서로 관련 있는 여러 객체들에 대한 군집을 생성하는 인터페이스 제공
            br
            |AbstractFactory : 군집 인스턴스 생성 연산 정의 → 구현 : ConcreteFactory
            br
            |AbstractProduct : 군집을 구성하는 각 객체 정의 → 구현 : ConcreteProduct
        li Builder
        p 복잡한 ─ 필드가 많지만, 인스턴스화에 모든 필드가 필요하지는 않은 ─ 객체 생성 로직을 별도 클래스로 분리
        li Factory Method(Virtual Constructor)
        p 객체 생성 인터페이스를 정의. 구현을 어떻게 할 지는 각 서브클래스가 결정
        li Prototype
        p 견본이 되는 인스턴스를 복사하여 새로운 객체 생성. Prototype은 복제 연산을 가져야 한다
        li Singleton
        p 단 하나의 클래스 인스턴스만 존재하며, 이를 공유
        li Adapter, Wrapper
        p 클래스의 인터페이스를 기대하는 다른 인터페이스로 변환
        li Facade
        p 서브시스템을 사용하기 쉽도록 상위 수준의 인터페이스 정의
        li Decorator
        p
            strong 동적으로
            |  새로운 기능 추가
        li Proxy
        p 다른 객체에 대한 접근을 제어하는 대리자
        li Chain of Responsibility
        p 요청을 자신이 처리해야 한다면 처리, 아니라면 후속 처리자에게 전달
        li Iterator
        p 내부를 노출하지 않고 원소를 차례대로 접근하는 방법 제공
        li Mediator
        p 내부 객체들이 서로를 직접 참조하지 않고, Mediator를 통해 교류
        li Observer
        p 감시하는 객체의 상태가 변하면 의존하는 객체들이 통지받도록 한다
        li State
        p 객체 내부 상태에 따라 행동을 변경
        li Template Method
        p 부모 클래스(abstract)는 공통 메서드를 정의하고, 각 leaf 클래스는 제각각의 구현을 갖는다
        li Strategy
        p 동일한 계열의 알고리즘들을 캡슐화하여 상호 교환할 수 있도록 한다
        li Scott Meyers : All non-leaf classes should be abstract

    h1 리팩터링
    ol
        li 자주 쓰이지 않는 코드의 성능 향상에 얽매이지 말 것
        li 주석을 적는 대신 주석이 설명하는 부분을 메서드로 추출
        li Extract Method
        p 코드들을 그룹으로 묶어도 좋겠다고 판단된다면, 목적이 드러나는 직관적인 이름의 메서드로 추출
        li Split Temporary Variable
        p 루프 변수나 누적용 임시 변수가 아닌 경우, 각 대입마다 새로운 임시변수를 사용하여 되도록 final 임시변수만 이용
        li Remove Assignments to Parameters
        p 매개변수는 되도록 final이 되도록 한다
        li Replace Method with Method Object
        p 지역변수로 메서드 추출이 어려운 아주 긴 메서드가 있을 때, 지역변수를 필드로 하는 객체를 만들고 메서드를 잘게 쪼갠다
        li Move Method
        p 메서드가 다른 클래스의 기능을 더 많이 이용할 때, 해당 클래스에 비슷한 내용의 메서드를 작성. 기존 메서드는 대리자로 변경하거나 삭제
        li Extract Class
        p 클래스가 2가지 이상의 책임을 가진 경우
        li Pull Up Field/Method/Constructor Body
        p 두 하위클래스의 같은 필드/메서드/생성자 코드는 상위클래스로. 반대로 특정 서브클래스에서만 이용하는 것은 하위클래스로
        li Replace Inheritance with Delegation
        p 상위클래스의 일부만 이용하는 경우, 상위클래스 인스턴스를 필드로 갖고 메서드에서는 호출을 위임. 반대로, 클래스 전반에 걸쳐 위임이 도배되는 경우엔 차라리 상속으로 전환

    h1 분산 데이터 시스템
    div
        h2 설계 원칙
        p 모든 상황에 맞는 확장 아키텍처는 없다 -- 1KB를 초당 10만건 처리하는 시스템과 2GB를 분당 3건 처리하는 시스템은 데이터 처리량이 같아도 설계는 매우 다르다.
        p 특정 애플리케이션에 적합한 아키텍처는 주요 동작이 무엇인지, 잘 하지 않는 동작이 무엇인지에 대한 가정을 부하 매개변수로 하여 구축한다 -- 하지만 스타트업 초기 단계나 검증되지 않은 제품은 불확실한 가정에 대비하기보다, 유지보수에 초점을 맞추는 것이 좋다
        ul
            li 운용성 : 운영팀이 시스템을 원활하게 운영할 수 있도록
            li 단순성 : 새로운 엔지니어가 시스템을 이해하기 쉽도록
            li 발전성 : 엔지니어가 이후 시스템을 변경하기 쉽도록

        h2 복제
        p 복제 방식에 따른 구분
        ul
            li 동기식 복제
            ul
                li 쓰기가 모든 팔로워에 반영 &gt; 리더에도 최종 반영 &gt; 클라이언트에 성공 응답
                li 임의 한 노드 장애가 전체 시스템을 멈추게 하므로 비현실적

            li 비동기식 복제
            ul
                li 쓰기는 리더에만 반영되면 클라이언트에 성공 응답을 보내고, 복제는 백그라운드에서 진행
                li 리더가 갑자기 중단되면 미처 팔로워에 복제되지 않은 쓰기는 유실된다
                li 비동기 팔로워의 읽기는 옛날 정보를 반환할 수 있지만, 시간이 지나면 최종적으로 하나의 값으로 수렴한다
                p 이를 "최종적 일관성"이라 일컫는데, 이 용어는 의도적으로 모호하다 -- 복제 서버가 얼마나 뒤쳐질 수 있는지에 대한 제한이 없다

            li 반동기식 복제
            ul
                li 두 방식을 같이 사용
                p 예. 같은 리전에 존재하는 팔로워 하나에는 동기식으로 복제, 다른 리전에 존재하는 팔로워에는 비동기식으로 복제

        p 토폴로지에 따른 구분
        ul
            li 단일 리더 복제
            ul
                li 쓰기 요청은 단일 리더 노드에서만 처리
                li 단일 리더 복제는 보통 완전히 비동기식으로 구성

            li 다중 리더 복제
            ul
                li 쓰기 요청은 여러 리더 노드들이 처리
                +pos('동시 쓰기 문제')
                li 같은 행에 대한 동시 쓰기를 어떻게 해결할 지 결정 필요
                ul
                    li 충돌 자체를 회피할 수 있도록 설계
                    li 충돌을 자동으로 수정할 수 있도록 설계
                    li 충돌을 사용자에게 알려 직접 해결하도록 설계

            li 리더 장애 복구
            ul
                li 다른 데이터 저장소와 함께 사용하는 사례에서는 팔로워에 미처 반영되지 않은 데이터를 단순히 폐기하는 경우 큰 문제가 발생할 수 있다
                p GitHub 예. MySQL 다중 리더 중 하나가 중단됐을때, 리더로 승격된 팔로워의 기본키 자동 증가 카운터가 불일치하여 기본키가 재사용됨

                li 토폴로지에서 분리된 노드가 여전히 자신을 리더라고 믿고 있다면(split brain) 큰 문제가 될 수 있다

                li 리더가 죽었다고 판단하는 타임아웃을 적절히 설정해야 한다. 너무 짧으면 불필요한 장애 복구가 발생하고, 너무 길면 장애 복구가 늦어진다
                p 자동 복구보다 수동 복구가 나을수도?

            li 리더 없는 복제
            ul
                li 쓰기 요청을 모든 노드들이 처리. 대표적으로 AWS의 다이나모 DB가 있다
                p 특정 시점에 노드들이 서로 다른 데이터를 가지기 십상이다
                ul
                    li 읽기 복구 : 읽기 시점에 데이터 버전 불일치를 발견하면 이전 버전 데이터를 업데이트
                    li 안티 엔트로피 처리 : 백그라운드 프로세스에서 지속적으로 동기화 수행
                li 클라이언트가 직접 여러 노드에 쓰기를 보내기도, 중간에 코디네이터를 둬 대신 수행하도록 구현하기도 한다
                li n개 복제 서버 중 w개 노드에 쓰기가 성공하면 쓰기 확정
                p w + c개의 노드에 쓰기 요청을 보냈고 w개의 노드에 쓰기가 성공했다면, 최대 c개의 쓰기 실패는 단순히 무시 가능
                li n개 복제 서버 중 r개 노드에 읽기가 성공하면 가장 최신 버전의 데이터로 반환
                li r개 노드 중 최소한 1개에 최신 버전의 데이터가 존재해야 하므로, w + r &gt; n을 만족해야 하며, 이때의 w, r을 각각 쓰기, 읽기 정족수라 한다
                li 읽기와 쓰기가 동시에 발생하는 경우, 어떤 버전의 데이터가 반환될 지는 불분명하다
                li 동시 쓰기는 여전히 문제가 된다 #[+goto('동시 쓰기 문제')]
                li 노드 간 복제 지연 시간이 균일하지 않다면, 나중에 발생한 읽기가 이전에 발생한 읽기보다 이전 버전의 데이터를 가져갈 수 있다

        h2 선형성과 인과성
        ul
            li 일반적으로 프로그래밍에서 변수에 어떤 값을 할당한 후 즉시 해당 변수를 읽었을 때, 직전에 쓴 값을 그대로 읽을 것으로 기대하며, 읽기를 몇 번 반복해 수행하든 그 결과는 동일할 것으로 기대한다
            p 분산 시스템에서 위와 같은 성질을 제공한다면 이를 선형성 시스템이라고 한다 -- 그 외는 비선형성 시스템
            li 선형성을 보장하는 시스템은 모든 연산에 대해 전역적인 단 하나의 순서를 부여해야하고, 필연적으로 느리다
            ul
                li 단일 리더 복제 시스템은 리더가 모든 연산에 단조 증가하는 일련번호를 부여하고, 팔로워는 이를 순서대로 적용함으로써 선형성을 만족할 수 있다
                li 여러 노드가 쓰기를 수행하는 시스템에서는 합의를 통해 순서를 결정하여 선형성을 만족할 수 있다
            li 보통 선형성이 필요한 경우는 인과 관계가 있는 두 쓰기 결과를 읽을 때다
            ul
                li 두 개의 쓰기 A, B가 서로 다른 시간에 발생했다면 나중에 발생한 쓰기가 이전 쓰기를 참조할 가능성이 있다 -- 인과 관계가 존재할 수 있다
                li 두 개의 쓰기가 동시에 발생했다면 두 쓰기 사이에 인과 관계가 존재할 리는 없다
            p 따라서 선형성을 보장하는 대신 좀 더 적은 비용으로 쓰기 연산이 인과성을 보존한다면, 서로 관계가 있는 연산들에 대해서는 순서를 보장할 수 있다

        h2 파티션
        ul
            li 모든 데이터셋을 한 노드가 들고 있는 것은 비효율적일 수 있고, 심지어 OLAP 시스템에서는 불가능할 수도 있다
            li 노드 수에 따라 자동으로 파티션을 확장/축소하는 것은 복잡할 수 있다
            p 간단한 해결책으로 파티션을 처음부터 1000개 만들어 고정하는 식으로 구현할 수도 있지만, 파티션 개수에 의한 오버헤드에 유의해야 한다
            li 시간을 기준으로 파티셔닝하면, 여전히 특정 파티션이 핫스팟이 될 수 있다
            p 파티션 분배는 시간을 기준으로 하지 않는 대신, 각 파티션 내에서 시간을 기준으로 데이터를 정렬해 저장하는 것이 더 나을 수 있다

        h2 분산 트랜잭션과 합의
        div
            h3 2단계 커밋(2PC)
            ol
                li 코디네이터는 쓰기에 참여하는 모든 노드에게 트랜잭션의 내용이 유효한지 묻는다
                p 이 시점에 "네"라고 응답한 노드는 단독으로 롤백을 수행할 수 없다 -- 이후 어떤 장애가 도중에 발생하든 코디네이터로부터 커밋 또는 롤백 결정을 받은 뒤 반영해야 한다. 이러한 장애 상태의 트랜잭션은 의심스러운 또는 불확실한 상태에 있다고 한다
                li 모든 노드가 유효하다고 응답했다면, 코디네이터는 모든 노드에게 커밋을 요구한다
                p 코디네이터 장애 복구를 위해, 코디네이터는 최종 요청을 노드들에게 보내기 전에 디스크에 기록해야 한다

            h3 XA 트랜잭션
            ul
                li 이기종 간 2단계 커밋을 구현하는 표준
                li PostgreSQL, MySQL 등의 관계형 데이터베이스와 ActiveMQ, MSSQ 등의 메시지 브로커에서 지원된다
                li 여러 XA 구현은 코디네이터 장애가 발생하여 트랜잭션이 의심스러운 상태에 있을 때, 더 큰 장애로 확산하는 걸 막기 위해 커밋 여부를 일방적으로 결정할 수 있는 방법을 제공한다

            h3 합의
            p 합의 알고리즘은 다음을 만족해야 한다
            ul
                li 균일한 동의 : 어떤 두 노드도 다르게 결정하지 않는다
                li 무결성 : 어떤 노드도 두 번 결정하지 않는다
                li 유효성 : 결정된 값은 어떤 노드에서 제안된 것이다
                li 종료 : 죽지 않은 모든 노드는 어떤 값을 결정한다
                p 도중에 죽은 노드는 더 이상 합의에 참여할 수 없다 -- 도중에 죽은 노드의 복구를 기다리지 않는다
            p 합의 알고리즘을 구현하는 것은 매우 어려우며, 주키퍼와 같은 성공적인 도구를 이용해 합의, 장애 감지, 분산 잠금, 멤버십 서비스 등을 위탁하는 것이 합리적이다

    h1 소프트웨어 설계 원칙
    ol
        li 계층 원칙 : 계층적인 추상화 조직 생성
        li 캡슐화 원칙 : 관심사 분리, 정보 은닉
        li 단일 책임 원칙 : 클래스를 변경해야 하는 이유가 둘 이상이 되어서는 안 된다
        li 비순환 의존성 원칙
        li OCP; Open/Close Principle
        p 모듈은 확장에는 열려야 하지만, 변경에는 닫혀야 한다. 특히 모듈은 코드 변경 없이 새로운 요구 사항을 지원할 수 있어야 한다. 일단 타입 구현을 완료하면 타입은 버그 수정을 위해서만 변경 가능하다

    h1 지연 시간
    ol
        li 지연 시간이 적절한 지 평가하기 위해 p95, p99, p999 등의 분위수를 사용하며, SLA(서비스 수준 계약)의 기준이 된다
        li 아마존은 p999를 기준으로 내부 서비스의 응답 시간 요구사항을 기술하는데, 이는 보통 응답 시간이 가장 느린 요청을 경험한 고객들은 많은 구매를 해 많은 데이터를 가진 가장 소중한 고객들이기 때문이다
        li 특정 API 응답 지연은 다른 API 엔드포인트로 전파될 수 있다
        p TCP에서 Head-of-line blocking 문제가 발생하듯, 클라이언트에 뷰를 구성하기 위해 여러 API 응답을 모두 기다려야 하는 상황이 존재하면 특정 1개 API로 인해 전체적으로 느린 경험을 하게 된다
