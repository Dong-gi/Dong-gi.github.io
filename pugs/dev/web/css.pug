include ../../../source/skeleton.pug

+post({
    title: 'CSS',
    description: 'CSS 정리',
})

    h1 자료
    ul
        li: +asA('https://www.w3schools.com/css/default.asp', 'W3Schools > CSS')
        li: +asA('https://web.dev/learn/css/', 'web.dev > CSS 배우기')
        li: +asA('https://developer.mozilla.org/en-US/docs/Web/CSS', 'MDN > CSS')

    h1 CSS 개요
    ul
        li CSS (Cascading Style Sheets)는 HTML 문서에 선택적으로 스타일을 적용하기 위한 문법을 규정한다
        li 스타일은 개별 CSS Ruleset 정의를 통해 적용된다
        +asCode('css').
            p {
                color: red;
            }
        ul
            li p &gt; 선택자 (selector) : 스타일을 적용할 HTML 요소를 지정
            li color &gt; 속성 (property) : 변경하려는 스타일 속성 지정
            li red &gt; 속성 값 : 적용하려는 스타일 속성 값

    h1 Box Model
    div
        h2 CSS가 표시하는 모든 것은 박스다
        p 각 박스는 하위 영역들(다시 박스)로 구성된다; 컨텐츠 박스 → 패딩 박스 → 테두리 박스 → 여백 박스
        ul
            li 컨텐츠 박스
            ul
                li 자식 요소들을 포함할 수 있다
                li 컨텐츠 박스의 크기가 자식 요소들의 크기에 의해 (동적으로) 결정되도록 할 수도 있다
                li 한편, 컨텐츠가 너무 많으면 컨텐츠 박스 밖으로 넘칠 수 있고(overflow), CSS는 기본적으로 이를 숨기지 않는다(overflow: visible;)
            li 패딩 박스
            ul
                li 컨텐츠 박스를 감싸는 영역으로, 컨텐츠 박스를 테두리로부터 밀어내는 작용을 하며, 음수로 설정할 수 없다
                li 요소에 적용된 배경은 이 영역까지 표시된다
                li 오버플로 속성으로 인한 스크롤바도 이 영역에 표시된다
            li 테두리 박스
            p 박스의 경계를 표시한다. border 속성으로 제어한다
            li 여백 박스
            ul
                li 박스 바깥의 공간으로, 여백의 크기는 박스의 크기에 영향을 미치지 않는다
                li 외부의 다른 요소들을 밀어내거나(양수 여백) 당기는(음수 여백) 작용을 한다

        h2 박스 모델 제어
        ul
            li 모든 웹 브라우저는 HTML 문서에 브라우저 기본 스타일시트를 적용한다 -- 때문에 브라우저마다 조금씩 다를 수 있다
            li display 속성 : 요소를 block 또는 inline 박스로 취급하고, 자식 박스들을 어떻게 배치할 지 제어한다. #[+goto('display 속성의 이해')]
            li box-sizing 속성 : width, height를 컨텐츠 박스까지 적용할 지(기본값), 테두리 박스까지 적용(box-sizing: border-box;)할 지 제어한다

    h1 선택자
    div
        h2 단순 선택자
        table.no-sort
            +ths('분류', '예', '설명')
            tr
                th 범용 선택자
                td *
                td 모든 HTML 요소를 선택
            tr
                th 타입 선택자
                td div
                td 모든 &lt;div&gt; 요소를 선택
            tr
                th 클래스 선택자
                td .dialog
                td 클래스 목록 중 "dialog"를 가진 모든 요소를 선택
            tr
                th ID 선택자
                td #target
                td id가 "target"인 요소 하나를 선택
            tr
                th&attributes({ rowspan: 7}) 속성 선택자
                td [attr]
                td attr 속성을 갖는 요소
            tr
                td [attr='value']
                td attr 속성값이 'value'와 일치하는 요소
            tr
                td [attr='value' s]
                td attr 속성값이 'value'와 일치하는 요소(대소문자 구별 O)
            tr
                td [attr='value' i]
                td attr 속성값이 'value'와 일치하는 요소(대소문자 구별 X)
            tr
                td [attr*='value']
                td attr 속성값이 'value'를 포함하는 요소
            tr
                td [attr^='value']
                td attr 속성값이 'value'로 시작하는 요소
            tr
                td [attr$='value']
                td attr 속성값이 'value'로 끝나는 요소
            tr
                th 그룹화 선택자
                td ,
                td 여러 선택자가 지정하는 모든 요소를 선택
                    +asCode('css').
                        /* strong 요소, em 요소, lang 속성을 가진 요소의 글자 색을 빨강으로 한다 */
                        strong, em, [lang] { color: red; }

        h2 의사 클래스 및 의사 요소
        div
            h3.fake 의사 클래스
            ul
                li 참고 자료 : #[+asA('https://developer.mozilla.org/ko/docs/Web/CSS/Pseudo-classes')]
                li 요소들의 상태를 기준으로 선택하는 데 사용할 수 있는 의사 클래스가 정의되어 있다. ':'을 이용해 의사 클래스를 지정한다
                li a: active, hover, link, visited
                li input: checked, disabled, enabled, focus, in-range, out-of-range, valid, invalid, read-only, read-write, required, optional
                li :first-child, last-child, nth-child(n), nth-last-child(n)
                li :not(selector)
                li :is(forgiving-selector-list)
                +asCode('css') .post :is(h1, h2, h3) { line-height: 1.2; }
                li :has(relative-selector-list)
                p 특정 조건을 만족하는 자식 요소를 갖는 부모를 필터링한다
                +asCode('css', '바로 아래에 p 자식을 갖는 h1을 선택하는 경우의 예') h1:has(+ p) { /* style */ }

            h3.fake 의사 요소
            ul
                li 요소의 특정 부분을 선택하거나, 요소의 앞뒤에 내용을 추가(content 속성을 설정한 경우, 요소가 자식 요소를 가질 수 있어야 함)하는 데 사용한다. '::'를 이용해 의사 요소를 지정한다
                li ::first-letter : 첫 번째 글자
                li ::first-line : 첫 번째 줄 
                li ::marker : 리스트 아이템의 글머리 기호(또는 번호)
                li ::before : 요소 앞부분에 추가
                li ::after : 요소 뒷부분에 추가
                li ::selection : 블록 지정된 요소

        h2 결합기(Combinator)
        p 결합기는 두 선택자 사이에 위치하여, 특정한 관계를 만족하는 요소를 선택할 수 있게 해준다
        ul
            li '&gt;' : 자식 요소
            li ' '(스페이스) : 후손 요소
            li '+' : 바로 다음 형제 요소
            li '~' : 다음 모든 형제 요소

        h2 Nesting
        p 자식 요소의 스타일을 부모 요소의 스타일 정의 안에 중첩하여 정의할 수 있다. 여기서 &amp;를 이용해 부모 자신을 가리키는 선택자로 이용할 수 있다
        ul
            li &amp; 미사용
            +asCode('css').
                parent {
                    /* parent style */
                    child {
                        /* child style */
                    }
                }
            li &amp; 사용
            +asCode('css').
                parent {
                    /* parent style */
                    & child {
                        /* child style */
                    }
                }
            li 위 2가지 모두 브라우저에서 아래와 같이 해석된다
            +asCode('css').
                parent {
                    /* parent style */
                }
                
                parent child {
                    /* child style */
                }

    h1 The cascade
    p 요소에 대해 둘 이상의 스타일이 존재할 때, 브라우저는 아래 순서에 따라 적용할 스타일을 결정한다.
    div
        h2 스타일의 위치와 순서
        ul
            li 동일한 CSS 안에서의 충돌 : 스크립트 뒷부분에 정의된 것이 우선
            li 두 CSS 간 충돌 : 보다 나중에 로드/정의된 것이 우선
            li 요소 내부의 style 속성으로 지정한 것이 요소 외부의 것보다 우선

        h2 선택자의 특정성
        p 위치상 후순위 스타일이더라도, 선택자가 요소를 보다 자세하게 특정하는 경우 보다 높은 우선순위를 가질 수 있다
        table
            +ths('선택자', '점수', '비고')
            +tds('*', '0', '')
            +tds('타입', '1', '')
            +tds('클래스, 의사 클래스, 속성', '10', ':not() 자체는 점수가 없지만, 인자로 넘겨진 선택자에 대해선 점수가 부여된다')
            +tds('ID', '100', '')
            +tds('inline style', '1,000', '')
            +tds('!important', '10,000', '')

        h2 출처
        p 우선순위가 낮은 순서부터,
        ol
            li 브라우저 기본 스타일
            li OS(e.g. 기본 폰트) 또는 브라우저 확장 스타일
            li 직접 작성된 CSS
            li 직접 작성된 !important
            li OS 또는 브라우저 확장 !important
            li 브라우저 기본 !important

        h3 중요성
        p 어떤 스타일은 기본적으로 다른 것보다 우선한다. 우선순위가 낮은 순서부터,
        ol
            li 일반
            li animation
            li !important
            li transition

    h1 상속
    ul
        li 일부 스타일 속성은 기본적으로 모든 자식 요소로 상속된다
        p color, font, direction, line-height, text-align, visibility 등

        li inherit 키워드를 이용한 명시적 상속
        +asCode('css').
            strong { font-weight: 900; }
            .my-class { font-weight: 500; }
            .my-class strong { font-weight: inherit; } /* 500이 적용된다 */

        li initial 키워드를 이용한 상속 취소(기본값 사용)

        li unset 키워드
        ul
            li 속성이 상속 가능하면 inherit으로, 아니면 initial로 작동
            li "all: unset;"으로 간편하게 모든 속성 상속 취소 가능

        li 모든 개별 속성을 설정하는 것은 번거로우므로, all 단축 속성을 이용해 전체 상속 설정을 변경할 수 있다
        p 상속 값 중 하나만 설정 가능하다
        +asCode('css').
            parent {
                /* ... */
                child {
                    all: unset;
                }
            }

    h1 Containment
    div
        p Containment는 페이지 내의 특정 서브트리를 나머지와 분리함으로써, 스타일이 나머지 영역에 영향을 미치지 않는다고 명시하여 렌더링 성능을 높이는 기술이다
        p contain, content-visibility 속성을 이용하여 개발자는 브라우저에 다음 결정을 위한 정보를 제공할 수 있다
        ul
            li 컨테이너의 컨텐츠를 표시할 것인지?
            li 페이지가 스크린에 보이지 않을때 렌더링할 것인지?

        h2 contain 속성
        p Containment에는 4가지 타입이 있다: layout, paint, size, style
        p contain 속성에는 이 네 개의 타입 중 어떤 것들이 적용되는지를 지정한다.
        ul
            li layout
            ul
                li 컨테이너 자식 요소의 위치/크기 변화는 컨테이너 외부에 영향을 주지 않는다
                li 컨테이너 자식 요소의 margin은 컨테이너 경계 밖으로 나갈 수 없다
                li 컨테이너 안에서 독립적으로 float 레이아웃, absolute 위치, fixed 위치가 계산된다
            li paint
            p 컨테이너 자식 요소는 컨테이너를 넘어서 그려지지 않는다. 따라서 컨테이너가 화면 안에 없으면, 자동으로 그 자식 요소들도 그려질 일이 없다
            li size
            ul
                li 컨테이너의 크기는 컨테이너의 자식 요소들과 무관하다 -- 자식이 없는 것과 다름없다
                li contain-intrinsic-size 또는 contain-intrinsic-width/height를 이용해 크기를 지정해야 한다
            li style
            p 이 서브트리로 인한 CSS counter 값의 변경은 외부에 영향을 미치지 않는다
            li content
            p "layout paint style"을 표현하기 위한 축약어
            li strict
            p "size layout paint style"을 표현하기 위한 축약어

        h2 content-visibility 속성
        ul
            li visible : 이 속성이 없는 것과 동작에 차이 없음
            li hidden : 이 요소는 화면 안에 있더라도 렌더링할 필요 없음. 추가로 페이지 검색에서 발견되지 않고, 탭 등으로 선택되지도 않음.
            li auto : #[+asInlineCode('contain: content', 'css')]가 적용된 것처럼 렌더링. hidden과 다르게, 눈에 보이지 않아도 선택되거나 검색될 수 있음.

        h2 Container query
        p 컨테이너 쿼리는 어떤 요소에 대하여, 이를 포함하는 컨테이너의 크기를 기준으로 스타일을 지정할 수 있게 해준다.
        ul
            li 컨테이너 쿼리를 사용하려면 먼저 컨테이너 컨텍스트를 정의해야 한다
            p 미디어 쿼리와는 사용하는 방법이 다르다. 미디어 쿼리는 뷰포트와 같은 전역 디바이스 속성에 기반하여 스타일을 지정하므로 CSS가 직접 이를 변경할 수 없으나, CSS는 자식 요소의 크기에 의하여 부모 요소의 크기가 동적으로 변경될 수 있기 때문에, containment를 사용하지 않으면 스타일 적용의 무한 루프가 발생할 수 있다.
            +asCode('css') .post { container-type: inline-size }
            ul
                li normal
                p 크기를 이용한 컨테이너 쿼리를 사용할 수 없다. 대신 스타일을 이용한 컨테이너 쿼리는 사용할 수 있다.
                li inline-size
                p 인라인 방향에 대해 크기를 이용한 컨테이너 쿼리를 사용할 수 있다 -- 컨테이너 width는 자식 요소와 독립
                +codeBtn({
                    path: '/Repositories/Single/202411/07-1721.html',
                    lan: 'nohighlight',
                    title: 'inline-size 예'
                })
                +codeBtn({
                    path: '/Repositories/Single/202411/07-1721.html',
                    lan: 'html',
                    title: '<- 코드'
                })
                li size
                p 인라인 및 블록 방향 모두에 대해 크기를 이용한 컨테이너를 사용할 수 있다  -- 컨테이너 width/height 모두 자식 요소와 독립
                +codeBtn({
                    path: '/Repositories/Single/202411/08-1150.html',
                    lan: 'nohighlight',
                    title: 'size 예'
                })
                +codeBtn({
                    path: '/Repositories/Single/202411/08-1150.html',
                    lan: 'html',
                    title: '<- 코드'
                })
            li 컨테이너 이름을 지정하여 스타일 지정을 손쉽게 할 수 있다
            +asCode('css').
                .post {
                    container-type: inline-size;
                    container-name: sidebar;
                }

                @container sidebar (min-width: 700px) {}
            li 위 모두를 설정하는 축약어를 제공한다
            +asCode('css') .post { container: sidebar / inline-size }
            li 컨테이너 자식 요소들에 대해 #[+goto('cqw')], cqh와 같은 단위를 이용할 수 있다

    h1 단위
    div
        h2 절대 길이
        p 화면에 표시하는 목적보다는 프린트하기에 좋은 단위
        ul
            li cm : 센티미터
            li mm : 밀리미터
            li in : 인치
            li pt : 포인트 == 1/72in
            li px : 픽셀 == 1/96in

        h2 상대 길이
        ul
            li em : 상속된 폰트 크기
            li rem : 루트 요소의 폰트 크기(기본값 16px)
            li cap : 대문자 크기
            li ch : 반각문자 평균 너비
            li ic : 전각문자 평균 너비
            li lh : 요소의 줄 간격
            li rlh : 루트 요소의 줄 간격
            li vw : 표시영역 너비의 1%
            li vh : 표시영역 높이의 1%
            li vi : 표시영역 inline axis(writing mode에 따른 방향) 길이의 1%
            li vb : 표시영역 block axis(block 요소가 추가되는 방향) 길이의 1%
            li vmin : min(vw, vh)
            li vmax : max(vw, vh)
            +pos('cqw')
            li cqw : 컨테이너 너비의 1%
            li cqh : 컨테이너 높이의 1%
            li cqi : 컨테이너 inline axis(writing mode에 따른 방향) 길이의 1%
            li cqb : 컨테이너 block axis(block 요소가 추가되는 방향) 길이의 1%
            li cqmin : min(cqi, cqb)
            li cqmax : max(cqi, cqb)

        h2 각도
        ul
            li deg : 60분법의 1도
            li rad : 1 라디안
            li turn : 1turn == 360deg

    h1 Layout
    div
        +pos('display 속성의 이해')
        h2 display 속성의 이해
        p 참고 자료 : #[+asA('https://developer.mozilla.org/en-US/docs/Web/CSS/display')]
        +asCode().
            display = 
                [ &lt;display-outside&gt; || &lt;display-inside&gt; ]         |
                &lt;display-listitem&gt;                                |
                &lt;display-internal&gt;                                |
                &lt;display-box&gt;                                     |
                &lt;display-legacy&gt;
        div
            h3 #{'<display-outside>'}
            p Flow layout(기본 배치; inline/block)에서 요소를 어떻게 배치할 지 제어한다
            ul
                li inline
                ul
                    li 너비에 여유가 있다면 inline 요소들은 한 줄에 같이 표시된다
                    li width, height 설정은 무시된다. 박스 크기는 기본적으로 실제 컨텐츠에 맞춰진다
                    li 위/아래 패딩, 여백, 테두리 설정으로 다른 인라인 박스들이 멀어지게 할 수 없다
                li block
                ul
                    li block 요소는 한 줄을 온전히 차지한다
                    li 박스 전후에 개행을 삽입한다
                    li width, height 설정이 가능하다. 컨텐츠가 박스 크기에 맞춰진다

            h3 #{'<display-inside>'}
            p 자식 요소들을 내부에서 어떻게 배치할 지 제어한다
            ul
                li flow
                p Flow layout에 따라 자식 요소들을 배치한다
                li flow-root
                p flow + 새로운 block formatting context(BFC; 블록 박스가 자리하고, float 요소가 상호작용하는 공간)를 생성한다
                +codeBtn({
                    path: '/Repositories/Single/202210/19_1643.html',
                    lan: 'nohighlight',
                    title: 'flow-root를 사용하지 않은 경우'
                })
                +codeBtn({
                    path: '/Repositories/Single/202210/19_1643.html',
                    lan: 'html',
                    title: '←코드'
                })
                +codeBtn({
                    path: '/Repositories/Single/202210/19_1646.html',
                    lan: 'nohighlight',
                    title: 'flow-root를 사용한 경우'
                })
                +codeBtn({
                    path: '/Repositories/Single/202210/19_1646.html',
                    lan: 'html',
                    title: '←코드'
                })
                li table
                p #{'<table>'} 요소처럼 취급된다. "display: table-cell;" 속성을 가진 자식들은 테이블 열이 제각기 너비를 차지하듯이 부모의 너비를 나눠갖는다. 추가로 부모 요소에서 table-layout 스타일 속성도 효과를 갖는다
                li flex
                p Flexible box layout에 따라 자식 요소들을 배치한다. 자식 요소들은 자동으로 flex item이 된다
                li grid
                p Grid layout에 따라 자식 요소들을 배치한다
                li ruby
                p #{'<ruby>'} 요소처럼 취급된다

            h3 #{'<display-listitem>'}
            ul
                li list-item
                p 요소를 리스트 항목으로 취급한다

            h3 #{'<display-internal>'}
            p table, ruby와 같이 복합 구조를 갖는 요소들의 자식들이 갖는 역할을 제어한다
            ul
                li table-row-group : #{'<tbody>'}에 대응
                li table-header-group : #{'<thead>'}에 대응
                li table-footer-group : #{'<tfoot>'}에 대응
                li table-row : #{'<tr>'}에 대응
                li table-cell : #{'<td>'}에 대응
                li table-column-group : #{'<colgroup>'}에 대응
                li table-column : #{'<col>'}에 대응
                li table-caption : #{'<caption>'}에 대응
                li ruby-base : #{'<ruby>'}에 대응
                li ruby-text : #{'<rt>'}에 대응
                li ruby-base-container : 익명 박스 생성
                li ruby-text-container : #{'<rtc>'}에 대응

            h3 #{'<display-box>'}
            ul
                li contents
                p 요소 자체는 박스를 생성하지 않는다. 그러나 자식 요소들과 의사 요소들은 정상적으로 박스를 생성한다. 즉, 요소는 트리 상에서만 존재하는 컨테이너가 된다
                p 예를 들어 display: flex;는 자식 요소들만을 flex item으로 취급하는데, 자식 요소에 display: contents;를 적용하여, 손자 요소들을 flex item처럼 표시할 수 있다
                +codeBtn({
                    path: '/Repositories/Single/202210/19_2231.html',
                    lan: 'nohighlight',
                    title: 'display: contents;'
                })
                +codeBtn({
                    path: '/Repositories/Single/202210/19_2231.html',
                    lan: 'html',
                    title: '←코드'
                })
                li none
                p 레이아웃에 요소를 표시하지 않는다. 자식들에게도 상속되어 영향을 미친다. 자리는 차지하되 렌더링만 하지 않기를 원한다면 visibility 속성을 사용할 수 있다

            h3 #{'<display-legacy>'}
            p CSS 2에서는 단일 키워드로 결합된 값들을 정의했다
            ul
                li inline-block : inline flow-root와 동일
                li inline-table : inline table과 동일
                li inline-flex : inline flex와 동일
                li inline-grid : inline grid와 동일

        h2 Flexible box layout
        div
            p 일직선 상에서 자식 요소들의 크기를 유연하게 조정한다 -- 크기를 넓혀 빈 공백을 채우거나, 오버플로되지 않도록 축소

            h3 Basic concepts of flexbox
            ul
                li Flex container의 자식들(flex item)은 기본적으로 아래와 같이 배치된다
                ul
                    li flex-direction: row; 한 줄로 표시되며, 주 축의 시작 위치부터 배치된다
                    li flex-wrap: nowrap; 공간이 부족해도 개행하지 않고 오버플로된다
                    li flex-grow: 0; 빈 공간이 존재하더라도 아이템 크기가 늘어나지 않는다
                    li flex-shrink: 1; 오버플로 되는 경우 아이템 크기가 줄어들 수 있다
                    li flex-basis: auto; 각 아이템 크기는 요소에 지정된 크기. 없으면 요소의 컨텐츠 크기
                    li align-items: stretch; 아이템 크기를 직교 축 끝까지 확장한다
                +codeBtn({
                    path: '/Repositories/Single/202210/19_1739.html',
                    lan: 'nohighlight',
                    title: '기본 flex'
                })
                +codeBtn({
                    path: '/Repositories/Single/202210/19_1739.html',
                    lan: 'html',
                    title: '←코드'
                })
                li 컨테이너 flex-direction 속성 : 요소를 배치할 축을 설정할 수 있다; row, row-reverse, column, column-reverse
                li 컨테이너 flex-wrap 속성 : nowrap(한 줄에 다 못채우면 오버플로), wrap(한 줄에 다 못채우면 개행. 각 줄을 별개의 컨테이너로 생각해야 한다)
                li 컨테이너 flex-flow 단축 속성 : flex-direction flex-wrap
                li 아이템 flex-basis 속성 : 아이템 기본 크기
                ul
                    li auto(기본값) : 요소에 지정된 크기가 존재하면 해당 값을 사용하고, 지정된 크기가 없으면 요소의 컨텐츠 크기(max-content 기준)를 사용한다
                    li content : auto와 달리, 요소에 지정된 크기가 있어도 컨텐츠 크기를 사용한다
                +codeBtn({
                    path: '/Repositories/Single/202210/19_2125.html',
                    lan: 'nohighlight',
                    title: 'flex-basis'
                })
                +codeBtn({
                    path: '/Repositories/Single/202210/19_2125.html',
                    lan: 'html',
                    title: '←코드'
                })
                li 아이템 flex-grow 속성 : 모든 아이템이 flex-basis 만큼 차지하고도 공간이 남으면, 각 가중치만큼 나눠갖는다
                +codeBtn({
                    path: '/Repositories/Single/202210/19_2143.html',
                    lan: 'nohighlight',
                    title: 'flex-grow'
                })
                +codeBtn({
                    path: '/Repositories/Single/202210/19_2143.html',
                    lan: 'html',
                    title: '←코드'
                })
                li 아이템 flex-shrink 속성 : flex-grow와 다르게, 오버플로 시 수축하는 비중을 지정한다
                p 그러나 각 아이템은 min-content 미만으로 축소되지 않는다
                li 아이템 flex 단축 속성 : flex-grow flex-shrink flex-basis
                ul
                    li flex: initial == flex: 0 1 auto
                    li flex: auto == flex: 1 1 auto
                    li flex: none == flex: 0 0 auto
                    li flex: n == flex: n 1 0

            h3 Aligning items in a flex container
            ul
                li 컨테이너 justify-content 속성 : 주 축에 대하여 아이템을 어떻게 배치할 지 지정한다
                ul
                    li flex-start(기본값) : 주 축의 시작 위치부터 배치한다
                    li flex-end : 주 축의 끝부터 배치한다
                    +codeBtn({
                        path: '/Repositories/Single/202210/19_2207.html',
                        lan: 'nohighlight',
                        title: 'flex-direction: row-reverse ↔ justify-content: flex-end 차이'
                    })
                    +codeBtn({
                        path: '/Repositories/Single/202210/19_2207.html',
                        lan: 'html',
                        title: '←코드'
                    })
                    li center : 가운데 정렬
                    li space-around : 가운데 정렬 + 각 아이템 좌우에 동일한 여백
                    li space-between : 가운데 정렬 + 각 아이템 사이에 동일한 여백
                    li space-evenly : 가운데 정렬 + 모두 동일한 여백
                li 컨테이너 align-items 속성 : 직교 축에 대하여 아이템을 어떻게 배치할 지 지정한다
                ul
                    li stretch(기본값) : 직교 축의 전체 공간을 차지한다
                    li flex-start : 직교 축의 시작부터 자리를 차지한다
                    li flex-end : 직교 축의 끝부터 자리를 차지한다
                    li center : 직교 축의 중간에 위치한다
                li 아이템 align-self 속성 : 직교 축 상에서의 아이템 배치 조정
                li 컨테이너 align-content : 직교 축 상의 여러 flex line 간의 배치 조정
                p stretch(기본값), flex-start, flex-end, center, space-around, space-between, space-evenly
                li 컨테이너 gap, column-gap, row-gap : 아이템 간 간격 조정
                li e.g. margin 속성을 이용해 특정 아이템 사이에만 여백 두기
                +codeBtn({
                    path: '/Repositories/Single/202210/20_1031.html',
                    lan: 'nohighlight',
                    title: 'flex-item { margin }'
                })
                +codeBtn({
                    path: '/Repositories/Single/202210/20_1031.html',
                    lan: 'html',
                    title: '←코드'
                })

            h3 Ordering flex items
            ul
                li 아이템 order 속성 : 기본값 0. 배치 순서를 세부적으로 조정 가능
                +codeBtn({
                    path: '/Repositories/Single/202210/20_1050.html',
                    lan: 'nohighlight',
                    title: 'flex-item { order }'
                })
                +codeBtn({
                    path: '/Repositories/Single/202210/20_1050.html',
                    lan: 'html',
                    title: '←코드'
                })

        h2 Grid layout
        div
            h3 Basic concepts of grid layout
            ul
                li Flexible box가 기본적으로 1차원으로 요소들을 배치하는 것과 다르게, Grid는 2차원 배치를 기본으로 한다
                +codeBtn({
                    path: '/Repositories/Single/202210/20_1209.html',
                    lan: 'nohighlight',
                    title: '간단한 grid'
                })
                +codeBtn({
                    path: '/Repositories/Single/202210/20_1209.html',
                    lan: 'html',
                    title: '←코드'
                })
                li 자식 요소가 많으면 정의된 행 또는 열의 개수를 초과하여 자동으로 다음 열 또는 행이 생성되는데, grid-auto-rows, grid-auto-columns 속성을 이용해 이러한 암묵적 그리드를 제어할 수 있다
                +codeBtn({
                    path: '/Repositories/Single/202210/21_1604.html',
                    lan: 'nohighlight',
                    title: 'grid-auto-rows'
                })
                +codeBtn({
                    path: '/Repositories/Single/202210/21_1604.html',
                    lan: 'html',
                    title: '←코드'
                })
                li 그리드는 행과 열의 정의에 따른 선들이 존재하는데, 문서의 writing mode에 따라 자연스러운 순서대로 1부터 번호가 매겨진다
                p grid-template-columns, grid-template-rows로 개수가 명시된 경우, 음수로도 지정 가능하다
                +codeBtn({
                    path: '/Repositories/Single/202210/21_1623.html',
                    lan: 'nohighlight',
                    title: 'grid line'
                })
                +codeBtn({
                    path: '/Repositories/Single/202210/21_1623.html',
                    lan: 'html',
                    title: '←코드'
                })
                li 그리드 항목은 동일한 셀을 점유할 수 있다. 눈에 보이는 것은 z-index에 따라 결정된다

            h3 명명된 그리드
            ul
                li 명명된 영역을 정의하여 그리드를 분배할 수 있다
                +codeBtn({
                    path: '/Repositories/Single/202210/21_1652.html',
                    lan: 'nohighlight',
                    title: 'grid-template-areas'
                })
                +codeBtn({
                    path: '/Repositories/Single/202210/21_1652.html',
                    lan: 'html',
                    title: '←코드'
                })
                li 명명된 영역의 경계선은 ${name}-start, ${name}-end로 참조할 수 있다
                +codeBtn({
                    path: '/Repositories/Single/202210/21_1703.html',
                    lan: 'nohighlight',
                    title: 'Implicit grid lines from named areas'
                })
                +codeBtn({
                    path: '/Repositories/Single/202210/21_1703.html',
                    lan: 'html',
                    title: '←코드'
                })
                li 반복 명명된 경계선을 이용한 12열 그리드 예
                +codeBtn({
                    path: '/Repositories/Single/202210/21_1710.html',
                    lan: 'nohighlight',
                    title: 'Multiple lines with the same name with repeat()'
                })
                +codeBtn({
                    path: '/Repositories/Single/202210/21_1710.html',
                    lan: 'html',
                    title: '←코드'
                })

            h3 박스 정렬
            ul
                li 그리드의 두 축은 block axis와 inline axis로 구분된다
                p 전자는 블록 요소가 블록 레이아웃을 따라 배치되는 방향, 후자는 텍스트를 같은 줄에서 한 글자씩 작성할 때 배치되는 방향이다
                li 컨테이너 align-items 속성 : block axis에 따른 아이템 배치를 지정한다
                p normal, stretch, start, center, end
                li 컨테이너 justify-items 속성 : inline axis에 따른 아이템 배치를 지정한다
                p normal, stretch, start, center, end
                li 컨테이너 align-content 속성 : block axis에 따른 아이템 간격 조정
                p normal, stretch, start(기본값), center, end, space-around, space-between, space-evenly
                li 컨테이너 justify-content 속성 : inline axis에 따른 아이템 간격 조정
                p normal, stretch, start(기본값), center, end, space-around, space-between, space-evenly
                li 아이템 align-self 속성 : block axis에 따른 정렬을 지정한다
                p auto, normal, stretch, start, center, end
                li 아이템 justify-self 속성 : inline axis에 따른 정렬을 지정한다
                p auto, normal, stretch, start, center, end
                li 또는 아이템 margin: auto; 속성으로 셀 내의 위치를 조정할 수 있다

    h1 함수
    div
        h2 #{`attr( <attribute-name> )`}
        p 해당 속성값을 획득한다

        h2 calc()
        +asCode('css').
            .x { width: calc(100% - 2rem) }
            .x { width: calc(var(--root-width) * 2) }
            .x { width: calc(calc(var(--root-width) * 2) * 2) }

        h2 clamp(min, val, max) == max(min, min(val, max))
        p [min, max] 범위를 벗어나지 않으면 val 반환

        h2 #{`var( <custom-property-name>, <declaration-value>?)`}
        ol
            li 변수 선언
            +asCode('css') root { --var1: 12px; --my-var2: blue; }
            li 변수 사용
            +asCode('css') p { color: var(--my-var2); }
            li 첫 번째 콤마 뒤의 모든 문자열이 fallback 값이다
            p 예를 들어 var(--foo, red, blue)에서의 fallback 값은 "red, blue"다

        h2 #{`url( <string> )`}
        p 외부 리소스를 참조한다
