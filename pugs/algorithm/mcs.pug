include ../../source/skeleton.pug

+post('Mathematics for Computer Science', 'MCS, Mathematics', 'Mathematics for Computer Science 정리', true)
    p.fake-h1
        |0.
        +asA('https://dong-gi.github.io/files/mcs.pdf', '도서')
        |정보
    .w3-row
        .w3-col.s2.w3-center
            +w3img('https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQew5ZrEOtvLqafGH3aEaTctFKCSV4qjsRoZS4tT7Ci_lJXjSIV', '도서')&attributes({style: 'max-height:210px'})
        .w3-col.s10
            table.no-sort
                +tds('표제/저자사항', 'Mathematics for Computer Science / Eric Lehman, F Thomson Leighton, Albert R Meyer')
                +tds('ISBN 정보', '979-11-88621-12-5 [93000]')
                tr
                    td Copyright
                    td 2017, Eric Lehman, F Tom Leighton,
                        +asA('http://people.csail.mit.edu/meyer', 'Albert R Meyer')
                        |. This work is available under the terms of the
                        +asA('http://creativecommons.org/licenses/by-sa/3.0/', 'Creative Commons Attribution-ShareAlike 3.0 license.')

    p.fake-h1 I. Proofs
    hr
    div
        p.fake-h2 Introduction
        +pos('증명')
        p 간단히 말해 증명은 참을 수립하는 과정이다. "참"은 보는 사람, 분야에 따라 다르기 때문에 수학적 증명 역시 자기만의 정의를 갖는다.
        p <b>정의.</b> 명제(proposition)에 대한 수학적 증명이란, 기본 공리(axiom)들과 이미 증명된 다른 명제들로부터 결론에 도달하는 일련의 논리적 연역(deduction)이다
        ul
            li 귀납(Induction) : 관찰된 사실들로부터 결론을 도출하는 과정
            p e.g. 모든 백조는 하얗다
            li 연역(Deduction) : 참인 전제들로부터 결론을 도출하는 과정
            p 참고. 수학적 귀납법은 연역논증이다

        +pos('1')
        h2 What is a Proof?
        div
            +pos('1.1')
            h3 Propositions
            p <b>정의.</b> 명제(proposition)란 참 또는 거짓인 문장이다
            p 예를 들어, 다음 2개 문장은 모두 명제다. 첫 번째는 참이고, 두 번째는 거짓이다.
            +pos('명제 1.1.1')
            p <b>명제 1.1.1.</b> 2 + 3 = 5
            +pos('명제 1.1.2')
            p <b>명제 1.1.2.</b> 1 + 1 = 3
            p 참/거짓이 되는 문장에는 제한이 없을 것 같지만, 실제로는 "미술관은 어디로 가면 되나요?", "A학점 주세요!"와 같은 문장들과, 진리값이 상황에 따라 변하는 "지금은 5시야", "내일 증시는 상승 마감할 거야" 같은 문장들은 명제가 될 수 없다.
            p 불행히도 명제의 참과 거짓을 밝히는 일이 항상 쉽지만은 않다.
            +pos('주장 1.1.3')
            p <b>주장 1.1.3.</b> 음이 아닌 모든 정수 n에 대하여, n^2 + n + 41은 소수(prime)다.
            p 이 명제를 실험해보자. Let
                |\[p(n) ::= n^2 + n + 41\]
                |p(0) = 41부터 시작하여, p(1) = 43, ..., p(39) = 1601까지 모두 소수임을 확인할 수 있다. 그러나 p(40) = 41 * 41은 소수가 아니다. 따라서
                +goto('주장 1.1.3')
                |은 거짓이다. 사실 음이 아닌 모든 정수를 소수로 매핑하는 다항식(상수식 제외)은 존재할 수 없지만, 여기서 말하고자 하는 바는 무한 집합을 대상으로 하는 명제를 유한한 표본들─개수가 많더라도─만으로 검증하기는 일반적으로 요원하다는 점이다.
            p 위처럼 모든 숫자 또는 특정한 종류의 모든 항목에 대한 명제는 매우 흔하며, 이를 위한 특별한 표기도 존재한다. 이를 이용하면
                +goto('주장 1.1.3')
                |은 아래와 같이 표기할 수 있다.
                |\[\forall n \in \mathbb{N}.\ \text{p(n) is prime}\]
                |여기서 기호 식[\forall]식은 "for all"라고 읽고, 식[\mathbb{N}]식은 음이 아닌 정수 집합을 의미한다.
            p <b>추측 (오일러 추측).</b> 방정식 식[a^4+b^4+c^4=d^4]식을 만족하는 양의 정수 a, b, c, d는 존재하지 않는다
            p 이를 아래와 같이 표현할 수 있다
                |\[\forall a, b, c, d \in \mathbb{Z}^+.\ a^4+b^4+c^4 \ne d^4.\]
                |한편 이 명제는 거짓으로 판명되었다. a = 95800, b = 217519, c = 414560, d = 422481
            +pos('명제 1.1.4')
            p <b>명제 1.1.4 (Four Color Theorem).</b> 모든 평면 지도는 4가지 색으로 모든 인접한 두 지역의 색이 서로 다르도록 칠할 수 있다.
            p 이 명제가 참이라는 것을 증명하는 데 컴퓨터가 사용되었다. 증명해야 하는 데이터 셋이 크다면 컴퓨터의 사용은 필수불가결한데, 컴퓨터의 계산에 오차가 존재하지 않는다고 보장할 수 있는 사람은 존재하지 않는다. 그렇다고 방대한 데이터를 일일이 검산할 사람 역시 존재하지 않는다.
            +pos('명제 1.1.5')
            p <b>명제 1.1.5 (Fermat's Last Theorem).</b> 식[n \in \mathbb{N}.\ n > 2.\ x^n + y^n = z^n]식을 만족하는 양의 정수 x, y, z는 존재하지 않는다.
            p 페르마는 이 명제를 적으면서 여백이 부족해 증명을 적지 않았다고 한다. 1994년 영국의 수학자 Andrew Wiles가 명제가 참임을 증명했고, 이 증명은 여백에 적을만한 분량은 아니었다.
            p 마지막으로 간결하지만, 아직 증명되지 않은 명제를 살펴보자.
            +pos('추측 1.1.6')
            p <b>추측 1.1.6 (Goldbach).</b> 2보다 큰 모든 짝수는 2개의 소수의 합으로 표현할 수 있다.
            p 골드바흐의 추측은 10^18까지 참임이 알려져 있지만, 전체가 참인지는 아직 증명되지 않았다.


            +pos('1.2')
            h3 Predicates
            p <b>정의.</b> Predicate ::= 변수에 의해 진리값이 결정되는 문제
            p 일반적인 수학 함수와 다르게, 출력은 항상 true 또는 false다.
            p 예. P(n) ::= "n은 완전제곱수다"


            +pos('1.3')
            h3 The Axiomatic Method
            p 표준 증명 절차는 유클리드가 기원전에 발명했다. 그는 부정할 수 없는 5가지 기하학에 관한 추측을 기반으로 증명했는데, 예컨데 "임의의 2개의 점 사이에는 1개의 직선이 존재한다"가 그 중 하나다. 이처럼 자명하게 참인 명제를 공리(axiom)라 한다.
                +goto('증명')
                |에 사용되는 이미 증명된 명제들은 그 역할과 비중에 따라 몇 가지 용어들로 참조된다.
            ul
                li 정리(Theorem) ::= 중요한 참 명제
                li 보조정리(Lemma) ::= 이후 명제를 증명하는 데 필요한 예비 명제
                li 따름정리(Corollary) ::= 정리로부터 쉽게 도출되는 명제
            p 위 용어들을 엄격하게 구별하여 사용할 필요는 없다.


            +pos('1.4')
            h3 Our Axioms
            div
                p <b>정의.</b> Implication ::= "If P, then Q."처럼 조건을 갖는 명제
                p 종종 식[P\text{ IMPLIES }Q]식 또는 식[P \longrightarrow Q]식로 표현한다
                p 증명을 간결하게 하기 위해 여기서는 중등 수학의 공리(Axiom)들을 증명없이 이용한다

                +pos('1.4.1')
                h4.fake Logical Deductions
                p 논리적 연역(logical deduction) 또는 추론 규칙(inference rule)은 이미 증명된 명제들로부터 새로운 명제를 증명하는 데 이용된다.
                p 기초가 되는 규칙은 <i>긍정 논법(modus ponens)</i>으로, P와 P IMPLIES Q가 참이라면 Q도 참이라는 규칙이다. 긍정 논법은 아래와 같이 표현할 수 있다.
                p <b>규칙.</b> \[{P, P \implies Q \over Q}\]
                p 이 표기법은 선분 위의 문장들(antecedents)이 참으로 증명되면, 선분 아래 문장(conclusion, consequent) 역시 참으로 간주할 수 있음을 나타낸다. 이외에도 자연스럽고 간결한 추론 규칙들이 존재한다.
                p <b>규칙.</b> \[{P \implies Q, Q \implies R \over P \implies R}\]
                p <b>규칙.</b> \[{\operatorname{NOT}(Q) \implies \operatorname{NOT}(P) \over P \implies Q}\]


            +pos('1.5')
            h3 Proving an Implication
            div
                h4.fake Method #1
                ol
                    li 다음과 같이 쓴다. "P가 참이라고 가정한다"
                    li Q가 논리적으로 도출됨을 보인다
                p.fake-h4 Example
                +pos('정리 1.5.1')
                p <b>정리 1.5.1.</b> If 0&lt;=x&lt;=2, then 식[-x^3 + 4x + 1 \gt 0]식.
                p 증명을 써내려가기에 앞서, 왜 이것이 참인지 구상해야 한다. 왼쪽 부등식은 x=0인 경우를 포함하며, 이 때 오른쪽 부등식은 1 > 0으로 참이다. 다음으로, 0 &lt; x &lt;=2의 구간에서, 4x는 식[-x^3]식보다 지배적(식[-x^3+4x \ge 0]식)이다. 따라서 [0, 2] 전체 구간에서 오른쪽 부등식은 참일 것 같다.
                p 여기서 "참일 것 같다"는 부분을 논리적으로 견고한 표현으로 바꾸어야 하는데, 인수분해가 이를 도와준다
                    |\[-x^3 + 4x + 1 = x(2 - x)(2 + x) + \gt 0\]
                p <i>증명.</i> 0&lt;=x&lt;=2가 참이라고 가정하자.
                    |<br>그러면 x, 2-x, 2+x 모두 음이 아니며, 따라서 이들의 곱도 음이 아니다.
                    |<br>이에 1을 더하면 양수임이 명백하며, 따라서 명제는 참이다.
                p.w3-right-align ■

                h4.fake Method #2 - 대우 증명
                ol
                    li 다음과 같이 쓴다. "대우명제를 통해 증명한다"
                    li 식[{\operatorname{NOT}(Q) \implies \operatorname{NOT}(P)}]식을 Method #1으로 증명한다
                p.fake-h4 Example
                +pos('정리 1.5.2')
                p <b>정리 1.5.2.</b> r이 무리수면, 식[\sqrt{r}]식도 무리수다.
                p <i>증명.</i> 대우명제를 통해 증명한다: 식[\sqrt{r}]식이 유리수면, r도 유리수다.
                    |<br>식[\sqrt{r}]식이 유리수라고 가정하자. 그러면 식[\sqrt{r}]식 = m / n을 만족하는 두 정수 m, n이 존재한다.
                    |<br>이때 양변을 제곱하면: r = m^2 / n^2
                    |<br>m과 n이 모두 정수이므로 m^2, n^2도 모두 정수이며, 따라서 r도 유리수다.
                p.w3-right-align ■

            +pos('1.6')
            h3 Proving an "If and Only If"
            div
                h4.fake Method #1
                ol
                    li 다음과 같이 쓴다. "식[P \implies Q]식과 그 역을 증명한다."
                    li 다음과 같이 쓴다. "먼저 식[P \implies Q]식를 증명한다". 이후
                        +goto('1.5')
                        |대로 증명
                    li 다음과 같이 쓴다. "다음으로 식[Q \implies P]식를 증명한다". 이후
                        +goto('1.5')
                        |대로 증명
                h4.fake Method #2 : Iff 체인
                ol
                    li 다음과 같이 쓴다. "If-and-only-if 조건 명제의 체인을 만든다."
                    li 어떠한 식(들)이 P와 동치임을 보이고, 다시 Q와도 동치임을 보인다
                p.fake-h4 Example
                p 표본 x1, ..., xn에 대한 표준편차는 다음과 같이 정의된다: \[\begin{align}\sqrt{(x_1 - \mu)^2 + \cdots + (x_n - \mu)^2 \over n} \tag*{(1.3)}\end{align}\]
                +pos('정리 1.6.1')
                p <b>정리 1.6.1.</b> 표본 x1, ..., xn에 대한 표준편차는 0이다 iff 모든 표본이 평균과 같다
                p <i>증명.</i> "iff" 조건 명제의 체인을 만든다. 표준 편차 (1.3)가 0인 조건식으로부터 시작한다.
                    |\[\begin{align}\sqrt{(x_1 - \mu)^2 + \cdots + (x_n - \mu)^2 \over n} = 0 \tag*{(1.4)}\end{align}\]
                    |오직 0만 제곱근이 0이므로, (1.4) iff
                    |\[\begin{align}(x_1 - \mu)^2 + \cdots + (x_n - \mu)^2 = 0 \tag*{(1.5)}\end{align}\]
                    |실수의 제곱은 항상 음이 아니므로, (1.5) 좌변의 모든 항도 음이 아니다. 따라서 (1.5) iff
                    |\[\begin{align}\text{(1.5) 좌변의 모든 항 }(x_i - \mu)^2 \text{은 0이다.} \tag*{(1.6)}\end{align}\]
                    |이때, 식[(x_i-\mu)^2 = 0 \iff x_i = \mu]식이므로, (1.6)가 참이다 iff
                    |\[\text{모든 } x_i = \mu\]
                p.w3-right-align ■

            +pos('1.7')
            h3 Proof by Cases
            p 명제가 가능한 모든 경우의 수에 대해 성립함을 보일 수 있다면 참임을, 단 하나의 경우라도 거짓임을 보인다면 거짓임을 증명할 수 있다

            +pos('1.8')
            h3 Proof by Contradiction
            p 간접 증명(indirect proof)이라고도 한다.
            ol
                li 다음과 같이 쓴다. "모순(Contradiction)을 통해 증명한다."
                li 다음과 같이 쓴다. "P가 거짓이라고 가정한다"
                li 논리적으로 모순임(거짓임이 알려진 명제가 참이 됨)을 보인다
                li 다음과 같이 쓴다. "이는 모순이며, 따라서 P는 참이다"
            div
                p.fake-h4 Example
                +pos('정리 1.8.1')
                p <b>정리 1.8.1.</b> 식[\sqrt{2}]식는 무리수다
                p <i>증명.</i> 모순을 통해 증명한다. 명제가 거짓이라 가정하자. 식[\sqrt{2}]식가 유리수라면, 이를 표현할 수 있는 기약분수 식[n / d]식이 존재해야 한다(식[\sqrt{2}=1.4\cdots]식가 정수가 아님은 자명하다)
                    |<br>양변을 제곱하면 식[2 = n^2 / d^2]식이 성립하며, 따라서 식[2d^2 = n^2]식이다. 이는 n이 2의 배수여야 함을 의미하며, 또다시 식[2d^2]식는 4의 배수여야 함을 의미한다
                    |<br>결국 n과 d모두 2의 배수여야 하지만, 이는 식[n / d]식이 기약분수라는 것에 위배된다. 이는 모순이며, 따라서 식[\sqrt{2}]식는 무리수다
                p.w3-right-align ■

            +pos('1.9')
            h3 Good Proofs in Practice
            p 증명은 계산이 아니라 에세이다

            h3 Problems
            div
                h4.fake 문제 1.1.
                p Albert는 그의 강의에서 다음 주에 서프라이즈 퀴즈를 치를 것을 예고했다.
                    |<br>학생들은 먼저 다음 주 금요일에 퀴즈가 있을 지 생각해봤다. 그리고 그럴 수 없다고 추론했다: 만약 금요일 전까지 서프라이즈 퀴즈가 없었다면, 퀴즈는 당연히 금요일에 치뤄질 것이고, 이는 더 이상 서프라이즈가 아니기 때문이다.
                    |<br>다음으로 학생들은 퀴즈가 목요일에 있을 지 생각해봤다. 목요일 전까지 퀴즈가 없었다면, 금요일은 퀴즈가 없을 것이므로 당연히 목요일에 퀴즈를 치룰 것이고, 이 또한 이제 서프라이즈가 아니다. 마찬가지로 학생들은 수요일, 화요일, 월요일도 서프라이즈가 될 수 없음을 추론했고, 따라서 다음 주에 서프라이즈 퀴즈를 치루는 것은 불가능하다는 결론에 이르렀다. 즉 Albert는 허풍으로 퀴즈를 예고한 것이다.
                    |<br>학생들의 추론에 문제가 존재하는가?
                p → '다음 주 금요일이 시험날이 될 수 없다'는 중간 결론은 '금요일 전까지 시험을 내지 않았다'는 가정이 참일 때만 유효하며, 해당 가정의 진리값은 실제로 다음 주 금요일 자정을 넘기지 않는 이상 알 수 없으므로, 적절한 수학적 명제로 볼 수 없다. 또한 부적절한 추론 결과인 '다음 주 금요일이 시험날이 아니다'를 이용한 이후의 모든 추론 역시 적절하지 않다.

                h4.fake 문제 1.3.
                p What's going on here? \[1=\sqrt{1}=\sqrt{(-1)(-1)}=\sqrt{-1}\sqrt{-1}=\left(\sqrt{-1}\right)^2=-1\]
                p <b>(a)</b> Precisely identify and explain the mistake(s) in this <i>bogus</i> proof.
                p 식[\sqrt{ab} = \sqrt{a}\sqrt{b}]식는 식[a,b\in \mathbb{R}^{0+}]식인 경우만 성립한다. 따라서 식[\sqrt{(-1)(-1)}=\sqrt{-1}\sqrt{-1}]식 이후의 추론은 모두 잘못됐다
                p <b>(b)</b> Prove (correctly) that if 1 = -1, then 2 = 1.
                p 1 = -1 양변에 1을 더하면 2 = 0. 다시 양변을 2로 나누면 1 = 0. 따라서 2 = 0 = 1이 성립한다
                p <b>(c)</b> 모든 양의 실수 r은 양과 음의 2가지 제곱근을 가진다. 실수의 곱셈에 관한 성질을 이용해 양의 실수 r, s에 대하여 다음이 성립함을 보여라. \[\sqrt{rs}=\sqrt{r}\sqrt{s}\]
                p 주어진 식의 우변을 제곱하면 식[\sqrt{r}\sqrt{s}\sqrt{r}\sqrt{s}]식이다. 곱셈에 관한 교환법칙에 의해 식[\sqrt{r}\sqrt{s}\sqrt{r}\sqrt{s}=\sqrt{r}\sqrt{r}\sqrt{s}\sqrt{s}]식이고, 곱셈에 관한 결합법칙에 의해 식[\sqrt{r}\sqrt{r}\sqrt{s}\sqrt{s}=(\sqrt{r}\sqrt{r})(\sqrt{s}\sqrt{s})=rs]식이다. 양변에서 양의 제곱근을 취하면, 곱셈에 관한 결합법칙에 의해 식[\sqrt{\sqrt{r}\sqrt{s}\sqrt{r}\sqrt{s}} = \sqrt{(\sqrt{r}\sqrt{s})(\sqrt{r}\sqrt{s})} = \sqrt{r}\sqrt{s} = \sqrt{rs}]식임을 알 수 있다.

                h4.fake 문제 1.4.
                p Identify exactly where the bugs are in each of the following bogus proofs.
                p <b>(b)</b> <i>Bogus proof</i> : 식[1¢ = $0.01 = ($0.1)^2 = (10¢)^2 = 100¢ = $1]식 ■
                p 식[$0.01 = $(0.1)^2]식, 식[$^2(0.1)^2=($0.1)^2]식 각각은 성립하지만 식[$ \ne 1, $ \ne 0]식이므로 식[$(0.1)^2 = $^2(0.1)^2]식은 성립하지 않는다

                h4.fake 문제 1.5.
                p 음이 아닌 임의의 두 실수 a, b에 대한 산술 평균은 기하 평균 이상이다. \[{a+b \over 2} \ge \sqrt{ab}\] 다음 증명 과정 중의 문제점을 찾고, 바르게 고치시오
                p <i>Bogus proof.</i>
                    |\begin{align*}
                    |   {a+b \over 2} \ge & \sqrt{ab}, && so \\
                    |   a+b \ge & 2\sqrt{ab}, && so \\
                    |   a^2+2ab+b^2 \ge & 4ab, && so \\
                    |   a^2-2ab+b^2 \ge & 0, && so \\
                    |   (a-b)^2 \ge & 0 && \text{which we know is true.}
                    |\end{align*}
                    |a - b가 실수고, 실수의 거듭제곱은 음이 아니므로 마지막 문장은 참이다. 따라서 명제는 참이다.
                p.w3-right-align ■
                p → 증명해야 하는 명제를 가정에서 참으로 이용하고 있으므로 시작부터 잘못된 증명이다. 또, 증명 순서가 반대로 됐다

                h4.fake 문제 1.7.
                p 양의 정수 n에 대하여, 식[\operatorname{log}_{7}n]식이 항상 정수 또는 무리수임을 증명하시오. 익숙한 수학적 사실들을 이용하되, 증명에 명시할 것.
                p → 모순을 통해 증명한다. 식[\operatorname{log}_{7}n]식이 정수가 아닌 유리수라면, 이를 표현할 수 있는 기약분수 식[{a \over b}]식가 존재해야 한다
                    |<br>\[\operatorname{log}_{7}n = {a \over b} \iff n = 7^{a \over b} \iff n^b=7^a\]
                    |<br>따라서 n은 7의 배수여야 한다. n을 소인수분해하면 식[n=2^{x_1} \cdot 3^{x_2} \cdot 5^{x_3} \cdot 7^{x_4} \cdots prime_k^{x_k} = 7^a]식
                    |<br>이때, 우변의 식[7^a]식은 7외의 소수로 나눌 수 없으므로 식[n=2^{0} \cdot 3^{0} \cdot 5^{0} \cdot 7^{x_4} \cdots prime_k^{0} = 7^{x_4}]식
                    |<br>따라서 식[n^b = 7^{x_4 b} = 7^a]식이며, 식[x_4 b = a \iff {a \over b} = x_4]식이다. 하지만 이는 식[a \over b]식가 기약분수라는 가정에 위배된다
                    |<br>이는 모순이며, 따라서 식[\operatorname{log}_{7}n]식은 정수거나 무리수다
                p.w3-right-align ■

                h4.fake 문제 1.9.
                p 무리수를 무리수의 지수로 올렸을 때, 결과가 유리수가 될 수 있을까? 식[\sqrt{2}^{\sqrt{2}}]식를 고려하여 가능함을 보여라.
                p → case 1. 식[\sqrt{2}^{\sqrt{2}}]식가 유리수인 경우, 명제가 참이 되는 경우가 존재함을 알 수 있다
                    |<br>case 2. 식[\sqrt{2}^{\sqrt{2}}]식가 무리수인 경우, 식[\left(\sqrt{2}^{\sqrt{2}}\right)^\sqrt{2} = \sqrt{2}^{\sqrt{2}\sqrt{2}} = \sqrt{2}^2 = 2]식이므로 명제가 참이 되는 경우가 존재함을 알 수 있다.

                h4.fake 문제 1.12.
                p 식[a^{\sqrt{3}}]식이 유리수인 무리수 a가 존재함을 보여라. 식[\sqrt[3]{2}^{\sqrt{3}}]식을 고려하여 가능함을 보여라.
                p → case 1. 식[\sqrt[3]{2}^{\sqrt{3}}]식이 유리수인 경우, 명제가 참이 되는 경우가 존재함을 알 수 있다.
                    |<br>case 2. 식[\sqrt[3]{2}^{\sqrt{3}}]식이 무리수인 경우, 식[\left(\sqrt[3]{2}^{\sqrt{3}}\right)^\sqrt{3} = \sqrt[3]{2}^{\sqrt{3}\sqrt{3}} = \sqrt[3]{2}^3 = 2]식이므로 명제가 참이 되는 경우가 존재함을 알 수 있다.

                h4.fake 문제 1.16.
                p 서로 다른 자연수 m, n에 대하여, n^2은 m의 배수이지만, n은 m의 배수가 아닌 경우를 제시하라. m이 n보다 작은 경우도 존재할 수 있을까?
                p → m = 4, n = 6

                +pos('문제 1.17.')
                h4.fake 문제 1.17.
                p
                    +goto('정리 1.8.1')
                    |을 얼마나 일반화할 수 있을까? 예를 들어, 식[\sqrt{3}]식은 어떠한가?
                p <i>증명.</i> 모순을 통해 증명한다. 식[\sqrt{3}]식이 유리수라면, 이를 표현할 수 있는 기약분수 식[n / d]식이 존재해야 한다(식[\sqrt{3}=1.7\cdots]식이 정수가 아님은 자명하다)
                    |<br>양변을 제곱하면 식[3 = n^2 / d^2]식이 성립하며, 따라서 식[3d^2 = n^2]식이다. 이는 n이 3의 배수여야 함을 의미하며, 또다시 식[3d^2]식는 9의 배수여야 함을 의미한다
                    |<br>결국 n과 d모두 3의 배수여야 하지만, 이는 식[n / d]식이 기약분수라는 것에 위배된다. 이는 모순이며, 따라서 식[\sqrt{3}]식은 무리수다
                p.w3-right-align ■

                h4.fake 문제 1.19.
                p 모순을 이용해 식[\sqrt{3}+\sqrt{2}]식가 무리수임을 증명하라. <i>Hint</i> : 식[(\sqrt{3}+\sqrt{2})(\sqrt{3}-\sqrt{2})]식
                p <i>증명.</i> 모순을 통해 증명한다. 식[\sqrt{3}+\sqrt{2}]식가 유리수라면, 이를 표현할 수 있는 기약분수 식[n / d]식이 존재해야 한다(식[\sqrt{3}+\sqrt{2}=3.14\cdots]식이 정수가 아님은 자명하다)
                    |<br>이때, 식[(\sqrt{3}+\sqrt{2})(\sqrt{3}-\sqrt{2})=1]식이므로, 식[\sqrt{3}-\sqrt{2}=d/n]식이다
                    |<br>따라서 식[(\sqrt{3}+\sqrt{2})+(\sqrt{3}-\sqrt{2})=2\sqrt{3}=n / d + d / n]식이며, 이는 식[\sqrt{3}]식이 유리수임을 의미한다
                    |<br>그러나
                    +goto('문제 1.17.')
                    |에서 증명하였듯 이는 식[\sqrt{3}]식이 무리수라는 것에 위배된다. 이는 모순이며, 따라서 식[\sqrt{3}+\sqrt{2}]식는 무리수다
                p.w3-right-align ■

                h4.fake 문제 1.20.
                p 여기에서
                    +goto('문제 1.17.')
                    |의 일반화를 보인다.
                p <b>보조정리.</b> 모든 계수가 정수인 다항식 \[a_0+a_1x+a_2x^2+\cdots+a_{m-1}x^{m-1}+x^m\]의 임의의 실수 해는 정수거나 무리수다
                p <b>(a)</b> 보조정리를 이용해 어떤 정수의 m 거듭제곱이 아닌 임의의 정수 k에 대하여 식[\sqrt[m]{k}]식가 무리수임을 보여라
                p <i>증명.</i> 모순을 통해 증명한다. 보조정리에 따라, 정수 n에 대한 방정식 식[n - k^m = 0]식의 실수 해 k는 정수거나 무리수다
                    |<br>k가 정수라고 가정하자. 그러면 식[n=k^m]식으로부터 식[k=\sqrt[m]{n}]식을 얻는다
                    |<br>그러나 이는 k가 어떤 정수의 m 거듭제곱이 아니라는 전제에 위배된다. 이는 모순이며, 따라서 k는 무리수다
                p.w3-right-align ■
                p <b>(b)</b> 보조정리를 증명하라
                p <i>증명.</i> 모순을 통해 증명한다. 실수 해 x가 정수가 아닌 유리수라고 가정하자. 그러면 x는 두 정수 d, n으로 이루어진 기약분수로 표현할 수 있다. 식[x = n / d]식
                    |<br>식[a_0+a_1(n/d)+a_2(n/d)^2+\cdots+a_{m-1}(n/d)^{m-1}+(n/d)^m = 0]식
                    |<br>양변에 식[d^m]식을 곱하면, 식[a_0d^m+a_1nd^{m-1}+a_2n^2d^{m-2}+\cdots+a_{m-1}n^{m-1}d+n^m = d(a_0d^{m-1}+a_1nd^{m-2}+a_2n^2d^{m-3}+\cdots+a_{m-1}n^{m-1})+n^m = 0]식
                    |<br>이는 d를 n으로 나눌 수 있음을 의미한다. 그러나 이는 n / d가 기약분수라는 가정에 위배된다. 이는 모순이며, 따라서 실수 해 x는 정수가 아닌 유리수가 아니다. 다시 말해 실수 해 x는 정수거나 무리수다
                p.w3-right-align ■

                h4.fake 문제 1.26.
                p 다항식 p(n) ::= n^2 + n + 41에 대하여, n = 40일 때는 소수가 아님을
                    +goto('주장 1.1.3')
                    |에서 보였다. 여기서는 모든 계수가 정수인 임의 다항식 q(n)이 소수만 생성할 수는 없음을 보인다. c ::= q(0)를 q의 상수항이라고 하자. 식[q(n) ::= c + c_1x + c_2x^2 + \cdots + c_ix^i]식
                p <b>(a)</b> 식[\forall{m} \in \mathbb{Z}.]식 q(cm)이 c의 배수임을 보여라
                p → 식[q(cm) = c + c_1(cm) + c_2(cm)^2 + \cdots + c_i(cm)^i = c\left(1 + c_1m + c_2cm^2 + \cdots + c_ic^{i-1}m^i\right)]식
                p <b>(b)</b> q가 상수가 아닌 다항식이고 c > 1일때, 음이 아닌 정수 식[n \in \mathbb{N}]식에 대하여 소수가 아닌 식[q(n) \in \mathbb{Z}]식가 무한히 존재함을 보여라
                p → (a)에 의해 2이상의 모든 정수 m에 대하여 q(cm)이 c의 배수 -- 즉 소수가 아님을 알 수 있다
                p <b>(c)</b> 상수가 아닌 임의 다항식 q에 대하여, q(n)이 소수가 아닌 식[n \in \mathbb{N}]식이 항상 존재함을 결론지어라
                p → c &lt;= 1인 임의 다항식 q는 q(0)이 소수가 아니므로, 마찬가지로 소수가 아닌 q(n)이 존재함을 알 수 있다


        +pos('2')
        h2 The Well Ordering Principle
        div
            p Every <i>nonempty</i> set of <i>nonnegative integers</i> has a <i>smallest</i> element.

            +pos('2.1')
            h3 Well Ordering Proofs
            p 앞서 식[\sqrt{2}]식가 무리수임을 증명할 때, 임의의 양의 정수 m, n에 대하여, m/n의 기약분수 표기가 존재함을 이용했다. WOP를 이용하여 기약분수가 존재함을 증명해보자
            p → 기약분수 표현이 존재하지 않는 분수 m/n에 대하여, 그러한 분자들의 집합을 C라고 하자. 그러면 식[m \in \mathbb{C}]식이므로, C는 공집합이 아니다
                |<br>WOP에 의하여, C에는 최소 원소 식[m_0 \in \mathbb{C}]식가 존재한다. 그러면 기약분수 표현이 존재하지 않는 식[m_0 / n_0]식가 존재한다(식[n_0]식는 양의 정수)
                |<br>식[m_0 / n_0]식가 기약분수가 아니므로, 식[m_0, n_0]식에 대한 소수 공약수 p가 존재한다. 그러면 식[{m_0/p \over n_0/p} = m_0 / n_0]식이고, 좌변의 분수 역시 기약분수 표현이 존재하지 않아야 한다
                |<br>C의 정의에 의해, 분자 식[m_0/p]식 역시 C의 원소여야 한다. 하지만 이는 식[m_0]식가 C의 최소 원소라는 것에 모순이다. 따라서 C는 공집합이어야 한다. 다시 말해, 기약분수로 표현할 수 없는 식[m/n]식은 존재하지 않는다
            p.w3-right-align ■

            +pos('2.2')
            h3 Template for WOP Proofs
            p WOP을 이용해 식[P(n)\text{ is true for all }n \in \mathbb{N}]식을 증명하기
            ol
                li P(n)의 반례집합 C를 정의한다. 식[C ::= \left\{n \in \mathbb{N} | \operatorname{NOT}(P(n))\text{ is true.}\right\}]식
                li 모순을 이용한 증명을 위해 C가 공집합이 아니라고 가정한다
                li WOP에 의해, C에는 최소 원소 c가 존재해야 한다
                li 모순에 도달한다
                p e.g. P(c)가 참임을 보이기, c보다 작은 원소가 C에 존재함을 보이기
                li C는 공집합이다. 따라서 P(n)은 항상 참이다

            div
                +pos('정리 2.2.1')
                h4.fake Summing the Integers
                +pos('정리 2.2.1.')
                p <b>정리 2.2.1.</b> \[\forall n \in \mathbb{N}. \sum_{1 \le i \le n} = n(n+1)/2\]
                p <i>증명.</i> 반례집합 식[C ::= \left\{n \in \mathbb{N} | \sum_{1 \le i \le n} \ne n(n+1)/2\right\}]식가 공집합임을 보여 증명한다
                    |<br>C가 원소를 가진다고 가정하자. WOP에 의해 C에는 최소 원소 c가 존재한다. 이때, n=0일때 식[\sum_{1 \le i \le 0}=0]식이므로 c > 0이다
                    |<br>c-1 >= 0이므로, 식[\sum_{1 \le i \le (c-1)}=(c-1)c/2]식가 성립한다. 양변에 c를 더하면 식[\sum_{1 \le i \le c} = (c-1)c/2 + c = c(c+1)/2]식이므로, 식[c \notin C]식이다
                    |<br>이는 c가 C의 최소 원소라는 것에 모순이므로, C는 공집합이며, 따라서 명제는 참이다
                p.w3-right-align ■

            +pos('2.3')
            h3 Factoring into Primes
            +pos('정리 2.3.1.')
            p <b>정리 2.3.1.</b> 1보다 큰 모든 자연수는 소수의 곱으로 표현할 수 있다
            p <i>증명.</i> 반례집합 C가 원소를 가진다고 가정하자. WOP에 의해 C에는 최소 원소 n > 1이 존재한다
                |<br>이때, n은 소수일 수 없으므로 식[1 &lt; a, b &lt; n]식를 만족하는 두 자연수 a, b의 곱이다
                |<br>n이 C의 최소원소이므로 식[a, b \notin C]식며, 따라서 a, b 각각은 소인수분해 가능하다
                |<br>하지만 이는 식[n = ab]식 역시 소인수분해 가능하며, 이는 C가 원소를 가질 수 없음을 의미한다. 따라서 명제는 참이다
            p.w3-right-align ■

            +pos('2.4')
            h3 Well Ordered Sets
            p 어떤 실수 집합에 대하여, 공집합이 아닌 모든 부분집합이 최소 원소를 갖는 경우, 이 집합은 well ordered set이다
            p 최소 원소를 갖는 집합이 항상 well ordered set은 아니다. e.g. 음이 아닌 유리수 집합은 최소 원소 0을 갖지만, 그 부분집합인 양의 유리수 집합은 최소 원소가 존재하지 않는다

            +pos('정리 2.4.1.')
            p <b>정리 2.4.1.</b> 음이 아닌 임의 정수 n에 대하여, 집합 식[S=\left\{m \in \mathbb{N}|m\ge -n\right\}]식는 well ordered set이다
            p <i>증명.</i> S의 모든 원소에 n을 더한 새로운 집합 S+n을 생각해보자. WOP에 의해 S+n은 0 이상의 최소 원소를 가진다. 또, S+n의 공집합이 아닌 모든 부분집합 역시 WOP에 의해 0 이상의 최소 원소를 가진다
                |<br>다시 S+n 집합의 모든 원소에서 n을 뺀 집합 S를 생각해보면, S와 공집합이 아닌 S의 모든 부분집합은 -n 이상의 최소 원소를 가짐을 알 수 있다
            p.w3-right-align ■

            +pos('정의 2.4.2.')
            p <b>정의 2.4.2.</b> 실수 집합 S의 하한(lower bound) ::= 식[\forall s \in S. s \ge b]식를 만족하는 실수 b
                |<br>실수 집합 S의 상한(upper bound) ::= 식[\forall s \in S. s \le b]식를 만족하는 실수 b

            +pos('따름정리 2.4.3.')
            p <b>따름정리 2.4.3.</b> Lower bound를 갖는 임의의 정수 집합은 well ordered set이다
            p <i>증명.</i> 정수 집합이 lower bound로 식[b \in \mathbb{R}]식를 갖는 경우, 정수 식[n = \lfloor b \rfloor]식 역시 집합의 lower bound다. 따라서
                +goto('정리 2.4.1.')
                |에 의하여 집합이 well ordered set임을 알 수 있다
            p.w3-right-align ■

            +pos('따름정리 2.4.4.')
            p <b>따름정리 2.4.4.</b> Upper bound를 갖는 임의의 정수 집합은 최대 원소가 존재한다
            p <i>증명.</i> 정수 집합 S가 upper bound로 식[b \in \mathbb{R}]식를 가질 때, 모든 원소에 -1을 곱한 집합 -S를 생각해보자.
                +goto('따름정리 2.4.3.')
                |에 의해 -S가 well ordered set이고, 최소 원소 -m을 가짐을 알 수 있으며, 다시 -S의 모든 원소에 -1을 곱한 집합 S는 최대 원소 m을 가짐을 알 수 있다
            p.w3-right-align ■

            +pos('보조정리 2.4.5.')
            p <b>보조정리 2.4.5.</b> 공집합이 아닌 모든 유한 실수 집합은 well ordered set이다
            p <i>증명.</i> 유한 집합 크기에 관한 WOP로 증명한다
                |<br>Well ordered set이 아닌 유한 실수 집합의 크기 n에 대한 집합 C를 생각하자. WOP에 의해 C는 최소 원소 m을 갖는다. 이때, 원소가 하나인 집합이 well ordered set임은 자명하므로 m >= 2다
                |<br>이제 원소를 m개 갖는 유한 실수 집합 F를 생각하자. F의 임의 원소 식[r_0]식를 F에서 제거한 집합을 F'이라고 하자. 이때, F'의 크기는 m-1이므로 최소 원소 식[r_1]식을 가진다
                |<br>따라서 식[r_0, r_1]식 중 작은 값이 F의 최소 원소가 됨을 알 수 있으며, 이는 m이 C의 원소라는 것에 위배된다. 이는 모순이며, 따라서 C는 공집합이다
            p.w3-right-align ■
            div
                +pos('2.4.1')
                h4.fake A Different Well Ordered Set(Optional)
                p n/(n+1) 꼴로 표현되는 집합 식[\mathbb{F}]식는 well ordered set이다
                    |\[{0 \over 1},{1 \over 2},{2 \over 3},\cdots,{n \over n+1},\cdots\]
                    |간단하게 분자가 가장 작은 원소가 최소 원소다

                +pos('보조정리 2.4.6.')
                p <b>보조정리 2.4.6.</b> 식[\mathbb{N}+\mathbb{F}]식는 well ordered set이다
                p <i>증명.</i> 식[\mathbb{N}+\mathbb{F}]식의 공집합이 아닌 임의 부분집합 S를 생각한다. S의 임의 원소는 n + f로 표현 가능하다 -- where 식[n\in\mathbb{N_s},f\in\mathbb{F_s},\mathbb{N_s}\subset\mathbb{N},\mathbb{F_s}\subset\mathbb{F}]식
                    |<br>식[\mathbb{N}]식이 well ordered set이므로, 식[\mathbb{N_s}]식는 최소원소 식[n_s]식를 가진다
                    |<br>이제 S의 원소 중 식[n_s + f_s]식로 표현 가능한 모든 원소들을 생각해보자 -- where 식[f_s\in\mathbb{F_ss},\mathbb{F_ss}\subset\mathbb{F_s}]식
                    |<br>식[\mathbb{F}]식가 well ordered set이므로, 식[\mathbb{F_ss}]식는 최소원소 식[f_{ss}]식를 가진다
                ul
                    li n > 식[n_s]식인 n이 식[\mathbb{N_s}]식에 존재하지 않는 경우 : 식[n_s+f_{ss}]식가 S의 최소원소임은 자명하다
                    li n > 식[n_s]식인 n이 식[\mathbb{N_s}]식에 존재하는 경우 :
                    p 가능한 모든 n + f에 대하여 식[n - n_s >= 1]식, 식[f - f_{ss} > -1]식이 각각 성립하므로 식[(n - n_s) + (f - f_{ss}) > 0]식이 성립한다. 따라서 식[n + f > n_s + f_{ss}]식이며, 식[n_s+f_{ss}]식가 S의 최소원소임을 알 수 있다
                p.w3-right-align ■

            h3 Problems
            div
                h4.fake 문제 2.5.
                p WOP를 이용하여 다음 방정식의 해가 모두 양의 정수인 경우는 존재하지 않음을 증명하라 \[4a^3+2b^3=c^3\]
                p → 가능한 모든 해에 대하여, 식[s = a+b+c]식의 집합 S을 생각해보자. 만약 해가 존재한다면 WOP에 의해 S는 최소 원소 식[s_m=a_m+b_m+c_m]식을 갖는다
                    |<br>식[4a^3+2b^3=c^3]식의 양변을 2로 나누면 식[2a^3+b^3=c^3/2]식이며, 이를 통해 c가 2의 배수(식[c=2c']식)임을 알 수 있다. 식[2a^3+b^3=4c'^3]식
                    |<br>마찬가지로 b, a도 2의 배수(식[a=2a', b=2b']식)임을 알 수 있으며, 이제 식[a_m/2, b_m/2, c_m/2]식도 방정식의 해임을 보여 S가 공집합임을 보이겠다
                    |<br>식[4(a_m/2)^3+2(b_m/2)^3=(c_m/2)^3]식의 양변에 8을 곱하면 식[4a_m^3+2b_m^3=c_m^3]식이며, 따라서 식[s_m]식은 S의 최소 원소가 아님을 알 수 있다. 따라서 S는 공집합이며, 방정식의 해가 모두 양의 정수인 경우는 존재하지 않는다
                p.w3-right-align ■

                h4.fake 문제 2.6.
                p 1, 2, 4, ..., 식[2^m]식 달러가 각각 들어있는 봉투들을 하나씩 받았다. 다음과 같은 정의가 주어질 때,
                P <b>속성</b> <i>m</i> : 주어진 봉투들 중 일부를 선택한 금액의 합계로 식[2^{m+1}]식보다 작은 임의의 음이 아닌 정수를 만들 수 있다
                p WOP를 이용하여 이것이 음이 아닌 모든 정수 m에 대하여 참임을 증명하라
                p → WOP를 적용하기 앞서 반례가 될 수 없는 경우를 살펴본다.
                ul
                    li m=0 : [0, 1)를 모두 만들 수 있는가?
                    p 봉투를 하나도 선택하지 않는 경우 0을 만들 수 있으므로 m=0은 반례가 될 수 없다
                p 이제 속성을 만족하지 않는 음이 아닌 정수 m의 집합 C를 생각하자. C가 공집합이 아니라면 WOP에 의해 최소 원소 c > 0가 존재한다. 이제 관건은 1, 2, ..., 식[2^c]식의 조합으로 [0, 식[2^{c+1}]식)을 모두 만들 수 있는가?가 된다. 이때, 구간을 2개로 나눌 수 있음에 주목하자
                ul
                    li [0, 식[2^c]식)
                    p c-1은 속성을 만족하므로, 식[2^c]식 봉투를 제외한 조합으로 모두 만들 수 있다
                    li [식[2^c]식, 식[2^{c+1}]식)
                    p 구간 [0, 식[2^c]식)에 속하는 모든 수에 대하여, 해당 수를 만드는 봉투 조합에 식[2^c]식를 추가함으로써 구간 [식[2^c]식, 식[2^{c+1}]식)의 모든 수 역시 1, 2, ..., 식[2^c]식의 조합으로 만들 수 있음을 알 수 있다
                p 이는 c가 속성을 만족함을 의미하며, 따라서 C는 공집합이고, 속성은 음이 아닌 모든 정수에 대하여 참이다
                p.w3-right-align ■

                h4.fake 문제 2.7.
                p WOP를 이용하여 8 이상의 임의 정수를 3의 배수와 5의 배수의 합으로 표현할 수 있음을 증명하라
                p → WOP를 적용하기 앞서 반례가 될 수 없는 경우를 살펴본다
                ul
                    li 8 = 3 + 5
                    li 9 = 3 * 3
                    li 10 = 2 * 5
                p 이제, 3의 배수와 5의 배수의 합으로 표현할 수 없는 8 이상의 정수의 집합 C를 생각하자. C가 공집합이 아니라면 WOP에 의해 최소 원소 c >= 11가 존재한다
                    |<br>이때, c - 3 >= 8은 C의 원소가 아니므로 3의 배수와 5의 배수의 합으로 표현할 수 있다: \[c - 3 = 3a + 5b\]
                    |여기서 양변에 3을 더하면 c = 3(a + 1) + 5b. 이는 c가 C의 원소라는 것에 모순이다. 따라서 C는 공집합이고, 명제는 참이다
                p.w3-right-align ■

                h4.fake 문제 2.10.
                p WOP를 이용하여 \[\begin{align}n\le 3^{n/3} \tag*{(2.6)}\end{align}\]이 임의의 음이 아닌 정수 n에 대하여 성립함을 보여라
                p → 부등식은 식[n^3 \le 3^n]식과 동치다. 먼저 반례가 될 수 없는 경우를 살펴본다
                ul
                    li n = 0. 식[0 \le 1]식
                    li n = 1. 식[1 \le 3]식
                    li n = 2. 식[8 \le 9]식
                    li n = 3. 식[27 \le 27]식
                p 반례 집합 C의 최소 원소 c >= 4가 존재한다고 가정하자. 식[c^3 \gt 3^c]식. 이때, c-1은 C의 원소가 아니므로 부등식이 성립한다. 식[(c-1)^3 \le 3^{c-1}]식
                    |<br>양변에 식[\left({c \over c-1}\right)^3]식을 곱하면 식[c^3 \le \left({c \over c-1}\right)^3 3^{c-1}]식
                    |<br>따라서 식[\left({c \over c-1}\right)^3 3^{c-1} \gt 3^c]식이 성립해야 한다
                    |<br>\begin{align*}
                    |\iff & \left({c \over c-1}\right)^3 = \left(1 + {1 \over c-1}\right)^3 \gt 3 \\
                    |\iff & {1 + {1 \over c-1}} \gt 1.44\cdots \\
                    |\iff & {1 \over c-1} \gt 0.44\cdots \\
                    |\iff & 1 \gt (c-1)\cdot 0.44\cdots
                    |\end{align*}
                    |이때, c-1 >= 3이므로 부등식은 성립하지 않는다. 따라서 C는 공집합이며, 명제는 참이다
                p.w3-right-align ■

        +pos('3')
        h2 Logical Formulas
        div
            +pos('3.1')
            h3 Propositions from Propositions
            p Propositional variables 또는 Boolean variable은 T(true) 또는 F(false) 값만 가질 수 있는 변수다
            div
                +pos('3.1.1')
                h4.fake NOT, AND, OR
                p 명제를 결합하는 데 NOT, AND, OR 등의 연산을 이용한다. 이러한 연산의 의미는 진리표(truth table)를 이용하여 표현할 수 있다. 예를 들어 명제 "NOT(P)"는 P에 의해 그 값이 결정되며, 진리표는 다음과 같다
                table.no-sort
                    +ths('P', 'NOT(P)')
                    +tds('T', 'F')
                    +tds('F', 'T')
                table.no-sort
                    +ths('P', 'Q', 'P AND Q')
                    +tds('T', 'T', 'T')
                    +tds('T', 'F', 'F')
                    +tds('F', 'T', 'F')
                    +tds('F', 'F', 'F')
                table.no-sort
                    +ths('P', 'Q', 'P OR Q')
                    +tds('T', 'T', 'T')
                    +tds('T', 'F', 'T')
                    +tds('F', 'T', 'T')
                    +tds('F', 'F', 'F')
                table.no-sort
                    +ths('P', 'Q', 'P XOR Q')
                    +tds('T', 'T', 'F')
                    +tds('T', 'F', 'T')
                    +tds('F', 'T', 'T')
                    +tds('F', 'F', 'F')

                +pos('3.1.2')
                h4.fake If and Only If
                p IFF는 동치 -- 즉 두 진리값이 일치하는 경우에만 참이다
                table.no-sort
                    +ths('P', 'Q', 'P IFF Q')
                    +tds('T', 'T', 'T')
                    +tds('T', 'F', 'F')
                    +tds('F', 'T', 'F')
                    +tds('F', 'F', 'T')

                +pos('3.1.3')
                h4.fake IMPLIES
                table.no-sort
                    +ths('P', 'Q', 'P IMPLIES Q')
                    +tds('T', 'T', 'T')
                    +tds('T', 'F', 'F')
                    +tds('F', 'T', 'T')
                    +tds('F', 'F', 'T')
                ul
                    li P IMPLIES Q == NOT(P) OR Q
                    li 골드바흐의 추측이 참이라면, 임의 실수 x에 대하여 식[x^2 \ge 0]식이다
                    p 전제와 무관하게 결론이 항상 참이므로 명제는 참이다
                    li 돼지가 날 수 있다면, 당신의 계정은 해킹당하지 않는다
                    p 전제가 거짓이므로 명제는 참이다
                    li 전제가 거짓일 때 명제가 참이 되는 것은 일반 상식과 거리가 있지만, 오히려 이것이 일상의 문제보다 수학적 implication을 간결하고 유용하게 해준다
                    p 예를 들어, 아래와 같은 12개의 규칙을 갖는 시스템 명세를 생각해보자
                    +asCode().
                        If  the     system sensors are in condition 1,
                            then    the system takes action 1.
                        ...
                        If  the     system sensors are in condition 12,
                            then    the system takes action 12.
                    p 다음과 같이 정의하자
                    +asCode().
                        Ci ::= 시스템이 상태 i를 감지?
                        Ai ::= 시스템이 동작 i를 취함?
                    p 그러면 시스템 명세는 다음과 같이 간결한 하나의 논리식으로 표현할 수 있다
                    +pos('(3.1)')
                    +asCode('text', '(3.1)') (C1 IMPLIES A1) AND (C2 IMPLIES A2) AND ... AND (C12 IMPLIES A12)
                    p 이제 시스템이 C2, C5 상태만을 감지하고, 실제로 A2, A5 동작을 실행한 경우를 생각해보자. 시스템은 명세에 따라 작동했으며, 우리는 식
                        +goto('(3.1)')
                        |이 참이길 바란다. 하지만 식
                        +goto('(3.1)')
                        |이 참이기 위해서는, 전제가 거짓인 나머지 10개의 IMPLIES 항들 모두가 참이어야 한다. 바로 이것이 수학적 implication 규칙으로부터 얻는 간결함이다

            +pos('3.2')
            h3 Propositional Logic in Computer Programs
            div
                +pos('3.2.1')
                h4.fake Truth Table Calculation
                p 진리표를 이용하여 서로 다른 두 논리식이 동치임을 한 눈에 파악할 수 있다. 복잡한 식은 보다 간결한 동치 식으로 교체함으로써 가독성을 높이고, 계산에 필요한 연산을 줄일 수 있다

                +pos('3.2.2')
                h4.fake Cryptic Notation
                p 프로그래머나 전자공학자와 마찬가지로 수학자들도 AND, OR 등의 논리 연산을 표현하는 연산자를 사용한다
                table.no-sort
                    +ths('English', 'Symbolic Notation')
                    tr
                        td NOT(P)
                        td 식[\neg{P}]식 또는 식[\overline{P}]식
                    tr
                        td P AND Q
                        td 식[P \land Q]식
                    tr
                        td P OR Q
                        td 식[P \lor Q]식
                    tr
                        td P IMPLIES Q, if P then Q
                        td 식[P \longrightarrow Q]식
                    tr
                        td P IFF Q
                        td 식[P \iff Q]식
                    tr
                        td P XOR Q
                        td 식[P \oplus Q]식

            +pos('3.3')
            h3 Equivalence and Validity
            div
                +pos('3.3.1')
                h4.fake Implications and Contrapositives
                ul
                    li 명제의 대우(Contrapositive)
                    p Implication과 그의 대우는 동치다. P IMPLIES Q == NOT(Q) IMPLIES NOT(P)
                    li 명제의 역(Converse)
                    p IFF는 implication과 그의 역 모두가 참인 경우와 동치다. P IFF Q == (P IMPLIES Q) AND (Q IMPLIES P)

                +pos('3.3.2')
                h4.fake Validity and Satisfiability
                ul
                    li <i>Valid</i> formula : 변수와 무관하게 항상 참인 식
                    p 두 식 F, G에 대하여, (F IFF G)가 valid면 F와 G는 동치다
                    li <i>Satisfiable</i> formula : 변수에 따라 참/거짓이 바뀌는 식
                    p (식 P가 satisfiable이다) IFF (NOT(P)는 valid하지 않다)

            +pos('3.4')
            h3 The Algebra of Propositions
            div
                +pos('3.4.1')
                h4.fake Propositions in Normal Form
                +pos('정리 3.4.1.')
                p <b>정리 3.4.1.</b> 모든 명제 식은 그와 동치인 full DNF, full CNF가 존재한다
                p e.g. A AND (B OR C)
                table.no-sort
                    +ths('A', 'B', 'C', 'A AND (B OR C)')
                    +tds('T', 'T', 'T', 'T')
                    +tds('T', 'T', 'F', 'T')
                    +tds('T', 'F', 'T', 'T')
                    +tds('T', 'F', 'F', 'F')
                    +tds('F', 'T', 'T', 'F')
                    +tds('F', 'T', 'F', 'F')
                    +tds('F', 'F', 'T', 'F')
                    +tds('F', 'F', 'F', 'F')
                ul
                    li DNF(Disjunctive normal form) : Sum-of-products. 서로 다른 변수들의 AND 절들을 OR 연산으로 연결한 것
                    li Full DNF : 식이 참이 되는 행들을 OR로 연결한다
                    p (A AND B AND C) OR (A AND B AND NOT(C)) OR (A AND NOT(B) AND C)
                    li Full DNF를 보다 간결한 동치 DNF로 표현할 수 있는 경우도 있다
                    p (A AND B) OR (A AND C)
                    li CNF(Conjunctive normal form) : 서로 다른 변수들의 OR 절들을 AND 연산으로 연결한 것
                    li Full CNF : 식이 거짓이 되는 행들의 NOT 표현을 AND로 연결한다
                    p (NOT(A) OR B OR C) AND (A OR NOT(B) OR NOT(C)) AND (A OR NOT(B) OR C) AND (A OR B OR NOT(C)) AND (A OR B OR C)

                +pos('3.4.2')
                h4.fake Proving Equivalences
                ul
                    li 변수가 늘어날 때 검사해야 되는 진리표의 크기는 기하급수로 늘어난다
                    li 두 식이 동치임을 보이는 데 진리표보다는, 대수학이 유용할 수 있다. 첫 번째 단계는 논리식에 사용되는 다양한 연산자들을 모두 AND, OR, NOT의 조합으로 변환하는 것이다
                table.no-sort
                    +tds('교환법칙 of AND', 'A AND B = B AND A')
                    +tds('결합법칙 of AND', 'A AND (B AND C) = (A AND B) AND C')
                    +tds('분배법칙 of AND over OR', 'A AND (B OR C) = (A AND B) OR (A AND C)')
                    +tds('분배법칙 of OR over AND', 'A OR (B AND C) = (A OR B) AND (A OR C)')
                    +tds('항등원 of AND', 'T AND A = A')
                    +tds('zero of AND', 'F AND A = F')
                    +tds('멱등 of AND', 'A AND A = A')
                    +tds('contradiction of AND', 'A AND NOT(A) = F')
                    +tds('double negation', 'NOT(NOT(A)) = A')
                    +tds('validity of OR', 'A OR NOT(A) = T')
                    +tds('De Morgan for AND', 'NOT(A AND B) = NOT(A) OR NOT(B)')
                    +tds('De Morgan for OR', 'NOT(A OR B) = NOT(A) AND NOT(B)')

                +pos('정리 3.4.2.')
                p <b>정리 3.4.2.</b> 위 동치 관계를 이용하여 임의 논리식을 하나의 정규식과 동치임을 보일 수 있다
                p 예를 들어 A, B, C 세 변수로 이루어진 논리식 NOT((A AND B) OR (A AND C))을 full DNF로 정규화하는 절차는 아래와 같다
                ol
                    li AND, OR, NOT 외의 연산자는 AND, OR, NOT으로 변환
                    li 식을 AND 항의 OR 합으로 변환
                    ul
                        li NOT(A AND B) AND NOT(A AND C)
                        li = (NOT(A) OR NOT(B)) AND (NOT(A) OR NOT(C))
                        li = (NOT(A) AND (NOT(A) OR NOT(C))) OR (NOT(B) AND (NOT(A) OR NOT(C)))
                        li = (NOT(A) AND NOT(A)) OR (NOT(A) AND NOT(C)) OR (NOT(A) AND NOT(B)) OR (NOT(B) AND NOT(C))
                        li = NOT(A) OR (NOT(A) AND NOT(B)) OR (NOT(A) AND NOT(C)) OR (NOT(B) AND NOT(C))
                    li 변수가 3개 미만인 AND 항은 나머지 변수를 붙여 확장
                    ul
                        li NOT(A) = (NOT(A) AND B AND C) OR (NOT(A) AND B AND NOT(C)) OR (NOT(A) AND NOT(B) AND C) OR (NOT(A) AND NOT(B) AND NOT(C))
                        li (NOT(A) AND NOT(B)) = (NOT(A) AND NOT(B) AND C) OR (NOT(A) AND NOT(B) AND NOT(C))
                        li (NOT(A) AND NOT(C)) = (NOT(A) AND B AND NOT(C)) OR (NOT(A) AND NOT(B) AND NOT(C))
                        li (NOT(B) AND NOT(C)) = (A AND NOT(B) AND NOT(C)) OR (NOT(A) AND NOT(B) AND NOT(C))
                    li 동일항 제거
                    p = (A AND NOT(B) AND NOT(C)) OR (NOT(A) AND B AND C) OR (NOT(A) AND B AND NOT(C)) OR (NOT(A) AND NOT(B) AND C) OR (NOT(A) AND NOT(B) AND NOT(C))

                +pos('정리 3.4.3.')
                p <b>정리 3.4.3.</b> 두 논리식이 동치다 iff 두 논리식이 위에 제시된 공리들을 이용해 같음을 보일 수 있다

            +pos('3.5')
            h3 The SAT Problem
            ul
                li <b>SAT</b> ::= 명제가 참일 수 있는 지(satisfiable)에 대한 일반적인 결정 문제
                li 일반적으로 입력 크기 n에 대하여 복잡도가 다항식 이하면 효율적인 알고리즘으로 간주한다 -- O(n^a)
                li SAT에 대한 효율적인 일반 해법은 아직 없다
                li SAT에 대한 효율적인 해법이 등장하면 좋을 것 같지만, 심각한 문제도 동시에 발생한다 -- 기존 암호학의 무력화
                li SAT에 대해 다항 시간 해법이 존재하지 않는다는 증명도 아직 없다 -- P vs NP 문제

            +pos('3.6')
            h3 Predicate Formulas
            div
                +pos('3.6.1')
                h4.fake Quantifiers
                ul
                    li for all : 식[\forall]식
                    li there exists : 식[\exists]식
                    li Universal quantification : 명제가 항상 참이라고 한정하는 것
                    li Existential quantification : 명제가 참일 수 있다고 한정하는 것

                +pos('3.6.2')
                h4.fake Mixing Quantifiers
                p e.g. 식[\forall{n}\in\text{Evens }\exists{p}\in\text{Primes }\exists{q}\in\text{Primes. }n=p+q]식

                +pos('3.6.3')
                h4.fake Order of Quantifiers
                p 서로 다른 종류의 한정자 순서를 변경하면 보통 명제의 의미가 달라짐에 유의

                +pos('3.6.4')
                h4.fake Variables Over One Domain
                p 모든 변수의 정의역이 동일하다면 표기에서 생략할 수 있다
                p e.g. 식[\forall{n}. n\in\text{Evens IMPLIES }(\exists{p}\exists{q}. p\in\text{Primes AND }q\in\text{Primes AND }n=p+q)]식

                +pos('3.6.5')
                h4.fake Negating Quantifiers
                p De Morgan's Laws for Quantifiers
                ul
                    li 식[NOT(\forall{x}. P(x))]식 == 식[\exists{x}. NOT(P(x))]식
                    li 식[NOT(\exists{x}. P(x))]식 == 식[\forall{x}. NOT(P(x))]식

                +pos('3.6.6')
                h4.fake Validity for Predicate Formulas
                ul
                    li 식[\exists{x}\forall{y}.P(x,y)\text{ IMPLIES }\forall{y}\exists{x}.P(x,y)]식은 항상 참
                    li 식[\forall{x}\exists{y}.P(x,y)\text{ IMPLIES }\exists{x}\forall{y}.P(x,y)]식은 항상 참은 아님

            h3 Problems
            div
                h4.fake 문제 3.3.
                p 수학자가 학생에게 "함수가 연속이 아니면, 미분 불가능하다"라고 말했다. D를 "함수가 미분 가능하다", C를 "함수가 연속이다"라고 했을 때, 수학자의 발언은 "NOT(C) IMPLIES NOT(D)" 또는 "D IMPLIES C"로 변환할 수 있다
                    |<br>그런데 어머니가 자식에게 "숙제를 하지 않으면, TV를 볼 수 없다"라고 말한 경우를 생각해보자. T를 "TV를 볼 수 있다", H를 "숙제를 했다"라고 했을 때, 어머니의 발언은 "NOT(H) IFF NOT(T)" 또는 "H IFF T"로 변환된다
                    |<br>왜 똑같은 IF-THEN 구조 문장을 서로 다르게 변환하는 것이 합당한지 설명하라
                p → 수학자의 발언은 함수의 미분 가능성을 위하여 함수의 연속을 요구하는 것이 아니다. 그러나 어머니의 발언은 TV를 보기 위해 숙제를 할 것을 요구하는 것을 내포하고 있다 -- "숙제를 하면, TV를 볼 수 있다". 즉, 어머니의 발언은 "(NOT(H) IMPLIES NOT(T)) AND (H IMPLIES T) = H IFF T"으로 변환된다.


                h4.fake 문제 3.6.
                p 이진수 덧셈 식[a_{1}a_{0}+b]식를 처리하는 2비트 반가산기는 3개 비트 식[cs_{1}c_{0}]식를 출력한다. 여기서 c는 carry bit라고 부른다 -- 다음 자릿수에 전달되어 연산에 사용되므로. 이를 아래와 같이 표현할 수 있다.
                    |\begin{align*}
                    |   c_0 =& b \\
                    |   s_0 =& a_0\text{ XOR }c_0 \\
                    |   c_1 =& a_0\text{ AND }c_0 && \text{the carry into column 1} \\
                    |   s_1 =& a_1\text{ XOR }c_1 \\
                    |   c_2 =& a_1\text{ AND }c_1 && \text{the carry into column 2} \\
                    |   c   =& c_2
                    |\end{align*}
                p <b>(a)</b> 위 논리식을 n+1비트 반가산기로 일반화하라. 즉, 식[a_{n} \cdots a_{1}a_{0}]식와 b를 입력으로 받아 식[cs_{n} \cdots s_{1}s_{0}]식를 출력한다.
                p → \begin{align*}
                    |   c_0 =& b \\
                    |   s_i =& a_i\text{ XOR }c_i \\
                    |   c_{i+1} =& a_i\text{ AND }c_i \\
                    |   c   =& c_{n+1}
                    |\end{align*}
                p <b>(b)</b> 유사하게, 두 개의 n+1비트 식[a_{n} \cdots a_{1}a_{0}]식, 식[b_{n} \cdots b_{1}b_{0}]식를 입력으로 받는 가산기의 출력에 대한 일반식을 작성하라
                p → \begin{align*}
                    |   c_0 =& 0 \\
                    |   s_i =& a_i\text{ XOR }b_i\text{ XOR }c_i \\
                    |   c_{i+1} =& (a_i\text{ AND }b_i)\text{ OR }(b_i\text{ AND }c_i)\text{ OR }(c_i\text{ AND }a_i) \\
                    |   c   =& c_{n+1}
                    |\end{align*}
                p <b>(c)</b> 위 <b>(b)</b>에서 작성한 계산기는 작동을 위해 몇 번의 논리 연산을 수행하는가?
                p → 2(n+1)번의 XOR 연산, 3(n+1)번의 AND 연산, 2(n+1)번의 OR 연산을 수행한다

                h4.fake 문제 3.7
                ul
                    li 회로의 속도 또는 지연은 입력과 출력 사이의 경로들 중 가장 게이트가 많이 존재하는 경로에 의해 결정된다
                    li 문제 3.6의 ripple-carry 반가산기는 이전 비트의 캐리 비트가 다음 비트의 계산에 필요하므로, 반가산기의 입력을 2배로 늘릴 때마다 소요 시간도 2배로 늘어난다
                    li 만약 가산기의 모든 비트가 동시에 계산된다면, 입력을 2배로 늘려도 소요 시간은 크게 늘지 않는다
                    li 식[a_{3}a_{2}a_{1}a_{0} + b_{3}b_{2}b_{1}b_{0} = cs_{3}s_{2}s_{1}s_{0}]식를 수행하는 자리올림수 예측 가산기(carry-lookahead adder) 구현을 생각해보자
                    ul
                        li 자리올림이 발생하는 경우
                        ul
                            li 두 입력의 동일 자리가 모두 1이면 반드시 자리올림수가 발생한다 : G(A, B) = A AND B
                            li 두 입력 중 하나만 1인 경우, 자리올림수가 발생할 수 있다 : P(A, B) = A XOR B
                        li 한 자리의 계산
                        ul
                            li 문제 3.6 - (b)의 답과 다름 없음
                            li 식[s_{i} = P_{i}\text{ XOR }c_{i} = a_i\text{ XOR }b_i\text{ XOR }c_i]식
                            li 식[c_{i+1} = G_{i}\text{ OR }(P_{i}\text{ AND }c_{i}) = (a_i\text{ AND }b_i)\text{ OR }(b_i\text{ AND }c_i)\text{ OR }(c_i\text{ AND }a_i)]식
                        li 식 전개
                        ul
                            li s0 = P0 XOR 0
                            li c1 = G0
                            li s1 = P1 XOR c1 = P1 XOR G0
                            li c2 = G1 OR (P1 AND c1) = G1 OR (P1 AND G0)
                            li s2 = P2 XOR c2 = P2 XOR (G1 OR (P1 AND G0))
                            li c3 = G2 OR (P2 AND c2) = G2 OR (P2 AND (G1 OR (P1 AND G0)))
                            li s3 = P3 XOR c3 = P3 XOR (G2 OR (P2 AND (G1 OR (P1 AND G0))))
                            li c4 = G3 OR (P3 AND c3) = G3 OR (P3 AND (G2 OR (P2 AND (G1 OR (P1 AND G0)))))
                        li 시간이 적게 소요되는 대신 회로 복잡도가 크게 증가한다 -- O(n^2)

                h4.fake 문제 3.17.
                p A half dozen different operators may appear in propositional formulas, but just AND, OR, and NOT are enough to do the job. That is because each of the operators is equivalent to a simple formula using only these three operators. For example, A IMPLIES B is equivalent to NOT(A) OR B. So all occurences of IMPLIES in a formula can be replaced using just NOT and OR.
                ul
                    li (a) Write formulas using only AND, OR, NOT that are equivalent to each of A IFF B and A XOR B. Conclude that every propositional formula is equivalent to an AND-OR-NOT formula.
                    ul
                        li A iff B = (A and B) or (not(A) and not(B))
                        li A xor B = (A and not(B)) or (not(A) and B)
                    li (b) Explain why you don’t even need AND.
                    p A and B = not(not(A) or not(B))
                    li (c) Explain how to get by with the single operator NAND where A NAND B is equivalent by definition to NOT(A AND B)
                    ul
                        li A and B = (A nand B) nand (A nand B)
                        li not(A) = A nand A
                        li A or B = not(not(A) and not(B)) = X nand X
                            |<br>where X = (Y nand Z) nand (Y nand Z), Y = A nand A, Z = B nand B
                h4.fake 문제 3.18.
                p The propositional connective NOR is defined by the rule
                    |<br>P NOR Q ::= NOT(P) AND NOT(Q)
                    |<br>Explain why every propositional formula—possibly involving any of the usual operators such as IMPLIES, XOR, . . .—is equivalent to one whose only connective is NOR.
                ul
                    li not(A) = A nor A
                    li A or B = not(A nor B) = (A nor b) nor (A nor b)
                    li A and b = not(not(A) or not(B)) = X nor X
                        |<br>where X = (Y nor Z) nor (Y nor Z), Y = A nor A, Z = B nor B
                h4.fake 문제 3.19.
                p Explain how to read off a conjunctive form for a propositional formula directly from a disjunctive form for its complement.
                p → Any DNF 식[P_1\text{ OR }P_2\text{ OR }\cdots\text{ OR }P_n]식, where 식[P_i=Q_{i1}\text{ AND }Q_{i2}\text{ AND }\cdots\text{ AND }Q_{im_i}]식
                    |<br>\begin{align*}
                    | & \text{ NOT}(P_1\text{ OR }P_2\text{ OR }\cdots\text{ OR }P_n) \\
                    |=& \text{ NOT}(P_1)\text{ AND }\text{ NOT}(P_2)\text{ AND }\cdots\text{ AND }\text{ NOT}(P_n) \\
                    |=& (\text{ NOT}(Q_{11})\text{ OR }\text{ NOT}(Q_{12})\text{ OR }\cdots\text{ OR }\text{ NOT}(Q_{1m_1})))\text{ AND } \\
                    | & (\text{ NOT}(Q_{21})\text{ OR }\text{ NOT}(Q_{22})\text{ OR }\cdots\text{ OR }\text{ NOT}(Q_{2m_1})))\text{ AND } \\
                    | & \vdots \\
                    | & (\text{ NOT}(Q_{n1})\text{ OR }\text{ NOT}(Q_{n2})\text{ OR }\cdots\text{ OR }\text{ NOT}(Q_{2n_1})))
                    |\end{align*}
                h4.fake 문제 3.32.
                p The goal of this problem is to translate some assertions about binary strings into logic notation. The domain of discourse is the set of all finite-length binary strings: λ, 0, 1, 00, 01, 10, 11, 000, 001, . . . . (Here λ denotes the empty string.) In your translations, you may use all the ordinary logic symbols (including =), variables, and the binary symbols 0, 1.
                    |<br>A string like 01x0y of binary symbols and variables denotes the concatenation of the symbols and the binary strings represented by the variables. For example, if the value of x is 011 and the value of y is 1111, then the value of 01x0y is the binary string 0101101111.
                ul
                    li (a) x consists of three copies of some string.
                    p → 식[\exists{y}. x=yyy]식
                    li (b) x is an even-length string of 0’s.
                    p → let CONCAT(a, b, c, ...) = abc...
                        |<br>let REPT(a, n) = CONCAT(a, REPT(a, n-1)) = CONCAT(aa, REPT(a, n-2)) = CONCAT(aa...a, REPT(a, 0)) = CONCAT(aa...a, λ) = aa...a
                        |<br>x = REPT(00, n) where n \in N
                    li (c) x does not contain both a 0 and a 1.
                    p → x = λ
                    li (d) x is the binary representation of 식[2^k + 1]식 for some integer 식[k \ge 0]식
                    p → x = 1 or CONCAT(1, REPT(0, n), 1) where 식[n \in \mathbb{N}]식
        h2 Mathematical Data Types
        div
            h3 Sets
            div
                h4.fake Some Popular Sets
                ul
                    li 식[\emptyset]식 : Empty set
                    li 식[\mathbb{N}]식 : Nonnegative integers
                    li 식[\mathbb{Z}]식 : Integers
                    li 식[\mathbb{Q}]식 : Rational numbers
                    li 식[\mathbb{R}]식 : Real numbers
                    li 식[\mathbb{C}]식 : Complex numbers
                h4.fake Comparing and Combining Sets
                ul
                    li 식[S \subseteq T]식 : S is a subset of T
                    li 식[S \subset T]식 : S is a strict subset of T
                    li Union : 식[x \in A \cup B\text{　　iff　　}x \in A\text{ OR }x \in B]식
                    li Intersection : 식[x \in A \cap B\text{　　iff　　}x \in A\text{ AND }x \in B]식
                    li Difference : 식[x \in A - B\text{　　iff　　}x \in A\text{ AND }x \notin B]식
                    li Complement : 식[\overline{A} ::= D - A]식 where D is domain set
                h4.fake Power Set
                p pow(A) ::= The set of all the subsets of a set A
            h3 Sequences
            ul
                li A sequence is a list of objects called terms or components. e.g. (a, b, c)
                li λ ::= empty sequence
                li Cartesian product of sets, 식[S_1\times S_2\times\cdots\times S_n]식, is a new set consisting of all sequences where the first component is drawn from S1, the second from S2, and so forth.
                li 식[S^n = S\times S\times\cdots\times S]식
            h3 Functions
            div
                h4.fake Domains and Images
                ul
                    li 식[f:A\rightarrow B]식 indicates that f is a function with domain, A, and codomain, B
                    li Partial function : function is not defined for some elements in the domain
                    li Total function : function is defined for every element in the domain
                    li range(f) ::= f(domain(f))
                    li image of S under f ::= f(S) where 식[S \subseteq A]식
                h4.fake Function Composition
                +pos('Definition 4.3.1.')
                p <b>Definition 4.3.1.</b> For functions 식[f:A\rightarrow B]식 and 식[g:B\rightarrow C]식, the composition, 식[g\circ f]식 is defined by the rule: 식[\forall{x}\in A, (g\circ f)(x) ::= g(f(x))]식
            h3 Binary Relations
            +pos('Definition 4.4.1.')
            p <b>Definition 4.4.1.</b> A binary relation, R, constists of a set, A, called the domain of R, a set, B, called the codomain of R, and a subset of 식[A\times B]식 called the graph of R
            ul
                li Also said to be "relation between A and B", "relation from A to B"
                li 식[R:A\rightarrow B]식
                li "a R b" means the pair (a, b) is in the graph of R
            div
                h4.fake Relation Diagrams
                +pos('Definition 4.4.2.')
                p <b>Definition 4.4.2.</b> A binary relation, R, is:
                ul
                    li function when it has the [식[\le]식1 arrow out] property
                    li surjective when it has the [식[\ge]식1 arrows in] property
                    li total when it has the [식[\ge]식1 arrows out] property
                    li injective when it has the [식[\le]식1 arrows in] property
                    li bijective when it has both the [=1 arrows in] and the [=1 arrows out] property
                h4.fake Relational Images
                +pos('Definition 4.4.5.')
                p <b>Definition 4.4.5.</b> The inverse, 식[R^{-1}]식 of a relation 식[R:A\rightarrow B]식 is the relation from B to A defined by the rule: 식[b R^{-1} a\text{　　iff　　}a R b]식
                +pos('Definition 4.4.6.')
                p <b>Definition 4.4.6.</b> The image of a set under the relation,  식[R^{-1}]식, is called the inverse image of the set.
            h3 Finite Cardinality
            +pos('Definition 4.5.1.')
            p <b>Definition 4.5.1.</b> If A is a finite set, the cardinality(= size) |A| is the number of elements in A
            +pos('Definition 4.5.2.')
            p <b>Definition 4.5.2.</b> Let A, B be sets. Then
            ul
                li A surj B iff there is a surjective function from A to B
                li A inj B iff there is an injective total relation from A to B
                li A bij B iff there is a bijection from A to B
            +pos('정리 4.5.4.')
            p <b>정리 4.5.4.</b> [Mapping Rules] For finite sets A, B,
            ul
                li A surj B iff |A| >= |B|
                li A inj B iff |A| &lt;= |B|
                li A bij B iff |A| = |B|
        h2 Induction
        |139p
        div
            h3 Ordinary Induction
            h3 b Induction
            h3 b Inductions vs. Induction vs. Well Ordering
        h2 State Machines
        div
            h3 States and Transitions
            h3 The Invariant Principle
            h3 Partial Correctness &amp; Termination
            h3 The Stable Marriage Problem
        h2 Recursive Data Types
        div
            h3 Recursive Definitions and Structural Induction
            h3 Strings of Matched Brackets
            h3 Recursive Functions on Nonnegative Integers
            h3 Arithmetic Expressions
            h3 Games as a Recursive Data Type
            h3 Induction in Computer Science
        h2 Infinite Sets
        div
            h3 Infinite Cardinality
            h3 The Halting Problem
            h3 The Logic of Sets
            h3 Does All This Really Work?

    p.fake-h1 II. Structures
    hr
    div
        p.fake-h2 Introduction
        h2 Number Theory
        div
            h3 Divisibility
            h3 The Greatest Common Divisor
            h3 Prime Mysteries
            h3 The Fundamental Theorem of Arithmetic
            h3 Alan Turing
            h3 Modular Arithmetic
            h3 Remainder Arithmetic
            h3 Turing's Code (Version 2.0)
            h3 Multiplicative Inverses and Cancelling
            h3 Euler's Theorem
            h3 RSA Public Key Encryption
            h3 What has SAT got to do with it?
            h3 Problems
        h2 Directed graphs &amp; Partial Orders
        div
            h3 Vertex Degrees
            h3 Walks and Paths
            h3 Adjacency Matrices
            h3 Walk Relations
            h3 Directed Acyclic Graphs &amp; Scheduling
            h3 Partial Orders
            h3 Representing Partial Orders by Set Containment
            h3 Linear Orders
            h3 Product Orders
            h3 Equivalence Relations
            h3 Summary of Relational Properties
            h3 Problems
        h2 Communication Networks
        div
            h3 Routing
            h3 Routing Measures
            h3 Network Designs
        h2 Simple Graphs
        div
            h3 Vertex Adjacency and Degrees
            h3 Sexual Demographics in America
            h3 Some Common Graphs
            h3 Isomorphism
            h3 Bipartite Graphs &amp; Matchings
            h3 Coloring
            h3 Walks in Simple Graphs
            h3 Connectivity
            h3 Special Walks and Tours
            h3 k-connected Graphs
            h3 Forests &amp; Trees
            h3 Problems
        h2 Planar Graphs
        div
            h3 Drawing Graphs in the Plane
            h3 Definitions of Planar Graphs
            h3 Euler's Formula
            h3 Bounding the Number of Edges in a Plannar Graph
            h3 Returning to 식[K_5]식 and 식[K_{3,3}]식
            h3 Coloring Planar Graphs
            h3 Classifying Polyhedra
            h3 Another Characterization for Planar Graphs

    p.fake-h1 III. Counting
    hr
    div
        p.fake-h2 Introduction
        h2 Sums and Asymptotics
        div
            h3 The Value of an Annuity
            h3 Sums of Powers
            h3 Approximating Sums
            h3 Hanging Out Over the Edge
            h3 Products
            h3 Double Trouble
            h3 Asymptotic Notation
        h2 Cardinality Rules
        div
            h3 Counting One Thing by Counting Another
            h3 Counting Sequences
            h3 The Generalized Product Rule
            h3 The Division Rule
            h3 Counting Subsets
            h3 Sequences with Repetitions
            h3 Counting Practice: Poker Hands
            h3 The Pigeonhole Principle
            h3 Inclusion-Exclusion
            h3 Combinatorial Proofs
            h3 Problems
        h2 Generating Functions
        div
            h3 Infinite Series
            h3 Counting with Generating Functions
            h3 Partial Fractions
            h3 Solving Linear Recurrences
            h3 Formal Power Series
            h3 Problems

    p.fake-h1 IV. Probability
    hr
    div
        p.fake-h2 Introduction
        h2 Events and Probability Spaces
        div
            h3 Let's Make a Deal
            h3 The Four Step Method
            h3 Strange Dice
            h3 The Birthday Principle
            h3 Set Theory and Probability
            h3 Problems
        h2 Conditional Probability
        div
            h3 Month Hall Confusion
            h3 Definition and Notation
            h3 The Four-Step Method for Conditional Probability
            h3 Why Tree Diagrams Work
            h3 The Law of Total Probability
            h3 Simpson's Paradox
            h3 Independence
            h3 Mutual Independence
            h3 Probability versus Confidence
        h2 Random Variables
        div
            h3 Random Variable Examples
            h3 Independence
            h3 Distribution Functions
            h3 Great Expectations
            h3 Linearity of Expectation
        h2 Deviation from the Mean
        div
            h3 Markov's Theorem
            h3 Chebyshev's Theorem
            h3 Properties of Variance
            h3 Estimation by Random Sampling
            h3 Confidence in an Estimation
            h3 Sums of Random Variables
            h3 Really Great Expectations
        h2 Random Walks
        div
            h3 Gambler's Ruin
            h3 Random Walks on Graphs

    p.fake-h1 V. Recurrences
    hr
    div
        p.fake-h2 Introduction
        h2 Recurrences
        div
            h3 The Towers of Hanoi
            h3 Merge Sort
            h3 Linear Recurrences
            h3 Divide-and-Conquer Recurrences
            h3 A Feel for Recurrences
