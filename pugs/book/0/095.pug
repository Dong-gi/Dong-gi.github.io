include ../../../source/skeleton.pug

+post({
    title: '클린 아키텍처',
    description: '『클린 아키텍처』 독서 기록',
})

    h1 도서 정보
    .w3-row
        .w3-col.s2.w3-center
            +w3img('https://image.yes24.com/goods/77283734/L', '도서 이미지')&attributes({style: 'max-height:210px'})
        .w3-col.s10
            +table()
                +tds('표제/저자사항', '클린 아키텍처 / 로버트 C. 마틴')
                +tds('ISBN 정보', '978-89-6626-247-2 (14000)')
                +tds('발행사항', '인사이트, 2019.08.20')

    h1 설계와 아키텍처란?
    ul
        li 흔히 아키텍처는 고수준, 설계는 저수준의 구조를 의미하지만 이러한 구분은 무의미하다
        p 둘 사이의 경계는 뚜렷하지 않고, 고수준에서 저수준으로 향하는 의사결정의 연속만 존재한다
        
        li 아키텍처의 목표는 시스템을 만들고 유지보수하는 데 투입되는 인력을 최소화하는 것

    h1 패러다임 개요
    ul
        li 구조적 프로그래밍 : 제어흐름의 직접적인 전환에 규칙 부과 -- 점프 구문 삭제
        li 객체 지향 프로그래밍 : 제어흐름의 간접적인 전환에 규칙 부과 -- 함수 포인터 삭제
        p 다형성을 언어 차원에서 지원함으로써, #[+asInlineCode('"고수준 함수1" -> "중간 수준 함수1"')]의 의존성이 아래와 같이 바뀔 수 있다(의존성 역전; Dependency Inversion)
        p #[+asInlineCode('"고수준 함수1" -> "인터페이스1" <- "중간 수준 함수1"')]
        p 즉, "고수준 함수1"과 "중간 수준 함수1"은 서로 독립적인 컴포넌트가 되므로, 독립적으로 개발/배포가 가능하다
        li 함수형 프로그래밍 : 할당문에 규칙 부과 -- 변수 변경 제거
        p 불변성이 왜 중요한가? 경합, 교착상태, 동시성 문제가 가변 변수로 인해 발생하기 때문!
        p 이벤트 소싱을 이용하면 가변 변수를 줄일 수 있다 -- 최신 상태를 유지하려고 하는 대신, 트랜잭션을 순서대로 저장한다.<br>
            |=> 상태가 필요해지면, 상태의 시작점으로부터 모든 트랜잭션을 처리한다. 물론 지름길을 택할 수도 있다. 예를 들어 매일 자정에 상태를 계산한 후 저장한다. 그 후 상태가 필요해지면 자정 이후의 트랜잭션만 처리하면 된다<br>
            |=> 결과적으로 애플리케이션은 CRUD가 아니라 CR만 수행한다

    h1 SOLID 설계 원칙
    div
        h2 Single Responsibility Principle; 단일 책임 원칙
        p 각 모듈은 변경되어야 할 이유가 단 하나여야 한다<br>
            |=> 각 모듈은 하나의 액터(사용자 또는 이해관계자)에 대해서만 책임을 져야 한다<br>
            |=> 그렇지 않다면 모듈을 분리해야 한다

        p 예: 우발적 중복
        p 회계팀에서 사용하는 calculatePay() 메서드와 인사팀에서 사용하는 reportHours() 메서드가 정규 근로 시간을 계산하는 함수 regularHours()를 공유할 때, 인사팀에서 정규 근로 시간 정의를 변경하면 이는 회계팀에도 영향을 미쳐 잘못된 급여가 지불될 가능성이 있다

        h2 Open-Closed Principle; 개방-폐쇄 원칙
        p 기존 코드를 수정하기보다, 새로운 코드를 추가하는 방식으로 행위를 변경하도록 설계해야 한다<br>
            |=> 이를 위해 시스템은 컴포넌트 단위로 분리하고, 저수준 컴포넌트의 변경으로부터 고수준 컴포넌트를 보호할 수 있도록 계층구조가 만들어져야 한다

        h2 Liskov Substitution Principle; 리스코프 치환 원칙
        p 상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들 수 있으려면, 이들 구성요소는 반드시 서로 치환 가능해야 한다<br>
            |=> 이들 구성요소는 클래스, 인터페이스에 국한되지 않는다. 예를 들어, 특정 REST API 군을 처리하는 서버도 치환 가능한 시스템의 구성요소가 될 수 있다
        p 예. 높이와 너비를 각각 변경할 수 있는 직사각형은, 정사각형의 부모가 될 수 없다

        h2 Interface Segregation Principle; 인터페이스 분리 원칙
        p 사용하지 않는 것에 의존하지 않아야 한다 -- 사용하는 것만 인터페이스로 분리하여 넘겨야 한다

        h2 Dependency Inversion Principle; 의존성 역전 원칙
        p 고수준 정책을 구현하는 코드는 (자주 변경되는) 저수준 세부사항을 구현하는 코드에 의존해서는 안 된다. 세부사항이 정책에 의존해야 한다


    h1 아키텍처의 목적
    p 좋은 아키텍처는 유스케이스를 그 중심에 두기 때문에, 프레임워크나 도구, 환경에 전혀 구애받지 않고 구조를 기술할 수 있다
