
                    <tr class="con-lv-3" con-title="Executor">
                        <th>interface Executor Since 1.5</th>
                    </tr>
                    <tr>
                        <td>
                            1. 전달받은 Runnable task를 실행하는 객체. Executor 자체가 쓰레드의 병행성을 부여하진 않는다. Executor의 구현에서 호출자와 다른 쓰레드 공간을 마련해주어야 한다.
                            <br>
                            <br>2. void execute(Runnable command)
                            <button type="button" onclick="javascript:showCode('JavaUtilConcurrent/src/ExecutorExample.java', 'java');" class="btn btn-primary btn-sm">
                                View Code : 예제 »
                            </button>
                            <button type="button" onclick='javascript:showCode("JavaUtilConcurrent/console/con1.txt", "text");' class="btn btn-primary btn-sm">
                                View Console : 콘솔 »
                            </button>
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="ExecutorService">
                        <th>interface ExecutorService extends Executor Since 1.5</th>
                    </tr>
                    <tr>
                        <td>
                            1. java.util.concurrent 패키지의 기본적인 Executor 구현.
                            <br>
                            <br>2. void shutdown()
                            <br>» 추가적인 Runnable을 받지 않는다. 이전에 추가된 것은 마저 실행한다.
                            <br>List&lt;&Runnable&gt; shutdownNow()
                            <br>» 진행중인 모든 작업을 중지. 실행 대기중인 일들은 반환.
                            <br>boolean isShutdown()
                            <br>boolean isTerminated() : 모든 일들이 끝났는지 여부
                            <br>boolean awaitTermination(long timeout, TimeUnit unit)
                            <br>» shutdown 요청 후 모든 작업이 종료되기를 기다리며 블록한다. timeout 발생한 경우 false 반환.
                            <br>&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)
                            <br>» 결과를 반환하는 작업을 등록한다. 작업이 성공적으로 종료되면 Future::get으로 결과를 확인할 수 있다.
                            <br>&lt;T&gt; Future&lt;T&gt; submit(Runnable atask, T result)
                            <br>» 작업을 등록한다. 작업이 성공적으로 종료되면 Future::get으로 result를 얻을 수 있다.
                            <br>Futur&lt;?&gt; submit(Runnable task)
                            <br>» 작업을 등록한다. 작업이 성공적으로 종료되면 Future::get은 null을 반환한다.
                            <br>&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt;
                            tasks)
                            <br>» 모든 작업이 종료되면 Future 리스트를 반환한다. 따라서 리스트 안의 각 Future::isDone은 true다.
                            <br>&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt;
                            tasks, long timout, TimeUnit unit)
                            <br>» 모든 작업이 종료되거나 timeout이 발생하면 반환. 리스트 안의 각 Future::isDone은 true. timeout 발생 시 완료되지 않은 작업들은
                            취소된다.
                            <br>&lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)
                            <br>» 성공적으로 완료된 첫 작업의 결과를 반환한다. 완료되지 않은 작업들은 취소된다.
                            <br>&lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;&gt;&gt; tasks, long timeout, TimeUnit
                            unit)
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="ScheduledExecutorService">
                        <th>interface ScheduledExecutorService extends ExecutorService Since 1.5</th>
                    </tr>
                    <tr>
                        <td>
                            1. 실행 전에 딜레이를 두거나, 주기적으로 실행을 반복할 수 있는 ExecutorService
                            <br>
                            <br>2. ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit)
                            <br>&lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable, long delay, TimeUnit
                            unit)
                            <br>ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period,
                            TimeUnit unit)
                            <br>» 반복되는 작업은 반환된 Future를 통해 취소할 수 있다.
                            <br>ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay,
                            TimeUnit unit)
                            <br>» scheduleAtFixedRate와 달리, 이전 작업이 완료된 후 다음 작업이 시작된다.
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="TimeUnit">
                        <th>enum TimeUnit Since 1.5</th>
                    </tr>
                    <tr>
                        <td>
                            1. 필드
                            <br>» NANOSECONDS, MICROSECONDS, MILLISECONDS, SECONDS, MINUTES Since 1.6, HOURS Since 1.6,
                            DAYS Since 1.6
                            <br>
                            <br>2. long convert(long sourceDuration, TimeUnit sourceUnit)
                            <br>long toNanos(long duration) : == NANOSECONDS.convert(duration, this)
                            <br>long toMicros(long duration) + toMillis, toSeconds, toMinutes, toHours, toDays
                            <br>void timeWait(Object obj, long timeout)
                            <br>» timeout만큼 obj.wait()
                            <br>void timedJoin(Thread thread, long timeout)
                            <br>» timeout만큼 Thread.join()
                            <br>void sleep(long timeout)
                            <br>ChronoUnit toChronoUnit() Since 9
                            <br>static TimeUnit of(ChronoUnit chronoUnit) Since 9
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="ThreadFactory">
                        <th>interface ThreadFactory Since 1.5</th>
                    </tr>
                    <tr>
                        <td>
                            Thread newThread(Runnable r)
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="Callable">
                        <th>@FunctionalInterface interface Callable&lt;V&gt; Since 1.5</th>
                    </tr>
                    <tr>
                        <td>
                            1. 매개변수 없는, 결과를 반환하는 작업을 정의. Runnable과 달리 checked 예외를 던져도 된다.
                            <br>
                            <br>2. V call()
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="Executors">
                        <th>class Executors Since 1.5</th>
                    </tr>
                    <tr>
                        <td>
                            1. Executor, ExecutorService, ScheduledExecutorService, ThreadFactory, Callable에 관한 팩터리 및 유틸리티.
                            <br>
                            <br>2. ExecutorService
                            <br>static ExecutorService newFixedThreadPool(int nThreads)
                            <br>» 최대 동시 실행 가능한 쓰레드 수가 제한. 나머지 쓰레드는 큐에서 대기. 쓰레드들은 명시적으로 shutdown되기 전까지 풀에 존재한다.
                            <br>static ExecutorService newWorkStealingPool(int parallelism) Since 1.8
                            <br>» parallelism : 병행 레벨 - 동시 실행 가능한 최대 쓰레드 수.
                            <br>» 풀 내부의 쓰레드 수는 가변적이다. 여러 큐를 이용할 수 있기 때문에, 쓰레드 실행 순서를 예측할 수 없다.
                            <br>static ExecutorService newWorkStealingPool() Since 1.8
                            <br>» 사용 가능한 프로세서 수를 parallelism level로 이용.
                            <br>static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory)
                            <br>» 새 쓰레드를 생성하는 데 threadFactory를 이용.
                            <br>static ExecutorService newSingleThreadExecutor()
                            <br>» 하나의 워커 쓰레드만 사용한다. 예기지 않게 워커가 종료되면 새로운 쓰레드가 나머지 작업을 위해 그 자리를 대신할 수 있다.
                            <br>» 같은 특징을 갖는 newFixedThreadPool(1)과 다르게, 반환된 Executor로 추가적인 워커 쓰레드를 이용하도록 설정할 수 없다.
                            <br>static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory)
                            <br>static ExecutorService newCachedThreadPool()
                            <br>» 이전에 종료된 쓰레드를 재사용. 60초 동안 이용되지 않으면 풀에서 삭제된다.
                            <br>static ExecutorService newCachedThreadPool(ThreadFactory threadFactory)
                            <br>static ExecutorService unconfigurableExecutorService(ExecutorService executor)
                            <br>» ExecutorService에 정의된 메서드들은 executor에 연결하고, 그 외 캐스트를 통해 이용할 수 있는 메서드들은 호출하지 못하도록 한다.
                            <br>
                            <br>3. ScheduledExecutorService
                            <br>static ScheduledExecutorService newSingleThreadScheduledExecutor() : 특징은 ExecutorService와 같다.
                            <br>static ScheduledExecutorService newSingleThreadScheduledExecutor(ThreadFactory threadFactory)
                            <br>static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)
                            <br>» corePoolSize : 풀에 유지할 쓰레드 수
                            <br>static ScheduledExecutorService newScheduledThreadPool(int corePoolSize, ThreadFactory threadFactory)
                            <br>static ScheduledExecutorService unconfigurableScheduledExecutorService(ScheduledExecutorService
                            executor)
                            <br>» ScheduledExecutorService에 정의된 메서드들은 executor에 연결하고, 그 외 캐스트를 통해 이용할 수 있는 메서드들은 호출하지 못하도록
                            한다.
                            <br>
                            <br>4. ThreadFactory
                            <br>static ThreadFactory defaultThreadFactory()
                            <br>» 모든 쓰레드들을 같은 ThreadGroup으로 생성한다. 쓰레드의 우선순위는 Threa.NORM_PRIORITY와 그룹의 최대 허용치 중 작은 것으로 설정된다.
                            <br>» 각 쓰레드들은 non-daemon으로 생성되며, Thread.getName()을 통해 얻을 수 있는 "pool-N-thread-M" 꼴의 이름으로 접근할
                            수 있다.
                            <br>static ThreadFactory privilegedThreadFactory()
                            <br>» 호출하는 쓰레드와 같은 권한으로 새로운 쓰레드를 생성하는 ThreadFactory 반환.
                            <br>
                            <br>5. Callable
                            <br>static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result)
                            <br>static Callable&lt;Object&gt; callable(Runnable task)
                            <br>» 작업이 완료되면 null을 반환하는 Callable 반환
                            <br>static Callable&lt;Object&gt; callable(PrivilegedAction&lt;?&gt; action)
                            <br>» 호출되면 action::run을 실행하고 그 결과를 반환하는 Callable 반환
                            <br>static Callable&lt;Object&gt; callable(PrivilegedExceptionAction&lt;?&gt; action)
                            <br>static &lt;T&gt; Callable&lt;T&gt; privilegedCallable(Callable&lt;T&gt; callable)
                            <br>» 호출되면 callable을 현재 access control context에서 실행. AccessController.doPrivileged에서 호출되어야
                            한다.
                            <br>static &lt;T&gt; Callable&lt;T&gt; privilegedCallableUsingCurrentClassLoader(Callable&lt;T&gt;
                            callable)
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="Future">
                        <th>interface Future&lt;V&gt; Since 1.5</th>
                    </tr>
                    <tr>
                        <td>
                            1. 비동기적 계산의 결과를 표현. 결과는 오직 get 메서드로만 얻을 수 있으며, 필요하다면 결과가 준비될 때까지 블록시킨다.
                            <br>
                            <br>2. boolean cancel(boolean mayInterruptIfRunning)
                            <br>&gt; 이 메서드가 종료된 후의 isDone()은 항상 true.
                            <br>boolean isCancelled()
                            <br>boolean isDone()
                            <br>V get()
                            <br>V get(long timeout, TimeUnit unit)
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="RunnableFuture">
                        <th>interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; Since 1.6</th>
                    </tr>
                    <tr>
                        <td>
                            1.Runnable한 Future.
                            <br>
                            <br>2. void run() : Future로 하여금 결과를 설정하도록 한다.
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="FutureTask">
                        <th>class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; Since 1.5</th>
                    </tr>
                    <tr>
                        <td>
                            1. 생성자
                            <br>public FutureTask(Callable&lt;V&gt; callable)
                            <br>public FutureTask(Runnable runnable, V result)
                            <br>
                            <br>2. protected void done() : 완료 상태가 될때 호출된다
                            <br>protected void set(V v) : 결과 설정
                            <br>protected void setException(Throwable t) : t를 ExecutionException 원인으로 설정
                            <br>protected boolean runAndReset() : 반복 실행 목적
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="Delayed">
                        <th>interface Delayed extends Comparable&lt;Delayed&gt; Since 1.5</th>
                    </tr>
                    <tr>
                        <td>
                            1. 객체가 일정 지연 뒤 작동함을 마킹하는 인터페이스. 이를 구체화할 땐 compareTo를 반드시 구현해야 한다.
                            <br>
                            <br>2. long getDelay(TimeUnit unit)
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="ScheduledFuture">
                        <th>interface ScheduledFuture&lt;V&gt; extends Delayed, Future&lt;V&gt; Since 1.5</th>
                    </tr>
                    <tr>
                        <td>
                            1. ScheduledExecutor의 스케쥴링 결과.
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="RunnableScheduledFuture">
                        <th>interface RunnableScheduledFuture&lt;V&gt; extends RunnableFuture&lt;V&gt;, ScheduledFuture&lt;V&gt;
                            Since 1.6</th>
                    </tr>
                    <tr>
                        <td>
                            1. Runnable한 ScheduledFuture.
                            <br>
                            <br>2. boolean isPeriodic()
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="CompletionStage">
                        <th>interface CompletionStage&lt;T&gt; Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            1. 비동기적일 수 있는 계산 단계. 다른 CompletionStage가 완료된 뒤 어떠한 동작을 수행하거나 값을 계산한다.
                            <br>» Stage에서 수행되는 연산은 Function, Consumer, Runnable로 표현되어야 한다. 각각은 apply, accept, run 메서드로
                            stage에 제공된다. 연산에 넘겨지는 인자는 트리거 stage의 결과이며, 이를 통해 연산의 pipeline을 만들 수 있다.
                            <br>
                            <br>2. &lt;U&gt; CompletionStage&lt;U&gt; thenApply(Function&lt;? super T, ? extends U&gt; fn) +
                            thenApplyAsync
                            <br>» Optional::map, Stream::map과 유사하다.
                            <br>CompletionStage&lt;Void&gt; thenAccept(Consumer&lt;? super T&gt; action) + thenAcceptAsync
                            <br>CompletionStage&lt;Void&gt; thenRun(Runnable action) + thenRunAsync
                            <br>
                            <br>&lt;U, V&gt; CompletionStage&lt;V&gt; thenCombine(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;?
                            super T, ? super U, ? extends V&gt; fn) : other와 이 stage 모두가 종료되면 fn을 실행하는 CompletionStage를 반환.
                            + thenCombineAsync
                            <br>&lt;U&gt; CompletionStage&lt;Void&gt; thenAcceptBoth(CompletionStage&lt;? extends U&gt; other,
                            BiConsumer&lt;? super T, ? super U&gt; action) + thenAcceptBothAsync
                            <br>CompletionStage&lt;Void&gt; runAfterBoth(CompletionStage&lt;?&gt; other, Runnable action) + runAfterBothAsync
                            <br>
                            <br>&lt;U&gt; CompletionStage&lt;U&gt; applyToEither(CompletionStage&lt;? extends T&gt; other, Function&lt;?
                            super T, U&gt; fn) : other나 이 stage 둘 중 하나라도 종료되면 fn을 실행하는 CompletionStage를 반환. + applyToEitherAsync
                            <br>CompletionStage&lt;Void&gt; acceptEither(CompletionStage&lt;? extends T&gt; other, Consumer&lt;?
                            super T&gt; action) + acceptEitherAsync
                            <br>CompletionStage&lt;Void&gt; runAfterEither(CompletionStage&lt;?&gt; other, Runnable action) +
                            runAfterEitherAsync
                            <br>
                            <br>&lt;U&gt; CompletionStage&lt;U&gt; thenCompose(Function&lt;? super T, ? extends CompletionStage&lt;U&gt;&gt;
                            fn) + thenComposeAsync
                            <br>» 이 stage가 종료되면 결과를 인자로 하여 fn이 호출되고, 다른 CompletionStage가 반환된다. 반환된 stage가 종료되면, 이 메서드가
                            반환한 CompletionStage가 같은 값으로 종료된다. Optional::flatMap, Stream::flatMap과 비슷하다.
                            <br>&lt;U&gt; CompletionStage&lt;U&gt; handle(BiFunction&lt;? super T, Throwable, ? extends U&gt;
                            fn) + handleAsync
                            <br>» 이 stage가 종료되면 결과와 예외를 인자로 fn을 실행하고, fn의 결과로 반환된 stage를 종료한다.
                            <br>CompletionStage&lt;T&gt; whenComplete(BiConsumer&lt;? super T, ? super Throwable&gt; action)
                            + whenCompleteAsync
                            <br>» 이 stage가 종료되면 결과와 예외를 인자로 action을 실행하고, action이 종료되면 반환된 stage도 종료된다.
                            <br>
                            <br>CompletionStage&lt;T&gt; exceptionally(Function&lt;Throwable, ? extends T&gt; fn)
                            <br>» 이 stage가 예외를 발생하면 그것을 인자로 fn 실행하는 CompletionStage 반환. 예외 발생이 없는 경우, 이 stage의 결과와 같은 값으로
                            반환된 stage가 종료된다.
                            <br>
                            <br>CompletableFuture&lt;T&gt; toCompletableFuture()
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="CompletableFuture">
                        <th>class CompletableFuture&lt;T&gt; impliments Future&lt;T&gt;, CompletionStage&lt;T&gt; Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            1. CompletionStage로 이용될 수 있는, 명시적으로 종료(값과 상태를 설정)되는 Future. 둘 이상의 쓰레드가 complete, completeExceptionally, cancel을 호출할 경우, 하나만
                            성공한다.
                            <br>» non-async 메서드로 등록된 작업은 현재 CompletableFuture가 완료된 쓰레드 또는 호출자에서 실행된다.
                            <br>» 명시적인 Executor 없이 async 메서드로 등록된 작업은 ForkJoinPool::commonPool에서 수행.
                            <br>» CompletionStage의 메서드들은 독립적으로 구현되어, 하나를 재정의해도 다른 메서드에 영향이 없다.
                            <br>» CompletionStage의 메서드들만 이용하도록 하려면 minimalCompletionStage()를, future를 변경하지 못하도록 하려면 copy()를
                            이용.
                            <br>
                            <br>
                            <b>2. static interface CompletableFuture.AsynchronousCompletionTask Since 1.8</b>
                            <br>» 비동기 메서드에서 생성된 비동기 작업을 나타내는 마커 인터페이스
                            <br>
                            <br>3. 생성자 : public CompletableFuture()
                            <br>
                            <br>4. 팩터리
                            <br>static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier) + 1 오버로드
                            <br>» supplier의 결과를 가지고 ForkJoinPool::commonPool에서 실행되는 작업에 의해 비동기 종료되는 새로운 CompletableFuture
                            객체 반환.
                            <br>static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable) + 1 오버로드
                            <br>» 주어진 동작을 수행한 뒤 ForkJoinPool::commonPool에서 실행되는 작업에 의해 비동기 종료되는 새로운 CompletableFuture 객체
                            반환
                            <br>static &lt;U&gt; CompletableFuture&lt;U&gt; completedFuture(U value)
                            <br>» 이미 특정 값으로 종료된 CompletableFuture 객체 반환.
                            <br>static CompletableFuture&lt;Void&gt; allOf(CompletableFuture&lt;?&gt;... cfs)
                            <br>» 모든 cfs가 종료되면 완료되는 새로운 CompletableFuture 객체 반환.
                            <br>static CompletableFuture&lt;Object&gt; anyOf(CompletableFuture&lt;?&gt;... cfs)
                            <br>» 하나라도 종료되면, 그 결과와 같은 값으로 종료되는 CompletableFuture 객체 반환.
                            <br>
                            <br>5. T join() : 종료되면 결과 값 반환, 또는 발생한 예외 던지기. 예외의 형태는 CompletionException으로 하고 기저 예외를 cause로 설정한
                            것이 좋다.
                            <br>T getNow(T valueIfAbsent) : 종료되었다면 결과 값 반환, 또는 발생한 예외 던지기. 아니면 valueIfAbsent 반환.
                            <br>boolean complete(T value) : 종료되지 않았다면 get()과 연관 메서드들의 반환값을 value로 설정. 이 호출로 CompletableFuture가
                            완료 상태로 이행되었다면 true 반환.
                            <br>boolean completeExceptionally(Throwable ex) : 종료되지 않았다면 get()과 연관 메서드들이 주어진 예외를 던지도록 한다. 이 호출로
                            CompletableFuture가 완료 상태로 이행되었다면 true 반환.
                            <br>boolean isCompletedExeptionally()
                            <br>void obtrudeValue(T value) : 강제로 get()과 연관 메서드들의 반환값 설정. 에러 복구를 위해 설계됨.
                            <br>void obtrudeException(Throwable ex)
                            <br>int getNumberOfDependents() : 종료 대기중인 CompletableFuture의 개수 추정. 동기화가 아닌 시스템 모니터링을 위해 설계됨.
                            <br>
                            <br>6. Since 9
                            <br>&lt;U&gt; CompletableFuture&lt;U&gt; newIncompletableFuture()
                            <br>» 완료되지 않은 새로운 CompletableFuture 객체를 반환한다. 타입 U는 CompletionStage 메서드로부터 얻어진다. 서브클래스들은 이를
                            재정의하여 CompletableFuture 객체를 반환해야 한다.
                            <br>Executor defaultExecutor()
                            <br>CompletableFuture&lt;T&gt; copy() : 정상적으로 종료되었다면, 같은 값을 갖는 종료된 CompletableFuture 반환. 예외 종료되었다면,
                            해당 예외를 원인으로 한 CompletionException으로 예외 종료된 CompletableFuture 반환. 동작은 thenApply(x -> x)와 같다.
                            <br>CompletionStage&lt;T&gt; minimalCompletionStage() : CompletionStage에 정의된 메서드만 이용 가능. 재정의되지 않았다면
                            toCompletableFuture() 메서드를 통해 그 외의 메서드에 접근 가능하다.
                            <br>CompletableFuture&lt;T&gt; completeAsync(Supplier&lt;? extends T&gt; supplier) + 1 오버로딩
                            <br>» 이 CompletableFuture를 supplier의 결과값으로 종료한다.
                            <br>CompletableFuture&lt;T&gt; orTimeout(long timeout, TimeUnit unit)
                            <br>» 이 CompletableFuture가 주어진 시간 내에 종료되지 않은 경우, TimeoutException으로 예외 종료한다.
                            <br>CompletableFuture&lt;T&gt; completeOnTimeout(T value, long timeout, TimeUnit unit)
                            <br>» 이 CompletableFuture가 주어진 시간 내에 종료되지 않은 경우, value로 종료한다.
                            <br>static Executor delayedExecutor(long delay, TimeUnit unit) + 1 오버로딩
                            <br>» 주어진 딜레이 이후에 executor로 작업을 제출하는 새로운 Executor 반환.
                            <br>static &lt;U&gt; CompletionStage&lt;U&gt; completedStage(U value)
                            <br>» 주어진 value로 이미 종료된 새로운 CompletionStage 반환.
                            <br>static &lt;U&gt; CompletableFuture&lt;U&gt; failedFuture(Throwable ex)
                            <br>» 주어진 예외로 이미 종료된 새로운 CompletableFuture 객체 반환.
                            <br>static &lt;U&gt; CompletionStage&lt;U&gt; failedStage(Throwable ex)
                            <br>» 주어진 예외로 이미 종료된 새로운 CompletionStage 반환.
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="AbstractExecutorService">
                        <th>abstract clas AbstractExecutorService implements ExecutorService Since 1.5</th>
                    </tr>
                    <tr>
                        <td>
                            1. submit, invokeAny, invokeAll 메서드 구현. 반환하는 RunnableFuture에는 FutureTask 이용.
                            <br>
                            <br>2. protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) Since 1.6
                            <br>protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) Since 1.6
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="ThreadPoolExecutor">
                        <th>class ThreadPoolExecutor extends AbstractExecutorService Since 1.5</th>
                    </tr>
                    <tr>
                        <td>
                            1. https://docs.oracle.com/javase/10/docs/api/java/util/concurrent/ThreadPoolExecutor.html
                            <br>
                            <br>2. 생성자
                            <br>public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit
                            unit, BlockingQueue&lt;Runnable&gt; workQueue)
                            <br>public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit
                            unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory)
                            <br>public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit
                            unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler)
                            <br>public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit
                            unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler
                            handler)
                            <br>
                            <br>3. void execute(Runnable command)
                            <br>void shutdown()
                            <br>List&lt;Runnable&gt; shutdownNow()
                            <br>boolean isTerminating()
                            <br>void setThreadFactory(ThreadFactory threadFactory) + getter
                            <br>void setRejectedExecutionHandler(RejectedExecutionHandler handler) + getter
                            <br>void setCorePoolSize(int corePoolSize) + getter
                            <br>boolean prestartCoreThread()
                            <br>» 코어(워커) 쓰레드를 시작시켜 작업을 대기시킨다. 새 작업을 시작할 때 코어 쓰레드를 실행하는 기본 설정을 재정의한 것. 모든 코어 쓰레드가 이미 시작되었다면
                            false 반환.
                            <br>int prestartAllCoreThreads()
                            <br>boolean allowsCoreThreadTimeOut() Since 1.6
                            <br>void allowCoreThreadTimeOut(boolean value) Since 1.6
                            <br>void setMaximumPoolSize(int maximumPoolSize) + getter
                            <br>void setKeepAliveTime(long time, TimeUnit unit) + getter
                            <br>BlockingQueue&lt;Runnable&gt; getQueue()
                            <br>boolean remove(Runnable task)
                            <br>void purge() : 취소된 Future 작업들을 큐에서 제거
                            <br>int getPoolSize()
                            <br>int getActiveCount()
                            <br>int getLargestPoolSize()
                            <br>long getTaskCount()
                            <br>long getCompletedTaskCount()
                            <br>
                            <br>4. 사용자 정의
                            <br>protected void beforeExecute(Thread t, Runnable r)
                            <br>protected void afterExecute(Runnable r, Throwable t)
                            <br>protected void terminated() : Executor가 종료되면 호출
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="RejectedExecutionHandler">
                        <th>interface RejectedExecutionHandler Since 1.5</th>
                    </tr>
                    <tr>
                        <td>
                            1. ThreadPoolExecutor에서, 실행되지 않은 작업에 대한 처리를 위해 사용.
                            <br>
                            <br>2. void rejectedExecution(Runnable r, ThreadPoolExecutor executor)
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="ScheduledThreadPoolExecutor">
                        <th>class ScheduledThreadPoolExecutor extends ThreadPoolExecutor implements ScheduledExecutorService
                            Since 1.5</th>
                    </tr>
                    <tr>
                        <td>
                            1. 생성자
                            <br>public ScheduledThreadPoolExecutor(int corePoolSize)
                            <br>public ScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory)
                            <br>public ScheduledThreadPoolExecutor(int corePoolSize, RejectedExecutionHandler handler)
                            <br>public ScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory, RejectedExecutionHandler
                            handler)
                            <br>
                            <br>2. void setContinueExistingPeriodicTasksAfterShutdownPolicy(boolean value) + getter
                            <br>void setExecuteExistingDelayedTasksAfterShutdownPolicy(boolean value) + getter
                            <br>void setRemoveOnCancelPolicy(boolean value) Since 1.7 + getter
                            <br>» 취소된 작업을 즉시 큐에서 제거할 것인지 설정. 기본값은 false.
                            <br>
                            <br>3. 사용자 정의
                            <br>protected &lt;V&gt; RunnableScheduledFuture&lt;V&gt; decorateTask(Runnable runnable, RunnableScheduledFuture&lt;V&gt;
                            task) Since 1.6
                            <br>protected &lt;V&gt; RunnableScheduledFuture&lt;V&gt; decorateTask(Callable&lt;V&gt; callable,
                            RunnableScheduledFuture&lt;V&gt; task) Since 1.6
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="CompletionService">
                        <th>interface CompletionService&lt;V&gt; Since 1.5</th>
                    </tr>
                    <tr>
                        <td>
                            1. 생산자가 작업들을 추가하면, 소비자는 그것이 완료된 순서대로 이용할 수 있다.
                            <br>
                            <br>2. Future&lt;V&gt; submit(Callable&lt;V&gt; task)
                            <br>Future&lt;V&gt; submit(Runnable task, V result)
                            <br>Future&lt;V&gt; take()
                            <br>» 완료된 작업을 가져온다. 없으면 대기한다.
                            <br>Future&lt;V&gt; poll()
                            <br>» 완료된 작업을 가져온다. 없으면 null.
                            <br>Futur&lt;V&gt; poll(long timeout, TimeUnit unit)
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="ExecutorCompletionService">
                        <th>class ExecutorCompletionService&lt;V&gt; impliments CompletionService&lt;V&gt;</th>
                    </tr>
                    <tr>
                        <td>
                            1. CompletionService 구현. 주어진 Executor를 실행에 이용한다. 완료되는 순서대로 작업을 take 메서드로 접근할 수 있는 큐에 배치한다.
                            <br>
                            <br>2. 생성자
                            <br>public ExecutorCompletionService(Executor executor)
                            <br>public ExecutorCompletionService(Executor executor, BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue)
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="정의된 큐들">
                        <th>java.util.concurrent에서 지원하는 큐들</th>
                    </tr>
                    <tr>
                        <td>
                            1. ConcurrentLinkedQueue : 가변 길이, 쓰레드-안전한 non-blocking FIFO 큐
                            <br>
                            <br>2. ConcurrentlinkedDeque : 가변 길이, 쓰레드-안전한 non-blocking 덱
                            <br>
                            <br>3. BlockingQueue : put(), take()를 블록하는 큐
                            <br>» LinkedBlockingQueue, ArrayBlockingQueue, SynchronousQueue, PriorityBlockingQueue, DelayQueue
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="정의된 맵들">
                        <th>java.util.concurrent에서 지원하는 맵들</th>
                    </tr>
                    <tr>
                        <td>
                            1. ConcurrentMap&lt;K, V&gt; : 쓰레드-안전, 작업의 원자성 보장.
                            <br>» ConcurrentHashMap&lt;K, V&gt;
                            <br>
                            <br>2. ConcurrentNavigableMap&lt;K, V&gt; : NavigableMap 연산을 지원하는 ConcurrentMap
                            <br>» ConcurrentSkipListMap&lt;K, V&gt; (ConcurrentSkipListSet도 존재)
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="Semaphore">
                        <th>class Semaphore implements Serializable Since 1.5</th>
                    </tr>
                    <tr>
                        <td>
                            1. 제한된 수의 접근 권한을 acquire()로 획득, release()로 반환.
                            <br>» fairness : acquire()호출 순서대로 권한 획득.
                            <br>
                            <br>2. 생성자
                            <br>public Semaphore(int permits) : nonfair
                            <br>public Semaphore(int permits, boolean fair)
                            <br>
                            <br>3. void acquire()
                            <br>void acquireUninterruptibly()
                            <br>boolean tryAcquire()
                            <br>boolean tryAcquire(long timeout, TimeUnit unit)
                            <br>void release()
                            <br>void acquire(int permits)
                            <br>void acquireUninterruptibly(int permits)
                            <br>boolean tryAcquire(int permits)
                            <br>boolean tryAcquire(int permits, long timeout, TimeUnit unit)
                            <br>void release(int permits)
                            <br>int availablePermits()
                            <br>int drainPermits() : 가용한 모든 권한을 얻는다. 만약 음수라면 release하여 0으로 맞춘다.
                            <br>boolean isFair()
                            <br>final int getQueueLength()
                            <br>protected Collection&lt;Thread&gt; getQueuedThreads()
                            <br>protected void reducePermits(int recudtion)
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="CountDownLatch">
                        <th>class CountDownLatch Since 1.5</th>
                    </tr>
                    <tr>
                        <td>
                            1. count가 0일 될때까지 대기.
                            <br>
                            <br>2. 생성자 : public CountDownLatch(int count)
                            <br>
                            <br>3. void await()
                            <br>boolean await(long timeout, TimeUnit unit)
                            <br>void countDown()
                            <br>long getCount()
                    </tr>
                    <tr class="con-lv-3" con-title="CyclicBarrier">
                        <th>class CyclicBarrier Since 1.5</th>
                    </tr>
                    <tr>
                        <td>
                            1. 쓰레드들이 공통의 목적이 달성되기까지 함께 대기. 이를 barrier라고 하며, barrier가 재사용될 수 있어 cyclic하다.
                            <br>
                            <br>2. 생성자
                            <br>public CyclicBarrier(int parties, Runnable barrierAction)
                            <br>» barrierAction : barrier를 넘을 때 실행.
                            <br>public CyclicBarrier(int parties)
                            <br>
                            <br>3. int getParties()
                            <br>int await()
                            <br>» 반환값 : 현재 쓰레드의 대기 순번. getParties() - 1이 첫 번째, 0이 마지막 쓰레드.
                            <br>int await(long timeout, TimeUnit unit)
                            <br>boolean isBroken()
                            <br>void reset()
                            <br>int getNumberWaiting()
                        </td>
                    </tr>
                </tbody>
                <tbody class="con-lv-2" con-title="java.util.concurrent.atomic">
                    <tr style="background-color: #bbb;">
                        <th>java.base(module) Since 9 » java.util.concurrent.atomic(package) Since 1.5</th>
                    </tr>
                    <tr class="con-lv-3" con-title="AtomicBoolean">
                        <th>class AtomicBoolean implements Serializable Since 1.5</th>
                    </tr>
                    <tr>
                        <td>
                            1. Boolean을 대신할 순 없다.
                            <br>
                            <br>2. 생성자
                            <br>public AtomicBoolean(boolean initialValue)
                            <br>public AtomicBoolean() : false
                            <br>
                            <br>2. final boolean get()
                            <br>» 현재 값을 반환한다. 메모리 영향은 VarHandle.getVolatile(Object...)와 같다 : 변수가 volatile인 것처럼 읽어 반환.
                            <br>final void set(boolean newValue)
                            <br>» newValue로 값 설정. 메모리 영향은 VarHandle.setVolatile(Object...)와 같다 : 변수가 volatile인 것처럼 값을 새로
                            설정한다.
                            <br>final boolean compareAndSet(boolean expectedValue, boolean newValue)
                            <br>» 현재 값이 expectedValue와 같다면, atomic 연산으로 newValue로 변경하고 true를 반환한다. 메모리 영향은 VarHandle.compareAndSet(Object...)와
                            같다 : setVolatile(Object...)로 값 설정, 현재 값은 getVolatile(Object...)로 가져온다.
                            <br>boolean weakCompareAndSetPlain(boolean expectedValue, boolean newValue) Since 9
                            <br>» 현재 값이 expectedValue와 같다면, 아마도 atomic 연산으로 newValue로 변경하고 true를 반환한다. 메모리 영향은 VarHandle.weakCompareAndSetPlain(Object...)와
                            같다 : 변수가 non-volatile, non-final하다고 간주하는 set(Object...), get(Object...)이용.
                            <br>final void lazySet(boolean newValue) Since 1.6
                            <br>» newValue로 값 설정. 메모리 영향은 VarHandle.setRelease(Object...)와 같다 : 값을 새로 설정하며, 이전의 읽기/쓰기들이
                            재배치되지 않도록 보장한다.
                            <br>final boolean getAndSet(boolean newValue)
                            <br>» atomic 연산으로 newValue로 설정하고, 이전 값을 반환한다. 메모리 영향은 VarHandle.getAndSet(Object...)와 같다 :
                            이전 값은 getVolatile(Object...)로 가져오고, setVolatile(Object...)로 값 설정.
                            <br>final boolean getPlain() Since 9
                            <br>» 변수가 non-volatile인 것처럼 가져온다.
                            <br>final void setPlain(boolean newValue) Since 9
                            <br>» 변수가 non-volatile, non-final인 것처럼 쓴다.
                            <br>final boolean getOpaque() Since 9
                            <br>» 현재 값을 반환한다. 메모리 영향은 VarHandle.getOpaque(Object...)와 같다 : 프로그램 순서에 따라 접근하여 반환. 다른 쓰레드들
                            사이의 접근 순서는 정해지지 않는다.
                            <br>final void setOpaque(boolean newValue) Since 9
                            <br>» newValue로 쓴다. 메모리 영향은 VarHandle.setOpaque(Object...)와 같다 : 프로그램 순서에 따라 접근하여 쓰기. 다른 쓰레드들
                            사이의 접근 순서는 정해지지 않는다.
                            <br>final boolean getAcquire() Since 9
                            <br>» 현재 값을 반환한다. 메모리 영향은 VarHandle.getAcquire(Object...)와 같다 : 변수의 값을 반환한다. 이후의 읽기/쓰기는 이전에
                            실행되지 않는다.
                            <br>final void setRelease(boolean newValue) Since 9
                            <br>» newValue로 설정. 메모리 영향은 VarHandle.setRelease(Object...)와 같다. : 변수의 값을 설정한다. 이전의 읽기/쓰기는
                            이후에 실행되지 않는다.
                            <br>final boolean compareAndExchange(boolean expectedValue, boolean newValue) Since 9
                            <br>» 현재 값이 expectedValue와 같다면 atomic 연산으로 newValue로 설정하고 이전 값 반환. 메모리 영향은 VarHandle.compareAndExchange(Object...)와
                            같다 : expectedValue와 같다면 atomic 연산으로 newValue로 설정. 이전 값은 getVolatile(Object...)로 접근.
                            <br>final boolean compareAndExchangeAcquire(boolean expectedValue, boolean newValue) Since 9
                            <br>» 현재 값이 expectedValue와 같다면 atomic 연산으로 newValue로 설정하고 이전 값 반환. 메모리 영향은 VarHandle.compareAndExchangeAcquire(Object...)와
                            같다 : expectedValue와 같다면 set(Object...)로 newValue 설정. 이전 값은 getAcquire(Object...)로 접근.
                            <br>final boolean compareAndExchangeRelease(boolean expectedValue, boolean newValue) Since 9
                            <br>» 현재 값이 expectedValue와 같다면 atomic 연산으로 newValue로 설정하고 이전 값 반환. 메모리 영향은 VarHandle.compareAndExchangeRelease(Object...)와
                            같다 : expectedValue와 같다면 setRelease(Object...)로 newValue 설정. 이전 값은 get(Object...)로 접근.
                            <br>final boolean weakCompareAndSetVolatile(boolean expectedValue, boolean newValue) Since 9
                            <br>» 현재 값이 expectedValue와 같다면, 아마도 atomic 연산으로 newvalue 설정하고 true 반환. 메모리 영향은 VarHandle.weakCompareAndSet(Object...)와
                            같다 : expectedValue와 같다면 setVolatile(Object...)로 newValue 설정. 이전 값은 getVolatile(Object...)로 접근.
                            <br>final boolean weakCompareAndSetAcquire(boolean expectedValue, boolean newValue) Since 9
                            <br>» 현재 값이 expectedValue와 같다면, 아마도 atomic 연산으로 newValue 설정하고 true 반환. 메모리 영향은 VarHandle.weakCompareAndSetAcquire(Object...)와
                            같다 : expectedValue와 같다면 set(Object...)로 newValue 설정. 이전 값은 getAcquire(Object...)로 접근
                            <br>final boolean weakCompareAndSetRelease(boolean expectedValue, boolean newValue) Since 9
                            <br>» 현재 값이 expectedValue와 같다면, 아마도 atomic 연산으로 newValue 설정하고 true 반환. 메모리 영향은 VarHandle.weakCompareAndSetRelease(Object...)와
                            같다 : expectedValue와 같다면 setRelease(Object...)로 newValue 설정. 이전 값은 get(Object...)로 접근.
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="AtomicInteger">
                        <th>class AtomicInteger extends Number implements Serializable Since 1.5</th>
                    </tr>
                    <tr>
                        <td>
                            1. 생성자
                            <br>public AtomicInteger(int initialValue)
                            <br>public AtomicInteger() : 0
                            <br>
                            <br>2. final int get()
                            <br>final void set(int newValue)
                            <br>final void lazySet(int newValue) Since 1.6
                            <br>final int getAndSet(int newValue)
                            <br>final boolean compareAndSet(int expectedValue, int newValue)
                            <br>final boolean weakCompareAndSetPlain(int expectedValue) Since 9
                            <br>
                            <br>final int getAndIncrement()
                            <br>» atomic 연산으로 1 증가한다. 이전 값을 반환하며, 메모리 영향은 VarHandle.getAndAdd(Object...)와 같다 : getVolatile(Object...)로
                            값을 가져오고, setVolatile(Object...)로 값을 설정
                            <br>final int getAndDecrement()
                            <br>final int getAndAdd(int delta)
                            <br>final int incrementAndGet()
                            <br>» atomic 연산으로 1 증가한다. 이후 값을 반환하며, 메모리 영향은 VarHandle.getAndAdd(Object...)와 같다.
                            <br>final int decrementAndGet()
                            <br>final int addAndGet(int delta)
                            <br>final int getPlain() Since 9
                            <br>final void setPlain(int newValue) Since 9
                            <br>final int getOpaque() Since 9
                            <br>final void setOpaque(int newValue) Since 9
                            <br>final int getAcquire() Since 9
                            <br>final void setRelease(int newValue) Since 9
                            <br>final int compareAndExchange(int expectedValue, int newValue) Since 9
                            <br>final int compareAndExchangeAcquire(int expectedValue, int newValue) Since 9
                            <br>final int compareAndExchangeRelease(int expectedValue, int newValue) Since 9
                            <br>final boolean weakCompareAndSetVolatile​(int expectedValue, int newValue) Since 9
                            <br>final boolean weakCompareAndSetAcquire​(int expectedValue, int newValue) Since 9
                            <br>final boolean weakCompareAndSetRelease​(int expectedValue, int newValue) Since 9
                            <br>» 위 함수들의 설명은
                            <button type="button" onclick="javascript:updateDropupManually($('tr.con-lv-3[con-title=AtomicBoolean]').attr('id'));" class="btn btn-primary btn-sm">
                                AtomicBoolean
                            </button>과 같다.
                            <br>
                            <br>final int getAndUpdate(IntUnaryOperator updateFunction) Since 1.8
                            <br>» atomic 연산으로 값을 갱신한다. 이전 값을 반환하며, 메모리 영향은 VarHandle.compareAndSet(Object...)와 같다. 이용되는
                            함수는 재실행될 수 있으므로, 부작용이 없어야 한다.
                            <br>final int updateAndGet(IntUnaryOperator updateFunction) Since 1.8
                            <br>» 갱신 이후 값을 반환.
                            <br>final int getAndAccumulate(int x, IntBinaryOperator accumulatorFunction) Since 1.8
                            <br>» atomic 연산으로 값을 갱신한다. 이전 값을 반환하며, 메모리 영향은 VarHandle.compareAndSet(Object...)와 같다. 이용되는
                            함수는 재실행될 수 있으므로, 부작용이 없어야 한다.
                            <br>final int accumulateAndGet(int x, IntBinaryOperator accumulatorFunction) Since 1.8
                            <br>» 갱신 이후 값을 반환.
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="AtomicIntegerArray">
                        <th>class AtomicIntegerArray implements Serializable Since 1.5</th>
                    </tr>
                    <tr>
                        <td>
                            1. 생성자
                            <br>public AtomicIntegerArray(int length) : 각 원소는 0으로 초기화.
                            <br>public AtomicIntegerArray(int[] array)
                            <br>
                            <br>2. final int get(int i)
                            <br>final void set(int i, int newValue) ...
                            <br>» 지원하는 함수들의 설명은
                            <button type="button" onclick="javascript:updateDropupManually($('tr.con-lv-3[con-title=AtomicInteger]').attr('id'));" class="btn btn-primary btn-sm">
                                AtomicInteger
                            </button>와 같다.
                            <br>
                            <br>final int length()
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="AtomicIntegerFieldUpdater">
                        <th>abstract class AtomicIntegerFieldUpdater&lt;T&gt; Since 1.5</th>
                    </tr>
                    <tr>
                        <td>
                            1. 지정된 volatile int 필드를 atomic 연산으로 갱신.
                            <br>
                            <br>2. static &lt;U&gt; AtomicIntegerFieldUpdater&lt;U&gt; newUpdater(Class&lt;U&gt; tclass, String
                            fieldName)
                            <br>
                            <br>3. abstract boolean compareAndSet(T obj, int expect, int update)
                            <br>abstract boolean weakCompareAndSet(T obj, int expect, int update) ...
                            <br>» 지원하는 함수들의 종류는
                            <button type="button" onclick="javascript:updateDropupManually($('tr.con-lv-3[con-title=AtomicInteger]').attr('id'));" class="btn btn-primary btn-sm">
                                AtomicInteger
                            </button>와 유사하다.
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="AtomicReference">
                        <th>class AtomicReference&lt;V&gt; implements Serializable Since 1.5</th>
                    </tr>
                    <tr>
                        <td>
                            1. 아마도 atomic 연산으로 변경되는 객체 참조를 정의.
                            <br>» 지원하는 함수들의 종류는
                            <button type="button" onclick="javascript:updateDropupManually($('tr.con-lv-3[con-title=AtomicInteger]').attr('id'));" class="btn btn-primary btn-sm">
                                AtomicInteger
                            </button>와 유사하다.
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="AtomicReferenceArray">
                        <th>class AtomicReferenceArray&lt;E&gt; implements Serializable Since 1.5</th>
                    </tr>
                    <tr>
                        <td>
                            1. 아마도 atomic 연산으로 변경되는 객체 참조들의 배열을 정의.
                            <br>» 지원하는 함수들의 종류는
                            <button type="button" onclick="javascript:updateDropupManually($('tr.con-lv-3[con-title=AtomicIntegerArray]').attr('id'));"
                                class="btn btn-primary btn-sm">
                                AtomicIntegerArray
                            </button>와 유사하다.
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="AtomicReferenceFieldUpdater">
                        <th>abstract class AtomicReferenceFieldUpdater&lt;T, V&gt; Since 1.5</th>
                    </tr>
                    <tr>
                        <td>
                            1. 지정된 클래스의 지정된 volatile 참조 필드를 atomic 연산으로 변경.
                            <br>» 지원하는 함수들의 종류는
                            <button type="button" onclick="javascript:updateDropupManually($('tr.con-lv-3[con-title=AtomicIntegerFieldUpdater]').attr('id'));"
                                class="btn btn-primary btn-sm">
                                AtomicIntegerFieldUpdater
                            </button>와 유사하다.
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="LongAdder">
                        <th>class LongAdder extends Number implements Serializable Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            1. 초깃값 0으로 시작하는 쓰레드-안전한 합계. 단, 합의 순서는 정의되지 않으므로 순서에 상관 없는 경우에 이용해야 한다. 또, 주어진 accumulatorFunction은 부작용이 없어야 한다.
                            <br>
                            <br>2. 생성자 : public LongAdder()
                            <br>
                            <br>3. void add(long x)
                            <br>void increment()
                            <br>void decrement()
                            <br>long sum() : 현재 합계 반환
                            <br>void reset()
                            <br>long sumThenReset()
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="LongAccumulator">
                        <th>class LongAccumulator extends Number implements Serializable Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            1. 특정 값과 특정 함수로 갱신되는 long 값 유지.
                            <br>
                            <br>2. 생성자 : public LongAccumulator(LongBinaryOperator accumulatorFunction, long identity)
                            <br>
                            <br>3. void accumulate(long x)
                            <br>long get()
                            <br>void reset()
                            <br>long getThenReset()
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="DoubleAdder">
                        <th>class DoubleAdder extends Number implements Serializable Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            <button type="button" onclick="javascript:updateDropupManually($('tr.con-lv-3[con-title=LongAdder]').attr('id'));" class="btn btn-primary btn-sm">
                                Goto LongAdder »
                            </button>
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="DoubleAccumulator">
                        <th>class DoubleAccumulator extends Number implements Serializable Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            <button type="button" onclick="javascript:updateDropupManually($('tr.con-lv-3[con-title=LongAccumulator]').attr('id'));"
                                class="btn btn-primary btn-sm">
                                Goto LongAccumulator »
                            </button>
                        </td>
                    </tr>
                </tbody>
                <tbody class="con-lv-2" con-title="java.util.function">
                    <tr style="background-color: #bbb;">
                        <th>java.base(module) Since 9 » java.util.function(package) Since 1.8</th>
                    </tr>
                    <tr class="con-lv-3" con-title="BiConsumer">
                        <th>@FunctionalInterface interface BiConsumer&lt;T, U&gt; Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            1. 인자 두개를 먹고 아무것도 뱉지 않는 소비자.
                            <br>
                            <br>2. void accept(T t, U u) : 적당한 동작 수행
                            <br>
                            <br>3. default BiConsumer&lt;T, U&gt; andThen(BiConsumer&lt;? super T, ? super U&gt; after) : 현재
                            소비자가 작업을 마치면 after가 실행되는 새로운 소비자 반환.
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="BiFunction">
                        <th>@FunctionalInterface interface BiFunction&lt;T, U, R&gt; Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            1. 인자 두개를 먹고 값을 반환하는 함수.
                            <br>
                            <br>2. R apply(T t, U u)
                            <br>
                            <br>3. default &lt;V&gt; BiFunction&lt;T, U, V&gt; andThen(Function&lt;? super R, ? extends V&gt;
                            after) : 함수가 실행되고 난 결과를 after가 처리하는 새로운 함수 반환.
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="BinaryOperator">
                        <th>@FunctionalInterface interface BinaryOperator extends BiFunction&lt;T, T, T&gt; Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            1. 같은 타입의 인자 두개를 먹고 같은 타입의 값을 반환하는 함수.
                            <br>
                            <br>2. static &lt;T&gt; BinaryOperator&lt;T&gt; minBy(Comparator&lt;? super T&gt; comparator) : 주어진
                            comparator에 따라 둘 중 작은 것을 반환하는 함수를 생성.
                            <br>static &lt;T&gt; BinaryOperator&lt;T&gt; maxBy(Comparator&lt;? super T&gt; comparator) : 주어진
                            comparator에 따라 둘 중 큰 것을 반환하는 함수 생성.
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="BiPredicate">
                        <th>@FunctionalInterface interface BiPredicate&lt;T, U&gt; Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            1. 인자 두개를 먹고 가부를 판단하는 함수.
                            <br>
                            <br>2. boolean test(T t, U u)
                            <br>
                            <br>3. default BiPredicate&lt;T, U&gt; and(BiPredicate&lt;? super T, ? super U&gt; other) : A short-circuiting
                            logical AND of this predicate and other.
                            <br>default BiPredicate&lt;T, U&gt; negate()
                            <br>default BiPredicate&lt;T, U&gt; or(BiPredicate&lt;? super T, ? super U&gt; other) : A short-circuiting
                            logical OR of this predicate and other.
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="BooleanSupplier">
                        <th>@FunctionalInterface interface BooleanSupplier Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            1. boolean 값을 공급하는 생산자.
                            <br>
                            <br>2. boolean getAsBoolean()
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="Consumer">
                        <th>@FunctionalInterface interface Consumer&lt;T&gt; Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            1. 인자를 하나 먹고 아무것도 반환하지 않는 소비자.
                            <br>
                            <br>2. void accept(T t)
                            <br>
                            <br>3. default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after) : 이 소비자 다음에 after가 소비하는
                            병합된 소비자 반환.
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="DoubleBinaryOperator">
                        <th>@FunctionalInterface interface DoubleBinaryOperator Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            1. double 두개를 먹고 double 하나를 반환하는 함수.
                            <br>
                            <br>2. double applyAsDouble(double left, double right)
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="DoubleConsumer">
                        <th>@FunctionalInterface interface DoubleConsumer Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            1. void accept(double value)
                            <br>
                            <br>2. default DoubleConsumer andThen(DoubleConsumer after)
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="DoubleFunction">
                        <th>@FunctionalInterface interface DoubleFunction&lt;R&gt; Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            1. R apply(double value)
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="DoublePredicate">
                        <th>@FunctionalInterface interface DoublePredicate Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            1. boolean test(double value)
                            <br>
                            <br>2. default DoublePredicate and(DoublePredicate other)
                            <br>default DoublePredicate or(DoublePredicate other)
                            <br>default DoublePredicate negate()
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="DoubleSupplier">
                        <th>@FunctionalInterface interface DoubleSupplier Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            1. double getAsDouble()
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="DoubleToIntFunction">
                        <th>@FunctionalInterface interface DoubleToIntFunction Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            1. int applyAsInt(double value)
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="DoubleToLongFunction">
                        <th>@FunctionalInterface interface DoubleToLongFunction Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            1. long applyAsLong(double value)
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="DoubleUnaryOperator">
                        <th>@FunctionalInterface interface DoubleUnaryOperator Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            1. double applyAsDouble(double operand)
                            <br>
                            <br>2. default DoubleUnaryOperator compose(DoubleUnaryOperator before)
                            <br>default DoubleUnaryOperator andThen(DoubleUnaryOperator after)
                            <br>static DoubleUnaryOperator identity() : 항상 입력값 그대로 반환하는 단항 연산자 반환.
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="Function">
                        <th>@FunctionalInterface interface Function&lt;T, R&gt; Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            1. 인자 하나를 먹고 결과 하나를 뱉는 함수.
                            <br>
                            <br>2. R apply(T t)
                            <br>
                            <br>3. default &lt;V&gt; Function&V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before)
                            <br>default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after)
                            <br>static &lt;T&gt; Function&lt;T, T&gt; identity() : 입력 인자 그대로 반환하는 함수.
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="IntBinaryOperator">
                        <th>@FunctionalInterface interface IntBinaryOperator Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            1. int applyAsInt(int left, int right)
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="IntConsumer">
                        <th>@FunctionalInterface interface IntConsumer Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            1. void accept(int value)
                            <br>
                            <br>2. default IntConsumer andThen(IntConsumer after)
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="IntFunction">
                        <th>@FunctionalInterface interface IntFunction&lt;R&gt; Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            1. R apply(int value)
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="IntPredicate">
                        <th>@FunctionalInterface interface IntPredicate Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            1. boolean test(int value)
                            <br>
                            <br>2. default IntPredicate and(IntPredicate other)
                            <br>default IntPredicate or(IntPredicate other)
                            <br>default IntPredicate negate()
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="IntSupplier">
                        <th>@FunctionalInterface interface IntSupplier Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            1. int getAsInt()
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="IntToDoubleFunction">
                        <th>@FunctionalInterface interface IntToDoubleFunction Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            1. double applyAsDouble(int value)
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="IntToLongFunction">
                        <th>@FunctionalInterface interface IntToLongFunction Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            1. long applyAsLong(int value)
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="IntUnaryOperator">
                        <th>@FunctionalInterface interface IntUnaryOperator Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            1. int applyAsInt(int operand)
                            <br>
                            <br>2. default IntUnaryOperator compose(IntUnaryOperator before)
                            <br>default IntUnaryOperator andThen(IntUnaryOperator after)
                            <br>static IntUnaryOperator identity()
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="LongBinaryOperator">
                        <th>@FunctionalInterface interface LongBinaryOperator Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            1. long applyAsLong(long left, long right)
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="LongConsumer">
                        <th>@FunctionalInterface interface LongConsumer Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            1. void accept(long value)
                            <br>
                            <br>2. default LongConsumer andThen(LongConsumer after)
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="LongFunction">
                        <th>@FunctionalInterface interface LongFunction&lt;R&gt; Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            1. R apply(long value)
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="LongPredicate">
                        <th>@FunctionalInterface interface LongPredicate Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            1. boolean test(long value)
                            <br>
                            <br>2. default LongPredicate and(LongPredicate other)
                            <br>default LongPredicate or(LongPredicate other)
                            <br>default LongPredicate negate()
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="LongSupplier">
                        <th>@FunctionalInterface interface LongSupplier Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            1. long getAsLong()
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="LongToDoubleFunction">
                        <th>@FunctionalInterface interface LongToDoubleFunction Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            1. double applyAsDouble(long value)
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="LongToIntFunction">
                        <th>@FunctionalInterface interface LongToIntFunction Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            1. int applyAsInt(long value)
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="LongUnaryOperator">
                        <th>@FunctionalInterface interface LongUnaryOperator Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            1. long applyAsLong(long operand)
                            <br>
                            <br>2. default LongUnaryOperator compose(LongUnaryOperator before)
                            <br>default LongUnaryOperator andThen(LongUnaryOperator after)
                            <br>static LongUnaryOperator identity()
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="ObjDoubleConsumer">
                        <th>@FunctionalInterface interface ObjDoubleConsumer&lt;T&gt; Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            1. void accept(T t, double value)
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="OjbIntConsumer">
                        <th>@FunctionalInterface interface ObjIntConsumer&lt;T&gt; Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            1. void accept(T t, int value)
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="ObjLongConsumer">
                        <th>@FunctionalInterface interface ObjLongConsumer&lt;T&gt; Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            1. void accept(T t, long value)
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="Predicate">
                        <th>@FunctionalInterface interface Predicate&lt;T&gt; Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            1. boolean test(T t)
                            <br>
                            <br>2. default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other)
                            <br>default Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other)
                            <br>static &lt;T&gt; Predicate&lt;T&gt; isEqual(Object targetRef) : Object.equals(Object, Object)를
                            이용해 비교하는 Predicate 반환
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="Supplier">
                        <th>@FunctionalInterface interface Supplier&lt;T&gt; Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            1. T get()
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="ToDoubleBiFunction">
                        <th>@FunctionalInterface interface ToDoubleBiFunction&lt;T, U&gt; Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            1. double applyAsDouble(T t, U u)
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="ToDoubleFunction">
                        <th>@FunctionalInterface interface ToDoubleFunction&lt;T&gt; Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            1. double applyAsDouble(T value)
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="ToIntBiFunction">
                        <th>@FunctionalInterface interface ToIntBiFunction&lt;T, U&gt; Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            1. int applyAsInt(T t, U u)
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="ToIntFunction">
                        <th>@FunctionalInterface interface ToIntFunction&lt;T&gt; Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            1. int applyAsInt(T value)
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="ToLongBiFunction">
                        <th>@FunctionalInterface interface ToLongBiFunction&lt;T, U&gt; Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            1. long applyAsLong(T t, U u)
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="ToLongFunction">
                        <th>@FunctionalInterface interface ToLongFunction&lt;T&gt; Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            1. long applyAsLong(T value)
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="UnaryOperator">
                        <th>@FunctionalInterface interface UnaryOperator&lt;T&gt; extends Function&lt;T, T&gt; Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            1. static &lt;T&gt; UnaryOperator&lt;T&gt; identity()
                        </td>
                    </tr>
                </tbody>
                <tbody class="con-lv-2" con-title="java.util.regex">
                    <tr style="background-color: #bbb;">
                        <th>java.base(module) Since 9 » java.util.regex(package) Since 1.4</th>
                    </tr>
                    <tr class="con-lv-3" con-title="MatchResult">
                        <th>interface MatchResult Since 1.5</th>
                    </tr>
                    <tr>
                        <td>
                            1. 정규표현식 매칭 결과. group의 의미에 대해선
                            <button type="button" onclick="javascript:updateDropupManually($('tr.con-lv-3[con-title=Pattern]').attr('id'));" class="btn btn-primary btn-sm">
                                Pattern »
                            </button> 참고.
                            <br>
                            <br>2. int start() : 매치된 결과의 시작 인덱스 반환
                            <br>int start(int group) : group번째 매치된 결과의 시작 인덱스 반환
                            <br>int end() : 매치된 결과의 마지막 글자 다음 인덱스 반환
                            <br>int end(int group) : group번째 매치된 결과의 마지막 글자 다음 인덱스 반환
                            <br>String group() : 이전 매치된 결과 반환
                            <br>String group(int group) : group번째 매치된 결과 반환
                            <br>int groupCount() : 매치된 group 개수 반환
                            <button type="button" onclick="javascript:showCode('JavaUtilRegex/src/MatchResultExample.java', 'java');" class="btn btn-primary btn-sm">
                                View Code : 예제 »
                            </button>
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="Pattern">
                        <th>final class Pattern implements Serializable Since 1.4</th>
                    </tr>
                    <tr>
                        <td>
                            1. 정규표현식의 컴파일된 표현.
                            <br>
                            <br>
                            <b>2. 정규표현식 상수</b>
                            <br>x » 문자 x 자체
                            <br>\\ » 백슬래시 문자
                            <br>\0n 또는 \0nn 또는 \0mnn» » 8진수 표현 문자
                            <br>\xhh 또는 \uhhhh 또는 \u{h...h} » 16진수 표현 문자
                            <br>\N{name} » 유니코드 이름으로 표현된 문자
                            <br>\t » 탭 \u0009
                            <br>\n » newline \u000A
                            <br>\r » carriage-return \u000D
                            <br>\f » form-feed \u000C
                            <br>\a » alert \u0007
                            <br>\e » escape \u001B
                            <br>\cx » x에 관한 제어 문자
                            <br>
                            <br>[abc] » a, b, or c(단순 집합)
                            <br>[^abc] » a, b, c를 제외한 임의 문자(여집합)
                            <br>[a-zA-Z] » a ~ z or A ~ Z, inclusive(범위)
                            <br>[a-d[m-p]] » a ~ d or m ~ p : [a-dm-p](합집합)
                            <br>[a-z&amp;&amp;[def]] » d, e, or f(교집합)
                            <br>[a-z&amp;&amp;[^bc]] » a ~ z, b와 c는 제외(차집합)
                            <br>[a-z&amp;&amp;[^m-p]] » a ~ z, m ~ p는 제외 : [a-lq-z](차집합)
                            <br>
                            <br>. » 임의 문자(줄 끝은 매치되지 않을수도 있음)
                            <br>\d » [0-9]
                            <br>\D » [^0-9]
                            <br>\h » 수평 공백 문자: [ \t\xA0\u1680\u180e\u2000-\u200a\u202f\u205f\u3000]
                            <br>\H » [^\h]
                            <br>\s » 공백 문자: [ \t\n\x0B\f\r]
                            <br>\S » [^\s]
                            <br>\v » 수직 공백 문자: [\n\x0B\f\r\x85\u2028\u2029]
                            <br>\V » [^\v]
                            <br>\w » [a-zA-Z_0-9]
                            <br>\W » [^w]
                            <br>
                            <br>\p{Lower} » [a-z]
                            <br>\p{Upper} » [A-Z]
                            <br>\p{ASCII} » All ASCII:[\x00-\x7F]
                            <br>\p{Alpha} » [\p{Lower}\p{Upper}]
                            <br>\p{Digit} » [0-9]
                            <br>\p{Alnum} » [\p{Alpha}\p{Digit}]
                            <br>\p{Punct} » Punctuation: One of !"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\]^_`{|}~
                            <br>\p{Graph} » A visible character: [\p{Alnum}\p{Punct}]
                            <br>\p{Print} » A printable character: [\p{Graph}\x20]
                            <br>\p{Blank} » A space or a tab: [ \t]
                            <br>\p{Cntrl} » A control character: [\x00-\x1F\x7F]
                            <br>\p{XDigit} » A hexadecimal digit: [0-9a-fA-F]
                            <br>\p{Space} » A whitespace character: [ \t\n\x0B\f\r]
                            <br>
                            <br>\p{javaLowerCase} » Equivalent to java.lang.Character.isLowerCase()
                            <br>\p{javaUpperCase} » Equivalent to java.lang.Character.isUpperCase()
                            <br>\p{javaWhitespace} » Equivalent to java.lang.Character.isWhitespace()
                            <br>\p{javaMirrored} » Equivalent to java.lang.Character.isMirrored()
                            <br>
                            <br>\p{IsLatin} » A Latin script character (script)
                            <br>\p{InGreek} » A character in the Greek block (block)
                            <br>\p{Lu} » An uppercase letter (category)
                            <br>\p{IsAlphabetic} » An alphabetic character (binary property)
                            <br>\p{Sc} » A currency symbol
                            <br>\P{InGreek} » Any character except one in the Greek block (negation)
                            <br>[\p{L}&amp;&amp;[^\p{Lu}]] » Any letter except an uppercase letter (subtraction)
                            <br>
                            <br>^ » The beginning of a line
                            <br>$ » The end of a line
                            <br>\b » A word boundary
                            <br>\b{g} » A Unicode extended grapheme cluster boundary
                            <br>\B » A non-word boundary
                            <br>\A » The beginning of the input
                            <br>\G » The end of the previous match
                            <br>\Z » The end of the input but for the final terminator, if any
                            <br>\z » The end of the input
                            <br>\R » Any Unicode linebreak sequence, is equivalent to \u000D\u000A|[\u000A\u000B\u000C\u000D\u0085\u2028\u2029]
                            <br>
                            <br>
                            <b>Greedy quantifiers
                                <a role="button" class="btn btn-info btn-sm" href="https://stackoverflow.com/questions/5319840/greedy-vs-reluctant-vs-possessive-quantifiers">참고자료</a>
                            </b>
                            <br>» 처음에 매치할 수 있는 만큼 최대한 매치. 그 다음 요소의 매칭이 없으면 백트래킹.
                            <br>X? » X, once or not at all
                            <br>X* » X, zero or more times
                            <br>X+ » X, one or more times
                            <br>X{n} » X, exactly n times
                            <br>X{n,} » X, at least n times
                            <br>X{n,m} » X, at least n but not more than m times
                            <br>
                            <br>
                            <b>Reluctant quantifiers</b>
                            <br>» non-greedy. 처음에 최소한만 매치. 그 다음 요소의 매칭이 없으면 백트래킹.
                            <br>X?? » X, once or not at all
                            <br>X*? » X, zero or more times
                            <br>X+? » X, one or more times
                            <br>X{n}? » X, exactly n times
                            <br>X{n,}? » X, at least n times
                            <br>X{n,m}? » X, at least n but not more than m times
                            <br>
                            <br>
                            <b>Possessive quantifiers</b>
                            <br>» Greedy quantifier와 같지만, 백트래킹은 없다.
                            <br>X?+ » X, once or not at all
                            <br>X*+ » X, zero or more times
                            <br>X++ » X, one or more times
                            <br>X{n}+ » X, exactly n times
                            <br>X{n,}+ » X, at least n times
                            <br>X{n,m}+ » X, at least n but not more than m times
                            <br>
                            <br>
                            <b>Logical operations</b>
                            <br>XY » X followed by Y
                            <br>X|Y » Either X or Y
                            <br>(X) » X, as a capturing group
                            <br>
                            <br>
                            <b>Back references</b>
                            <br>\n » Whatever the n-th capturing group matched
                            <br>\k&lt;name&gt; » Whatever the named-capturing group "name" matched
                            <br>
                            <br>
                            <b>Quotation</b>
                            <br>\ » Nothing, but quotes the following character
                            <br>\Q » Nothing, but quotes all characters until \E
                            <br>\E » Nothing, but ends quoting started by \Q
                            <br>
                            <br>
                            <b>Special constructs</b>
                            <br>(?&lt;name&gt;X) » X, as a named-capturing group
                            <br>(?:X) » X, as a non-capturing group
                            <br>(?idmsuxU-idmsuxU) » Nothing, but turns match flags i d m s u x U on - off
                            <br>(?idmsux-idmsux:X) » X, as a non-capturing group with the given flags i d m s u x on -
                            off
                            <br>(?=X) » X, via zero-width positive lookahead
                            <br>(?!X) » X, via zero-width negative lookahead
                            <br>(?&lt;=X) » X, via zero-width positive lookbehind
                            <br>(?&lt;!X) » X, via zero-width negative lookbehind
                            <br>(?&gt;X) » X, as an independent, non-capturing group
                            <br>
                            <br>
                            <b>3. Groups and capturing</b>
                            <br>» 괄호 여는 순서에 따라 capturing group의 숫자가 매겨진다.
                            <br>» ((A)(B(C)))에 대하여, 0: ((A)(B(C))), 1: (A), 2: (B(C)), 3: (C)의 4가지 그룹이 존재하며, 0번 그룹은 항상
                            전체 표현을 가리킨다.
                            <br>
                            <br>4. 필드
                            <br>public static final int UNIX_LINES
                            <br>» 줄끝 '\n'만 ., ^, $에서 동작. (?d) 플래그도 같은 의미.
                            <br>public static final int CASE_INSENSITIVE
                            <br>» 대소문자 구분 없음. (?i) 플래그도 같은 의미.
                            <br>public static final int COMMENTS
                            <br>» 공백과 주석 허용 » 공백과 #부터 줄 끝까지의 주석이 무시된다. (?x) 플래그도 같은 의미.
                            <br>public static final int MULTILINE
                            <br>» ^, $이 각 줄의 끝을 기준으로도 작동; 기본 동작은 입력 시작과 끝에서만 작동. (?m) 플래그도 같은 의미.
                            <br>public static final int LITERAL Since 1.5
                            <br>» 표현식 전체를 상수 문자열 취급.
                            <br>public static final int DOTALL
                            <br>» .이 줄 끝도 포함하여 매치; 기본 동작은 줄 끝 문자는 미포함. (?s) 플래그도 같은 의미.
                            <br>public static final int UNICODE_CASE
                            <br>» CASE_INSENSITIVE 플래그가 유니코드 표준 상에서 동작한다; 기본은 US-ASCII에서만 동작. (?u) 플래그도 같은 의미.
                            <br>2개 생략
                            <br>
                            <br>5. static Pattern compile(String regex) + 1 오버로딩
                            <br>static boolean matches(String regex, CharSequence input) : 1회용
                            <br>String pattern()
                            <br>String toString() Since 1.5
                            <br>static String quote(String s) Since 1.5
                            <br>» s를 매칭할 수 있는 정규표현식 리터럴 문자열 표현을 반환.
                            <br>int flags()
                            <br>
                            <br>6. Matcher matcher(CharSequence input)
                            <br>String[] split(CharSequence input) + 1 오버로딩
                            <br>
                            <br>7. Since 1.8
                            <br>Predicate&lt;String&gt; asPredicate()
                            <br>Stream&lt;String&gt; splitAsStream(CharSequence nput)
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="Matcher">
                        <th>final class Matcher implements MatchResult Since 1.4</th>
                    </tr>
                    <tr>
                        <td>
                            1. Pattern으로부터 만들어지는 매칭 엔진으로, 아래 세 가지 작업을 수행한다.
                            <br>» matches() : 전체 입력에 대해 패턴 매칭
                            <br>» lookingAt() : 입력 시작부분 패턴 매칭
                            <br>» find() : 입력의 다음 부분 패턴 매칭
                            <br>
                            <br>2. Pattern pattern()
                            <br>MatchResult toMatchResult() Since 1.5
                            <br>Matcher usePattern(Pattern newPattern) Since 1.5
                            <br>Matcher reset() + 1오버로딩
                            <br>
                            <br>3. int start(String name) Since 1.8
                            <br>» 주어진 식별자에 해당하는 그룹의 시작 인덱스 반환
                            <br>int end(String name) Since 1.8
                            <br>String group(String name) Since 1.7
                            <br>
                            <br>4. boolean mathes()
                            <br>boolean find() + 1 오버로딩
                            <br>boolean lookingAt()
                            <br>
                            <br>5. static String quoteReplacement(String s) Since 1.5
                            <br>» appendReplacement 메서드의 replacement로 사용될 s의 리터럴 표기를 반환.
                            <br>Matcher appendReplacement(StringBuffer sb, String replacement) + 1 오버로딩
                            <br>» 입력 소스의 append position부터 start() 전까지 sb에 추가.
                            <br>» replacement를 sb에 추가. 현재 matcher의 append position을 end()로 설정.
                            <br>StringBuffer appendTail(StringBuffer sb) + 1 오버로딩
                            <br>» 입력 소스의 append position부터를 sb에 추가.
                            <br>» appendReplacement 메서드를 호출한 뒤에 이를 호출하여 남머지 부분을 복사할 목적으로 만들어짐.
                            <br>String replaceAll(String replacement)
                            <br>» 입력 소스의 모든 매칭되는 부분을 replacement로 변경.
                            <br>String replaceAll(Function&lt;MatchResult, String&gt; replacer) Since 9
                            <br>String replaceFirst(String replacement) + 1 오버로딩
                            <br>Stream&lt;MatchResult&gt; results() Since 9
                            <br>
                            <br>6. Matcher region(int start, int end) Since 1.5
                            <br>» 입력 소스의 특정 구간을 매칭 대상으로 하도록 초기화한다. transparency, anchoring 속성에 따라 동작이 다르다.
                            <br>int regionStart(), regionEnd() Since 1.5
                            <br>boolean hasTransparentBounds() Since 1.5
                            <br>Matcher useTransparentBounds(boolean b) Since 1.5
                            <br>» region의 경계 너머를 패턴 매칭에 보이도록 할지 여부
                            <br>boolean hasAnchoringBounds() Since 1.5
                            <br>Matcher useAnchoringBounds(boolean b) Since 1.5
                            <br>» region의 경계에서 ^, $를 작동하게 할지 여부
                        </td>
                    </tr>
                </tbody>
                <tbody class="con-lv-2" con-title="java.util.stream">
                    <tr style="background-color: #bbb;">
                        <th>java.base(module) Since 9 » java.util.stream(package) Since 1.8</th>
                    </tr>
                    <tr class="con-lv-3" con-title="BaseStream">
                        <th>interface BaseStream&lt;T, S extends BaseStream&lt;T, S&gt;&gt; extends AutoCloseable Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            Iterator&lt;T&gt; iterator()
                            <br>Spliterator&lt;T&gt; spliterator()
                            <br>boolean isParallel()
                            <br>S sequential() : 순차적인 스트림 반환(어쩌면 자기 자신)
                            <br>S parallel() : 병렬적인 스트림 반환(어쩌면 자기 자신)
                            <br>S unordered() : 순서 없는 스트림 반환(어쩌면 자기 자신)
                            <br>S onClose(Runnable closeHandler)
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="DoubleStream">
                        <th>interface DoubleStream extends BaseStream&lt;Double, DoubleStream&gt; Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            <b>1. static interface DoubleStream.Builder extends DoubleConsumer Since 1.8</b>
                            <br>default DoubleStream.Builder add(double t)
                            <br>DoubleStream build()
                            <br>
                            <br>2. DoubleStream filter(DoublePredicate predicate) : 솎아내기
                            <br>DoubleStream map(DoubleUnaryOperator mapper) : 각 원소에 연산 적용
                            <br>&lt;U&gt; Stream&lt;U&gt; mapToObj(DoubleFunction&lt;? extends U&gt; mapper)
                            <br>IntStream mapToInt(DoubleToIntFunction maper)
                            <br>LongStream mapToLong(DoubleToLongFunction mapper)
                            <br>DoubleStream flatMap(DoubleFunction&lt;? extends DoubleStream&gt; mapper)
                            <br>» map + each mapped stream is closed after its contents have been placed into this stream
                            <br>DoubleStream distinct() : 중복 원소 제거
                            <br>DoubleStream sorted() : 정렬
                            <br>DoubleStream peek(DoubleConsumer action) : 각 원소를 소비하고 그대로 반환. 디버그용.
                            <br>DoubleStream limit(long maxSize) : 뒷부분 자르기
                            <br>DoubleStream skip(long n) : 처음 n개 제거
                            <br>default DoubleStream takeWhile(DoublePredicate predicate) Since 9
                            <br>» 정렬된 스트림의 경우 조건을 만족하는 최장 길이 접두 부분을 반환.
                            <br>» 정렬되지 않은 경우, 조건을 만족하는 원소들의 부분 집합 반환. 반환되는 부분 집합은 해당 원소들을 모두 포함할수도, 공집합일수도 있다.
                            <br>default DoubleStream dropWhile(DoublePredicate predicate) Since 9
                            <br>void forEach(DoubleConsumer action) : 스트림 원소 순서와 실행 순서 다를 수 있음.
                            <br>void forEachOrdered(DoubleConsumer action) : 스트림 원소 순서와 실행 순서가 같음을 보장.
                            <br>double[] toArray()
                            <br>double reduce(double identity, DoubleBinaryOperator op)
                            <br>» 아래와 같다.
                            <br>var result = identity;
                            <br>for(var element : this stream)
                            <br>&nbsp;&nbsp;&nbsp;&nbsp;result = op.applyAsDouble(result, element);
                            <br>return result;
                            <br>OptionalDouble reduce(DoubleBinaryOperator op)
                            <br>» 아래와 같다.
                            <br>var foundAny = false;
                            <br>double result = null;
                            <br>for(var element : this stream) {
                            <br>&nbsp;&nbsp;&nbsp;&nbsp;if(!foundAny) {
                            <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foundAny = true;
                            <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = element;
                            <br>&nbsp;&nbsp;&nbsp;&nbsp;} else
                            <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = op.applyAsDouble(result, element);
                            <br>}
                            <br>return foundAny? OptionalDouble.of(result) : OptionalDouble.empty();
                            <br>&lt;R&gt; R collect(Supplier&lt;R&gt; supplier, ObjDoubleConsumer&lt;R&gt; accumulator, BiConsumer&lt;R,
                            R&gt; combiner)
                            <br>» Collection, StringBuilder처럼 가변적인 컨테이너에 자료를 담을 때 사용.
                            <br>예. 전체 원소의 문자열 표현을 하나로 모으기.
                            <br>var strings = stream.collect(() -&gt; new ArrayList&lt;String&gt;(), (c, e) -&gt; c.add(e.toString()),
                            (c1, c2) -&gt; c1.addAll(c2));
                            <br>var strings = stream.map(Object::toString).collect(ArrayList::new, ArrayList::add, ArrayList::addAll);
                            <br>double sum()
                            <br>OptionalDouble min(), max(), average(), findFirst(), findAny()
                            <br>long count()
                            <br>DoubleSummaryStatistics summaryStatistics()
                            <br>boolean anyMatch(DoublePredicate predicate), allMatch(DoublePredicate predicate), noneMatch(DoublePredicate
                            predicate)
                            <br>Stream&lt;Double&gt; boxed()
                            <br>
                            <br>3. static DoubleStream.Builder builder()
                            <br>static DoubleStream empty()
                            <br>static DoubleStream of(double t)
                            <br>static DoubleStream of(double... values)
                            <br>static DoubleStream iterate(double seed, DoubleUnaryOperator f) : 무한 스트림 생성; seed, f(seed), f(f(seed)),
                            ...
                            <br>static DoubleStream iterate(double seed, DoublePredicate hasNext, DoubleUnaryOperator next) Since
                            9
                            <br>static DoubleStream generate(DoubleSupplier s)
                            <br>static DoubleStream concat(DoubleStream a, DoubleStream b)
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="IntStream">
                        <th>interface IntStream extends BaseStream&lt;Integer, Integer&gt; Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            <b>1. static interface IntStream.Builder</b>
                            <br>
                            <br>2. static IntStream range(int startInclusive, int endExclusive)
                            <br>static IntStream rangeClosed(int startInclusive, int endInclusive)
                            <button type="button" onclick="javascript:updateDropupManually($('tr.con-lv-3[con-title=DoubleStream]').attr('id'));" class="btn btn-primary btn-sm">
                                참고 : DoubleStream »
                            </button>
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="LongStream">
                        <th>interface LongStream extends BaseStream&lt;Long, LongStream&gt; Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            <b>1. static interface LongStream.Builder</b>
                            <button type="button" onclick="javascript:updateDropupManually($('tr.con-lv-3[con-title=IntStream]').attr('id'));" class="btn btn-primary btn-sm">
                                참고 : IntStream »
                            </button>
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="Stream">
                        <th>interface Stream&lt;T&gt; extends BaseStream&lt;T, Stream&lt;T&gt;&gt; Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            <b>1. static interface Stream.Builder&lt;T&gt; Since 1.8</b>
                            <br>void accept(T t)
                            <br>default Stream.Builder&lt;T&gt; add(T t)
                            <br>Stream&lt;T&gt; build()
                            <br>
                            <br>2. IntStream flatMapToInt(Function&lt;? super T, ? extends IntStream&gt; mapper ) + long, double
                            <br>&lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator)
                            <br>» generator는 배열 크기를 먹고 배열을 뱉는 함수. 예: Person[]::new
                            <br>
                            <br>&lt;U&gt; U reduce(U identity, BiFunction&lt;U, ? super T, U&gt; accumulator, BinaryOperator&lt;U&gt;
                            combiner)
                            <br>» 아래와 같다.
                            <br>var result = identity;
                            <br>for(T element : this stream)
                            <br>&nbsp;&nbsp;&nbsp;&nbsp;result = accumulator.apply(result, element);
                            <br>return result;
                            <br>
                            <br>&lt;R&gt; R collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R, ? super T&gt; accumulator, BiConsumer&lt;R,
                            R&gt; combiner)
                            <br>» 아래와 같다
                            <br>var result = supplier.get();
                            <br>for(T element : this stream)
                            <br>&nbsp;&nbsp;&nbsp;&nbsp;accumulator.accept(result, element);
                            <br>return result;
                            <br>
                            <br>&lt;R, A&gt; collect(Collector&lt;? super T, A, R&gt; collector)
                            <br>Optional&lt;T&gt; min(Comparator&lt;? super T&gt; comparator) + max
                            <br>
                            <br>3. static &lt;T&gt; Stream&lt;T&gt; ofNullable(T t)
                            <br>@SafeVarargs static &lt;T&gt; Stream&lt;T&gt; of(T... values)
                            <br>
                            <button type="button" onclick="javascript:updateDropupManually($('tr.con-lv-3[con-title=DoubleStream]').attr('id'));" class="btn btn-primary btn-sm">
                                참고 : DoubleStream »
                            </button>
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="StreamSupport">
                        <th></th>
                    </tr>
                    <tr>
                        <td>
                            static &lt;T&gt; Stream&lt;T&gt; stream(Spliterator&lt;T&gt; spliterator, boolean parallel)
                            <br>static &lt;T&gt; Stream&lt;T&gt; stream(Supplier&lt;? extends Spliterator&lt;T&gt;&gt; supplier,
                            int characteristics, boolean parallel)
                            <br>» characteristics = supplier.get().characteristics()
                            <br>static IntStream intStream(Spliterator.OfInt spliterator, boolean parallel) + long, double
                            <br>static IntStream intStream(Supplier&lt;? extends Spliterator.OfInt&gt; supplier, int characteristics,
                            boolean parallel)
                            <br>» characteristics = supplier.get().characteristics()
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="Collector">
                        <th>interface Collector&lt;T, A, R&gt; Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            1. 스트림 결과 수집.
                            <br>» 새로운 결과 컨테이너 생성 : supplier()
                            <br>» 결과 컨테이너에 새 데이터를 축적 : accumulator()
                            <br>» 두 결과 컨테이너를 하나로 합치기 : combiner()
                            <br>» Optional 최종 변환 : finisher()
                            <br>
                            <br>
                            <b>2. static enum Collector.Characteristics</b>
                            <br>» CONCURRENT, IDENTITY_FINISH, UNORDERED
                            <br>
                            <br>3. Supplier&lt;A&gt; supplier()
                            <br>» 결과 컨테이너인 A를 생성하는 함수 반환.
                            <br>BiConsumer&lt;A, T&gt; accumulator()
                            <br>» A의 결과에 T 타입 데이터를 축적하는 함수
                            <br>BinaryOperator&lt;A&gt; combiner()
                            <br>» 두 결과 컨테이너를 받아 하나로 반환하는 함수
                            <br>Function&lt;A, R&gt; finisher()
                            <br>» 결과 컨테이너로부터 최종 결과 R으로 변환하는 함수 반환
                            <br>Set&lt;Collector.Characteristics&gt; characteristics()
                            <br>
                            <br>4. static &lt;T, A, R&gt; Collector&lt;T, A, R&gt; of(Supplier&lt;A&gt; supplier, BiConsumer&lt;A,
                            T&gt; accumulator, BinaryOperator&lt;A&gt; combiner, Function&lt;A, R&gt; finisher, Collector.Characteristics...
                            characteristics) + 1 오버로딩
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="Collectors">
                        <th>final class Collectors Since 1.8</th>
                    </tr>
                    <tr>
                        <td>
                            1. 미리 정의된 Collector들
                            <br>
                            <br>2. static &lt;T, C extends Collection&lt;T&gt;&gt; Collector&lt;T, ?, C&gt; toCollection(Supplier&lt;C&gt;
                            collectionFactory)
                            <br>» collectionFactory로 생성한 Collection 객체에 원소들을 만나는 순서대로 집어넣는 Collector 반환.
                            <br>
                            <br>static &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList()
                            <br>» 새로운 List 객체에 입력 원소들을 모두 담아 반환하는 Collector. 반환된 List의 타입, 변경 가능 여부, 직렬화, 쓰레드-안전 그 무엇도
                            보장하지 않음.
                            <br>
                            <br>static &lt;T&gt; Collector&lt;T, ? Set&lt;T&gt;&gt; toSet()
                            <br>» 새로운 Set 객체에 입력 원소들을 모두 담아 반환하는 Collector. 반환된 Set의 타입, 변경 가능 여부, 직렬화, 쓰레드-안전 그 무엇도 보장하지
                            않음.
                            <br>
                            <br>static &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toUnmodifiableList() Since 10
                            <br>static &lt;T&gt; Collector&lt;T, ?, Set&lt;T&gt;&gt; toUnmodifiableSet() Since 10
                            <br>
                            <br>static Collector&lt;CharSequence, ?, String&gt; joining() + 2 오버로딩
                            <br>» String에 만나는 순서대로 덧붙이는 Collector.
                            <br>
                            <br>static &lt;T, U, A, R&gt; Collector&lt;T, ?, R&gt; mapping(Function&lt;? super T, ? extends U&gt;
                            mapper, Collector&lt;? super U, A, R&gt; downstream)
                            <br>» U 타입 원소에 대한 Collector에 T 타입 원소를 mapper를 통해 U 타입으로 변환하여 받아들이는 Collector.
                            <br>
                            <br>static &lt;T, U, A, R&gt; Collector&lt;T, ?, R&gt; flatMapping(Function&lt;? super T, ? extends
                            Stream&lt;? extends U&gt;&gt; mapper, Collector&lt;? super U, A, R&gt; downstream) Since 9
                            <br>» Flat mapper는 입력 요소를 0개 이상의 요소를 담은 stream으로 만들어내며, downstream에 투입되면 해당 stream은 닫힌다.(null인
                            경우 빈 스트림을 대신 이용한다)
                            <br>
                            <br>static &lt;T, A, R&gt; Collector&lt;T, ?, R&gt; filtering(Predicate&lt;? super T&gt; predicate,
                            Collector&lt;? super T, A, R&gt; downstream) Since 9
                            <br>» 동일한 입력 타입 T 원소를 받아 predicate을 만족하면 downstream에 투입하는 Collector.
                            <br>
                            <br>static &lt;T, A, R, RR&gt; Collector&lt;T, A, RR&gt; collectingAndThen(Collector&lt;T, A, R&gt;
                            downstream, Function&lt;R, RR&gt; finisher)
                            <br>
                            <br>static &lt;T&gt; Collector&lt;T, ?, Long&gt; counting()
                            <br>static &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt; minBy(Comparator&lt;? super T&gt; comparator)
                            <br>static &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt; maxBy(Comparator&lt;? super T&gt; comparator)
                            <br>static &lt;T&gt; Collector&lt;T, ?, Integer&gt; summingInt(ToIntFunction&lt;? super T&gt; mapper)
                            + Long, Double
                            <br>static &lt;T&gt; Collector&lt;T, ?, Double&gt; averagingInt(ToIntFunction&lt;? super T&gt; mapper)
                            + Long, Double
                            <br>static &lt;T&gt; Collector&lt;T, ?, IntSummaryStatistics&gt; summarizingInt(ToIntFunction&lt;?
                            super T&gt; mapper) + Long, Double
                            <br>
                            <br>static &lt;T&gt; Collector&lt;T, ? T&gt; reducing(T identity, BInaryOperator&lt;T&gt; op) + 2
                            오버로딩
                            <br>» reducing 설명은
                            <button type="button" onclick="javascript:updateDropupManually($('tr.con-lv-3[con-title=DoubleStream]').attr('id'));" class="btn btn-primary btn-sm">
                                DoubleStream
                            </button> 참고
                            <br>
                            <br>static &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt; groupingBy(Function&lt;?
                            super T, ? extends K&gt; classifier) + 2 오버로딩
                            <br>static &lt;T, K&gt; Collector&lt;T, ?, ConcurrentMap&lt;K, List&lt;T&gt;&gt;&gt; groupingByConcurrent(Function&lt;?
                            super T, ? extends K&gt; classifier) + 2 오버로딩
                            <br>static &lt;T&gt; Collector&lt;T, ?, Map&lt;Boolean, List&lt;T&gt;&gt;&gt; partitioningBy(Predicate&lt;?
                            super T&gt; predicate) + 1 오버로딩
                            <br>static &lt;T, K, U&gt; Collector&lt;T, ?, Map&lt;K, U&gt;&gt; toMap(Function&lt;? super T, ?
                            extends K&gt; keyMapper, Function&lt;? super T, ? extends U&gt; valueMapper) + 2 오버로딩
                            <br>static &lt;T, K, U&gt; Collector&lt;T, ?, Map&lt;K, U&gt;&gt; toUnmodifiableMap(Function&lt;?
                            super T, ? extends K&gt; keyMapper, Function&lt;? super T, ? extends U&gt; valueMapper) Since
                            10 + 1 오버로딩
                            <br>static &lt;T, K, U&gt; Collector&lt;T, ?, ConcurrentMap&lt;K, U&gt;&gt; toConcurrentMap(Function&lt;?
                            super T, ? extends K&gt; keyMapper, Function&lt;? super T, ? extends U&gt; valueMapper) + 2 오버로딩
                        </td>
                    </tr>
                </tbody>
                <tbody class="con-lv-2" con-title="java.util.zip">
                    <tr style="background-color: #bbb;">
                        <th>java.base(module) Since 9 » java.util.zip(package) Since 1.1</th>
                    </tr>
                    <tr class="con-lv-3" con-title="Checksum">
                        <th>interface Checksum Since 1.1</th>
                    </tr>
                    <tr>
                        <td>
                            void update(int b)
                            <br>default void update(byte[] b) Since 9
                            <br>void update(byte[] b, int off, int len)
                            <br>default void update(ByteBuffer buffer) Since 9
                            <br>long getValue()
                            <br>void reset()
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="Adler32">
                        <th>class Adler32 implements Checksum Since 1.1</th>
                    </tr>
                    <tr>
                        <td>
                            1. 생성자 : public Adler32()
                            <br>
                            <br>2. void update(ByteBuffer buffer) Since 1.8
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="CRC32">
                        <th>clas CRC32 implements Checksum Since 1.1</th>
                    </tr>
                    <tr>
                        <td>
                            1. 생성자 : public CRC32()
                            <br>
                            <br>2. void update(ByteBuffer buffer) Since 1.8
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="CRC32C">
                        <th>class CRC32C implements Checksum Since 9</th>
                    </tr>
                    <tr>
                        <td>
                            1. 생성자 : public CRC32C()
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="ZipInputStream">
                        <th>class ZipInputStream extends InflaterInputStream Since 1.1</th>
                    </tr>
                    <tr>
                        <td>
                            1. 생성자
                            <br>public ZipInputStream(InputStream in)
                            <br>public ZipInputStream(InputStream in, Charset charset) Since 1.7
                            <br>
                            <br>2. ZipEntry getNextEntry()
                            <br>void closeEntry()
                            <br>» 현재 ZipEntry를 닫고 읽기 위치를 다음 entry로 이동.
                            <br>int available()
                            <br>» EOF를 만났으면 0, 아니면 1
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="ZipOutputStream">
                        <th>class ZipOutputStream extends DeflaterOutputStream Since 1.1</th>
                    </tr>
                    <tr>
                        <td>
                            1. 생성자
                            <br>public ZipOutputStream(OutputStream out)
                            <br>public ZipOutputStream(OutputStream out, Charset charset) Since 1.7
                            <br>
                            <br>2. void setComment(String comment)
                            <br>void setMethod(int method)
                            <br>» ZipEntry에 설정되지 않은 경우 사용하는 압축 방법 : DEFLATED(압축, 기본값), STORED(비압축)
                            <br>
                            <br>void setLevel(int level)
                            <br>» 압축 레벨 : 0(BEST_SPEED) ~ 9(BEST_COMPRESSION). 기본은 DEFAULT_COMPRESSION(-1)이며, 보통 6.
                            <br>
                            <br>void putNextEntry(ZipEntry e)
                            <br>void closeEntry()
                            <br>» 현재 ZipEntry를 닫고 다음 쓰기 위치로 이동. putNextEntry 메서드는 쓰기 전에 알아서 닫는다.
                            <br>
                            <br>void finish()
                            <br>» 쓰기를 종료하고 스트림을 닫는다. 동일한 출력 스트림에 여러 필터를 적용한 경우에 사용.
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="ZipEntry">
                        <th>class ZipEntry implements Cloneable Since 1.1</th>
                    </tr>
                    <tr>
                        <td>
                            1. 생성자
                            <br>public ZipEntry(String name)
                            <br>public ZipEntry(ZipEntry e) : e로 필드를 채운다.
                            <br>
                            <br>2. String getName()
                            <br>void setTime(long time) + getter
                            <br>void setTimeLocal(LocalDateTime time) Since 9 + getter
                            <br>ZipEntry setLastModifiedTime(FileTime time) Since 1.8 + getter
                            <br>ZipEntry setLastAccessTime(FileTime time) Since 1.8 + getter
                            <br>ZipEntry setCreationTime(FileTime time) Since 1.8 + getter
                            <br>void setSize(long size) : 비압축 크기 설정 + getter
                            <br>void setCompressedSize(long csize) + getter
                            <br>void setCrc(long crc) + getter
                            <br>void setMethod(int method) + getter
                            <br>» DEFLATED(압축), STORED(비압축), -1(미설정)
                            <br>
                            <br>void setExtra(byte[] extra) + getter
                            <br>void setComment(String comment) + getter
                            <br>boolean isDirectory()
                            <br>» 이름이 "/"로 끝나면 디렉터리.
                            <br>
                            <br>String toString()
                            <br>int hashCode()
                            <br>Object clone()
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="ZipFile">
                        <th>class ZipFile implements Closeable Since 1.1</th>
                    </tr>
                    <tr>
                        <td>
                            1. 생성자
                            <br>public ZipFile(String name) : UTF-8
                            <br>public ZipFile(File file, int mode) Since 1.3 : UTF-8
                            <br>» mode : OPEN_READ | OPEN_DELETE(파일이 close 호출 전까지 삭제됨, 내용은 객체를 통해 계속 접근 가능)
                            <br>
                            <br>public ZipFile(File file) : UTF-8
                            <br>public ZipFile(File file, int mode, Charset charset) SInce 1.7
                            <br>public ZipFile(String name, Charset charset) Since 1.7
                            <br>public ZipFile(File file, Charset charset) Since 1.7
                            <br>
                            <br>2. String getComment() Since 1.7
                            <br>ZipEntry getEntry(String name)
                            <br>InputStream getInputStream(ZipEntry entry)
                            <br>» ZipFile이 닫히면 이 메서드가 반환한 모든 스트림도 같이 닫힌다.
                            <br>
                            <br>String getName()
                            <br>Enumeration&lt;? extends ZipEntry&gt; entries()
                            <br>Stream&lt;? extends ZipEntry&gt; stream() Since 1.8
                            <br>int size() : entry 개수
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>

        <div class="container table-responsive con-lv-1" con-title="JavaFX">
            <h2>JavaFX</h2>
            <table class="table table-hover">
                <tbody class="con-lv-2" con-title="JavaFX 기초">
                    <tr>
                        <th>JavaFX 기초</th>
                    </tr>
                    <tr class="con-lv-3" con-title="JavaFX란?">
                        <th>JavaFX란?</th>
                    </tr>
                    <tr>
                        <td>
                            1. Swing을 대체해 RIP(Rich Internet Application)을 개발하기 위한 GUI 라이브러리
                            <br>
                            <br>2. 프로그램 구조
                            <br>» javafx.application.Application을 상속
                            <br>» main 메서드에서 launch 메서드 호출 → init() → start() : UI 구성 → stop()
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="노드">
                        <th>노드</th>
                    </tr>
                    <tr>
                        <td>
                            1. JavaFX UI는 노드의 계층적인 구성으로 이루어진다.
                            <br>» 컨테이너 노드 : 다른 노드를 내부에 포함. Stage, Scene, Pane...
                            <br>» 기본 노드 : Button, Label, Checkbox...
                            <br>1.1 Layout Manager : BorderPane, FlowPane, StackPane, HBox, VBox...
                            <br>
                            <br>2. Stage는 윈도우 창으로, 하나의 Scene을 보여준다. 하나의 Scene은 하나 이상의 Pane으로 구성된다.
                            <br>2.1 Modal : 해당 윈도우가 종료될 때까지 부모 윈도우와 상호작용 불가. ↔ modaless
                            <br>
                            <br>3. 그리기 : javafx.scene.shape
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="이벤트">
                        <th>이벤트</th>
                    </tr>
                    <tr>
                        <td>
                            1. Event ← ActionEvent, InputEvent, WindowEvent
                            <br>InputEvent ← KeyEvent, MouseEvent, GestureEvent, DragEvent, TouchEvent
                        </td>
                    </tr>
                    <tr class="con-lv-3" con-title="메뉴">
                        <th>메뉴</th>
                    </tr>
                    <tr>
                        <td>
                            1. javafx.scene.control.MenuBar, Menu, MenuItem, SeperatorMenuItem, CheckMenuItem, RadioMenuItem
                            <br>» 메뉴에 하위 메뉴 포함 가능
                            <button type="button" onclick="javascript:showCode('JavaLang/src/Syntax.java', 'java');" class="btn btn-primary btn-sm">
                                View Code : 예제 »
                            </button>
                            <button type="button" onclick='javascript:showCode("JavaLang/console/con4.txt", "text");' class="btn btn-primary btn-sm">
                                View Console : 콘솔 »
                            </button>
                            <button type="button" onclick="javascript:updateDropupManually($('tr.con-lv-3[con-title=Externalizable]').attr('id'));" class="btn btn-primary btn-sm">
                                Goto Externalizable »
                            </button>
                            <a role="button" class="btn btn-info btn-sm" href=""></a>
                        </td>
                    </tr>

                </tbody>
            </table>
        </div>
    </main>

    <hr>

    <footer id="main-footer" class="container"></footer>
</body>

</html>