html
  body
    script(src='/source/redirect.js?200226_1657')
    hr
    details
      summary 진리값 판별
      |     
      ul
        li 모든 객체는 if 조건, while 조건, Boolean 연산에 이용하기 위한 진리값 판별이 가능하다.
        |         기본적으로 __bool__() 메서드가 false를 반환하거나 __len__() 메서드가 0을 반환하지 않는 객체는 참이다.
    hr
    details
      summary 논리 연산
      |     and(short-circuit), or(short-circuit), not
    hr
    details
      summary 비교 연산
      |     
      ol
        li <, <=, >, >=, ==, !=, is(object identity), is not
        |         
        li 연속적인 비교가 가능하다.
        |         x < y <= z는 y가 한번만 계산된다는 것만 빼곤 x < y and y <= z와 동일하다.
        |         
        li __eq__() 메서드를 정의하지 않는 이상 인스턴스들은 보통 같지 않다고 판별된다
        |         
        li
          | __lt__(), __le__(), __gt__(), __ge__() 등을 충분히 정의하지 않으면 정렬이 불가능하다. 보통 __lt__()와 __eq__()로 충분하다.
    hr
    details
      summary 숫자 타입
      |     
      ul
        li int, float, complex
        |         
        ul
          li int 정밀도는 제한이 없다.
          |             
          li 정밀도 등 float에 관한 정보는 sys.float_info를 통해 확인할 수 있다.
          |             
          li complex의 실수부(z.real) 허수부(z.imag)는 각각 float이다.
        |         
        li
          | fractions.Fraction # 유리수
          br
          |             decimal.Decimal # 사용자 정의 정밀도 부동소수
        |         
        li 산술 연산
        |         x + y, x - y, x * y, x / y, x // y, x % y, -x, +x, abs(x), int(x), float(x), complex(re, im), c.conjugate() 켤레복소수, divmod(x, y), pow(x, y), x ** y
        |         
        li 비트 연산
        |         x | y, x ^ y, x & y, x << n, x >> n, ~x
        |         
        li int(numbers.Integral 구현체) 확장 연산
        |         
        ul
          li int.bit_length() Since 3.1 : 비트 길이
          |             
          li
            | int.to_bytes(length, byteorder, *, signed=False) Since 3.2 # byteorder : "big" | "little" | sys.byteorder
          |             
          li
            | classmethod int.from_bytes(bytes, byteorder, *, signed=False) Since 3.2
            | # bytes는 
            a.w3-btn.w3-round.w3-round-xxlarge.w3-small.w3-green(target='_blank', href='https://docs.python.org/3/glossary.html#term-bytes-like-object') bytes-like object
            | 거나 byte iterable이어야 한다
          |             
          li int.as_integer_ratio() Since 3.8 # float과의 호환성을 위해 추가되었다. 분모는 1로 고정
        |         
        li float(numbers.Real 구현체) 확장 연산
        |         
        ul
          li float.as_integer_ratio() # (분자, 분모) 튜플을 반환한다. 분모는 양수.
          |             
          li float.is_integer()
          |             
          li float.hex() # 0x로 시작하고 p로 끝난뒤 지수가 붙는다. 지수의 base는 2
          |             
          li
            | classmethod float.fromhex(s) # C의 %a 포맷과 Java의 Double.toHexString()의 결과를 받아들일 수 있다.
        |         
        li Hashing : 해시값은 modulo P 안에서 선택된다. P는 고정된 소수로, sys.hash_info에서 확인 가능
    hr
    details
      summary Iterator Types
      |     
      ol
        li container.__iter__()
        |         container가 iteration을 지원하려면 정의해야 한다. 반환하는 객체는 iterator protocol(아래의 2개 특별 메서드)을 지원해야 된다.
        |         
        li iterator.__iter__()
        |         iterator 자기 자신을 반환하면 된다
        |         
        li iterator.__next__()
        |         다음 요소 반환. 없으면 StopIteration 발생.
        |         
        li Generator Types
        |         generator는 iterator protocol을 쉽게 제공한다. container의 __iter__()가 generator로 정의된 경우, 자동으로 __iter__()와 __next__()를 지원하는 iterator 객체를 반환한다.
        |         
        button.btn-code(path='Repositories/Python/Basic/syntax.py', displayrange='[143,150]', lan='python') 예시 1 »
        |         
        button.btn-code(path='Repositories/Python/Basic/syntax.py', displayrange='[70,76]', lan='python') 예시 2»
    hr
    details
      summary Sequence Types
      |     
      ul
        li list, tuple, range # 3가지 기본 시퀀스 타입
        |         
        li Common Sequence Operations
        |         
        ul
          li collections.abc.Sequence는 사용자 정의 sequence 타입의 연산 정의를 도와준다.
          |             
          li
            | x in s, x not in s, s[i], s[i:j], s[i:j:k], len(s), min(s), max(s), s.count(x)
            br
            |                 s + t # 접합, s * n 또는 n * s # 셀프 접합
            br
            |                 s.index(x[, i[, j]]) # s[i:j]중 처음 등장하는 x의 위치
          |             
          li str, bytes, bytearray도 subsequence 검사에 in을 이용할 수 있다.
          |             
          li s * n은 s를 n번 복제하는 것이 아니라 s를 n번 접근하는 것이다. 복제하려면 list comprehension 이용
          |             
          li index가 음수일 경우 len(s) + i가 대신 쓰인다. 단, -0 == 0
          |             
          li 불변 sequence들의 접합은 항상 새로운 객체를 생성하며, 시간 비용은 n^2
          |             
          ul
            | ↓ 보다 빠른 접합
            li str : str.join() 이용 | io.StringIO 객체에 쓰기
            |                 
            li bytes : bytes.join() 이용 | io.BytesIO 객체에 쓰기 | bytearray 이용
            |                 
            li tuple : list를 대신 이용
        |         
        li Immutable Sequence Types : hash()를 지원할 수 있다
        |         
        li Mutable Sequence Types
        |         
        ul
          li collections.abc.MutableSequence는 사용자 정의 sequence 타입의 연산 정의를 도와준다.
          |             
          li
            | s[i] = x, x[i:j] = t, del s[i:j], del s[i:j:k], s.append(x), s.clear(), s.copy(), s.extend(t) or s += t, s *= n, s.insert(i, x), s.pop([i]), s.remove(x), s.reverse()
            br
          |             슬라이스에 대한 할당(s[i:j:k] = t)은 길이가 일치해야 한다
    hr
    details
      summary Text Sequence Type
      |     
      ul
        li str 객체 또는 유니코드 시퀀스 strings로 표현하며, 모두 내용은 변경 불가능하다.
        |         
        li
          | str.capitalize() # 첫 번째 글자는 titlecase, 나머지는 lowercase로
          br
          |             str.casefold() # lower()보다 강한 변환
          br
          |             str.upper(), str.lower(), str.title()
          br
          |             str.swapcase() # 두 번 적용한 것이 원본과 항상 같지는 않다
        |         
        li
          | str.center(width[, fillchar])
          br
          |             str.ljust(width[, fillchar])
          br
          |             str.rjust(width[, fillchar])
        |         
        li
          | str.count(sub[, start[, end]])
          br
          |             str.find(sub[, start[, end]]), str.rfind(sub[, start[, end]]) # 첫 등장 위치. 없으면 -1. 단순 포함 여부는 in 연산자
          br
          |             str.index(sub[, start[, end]]), str.rindex(sub[, start[, end]]) # find와 같으나 없으면 ValueError
        |         
        li
          | str.endswith(suffix[, start[, end]])
          br
          |             str.startswith(prefix[, start[, end]])
          br
          |             # suffix, prefix에 튜플도 가능
        |         
        li str.encode(encoding="utf-8", errors="strict")
        |         
        li str.expandtabs(tabsize=8)
        |         오피스 문서와 같은 탭 작업. 문자열 끝에 탭이 존재하면 결과적으로 반환된 문자열은 tabsize의 배수 길이가 된다.
        |         
        li
          | str.format(*args, **kwargs)
          br
          |             str.format_map(mapping) # str.format(**mapping)과 유사
          |             
          button.btn-code(path='Repositories/Python/Basic/format_map_example.py', lan='python') 예시 »
        |         
        li
          | str.isalnum(), str.isalpha(), str.islower(), str.isupper(), str.istitle(), str.isprintable(), str.isspace(), str.isidentifier()
          br
          |             str.isdecimal() # [0-9]만, str.isdigit(), str.isnumeric() # digit보다 광범위
        |         
        li str.join(iterable) # iterable 문자열들을 str로 접합
        |         
        li
          | str.strip([chars])
          br
          |             str.lstrip([chars])
          br
          |             str.rstrip([chars])
        |         연속한 chars에 속하는 문자들을 제거한다. 인자가 없는 경우 연속적인 공백을 제거한다.
        |         
        li static str.maketrans(x[, y[, z]])
        |         str.translate()에 쓰일 번역 테이블을 생성한다. 인자가 하나 주어진 경우 아래 서술한 table이어야 하고, 2개 주어진 경우 같은 길이의 문자열이어야 한다. 3개 주어진 경우 마지막 문자열의 각 문자들은 None에 매핑된다.
        |         
        li str.translate(table)
        |         table의 key는 유니코드 정수여야 하고, 대응하는 value는 유니코드 정수값이나 문자열이 가능하다.
        |         
        button.btn-code(path='Repositories/Python/Basic/translate_example.py', lan='python') 예시 »
        |         
        li
          | str.partition(sep)
          br
          |             str.rpartition(sep)
        |         처음 만나는 sep을 기준으로 분리하여, (앞부분, sep, 뒷부분)을 반환. sep이 없을 경우 (sep, '', '')반환.
        |         
        li
          | str.split(sep=None, maxsplit=-1)
          br
          |             str.rsplit(sep=None, maxsplit=-1)
        |         sep으로 분리한 부분 문자열 리스트 반환. sep이 주어지지 않은 경우 공백문자로 분리하며, 연속적인 공백문자도 하나의 공백으로 처리하고 결과에 빈 문자열은 포함하지 않는다.
        |         
        li str.splitlines([keepends]) # keepends=True면 줄바꿈 문자를 결과에 포함한다.
        |         
        li str.replace(old, new[, count])
        |         
        li str.zfill(width) # '0'을 문자열 앞에 붙인다. 처음 등장하는 '+', '-'는 위치 유지.
    hr
    details
      summary Binary Sequence Types
      |     
      ul
        li bytes, bytearray, memoryview
        |         핵심 자료형은 bytes, bytearray며, memoryview는 다른 이진 객체를 복사하지 않고 buffer protocol을 통해 접근한다.
        |         
        li class bytes([source[, encoding[, errors]]]) # 변경불가
        |         
        ul
          li b'hello'처럼 b로 시작하는 문자열은 bytes 리터럴이다. 단, ASCII 문자만 가능.
          |             
          li
            | 문자열과 달리 bytes 객체 b의 b[0]는 정수, b[0:1]는 길이 1의 bytes 객체다. 각 바이트 숫자를 확인하는 데는 list(b)가 유용
          |             
          li 0으로 초기화 → bytes(size)
          |             
          li 정수 iterable로부터 생성 → bytes(iterable)
          |             
          li 기존 이진 객체(buffer protocol)로부터 생성 → bytes(obj)
          |             
          li classmethod fromhex(string) ↔ hex() Since 3.5
          |             16진수 표기 문자열로부터 생성. string은 반드시 1바이트당 2개 16진수를 포함해야하고, 공백(' ')은 무시된다.
        |         
        li class bytearray([source[, encoding[, errors]]]) # 가변
        |         
        ul
          li 빈 bytearray 객체 → bytearray()
          |             
          li 0으로 초기화 → bytearray(size)
          |             
          li 정수 iterable로부터 생성 → bytearray(iterable)
          |             
          li 기존 이진 객체(buffer protocol)로부터 생성 → bytearray(buf)
          |             
          li classmethod fromhex(string) ↔ hex() Since 3.5 # bytes와 비슷
        |         
        li bytes and bytearray Operations
        |         
        ul
          li
            | count(sub[, start[, end]])
            br
            |                 find(sub[, start[, end]]), rfind(sub[, start[, end]]) # 첫 등장 위치. 없으면 -1. 단순 포함 여부는 in 연산자
            br
            |                 index(sub[, start[, end]]), rindex(sub[, start[, end]]) # find와 같지만 없으면 ValueError
          |             sub는 
          a.w3-btn.w3-round.w3-round-xxlarge.w3-small.w3-green(target='_blank', href='https://docs.python.org/3/glossary.html#term-bytes-like-object') bytes-like object
          |  거나 [0, 255] 사이의 정수(Since 3.3)여야 한다.
          |             
          li decode(encoding="utf-8", errors="strict")
          |             
          li
            | endswith(suffix[, start[, end]])
            br
            |                 startswith(prefix[, start[, end]])
            br
            |                 # suffix, prefix에 튜플도 가능
          |             
          li join(iterable)
          |             
          li static maketrans(from, to) Since 3.1
          |             from, to는 같은 길이의 
          a.w3-btn.w3-round.w3-round-xxlarge.w3-small.w3-green(target='_blank', href='https://docs.python.org/3/glossary.html#term-bytes-like-object') bytes-like object
          | 여야 한다. translate()에 이용할 테이블을 생성한다.
          |             
          li translate(table, delete=b'')
          |             포함하는 delete 안의 바이트들을 모두 제거한 뒤 table에 따라 변환한다. table은 길이 256의 bytes 객체여야 한다.
          |             
          li
            | partition(sep)
            br
            |                 rpartition(sep)
          |             sep으로 구분하여 (before, sep, after)를 반환. 없으면 (sep, b'', b'') 또는 (sep, bytearray(b''), bytearray(b'')) 반환
          |             
          li
            | center(width[, fillbyte])
            br
            |                 ljust(width[, fillbyte])
            br
            |                 rjust(width[, fillbyte])
          |             
          li
            | strip([chars])
            br
            |                 lstrip([chars])
            br
            |                 rstrip([chars])
          |             연속하여 chars에 속하는 문자들을 제거한다. 인자가 없는 경우 연속적인 공백을 제거한다.
          |             
          li
            | split(sep=None, maxsplit=-1)
            br
            |                 lsplit(sep=None, maxsplit=-1)
            br
            |                 rsplit(sep=None, maxsplit=-1)
          |             sep으로 분리한 부분 이진 문자열 리스트 반환. sep이 주어지지 않은 경우 공백문자로 분리하며, 연속적인 공백문자도 하나의 공백으로 처리하고 결과에 빈 이진 문자열은 포함하지 않는다
          |             
          li expandtabs(tabsize=8)
          |             오피스 문서와 같은 탭 작업. 문자열 끝에 탭이 존재하면 결과적으로 반환된 문자열은 tabsize의 배수 길이가 된다.
          |             
          li splitlines(keepends=False)
          |             줄 바꿈 문자를 기준으로 나누며, 결과에 줄 바꿈 문자를 포함할지는 keepends로 결정한다.
          |             
          li capitalize(), lower(), swapcase(), title(), upper()
          |             
          li isalnum(), isalpha(), isdigit(), islower(), isspace(), istitle(), isupper()
          |             
          li zfill(width)
          |             width가 될 때까지 b'0'을 앞에 채운다. 맨 처음 등장하는 b'+', b'-'는 위치를 유지한다.
        |         
        li class memoryview(obj)
        |         
        ul
          li obj가 수정 가능할 경우, 1차원 slice 할당이 가능하다. 단, 크기 변경은 불가능하다.
          |             
          li Since 3.3 → 1차원 memoryview는 slicing 가능
          |             
          li Since 3.4 → memoryview는 자동으로 collections.abc.Sequence
          |             
          li Since 3.5 → 정수 tuple로 indexing 가능
          |             
          li __eq__(exporter) # struct 모듈이 지원하지 않는 객체와의 비교는 False
          |             
          li tobytes(order=None) # bytes 생성자 호출과 같은 결과
          |             Snice 3.8 → order는 'C'(default, C 순서), 'F'(Fortran 순서), 'A'(메모리 복사) 중 하나
          |             
          button.btn-code(path='Repositories/Python/Basic/tobytes_example.py', lan='python') 예 »
          |             
          li hex() Since 3.5 # 16진수 문자열 반환
          |             
          li tolist() # 버퍼 데이터를 리스트로 반환
          |             
          li toreadonly() Since 3.8
          |             
          li release() Since 3.2 # buffer 해제. 이후 다른 연산은 ValueError
          |             
          li cast(format[, shape]) Since 3.3
          |             
          ul
            li
              | format은 struct syntax로 지정하며, 가능한 포맷은 'B'(unsigned char), 'b'(signed char), 'c'(char)
            |                 
            li
              | shape 기본값은 [byte_length//new_itemsize], 같은 buffer를 참조하는 새 memoryview 객체를 반환한다.
              button.btn-code(path='Repositories/Python/Basic/cast_example.py', lan='python') 예 »
          |             
          li obj Since 3.3 # memoryview의 기저 객체
          |             
          li readonly # 객체가 readonly인지 여부
          |             
          li format # struct 모듈 스타일의 format string
          |             
          li
            | nbytes Since 3.3 # 바이트 크기
            br
            |                 itemsize # 요소 하나의 바이트 크기
            br
            |                 ndim # 몇 차원 배열인지
            br
            |                 shape # 크기가 ndim인 튜플로 표현되는 배열 모양
            br
            |                 strides # 크기가 ndim인 튜플로 표현되는 각 차원 원소의 바이트 크기
          |             
          li
            | c_contiguous Since 3.3 # 메모리가 C-contiguous인지
            br
            |                 f_contiguous Since 3.3 # 메모리가 Fortran contiguous인지
            br
            |                 contiguous Since 3.3 # 메모리가 contiguous인지
    hr
    details
      summary Set Types
      |     
      ul
        li
          | class set([iterable])
          br
          |             class frozenset([iterable])
        |         
        li 해시 가능한 순서 없는 collection. frozenset은 불변이며, 다른 set의 원소가 될 수 있다.
        |         
        li 연산자 버전이 있는 메서드들은 인자로 iterable도 받을 수 있다.
        |         
        li set과 frozenset 두 가지에 대한 연산 결과는 첫번째 피연산자의 타입이다.
        |         
        li len(s), x in s, x not in s, for x in set
        |         
        li isdisjoint(other) # 교집합이 공집합인지 여부
        |         
        li issubset(other) # 연산자 <=, <로도 가능
        |         
        li issuperset(other) # 연산자 >=, >로도 가능
        |         
        li union(*others) # 연산자 |로도 가능
        |         
        li intersection(*others) # 연산자 &로도 가능
        |         
        li difference(*others) # 연산자 -로도 가능
        |         
        li symmetric_difference(other) # 연산자 ^로도 가능
        |         
        li update(*others) # others의 모든 원소 추가. set |= other | ...
        |         
        li intersection_update(*others) # 모든 집합에 속하는 공통 원소들만 보존. set &= other & ...
        |         
        li difference_update(*others) # 호출자에 속하는 원소들만 보존. set -= other | ...
        |         
        li symmetric_difference_update(other) # set ^= other
        |         
        li
          | copy(), add(elem), clear()
          br
          |             remove(elem) # 없으면 KeyError
          br
          |             discard(elem) : 포함하면 삭제
          br
          |             pop() # 임의 원소 삭제
        |         elem은 set일 수 있다.
    hr
    details
      summary Mapping Types
      |     
      ul
        li
          | class dict(**kwarg)
          br
          |             class dict(mapping, **kwarg)
          br
          |             class dict(iterable, **kwarg)
        |         mapping 객체는 해시 가능한 값을 임의 객체로 매핑한다.
        pre.
          \na = dict(one=1, two=2, three=3)
          b = {'one': 1, 'two': 2, 'three': 3}
          c = dict(zip(['one', 'two', 'three'], [1, 2, 3]))
          d = dict([('two', 2), ('one', 1), ('three', 3)])
          e = dict({'three': 3, 'one': 1, 'two': 2})
          a == b == c == d == e          
        |         
        li Dictionary Operations
        |         
        ul
          li
            | len(d), d[key], d[key] = value, del d[key], key in d, key not in d, iter(d), copy(), clear(), list(d) # 키 리스트 반환
          |             
          li classmethod fromkeys(seq[, value]) # seq를 키로 하는 dict 반환. value의 기본값은 None
          |             
          li get(key[, default]) # key가 없으면 default 반환
          |             
          li
            | items() # (key, value)쌍에 대한 view 반환
            br
            |                 keys() # key에 대한 view 반환
            br
            |                 values() # value에 대한 view 반환
          |             
          li
            | pop(key[, default])
            br
            |                 popitem() # 임의 키-값 쌍 제거
          |             
          li
            | setdefault(key[, default]) # key가 있으면 value 반환, 없으면 default로 추가하고 defualt 반환. 둘 다 없으면 KeyError
          |             
          li update([other]) # other에는 dict 생성 인자들 모두 허용된다.
          |             
          li Since 3.8 → dict 순서를 reversed()로 뒤집을 수 있다
        |         
        li Dictionary view objects
        |         
        ul
          li dict.keys(), dict.values(), dict.items()로 반환된 뷰. dict의 변화는 뷰에도 반영된다.
          |             
          li
            | len(dictview)
            br
            |                 iter(dictview) # dict 수정 중엔 RuntimeError 가능
            br
            |                 x in dictview
            br
            |                 reversed(dictview) Since 3.8
    hr
    details
      summary Context Manager Types
      |     
      ul
        li with statement
        |         Context manager가 정의한 runtime context를 지원
        |         
        li contextmanager.__enter__()
        |         반환된 객체는 with문의 as 절의 식별자에 bound된다.
        |         
        li contextmanager.__exit__(exc_type, exc_val, exc_tb)
        |         억제된 예외가 있는지 여부 반환. True면 인자에 예외 타입, 값, traceback 정보가 넘어간다.
    hr
    details
      summary Special Attributes
      |     
      ul
        li
          | object.__dict__
          br
          |             instance.__class__
          br
          |             class.__bases__
          br
          |             definition.__name__
          br
          |             class.subclasses__()
        |         
        li
          | class.__mro__ # method를 찾는 순서
          br
          |             class.mro() # __mro__ 반환. 재정의 가능.
        |         
        li definition.__qualname__ Since 3.3
        |         Qualified name(모듈의 글로벌 스코프부터 호출자까지 '.'으로 구분)
    hr
