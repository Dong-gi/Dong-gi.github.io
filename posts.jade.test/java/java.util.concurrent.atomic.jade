html
  body
    script(src='/source/redirect.js?200226_1657')
    hr
    details(open='')
      summary Package Summary
      |     
      ol
        li 변수 하나에 대한 잠금 없는 스레드-안전성을 제공한다
        |         
        li VarHandle을 통해 변수를 원자적으로 접근한다
        |         
        li AtomicBoolean, AtomicInteger 등은 일반적인 Boolean, Integer 등을 대신할 수 없다
        |         
        li 메모리 장벽을 만나면 CPU 코어의 캐시값이 RAM으로 반영된다
    hr
    details
      summary abstract class VarHandle implements Constable Since 9
      |     
      ol
        li java.lang.invoke 패키지 멤버임
        |         
        li
          | 하나의 변수, 매개변수, 필드 등에 대한 동적인 타입 참조. plain 읽기/쓰기, volatile 읽기/쓰기, compare-and-set 접근을 지원한다
      |     
      details
        summary static enum VarHandle.AccessMode
        |         
        table
          tbody
            tr
              th GET
              td VarHandle.get
            |                 
            tr
              th SET
              td VarHandle.set
            |                 
            tr
              th GET_VOLATILE
              td VarHandle.getVolatile
            |                 
            tr
              th SET_VOLATILE
              td VarHandle.setVolatile
            |                 
            tr
              th GET_ACQUIRE
              td VarHandle.getAcquire
            |                 
            tr
              th SET_RELEASE
              td VarHandle.setRelease
            |                 
            tr
              th GET_OPAQUE
              td VarHandle.getOpaque
            |                 
            tr
              th SET_OPAQUE
              td VarHandle.setOpaque
            |                 
            tr
              th COMPARE_AND_SET
              td VarHandle.compareAndSet
            |                 
            tr
              th COMPARE_AND_EXCHANGE
              td VarHandle.compareAndExchange
            |                 
            tr
              th COMPARE_AND_EXCHANGE_ACQUIRE
              td VarHandle.compareAndExchangeAcquire
            |                 
            tr
              th COMPARE_AND_EXCHANGE_RELEASE
              td VarHandle.compareAndExchangeRelease
            |                 
            tr
              th WEAK_COMPARE_AND_SET_PLAIN
              td VarHandle.weakCompareAndSetPlain
            |                 
            tr
              th WEAK_COMPARE_AND_SET
              td VarHandle.weakCompareAndSet
            |                 
            tr
              th WEAK_COMPARE_AND_SET_ACQUIRE
              td VarHandle.weakCompareAndSetAcquire
            |                 
            tr
              th WEAK_COMPARE_AND_SET_RELEASE
              td VarHandle.weakCompareAndSetRelease
            |                 
            tr
              th GET_AND_SET
              td VarHandle.getAndSet
            |                 
            tr
              th GET_AND_SET_ACQUIRE
              td VarHandle.getAndSetAcquire
            |                 
            tr
              th GET_AND_SET_RELEASE
              td VarHandle.getAndSetRelease
            |                 
            tr
              th GET_AND_ADD
              td VarHandle.getAndAdd
            |                 
            tr
              th GET_AND_ADD_ACQUIRE
              td VarHandle.getAndAddAcquire
            |                 
            tr
              th GET_AND_ADD_RELEASE
              td VarHandle.getAndAddRelease
            |                 
            tr
              th GET_AND_BITWISE_OR
              td VarHandle.getAndBitwiseOr
            |                 
            tr
              th GET_AND_BITWISE_OR_RELEASE
              td VarHandle.getAndBitwiseOrRelease
            |                 
            tr
              th GET_AND_BITWISE_OR_ACQUIRE
              td VarHandle.getAndBitwiseOrAcquire
            |                 
            tr
              th GET_AND_BITWISE_AND
              td VarHandle.getAndBitwiseAnd
            |                 
            tr
              th GET_AND_BITWISE_AND_RELEASE
              td VarHandle.getAndBitwiseAndRelease
            |                 
            tr
              th GET_AND_BITWISE_AND_ACQUIRE
              td VarHandle.getAndBitwiseAndAcquire
            |                 
            tr
              th GET_AND_BITWISE_XOR
              td VarHandle.getAndBitwiseXor
            |                 
            tr
              th GET_AND_BITWISE_XOR_RELEASE
              td VarHandle.getAndBitwiseXorRelease
            |                 
            tr
              th GET_AND_BITWISE_XOR_ACQUIRE
              td VarHandle.getAndBitwiseXorAcquire
      |     
      details
        summary Method Detail
        |         
        ol
          li final Object get(Object... args)
          |             변수가 non-volatile인 것처럼 읽는다(= plain read). 모든 VarHandle 인스턴스에서 지원된다
          |             
          li final void set(Object... args)
          |             변수가 non-volatile, non-final인 것처럼 쓴다(= plain write). 메서드 시그니처는 (CT1 ct1, ..., CTn ctn, T newValue)void.
          |             
          li final Object getVolatile(Object... args)
          |             변수가 volatile인 것처럼 읽는다.
          |             
          li final void setVolatile(Object... args)
          |             변수가 volatile인 것처럼 쓴다. 메서드 시그니처는 (CT1 ct1, ..., CTn ctn, T newValue)void.
          |             
          li final Object getOpaque(Object... args) + setOpaque
          |             Opaque : Program order 순서대로 접근한다. 다른 스레드와의 조율은 없다
          |             
          li final Object getAcquire(Object... args)
          |             같은 변수에 대해 이어지는 load/store 연산이 이 접근보다 먼저 발생하지 않는다
          |             
          li final void setRelease(Object... args)
          |             같은 변수에 대한 이전의 load/store 연산이 이 접근보다 나중에 발생하지 않는다
          |             
          li final boolean compareAndSet(Object... args)
          |             원자적으로 다음이 실행된다. getVolatile과 동일한 문맥으로 가져온 값(witness value)이 expectedValue와 동일(==)하면 setVolatile과 동일한 문맥으로 newValue 설정 후 true 반환, 그 외엔 false 반환
          br
          |             메서드 시그니처는 (CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)boolean
          |             
          li final Object compareAndExchange(Object... args)
          |             원자적으로 다음이 실행된다. getVolatile과 동일한 문맥으로 가져온 값(witness value)이 expectedValue와 동일(==)하면 setVolatile과 동일한 문맥으로 newValue 설정. 반환값은 witness value
          |             
          li final Object compareAndExchangeAcquire(Object... args)
          |             원자적으로 다음이 실행된다. getAcquire와 동일한 문맥으로 가져온 값(witness value)이 expectedValue와 동일(==)하면 set와 동일한 문맥으로 newValue 설정. 반환값은 witness value
          |             
          li final Object compareAndExchangeRelease(Object... args)
          |             원자적으로 다음이 실행된다. get와 동일한 문맥으로 가져온 값(witness value)이 expectedValue와 동일(==)하면 setRelease와 동일한 문맥으로 newValue 설정. 반환값은 witness value
          |             
          li final boolean weakCompareAndSetPlain(Object... args)
          |             다음이 실행된다. get과 동일한 문맥으로 가져온 값(witness value)이 expectedValue와 동일(==)하면 set과 동일한 문맥으로 newValue 설정 후 true 반환. 그 외엔 false
          |             
          li final boolean weakCompareAndSet(Object... args) + ~Acquire, ~Release
          |             다음이 실행된다. getVolatile과 동일한 문맥으로 가져온 값(witness value)이 expectedValue와 동일(==)하면 setVolatile과 동일한 문맥으로 newValue 설정 후 true 반환. 그 외엔 false
          |             
          li final Object getAndSet(Object... args) + ~Acquire, ~Release
          |             원자적으로 다음이 실행된다. getVolatile과 동일한 문맥으로 값(witness value)을 가져오고, setVolatile과 동일한 문맥으로 newValue 설정 후 witness value 반환
          |             
          li final Object getAndAdd(Object... args) + ~Acquire, ~Release
          |             원자적으로 값을 더한 후 이전 값 반환. 메서드 시그니처는 (CT1 ct1, ..., CTn ctn, T value)T
          |             
          li final Object getAndBitwiseOr(Object... args)
          |             원자적으로 OR 연산 수행 후 이전 값 반환. 메서드 시그니처는 (CT1 ct1, ..., CTn ctn, T mask)T
          br
          |             + ~Acquire, ~Release, getAndBitwiseAnd~, getAndBitwiseXor~
          |             
          li final Class<?> varType() + coordinateTypes
          |             
          li
            | final MethodType accessModeType(VarHandle.AccessMode accessMode) + isAccessModeSupported
          |             접근 모드 획득
          |             
          li static void acquireFence()
          |             장벽 이전의 load 연산이 장벽 이후의 load/store 뒤로 재배치되지 않음
          |             
          li static void fullFence()
          |             장벽 이전의 load/store 연산이 장벽 이후의 load/store 뒤로 재배치되지 않음
          |             
          li static void releaseFence()
          |             장벽 이전의 load/store 연산이 장벽 이후의 store 뒤로 재배치되지 않음
          |             
          li static void loadLoadFence()
          |             장벽 이전의 load 연산이 장벽 이후의 load 뒤로 재배치되지 않음
          |             
          li static void storeStoreFence()
          |             장벽 이전의 store 연산이 장벽 이후의 store 뒤로 재배치되지 않음
    hr
    details
      summary class AtomicBoolean implements Serializable Since 1.5
      |     
      ol
        li public AtomicBoolean(boolean initialValue) + 오버로딩
        |         지정하지 않으면 false
        |         
        li final boolean get() : VarHandle#getVolatile
        |         
        li
          | final boolean compareAndSet(boolean expectedValue, boolean newValue) : VarHandle#compareAndSet
        |         
        li
          | boolean weakCompareAndSetPlain(boolean expectedValue, boolean newValue) Since 9 + VarHandle#weakCompareAndSetPlain
        |         
        li final void set(boolean newValue) : VarHandle#setVolatile
        |         
        li final void lazySet(boolean newValue) Since 1.6 : VarHandle#setRelease
        |         
        li final boolean getAndSet(boolean newValue) : VarHandle#getAndSet
        |         
        li final boolean getPlain() Since 9 : VarHandle#get
        |         
        li final void setPlain(boolean newValue) Since 9 : VarHandle#set
        |         
        li final boolean getOpaque() Since 9 : VarHandle#getOpaque
        |         
        li final void setOpaque(boolean newValue) Since 9 : VarHandle#setOpaque
        |         
        li final boolean getAcquire() Since 9 : VarHandle#getAcquire
        |         
        li final void setRelease(boolean newValue) Since 9 : VarHandle#setRelease
        |         
        li
          | final boolean compareAndExchange(boolean expectedValue, boolean newValue) Since 9 + ~Acquire, ~Release
        |         메모리 영향은 VarHandle#compareAndExchange와 같다.
        |         
        li
          | final boolean weakCompareAndSetVolatile(boolean expectedValue, boolean newValue) Since 9 + ~Acquire, ~Release
        |         메모리 영향은 VarHandle#weakCompareAndSet와 같다
    hr
    details
      summary
        | class AtomicInteger extends Number implements Serializable Since 1.5 + AtomicLong, AtomicReference
      |     
      ol
        li public AtomicInteger(int initialValue) + 오버로딩
        |         지정하지 않은 경우 0
        |         
        li final int get() : VarHandle#getVolatile
        |         
        li final void set(int newValue) : VarHandle#setVolatile
        |         
        li final void lazySet(int newValue) Since 1.6 : VarHandle#setRelease
        |         
        li final int getAndSet(int newValue) : VarHandle#getAndSet
        |         
        li
          | final boolean weakCompareAndSetPlain(int expectedValue) Since 9 : VarHandle#weakCompareAndSetPlain
        |         
        li VarHandle#getAndAdd
        |         final int getAndIncrement() + getAndDecrement, getAndAdd, incrementAndGet, decrementAndGet, addAndGet
        |         
        li VarHandle#compareAndSet
        |         final boolean compareAndSet(int expectedValue, int newValue) + getAndUpdate, updateAndGet, getAndAccumulate, accumulateAndGet
        |         
        li getPlain ~ weakCompareAndSetRelease​ : AtomicBoolean과 동일
    hr
    details
      summary
        | class AtomicIntegerArray implements Serializable Since 1.5 + AtomicLongArray, AtomicReferenceArray
      |     
      ol
        li 인덱스를 추가로 받는 것 외에, 지원하는 메서드들은 AtomicInteger와 같다.
        |         
        li public AtomicIntegerArray(int length) : 각 원소는 0으로 초기화.
        |         
        li public AtomicIntegerArray(int[] array)
        |         
        li final int length()
    hr
    details
      summary
        | abstract class AtomicIntegerFieldUpdater<T> Since 1.5 + AtomicLongFieldUpdater, AtomicReferenceFieldUpdater
      |     
      ol
        li 지정된 volatile int 필드를 atomic 연산으로 갱신.
        |         해당 필드를 단일 업데이터로만 접근한다면, compareAndSet 메서드들이 원자적으로 작동됨이 보장된다
        |         
        li 지원하는 메서드는 AtomicInteger와 유사하다.
        |         
        li
          | static <U> AtomicIntegerFieldUpdater<U> newUpdater(Class<U> tclass, String fieldName)
    hr
    details
      summary class AtomicMarkableReference<V> Since 1.5
      |     
      ol
        li 원자적으로 갱신되는 마커 bit와 객체 참조 쌍
        |         
        li public AtomicMarkableReference(V initialRef, boolean initialMark)
        |         
        li V getReference() + isMarked
        |         
        li V get(boolean[] markHolder)
        |         markHolder[0]에 해당하는 참조 반환
        |         
        li
          | boolean compareAndSet(V expectedReference, V newReference, boolean expectedMark, boolean newMark) + weakCompareAndSet
        |         기존 참조와 마커 bit가 모두 예상과 동일(==)하다면 원자적으로 갱신하고 true 반환. 그 외엔 false
        |         
        li void set(V newReference, boolean newMark)
        |         
        li boolean attemptMark(V expectedReference, boolean newMark)
        |         기존 참조가 예상과 동일(==)하다면, 마커 bit를 원자적으로 갱신하고 true 반환. 그 외엔 false
    hr
    details
      summary class AtomicStampedReference<V> Since 1.5
      |     
      ol
        li 원자적으로 갱신되는 index와 참조 쌍
        |         
        li public AtomicStampedReference(V initialRef, int initialStamp)
        |         
        li V getReference() + getStamp
        |         
        li V get(int[] stampHolder)
        |         stampHolder[0]에 해당하는 참조 반환
        |         
        li
          | boolean compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp) + weakCompareAndSet
        |         기존 참조와 인덱스가 예상과 동일(==)하다면 원자적으로 갱신하고 true 반환. 그 외엔 false
        |         
        li void set(V newReference, int newStamp)
        |         
        li boolean attempStamp(V expectedReference, int newStamp)
        |         기존 참조가 예상과 동일(==)하다면, 인덱스를 원자적으로 갱신하고 true 반환. 그 외엔 false
    hr
    details
      summary class LongAdder extends Number implements Serializable Since 1.8 + DoubleAdder
      |     
      ol
        li 초깃값 0으로 시작하는 스레드-안전한 합계.
        |         합의 순서는 정의되지 않으므로 순서에 상관 없는 경우에 이용해야 한다.
        |         
        li public LongAdder()
        |         
        li void add(long x)
        |         
        li void increment()
        |         
        li void decrement()
        |         
        li long sum() : 현재 합계 반환
        |         
        li void reset()
        |         
        li long sumThenReset()
    hr
    details
      summary
        | class LongAccumulator extends Number implements Serializable Since 1.8 + DoubleAccumulator
      |     
      ol
        li 특정 값과 특정 함수로 갱신되는 long 값 유지.
        |         주어진 accumulatorFunction은 부작용이 없어야 한다.
        |         
        li public LongAccumulator(LongBinaryOperator accumulatorFunction, long identity)
        |         
        li void accumulate(long x)
        |         
        li long get()
        |         
        li void reset()
        |         
        li long getThenReset()
    hr
