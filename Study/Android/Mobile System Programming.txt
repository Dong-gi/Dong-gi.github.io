1. Mobile Sensing System Overview
	1. Mobile Sensing Pipeline
		Sensor -> Sensing -> Feature extraction/Preprocessing -> Classification/Inference -> Applications
	
2. Android Programming Basic
	1. 안드로이드 구조
		Applications - Application Framework - Android Runtime + Libraries - Linux Kernel
	2. 기초 용어
		* Components : Activity, Service, Broadcast Receiver, Content Provider
			- Activity : UI 화면을 가지는 하나의 작업.
			- Service : 백그라운드에서 작업을 처리.
			- Broadcast Receiver : Broadcast 수신. BroadcastReceiver를 등록하여 관심 있는 이벤트를 감지.
		
		* Intent : 컴포넌트를 실행하기 위한 메시지.
		* Manifest file : 앱을 구성하는 컴포넌트들 선언, 필요한 권한 설정, 최소 API 레벨 선언, 기능 선언

3. Sensor Manager
	https://developer.android.com/guide/topics/sensors/sensors_overview.html?hl=ko
	1. SensorManager 클래스
		센서를 관리하고 이용할 수 있도록 제공되는 시스템 서비스
		SensorManager sm = (SensorManager)getSystemService(Context.SENSOR_SERVICE);
	2. Sensor 클래스
		Sensor accel = sm.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
		accel.getMaximumRange(), accel.getMinDelay(), .getName(), .getPower() // 소모한 파워(mA)
		.getStringType(), .getType(), .getVendor(), .getVersion()
		https://developer.android.com/reference/android/hardware/Sensor.html

예.
List<Sensor> sensors = sm.getSensorList(Sensor.TYPE_ALL);
list += "전체 센서 수: " + sensors.size() + "\n";int i = 0;
for(Sensor s: sensors) {
	list += "" + i++ + " name: " + s.getName() + "\n“ + "power: " + s.getPower() + "\n"
		+ "resolution: " + s.getResolution() + "\n“ + "range: " + s.getMaximumRange() + "\n"
		+ "vendor: " + s.getVendor() + "\n“ + "min delay: " + s.getMinDelay() + "\n\n";
}
	3. SensorEventListener 인터페이스
		SensorManager 중,
		boolean registerListener(SensorEventListener listener, Sensor sensor, int samplingPeriodUs)
		* SENSOR_DELAY_NORMAL, SENSOR_DELAY_UI, SENSOR_DELAY_GAME, SENSOR_DELAY_FASTEST
		void unregisterListener(SensorEventListener listener[, Sensor sensor])
		
		https://developer.android.com/reference/android/hardware/SensorEventListener.html?hl=ko
		SensorEventListener 인터페이스 구현
		* public void onAccuracyChanged(Sensor sensor, int accuracy)
			센서의 정밀도가 변경되었을 때 호출
		* public void onSensorChanged(SensorEvent event)
			센서 값이 변했을 때 호출.
			
	4. SensorEvent 클래스
		https://developer.android.com/reference/android/hardware/SensorEvent.html?hl=ko
		int accuracy, Sensor sensor, long timestamp, final float[] values
		* Sensor.TYPE_LIGHT : 조도센서, Sensor.TYPE_PRESSURE : 기압, Sensor.TYPE_PROXIMITY : 근접도(cm)
		  Sensor.TYPE_LINEAR_ACCELERATION : 중력가속도 제외.
예.
public void onSensorChanged(SensorEvent event) {
	if(event.sensor.getType() == Sensor.TYPE_ORIENTATION) {
		mText.setText("방향 센서값\n\n방위각: " + event.values[0]
			+ "\n피치: " + event.values[1] + "\n롤: " + event.values[2]);
	}
}
		
4. Location Manager
	* GPS : 오차 수~수십 미터
	  전화 기지국 : 오차 수백 미터
	  WiFi AP : 실내 위치
	  
	1. LocationManager 클래스
		LocationManager manager = (LocationManager)getSystemService(Context.LOCATION_SERVICE);
		void requestLocationUpdates(String provider, long minTime, float minDistance, LocationListener listener)
			업데이트 간 최소 시간 간격(ms), 업데이트 간 최소 거리(m)
		void requestSingleUpdate(String provider, LocationListener listener, Looper looper)
			looper : 콜백을 구현하기 위해 사용될 메시지 큐를 갖는 Looper 객체. UI 스레드에서 콜백을 받는 경우 null로 설정.
		void removeUpdates(LocationListener listener)
		
	2. LocationProvider 클래스
		위치 정보 제공원을 추상화한 것.
		LocationManager.GPS_PROVIDER : GPS 이용
			배터리 소모 큼. 실외. 긴 TTFF(Time To First Fix) 소요. 권한 : ACCESS_FINE_LOCATION
		LocationManager.NETWORK_PROVIDER : Cell ID, AP 이용
			부정확. 짧은 TTFF, 적은 배터리 소모. 권한 : ACCESS_COARSE_LOCATION
		LocationManager.PASSIVE_PROVIDER : 다른 앱이 요청한 정보를 사용
			권한 : ACCESS_FINE_LOCATION
			
	3. Location 클래스
		위치 정보를 캡슐화한 것.
		위도(latitude), 경도(longitude), 고도(altitude), 시각(timestamp), 속도(velocity)
		모든 LocationProvider가 모든 속성을 제공하지는 않는다. -> hasAltitude(), hasSpeed(), ...
		
	4. Criteria 클래스
		원하는 위치 제공자 목록을 얻기 위한 검색 용도로 사용.
		Criteria.ACCURACY_FINE, Criteria.ACCURACY_COARSE, Criteria.ACCURACY_HIGH, Criteria.POWER_LOW, ...
예.
Criteria criteria = new Criteria();
criteria.setAccuracy(Criteria.ACCURACY_COARSE);
List<String> enabledProviders = manager.getProviders(criteria, true);
// public List<String> getProviders(Criteria criteria, boolean enabledOnly)

	5. LocationListener 인터페이스
		void onLocationChanged(Location location)
		void onProviderDisabled(String provider)
		void onProviderEnabled(String provider)
			사용자가 위치 설정의 ON/OFF를 변경할 때
		void onStatusChanged(String provider, int status, Bundle extras)
			사용자의 설정 변경에 의한 것이 아님. GPS를 이용하도록 설정했음에도 신호가 수신되지 않는 경우 등.
			status : LocationProvider.OUT_OF_SERVICE, LocationProvider.TEMPORARILY_UNAVAILABLE, LocationProvider.AVAILABLE
			
	6. Permission
		<uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/>
		or android.permission.ACCESS_COARSE_LOCATION
		
		Android 6.0부터는 매니페스트 선언과 별개로 사용자로부터 Runtime permission을 얻어야 한다.
		
	7. Proximity Alert
		LocationManager 메소드.
		근접 경보. 등록한 영역에 들어가거나 나갈 때 인텐트로 알림.
		권한 : ACCESS_FINE_LOCATION
		void addProximityAlert(double latitude, double longitude, float radius, long expiration, PendingIntent intent)
			expiration : 기한. 기한 내에 도착하지 못하면 알림은 취소. -1이면 무기한.
			intent로 KEY_PROXIMITY_ENTERING이라는 boolean 값 전달. true면 들어가는 것, false면 나가는 것.
		void removeProximityAlert(PendingIntent intent)
		
예.
AlertReceiver receiver = new AlertReceiver();
IntentFilter filter = new IntentFilter("kr.ac.koreatech.msp.locationAlert");
registerReceiver(receiver, filter);

Intent intent = new Intent("kr.ac.koreatech.msp.locationAlert");
PendingIntent proximityIntent = PendingIntent.getBroadcast(this, 0, intent, 0);
// 브로드캐스트를 수행하는 PendingIntent 생성.

public class AlertReceiver extends BroadcastReceiver {
    @Override
    public void onReceive(Context context, Intent intent) {
        boolean isEntering = intent.getBooleanExtra(LocationManager.KEY_PROXIMITY_ENTERING, false);
        // getBooleanExtra(String name, boolean defaultValue)

        if(isEntering)
            Toast.makeText(context, "목표 지점에 접근중입니다..", Toast.LENGTH_LONG).show();
        else
            Toast.makeText(context, "목표 지점에서 벗어납니다..", Toast.LENGTH_LONG).show();
    }
}

5. WiFi Manager
	WifiManager wm = (WifiManager)getSystemService(Context.WIFI_SERVICE)
	Geocoding : 주소/지명을 좌표로, Reverse Geocoding : 좌표를 주소/지명으로
	
	1. 실내위치 인식 방법
		1. 비콘
			BLE(Bluetooth Low Energy) 기반의 비콘 이용.
		2. 초음파 이용
		3. 자기장 왜곡 이용
		4. WiFi AP 정보 이용
			WiFi fingerprint : 위치에 따른 AP와 신호 강도에 대한 정보.

	2. 권한 : ACCESS_WIFI_STATE, CHANGE_WIFI_STATE
	3. ScanResult 클래스
		public : BSSID, SSID, frequency, level, timestamp, ...
		SSID : 무선 네트워크 이름, KUTAP ...
		BSSID : MAC 주소
		RSSI(Received Signal Strength Indication) : 수신 강도
		
예.
WifiManager wifiManager = (WifiManager)getApplicationContext().getSystemService(WIFI_SERVICE);
// wifi가 활성화되어있는지 확인 후 꺼져 있으면 켠다
if(wifiManager.isWifiEnabled() == false)
    wifiManager.setWifiEnabled(true);

BroadcastReceiver mReceiver = new BroadcastReceiver() {
    @Override
    public void onReceive(Context context, Intent intent) {
        String action = intent.getAction();
        if (action.equals(WifiManager.SCAN_RESULTS_AVAILABLE_ACTION))
            getWifiInfo();
    }
};

// wifi scan 결과를 얻어서 UI의 TextView에 표시하는 기능 수행
private void getWifiInfo() {
    List<ScanResult> scanResultList = wifiManager.getScanResults();
    scanResultText.setText("===================================\n");
    for(int i = 0; i < scanResultList.size(); i++) {
        ScanResult result = scanResultList.get(i);
        scanResultText.append((i+1) + "- SSID: " + result.SSID + "\t RSSI: " + result.level + " dBm\n");
    }
    scanResultText.append("===================================");
}

IntentFilter filter = new IntentFilter(WifiManager.SCAN_RESULTS_AVAILABLE_ACTION);
registerReceiver(mReceiver, filter);

wifiManager.startScan();

	4. WiFi 근접경보
예.
Intent intent = new Intent(this, AlertService.class);
startService(intent);
<-> stopService(new Intent(this, AlertService.class));

// 타이머 작업
TimerTask timerTask = new TimerTask() {
	@Override
	public void run() {
		wifiManager.startScan();
	}
};
timer.schedule(timerTask, 1000, 10000); // 1초 후 실행, 10초마다 반복

// 진동
Vibrator vib = (Vibrator)getSystemService(VIBRATOR_SERVICE);
long[] pattern = {0, 200, 100, 200, 100, 200}; // 0초 후 시작. 200ms 동안 진동, 100ms 동안 쉼, ...
vib.vibrate(pattern, -1); // -1 : 반복 없음

6. Bluetooth Manager
	JELLY_BEAN_MR1 이하
	BluetoothAdapter bluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
	JELLY_BEAN_MR2 이상
	BluetoothManager bm = (BluetoothManager)getSystemService(BLUETOOTH_SERVICE);
	BluetoothAdapter bluetoothAdapter = bm.getAdapter();
	권한 : BLUETOOTH, BLUETOOTH_ADMIN
	
	Android 6.0 이후, WiFi 스캔, 블루투스 스캔으로 근처 기기의 식별자에 액세스하려면 ACCESS_COARSE_LOCATION 혹은 ACCESS_FINE_LOCATION 권한 필요.
	
7. Power Manager
	1. 파워 상태
		Run
		Standby : 시스템 비활성화, 백라이트 Off
		Sleep : Standby 상태가 지속되면 주변장치 전원 차단, CPU Sleep
		Shutdown : 파워 Off
		RTC(Real Time Clock)은 항상 On
	
	권한 : WAKE_LOCK
	PowerManager pm = (PowerManager)getSystemService(Context.POWER_SERVICE);
	PowerManager.WakeLock wl = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "Tag: partial wake lock");
	// public PowerManager.WakeLock newWakeLock(int levelAndFlags, String tag)
	// level, flag : PowerManager 클래스에 정의
	// level 하나만 설정 : PARTIAL_WAKE_LOCK(CPU만 On, 다른 Wake Lock과 달리 파워 버튼을 눌러도 CPU ON), FULL_WAKE_LOCK, SCREEN_DIM_WAKE_LOCK, SCREEN_BRIGHT_WAKE_LOCK
	// flag or 연산으로 추가 : ACQUIRE_CAUSES_WAKEUP(스크린과 키보드 불을 켠다), ON_AFTER_RELEASE
	wl.acquire();
	// 동작
	wl.release();
	화면과 관련된 wake lock은 deprecated. "Activity"에서 FLAG_KEEP_SCREEN_ON을 사용한다. 별도 권한이나 release()같은 작업이 필요 없다.
예.
xml : android:keepScreenOn="true"
java : getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);

8. Mobile Device Power Measurement
	1. CPU DVFS
		CPU의 동작 전압과 주파수를 요구되는 연산량에 따라 조절.
	2. big.LITTLE Architecture
		ARM에서 개발한 이기종 컴퓨팅 아키텍처. 저전력 저성능 프로세서와 고전력 고성능 코어를 함께 탑재.
	
9. Energy Efficient Mobile Sensing System Design
	1. Duty Cycling
		주기적으로 센싱하고 처리. D = T/P*100(T : active 상태 시간, P : 주기)
	2. Adaptive Duty Cycling
		이벤트 혹은 inference(추론)에 따라 duty cycle을 동적으로 변경.
		Adaptive Duty Cycling이 단순 Duty Cycling보다 좋을 수 있는 것은 사람의 행동 패턴에 locality가 존재하기 때문
	3. Hierarchical(Conditional) Sensing
		low power sensor를 이용하여 특정 조건이 만족되는지 확인한 후에 알고 싶은 context 정보를 inference하는 데 필요한 sensor를 사용.
		예. 이동 중일때만 GPS 센싱
	4. Cloud Offloading
		일부 과정을 cloud 서버에서 처리. offloading을 위해 발생하는 에너지 소모보다 절약되는 에너지가 커야 의미가 있다.
		예. 음성 인식.
	5. AlarmManager 클래스
		디바이스가 sleep 상태인 경우에도 미래의 특정 시점에 작업을 수행해야 하는 경우.
예.
AlarmManager am = (AlarmManager)getSystemService(ALARM_SERVICE);
IntentFilter intentFilter = new IntentFilter("kr.ac.koreatech.msp.alarm");
registerReceiver(AlarmReceiver, intentFilter);
Intent intent = new Intent("kr.ac.koreatech.msp.alarm");
PendingIntent pendingIntent = PendingIntent.getBroadcast(this, 0, intent, 0);
// 5초 뒤 알람 발생
am.setExact(AlarmManager.ELAPSED_REALTIME_WAKEUP, SystemClock.elapsedRealtime()+5000, pendingIntent);
		1. Alarm 발생 설정
			* 부팅 후 경과 시간 ELAPSED_REALTIME, 실제 시간 RTC
			* Sleep 상태에서 수행 wake up
			* 일회성 set(), 반복 setRepeating() // API level 19부터는 모두 inexact
			* 정확한 시각에 수행 setExact(), 오차 허용 setInexactRepeating()
		2. Doze 모드 - API level 23
			Not 충전중, Off 스크린, No 동작
			=> 네트워크 액세스 제한, Wake lock 무시, WiFi 스캔 중지, SyncAdapter, JobScheduler, AlarmManager 중지
			주기적으로 유지관리 기간이 할당되며 이 기간 동안 중지되었던 작업 실행.
			Doze 모드 중 알람이 실행되도록 설정
				* setAndAllowWhileIdle() -> set()과 유사
				* setExactAndAllowWhileIdle() -> setExact()와 유사
				최소 주기 : 1분(비 Doze 모드), 15분(Doze 모드)
				* setAlarmClock()으로 설정된 알람은 정상적으로 실행된다.
					알람이 실행되기 직전에 Doze 모드 종료
1. 사용자 인터페이스 기초
	1. 뷰와 뷰 그룹
		1. View
			* 안드로이드에서 UI를 구성하는 기본 building block.
			* View 클래스를 상속받아 작성.
		2. View Group
			* View를 담는 컨테이너(Layout)
			* ViewGroup 클래스를 상속받아 작성.
			htps:/developer.android.com/reference/android/view/View.html
	2. 크기 단위
		px(픽셀), dp(density-independent pixels), sp(scale-independent pixels), pt(points, 1/72인치), mm, ,in(inches)
	3. 색상
		#RRGGBB, #AARRGGBB
		예. android:background="#ff000000" : 완전 불투명 검정색
	4. View - android:visibility
		상수			값		설명
		visible		0		화면에 보이게 한다. 디폴트
		invisible	1		표시되지 않지만 공간은 차지.
		gone		2		완전히 숨겨진다.
	5. EditText - inputType
		Text, textMultiLine, textEmailAddress, textPassword, textVisiblePassword, number, phone, datetime
		
	
	