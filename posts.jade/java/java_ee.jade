include ../../source/skeleton.jade
+post('JavaEE', 'JavaEE, Servlet, tomcat, JSP, Spring', 'JavaEE 정리')
    h1.marker JavaEE
    ol
        li Java Enterprise Edition은 동적 웹 애플리케이션 개발을 위한 자바 플랫폼이다.
        p
            | JavaSE와는 문서 페이지가 다르다. 
            +asA('https://javaee.github.io/javaee-spec/javadocs/')
        li WAR(Web Application Archive) : JavaEE 웹 애플리케이션을 위한 압축 파일
        p 전통적인 war 파일 구조 ↓
        +asCode().
            웹앱 루트
            ㄴ META-INF
                ㄴ MANIFEST.MF
                ㄴ 컨테이너 지원
            ㄴ WEB-INF : 웹에서 접근 불가
                ㄴ classes
                    ㄴ META-INF
                        ㄴ 애플리케이션 자원
                    ㄴ 자바 .class 파일 및 자원
                ㄴ i88n
                    ㄴ 국제화 파일
                ㄴ lib
                    ㄴ 번들 jar 파일
                ㄴ tags
                    ㄴ JSP 태그 파일
                ㄴ tld
                    ㄴ JSP 태그 라이브러리 설명자
            ㄴ 기타 웹에서 접근 가능한 파일
        li 서블릿
        p
            | 자바로 구현된 CGI(Common Gateway Interface; 웹 서버와 프로그램 사이의 통신 규약).
            |  JCP(Java Community Process)에서 제정한 Servlet Specification을 따라야 한다.
        li 서블릿 컨테이너
        p 서블릿의 생애를 관리하는 프로그램(예. 톰캣)
        li JSP
        p
            | 전용 태그 "&lt;% %>"를 이용해 HTML 문서에 자바 코드를 삽입.
            |  컨테이너가 자동으로 컴파일 하며, 서블릿 클래스와 달리 수정사항이 있어도 다시 빌드할 필요가 없다.

    h1.marker 톰캣 배포 프로젝트
    div
        h2.marker 개발 환경
        ol
            li
                +asA('http://openjdk.java.net/install/', 'OpenJDK')
                |  설치
            li
                +asA('https://tomcat.apache.org/', '톰캣')
                |  설치
            li IDE(이클립스, STS 등) 설치
            ul
                li 이클립스에 톰캣 추가
                +asCode() Windows » Preferences » Server » Runtime Environments » Add » Apache
                li 이클립스 프로젝트에 톰캣 구성 추가
                +asCode() 프로젝트 Server 속성에 추가.
                li IntelliJ에 톰캣 추가
                +asCode() Settings » Application Servers » + » 톰캣 홈 디렉터리 추가
                li IntelliJ 프로젝트에 톰캣 구성 추가
                +asCode().
                    도구 모음에서 Run/Debug Configurations 아이콘(아래방향 화살표)을 누른 다음 Edit Configurations 클릭
                    
                    대화상자가 열리면 + 버튼 클릭 후 Tomcat Server를 Local로 추가.
                    
                    배포할 아티팩트를 선택하지 않았다는 경고가 표시되면 Deployment 탭을 누르고 "Deploy at the server setup" 머리글 아래의 + 버튼 클릭.
                    Artifact를 누르고 확장된 war 파일 아티팩트를 누른 다음 OK. 배포를 위한 "Application context"이름을 서버를 기준으로 한 상대 주소로 변경(예. /my-app)

        h2.marker Hello World 프로젝트
        div
            h3.marker 이클립스 Dynamic Web Project
            ol
                li New Project » Web » Dynamic Web Project » Target runtime에 톰캣 설정
                +w3img('/imgs/20180929_220300.png')
                li 코드 작성
                +w3img('/imgs/20180929_220301.png')
                +codeBtn('/Repositories/Eclipse/app1/src/main/java/io/github/donggi/servlet/Hello1.java', 'java') Hello1.java »
                +codeBtn('/Repositories/Eclipse/app1/src/main/webapp/WEB-INF/web.xml', 'xml') web.xml »
                li web.xml
                p
                    | web.xml은 배포 설명자로, 서블릿 및 서블릿 매핑, 필터 등을 정의한다.
                    |  이클립스 프로젝트 생성 마법사로 web.xml을 생성하면 자동으로 welcome-file-list를 구성해주는데, welcome-file-list에 정의된 welcome-file을 순서대로 찾아 기본 페이지로 보여준다.
                li 실행
                +w3img('/imgs/20180929_220302.png')
                p 또는 Export » WAR file를 선택하여, 톰캣 webapps 디렉터리에 옮긴 후 배치되기를 기다린 뒤 브라우저에서 실행.
                li 이클립스 내부에서 실행하는 경우 웹 애플리케이션 배포 위치
                p ${PROJECT_ROOT}\.metadata\.plugins\org.eclipse.wst.server.core\tmp0\wtpwebapps\Web01\WEB-INF

            h3.marker 톰캣에 직접 배치
            ol
                li
                    | 위와 동일하게 HelloWorld.java 작성 
                    +codeBtn('/Repositories/Eclipse/app1/src/main/java/io/github/donggi/servlet/Hello1.java', 'java') Hello1.java »
                li 컴파일
                ul
                    li 톰캣 lib를 클래스패스로 넘기는 경우
                    +asCode('shell') javac -encoding UTF-8 -cp "C:\apache-tomcat-8.0.52\lib\servlet-api.jar" HelloWorld.java
                    li JDK의 jre/lib/ext에 servlet-api.jar를 붙여넣은 경우
                    +asCode('shell') javac -encoding UTF-8 HelloWorld.java
                li 컴파일된 클래스 파일을 webapps/${웹모듈명}/WEB-INF/classes/${패키지 경로}/ 에 저장
                li
                    | 동일한 배포 설명자 web.xml을 WEB-INF에 작성하고 실행 
                    +codeBtn('/Repositories/Eclipse/app1/src/main/webapp/WEB-INF/web.xml', 'xml') web.xml »

            h3.marker 이클립스 Maven 프로젝트
            ol
                li New Project » Maven » Maven Project » maven-archetype-webapp
                +w3img('/imgs/20180930_154849.png')
                p webapp 아티팩트로 프로젝트를 만들면 Hello World를 출력하는 index.jsp가 생성된다.
                li Maven Install, 빌드하여 war 파일이 생성되면 톰캣 webapps 디렉터리에 붙여넣고 배치되기를 기다린 뒤 브라우저에서 실행
                p maven이 pom.xml에 정의된 라이브러리를 /users/유저이름/.m2 폴더에 다운로드한다.

        h2.marker 서블릿 생애 주기
        ol
            li 서블릿 컨테이너에 의해 최초로 로드되어 인스턴스 생성
            li init()
            li 각 요청마다 service() 호출
            li destroy()
            +codeBtn('/Repositories/Eclipse/app1/src/main/java/io/github/donggi/servlet/LifeCycle.java', 'java')

        h2.marker web.xml 대신 애너테이션으로 서블릿 기술
        ol
            li WebServlet 애너테이션으로 배포설명자 web.xml 대신 간결하게 서블릿을 기술할 수 있다.
            +codeBtn('/Repositories/Eclipse/app1/src/main/java/io/github/donggi/servlet/Hello2.java', 'java') value
            +codeBtn('/Repositories/Eclipse/app1/src/main/java/io/github/donggi/servlet/Hello3.java', 'java') initParams
            li name : 배포설명자의 servlet-name에 해당.
            li urlPatterns : 배포설명자의 url-pattern들의 배열에 해당.
            li value : urlPatterns 요소와 동일하게 동작하기 때문에, 서블릿 매핑만을 기술할 거라면 편하게 WebServlet("/hello")처럼 기술할 수 있다.
            li initParams : 배포설명자의 init-param들의 배열에 해당.
            p GenericServlet#getInitParameter로 참조할 수 있으며, 이 메서드는 ServletConfig#getInitParameter를 호출한다. ServletConfig는 GenericServlet#getServletConfig 메서드로 참조할 수 있다.
            li loadOnStartup : 컨테이너가 애플리케이션을 시작할 때, 클라이언트의 요청이 없어도 미리 해당 서블릿을 인스턴스화 한다.
            p
                | Non-negative 정수로 설정하며, 0에 가까울수록 우선 초기화
                +codeBtn('/Repositories/Eclipse/app1/src/main/java/io/github/donggi/servlet/Hello5.java', 'java') loadOnStartup

        h2.marker JDBC 예시
        ol
            li 드라이버 설치
            ul
                li 톰캣 lib(예. C:\apache-tomcat-8.0.52\lib)에 복사
                li 또는 웹 애플리케이션 lib(${프로젝트}\WebContent\WEB-INF\lib)에 복사
                li 또는 프로젝트에 직접 포함
            li 사용하기 전에 드라이버 클래스 로드
            li DataSource 직접 사용하기
                +codeBtn('/Repositories/Eclipse/app1/src/main/java/io/github/donggi/servlet/Hello4.java', 'java')
            ul
                li url : JDBC 연결 문자열로, 옵션은 각 JDBC마다 제공하는 것이 다르다
                li
                    | 위 예시코드에서는 Apache Commons DBCP를 이용. 
                    +asA('https://commons.apache.org/proper/commons-dbcp/guide/index.html')
                +asCode('java').
                    BasicDataSource.initialSize                 // 최초 커넥션 수 + maxActive, maxIdle, minIdle
                    BasicDataSource.maxWait                     // 풀에 커넥션이 없을 때 대기하는 최대 시간(ms). 음수면 무기한
                    BasicDataSource.minEvictableIdleTimeMillis  // 설정된 것 이상 비활성 상태인 커넥션은 정리될 수 있다
                                                                // + timeBetweenEvictionRunsMillis, numTestsPerEvictionRun
                    BasicDataSource.testOnBorrow                // 커넥션을 가져올 때, 유효한 지 검사할 지 여부
                                                                // + testOnReturn, testWhileIdle
            li context.xml 리소스로 DataSource 정의하기
            +codeBtn('/Repositories/Eclipse/app1/src/main/webapp/META-INF/context.xml', 'xml') context.xml »
            +asCode('xml', 'web.xml » resource-ref').
                &lt;resource-ref>
                    &lt;res-ref-name>jdbc/MySQL/localhost/test&lt;/res-ref-name>
                    &lt;res-type>javax.sql.DataSource&lt;/res-type>
                    &lt;res-auth>Container&lt;/res-auth>
                &lt;/resource-ref>
            +codeBtn('/Repositories/Eclipse/app1/src/main/java/io/github/donggi/servlet/Hello6.java', 'java') 서블릿 »

    h1.marker 서블릿
    div
        h2.marker 다른 페이지로 이동/호출
        ol
            +codeBtn('/Repositories/Eclipse/app1/src/main/java/io/github/donggi/servlet/CallOther.java', 'java')
            li 다른 페이지로 이동
            ul
                li Refresh : 응답 페이지를 보여준 뒤 클라이언트가 나중에 다시 요청하도록 한다.
                li Redirect : 응답 페이지 없이 바로 다른 url을 요청하도록 한다.
                p 따라서 redirect의 경우에는 getWriter()를 이용하지 말아야 한다.
            li 다른 페이지 호출
            ul
                li Forward
                ul
                    li 호출하는 페이지로 제어를 넘기기 때문에 해당 페이지가 종료되도 제어가 되돌아오지 않는다.
                    p
                        | 따라서 forward를 호출하는 측은 getWriter()를 이용하지 말아야 한다.
                        |  + 호출자 자신과 동일한 페이지/서블릿을 호출할 수 있다.
                    li forward는 서버 내에서 요청/응답 객체를 넘겨주므로 별도의 인코딩 없이 텍스트나 다른 객체를 추가하여 넘겨줄 수 있다.
                li Include
                ul
                    li Forward와 달리 호출된 페이지가 종료되면 제어가 돌아온다.
                    p 때문에 호출자와 동일한 페이지/서블릿을 호출할 수 없다.
                    li 호출된 페이지와 호출한 페이지 사이의 출력 HTML 코드 조각 순서를 맞추기 위해 flush()를 적절히 호출해줘야 한다.

        h2.marker 필터
        ol
            li 웹 브라우저가 웹 컴포넌트를 호출하면, 필터가 사전작업을 수행하고 웹 컴포넌트를 호출.
            li 필터 체인 : 하나의 페이지에 대해 여러 필터가 정의된 경우, 정의된 순서대로 필터가 호출된다.
            li 배포 설명자에 명시 :
                +codeBtn('/Repositories/Eclipse/app1/src/main/webapp/WEB-INF/web.xml', 'xml') web.xml »
                +codeBtn('/Repositories/Eclipse/app1/src/main/java/io/github/donggi/filter/DoNothing.java', 'java')
            li 애너테이션으로 명시 :
                +codeBtn('/Repositories/Eclipse/app1/src/main/java/io/github/donggi/filter/DoNothing2.java', 'java')

        h2.marker 래퍼
        ol
            li Http 요청/응답을 감싸는 사용자 정의 객체
            li 각각 HttpServletRequestWrapper, HttpServletResponseWrapper를 상속하면 된다.
            +codeBtn('/Repositories/Eclipse/app1/src/main/java/io/github/donggi/request/RequestWrapper.java', 'java') MyRequestWrapper.java »
            +codeBtn('/Repositories/Eclipse/app1/src/main/java/io/github/donggi/response/ResponseWrapper.java', 'java') MyResponseWrapper.java »

        h2.marker JSP
        ol
            li JSP 파일은 클라이언트 요청으로 필요해지면 HttpJspPage 인터페이스를 구현한 서블릿 클래스로 컴파일되고, 해당 서블릿이 요청을 처리한다
            li JSP 파일의 본문은 HttpJspPage#_jspService 메서드의 본문이 된다.
            li HttpJspPage → JspPage → Servlet
            p JspPage 인터페이스는 jspInit(), jspDestroy()를 정의한다
            li JSP 태그
                +codeBtn('/Repositories/Eclipse/app1/src/main/webapp/jsp/Hello.jsp', 'xml') Hello.jsp »
            ul
                li &lt;%@ %> : 지시자; Directive : page, taglib, include 3종류가 있다
                li &lt;% %> : Scriptlet : 일반 자바 코드를 작성하면 된다. _jspService 메서드 안의 코드로, 매개변수를 포함한 아래의 변수들을 참조할 수 있다.
                +w3img('/imgs/20190912_191500.png')
                li &lt;%! %> : 선언문; Declaration : 서블릿 클래스의 멤버 정의
                li &lt;%= %> : Expression : out#print 또는 out#write에 들어갈 값을 반환하는 문장을 작성하면 된다

        h2.marker 데이터 저장소
        ol
            li ServletContext
            p
                | 애플리케이션 수준 공유 데이터. GenericServlet#getServletContext로 참조할 수 있다. JSP에서는 application 변수.
                br
                | initParams : 앱 초기화 매개변수. 모든 서블릿이 ServletContext#getInitParameter로 참조할 수 있다.
            +asCode('xml').
                &lt;!-- web.xml -->
                &lt;context-param>
                    &lt;param-name>name&lt;/param-name>
                    &lt;param-value>Context Param&lt;/param-value>
                &lt;/context-param>
            li ServletConfig
            p
                | 서블릿 수준 공유 데이터. GenericServlet#getServletConfig로 참조할 수 있다. JSP에서는 config 변수.
                br
                | initParams : 서블릿 초기화 매개변수. 서블릿 내에서 GenericServlet#getInitParameter로 참조할 수 있다.
            li 당연하지만, 서블릿 static 멤버도 서블릿 수준 공유 가능
            li HttpSession
            p 세션 수준 공유 데이터. HttpServletRequest#getSession으로 참조할 수 있다. JSP에서는 session 변수
            li ServletRequest
            p (클라이언트 요청 처리) 스레드 수준 공유 데이터. 서블릿마다 자동으로 공유되지는 않으며, 직접 전달해야 한다
            li 각 클라이언트의 요청이 별개의 스레드에서 실행되므로, ThreadLocal이 유용할 수 있다
            li JspContext
            p _jspService()에서 자동 선언하는 pageContext 지역변수(). JSP 실행하는 동안 유효.

        h2.marker javax.servlet 이벤트 리스너
        p 이벤트 리스너 구현 클래스는 배포 설명자에 서술되거나, @WebListener를 표기하거나, ServletContext#addListener로 등록돼야 한다
        ul
            li @WebListener 표기 가능 리스너 : ServletContextListener, ServletContextAttributeListener, ServletRequestListener, ServletRequestAttributeListener, HttpSessionListener, HttpSessionAttributeListener, HttpSessionIdListener
            li ServletContext#addListener 등록 가능 리스너 : ServletContextAttributeListener, ServletRequestListener, ServletRequestAttributeListener, HttpSessionAttributeListener, HttpSessionIdListener, HttpSessionListener.
            p ServletContext 인스턴스가 ServletContainerInitializer#onStartup()으로 설정됐다면 ServletContextListener도 등록 가능
        table
            caption 종류
            +ths('분류', '이벤트', '인터페이스', '메서드', '설명')
            +tds('웹앱', 'ServletContextEvent', 'ServletContextListener Since Servlet 2.3', 'contextInitialized', '웹앱 초기화')
            +tds('웹앱', 'ServletContextEvent', 'ServletContextListener Since Servlet 2.3', 'contextDestroyed', '웹앱 종료')
            +tds('웹앱 속성', 'ServletContextAttributeEvent', 'ServletContextAttributeListener Since Servlet 2.3', 'attributeAdded', '속성 추가')
            +tds('웹앱 속성', 'ServletContextAttributeEvent', 'ServletContextAttributeListener Since Servlet 2.3', 'attributeRemoved', '속성 제거')
            +tds('웹앱 속성', 'ServletContextAttributeEvent', 'ServletContextAttributeListener Since Servlet 2.3', 'attributeReplaced', '속성 변경')
            +tds('요청', 'ServletRequestEvent', 'ServletRequestListener Since Servlet 2.4', 'requestInitialized', '요청이 웹앱 스코프에 진입')
            +tds('요청', 'ServletRequestEvent', 'ServletRequestListener Since Servlet 2.4', 'requestDestroyed', '요청이 웹앱 스코프를 벗어남')
            +tds('요청 속성', 'ServletRequestAttributeEvent', 'ServletRequestAttributeListener Since Servlet 2.4', 'attributeAdded', '속성 추가')
            +tds('요청 속성', 'ServletRequestAttributeEvent', 'ServletRequestAttributeListener Since Servlet 2.4', 'attributeRemoved', '속성 제거')
            +tds('요청 속성', 'ServletRequestAttributeEvent', 'ServletRequestAttributeListener Since Servlet 2.4', 'attributeReplaced', '속성 변경')
            +tds('세션', 'HttpSessionEvent', 'HttpSessionListener Since Servlet 2.3', 'sessionCreated', '세션 생성')
            +tds('세션', 'HttpSessionEvent', 'HttpSessionListener Since Servlet 2.3', 'sessionDestroyed', '세션 폐기')
            +tds('세션 속성', 'HttpSessionEvent', 'HttpSessionIdListener Since Servlet 3.1', 'sessionIdChanged', '세션 ID 변경')
            +tds('세션 속성', 'HttpSessionBindingEvent', 'HttpSessionAttributeListener Since Servlet 2.3', 'attributeAdded', '속성 추가')
            +tds('세션 속성', 'HttpSessionBindingEvent', 'HttpSessionAttributeListener Since Servlet 2.3', 'attributeRemoved', '속성 제거')
            +tds('세션 속성', 'HttpSessionBindingEvent', 'HttpSessionAttributeListener Since Servlet 2.3', 'attributeReplaced', '속성 변경')
            +tds('세션 속성', 'HttpSessionBindingEvent', 'HttpSessionBindingListener', 'valueBound', 'HttpSessionBindingListener를 구현한 인스턴스가 세션의 setAttribute()로 추가되면 호출')
            tr
                td 세션 속성
                td HttpSessionBindingEvent
                td HttpSessionBindingListener
                td valueUnbound
                td: ul
                    p HttpSessionBindingListener를 구현한 인스턴스가
                    li 세션의 removeAttribute()로 제거된 경우
                    li invalidate()로 세션이 만료된 경우
                    li 시간 초과로 세션이 만료된 경우 호출
            +tds('요청 스트림', 'void', 'ReadListener Since Servlet 3.1', 'onDataAvailable', 'HTTP 요청 데이터 읽기가 가능해지는 시점에 한 번 호출')
            +tds('요청 스트림', 'void', 'ReadListener Since Servlet 3.1', 'onAllDataRead', '블로킹 없이 모든 요청 데이터를 읽을 수 있을 때 호출')
            +tds('요청 스트림', 'Throwable', 'ReadListener Since Servlet 3.1', 'onError', '요청 처리에 예외가 발생한 경우 호출')
            +tds('응답 스트림', 'void', 'WriteListener Since Servlet 3.1', 'onWritePossible', '응답 쓰기가 가능해지는 시점에 한 번 호출')
            +tds('응답 스트림', 'Throwable', 'WriteListener Since Servlet 3.1', 'onError', 'non-blocking 쓰기 중 발생한 예외 처리')
            +tds('비동기 처리', 'AsyncEvent', 'AsyncListener Since Servlet 3.0', 'onStartAsync', '비동기 작업 시작')
            +tds('비동기 처리', 'AsyncEvent', 'AsyncListener Since Servlet 3.0', 'onComplete', '비동기 작업 완료')
            +tds('비동기 처리', 'AsyncEvent', 'AsyncListener Since Servlet 3.0', 'onTimeout', '비동기 작업 시간초과')
            +tds('비동기 처리', 'AsyncEvent', 'AsyncListener Since Servlet 3.0', 'onError', '비동기 작업 중 예외가 발생')
        ul
            li ReadListener 설정 : ServerRequest#getInputStream → ServerInputStream#setReadListener
            li WriteListener 설정 : ServerResponse#getOutputStream → ServerOutputStream#setWriteListener
            li AsyncListener 설정 : ServletRequest#startAsync → AsyncContext#addListener

    h1.marker MyBatis
    div
        h2.marker mybatis-config.xml
        ol
            li DTD
            +asCode('xml') &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd">
            li ELEMENT configuration (properties?, settings?, typeAliases?, typeHandlers?, objectFactory?, objectWrapperFactory?, reflectorFactory?, plugins?, environments?, databaseIdProvider?, mappers?)
            li properties 예
            +asCode('xml').
                &lt;properties url="mybatis.properties"/>
                &lt;!-- resource : 파일이 클래스 패스에 있는 경우.
                     url      : 다른 경로에 있는 경우 -->
            li 로거 settings
            +asCode('xml').
                &lt;setting name="logImpl" value=""/>
                &lt;!-- value : SLF4J, LOG4J, LOG4J2, JDK_LOGGING, COMMONS_LOGGING, STDOUT_LOGGING, NO_LOGGING, Qualified class path -->
            li typeAliases : SQL 매퍼 파일의 매개변수/리턴 타입의 별명을 지정
            p built-in 별명 : _int(int), int(java.lang.Integer), date(java.util.Date) 등
            li environments : 실행 환경(environment) 정의.
            ul
                li environment » transactionManager » type 속성 : JDBC(MyBatis에서 트랜잭션 관리), MANAGED(서버나 서블릿 컨테이너에서 트랜잭션 관리)
                li environment » dataSource » type 속성 : UNPOOLED(매 요청마다 새 커넥션 생성), POOLED(커넥션 풀링), JNDI(서버나 서블릿 컨테이너의 데이터 소스 사용)
                +asCode('xml', 'POOLED').
                    &lt;dataSource type="POOLED">
                        &lt;property name="driver" value="org.postgresql.Driver"/>
                        &lt;property name="url" value="jdbc:postgresql://localhost:5432/log"/>
                        &lt;property name="username" value="name"/>
                        &lt;property name="password" value="password"/>
                    &lt;/dataSource>
                +asCode('xml', 'JNDI').
                    &lt;dataSource type="JNDI">
                        &lt;property name="data_source" value="jdbc/MySQL/localhost/test"/>
                    &lt;/dataSource>
            li mappers : 각 매퍼(mapper) 파일 정의
            +asCode('xml').
                &lt;mappers>
                    &lt;mapper resource="SomeMapper.xml"/>
                    &lt;!-- resource : 파일이 클래스 패스에 있는 경우.
                         url      : 다른 경로에 있는 경우 -->
                &lt;/mappers>
        h2.marker mapper.xml
        +asCode('xml').
            &lt;if test="condition">sql&lt;/if>
            &lt;choose> &lt;when test="condition">sql&lt;/when> &lt;otherwise>sql&lt;/otherwise>
            &lt;where> &lt;if test="condition">sql&lt;/when> &lt;/where>
            &lt;set> &lt;if test="condition">sql&lt;/if> &lt;/set>
            &lt;foreach item="item" index...

    h1.marker Spring Framework
    div
        +asA('https://spring.io/projects/spring-framework#learn', 'spring-framework#learn')
        +asA('https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/index.html', 'spring-framework-reference')
        h2.marker Overview
        ul
            li JavaEE 앱 개발을 위한 프레임워크. 다른 JVM 언어(Groovy, Kotlin)도 지원한다.
            li Spring Framework 5에 추가된 WebFlux는 서블릿 컨테이너 대신 Netty 등의 리액티브 스트림 서버를 이용한다
            li Spring Framework는 순환적인 패키지 참조가 없는, 고도로 표준화된 코드를 유지한다.
            li 빠른 시작
            +asA('https://start.spring.io/', 'Spring Boot initializer')
            +asA('https://spring.io/guides#topical-guides')

        h2.marker Core
        div
            h3.marker IoC Container
            div
                h4.marker Introduction
                ul
                    li Dependency란?
                    p 객체가 정상적인 작동을 위해 필요로 하는 다른 객체
                    
                    li IoC(Inversion of Control), DI(Dependency Injection)란?
                    ul
                        li 객체 인스턴스화, 프로퍼티 설정을 Spring IoC 컨테이너가 대신 해준다.
                        li 의존성을 컨테이너가 주입(DI)한다.
                        li 의존성을 외부에서 설정하므로 제어의 역전(IoC)이 존재한다.
                    
                    li Bean이란?
                    p Spring IoC 컨테이너가 관리하는 인스턴스. 그 외 임의 인스턴스를 지칭해도 무방
                    
                    li 연관 패키지
                    p org.springframework.beans, org.springframework.context
                    
                    li ApplicationContext → BeanFactory 인터페이스
                    ul
                        li BeanFactory : 임의 타입 객체를 관리할 수 있는, DI 관련 최상위 인터페이스.
                        li ApplicationContext : AOP, 이벤트 발행 등 상용 애플리케이션에 쓰일 특징을 추가로 주입한다.

                h4.marker Container Overview
                p ApplicationContext는 메타데이터(XML, Java annotation Since 2.5, Java code Since 3.0)에 기술된 대로 클래스를 인스턴스화하고, 의존성을 주입한다.
                ol
                    li IoC 메타데이터 작성
                    li IoC Container 인스턴스화
                    li IoC Container 이용
                div
                    h5.marker XML 메타데이터
                    ul
                        li ClassPathXmlApplicationContext : 클래스 패스 상의 메타데이터 파일 이용
                        li FileSystemXmlApplicationContext : 파일 시스템 상의 메타데이터 파일 이용
                        li WebApplicationContext : web.xml 이용
                    div
                        h6.fake.marker 최상위 &lt;beans/> 안에 필요한 &lt;bean/>들을 정의한다
                        h6.fake.marker 다른 xml 포함
                        +asCode('xml').
                            &lt;beans>
                                &lt;import resource="other.xml"/>
                                &lt;import resource="dir/other.xml"/>
                            &lt;/beans>
                        p ↑ resource의 경로는 '/'로 시작하더라도 항상 현재 디렉터리에 대한 상대경로로 해석된다.

                    h5.marker Groovy DSL 메타데이터
                    +asCode('groovy', 'services.groovy').
                        beans {
                            myService(MyService) {
                                msg = "Hello World"
                            }
                        }
                    +asCode('java').
                        var context = new GenericGroovyApplicationContext("services.groovy");
                    h5.marker 메타데이터 혼용
                    p GenericApplicationContext를 이용하면 종류가 다른 메타데이터들을 혼용할 수 있다
                    +asCode('java').
                        var context = new GenericApplicationContext();
                        new XmlBeanDefinitionReader(context).loadBeanDefinitions("services.xml", "daos.xml");
                        new GroovyBeanDefinitionReader(context).loadBeanDefinitions("services.groovy", "daos.groovy");
                        context.refresh();
                
                h4.marker Bean Overview
                table.no-sort
                    caption
                        | 빈을 정의하는 요소 
                        +asA('https://docs.spring.io/spring/docs/5.3.0-SNAPSHOT/javadoc-api/org/springframework/beans/factory/config/BeanDefinition.html')
                    +tds('Class')
                    +tds('Name')
                    +tds('Scope')
                    +tds('Constructor arguments')
                    +tds('Properties')
                    +tds('Autowiring mode')
                    +tds('Lazy initialization mode')
                    +tds('Initialization method')
                    +tds('Destruction method')
                div
                    h5.marker Naming Beans
                    ul
                        li 모든 빈은 이름을 가지며, 지정하지 않더라도 자동 할당된다
                        li XML에서 빈 이름은 id 또는 name 속성으로 정의할 수 있다
                        p id는 컨테이너 전체에 걸쳐 고유해야 하며, name은 여러 이름을 ',', ';', ' '로 구분하여 설정할 수 있다
                        li 동일한 빈을 여러 이름으로 접근할 수 있다
                        +asCode('xml').
                            &lt;alias name="originalName" alias="alias1"/>
                            &lt;alias name="originalName" alias="alias2"/>
                    h5.marker Instantiating Beans
                    ul
                        li 빈 클래스로 static 클래스 지정 가능
                        +asCode('xml') &lt;bean class="com.example.SomeThing$OtherThing"/>
                        li 팩터리 메서드 지정 가능
                        +asCode('xml').
                            &lt;bean class="..." factory-method="newInstance"/>
                            &lt;bean factory-bean="beanName" factory-method="newInstance"/>
                        li 생성된 빈의 실제 타입은 BeanFactory#getType 메서드로 획득할 수 있다
                h4.marker Dependency Injection
                ul
                    li A가 B에 의존하고, 둘 사이에 순환 의존성이 존재하지 않는다면, A에 B가 주입되기 전에 B가 완전히 초기화됨이 보장된다
                    li.marker 생성자 주입 // 팩터리 메서드 인자도 동일한 태그를 사용한다
                    +asCode('xml').
                        &lt;constructor-arg index="0" type="java.lang.String" name="msg" value="Hell World"/>
                        &lt;constructor-arg value="Hell World"/>
                        &lt;constructor-arg ref="beanName"/>
                        &lt;constructor-arg>
                            &lt;ref bean="beanName"/>
                        &lt;/constructor-arg>
                    ul
                        li
                            | index, type, name은 모호성을 피하기 위해 사용하는 옵션 프로퍼티이며, name을 이용하는 경우 debug 컴파일하거나, 
                            +asA('https://docs.oracle.com/javase/8/docs/api/java/beans/ConstructorProperties.html')
                            | 를 이용해 이름을 탐색할 수 있게 해야한다.
                        li constructor-arg를 이용한 생성자 주입 예
                        +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/bean/Hello17.java', 'java') Bean
                        +codeBtn('/Repositories/Eclipse/app2/src/main/resource/Beans25.xml', 'xml') XML
                        +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/bean/Hello17Test.java', 'java') Context
                        li xmlns:c를 이용한 생성자 주입 예
                        ul
                            li
                                | 생성자 인자 이름을 알 수 있는 경우 예 : 
                                +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/bean/Hello17.java', 'java') Bean
                                +codeBtn('/Repositories/Eclipse/app2/src/main/resource/Beans26.xml', 'xml') XML
                                +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/bean/Hello17Test2.java', 'java') Context
                            li
                                | 생성자 인자 이름을 알 수 없는 경우 예 : 
                                +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/bean/Hello17.java', 'java') Bean
                                +codeBtn('/Repositories/Eclipse/app2/src/main/resource/Beans32.xml', 'xml') XML
                                +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/bean/Hello17Test4.java', 'java') Context

                    li.marker 세터 주입
                    +asCode('xml').
                        &lt;property name="message" value="Hello"/>
                        &lt;property name="message" ref="beanName"/>
                        &lt;property name="message">
                            &lt;ref bean="beanName"/>
                        &lt;/property>
                        &lt;property name="message">
                            &lt;bean class="java.lang.String" c:original="빈 메시지 2"/>
                        &lt;/property>
                    ul
                        li 인자 없는 생성자 또는 팩터리 메서드 호출 뒤, 세터를 호출하여 의존성을 주입한다
                        li property를 이용한 세터 주입 예
                        +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/bean/Hello1.java', 'java') Bean
                        +codeBtn('/Repositories/Eclipse/app2/src/main/resource/Beans1.xml', 'xml') XML
                        +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/bean/Hello1Test.java', 'java') Context
                        li p(property) xmlns:p를 이용한 세터 주입 예
                        +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/bean/Hello1.java', 'java') Bean
                        +codeBtn('/Repositories/Eclipse/app2/src/main/resource/Beans5.xml', 'xml') XML
                        +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/bean/Hello1Test2.java', 'java') Context

                    li.marker 기타 의존성 주입
                    table
                        +ths('종류', '예시 코드')
                        tr
                            td 익명 빈 생성
                            td
                                +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/bean/Hello17.java', 'java') Bean
                                +codeBtn('/Repositories/Eclipse/app2/src/main/resource/Beans27.xml', 'xml') XML
                                +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/bean/Hello17Test3.java', 'java') Context
                        tr
                            td 의존 빈 주입
                            td
                                | property, constructor-arg 태그 안에서 이용하는 bean 태그들은 id, name이 필요없으며, 지정해도 무시된다.
                                +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/bean/Hello1.java', 'java') Bean1
                                +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/bean/Hello17.java', 'java') Bean2
                                +codeBtn('/Repositories/Eclipse/app2/src/main/resource/Beans7.xml', 'xml') XML
                                +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/bean/Hello4Test3.java', 'java') Context
                        tr
                            td 의존 컬렉션 주입
                            td
                                | 자바 기본 타입 및 String은 문자열로부터 알아서 변환되어 주입된다.
                                |  반면 배열, List, Properties, Map 등은 전용 태그를 이용하거나, 다른 팩터리 메서드를 빌려 설정해야 한다.
                                +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/bean/Hello5.java', 'java') Bean
                                +codeBtn('/Repositories/Eclipse/app2/src/main/resource/Beans8.xml', 'xml') XML
                                +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/bean/Hello5Test.java', 'java') Context
                        tr
                            td 팩터리를 통한 의존 컬렉션 주입
                            td
                                +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/bean/Hello5.java', 'java') Bean
                                +codeBtn('/Repositories/Eclipse/app2/src/main/resource/Beans10.xml', 'xml') XML
                                +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/bean/Hello5Test3.java', 'java') Context
                        tr
                            td xmlns:util을 이용한 의존 컬렉션 주입
                            td
                                +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/bean/Hello5.java', 'java') Bean
                                +codeBtn('/Repositories/Eclipse/app2/src/main/resource/Beans9.xml', 'xml') XML
                                +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/bean/Hello5Test2.java', 'java') Context
                        tr
                            td parent 속성을 통한 상속
                            td
                                p
                                    | 값 상속 예 : 
                                    +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/bean/Hello1.java', 'java') Bean
                                    +codeBtn('/Repositories/Eclipse/app2/src/main/resource/Beans11.xml', 'xml') XML
                                    +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/bean/Hello1Test3.java', 'java') Context
                                p
                                    | 컬렉션 상속(merge="true") 예 : 
                                    +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/bean/Hello5.java', 'java') Bean
                                    +codeBtn('/Repositories/Eclipse/app2/src/main/resource/Beans31.xml', 'xml') XML
                                    +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/bean/Hello5Test4.java', 'java') Context
                        tr
                            td parent context를 이용한 상속
                            td
                                +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/bean/Hello18.java', 'java') Interface
                                +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/bean/Hello18Impl.java', 'java') Impl
                                +codeBtn('/Repositories/Eclipse/app2/src/main/resource/Beans29.xml', 'xml') parent XML
                                +codeBtn('/Repositories/Eclipse/app2/src/main/resource/Beans30.xml', 'xml') child XML
                                +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/bean/Hello18Test.java', 'java') Context
                        tr
                            td lookup-method를 통한 프록시
                            td
                                ul
                                    +pos('lookup-method')
                                    li name : 재정의할 메서드 이름 → private X, void 반환 X, 메서드 매개변수 X, final X
                                    li bean : 재정의한 메서드에서 반환할 객체
                                    +codeBtn('/Repositories/Eclipse/app2/src/main/resource/Beans19.xml', 'xml') XML
                                    +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/bean/Beans19Test.java', 'java') Context
                        tr
                            td replaced-method를 통한 프록시
                            td
                                ul
                                    li name : 재정의할 메서드 이름
                                    li replacer : MethodReplacer 구현체
                                    +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/bean/Hello22.java', 'java') Bean
                                    +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/bean/Hello22Replacement.java', 'java') MethodReplacer
                                    +codeBtn('/Repositories/Eclipse/app2/src/main/resource/Beans36.xml', 'xml') XML
                                    +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/bean/Hello22Test.java', 'java') Context
                        tr
                            td Compound property name을 이용한 내부 빈 속성 설정
                            td
                                +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/bean/Hello19.java', 'java') Bean
                                +codeBtn('/Repositories/Eclipse/app2/src/main/resource/Beans33.xml', 'xml') XML
                                +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/bean/Hello19Test.java', 'java') Context
                        tr
                            td
                                +pos('depends-on')
                                | depends-on을 이용한 빈 생성 순서 설정
                            td
                                | has-a 관계보다 약한 의존 관계에서, depends-on을 이용해 특정 빈이 먼저 생성되도록 강제할 수 있다.
                                |  양쪽 빈 모두 싱글톤인 경우, 객체 소멸 순서도 정해진다.
                                +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/bean/Hello20.java', 'java') Bean
                                +codeBtn('/Repositories/Eclipse/app2/src/main/resource/Beans34.xml', 'xml') XML
                                +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/bean/Hello20Test.java', 'java') Context
                        tr
                            td lazy-init을 이용한 빈 생성 늦추기
                            td
                                +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/bean/Hello21.java', 'java') Bean
                                +codeBtn('/Repositories/Eclipse/app2/src/main/resource/Beans35.xml', 'xml') XML
                                +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/bean/Hello21Test.java', 'java') Context
                div
                    h5.marker Autowire
                    ul
                        li IoC 컨테이너가 관리중인 빈들을 자동으로 주입하도록 구성할 수 있다. XML에서는 bean 태그의 autowire 속성으로 제어하며, 아래 4가지 모드가 가능하다
                        table
                            +ths('mode', '설명')
                            +tds('no', '기본 설정. 모든 의존성은 명시되어야 한다.')
                            +tds('byName', '이름이 일치하는 빈을 주입한다')
                            +tds('byType', '타입이 일치하는 빈을 주입한다. 일치하는 빈이 2개 이상이면 에러, 0개면 미설정')
                            +tds('constructor', '생성자에 적용되는 byType')
                        li 명시된 의존성은 항상 autowire보다 우선이며, 자바 기본 타입은 autowire 할 수 없다.
                        li bean 정의 시 autowire-candidate 속성을 false로 하면, type 매치 주입물이 되지 않는다
                        li beans 정의 시 default-autowire-candidates를 이용해 autowire 주입물을 제한할 수 있다
                        +asCode('xml') &lt;beans ... default-autowire-candidates="*Service,*Dao" />
                        li bean 정의 시 primary 속성을 true로 하면, 최우선 autowire 주입물이 된다
                        li
                            | 예시 
                            +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/bean/Hello15.java', 'java') Bean1
                            +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/bean/Hello16.java', 'java') Bean2
                            +codeBtn('/Repositories/Eclipse/app2/src/main/resource/Beans12.xml', 'xml') XML
                            +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/bean/Hello15Test3.java', 'java') Context

                h4.marker Bean Scope
                ul
                    li 빈의 유효 기간을 설정할 수 있다. 아래 6가지는 빈 설정 시 기본으로 이용할 수 있는 목록이다.
                    table
                        +ths('Scope', '설명')
                        +tds('singleton', '기본값. 컨테이너에서 하나의 인스턴스만 생성')
                        +tds('prototype', '빈 요청마다 새 인스턴스 생성. 컨테이너는 prototype 빈의 일부 lifecycle만 관리하며, 생성 이후 lifecycle은 클라이언트가 책임져야 한다')
                        +tds('request', 'HTTP 요청마다 새 인스턴스 생성. Web 관련 ApplicationContext에서 지정 가능')
                        +tds('session', 'HTTP 세션마다 새 인스턴스 생성. Web 관련 ApplicationContext에서 지정 가능')
                        +tds('application', 'ServletContext마다 새 인스턴스 생성. Web 관련 ApplicationContext에서 지정 가능')
                        +tds('websocket', 'WebSocket마다 새 인스턴스 생성. Web 관련 ApplicationContext에서 지정 가능')
                    li Spring 3.0부터 스레드 단위로 인스턴스를 생성하는 SimpleThreadScope가 추가되었다.
                    p ConfigurableBeanFactory.registerScope(String, Scope) 또는 CustomScopeConfigurer로 사용 가능
                    +pos('scope 예')
                    li request, session, application 예
                    +codeBtn('/Repositories/STS/ioc-example/src/main/java/io/github/donggi/example/entity/PerApp.java', 'java') Bean per App
                    +codeBtn('/Repositories/STS/ioc-example/src/main/java/io/github/donggi/example/entity/PerRequest.java', 'java') Bean per Request
                    +codeBtn('/Repositories/STS/ioc-example/src/main/java/io/github/donggi/example/entity/PerSession.java', 'java') Bean per Session
                    +codeBtn('/Repositories/STS/ioc-example/src/main/java/io/github/donggi/example/controller/ScopeController.java', 'java', '[27,55]') Controller
                    li 기본적으로 빈에 주입된 의존 객체는 컨테이너에 의해 다시 설정되지 않는다.
                    p
                        | 만일 스코프가 더 좁은 빈을 의존하지만 참조 시마다 새로운 인스턴스가 필요한 경우, 해당 메서드를 재정의하거나, aop:scoped-proxy를 이용하면 된다.
                        |  AOP proxy 인스턴스는 직렬화 가능하며, 직렬화 전 참조 객체와 역직렬화 후 참조 객체는 동일하다.
                    p 다른 방법으로 ObjectFactory#getObject(), ObjectProvider(→ ObjectFactory)의 getIfAvailable(), getIfUnique()을 이용할 수도 있다
                    p
                        span.hover-content(template-id='template-jsr330') JSR-330
                        | 에서는 Provider가 위와 비슷한 기능을 제공한다.
                    table.no-sort
                        tr
                            td 아무 설정 없는 예
                            td
                                +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/bean/Hello15.java', 'java') Bean1
                                +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/bean/Hello16.java', 'java') Bean2
                                +codeBtn('/Repositories/Eclipse/app2/src/main/resource/Beans20.xml', 'xml') XML
                                +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/bean/Hello15Test.java', 'java') Context
                        tr
                            td 메서드 재정의 예
                            td
                                +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/bean/Hello15.java', 'java') Bean1
                                +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/bean/Hello16.java', 'java') Bean2
                                +codeBtn('/Repositories/Eclipse/app2/src/main/resource/Beans37.xml', 'xml') XML
                                +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/bean/Hello15Test5.java', 'java') Context
                        tr
                            td aop:scoped-proxy 예
                            td
                                +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/bean/Hello15.java', 'java') Bean1
                                +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/bean/Hello16.java', 'java') Bean2
                                +codeBtn('/Repositories/Eclipse/app2/src/main/resource/Beans21.xml', 'xml') XML
                                +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/bean/Hello15Test4.java', 'java') Context
                        tr
                            td Custom Scope 예
                            td
                                +codeBtn('/Repositories/STS/ioc-example/src/main/java/io/github/donggi/example/entity/PerMinute.java', 'java') Bean per Minute
                                +codeBtn('/Repositories/STS/ioc-example/src/main/java/io/github/donggi/example/scope/MinuteScope.java', 'java') Custom Scope
                                +codeBtn('/Repositories/STS/ioc-example/src/main/java/io/github/donggi/example/config/MinuteBeanFactoryPostProcessor.java', 'java') PostBeanProcessor
                                +codeBtn('/Repositories/STS/ioc-example/src/main/java/io/github/donggi/example/config/AppConfig.java', 'java') AppConfig
                                +codeBtn('/Repositories/STS/ioc-example/src/main/java/io/github/donggi/example/controller/ScopeController.java', 'java', '[57,70]') Controller
                                p aop:scoped-proxy 설정을 하고 싶다면 @Scope의 proxyMode 변수를 설정
                                ul
                                    li NO : default. 프록시 없음
                                    li INTERFACES : 인터페이스 프록시 생성. JDK 동적 프록시 이용
                                    li TARGET_CLASS : 클래스 프록시 생성. CGLIB 이용

                h4.marker Bean 커스터마이징
                div
                    h5.marker Lifecycle Callback
                    ul
                        li
                            | InitializingBean, DisposableBean 예 
                            +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/bean/Hello2.java', 'java') Bean
                            +codeBtn('/Repositories/Eclipse/app2/src/main/resource/Beans2.xml', 'xml') XML
                            +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/bean/Hello2Test.java', 'java') Context
                        li
                            | Lifecycle 예 
                            +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/bean/Hello29.java', 'java') Bean
                            +codeBtn('/Repositories/Eclipse/app2/src/main/resource/Beans46.xml', 'xml') XML
                            +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/bean/Hello29Test.java', 'java') Context
                        li
                            | init-method, destroy-method 예 
                            +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/bean/Hello3.java', 'java') Bean
                            +codeBtn('/Repositories/Eclipse/app2/src/main/resource/Beans3.xml', 'xml') XML
                            +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/bean/Hello3Test.java', 'java') Context
                        li
                            | destroy-method로 (inferred)를 설정하면 public close() 또는 shutdown()을 찾아 실행한다 
                            +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/bean/Hello23.java', 'java') Bean
                            +codeBtn('/Repositories/Eclipse/app2/src/main/resource/Beans38.xml', 'xml') XML
                            +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/bean/Hello23Test.java', 'java') Context
                        li
                            | default-init-method, default-destroy-method 예 
                            +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/bean/Hello24.java', 'java') Bean
                            +codeBtn('/Repositories/Eclipse/app2/src/main/resource/Beans39.xml', 'xml') XML
                            +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/bean/Hello24Test.java', 'java') Context
                        li
                            | JSR-250 : @PostConstruct, @PreDestroy 예 
                            +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/anno/Anno21.java', 'java') Bean
                            +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/anno/Anno21Test.java', 'java') Context
                        li 위 설정들은 중복이 가능하며, 서로 다른 메서드들로 설정된 경우 아래 순서대로 실행된다
                        ul
                            li @PostConstruct → InitializingBean → init-method
                            li @PreDestroy → DisposableBean → destroy-method
                        li
                            | ConfigurableApplicationContext#registerShutdownHook 예 
                            +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/bean/Hello4Test.java', 'java') Context
                    h5.marker Aware
                    ul
                        li
                            | ApplicationContextAware 인터페이스를 구현한 경우, 빈 생성 후 어떤 컨텍스트가 만들었는지 알 수 있다. 
                            +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/bean/Hello25.java', 'java') Bean
                            +codeBtn('/Repositories/Eclipse/app2/src/main/resource/Beans40.xml', 'xml') XML
                            +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/bean/Hello25Test.java', 'java') Context
                        li
                            | BeanNameAware 인터페이스를 구현한 경우, 빈 생성 후 어떤 이름으로 만들었는지 알 수 있다. 
                            +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/bean/Hello26.java', 'java') Bean
                            +codeBtn('/Repositories/Eclipse/app2/src/main/resource/Beans41.xml', 'xml') XML
                            +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/bean/Hello26Test.java', 'java') Context
                    +asA('https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aware-list')
                    table
                        +ths('interface', '주입물')
                        +tds('ApplicationEventPublisherAware', 'ApplicationEventPublisher')
                        +tds('BeanClassLoaderAware', 'ClassLoader')
                        +tds('BeanFactoryAware', 'BeanFactory')
                        +tds('LoadTimeWeaverAware', 'LoadTimeWeaver')
                        +tds('MessageSourceAware', 'MessageSource')
                        +tds('ResourceLoaderAware', 'ResourceLoader')
                        +tds('ServletConfigAware', 'ServletConfig')
                        +tds('ServletContextAware', 'ServletContext')

                h4.marker 컨테이너 확장
                p ApplicationContext를 직접 상속하지 않고, 여러 인터페이스 구현체를 등록함으로써 기능 확장이 가능하다.
                ul
                    li
                        | BeanPostProcessor 
                        +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/bean/Hello27.java', 'java') Bean
                        +codeBtn('/Repositories/Eclipse/app2/src/main/resource/Beans42.xml', 'xml') XML
                        +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/bean/Hello27Test.java', 'java') Context
                    p 인스턴스 생성 후, 초기화 콜백 호출 전/후 작업을 추가할 수 있다. 여러 BeanPostProcessor를 등록하는 경우, order 속성(Ordered 인터페이스)으로 실행 순서를 제어할 수 있다.
                    p ApplicationContext#addBeanPostProcessor를 이용해 직접 등록하는 경우, Ordered 인터페이스를 구현해도 무시하며, 직접 등록된 순서대로 실행된다. 자동으로 탐색된 다른 BeanPostProcessor들보다 항상 먼저 실행된다.
                    li BeanFactoryPostProcessor
                    p 빈을 생성하기 전에 컨테이너 관련 설정을 변경할 수 있다. 여러 BeanFactoryPostProcessor를 등록하는 경우, order 속성(Ordered 인터페이스)으로 순서를 제어할 수 있다
                    ul
                        li
                            | PropertySourcesPlaceholderConfigurer 예 
                            +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/bean/Hello1.java', 'java') Bean1
                            +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/bean/Hello17.java', 'java') Bean2
                            +codeBtn('/Repositories/Eclipse/app2/src/main/resource/Beans43.xml', 'xml') XML
                            +codeBtn('/Repositories/Eclipse/app2/src/main/resource/beans43-1.properties', 'properties') properties1
                            +codeBtn('/Repositories/Eclipse/app2/src/main/resource/beans43-2.properties', 'properties') properties2
                            +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/bean/Hello17Test5.java', 'java') Context
                        li
                            | PropertyOverrideConfigurer 예 
                            +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/bean/Hello1.java', 'java') Bean1
                            +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/bean/Hello17.java', 'java') Bean2
                            +codeBtn('/Repositories/Eclipse/app2/src/main/resource/Beans44.xml', 'xml') XML
                            +codeBtn('/Repositories/Eclipse/app2/src/main/resource/beans43-1.properties', 'properties') properties1
                            +codeBtn('/Repositories/Eclipse/app2/src/main/resource/beans43-2.properties', 'properties') properties2
                            +codeBtn('/Repositories/Eclipse/app2/src/main/resource/beans44.properties', 'properties') properties3
                            +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/bean/Hello17Test6.java', 'java') Context
                    li
                        | FactoryBean
                        +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/bean/Hello28.java', 'java') Bean
                        +codeBtn('/Repositories/Eclipse/app2/src/main/resource/Beans45.xml', 'xml') XML
                        +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/bean/Hello28Test.java', 'java') Context
                    p 빈 생성 절차를 XML보다 Java로 표현하는 것이 효율적인 경우, FactoryBean을 컨테이너에 등록할 수 있다

                h4.marker Annotation 기반 설정
                ul
                    li XML 기반 설정과 같이 이용하는 경우, Annotation 기반 처리가 먼저 이뤄짐에 유의.
                    li
                        | context:annotation-config 
                        +codeBtn('/Repositories/Eclipse/app2/src/main/resource/anno01.xml', 'xml') XML
                    p ↑ 컨테이너에 등록된 빈에 대하여 애너테이션 처리
                    li
                        | context:component-scan 
                        +codeBtn('/Repositories/Eclipse/app2/src/main/resource/anno02.xml', 'xml') XML
                    p ↑ 기준 패키지의 모든 클래스를 탐색하여 자동으로 빈 등록, DI, 기타 애너테이션 처리
                    li
                        | XML을 아예 사용하지 않고도 구성 가능하다 
                        +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/anno/Anno02.java', 'java') Bean
                        +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/anno/Anno02Test2.java', 'java') Context
                    li @Autowired, @Inject, @Value, @Resource는 BeanPostProcessor 구현체가 처리하므로, 사용자 정의 BeanPostProcessor 또는 BeanFactoryPostProcessor 클래스 안에서 해당 애너테이션들을 적용할 수 없다. 대신 @Bean을 이용해야 한다.
                    li Since JDK 9 : 스캔 대상 패키지가 module-info에서 exports 됐는지, non-public 메서드를 호출해야 되는 패키지가 opens(exports 말고) 됐는지 확인 필요
                table
                    +ths('Annotation', '대응 코드', '예시 코드')
                    tr
                        td @Component
                        td xml: bean
                        td: ul
                            li 해당 타입이 빈 생성 대상임을 나타낸다
                            li value로 빈 이름을 설정할 수 있다. ""(default)면 자동 할당
                            li @Repository : Persistence layer
                            li @Service : Service layer
                            li @Controller : Presentation layer
                            li @Configuration : @Bean 메서드들을 갖는 구성 클래스
                            p
                                | @Configuration 클래스 안에서 형제 @Bean 메서드 호출은 의존 관계의 정의를 의미한다 
                                +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/anno/Anno26.java', 'java') Configuration
                                +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/anno/Anno26Test.java', 'java') Context
                            li @RestController = @Controller + @ResponseBody
                            li 기타 사용자 정의 애너테이션도 가능
                    tr
                        td @Bean
                        td xml: bean
                        td: ul
                            li 팩터리 메서드에 적용하여 빈 생성 대상임을 나타낸다
                            li static 메서드에 적용하는 경우 프록시를 통하지 않고 호출된다
                            li name으로 빈 별명을 설정할 수 있다
                            li initMethod를 설정할 수 있다 ← 메서드 바디에서 호출하면 되므로 쓸 일은 별로 없을듯
                            li destroyMethod를 설정할 수 있다
                            p 기본값은 "(inferred)"로, 자동으로 public close() 또는 shutdown()을 찾아 실행한다. 아무것도 호출하고 싶지 않다면 ""로 설정하면 된다.
                            p JNDI로 가져온 리소스 ─ 특히 DataSource들은 외부에서 생애가 관리되므로 destroyMethod="" 설정함이 바람직하다
                    tr
                        td @Conditional
                        td
                        td Condition 인터페이스 구현체를 지정하여, @Component, @Configuration, @Bean 초기화를 진행할 지 여부를 미리 판단한다
                    tr
                        td
                            +pos('@Profile')
                            | @Profile
                        td xml: beans profile=""
                        td
                            | @Conditional(value=org.springframework.context.annotation.ProfileCondition.class) → active profile을 기준으로 판단한다
                            +goto('profile 표현식')
                    tr
                        td @Autowired
                        td xml: autowire
                        td: ul
                            li 적용 위치 : CONSTRUCTOR, FIELD, METHOD, PARAMETER
                            li
                                | CONSTRUCTOR 적용 예 
                                +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/anno/Anno03.java', 'java') Bean
                                +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/anno/Anno03Test.java', 'java') Context
                            p Since 4.3 : 기본 생성자가 없으면서 여러 생성자가 존재하는 경우에만 생성자에 @Autowired 적용 필요
                            li
                                | FIELD 적용 예 
                                +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/anno/Anno01.java', 'java') Bean
                                +codeBtn('/Repositories/Eclipse/app2/src/main/resource/anno01.xml', 'xml') XML
                                +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/anno/Anno01Test.java', 'java') Context
                            li 특정 타입 T의 배열(T[])/컬렉션(Collection&lt;T>)/맵(Map&lt;String, T>에 적용한 경우, 해당 타입의 모든 빈을 목록으로 설정해준다.
                            p 타깃 타입이 org.springframework.core.Ordered를 구현했거나, @Order, @Priority를 갖고 있으면 정렬하여 설정해준다
                            ul
                                li
                                    | Array FIELD 적용 예 
                                    +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/anno/Anno02.java', 'java') Bean
                                    +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/anno/Anno02Test.java', 'java') Context
                                li
                                    | Set FIELD 적용 예 
                                    +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/anno/Anno05.java', 'java') Bean
                                    +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/anno/Anno05Test.java', 'java') Context
                                li
                                    | Map FIELD 적용 예 
                                    +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/anno/Anno06.java', 'java') Bean
                                    +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/anno/Anno06Test.java', 'java') Context
                            li required = false
                            ul
                                li
                                    | FIELD, METHOD에 required = false 적용 예 
                                    +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/anno/Anno07.java', 'java') Bean
                                    +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/anno/Anno07Test.java', 'java') Context
                                p 의존 객체가 하나라도 누락되면 호출을 생략한다. → 따라서 기본값 그대로 남는다.
                                li 팩터리 메서드, CONSTRUCTOR에 required = false 적용
                                p 배열, Collection, Map인자로 매칭되는 빈이 없는 경우, empty 인스턴스를 넘겨 호출한다.
                                li
                                    | ↑ 이는 @Autowired가 없는 단일 생성자를 갖는 일반 클래스에도 적용된다 
                                    +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/anno/Anno08.java', 'java') Bean
                                    +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/anno/Anno08Test.java', 'java') Context
                            li
                                | METHOD 적용 예 
                                +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/anno/Anno04.java', 'java') Bean
                                +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/anno/Anno04Test.java', 'java') Context
                            li
                                | 인자가 있든 없든 호출되길 원한다면 Optional 또는 @Nullable(Since 5.0)을 이용하면 된다 
                                +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/anno/Anno09.java', 'java') Bean
                                +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/anno/Anno09Test.java', 'java') Context
                            li 아래의 인터페이스 및 연관 구현 클래스에 대한 @Autowired 필드는 실행 환경에 따라 적절히 주입된다.
                            p BeanFactory, ApplicationContext, Environment, ResourceLoader, ApplicationEventPublisher, MessageSource
                    tr
                        td @Primary
                        td xml: primary="true"
                        td
                            | 특정 빈을 우선적으로 주입하도록 설정한다 
                            +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/anno/Anno10.java', 'java') Bean
                            +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/anno/Anno10Test.java', 'java') Context
                    tr
                        td @Qualifier
                        td
                            | xml: qualifier value="xxx"
                            br
                            | xml: qualifier type="x.y.Z" value="xxx"
                        td: ul
                            li
                                | 빈을 구별할 수 있는 값을 설정한다. 빈 이름은 default qualifier로 이용됨에 유의. 
                                +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/anno/Anno11.java', 'java') Bean
                                +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/anno/Anno11Test.java', 'java') Context
                            li Qualifier는 고유할 필요가 없으며, 배열/컬렉션/맵 주입 시 qualifier가 일치하는 모든 빈들이 멤버로 할당된다
                            li @Autowired와 같이 사용하는 경우, 타입 기반 매칭이 먼저 수행됨에 유의. Qualifier 매칭만 수행하려는 경우 JSR-250의 @Resource를 이용할 것.
                            li
                                | 사용자 정의 @Qualifier를 이용할 수 있다 
                                +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/anno/Anno12.java', 'java') Bean
                                +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/anno/Anno12Test.java', 'java') Context
                            li
                                | 사용자 정의 @Qualifier는 값 없이도 빈 특정이 가능할 수 있다 
                                +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/anno/Anno13.java', 'java') Bean
                                +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/anno/Anno13Test.java', 'java') Context
                            li
                                | 사용자 정의 @Qualifier는 다른 타입 속성들을 가질 수 있다 
                                +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/anno/Anno14.java', 'java') Bean
                                +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/anno/Anno14Test.java', 'java') Context
                            li
                                | Generic도 일종의 타입 Qualifier로 이용할 수 있다
                                +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/anno/Anno15.java', 'java') Bean
                                +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/anno/Anno15Test.java', 'java') Context
                    tr
                        td @Resource
                        td xml: ref="beanName"
                        td: ul
                            li
                                | 빈 이름을 기준으로 주입한다 
                                +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/anno/Anno16.java', 'java') Bean
                                +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/anno/Anno16Test.java', 'java') Context
                            li name 속성을 지정하지 않으면 field 또는 parameter 이름을 기준으로 찾는다
                            li
                                | 이름을 기준으로 찾지 못하면 타입을 기준으로 다시 찾는다 
                                +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/anno/Anno17.java', 'java') Bean
                                +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/anno/Anno17Test.java', 'java') Context
                    tr
                        td @Value
                        td xml: context:property-placeholder
                        td: ul
                            li
                                | 외부 *.properties 파일 기반으로 값 주입
                                +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/anno/Anno18.java', 'java') Bean
                                +codeBtn('/Repositories/Eclipse/app2/src/main/resource/anno18.properties', 'properties') properties
                                +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/anno/Anno18Test.java', 'java') Context
                            li @Bean static 메서드로 PropertySourcesPlaceholderConfigurer 인스턴스를 반환하면 커스터마이징 가능하다
                            li Spring Boot 애플리케이션은 기본적으로 application.properties, application.yml 파일을 읽는 PropertySourcesPlaceholderConfigurer 빈을 갖는다
                            li 프로퍼티 문자열 → Java Type으로의 변환
                            p
                                | BeanPostProcessor는 ConversionService를 이용해 타입 변환을 수행한다. 커스텀 컨버터를 등록하면 사용자 정의 타입으로의 변환도 가능하다 
                                +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/anno/Anno19.java', 'java') Bean
                                +codeBtn('/Repositories/Eclipse/app2/src/main/resource/anno19.properties', 'properties') properties
                                +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/anno/Anno19Test.java', 'java') Context
                            li
                                | SpEL 표현식도 가능하다 
                                +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/anno/Anno20.java', 'java') Bean
                                +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/anno/Anno20Test.java', 'java') Context
                    tr
                        td @PostConstruct
                        td xml: init-method
                        td
                            | 빈 생성 후 호출 
                            +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/anno/Anno21.java', 'java') Bean
                            +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/anno/Anno21Test.java', 'java') Context
                    tr
                        td @PreDestroy
                        td xml: destroy-method
                        td
                            | 빈 소멸 시 호출
                            +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/anno/Anno21.java', 'java') Bean
                            +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/anno/Anno21Test.java', 'java') Context
                    tr
                        td @ComponentScan
                        td xml: context:component-scan base-package=""
                        td: ul
                            li
                                | 스캔 범위를 확장한다 
                                +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/anno/Anno22.java', 'java') Configuration
                                +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/rare/Rare1.java', 'java') Bean
                                +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/anno/Anno22Test.java', 'java') Context
                            li
                                | includeFilters == xml: context:include-filter 
                            p ↑ 명시적으로 매칭되는 클래스만 스캔
                            li
                                | excludeFilters == xml: context:exclude-filter
                            p ↑ 매칭되는 클래스는 스캔 제외
                            li useDefaultFilters=false == xml: use-default-filters="false"
                            p ↑ @Component, @Repository, @Service 등을 자동으로 찾지 않는다.
                            li 필터 종류
                            ul
                                li
                                    | annotation(default) : 타입에 특정 애너테이션이 붙어있는지? 
                                    +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/anno/Anno23.java', 'java') Configuration
                                li
                                    | assignable : 특정 타입으로 할당 가능한지? 
                                    +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/anno/Anno23.java', 'java') Configuration
                                li
                                    | aspectj : 클래스 경로가 AspectJ 표현식에 일치하는지? 
                                    +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/anno/Anno24.java', 'java') Configuration
                                +asCode('gradle', 'AspectJ 관련 jar들을 포함해야 한다. Spring Boot 예') implementation 'org.springframework.boot:spring-boot-starter-aop'
                                li
                                    | regex : 클래스 경로가 정규표현식에 일치하는지? 
                                    +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/anno/Anno24.java', 'java') Configuration
                                li
                                    | custom : TypeFilter 구현 클래스 지정 
                                    +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/anno/Anno25.java', 'java') Configuration
                                    +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/scan/ScanFilter.java', 'java') TypeFilter
                                    +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/anno/Anno25Test.java', 'java') Context
                            li nameGenerator == xml: name-generator
                            p 스프링 기본 네이밍이 맞지 않는 경우 BeanNameGenerator 구현체를 직접 제공해도 된다. 특히 같은 이름의 클래스가 여러 패키지에 존재하는 경우, 클래스 풀네임을 이름으로 제공하는 FullyQualifiedAnnotationBeanNameGenerator(Since 5.2.3)도 고려해봄직하다.
                            li scopeResolver == xml: scope-resolver
                            p 애너테이션 기반 스코핑이 불충분하다면, 직접 ScopeMetadataResolver 구현체를 제공할 수 있다.
                            li scopedProxy == xml: scoped-proxy
                            p singleton 외 스코프 빈에 대한 기본 프록시 설정 가능.
                            ul
                                li NO : default. 프록시 없음
                                li INTERFACES : 인터페이스 프록시 생성. JDK 동적 프록시 이용
                                li TARGET_CLASS : 클래스 프록시 생성. CGLIB 이용
                    tr
                        td @Inject
                        td @Autowired
                        td
                            span.hover-content(template-id='template-jsr330') JSR-330
                            ul
                                li
                                    | @Autowire와 마찬가지로 필드, 메서드, 생성자에 적용 가능 
                                    +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/jsr330/Anno01.java', 'java') Configuration
                                    +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/jsr330/Anno01Test.java', 'java') Context
                                li
                                    | @Named로 이름 지정 가능 
                                    +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/jsr330/Anno02.java', 'java') Configuration
                                    +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/jsr330/Anno02Test.java', 'java') Context
                                p @Named는 주입/생성 빈 이름 모두에 사용할 수 있다
                                li
                                    | Provider를 이용하여 지연된 접근, 짧은 scope 빈 접근 가능 
                                    +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/jsr330/Anno03.java', 'java') Configuration
                                    +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/jsr330/Anno03Test.java', 'java') Context
                                li
                                    | Optional 또는 @Nullable도 사용 가능 
                                    +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/jsr330/Anno04.java', 'java') Configuration
                                    +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/jsr330/Anno04Test.java', 'java') Context
                    tr
                        td @Named, @ManagedBean
                        td @Component
                        td 
                            span.hover-content(template-id='template-jsr330') JSR-330.
                            |  타입에 적용하는 경우 자동 생성 대상임을 나타낸다. 속성으로 이름을 지정하지 않는 경우 자동으로 할당된다.
                    tr
                        td @Singleton
                        td @Scope("singleton")
                        td 
                            span.hover-content(template-id='template-jsr330') JSR-330
                            | 의 기본 scope는 prototype이지만, 스프링 컨테이너는 singleton으로 처리한다. 따라서 이 애너테이션은 사용자 정의 스코프 정의에만 이용하면 된다.
                    tr
                        td @Qualifier, @Named
                        td @Qualifier
                        td 
                            span.hover-content(template-id='template-jsr330') JSR-330.
                            |  javax.inject.Qualifier는 사용자 정의 Qualifier를 위해 존재하며, @Named는 String qualifier 구현체로 이용할 수 있다.
                    tr
                        td @Import, @ImportResource
                        td xml: import
                        td: ul
                            li
                                | @Import : @Configuration에서 다른 @Configuration 임포트 
                                +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/anno/Anno27.java', 'java') Configuration
                                +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/anno/Anno27Test.java', 'java') Context
                            +asCode('java').
                                @Configuration
                                @Import({OtherConfiguration.class})
                                public class MyConfiguration {}
                            li
                                | @ImportResource : @Configuration 다른 xml 임포트 
                                +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/anno/Anno28.java', 'java') Configuration
                                +codeBtn('/Repositories/Eclipse/app2/src/main/resource/anno28.xml', 'xml') XML
                                +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/anno/Anno28Test.java', 'java') Context
                            +asCode('java').
                                @Configuration
                                @ImportResource("file:src/main/resource/otherConfig.xml")
                                public class MyConfiguration {}
                                
                                @Configuration
                                @ImportResource("classpath:/otherConfig.xml")
                                public class MyConfiguration {}
                            li xml에서 @Configuration 임포트는 context:component-scan, context:component-scan 또는 그냥 bean 이용
                    tr
                        td @DependsOn
                        td xml: depends-on
                        td: +goto('depends-on')
                    tr
                        td @lookup
                        td xml: lookup-method
                        td: +goto('lookup-method')
                    tr
                        td @RequestScope
                        td xml: scope="request"
                        td: +goto('scope 예')
                    tr
                        td @SessionScope
                        td xml: scope="session"
                        td: +goto('scope 예')
                    tr
                        td @ApplicationScope
                        td xml: scope="application"
                        td: +goto('scope 예')
                    tr
                        td @Description
                        td xml: description
                        td 빈에 대한 설명(Optional)
                    tr
                        td @EnableLoadTimeWeaving
                        td xml: context:load-time-weaver
                        td
                            | LoadTimeWeaverAware를 구현한 빈은 LoadTimeWeaver 인스턴스를 인자로 받는다
                            +goto('Spring AOP')

                h4.marker Environment
                ul
                    li Environment 인터페이스는 profile, properties 정보를 컨테이너에 제공한다
                    +pos('profile 표현식')
                    li
                        | Profile 표현에 !(not), &amp;(and), |(or) 가능. 
                        +goto('@Profile')
                    p
                        | 예. production &amp; (us-east | eu-central)
                        br
                        | xml 표현식에서 !는 가능하지만 &amp;, |는 포함할 수 없다. 대신 beans profiles=""를 중첩하여 &amp; 효과를 얻을 수는 있다
                    li Profile 활성화
                    +asCode('java').
                        context.getEnvironment().setDefaultProfiles("profile1", "profile2")
                        context.getEnvironment().setActiveProfiles("profile1", "profile2")
                    +asCode('shell') $ env "spring.profiles.active=profile1,profile2"
                    +asCode('shell') $ java ... -Dspring.profiles.active="profile1,profile2"
                    li 제공할 수 있는 properties 타입
                    p properties 파일, JNDI, Servlet context parameter, Properties 인스턴스, Map 인스턴스
                    li StandardEnvironment(→ AbstractEnvironment) 기본 포함 properties
                    p JVM system properties (System.getProperties()) + 환경 변수 (System.getenv()). 시스템 속성이 환경 변수보다 우선 검색된다
                    li StandardServletEnvironment(→ StandardEnvironment) 추가 제공 properties
                    p
                        | Servlet config + Servlet context parameter + JndiPropertySource(Optional).
                        br
                        | 우선 순위 : ServletConfig ← ServletContext parameter ← JNDI ← JVM system properties ← 환경 변수
                    li PropertySource 추가
                    +asCode('java', '수동 추가').
                        var sources = context.getEnvironment().getPropertySources();
                        sources.addFirst(new PropertySourceA(...));
                        sources.addLast(new PropertySourceB(...));
                    +asCode('java', '자동 추가').
                        @Configuration
                        @PropertySource("classpath:io/github/donggi/${spring.profiles.active:localhost}.properties")
                        @PropertySource("classpath:io/github/donggi/more/${spring.profiles.active:localhost}.properties")
                        public class AppConfig {}

                h4.marker ApplicationContext 추가 기능
                div
                    h5.marker 국제화; ApplicationContext → MessageSource
                    ul
                        li HierarchicalMessageSource 인터페이스는 부모의 것을 상속한다
                        li 문자열 획득
                        +asCode('java').
                            String getMessage(String code, Object[] args[, String default], Locale loc)
                            String getMessage(MessageSourceResolvable resolvable, Locale locale)
                        li MessageSource 탐색
                        ol
                            li ApplicationContext는 자동으로 "messageSource" 이름의 MessageSource 빈을 찾는다
                            li 없는 경우 부모 컨텍스트에서 해당하는 빈을 찾는다
                            li 없는 경우 DelegatingMessageSource 인스턴스로 설정
                        li MessageSource 구현체 : ResourceBundleMessageSource, StaticMessageSource
                        li *.properties 네이밍 규칙
                        ul
                            li Locale ENGLISH = createConstant("en", ""); → xxx_en.properties
                            li Locale US = createConstant("en", "US"); → xxx_en_US.properties
                        li
                            | 예시 코드 
                            +codeBtn('/Repositories/STS/ioc-example/src/main/java/io/github/donggi/example/config/I18nConfig.java', 'java') Configuration
                            +codeBtn('/Repositories/STS/ioc-example/src/main/resources/i18n/templates_en.properties', 'properties') templates_en.properties
                            +codeBtn('/Repositories/STS/ioc-example/src/main/resources/i18n/templates_ko.properties', 'properties') templates_ko.properties
                            +codeBtn('/Repositories/STS/ioc-example/src/test/java/io/github/donggi/example/config/I18nTests.java', 'java') Test
                    h5.marker 이벤트 Pub/Sub
                    ul
                        li 이벤트 정의 : ApplicationEvent
                        li 이벤트 리스너 : ApplicationListener 또는 @EventListener(Since 4.2)
                        li 내장 이벤트
                        table
                            +ths('Event', '요약')
                            +tds('ContextRefreshedEvent', 'ApplicationContext 초기화 또는 갱신(refresh) 완료')
                            +tds('ContextStartedEvent', 'ConfigurableApplicationContext#start()')
                            +tds('ContextStoppedEvent', 'ConfigurableApplicationContext#stop()')
                            +tds('ContextClosedEvent', 'ConfigurableApplicationContext#close() 또는 JVM 종료')
                            +tds('RequestHandledEvent', 'HTTP 요청 처리 완료')
                            +tds('ServletRequestHandledEvent', 'RequestHandledEvent + 서블릿 정보')
                        li
                            | 예시 
                            +codeBtn('/Repositories/STS/ioc-example/src/main/java/io/github/donggi/example/event/MyEvent1.java', 'java') Event
                            +codeBtn('/Repositories/STS/ioc-example/src/main/java/io/github/donggi/example/event/MyEvent1Publisher.java', 'java') Publisher
                            +codeBtn('/Repositories/STS/ioc-example/src/main/java/io/github/donggi/example/event/MyEvent1Listener1.java', 'java') Listener
                            +codeBtn('/Repositories/STS/ioc-example/src/test/java/io/github/donggi/example/event/Event1Tests.java', 'java') Test
                        li
                            | @EventListener 예시 
                            +codeBtn('/Repositories/STS/ioc-example/src/main/java/io/github/donggi/example/event/MyEvent2.java', 'java') Event
                            +codeBtn('/Repositories/STS/ioc-example/src/main/java/io/github/donggi/example/event/MyEvent2Publisher.java', 'java') Publisher
                            +codeBtn('/Repositories/STS/ioc-example/src/main/java/io/github/donggi/example/event/MyEvent2Listener1.java', 'java') Listener1
                            +codeBtn('/Repositories/STS/ioc-example/src/main/java/io/github/donggi/example/event/MyEvent2Listener2.java', 'java') Listener2
                            +codeBtn('/Repositories/STS/ioc-example/src/test/java/io/github/donggi/example/event/Event2Tests.java', 'java') Test
                        li 이벤트 핸들러가 다른 이벤트를 반환하는 경우, 해당 이벤트가 발행된다. 이벤트에 대한 컬렉션을 반환하면, 각각이 모두 발행된다
                        p 단, @Async 메서드는 수동으로 발행해야 한다.
                        li @Order로 리스너 호출 순서를 제어할 수 있다
                        li @EventListener > condition에 사용 가능한 SpEL 이벤트 메타데이터
                        table
                            +ths('code', 'description')
                            +tds('#root.event, event', 'ApplicationEvent 인스턴스')
                            +tds('#root.args, args', '메서드 파라미터 배열')
                            +tds('#name, #a0, #p0', '이름 또는 인덱스로 지정한 메서드 파라미터')
                    h5.marker ApplicationContext → ResourceLoader
                    ul
                        li Resource ::= java.net.URL을 포함한 클래스 패스 또는 파일 시스템 상의 리소스
                        li ApplicationContext는 그 자체로 ResourceLoader며, 저수준 Resource 획득을 쉽게 해준다
                        li ResourceLoaderAware를 구현한 빈들은 초기화 시 ApplicationContext를 ResourceLoader로 전달받는다
                        li ClassPathXmlAPplicationContext에 간단한 경로로 리소스를 질의하는 경우, 클래스 패스 상의 리소스를 찾는다.
                        p 애매한 경우, 명시적으로 classpath:, file: 등 URL을 지정해야 한다.

            h3.marker Resources
            div
                h4.marker interface Resource extends InputStreamSource
                +asCode('java').
                    boolean             exists()            // 리소스의 실재 여부는 이 메서드로 확인해야 한다
                    boolean             isReadable()
                    boolean             isOpen()            // InputStream이 이미 열렸는지 여부.
                                                            // true면 InputStream을 한 번만 읽고 닫아야 한다
                    boolean             isFile()

                    URL                 getURL()
                    URI                 getURI()
                    File                getFile()
                        long            contentLength()
                        long            lastModified()
                        String          getFilename()
                        String          getDescription()

                    InputStream         getInputStream()    // from InputStreamSource
                                                            // 매 호출마다 새로운 InputStream을 반환한다고 가정해도 된다
                    ReadableByteChannel readableChannel()   // Channels.newChannel(getInputStream())

                    Resource            createRelative(String relativePath)
                h4.marker 내장 Resource 구현클래스
                ul
                    li UrlResource
                    p classpath:, file:, http:, ftp: 등 일반적인 스킴 모두 지원
                    li ClassPathResource
                    p 클래스패스 상의 리소스
                    li FileSystemResource
                    p 파일 시스템 상의 리소스
                    li ServletContextResource
                    p 웹앱 루트 디렉터리를 기준으로 한 상대 경로 상의 리소스
                    li InputStreamResource
                    p 지정 IputStream으로부터 Resource 생성. isOpen()이 true를 반환한다. 다른 구현체를 이용할 수 있다면 그쪽을 사용하는 편이 좋다
                    li ByteArrayResource
                    p 주어진 byte 배열로부터 Resource 생성. 여러번 읽기 가능.
                h4.marker interface ResourceLoader
                +asCode('java').
                    static String       CLASSPATH_URL_PREFIX    // "classpath:"

                    ClassLoader         getClassLoader()
                    Resource            getResource(String location)
                        // 스킴을 지정하지 않은 경우, 각 ApplicationContext 구현체는 서로 다른 Resource를 찾아 반환한다
                        // 예. ClassPathXmlApplicationContext -> ClassPathResource
                        // 예. FileSystemXmlApplicationContext  -> FileSystemResource
                        // 예. WebApplicationContext -> ServletContextResource
                h4.marker Resource 주입
                ul
                    li XML 기반 설정에서, Resource 타입 property의 value로 URL 문자열이 가능하다
                    li 일반적으로 ApplicationContext 생성자 자체도 URL 문자열 (배열)로 초기화 가능하다
                    li ClassPathXmlApplicationContext 생성자에 클래스와 파일명 배열을 같이 보내면, 자동으로 클래스 위치에서 파일을 찾는다
                    li ApplicationContext 생성자 및 PathMatcher 유틸리티 클래스는 와일드카드를 사용할 수 있다
                    ul
                        li "file:C:/some/path/*-context.xml", "classpath*:com/mycompany/**/applicationContext.xml"
                        li XML관련 ApplicationContext는 "classpath*:" 접두를 사용할 수 있다. 의미는 모든 클래스패스 리소스 검색
                        +asCode('java') new ClassPathXmlApplicationContext("classpath*:conf/appContext.xml");
                        p 내부적으로 ClassLoader.getResources()를 이용한다. jar 파일에서 리소스를 로드하는 경우, getClass().getClassLoader().getResources()를 직접 호출했을 때와 비교하여 차이가 있으면 서버 설정을 조정하거나 해야 한다.
                        li "jar:" 리소스들은 java.net.JarURLConnection을 필요로 하기 때문에, 일부 환경에서 실패할 수 있음에 유의
                    li 이전 버전과의 호환성을 위해, FileSystemApplicationContext 자체가 ResourceLoader 역할을 하는 경우, 절대 경로도 상대 경로로 해석함에 유의.
                    p 절대 경로로 리소스를 지정하려면 "file:///path/file.ext" 처럼 "file:" 접두를 사용해 UrlResource로 가져오도록 해야 한다.

            h3.marker 데이터 검증, 바인딩, 타입 변환
            div
                h4.marker Validator를 이용한 검증
                +asCode('java').
                    boolean supports(Class&lt;?&gt; clazz)
                        // 전형적으로 MyTargetClass.class.isAssignableFrom(clazz)
                    void validate(Object target, Errors errors)
                        // Errors.reject*()를 이용해 오류 정보 전달
                        // Errors의 각 거부 항목들은 이름-에러코드 쌍으로 구성된다. 예. ("x", "is.null")
                        // DefaultMessageCodesResolver는 에러 정보를 토대로 새 에러코드도 등록한다.
                        //      예. ("x", "is.null") → is.null.x, is.null.float, is.null
                        //      이를 이용해 MessageSource로부터 보다 적절한 메시지를 가져올 수 있다
                        // ValidationUtils를 이용하면 구현에 도움이 된다
                p
                    | 예시 코드 
                    +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/anno/Anno29.java', 'java') Bean
                    +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/anno/anno29_ko.properties', 'properties') message
                    +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/anno/Anno29Test.java', 'java') Context
                h4.marker 애너테이션 기반 검증
                ul
                    li
                        +asA('https://beanvalidation.org/', 'Java Bean Validation API')
                        | 예 
                        +codeBtn('/Repositories/STS/spring-core/src/main/java/io/github/donggi/bean/Test2Bean.java', 'java') Bean1
                        +codeBtn('/Repositories/STS/spring-core/src/main/java/io/github/donggi/bean/Test2Bean2.java', 'java') Bean2
                        +codeBtn('/Repositories/STS/spring-core/src/main/java/io/github/donggi/bean/Test2Bean3.java', 'java') Bean3
                        +codeBtn('/Repositories/STS/spring-core/src/main/java/io/github/donggi/anno/Test2Constraint.java', 'properties') Test2Constraint
                        +codeBtn('/Repositories/STS/spring-core/src/main/java/io/github/donggi/config/Test2Config.java', 'properties') Config
                        +codeBtn('/Repositories/STS/spring-core/src/test/java/io/github/donggi/Test2.java', 'java') Test
                h4.marker BeanWrapper의 프로퍼티 주입
                ul
                    li BeanWrapper는 단일/벌크 프로퍼티 설정을 위한 연산을 정의하며, BeanWrapperImpl은 가장 기본적으로 사용되는 구현 클래스다
                    +asCode('java').
                        var person = new BeanWrapperImpl(new Person());
                        person.setPropertyValue("name", "my name");
                        var realPerson = person.getWrappedInstance();
                    li 프로퍼티 경로는 구분자를 이용한 무제한 확장이 가능하다
                    table.no-sort
                        +tds('prop', 'prop 이름의 필드를 가리킨다. 접근 메서드는 getProp() or isProp(), setProp()')
                        +tds('prop1.prop2', 'prop1 필드의 prop2 필드. 접근 메서드는 getProp1().getProp2() or getProp1().isProp2(), getProp1().setProp2()')
                        +tds('prop[2]', 'prop 이름의 배열, List, 기타 ordered collection')
                        +tds('prop[key]', 'prop 이름의 Map')
                h4.marker PropertyEditor의 Object ↔ String 변환
                ul
                    li Something 클래스와 같은 패키지에 PropertyEditor를 구현한 SomethingEditor가 존재하면 자동으로 사용된다
                    p
                        | 예시 코드 
                        +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/anno/Anno30.java', 'java') Bean
                        +codeBtn('/Repositories/Eclipse/app2/src/main/java/io/github/donggi/anno/Anno30DataEditor.java', 'java') Editor
                        +codeBtn('/Repositories/Eclipse/app2/src/test/java/io/github/donggi/anno/Anno30Test.java', 'java') Context
                    li 내장 PropertyEditor 구현체
                    table
                        +ths('Class', '설명')
                        +tds('ByteArrayPropertyEditor', 'String → byte[]. BeanWrapperImpl 기본 등록')
                        +tds('ClassEditor', 'String(클래스 경로) ↔ Class. BeanWrapperImpl 기본 등록')
                        +tds('FileEditor', 'String(파일 경로) → File. BeanWrapperImpl 기본 등록')
                        +tds('InputStreamEditor', 'String(리소스 경로) → InputStream. BeanWrapperImpl 기본 등록; InputStream을 알아서 닫아주지는 않는다')
                        +tds('LocaleEditor', 'String ↔ Locale. BeanWrapperImpl 기본 등록')
                        +tds('PropertiesEditor', 'String → Properties. BeanWrapperImpl 기본 등록')
                        +tds('URLEditor', 'String → URL. BeanWrapperImpl 기본 등록')
                        
                        +tds('CustomBooleanEditor', 'String ↔ Boolean. BeanWrapperImpl 기본 등록 & 덮어쓰기 가능')
                        +tds('CustomNumberEditor', 'String ↔ Number. BeanWrapperImpl 기본 등록 & 덮어쓰기 가능')
                        
                        +tds('CustomCollectionEditor', 'source Collection → target Collection')
                        +tds('CustomDateEditor', 'String ↔ Date. 커스텀 DateFormat 사용 가능.')
                        +tds('PatternEditor', 'String ↔ Pattern')
                        +tds('StringTrimmerEditor', 'String → Trimmed string. (Option) "" → null')
                    li 사용자 정의 PropertyEditor를 BeanWrapper 또는 IoC container에 등록하여 사용할 수 있다
                    +asCode('java', 'SomethingEditor.java').
                        public class SomethingEditor extends PropertyEditorSupport {
                            public void setAsText(String text) {
                                setValue(new Something(text));
                            }
                        }
                    ul
                        li CustomEditorConfigurer 이용 : 중첩 프로퍼티 설정도 해준다
                        +asCode('xml', 'config.xml').
                            &lt;bean class="org.springframework.beans.factory.config.CustomEditorConfigurer">
                                &lt;property name="customEditors">
                                    &lt;map>
                                        &lt;entry key="package.Something" value="package.SomethingEditor"/>
                                    &lt;/map>
                                &lt;/property>
                            &lt;/bean>
                        +asCode('java', 'Config.java').
                            @Bean
                            public CustomEditorConfigurer customEditorConfigurer() {
                                var c = new CustomEditorConfigurer();
                                var map = new HashMap&lt;Class&lt;?>, Class&lt;? extends PropertyEditor>>();
                                map.put(Something.class, SomethingEditor.class);
                                c.setCustomEditors(map);
                                return c;
                            }
                        li PropertyEditorRegistrar 이용 : 사용 시마다 새 PropertyEditor 인스턴스를 만들기 때문에 동기화 걱정 없음
                        +asCode('java', 'CustomPropertyEditorRegistrar.java').
                            public class CustomPropertyEditorRegistrar implements PropertyEditorRegistrar {
                                public void registerCustomEditors(PropertyEditorRegistry registry) {
                                    registry.registerCustomEditor(Something.class, new SomethingEditor());
                                }
                            }
                        +asCode('java', 'Config.java').
                            @Bean
                            public PropertyEditorRegistrar customPropertyEditorRegistrar() {
                                return new CustomPropertyEditorRegistrar();
                            }
                            @Bean
                            public CustomEditorConfigurer customEditorConfigurer() {
                                var c = new CustomEditorConfigurer();
                                c.setPropertyEditorRegistrars(new PropertyEditorRegistrar[] { customPropertyEditorRegistrar() });
                                return c;
                            }
                        li ConfigurableBeanFactory.registerCustomEditor()
                h4.marker 타입 변환
                ul
                    li core.convert 서브 패키지는 타입 변환 시스템을 제공한다. PropertyEditor 대신 이용해도 좋다
                    +asCode('java', 'interface Converter<S, T>') T convert(S source);
                    ul
                        li source는 non-null임이 보장된다
                        li 실패한 경우 IllegalArgumentException을 던지면 된다
                        li convert 메서드는 스레드-안전해야 한다.
                        li core.convert.support 서브 패키지에서 여러 범용 컨버터를 제공한다.
                    li 동일 소스로부터 여러 타입으로의 변환이 필요한 경우 ConverterFactory를 이용하면 좋다
                    +asCode('java', 'interface ConverterFactory<S, R>') &lt;T extends R&gt; Converter&lt;S, T&gt; getConverter(Class&lt;T&gt; targetType);
                    li n:m 변환을 한번에 지원하려면 GenericConverter가 유용할 수 있다
                    +asCode('java', 'interface GenericConverter').
                        Set&lt;ConvertiblePair&gt; getConvertibleTypes();
                        Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);
                    +asCode('java', 'TypeDescriptor 헬퍼 메서드').
                        List&lt;Integer&gt; list;
                        conversionService.convert(list,
                                TypeDescriptor.forObject(input),                                                // List&lt;Integer>
                                TypeDescriptor.collection(List.class, TypeDescriptor.valueOf(String.class)))    // List&lt;String>
                    li ConditionalGenericConverter : 특정 조건을 만족할 때만 변환
                    +asCode('java', 'interface ConditionalConverter')
                        boolean matched(TypeDescriptor sourceType, TypeDescriptor targetType);
                    li 각 컨버터는 ConversionService 뒤에서 실행된다
                    +asCode('java', 'interface ConversionService').
                        boolean canConvert(Class&lt;?> sourceType, Class&lt;?> targetType);
                        &lt;T> T convert(Object source, Class&lt;T> targetType);
                        boolean canConvert(TypeDescriptor sourceType, TypeDescriptor targetType);
                        Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);
                    ul
                        li 대부분의 ConversionService 구현 클래스들은 ConverterRegistry 역시 구현하며, 이를 통해 컨버터를 등록할 수 있다
                        li core.convert.support 서브 패키지에서 일반적인 GenericConversionService 클래스를 제공한다
                        li core.convert.support 서브 패키지에서 ConversionService 생성을 위한 ConversionServiceFactory 클래스를 제공한다
                        li IoC 컨테이너에 설정된 ConversionService는 관리되는 임의 빈에서 직접 사용할 수 있다.
                    +asCode('xml', '기본 ConversionService 등록') &lt;bean class="org.springframework.context.support.ConversionServiceFactoryBean"/>
                    +asCode('xml', '기본 + 사용자 컨버터 추가').
                        &lt;bean class="org.springframework.context.support.ConversionServiceFactoryBean">
                            &lt;property name="converters">
                                &lt;set>
                                    &lt;bean class="example.MyCustomConverter"/>
                                &lt;/set>
                            &lt;/property>
                        &lt;/bean>
                h4.marker Field Formatting
                +asCode('java').
                    interface Formatter&lt;T&gt; extends Printer&lt;T&gt;, Parser&lt;T&gt; {}
                    interface Printer&lt;T&gt; {
                        String print(T fieldValue, Locale locale);
                    }
                    interface Parser&lt;T&gt; {
                        T parse(String clientValue, Locale locale) throws ParseException;
                    }
                ul
                    li Formatter는 스레드-안전해야 한다
                    li format 서브 패키지에서 여러 Formatter 구현체를 제공한다
                    p NumberStyleFormatter, PercentStyleFormatter, DateFormatter, ...
                    li FormatterRegistry, FormatterRegistrar : 포매터 등록을 위한 인터페이스
                    +asA('https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/web.html#mvc-config-conversion')
                    li Annotation-driven Formatting
                    p
                        | AnnotationFormatterFactory를 이용한다. 예시 코드 
                        +codeBtn('/Repositories/STS/spring-core/src/main/java/io/github/donggi/bean/Test1Bean.java', 'java') Bean
                        +codeBtn('/Repositories/STS/spring-core/src/main/java/io/github/donggi/anno/Test1FormatAnnotationFormatterFactory.java', 'java') FormatterFactory
                        +codeBtn('/Repositories/STS/spring-core/src/main/java/io/github/donggi/config/Test1Config.java', 'properties') Config
                        +codeBtn('/Repositories/STS/spring-core/src/test/java/io/github/donggi/Test1.java', 'java') Test

            h3.marker SpEL; Spring Expression Language
            div
                h4.marker 표현식 평가
                +asCode('java').
                    var parser = new SpelExpressionParser();
                    var exp = parser.parseeExpression("'Hello World'");
                    exp = parser.parseeExpression("'Hello World'.concat('!')");          // concat()
                    exp = parser.parseeExpression("'Hello World'.bytes");                // getBytes()
                    exp = parser.parseeExpression("new String('Hello World').bytes.length");

                    parser.parseExpression("name").getValue(String.class);               // get result value as String
                    parser.parseExpression("name").getValue(obj);                        // get obj.name via obj.getName()
                    parser.parseExpression("name == 'Bob'").getValue(obj, Boolean.class) // get (obj.getName().equals("Bob"))
                p 속도 향상을 위해 컴파일러를 켤 수 있다.
                +asCode('java').
                    new SpelParserConfiguration(SpelCompilerMode.IMMEDIATE, ...);
                    // OFF(default), IMMEDIATE(즉시 컴파일), MIXED(나중에 컴파일, 컴파일 표현식 실패 시 다시 인터프리팅 해석)
                    // 또는 시스템 속성 spring.expression.compiler.mode=off|immediate|mixed 로도 설정 가능

                    // 4.1 제약사항
                    // * 할당 문장 사용 불가
                    // * Conversion service 의존 문장 사용 불가
                    // * 사용자 정의 resolver, accessor 사용 불가
                    // * Selection, projection  불가
                h4.marker 빈 정의 표현식
                p
                    strong &#x23;{ 표현식 }
                    | 으로 빈을 정의할 수 있다
                +asCode('xml').
                    &lt;property value="&#x23;{ T(java.lang.Math).random() * 100 }"/>
                    &lt;!-- 컨텍스트 상에 정의된 다른 모든 빈을 참조할 수 있다 -->
                    &lt;property value="&#x23;{ systemProperties['user.region'] }"/>
                    &lt;property value="&#x23;{ myBean.someProp }"/>
                +asCode('java') @Value("&#x23;{ systemProperties['user.region'] }")
                h4.marker 표현식 문법
                div
                    h5.marker Literal
                    +asCode().
                        &#x23;{ 'Text' }
                        &#x23;{ '3.14e+15' }
                        &#x23;{ '0x7fff' }
                        &#x23;{ 'true' }
                        &#x23;{ 'null' }
                    h5.marker Properties, Arrays, Lists, Maps, Indexers
                    +asCode().
                        &#x23;{ list[3].arr[3][3] }
                        &#x23;{ map['key'] }
                        &#x23;{ {1, 2, 3} }                    // inline list
                        &#x23;{ {} }                           // empty list
                        &#x23;{ {num: 1, date: '2020-02-02'} } // inline map
                        &#x23;{ {:} }                          // empty map
                        &#x23;{ new int[] {1, 2, 3} }          // 배열 생성자 호출 가능
                    h5.marker Operators
                    +asCode().
                        &#x23;{ 2 > null == true }                       // null은 다른 모든 것보다 작다고 간주
                        &#x23;{ 2 gt null eq true }
                            // lt(&lt;), gt(>), le(&lt;=), ge(>=), eq(==), ne(!=), div(/), mod(%), not(!), and(&amp;&amp;), or(||)
                        &#x23;{ 'text' instanceof T(java.lang.String) }  // 기본 타입들은 모두 래핑됨에 유의
                        &#x23;{ 'text' matches '^\\w+$' }
                        &#x23;{ T(java.math.RoundingMode).CEILING }      // static 멤버 접근 가능
                        &#x23;{ name?:'Anonymous' }                      // name != null ? name : "Anonymous"
                        &#x23;{ bean?.prop }                             // Null safe navigation
                    h5.marker Variables, Functions
                    +asCode().
                        &#x23;{ &#x23;variable }   // 변수 참조
                        &#x23;{ &#x23;this }       // 현재 컨텍스트
                        &#x23;{ &#x23;root }       // 루트 컨텍스트
                        &#x23;{ &#x23;funcName() } // 사용자 정의 함수 호출
                    h5.marker Selection, Projection
                    +asCode().
                        ${ collection.?[num > 123] } // selection
                        ${ collection.![num + 123] } // projection

            h3.marker Spring AOP
            +pos('Spring AOP')
            div
                h4.marker AOP 개념
                ol
                    li Aspect : 횡단 관심사. 로깅/보안 등, 여러 객체를 가로질러 공통적으로 사용되는 모듈/기능
                    li Join Point : Aspect 실행 지점
                    li Advice : Join Point에서 실행되는 코드
                    li Pointcut : 일치하는 Join Point에 대한
                        +asA('https://www.eclipse.org/aspectj/doc/next/progguide/semantics-pointcuts.html', '정규 표현식')
                    | Advice는 Pointcut과 연관되며, 일치하는 모든 Join Point에서 실행된다.
                    li Weaving : Advice 코드를 삽입
                    | 세 가지 Weaving 방식 : 컴파일 타임 위빙, 클래스 로드 타임 위빙, 런타임 위빙

                h4.marker Spring AOP
                ul
                    li Spring은 프록시를 만들어 Aspect의 실행을 삽입한다
                    p 따라서 final이거나, 정의되지 않은 메서드는 Aspect 삽입이 불가능하다.
                    li JDK 프록시는 public 인터페이스 메서드만, CGLIB 프록시는 public, protected 인터페이스/클래스 메서드에 삽입 가능
                    +asCode('java', 'CGLIB 고정 - java') @EnableAspectJAutoProxy(proxyTargetClass=true)
                    +asCode('xml','CGLIB 고정 - xml').
                        &lt;aop:config proxy-target-class="true">&lt;/aop:config>
                        &lt;aop:aspectj-autoproxy proxy-target-class="true"/>
                    li 프록시가 새 인터페이스를 구현하도록 변경(Introduction)하는 것은 가능하다.
                    li Aspect 적용 순서 정의
                    p @Order(xml에서는 order 속성)를 적용하거나 Ordered 인터페이스 구현

                    li.marker 지원하는 advice
                    table
                        +ths('종류','aop 태그','적용 시점')
                        +tds('Before','aop:before','메서드 실행 전')
                        +tds('After Returning','aop:after-returning','메서드 정상 종료 후')
                        +tds('After Throwing','aop:after-throwing','메서드 예외 throw시 적용')
                        +tds('After','aop:after','after-returning + after-throwing')
                        +tds('Around','aop:around','before + after')
                    li.marker 지원하는 pointcut 지시자
                    table
                        +ths('Designator', '설명')
                        +tds('bean', '특정 빈에 정의된 메서드 호출. id or name 지정. 와일드카드 * 사용 가능')
                        +tds('execution', '특정 메서드 호출')
                        +tds('within', '특정 타입들에 정의된 메서드 호출')
                        +tds('this', '특정 타입 AOP 프록시 인스턴스에 정의된 메서드 호출')
                        +tds('target', '특정 타입 인스턴스에 정의된 메서드 호출')
                        +tds('args', '인자가 특정 타입 인스턴스들인 메서드 호출')
                        +tds('@annotation', '특정 애너테이션이 붙은 메서드 호출')
                        +tds('@within', '특정 애너테이션이 타입들에 정의된 메서드 호출')
                        +tds('@target', '특정 애너테이션이 붙은 클래스 인스턴스에 정의된 메서드 호출')
                        +tds('@args', '인자에 특정 애너테이션이 붙은 메서드 호출')
                    ul
                        li Pointcut 표현식에 &amp;&amp;, ||, ! 사용 가능
                        li Pointcut 표현식에 이름 사용 가능
                        +asCode('java').
                            @Pointcut("execution(public * *(..))")
                            private void anyPublicOperation() {} 
                            @Pointcut("within(com.xyz.someapp.trading..*)")
                            private void inTrading() {} 
                            @Pointcut("anyPublicOperation() &amp;&amp; inTrading()")
                            private void tradingOperation() {} 
                        li public Pointcut 표현식은 외부에서도 이용 가능하므로, 정의를 중앙화할 수 있다.
                        li execution 표현식
                        +asCode().
                            execution(modifires-pattern? return-type-pattern declaring-type-pattern?name-pattern(param-pattern) throws-pattern?)
                                return-type-pattern     *는 임의 반환 타입에 매칭
                                declaring-type-pattern  메서드가 정의된 타입 지정. 마지막은 '.'으로 끝나야 한다.
                                name-pattern            메서드 이름 지정
                                param-pattern           ()는 무인자, (..)는 임의 타입 및 길이 인자, (*)는 해당 자리의 임의 타입 인자.
                    li.marker 각 advice별 예시 코드(XML)
                    table.no-sort
                        tr
                            td Before
                            td
                                +codeBtn('/Repositories/Eclipse/spring-aop/src/main/java/io/github/donggi/advice/BeforeAdvice.java', 'java') Advice
                                +codeBtn('/Repositories/Eclipse/spring-aop/src/test/resources/beans/Beans2.xml', 'xml') Config
                                +codeBtn('/Repositories/Eclipse/spring-aop/src/test/java/io/github/donggi/advice/BeforeAdviceTest.java', 'java') Test
                                br
                                | Before advice에서 예외를 던지면 실제 메서드는 호출되지 않는 효과가 있다.
                        tr
                            td After returning
                            td
                                +codeBtn('/Repositories/Eclipse/spring-aop/src/main/java/io/github/donggi/advice/AfterAdvice.java', 'java') Advice
                                +codeBtn('/Repositories/Eclipse/spring-aop/src/test/resources/beans/Beans3.xml', 'xml') Config
                                +codeBtn('/Repositories/Eclipse/spring-aop/src/test/java/io/github/donggi/advice/AfterAdviceTest.java', 'java') Test
                        tr
                            td After throwing
                            td
                                +codeBtn('/Repositories/Eclipse/spring-aop/src/main/java/io/github/donggi/advice/AfterAdvice2.java', 'java') Advice
                                +codeBtn('/Repositories/Eclipse/spring-aop/src/test/resources/beans/Beans4.xml', 'xml') Config
                                +codeBtn('/Repositories/Eclipse/spring-aop/src/test/java/io/github/donggi/advice/AfterAdviceTest2.java', 'java') Test
                        tr
                            td After
                            td
                                +codeBtn('/Repositories/Eclipse/spring-aop/src/main/java/io/github/donggi/advice/AfterAdvice3.java', 'java') Advice
                                +codeBtn('/Repositories/Eclipse/spring-aop/src/test/resources/beans/Beans5.xml', 'xml') Config
                                +codeBtn('/Repositories/Eclipse/spring-aop/src/test/java/io/github/donggi/advice/AfterAdviceTest3.java', 'java') Test
                        tr
                            td Around
                            td
                                +codeBtn('/Repositories/Eclipse/spring-aop/src/main/java/io/github/donggi/advice/TimerAdvice.java', 'java') Advice
                                +codeBtn('/Repositories/Eclipse/spring-aop/src/test/resources/beans/Beans1.xml', 'xml') Config
                                +codeBtn('/Repositories/Eclipse/spring-aop/src/test/java/io/github/donggi/advice/TimerAdviceTest.java', 'java') Test
                    li.marker 각 advice별 예시 코드(@Aspect)
                    +asCode('java', '@Aspect 켜기 - Java').
                        @Configuration
                        @EnableAspectJAutoProxy
                    +asCode('xml', '@Aspect 켜기 - XML') &lt;aop:aspectj-autoproxy/>
                    table.no-sort
                        tr
                            td Before
                            td
                                +codeBtn('/Repositories/Eclipse/spring-aop/src/main/java/io/github/donggi/aspect/BeforeAspect.java', 'java') Aspect
                                +codeBtn('/Repositories/Eclipse/spring-aop/src/test/resources/beans/Beans7.xml', 'xml') Config
                                +codeBtn('/Repositories/Eclipse/spring-aop/src/test/java/io/github/donggi/advice/BeforeAdviceTest2.java', 'java') Test
                        tr
                            td After Returning
                            td
                                +codeBtn('/Repositories/Eclipse/spring-aop/src/main/java/io/github/donggi/aspect/AfterAspect.java', 'java') Aspect
                                +codeBtn('/Repositories/Eclipse/spring-aop/src/test/resources/beans/Beans8.xml', 'xml') Config
                                +codeBtn('/Repositories/Eclipse/spring-aop/src/test/java/io/github/donggi/advice/AfterAdviceTest4.java', 'java') Test
                        tr
                            td After Throwing
                            td
                                +codeBtn('/Repositories/Eclipse/spring-aop/src/main/java/io/github/donggi/aspect/AfterAspect2.java', 'java') Aspect
                                +codeBtn('/Repositories/Eclipse/spring-aop/src/test/resources/beans/Beans9.xml', 'xml') Config
                                +codeBtn('/Repositories/Eclipse/spring-aop/src/test/java/io/github/donggi/advice/AfterAdviceTest5.java', 'java') Test
                        tr
                            td After
                            td
                                +codeBtn('/Repositories/Eclipse/spring-aop/src/main/java/io/github/donggi/aspect/AfterAspect3.java', 'java') Aspect
                                +codeBtn('/Repositories/Eclipse/spring-aop/src/test/resources/beans/Beans10.xml', 'xml') Config
                                +codeBtn('/Repositories/Eclipse/spring-aop/src/test/java/io/github/donggi/advice/AfterAdviceTest6.java', 'java') Test
                        tr
                            td Around
                            td
                                +codeBtn('/Repositories/Eclipse/spring-aop/src/main/java/io/github/donggi/aspect/AroundAspect.java', 'java') Aspect
                                +codeBtn('/Repositories/Eclipse/spring-aop/src/test/resources/beans/Beans6.xml', 'xml') Config
                                +codeBtn('/Repositories/Eclipse/spring-aop/src/test/java/io/github/donggi/advice/TimerAdviceTest2.java', 'java') Test
                    li.marker execution 외 Pointcut 예시 코드
                    table.no-sort
                        tr
                            td args XML 설정 예
                            td
                                +codeBtn('/Repositories/Eclipse/spring-aop/src/main/java/io/github/donggi/advice/BeforeAdvice2.java', 'java') Advice
                                +codeBtn('/Repositories/Eclipse/spring-aop/src/test/resources/beans/Beans11.xml', 'xml') Config
                                +codeBtn('/Repositories/Eclipse/spring-aop/src/test/java/io/github/donggi/advice/BeforeAdviceTest3.java', 'java') Test
                        tr
                            td args @Aspect 설정 예
                            td
                                +codeBtn('/Repositories/Eclipse/spring-aop/src/main/java/io/github/donggi/aspect/BeforeAspect2.java', 'java') Aspect
                                +codeBtn('/Repositories/Eclipse/spring-aop/src/test/resources/beans/Beans12.xml', 'xml') Config
                                +codeBtn('/Repositories/Eclipse/spring-aop/src/test/java/io/github/donggi/advice/BeforeAdviceTest4.java', 'java') Test
                        tr
                            td execution + args 예
                            td
                                +asCode('java', '즉시 이용').
                                    @Before("com.xyz.myapp.SystemArchitecture.dataAccessOperation() &amp;&amp; args(account,..)")
                                    public void validateAccount(Account account) { ... }
                                +asCode('java', 'Pointcut 지정').
                                    @Pointcut("com.xyz.myapp.SystemArchitecture.dataAccessOperation() &amp;&amp; args(account,..)")
                                    private void accountDataAccessOperation(Account account) {}

                                    @Before("accountDataAccessOperation(account)")
                                    public void validateAccount(Account account) { ... }
                        tr
                            td Generic args 예
                            td: +asCode('java').
                                public interface Sample&lt;T> {
                                    void sampleGenericMethod(T param);
                                    void sampleGenericCollectionMethod(Collection&lt;T> param);
                                }
                                
                                @Before("execution(* ..Sample+.sampleGenericMethod(*)) &amp;&amp; args(param)")
                                public void beforeSampleMethod(MyType param) { ... } // ← 가능
                                
                                @Before("execution(* ..Sample+.sampleGenericCollectionMethod(*)) &amp;&amp; args(param)")
                                public void beforeSampleMethod(Collection&lt;MyType> param) { ... } // ← 불가능
                    li.marker Aspect 인스턴스화 종류
                    ul
                        li default. 싱글톤
                        li perthis : 대상 메서드를 실행하는 프록시 인스턴스(this)마다 프록시 생성
                        +asCode('java').
                            @Aspect("perthis(com.xyz.myapp.SystemArchitecture.businessService())")
                            public class MyAspect { }
                        li pertarget : 대상 메서드를 실행하는 실제 인스턴스(target)마다 프록시 생성

                h4.marker Null-safety
                ul
                    li @Nullable : 파리미터, 반환값, 필드가 null일 수 있음
                    li @NonNull : 파리미터, 반환값, 필드가 null일 수 없음
                    li @NonNullApi : 패키지 수준으로

    details
        summary 정리중...
        details
            summary Spring MVC
            ol
                li DispatcherServlet : 클라이언트 요청을 받아 컨트롤러에 처리를 넘긴다.
                | 각 DispatcherServlet은 하나의 WebApplicationContext를 갖는다
                +codeBtn('/Repositories/Eclipse/spring-mvc/src/main/webapp/WEB-INF/web.xml', 'xml') WEB-INF/web.xml
                br
                | 기본적으로 {서블릿_이름}-servlet.xml 설정을 읽어온다
                +codeBtn('/Repositories/Eclipse/spring-mvc/src/main/webapp/WEB-INF/dispatcher-servlet.xml', 'xml') WEB-INF/dispatcher-servlet.xml
                br
                | 설정 파일을 직접 지정하려면 DispatcherServlet의 "contextConfigLocation" init-param을 지정하면 된다. 각 경로들은 ',', ' ', '\n' 등으로 구분하면 된다. 클래스패스에 있는 파일은 classpath:conf.xml처럼 지정하면 된다
                br
                | 여러 DispatcherServlet을 이용하면서도 두 WebApplicationContext이 공통적으로 가져야 하는 빈이 있다면 ContextLoaderListener를 설정하면 된다
                +codeBtn('/Repositories/Eclipse/spring-mvc/src/main/webapp/WEB-INF/applicationContext.xml', 'xml') WEB-INF/applicationContext.xml
                li HandlerMapping : 클라이언트의 요청 URL을 어떤 컨트롤러가 처리할 지 결정한다.
                ul
                    li 요청 URL의 매핑을 항상 전체 경로로만 하려는 경우
                    | 스프링 설정에서 아래 2개의 기본 구현체의 alwaysUseFullPath 설정을 변경
                    br
                    | &lt;bean class="org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping" p:alwaysUseFullPath="true"/>
                    br
                    | &lt;bean class="org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter" p:alwaysUseFullPath="true"/>
                    li RESTful URI
                        +codeBtn('/Repositories/Eclipse/spring-mvc/src/main/java/io/github/donggi/controller/HelloController.java', 'java') 예시
            details
                summary @RequestMapping 사용 시 가능한 파라미터 타입
                ol
                    li 서블릿 API 관련 : (Http)ServletRequest, (Http)ServletResponse, HttpSession
                        +codeBtn('/Repositories/Eclipse/spring-mvc/src/main/java/io/github/donggi/controller/HelloController.java', 'java') 예시
                    li 요청 Locale : java.util.Locale
                    li 요청/응답 직접 액세스 : InputStream, Reader, OutputStream, Writer
                    li URI 템플릿 변수 : @PathVariable
                    li HTTP 요청 파라미터 : @RequestParam
                    li HTTP 요청 헤더 : @RequestHeader
                    li HTTP 쿠키 : @CookieValue
                    li HTTP 요청 : @RequestBody
                    li 뷰에 전달할 모델 : Map, Model, ModelMap
                    li POJO : 각 POJO 클래스
                        +codeBtn('/Repositories/Eclipse/spring-mvc/src/main/java/io/github/donggi/controller/LoginController.java', 'java') 예시1
                        +codeBtn('/Repositories/Eclipse/spring-mvc/src/main/webapp/WEB-INF/view/login.jsp', 'xml') login.jsp
                        +codeBtn('/Repositories/Eclipse/spring-mvc/src/main/java/io/github/donggi/controller/BulkLoginController.java', 'java') 예시2
                        +codeBtn('/Repositories/Eclipse/spring-mvc/src/main/webapp/WEB-INF/view/bulkLogin.jsp', 'xml') bulkLogin.jsp
                    li Multipart 폼 데이터 예시
                    | CommonsMultipartResolver 이용(commons-fileupload 패키지 의존)
                    +codeBtn('/Repositories/Eclipse/spring-mvc/src/main/webapp/WEB-INF/dispatcher-servlet.xml', 'xml') WEB-INF/dispatcher-servlet.xml
                    +codeBtn('/Repositories/Eclipse/spring-mvc/src/main/webapp/WEB-INF/view/upload.jsp', 'xml') upload.jsp
                    +codeBtn('/Repositories/Eclipse/spring-mvc/src/main/java/io/github/donggi/controller/FileController.java', 'java') FileController
                    li POJO로의 바인딩 결과 : Errors, BindingResult
                    +codeBtn('/Repositories/Eclipse/spring-mvc/src/main/java/io/github/donggi/controller/LoginController.java', 'java') @Valid, @InitBinder 예시
                    +codeBtn('/Repositories/Eclipse/spring-mvc/src/main/java/io/github/donggi/validator/LoginRequestValidator.java', 'java') Validator 예시
                    li SessionStatus
            ol
                li Controller : 클라이언트의 요청을 처리한 뒤 결과를 DispatcherServlet에 넘긴다.
                    +codeBtn('/Repositories/Eclipse/spring-mvc/src/main/java/io/github/donggi/controller/HelloController.java', 'java') 예시
            details
                summary 컨트롤러 메서드의 반환 타입
                ol
                    li ModelAndView : 뷰 정보 + 모델 정보
                    li Model, Map : 모델 정보. 뷰 이름은 요청 URL로부터 결정(RequestToViewNameTranslator)된다.
                    li String : 뷰 이름
                    li View : 뷰 인스턴스(org.springframework.web.servlet.View)
                    li void : 메서드가 (Http)ServletRequest를 매개변수로 받는다면 직접 응답을 처리한다고 가정한다. 그 외의 경우, 뷰 이름은 요청 URL로부터 결정.
                    li 메서드에 @ResponseBody가 적용된 경우 반환 객체를 HTTP 응답으로(HttpMessageConverter) 전송한다.
                        | AJAX에 유용.
                        +codeBtn('/Repositories/Eclipse/spring-mvc/src/main/java/io/github/donggi/controller/EtcController.java', 'java') 예시
                    li 뷰 이름을 통한 리다이렉트 : "redirect:" 접두어 활용. 상대 경로, 절대 경로 모두 가능
            ol
                li ModelAndView : 컨트롤러의 처리 결과와 뷰 생성에 필요한 정보
                li ViewResolver : 생성할 뷰를 결정한다.
                li View : 컨트롤러의 처리 결과를 클라이언트에 보낼 형태로 생성한다
                li 예외 처리
                ul
                    li 기본 예외 페이지 설정 :
                        +codeBtn('/Repositories/Eclipse/spring-mvc/src/main/webapp/WEB-INF/web.xml', 'xml') WEB-INF/web.xml
                        +codeBtn('/Repositories/Eclipse/spring-mvc/src/main/webapp/WEB-INF/view/error.jsp', 'xml') error.jsp
                    li 컨트롤러 내부 @ExceptionHandler 메서드 선언 :
                        +codeBtn('/Repositories/Eclipse/spring-mvc/src/main/java/io/github/donggi/controller/HelloController.java', 'java') 예시
                    li 컨트롤러 HandlerExceptionResolver 인터페이스 구현 :
                        +codeBtn('/Repositories/Eclipse/spring-mvc/src/main/java/io/github/donggi/controller/FileController.java', 'java') 예시
                    li SimpleMappingExceptionResolver로 전체 컨트롤러 특정 예외를 특정 뷰로 연결 :
                        +codeBtn('/Repositories/Eclipse/spring-mvc/src/main/webapp/WEB-INF/dispatcher-servlet.xml', 'xml') WEB-INF/dispatcher-servlet.xml
                    li @ControllerAdvice를 이요한 특정 패키지/클래스/인터페이스 예외 처리 :
                        +codeBtn('/Repositories/Eclipse/spring-mvc/src/main/java/io/github/donggi/advice/UnhandledExceptionAdvice.java', 'java') 예시
                li 사용자 정의 PropertyEditor
                    +codeBtn('/Repositories/Eclipse/spring-mvc/src/main/java/io/github/donggi/advice/InitAdvice.java', 'java') 예시
        h2.marker Spring 트랜잭션 사용하기
        ul
            li 관련 클래스
            p AbstractPlatformTransactionManager ← DataSourceTransactionManager(JDBC), HibernateTransactionManager, JtaTransactionManager
            li 예시 코드
            +codeBtn('/Repositories/Eclipse/spring-transaction/pom.xml', 'xml') pom.xml »
            +codeBtn('/Repositories/Eclipse/spring-transaction/src/main/resources/applicationContext.xml', 'xml') applicationContext.xml »
            +codeBtn('/Repositories/Eclipse/spring-transaction/src/main/java/io/github/donggi/service/NameService.java', 'java') NameService.java »
            +codeBtn('/Repositories/Eclipse/spring-transaction/src/test/java/Test.java', 'java') Test.java »
        hr
        details
            summary Spring JUnit
            +codeBtn('/Repositories/Eclipse/spring-transaction/src/test/java/Test.java', 'java') 예시 코드 1 »
            +codeBtn('/Repositories/Eclipse/spring-mvc/src/test/java/Test.java', 'java') 예시 코드 2 »
        hr
        details
            summary Spring Boot
            details
                summary Spring Boot Web Microservice
                ol
                    li 예시 코드
                    +codeBtn('/Repositories/STS/rest-microservice/pom.xml', 'xml') pom.xml
                    +codeBtn('/Repositories/STS/rest-microservice/src/main/java/io/github/donggi/controller/HelloController.java', 'java') HelloController.java
                    +codeBtn('/Repositories/STS/rest-microservice/src/test/java/io/github/donggi/controller/HelloControllerTest.java', 'java') HelloControllerTest.java
                    li 스프링 부트 마이크로서비스는 실행에 필요한 모든 의존 라이브러리, HTTP 리스너 등을 하나의 jar로 패키징한다
                    +w3img('/imgs/20191006_180335.png')
                    +w3img('/imgs/20191006_180348.png')
                    +w3img('/imgs/20191006_180401.png')
                    li mvn install하면 bootJar가 빌드된다
                        br
                        | java -jar target/rest-microservice-0.0.1-SNAPSHOT.jar
            details
                summary Gradle 프로젝트 빌드 및 실행
                ol
                    li bootRun 실행
                    | gradle app-name:bootRun -Pprofile=dev
                    li bootJar 빌드
                    | gradle app-name:bootJar -x test
                    li bootJar 실행
                    | java -jar -Dspring.profiles.active=dev app-name.jar
                    li 디버그 포트 열기
                    | -Xdebug -Xrunjdwp:server=y,transport=dt_socket,address=55555,suspend=n
                    br
                    | suspend=y로 하는 경우, 디버그 연결까지 실행을 대기한다, 허용 서브넷 명시 : address=*:55555, address=0.0.0.0:55555
            details(open='')
                summary application.properties 서버 포트 지정
                | server.port=18080
                br
                | tomcatPort=18009
                br
                | tomcatRedirectPort=18443
            details
                summary Spring Boot Reactive Web Microservice
                ol
                    li 예시 코드
                    +codeBtn('/Repositories/STS/reactive-webflux/pom.xml', 'xml') pom.xml
                    +codeBtn('/Repositories/STS/reactive-webflux/src/main/java/io/github/donggi/controller/HelloController.java', 'java') HelloController.java
                    +codeBtn('/Repositories/STS/reactive-webflux/src/test/java/io/github/donggi/controller/HelloControllerTest.java', 'java') HelloControllerTest.java
                    +w3img('/imgs/20191008_110029.png')
                    li 리액티브 스트림 : java.util.concurrent.Flow
                    ul
                        li Publisher : 발행자. subscribe​(Subscriber)
                        li Subscriber : 구독자. onSubscribe(Subscription), onNext(T), onError(Throwable), onComplete(Void)
                        li Subscription : 구독. request(long), cancel(Void)
                        li Processor extends Subscriber, Publisher : 발행자 + 구독자
                    li 리액터의 발행자 Processor
                    ul
                        li reactor.core.publisher.Mono : 0 또는 1개의 이벤트 발행
                        li reactor.core.publisher.Flux : 0 또는 n개의 이벤트 발행
            details
                summary CORS 허용
                ol
                    li 컨트롤러 클래스 또는 메서드에 @CrossOrigin 설정
                    li WebMvcConfigurer 빈의 addCorsMappings(CorsRegistry)를 재정의하여 앱 전체 설정 변경
            details
                summary Spring Config Server
                ol
                    li Config Server 선택
                    +w3img('/imgs/20191009_095724.png')
                    li 예시 코드
                    +codeBtn('/Repositories/STS/config-server/src/main/resources/bootstrap.properties', 'text') bootstrap.properties
                    +codeBtn('/Repositories/STS/config-server/src/main/java/io/github/donggi/ConfigServerApplication.java', 'java') @EnableConfigServer
                    +codeBtn('/Repositories/Config/webapp.properties', 'text') webapp.properties
                    br
                    li 접근 예
                    | http://localhost:28888/webapp/default
                    br
                    | http://localhost:28888/webapp/default/master/test.xml
                    ul
                        li /{application}/{profile}[/{label}]
                        li /{application}-{profile}.yml
                        li /{label}/{application}-{profile}.yml
                        li /{application}-{profile}.properties
                        li /{label}/{application}-{profile}.properties
                        +w3img('/imgs/20191009_115402.png')
                    li 갱신 : http://localhost:28888/actuator/refresh
            details
                summary Spring Config Client
                ol
                    li Config Client, Actuator 선택
                    +w3img('/imgs/20191009_124833.png')
                    li 예시 코드
                    +codeBtn('/Repositories/Config/config-client.properties', 'text') config-client.properties
                    +codeBtn('/Repositories/STS/config-client/src/main/resources/bootstrap.properties', 'text') bootstrap.properties
                    +codeBtn('/Repositories/STS/config-client/src/main/java/io/github/donggi/controller/HelloController.java', 'java') HelloController.java
                    li 접근 예 http://localhost:18888/hello
                    +w3img('/imgs/20191009_122755.png')
                    li 갱신 : POST http://localhost:18888/actuator/refresh
                    | http://localhost:18888/actuator/에 접속했을 때 /refresh가 보이지 않는다면 management.security.enabled=false, management.endpoints.web.exposure.include=* 2개 설정 확인
                    +w3img('/imgs/20191009_124710.png')
                    +w3img('/imgs/20191009_124647.png')
            ol
                li @Async
                | 메서드를 스프링이 관리하는 ThreadExecutor에서 비동기적으로 실행하는 프록시를 생성한다.
                +codeBtn('/Repositories/STS/web-app/src/main/java/io/github/donggi/WebAppApplication.java', 'java') @EnableAsync »
                +codeBtn('/Repositories/STS/web-app/src/main/java/io/github/donggi/controller/SleepController.java', 'java') @Async »
                li @Scheduled
                | 메서드를 명시적으로 호출하지 않아도 스케쥴대로 실행된다.
                +codeBtn('/Repositories/STS/web-app/src/main/java/io/github/donggi/WebAppApplication.java', 'java') @EnableScheduling »
                +codeBtn('/Repositories/STS/web-app/src/main/java/io/github/donggi/controller/HelloController.java', 'java') @Scheduled »
        hr
        details
            summary WebSocket
            ul
                li HTTP/1.1 업그레이드 기능을 이용해 기존 HTTP/HTTPS를 웹 소켓 연결 WS/WSS로 그대로 전환
                | 사용하던 80/443포트 그대로 연결하므로 방화벽의 차단에도 안전. 프록시 서버가 HTTP 업그레이드를 처리하지 않는다면 WSS를 이용.
                li 웹소켓 API Since JavaEE 7
                ul
                    li javax.websocket : 클라이언트/서버 공통 기능
                    ul
                        li WebSocketContainer
                        | 웹소켓 클라이언트 기능. connectToServer()
                        li ContainerProvider
                        | 웹소켓 클라이언트 인스턴스 획득을 위한 getWebSocketContainer()
                        li @interface ClientEndpoint
                        | POJO가 클라이언트측 웹소켓임을 나타낸다. 해당 클래스는 메서드는 @OnOpen, @OnClose, @OnError, @OnMessage 애너테이트될 수 있다
                        li @interface OnOpen + OnClose
                        | 선택적 Session 매개변수, 선택적 EndpointConfig 매개변수, 0 ~ n개 @PathParam String 매개변수를 가질 수 있다
                        li @interface OnError
                        | 선택적 Session 매개변수, Throwable 매개변수, 0 ~ n개 @PathParam String 매개변수를 가질 수 있다
                        li @interface OnMessage
                        | 선택적 Session 매개변수, 0 ~ n개 @PathParam String 매개변수, 아래 중 하나의 메시지 매개변수
                        ul
                            li 텍스트 메시지 처리
                            ul
                                li 전체 메시지 String
                                li 메시지로부터 변환되는 Java primitive or class
                                li 메시지 청크 String and boolean pair : 마지막 메시지는 true
                                li 전체 메시지 Reader
                                li Decoder.Text or Decoder.TextStream
                            li 이진 메시지 처리
                            ul
                                li 전체 메시지 byte[] or ByteBuffer
                                li 메시지 청크 (byte[] or ByteBuffer) and boolean pair : 마지막 메시지는 true
                                li 전체 메시지 InputStream
                                li Decoder.Binary or Decoder.BinaryStream
                            li 퐁 메시지 처리 : PongMessage
                    li javax.websocket.server : 서버 전용 기능
                    ul
                        li ServerContainer extends WebSocketContainer
                        | ServerEndpointConfig 인스턴스 또는 @ServerEndpoint 클래스 등록
                li Spring Boot 예시
                ul
                    li 웹소켓 API를 사용하기 위해 javax.websocket-api, 스프링의 관리를 위해 spring-websocket 필요
                        +codeBtn('/Repositories/STS/web-app/pom.xml', 'xml') pom.xml »
                    li 스프링이 Endpoint를 찾아 알아서 빈을 생성하도록 ServerEndpointExporter 생성
                        +codeBtn('/Repositories/STS/web-app/src/main/java/io/github/donggi/config/WebSocketConfig.java', 'java') WebSocketConfig.java »
                    li @ServerEndpoint 예
                        +codeBtn('/Repositories/STS/web-app/src/main/java/io/github/donggi/websocket/Echo.java', 'java') Echo.java »
                    | @ServerEndpoint 안에서 @Autowired 주입을 위해 @ServerEndpoint(configurator = ServerEndpointConfigurator.class)를 설정하고 @PostConstruct에서 주입을 실행했음을 참고
                    +codeBtn('/Repositories/STS/web-app/src/main/java/io/github/donggi/config/ServerEndpointConfigurator.java', 'java') ServerEndpointConfigurator.java »
        hr
    +hoverTemplate()#template-jsr330
        p 별도 jar 포함 필요
        +asCode('xml').
            &lt;dependency>
                &lt;groupId>javax.inject&lt;/groupId>
                &lt;artifactId>javax.inject&lt;/artifactId>
                &lt;version>1&lt;/version>
            &lt;/dependency>
        +asCode('gradle') implementation 'javax.inject:javax.inject:1'
