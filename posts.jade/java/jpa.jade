include ../../source/skeleton.jade
+post('JPA', 'JPA, Java Persistence API, Hibernate, Spring Data JPA', 'JPA; Java Persistence API 정리')
    h1.marker JPA?
    div
        h2.marker 정의
        p
            strong Java Persistence API
            |  ::= Java ORM(Object-Relational Mapping)을 위한 명세
            br
            | → 객체지향 설계와 RDB의 설계를 둘 다 해치지 않으면서 둘 사이의 매핑을 지원 ─ 즉, 필요한 SQL을 자동으로 구성
            ul
                li SQL과 유사한, 객체를 이용한 JPQL(Java Persistence Query Language) 지원
                li 객체 상속 관계 사용 가능
                +asCode('java').
                    public class MMonster {
                        private Integer monsterId;
                        private String name;
                    }
                    public class MBossMonster extends MMonster {
                        private Integer baseMonsterId;
                    }
                li 객체 참조 관계 유지 가능
                +asCode('java').
                    public class MCharacterVoice {
                        private Integer characterId;
                        private MVoice voice;
                    }
                    public class MVoice {
                        private Integer voiceId;
                        private String message;
                    }
                +asCode('sql').
                    create table m_character_voice (
                        character_id int primary key,
                        voice_id int not null
                    );
                    create table m_voice (
                        voice_id int primary key,
                        message text
                    );

        h2.marker JPA 사용
        p Hibernate와 같은 JPA 구현체(JPA Provider)를 이용하거나, 직접 구현하여 이용하면 된다
        
        h2.marker Spring Data JPA
        p JPA에 대한 추상화된 모듈을 제공하여 보다 쉬운 사용을 가능하게 한다

    h1.marker JPA 사용 정리
    div
        h2.marker 예시 코드
        table
            +ths('설명', '링크')
            tr
                td 전체 프로젝트
                td: +asA('https://github.com/Dong-gi/Dong-gi.github.io/tree/master/Repositories/STS/jpa-example')
            tr
                td 예시 코드 1 - 기본 CRUD
                td
                    +codeBtn('/Repositories/STS/jpa-example/src/main/resources/ddl/jpa_user.sql', 'sql', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/test/java/io/github/donggi/jpa/dao/UserDaoTests.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/User1.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/User2.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/dao/User1Dao.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/dao/User2Dao.java', 'java', null, true)
            tr
                td 예시 코드 2 - Embed 매핑
                td
                    +codeBtn('/Repositories/STS/jpa-example/src/main/resources/ddl/jpa_item.sql', 'sql', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/test/java/io/github/donggi/jpa/dao/ItemDaoTests.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/Item1.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/Price.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/Item2.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/Item3.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/PricePair.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/ItemInfo.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/Item4.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/Item5.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/ItemInfo3.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/ItemInfo3Key.java', 'java', null, true)
        h2.marker EntityManager
        div
            h3.marker Persistence context; 영속 컨텍스트
            ul
                li DB에서 읽어오거나 DB로 삽입하고자 추가한 객체들은 영속 객체(Persistence object)들로, EntityManager가 관리하는 영속 컨텍스트에 보관된다
                li 트랜잭션 커밋 시점 또는 명시적인 flush() 호출로 영속 컨텍스트의 변경 사항이 DB에 실제 반영된다
                li 영속 객체는 (타입 + 식별자)를 키로 하는 Map으로 관리된다.
                p 이를 이용해 조회하려는 엔티티가 이미 컨텍스트에 있다면 DB에 쿼리를 보내지 않고 즉시 컨텍스트의 객체를 반환한다
                li 영속 객체 생애 주기
                +w3img('/imgs/20200731_215700.png', 'Entity Life Cycle')
                ul
                    li Managed : 변경이 존재하면 DB에 반영됨
                    li Detached : EntityManager가 닫혔거나, 롤백되어 분리된 상태. 변경이 DB에 반영되지 않음
                    li Removed : 커밋 또는 flush() 호출 시 DB에서 삭제
            h3.marker EntityManager를 직접 관리하는 경우
            ol
                li EntityMaganerFactory를 만든다
                li EntityManager가 필요할 때마다 팩터리로부터 하나 생성하고, 사용한 뒤에 직접 닫는다
                li 트랜잭션이 여러 메서드에 걸쳐있는 경우, 동일한 EntityManager를 이용함을 직접 보장해야 한다
                p 메서드 파라미터로 넘기거나 ThreadLocal을 이용하거나... 구현은 자유
            h3.marker EntityManager를 컨테이너에서 관리하는 경우
            p @PersistenceContext로 현재 EntityManager 인스턴스를 주입받으면 된다. Spring Data JPA 에서는 @Autowired도 가능
            h3.marker 메서드
            ul
                li &lt;T> T find(class&lt;T> entityClass, Object primaryKey)
                p 쿼리 즉시 실행. DB에 있으면 T 인스턴스, 없으면 null 리턴
                li &lt;T> T getReference(class&lt;T> entityClass, Object primaryKey)
                ul
                    li 쿼리 지연 실행. 우선 T 프록시를 반환. 프록시 최초 사용 시 쿼리 실행되며, DB에 없으면 EntityNotFoundException
                    li 사용하는 EntityManager를 닫기 전에 프록시를 사용해야 한다
                    li Hibernate의 경우, final entity class에 대하여 쿼리 즉시 실행
                li void persist(Object entity)
                p DB에 저장
                li void remove(Object entity)
                p DB에서 삭제
                li 엔티티 수정
                p 트랜잭션(@Transactional 포함) 안에서 엔티티 수정 시 트랜잭션 커밋 시점에 자동 반영. 또는 flush()로 즉시 반영.
        h2.marker @Entity
        ul
            li DB 입출력 단위
            li 기본 생성자 필수. @Id 최소 한 개 지정 필수
            li 원활한 프록시 동작을 위해 protected 이상, non-final 클래스로 정의
        +asCode('java').
            @Entity
            public class MMonster {}
            @Entity(name = "m_monster_v2")
            public class MMonster {}
        h2.marker @Table
        p @Entity에 catalog, index, schema, UniqueConstraint 설정 추가
        h2.marker @Id
        p 필드 또는 getter 메서드에 대해 기본키 명시. 기본 타입 + Wrapper 타입, Date, BigInteger, BigDecimal 타입만(should) 가능
        h2.marker @GeneratedValue, @SequenceGenerator, @TableGenerator
        ul
            | 기본키 자동 설정 명시. insert 실행 후 실제 값이 설정된다.
            +asCode('java').
                @Id
                @GeneratedValue(strategy = GenerationType.IDENTITY)
                private Long userId;
            li strategy = GenerationType.IDENTITY : DB 설정(MySQL auto_increment, PostgreSQL serial) 그대로 이용
            li generator = "gen_name" : 시퀀스 또는 ID 생성 테이블 이용
            +asCode('java', '시퀀스').
                @Id
                @SequenceGenerator(name = "gen_name", sequenceName = "jpa_user2_user_id_seq", allocationSize = 1)
                @GeneratedValue(generator = "gen_name")
                private Long userId;
            +asCode('java', '테이블').
                @Id
                @TableGenerator(
                    name = "gen_name",
                    table = "jpa_id",                    // ID 생성 테이블
                    pkColumnName = "id_name",            // 테이블 기본키
                    pkColumnValue = "jpa_user2_user_id", // 기준 행을 찾기 위한 기본키 값
                    valueColumnName = "next_id",         // id로 사용할 컬럼 이름
                    initialValue = 0,                    // 테이블에 행이 없는 경우 초기값으로 이용
                    allocationSize = 1
                )
                @GeneratedValue(generator = "gen_name")
                private Long userId;
        h2.marker @Temporal
        p date, time, timestamp 컬럼 명시. 각각 java.sql.Date, java.sql.Time, java.sql.Timestamp에 매핑
        h2.marker @Column
        ul
            | 필드 또는 getter 메서드에 대해 컬럼 정보 명시.
            li name : DB 컬럼 이름
            li unique : 이 컬럼만으로 unique key인 경우
            li length : 텍스트 길이
            li precision, scale : decimal 정밀도
            li insertable : insert 포함 여부
            li updatable : update 포함 여부
            +asCode('java').
                @Temporal(TemporalType.TIMESTAMP)
                @Column(insertable = false, updatable = false)
                    // ↑ false면 쿼리 실행 후 컬럼 값이 변경되도 객체에 반영되지 않음
                private Date addDate;
        h2.marker @Transient 또는 transient 한정자
        p 해당 필드는 persistence 대상에서 제외
        h2.marker @Enumerated
        p enum 매핑 : EnumType.ORDINAL, STRING 2가지만 가능
        h2.marker @Convert, @Converter
        p 커스텀 컨버터 지정
        +asCode('java').
            @Entity
            @Data
            @NoArgsConstructor
            @AllArgsConstructor
            class ApiAccessLog {
                private Long userId;
                private String requestApi;
                private String requestParam;
                @Convert(converter = ApiResultCode.class)
                private ApiResultCode apiResult;
                @Temporal(TemporalType.TIMESTAMP)
                private Date addDate;
            }

            interface EnumValue {
                //@com.fasterxml.jackson.annotation.JsonValue
                int getValue();
            }

            enum ApiResultCode implements EnumValue, AttributeConverter&lt;ApiResultCode, Integer> {
                /** 정상 */
                OK(200),
                /** 입력 불량 */
                BAD_REQUEST(400),
                /** 알 수 없는 서버 에러 */
                INTERNAL_ERROR(500),
                ;


                private final int value;
                private static final Map&lt;Integer, ApiResultCode> MAP = null /* EnumUtil.asMap(OK) */;


                //@com.fasterxml.jackson.annotation.JsonCreator
                public static ApiResultCode valueOf(int value) {
                    return MAP.get(value);
                }

                private ApiResultCode(int value) {
                    this.value = value;
                }

                @Override
                public int getValue() {
                    return value;
                }

                @Override
                public Integer convertToDatabaseColumn(ApiResultCode attribute) {
                    return getValue();
                }

                @Override
                public ApiResultCode convertToEntityAttribute(Integer dbData) {
                    return valueOf(dbData);
                }

            }
        h2.marker @DynamicInsert, @DynamicUpdate
        ul
            li Non-null 컬럼만 insert, update 시 이용.
            li 세션 당 최초 1번만 적용된다.
            li 쿼리 실행 후 생략된 컬럼 값이 변경되더라도, 객체에 설정되지 않는다.
        +asCode('java').
            @Entity(name = "jpa_user1")
            @DynamicInsert
            @DynamicUpdate
            @Data
            @NoArgsConstructor
            @AllArgsConstructor
            public class User1 {
                @Id
                @GeneratedValue(strategy = GenerationType.IDENTITY)
                private Long userId;
                private String nickname;
                @Temporal(TemporalType.TIMESTAMP)
                private Date addDate;
                @Temporal(TemporalType.TIMESTAMP)
                private Date updDate;
            }

            @Test
            void createUser1() {
                var user = new User1();
                user.setNickname("At" + System.nanoTime());
                user = user1Dao.save(user);
                assertTrue(user.getUserId() != null);   // ← 설정됨
                assertTrue(user.getAddDate() == null);  // ← 설정되지 않음
            }
        h2.marker @Embeddable, @Embedded, @AttributeOverride, @SecondaryTable
        ul
            li
                | 엔티티 필드 일부를 하나의 @Embeddable value 클래스로 묶을 수 있다. 
                +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/Price.java', 'java', null, true)
                +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/Item1.java', 'java', null, true)
            p Value class : 여타 ValueType과 마찬가지로 값을 이용해 비교하며, 자기 자신을 변경하지 않는다(getter만 제공).
            li
                | @AttributeOverride를 이용해 동일 @Embeddable 클래스를 여러 개 이용하는 경우에 대처할 수 있다
                +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/Item2.java', 'java', null, true)
            li
                | @Embeddable 클래스의 필드 일부도 다른 @Embeddable 클래스로 묶을 수 있다.
                +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/PricePair.java', 'java', null, true)
                +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/Item3.java', 'java', null, true)
            li @Embeddable 클래스로 복합키를 표현할 수 있다
            p 복합키 클래스는 Serializable 인터페이스를 구현하고, equals(), hashCode()를 적절히 재정의해야 한다.
            +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/ItemInfo3Key.java', 'java', null, true)
            +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/ItemInfo3.java', 'java', null, true)
            li @SecondaryTable을 이용해 다른 테이블(secondary table) 컬럼을 엔티티(primary table)에 포함할 수 있다
            ul
                li Default로 primary table의 기본키를 그대로 이용하여 조회한다
                +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/ItemInfo.java', 'java', null, true)
                +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/Item4.java', 'java', null, true)
                li pkJoinColumns으로 secondary table 기본키를 설정할 수 있다
                +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/Item5.java', 'java', null, true)
                li Select에 이용되는 쿼리는 left outer join이다.
 
        h2.marker 트랜잭션
        ul
            li RESOURCE_LOCAL 타입 트랜잭션
            ul
                li JPA의 EntityTransaction을 이용한 트랜잭션 처리
                li Spring Data JPA는 공유 EntityManager 인스턴스로 직접 트랜잭션 관리하는 것을 허용하지 않는다.
                +asCode('java').
                    @Autowired
                    private EntityManager manager;
                    @Test
                    void test() {
                        assertFalse(manager.isJoinedToTransaction());
                        var transaction = manager.getTransaction();
                        transaction.begin();
                        // java.lang.IllegalStateException: Not allowed to create transaction on shared EntityManager - use Spring transactions or EJB CMT instead
                        transaction.commit();
                    }
            li JTA(Java Transaction API) 타입 트랜잭션
            ul
                li 직접 트랜잭션을 관리하는 경우
                +asCode('java').
                    UserTransaction transaction;
                    EntityManager manager;

                    transaction.begin();
                    manager.joinTransaction();
                        // 트랜잭션에 참여시킨다. isJoinedToTransaction()으로 참여 여부 확인 가능.
                        // 트랜잭션 시작 후에 EntityManager가 초기화됐다면 자동으로 참여된다.
                    try {
                        transaction.commit();
                    } catch {
                        transaction.rollback();
                    }
                li 외부 컨테이너에서 관리하는 경우 : @Transactional 이용
                ul
                    li @Transactional은 전후에 트랜잭션의 시작, 커밋을 자동으로 진행한다
                    p RuntimeException을 포함하여, 예외를 감지하면 자동으로 롤백한다
                    li 클래스, 메서드 둘 다에 적용 가능하고, 메서드에 붙으면 클래스의 것을 오버라이드한다.
                    li @Transactional 메서드가 다른 @Transactional 메서드를 호출하고, 해당 메서드에서 롤백이 발생하면 default로 전역 롤백한다
                    p
                        +asA('https://docs.spring.io/spring/docs/5.2.8.RELEASE/javadoc-api/org/springframework/transaction/support/AbstractPlatformTransactionManager.html#setGlobalRollbackOnParticipationFailure-boolean-')
                        | 로 변경 가능
                +asCode('java').
                    @Test
                    @Transactional
                    @Rollback(false) // 테스트 자동 롤백하지 않도록 설정
                    void updateUser() {
                        assertTrue(manager.isJoinedToTransaction());
                    }
