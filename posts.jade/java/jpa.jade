include ../../source/skeleton.jade
+post('JPA', 'JPA, Java Persistence API, Hibernate, Spring Data JPA', 'JPA; Java Persistence API 정리')
    h1.marker JPA?
    div
        h2.marker 정의
        ul
            li
                strong Java Persistence API
                |  ::= Java ORM(Object-Relational Mapping)을 위한 명세
            p 객체지향 설계와 RDB의 설계를 둘 다 해치지 않으면서 둘 사이의 매핑을 지원 ─ 즉, 필요한 SQL을 자동으로 구성
            li SQL과 유사한, 객체를 이용한 JPQL(Java Persistence Query Language) 지원
            li 객체 상속 관계 사용 가능
            li 객체 참조 관계 유지 가능

        h2.marker JPA 사용
        p Hibernate와 같은 JPA 구현체(JPA Provider)를 이용하거나, 직접 구현하여 이용하면 된다
        
        h2.marker Spring Data JPA
        p JPA에 대한 추상화된 모듈을 제공하여 보다 쉬운 사용을 가능하게 한다

    h1.marker JPA 사용 정리
    div
        h2.marker 예시 코드
        table
            +ths('설명', '링크')
            tr
                td 전체 프로젝트
                td: +asA('https://github.com/Dong-gi/Dong-gi.github.io/tree/master/Repositories/STS/jpa-example')
            tr
                td 예시 코드 - 기본 CRUD
                td
                    +codeBtn('/Repositories/STS/jpa-example/src/main/resources/ddl/jpa_user.sql', 'sql', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/test/java/io/github/donggi/jpa/dao/UserDaoTests.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/User1.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/User2.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/dao/User1Dao.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/dao/User2Dao.java', 'java', null, true)
            tr
                td 예시 코드 - Converter
                td
                    +codeBtn('/Repositories/STS/jpa-example/src/main/resources/ddl/jpa_log.sql', 'sql', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/test/java/io/github/donggi/jpa/dao/ApiLogDaoTests.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/ApiLog.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/enums/ApiResultCode.java', 'java', null, true)
            tr
                td 예시 코드 - Embed
                td
                    +codeBtn('/Repositories/STS/jpa-example/src/main/resources/ddl/jpa_item.sql', 'sql', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/test/java/io/github/donggi/jpa/dao/ItemDaoTests.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/Item1.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/Price.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/Item2.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/Item3.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/PricePair.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/ItemInfo.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/Item4.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/Item5.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/ItemInfo3.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/ItemInfo3Key.java', 'java', null, true)
            tr
                td 예시 코드 - @OneToOne 단방향
                td
                    +codeBtn('/Repositories/STS/jpa-example/src/main/resources/ddl/jpa_user_card.sql', 'sql', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/test/java/io/github/donggi/jpa/dao/UserCard1DaoTests.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/UserCard1.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/User3.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/AbstractUser3.java', 'java', null, true)
            tr
                td 예시 코드 - @OneToOne 양방향
                td
                    +codeBtn('/Repositories/STS/jpa-example/src/main/resources/ddl/jpa_user_card.sql', 'sql', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/test/java/io/github/donggi/jpa/dao/UserCard2DaoTests.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/UserCard2.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/UserWithCard1.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/AbstractUser3.java', 'java', null, true)

        h2.marker EntityManager
        div
            h3.marker Persistence context; 영속 컨텍스트
            ul
                li DB에서 읽어오거나 DB로 삽입하고자 추가한 객체들은 영속 객체(Persistence object)들로, EntityManager가 관리하는 영속 컨텍스트에 보관된다
                p 트랜잭션(@Transactional 포함) 안에서 엔티티 수정 시 트랜잭션 커밋 시점에 자동 반영. 또는 flush()로 즉시 반영.
                li 트랜잭션 커밋 시점 또는 명시적인 flush() 호출로 영속 컨텍스트의 변경 사항이 DB에 실제 반영된다
                li 영속 객체는 (타입 + 식별자)를 키로 하는 Map으로 관리된다.
                ul
                    li 이를 이용해 조회(find)하려는 엔티티가 이미 컨텍스트에 있다면 DB에 쿼리를 보내지 않고 즉시 컨텍스트의 객체를 반환한다
                    li @Id를 @GeneratedValue(strategy = GenerationType.IDENTITY)로 구성하는 경우, 커밋 전에 식별자를 얻기 위해 미리 insert 쿼리가 실행된다
                li 영속 객체 생애 주기
                +w3img('/imgs/20200731_215700.png', 'Entity Life Cycle')
                ul
                    li Managed : 변경이 존재하면 DB에 반영됨
                    li Detached : EntityManager가 닫혔거나, 롤백되어 분리된 상태. 변경이 DB에 반영되지 않음
                    li Removed : 커밋 또는 flush() 호출 시 DB에서 삭제
            h3.marker EntityManager를 직접 관리하는 경우
            ol
                li EntityMaganerFactory를 만든다
                li EntityManager가 필요할 때마다 팩터리로부터 하나 생성하고, 사용한 뒤에 직접 닫는다
                li 트랜잭션이 여러 메서드에 걸쳐있는 경우, 동일한 EntityManager를 이용함을 직접 보장해야 한다
                p 메서드 파라미터로 넘기거나 ThreadLocal을 이용하거나... 구현은 자유
            h3.marker EntityManager를 컨테이너에서 관리하는 경우
            p @PersistenceContext로 현재 EntityManager 인스턴스를 주입받으면 된다. Spring Data JPA 에서는 @Autowired도 가능
            h3.marker 메서드
            ul
                li void persist(Object entity)
                p 객체를 영속 컨텍스트에 등록하여 변경이 DB에 반영되도록 한다.
                li &lt;T> T find(class&lt;T> entityClass, ...)
                p 지정 (타입 + 기본키)를 이용해 객체를 조회한다. 영속 컨텍스트에 있다면 DB를 조회하지 않고 해당 객체를 반환한다. DB에도 없으면 null 리턴
                li &lt;T> T getReference(class&lt;T> entityClass, Object primaryKey)
                ul
                    li 쿼리 지연 실행. 우선 T 프록시를 반환. 프록시 최초 사용 시 쿼리 실행되며, DB에 없으면 EntityNotFoundException
                    li 사용하는 EntityManager를 닫기 전에 프록시를 사용해야 쿼리가 실행된다
                    li Hibernate의 경우, final entity class에 대하여 쿼리 즉시 실행
                li void remove(Object entity)
                p 객체를 DB에서 삭제하도록 한다.
                li void detach(Object entity)
                p 객체를 영속 컨텍스트로부터 분리한다. 따라서 영속 객체의 변경 사항이 DB에 반영되지 않도록 한다.
                li void clear()
                p 영속 컨텍스트를 비우고 모든 객체를 detached 상태로 변경한다.
                li &lt;T> T merge(T entity)
                p 객체를 현재 영속 컨텍스트에 등록한다.
                li boolean contains(Object entity)
                p 객체가 영속 컨텍스트에 포함됐는지 여부
                li void flush()
                p 영속 컨텍스트를 DB로 동기화한다
                li void refresh(Object entity, ...)
                p 특정 객체를 DB로부터 동기화한다
                li void lock(Object entity, LockModeType lockMode, ...)
                p 영속 컨텍스트의 객체를 잠근다.
                //- Query createQuery(String qlString)
                //- https://javaee.github.io/javaee-spec/javadocs/javax/persistence/EntityManager.html
        h2.marker @Entity
        ul
            li DB 입출력 단위
            li 기본 생성자 필수. @Id 최소 한 개 지정 필수
            li 원활한 프록시 동작을 위해 protected 이상, non-final 클래스로 정의
        +asCode('java', '@Entity 예').
            @Entity
            public class MMonster {}
            @Entity(name = "m_monster_v2")
            public class MMonster {}
        h2.marker @Table
        ul
            li @Entity 클래스에 name, catalog, index, schema, UniqueConstraint 설정 추가
            li name 속성만 필요하다면 @Entity에 직접 설정 가능
        h2.marker @Id
        p 기본키 컬럼 명시. 기본 타입 + Wrapper 타입, Date, BigInteger, BigDecimal 타입만(should) 가능
        h2.marker @GeneratedValue, @SequenceGenerator, @TableGenerator
        ul
            +asCode('java', '기본키 자동 설정').
                @Id
                @GeneratedValue(strategy = GenerationType.IDENTITY)
                private Long userId;
            li strategy = GenerationType.IDENTITY
            p DB 설정(MySQL auto_increment, PostgreSQL serial) 그대로 이용. insert 실행 후 실제 값이 설정된다.
            li generator = "gen_name" : 시퀀스 또는 ID 생성 테이블 이용
            +asCode('java', '1. 시퀀스').
                @Id
                @SequenceGenerator(name = "gen_name", sequenceName = "jpa_user2_user_id_seq", allocationSize = 1)
                @GeneratedValue(generator = "gen_name")
                private Long userId;
            +asCode('java', '2. 테이블').
                @Id
                @TableGenerator(
                    name = "gen_name",
                    table = "jpa_id",                    // 테이블 이름
                    pkColumnName = "id_name",            // 테이블 기본키
                    pkColumnValue = "jpa_user2_user_id", // 기준 행을 찾기 위한 기본키 값
                    valueColumnName = "next_id",         // id로 사용할 컬럼 이름
                    initialValue = 0,                    // 테이블에 행이 없는 경우 초기값으로 이용
                    allocationSize = 1
                )
                @GeneratedValue(generator = "gen_name")
                private Long userId;
        h2.marker @Temporal
        p date, time, timestamp 컬럼 명시. 각각 java.sql.Date, java.sql.Time, java.sql.Timestamp에 매핑
        h2.marker @Column
        ul
            | 필드 또는 getter 메서드에 대해 컬럼 명시.
            li name : 컬럼 이름
            li unique : 이 컬럼만으로 unique key인 경우
            li length : 텍스트 길이
            li precision, scale : decimal 정밀도
            li insertable : insert 포함 여부
            li updatable : update 포함 여부
            +asCode('java').
                @Temporal(TemporalType.TIMESTAMP)
                @Column(insertable = false, updatable = false)
                    // ↑ false면 쿼리 실행 후 컬럼 값이 변경되도 객체에 반영되지 않음
                private Date addDate;
        h2.marker @Transient 또는 transient 한정자
        p 해당 필드는 persistence 대상에서 제외
        h2.marker @Enumerated
        p enum 매핑 : EnumType.ORDINAL, STRING 2가지만 가능
        h2.marker @Convert, @Converter
        p
            | 커스텀 컨버터 지정 
            +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/ApiLog.java', 'java', [19], true)
            +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/enums/ApiResultCode.java', 'java', [9], true)
        h2.marker @DynamicInsert, @DynamicUpdate
        ul
            li Non-null 컬럼만 insert, update 시 이용.
            li 세션 당 최초 1번만 적용된다.
            li 쿼리 실행 후 생략된 컬럼 값이 변경되더라도, 객체에 설정되지 않는다.
            +codeBtn('/Repositories/STS/jpa-example/src/test/java/io/github/donggi/jpa/dao/UserDaoTests.java', 'java', [18], true)
            +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/User1.java', 'java', [19], true)

        h2.marker 다른 엔티티 포함
        ul
            li
                | 엔티티 필드 일부를 하나의 @Embeddable value 클래스로 묶을 수 있다. 
                +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/Price.java', 'java', [9], true)
                +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/Item1.java', 'java', [12], true)
            p Value class : 여타 ValueType과 마찬가지로 값을 이용해 비교하며, 자기 자신을 변경하지 않는다(getter만 제공).
            li
                | @AttributeOverride를 이용해 동일 @Embeddable 클래스를 여러 개 이용하는 경우에 대처할 수 있다
                +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/Item2.java', 'java', [15], true)
            li
                | @Embeddable 클래스의 필드 일부도 다른 @Embeddable 클래스로 묶을 수 있다.
                +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/PricePair.java', 'java', [12], true)
                +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/Item3.java', 'java', [12], true)
            li @Embeddable 클래스로 복합키를 표현할 수 있다
            p
                | 복합키 클래스는 Serializable 인터페이스를 구현하고, equals(), hashCode()를 적절히 재정의해야 한다. 
                +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/ItemInfo3Key.java', 'java', [12], true)
                +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/ItemInfo3.java', 'java', [10], true)
            li @SecondaryTable을 이용해 다른 테이블(secondary table) 컬럼을 엔티티(primary table)에 포함할 수 있다
            ul
                li
                    | Default로 primary table의 기본키를 그대로 이용하여 조회한다 
                    +codeBtn('/Repositories/STS/jpa-example/src/main/resources/ddl/jpa_item.sql', 'sql', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/ItemInfo.java', 'java', [9], true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/Item4.java', 'java', [17], true)
                li
                    | pkJoinColumns으로 secondary table 기본키를 설정할 수 있다 
                    +codeBtn('/Repositories/STS/jpa-example/src/main/resources/ddl/jpa_item.sql', 'sql', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/ItemInfo.java', 'java', [9], true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/Item5.java', 'java', [18], true)
                li Select에 이용되는 쿼리는 left outer join이다.
            li @OneToOne으로 다른 엔티티를 1개 포함할 수 있다
            ul
                li
                    | 1:1 단방향 매핑 
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/UserCard1.java', 'java', [13], true)
                ul
                    li @JoinColumn으로 기본키를 설정한다. @SecondaryTable과는 다르게 조인 컬럼 자체를 영속 필드로 가질 수는 없고, 대신 매핑된 엔티티 변경에 따라 자동으로 조인 컬럼 값을 변경한다.
                    li 두 테이블의 기본키가 동일한 경우 @JoinColumn 대신 @PrimaryKeyJoinColumn을 이용할 수 있다
                    p 이 경우 신규 엔티티 삽입을 위해 식별자가 필요하므로, 참조하는 테이블의 신규 엔티티가 먼저 영속 컨텍스트에 등록되어야 한다
                li 쿼리 지연 실행
                p Default로 처음부터 연관 테이블을 함께 조회(left outer join)한다. fetch 속성으로 변경할 수 있다.
                +asCode('java') @OneToOne(fetch = FetchType.LAZY)
                li
                    | 1:1 단방향 매핑을 그대로 양방향 매핑으로 이용 
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/UserCard2.java', 'java', [13], true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/UserWithCard1.java', 'java', [13], true)
                +asCode('java') @OneToOne(mappedBy = "fieldName")

        h2.marker 하이버네이트 관련 참고사항
        ul
            li 지연 로딩된 프록시 인스턴스의 실제 클래스 반환
            +asCode('java') HibernateProxyHelper.getClassWithoutInitializingProxy(proxy)
 
        h2.marker 트랜잭션
        ul
            li RESOURCE_LOCAL 타입 트랜잭션
            ul
                li JPA의 EntityTransaction을 이용한 트랜잭션 처리
                li Spring Data JPA는 공유 EntityManager 인스턴스로 직접 트랜잭션 관리하는 것을 허용하지 않는다.
                +asCode('java').
                    @Autowired
                    private EntityManager manager;
                    @Test
                    void test() {
                        assertFalse(manager.isJoinedToTransaction());
                        manager.getTransaction().begin();
                        // java.lang.IllegalStateException: Not allowed to create transaction on shared EntityManager - use Spring transactions or EJB CMT instead
                        manager.getTransaction().commit();
                    }
            li JTA(Java Transaction API) 타입 트랜잭션
            ul
                li 직접 트랜잭션을 관리하는 경우
                +asCode('java').
                    UserTransaction transaction;
                    EntityManager manager;

                    transaction.begin();
                    manager.joinTransaction();
                        // 트랜잭션에 참여시킨다. isJoinedToTransaction()으로 참여 여부 확인 가능.
                        // 트랜잭션 시작 후에 EntityManager가 초기화됐다면 자동으로 참여된다.
                    try {
                        transaction.commit();
                    } catch {
                        transaction.rollback();
                    }
                li 외부 컨테이너에서 관리하는 경우 : @Transactional 이용
                ul
                    li @Transactional은 전후에 트랜잭션의 시작, 커밋을 자동으로 진행한다
                    p RuntimeException을 포함하여, 예외를 감지하면 자동으로 롤백한다
                    li 클래스, 메서드 둘 다에 적용 가능하고, 메서드에 붙으면 클래스의 것을 오버라이드한다.
                    li @Transactional 메서드가 다른 @Transactional 메서드를 호출하고, 해당 메서드에서 롤백이 발생하면 default로 전역 롤백한다
                    p
                        +asA('https://docs.spring.io/spring/docs/5.2.8.RELEASE/javadoc-api/org/springframework/transaction/support/AbstractPlatformTransactionManager.html#setGlobalRollbackOnParticipationFailure-boolean-')
                        | 로 변경 가능
                +asCode('java').
                    @Test
                    @Transactional
                    @Rollback(false) // 테스트 자동 롤백하지 않도록 설정
                    void updateUser() {
                        assertTrue(manager.isJoinedToTransaction());
                    }
