include ../../source/skeleton.jade

+post('개발자 면접 준비', '개발자, 면접, 이력서, 자기소개서, 코딩 테스트, 준비', '개발자 면접 준비 도움말')
    h1.marker 참고 도서 정보
    .w3-row
        .w3-col.s2.w3-center
            +w3img(src='https://www.hanbit.co.kr/data/books/B7155705626_l.jpg', '도서 이미지')&attributes({style: 'max-height:210px'})
        .w3-col.s10
            table.no-sort
                +tds('제목', '(JAVA) 프로그래밍 면접 이렇게 준비한다')
                +tds('저자', '지은이: 노엘 마크엄 옮긴이: 정원천')
                +tds('ISBN', '978-89-6848-152-9 [93000]')
                +tds('발행일', '2015년 02월 01일')
                +tds('발행처', '한빛미디어')
        h2.marker 책의 오류
        ul
            li 80p 정수 타입 배열에는 final 키워드를 사용할 수 없다
            p -> 배열 원소의 타입과 무관하게 final 키워드 사용 가능하며, 해당 변수 초기화 이후 재할당은 불가하다
    .w3-row
        .w3-col.s2.w3-center
            +w3img(src='https://www.hanbit.co.kr/data/books/B9005920688_l.jpg', '도서 이미지')&attributes({style: 'max-height:210px'})
        .w3-col.s10
            table.no-sort
                +tds('제목', '프로그래밍 면접 이렇게 준비한다')
                +tds('저자', '존 몽건,노아 킨들러,에릭 기게리 지음 서환수 옮김')
                +tds('ISBN', '979-11-6224-199-8 [93000]')
                +tds('발행일', '2019년 07월 04일')
                +tds('발행처', '한빛미디어')

    h1.marker 이력서
    ol
        li 전문성과 기술을 어필
        li 2p 이내로 요약하는 것이 좋다
        +asCode().
            # 지원 동기와 현재까지 경력을 요약한 첫 문단

            # 개발 언어, 운영체제, IDE, VCS 등

            # 경력 사항
            - 업무 기간, 장소, 수행 역할, 성과

            # 최종 학력

    h1.marker 자기소개서
    ol
        li 팀(회사)에 어울리는 사람임을 어필
        ul
            li 이력서의 내용 중 지원하는 역할과 관련 있는 내용을 강조
            li 구체적인 지원 동기
        li 1p 이내로 작성
        li 이력 사이의 공백에 대해 설명

    h1.marker 면접
    ul
        li 어떤 사업을 하는 회사인지, 무료 상용 서비스가 있다면 직접 체험할 필요도 있다
        li 스타트업 같은 소규모 회사는 CET, CTO 등의 SNS를 통해 동향 파악 가능
        li 면접관이 질문이 있는지 물었을 때, 없다고 답하면 부정적으로 보일 수 있음
        li 코딩 면접
        ul
            li 발생 가능한 예외, 경계조건에서의 동작 확인
            li 단위 테스트 꼭 작성

    h1.marker Java 질문
    ol
        li Comparable, Comparator 인터페이스의 차이?
        p Comparable은 클래스의 자연스러운 정렬 순서를, @FunctionalInterface Comparator는 필요에 따른 임의 정렬 순서를 의미한다

        li 서로 다른 키 객체의 hashCode() 결과가 동일한데도 HashSet, HashMap이 여전히 잘 작동하는 이유?
        p hashCode()에 대응하는 버킷 리스트의 각 버킷은 여전히 키 객체를 저장하고 있으므로 2차적인 비교를 통해 구별이 가능하기 때문

        li String interning?
        p 서로 다른 위치에 존재하는 같은 내용의 String 리터럴이 상수 풀의 단일 String 객체를 참조하는 것

        li Vector, Hashtable 클래스가 이미 있는데 ArrayList, HashMap이 추가된 이유?
        ul
            li Vector, Hashtable은 동기화되어 병렬 처리에 적합하지만, 병렬 처리할 일이 없다면 불필요한 오버헤드만 발생한다
            li 따라서 스레드-안전할 필요가 없다면 각각 ArrayList, HashMap를 이용하는 것이 좋다
            li 추가적으로, 높은 병렬성이 요구된다면 ConcurrentHashMap을 이용하는 것이 좋다

        li 병렬로 실행되는 코드를 테스트하려면?
        ol
            li 테스트 스레드에서 실행되도록 Executor 변경
            +asCode('java').
                @Test
                void test() {
                    final var executor = new Executor() {
                        @Override
                        public void execute(final Runnable command) {
                            command.run();
                        }
                    }
                    // ...
                }
            li 병렬 스레드가 종료되기를 기다림
            ol
                li 모든 작업을 등록한 뒤 ExecutorService의 shutdown()을 호출하여 추가 작업을 받지 않도록 한다
                li isTerminated() 또는 awaitTermination()으로 종료 확인