<html lang="ko"><head><script id="google-analytics" src="https://www.googletagmanager.com/gtag/js?id=UA-143098403-1" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-143098403-1');
</script><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="google-site-verification" content="aH-DyzdytYQ0NPHNQFcs5dVoiu5YNs6CEEHYgqDmAFM"><meta name="author" content="Donggi Kim &lt;hi.donggi@gmail.com&gt;"><meta name="keywords" content="Network, TCP/IP, HTTP, HTTP1.1, HTTP2, HTTP3"><meta name="description" content="Network 정리"><title>Network</title><link id="w3css" rel="stylesheet" href="/source/w3.css"><link id="highlight-style" rel="stylesheet" href="/source/xcode.css"><link id="default-style" rel="stylesheet" href="/source/default.css"><script id="highlight-js" src="/source/highlight.pack.js"></script><script id="default-js" src="/source/default.min.js"></script><script id="dsq-count-scr" src="//donggi.disqus.com/count.js" async></script></head><body><div class="w3-bar-block w3-sidebar w3-animate-left" id="sidebar"><hr><a class="w3-bar-item w3-button" href="javascript:closeSidebar();">Close &times;</a><hr><div id="marker-list"></div><hr><div id="post-list"></div><hr><div id="file-list"></div><hr></div><div id="main"><div class="w3-bar w3-blue w3-large" id="nav" style="position:-webkit-sticky;position:sticky;top:0px;vertical-align:middle"><button class="w3-bar-item w3-button w3-hover-theme" onclick="toggleSidebar()">&#9776;</button><input class="w3-bar-item" id="query" type="text" placeholder="search" style="max-width:35%"><a class="w3-bar-item w3-button w3-hover-theme" href="/">Home</a></div><div class="w3-padding" id="contents"><h1>TCP/IP 4계층</h1><ol><li>Application : HTTP, FTP, DNS, SMTP, ...</li><li>Transport : TCP, UDP</li><p>프로세스 간의 통신</p><li>Internet : IP, ARP, ICMP, ...</li><p>(가변적인) 논리적 주소를 갖는 두 호스트 간의 통신</p><li>Link : MAC; CSMA/CD, CSMA/CA, ...</li><p>고정적인 물리적 주소를 갖는 두 노드 간의 통신</p></ol><h1>IP</h1><div><h2>IPv4</h2><ul><li>32bit : [0-255].[0-255].[0-255].[0-255]</li><li>Subnet & CIDR</li><ul><li>주소 소유자는 예약한 특정 접두 주소(subnet mask)를 제외한 나머지 부분을 자유롭게 할당하여 사용할 수 있다</li><li>A-class : 앞 8비트를 예약하고, 나머지 24비트를 자유롭게 할당. e.g. 123.0.0.0/8</li><li>B-class : 앞 16비트를 예약하고, 나머지 16비트를 자유롭게 할당. e.g. 123.123.0.0/8</li><li>기타 관용적인 사설 네트워크 서브넷 : 10.0.0.0/8, 192.168.0.0/24</li><li>CIDR; Classless Inter-Domain Routing</li><p>클래스없이 주소 블록 할당. e.g. 123.123.123.123/7</p></ul></ul><h2>IPv6</h2><ul><li>128bit : [0-ffff]:[0-ffff]:[0-ffff]:[0-ffff]:[0-ffff]:[0-ffff]:[0-ffff]:[0-ffff]</li><li>접두 0은 제거할 수 있다 + 반복 적용 가능; 0123:A:0123 == 123:A:123</li><li>0:0(:0)*은 :으로 축약할 수 있다 + 전체 주소에 대해 1회만 적용 가능; A:0:0:B == A::B</li></ul></div><h1>UDP; User Datagram Protocol</h1><div><h2>특징</h2><ul><li>비연결형</li><p>특정 소켓으로의 전송, 임의 소켓으로부터의 수신 기능만 존재. 각 데이터그램은 모두 독립적이며, 65507 바이트보다 큰 메시지를 알아서 쪼개고 합치지 않는다.</p><li>신뢰성 없음</li><p>확인응답 없음 + 데이터그램 오류 탐지 시 단순 폐기</p></ul><h2>Datagram</h2><p>Source port 16비트 | Destination port 16비트 | Total length(최대 65507바이트) 16비트 | Checksum 16비트 | Data</p></div><h1>TCP; Transmission Control Protocol</h1><div><h2>특징</h2><ul><li>연결 지향</li><p>연결 지속되는 채널을 이용해 스트림 전송. 스트림은 패킷들로 나눠지고, 이때 패킷은 IP 계층 전송 단위에 맞게 세그먼트로 표현된다</p><li>송신 버퍼 + 수신 버퍼를 이용한 생산/소비 균형 조절</li><li>신뢰성 있음</li><p>패킷 순서 보장. ack 응답 및 응답 시간제한, 재전송 기능 제공</p><li>전이중 통신</li><p>동시에 양방향으로 패킷 전송 가능</p></ul><h2>연결 수립; 3-way handshaking</h2><ol><li>A -> B : SYN 세그먼트(#seq=a)</li><li>B -> A : SYN + ACK 세그먼트(#seq=b,#ack=a+1)</li><li>A -> B : ACK 세그먼트(#seq=a+1,#ack=b+1)</li><p>양쪽이 동시에 연결을 요구하더라도 연결은 하나만 수립된다</p></ol><h2>연결 종료; 3-way handshaking</h2><ol><li>A -> B : FIN 세그먼트(#seq=a,#ack=b)</li><li>B -> A : FIN + ACK 세그먼트(#seq=b,#ack=a+1)</li><li>A -> B : ACK 세그먼트(#seq=a+1,#ack=b+1)</li></ol><h2>연결 종료; 4-way handshaking</h2><ol><p>데이터를 보낼 게 남아있다면, FIN 요청은 수락한 뒤, 데이터를 마저 보낸 후 FIN 응답한다</p><li>A -> B : FIN 세그먼트(#seq=a,#ack=b1)</li><li>B -> A : FIN + ACK 세그먼트(#seq=b1,#ack=a+1)</li><li>남은 데이터 전송</li><ul><li>B -> A : 데이터 세그먼트</li><li>A -> B : ACK 세그먼트</li></ul><li>B -> A : FIN 세그먼트(#seq=b2,#ack=a+1)</li><li>A -> B : ACK 세그먼트(#seq=a+1,#ack=b2+1)</li></ol><h2>TCP 소켓 상태</h2><div class="w3-center w3-margin-bottom"><img class="w3-round" src="https://upload.wikimedia.org/wikipedia/commons/f/f6/Tcp_state_diagram_fixed_new.svg"></div><ul><li>CLOSED : 연결 없음</li><li>LISTEN : Passive open; 서버 소켓 개방 -> SYN 대기</li><li>SYN SENT : Active open; 클라이언트 SYN 전송 -> ACK 대기</li><li>SYN RECEIVED : SYN+ACK 전송 -> ACK 대기</li><li>ESTABLISHED : 연결 수립. 데이터 전송 가능</li><li>FIN WAIT 1 : 클라이언트가 ESTABLISHED 상태에서 연결 종료하기로 결정 -> 1번째 FIN 전송 -> ACK 대기</li><li>FIN WAIT 2 : FIN WAIT 1에서 ACK 수신 -> 2번째 FIN 대기</li><li>CLOSING : FIN WAIT 1 상태에서 FIN 수신 == 동시 종료 결정</li><li>TIME WAIT : 연결 종료; 일정 시간 후 CLOSED 천이</li><li>CLOSE WAIT : 서버가 ESTABLISHED 상태에서 1번째 FIN 수신 -> ACK 전송 -> 애플리케이션의 소켓 연결 종료 대기</li><li>LAST ACK : CLOSE WAIT 상태에서 연결 종료 결정 -> 2번째 FIN 전송 -> ACK 대기</li><h3>RST 세그먼트</h3><ul><li>연결 요청 거부 -> 즉시 CLOSED 천이</li><li>기존 연결 중단 -> 즉시 CLOSED 천이</li><li>휴지 상태 연결 종료 -> 즉시 CLOSED 천이</li><li>RST 세그먼트를 수신한 쪽도 즉시 CLOSED 천이</li></ul></ul></div><h1>SCTP; Stream Control Transport Protocol</h1><div><h2>정의</h2><ul><li>Association ::= 두 SCTP 종단점 사이의 연결</li><ul><li>서버, 클라이언트 각각은 SCTP 헤더의 VT(Verification Tag)에 각자의 association 구별을 위한 32비트 값을 설정한다</li><p>즉, 양쪽에서 전송하는 VT는 서로 다를 수 있다</p><li>서버, 클라이언트 각각은 수신한 VT와 동일한 값으로 응답 패킷의 VT를 설정한다</li><p>따라서, 응답받은 쪽은 응답 VT를 이용해 어떤 association으로 보냈는지 판별 가능</p><li>따라서 TCP와 달리, 같은 소켓으로부터 패킷이 오더라도 실제로 유효한 연결(association)에 해당하는 패킷인지 구별할 수 있다</li></ul><li>Chunk ::= SCTP의 데이터 전송 단위</li><p>TCP의 스트림과 달리, 단편화가 이뤄지더라도 메시지의 시작과 끝이 명확히 구분된다</p></ul><h2>특징</h2><ul><li>하나의 association 내에서 다중스트림 지원</li><p>스트림 하나가 블록되더라도 다른 스트림들은 전송을 계속할 수 있다</p><li>Multi-homing 지원</li><p>Primary 주소가 비가용 상태가 되더라도 alternative 주소를 통해 연결을 지속할 수 있다</p><li>TCP와 마찬가지로 전이중, 신뢰성 있는 통신 제공</li><p>+ 흐름 제어, 오류 제어, 혼잡 제어 기능 제공</p><li>TCP는 제어 정보를 헤더로 이용하는 반면, SCTP는 제어 정보 또한 하나의 chunk로 전송한다</li><p>따라서 SCTP는 12바이트 고정 헤더를 사용한다</p><li>하나의 SCTP 패킷이 여러 chunk들을 포함할 수 있다</li><p>이때 각 chunk들은 각각 다른 스트림에 속할 수 있다</p><li>TCP의 ACK, FIN 세그먼트와 달리, SCTP의 확인 응답 등에 이용되는 제어 chunk는 TSN을 필요로 하지 않는다</li><p>제어 chunk는 다른 종류의 제어 chunk에 의해 응답되고, 일부는 아예 응답이 필요하지 않다</p><li>Numbering</li><ul><li>스트림은 16비트 SI(Stream Identifier)를 갖는다</li><li>DATA Chunk 전송 순서를 위해 순차적인 32비트 TSN(Transmission Sequence Number)을 사용한다</li><li>스트림 내 chunk 순서를 표시하기 위해 SSN(Stream Sequence Number)을 사용한다</li><p>SI와 SSN을 이용해 chunk가 목적지에 도달하면 적절한 스트림에 전달되어 올바른 순서에 놓인다</p></ul></ul><h2>Chunk 종류</h2><table class="no-sort"><tr><td>0</td><td>DATA</td><td>User data. TSN을 사용하는 유일한 chunk type</td></tr><tr><td>1</td><td>INIT</td><td>Association 시작. 다른 chunk와 같이 보낼 수 없다</td></tr><tr><td>2</td><td>INIT ACK</td><td>INIT에 대한 확인응답. 다른 chunk와 같이 보낼 수 없다</td></tr><tr><td>10</td><td>COOKIE ECHO</td><td>INIT ACK에 포함된 쿠키를 되돌려 보낸다</td></tr><tr><td>11</td><td>COOKIE ACK</td><td>COOKIE ECHO에 대한 확인응답</td></tr><tr><td>3</td><td>SACK</td><td>데이터 chunk에 대한 확인응답</td></tr><tr><td>4</td><td>HEARTBEAT</td><td>살아있는 지 문의</td></tr><tr><td>5</td><td>HEARTBEAT ACK</td><td>HEARTBEAT에 대한 확인응답</td></tr><tr><td>7</td><td>SHUTDOWN</td><td>Association 종료</td></tr><tr><td>8</td><td>SHUTDOWN ACK</td><td>SHUTDOWN에 대한 확인응답</td></tr><tr><td>14</td><td>SHUTDOWN COMPLETE</td><td>SHUTDOWN ACK에 대한 확인응답</td></tr><tr><td>9</td><td>ERROR</td><td>수신한 패킷에서 오류를 검출한 경우</td></tr><tr><td>6</td><td>ABORT</td><td>오류로 인해 association을 종결해야 하는 경우</td></tr><tr><td>192</td><td>FORWARD TSN</td><td>누적 TSN을 조정하려는 경우</td></tr></table><h2>쿠키를 이용한 SYN 플러딩 방지</h2><ul><li>SCTP는 COOKIE ECHO chunk를 받은 후에야 비로소 리소스를 할당한다</li><li>COOKIE ECHO가 실제로 INIT -> INIT ACK를 거쳤다는 것을 검증하기 위해, 쿠키에는 서버의 비밀키가 연관된 digest가 담긴다</li></ul><h2>상태 천이 다이어그램</h2><div class="w3-center w3-margin-bottom"><img class="w3-round" src="/imgs/SCTP-state-diagram.png"></div><ul><li>Closed : Association 없음</li><li>Cookie Wait : INIT 보낸 후 INIT ACK에 포함된 쿠키 대기 중</li><li>Cookie Echoed : COOKIE ECHO 보낸 후 COOKIE ACK 대기 중</li><li>Established : COOKIE ACK를 받아 association 수립</li><li>Shutdown Pending : close 신호를 받아 SHUTDOWN을 보내기 전에, 남은 데이터 chunk를 보내는 중</li><li>Shutdown Sent : 남은 데이터 chunk가 없어 SHUTDOWN 전송하고 SHUTDOWN ACK 대기; 이후 데이터 chunk는 전송되지 않는다</li><li>Shutdown Received : SHUTDOWN 수신. 남은 데이터 chunk가 있다면 마저 보낸 뒤 SHUTDOWN ACK 전송; 이후 데이터 chunk는 전송되지 않는다</li><li>Shutdown Ack Sent : SHUTDOWN ACK를 보내고 SHUTDOWN COMPLETE 대기</li></ul></div><h1>HTTP</h1><div><h2>HTTP/0.9</h2><p>GET 메서드(요청 헤더도 없음)로 HTML 텍스트를 가져오는 기능 제공</p><h2>HTTP/1.0</h2><ul><li>PUT 등 다른 요청 메서드 지원</li><li>요청 헤더 지원</li><li>응답 코드 추가</li><li>리다이렉션 지원</li><li>컨텐츠 인코딩(압축 포함) 제공</li><li>조건부 요청</li></ul><h2>HTTP/1.1</h2><ul><li>Host 헤더 필수 지정</li><li>동일 서버에 대한 여러 요청을 하나의 커넥션으로 순차적으로 수행 가능</li><li>OPTIONS 메서드 지원</li><li>Upgrade 헤더 지원</li><li>cacheability 헤더 확장</li></ul><h2>HTTP/2 <a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://datatracker.ietf.org/doc/html/rfc7540">rfc7540</a></h2><ul><li>요청 헤더 압축 지원</li><li>동일 서버에 대해 하나의 커넥션으로 여러 요청 동시 수행 가능</li></ul><div><h3>스트림 & 프레임</h3><ul><li>클라이언트와 서버는 하나의 연결 안에서 여러 스트림을 열어 통신을 수행한다</li><li>전송 단위는 프레임으로, 기존 텍스트 형식을 버리고 정형화된 바이너리 포맷을 이용한다</li><p><strong>↓ 기존 HTTP 패킷 예</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="HTTP">GET / HTTP/1.1\r\n
Host: localhost:8000\r\n
User-Agent: Mozilla/5.0 ...\r\n
Accept: text/html,application/xhtml+xml,...\r\n
...\r\n
Content-Length: 345\r\n
\r\n
request body...\r\n</div><p><strong>↓ HTTP/2 frame format</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">+-----------------------------------------------+
|                 Length (24)                   |
+---------------+---------------+---------------+
|   Type (8)    |   Flags (8)   |
+-+-------------+---------------+-------------------------------+
|R|                 Stream Identifier (31)                      |
+=+=============================================================+
|                   Frame Payload (0...)                      ...
+---------------------------------------------------------------+</div><ul><li>Length : 기본 프레임 최대 길이는 2^14바이트로, 더 큰 값을 사용하려면 SETTINGS 프레임으로 협상해야 한다</li><p>\r\n을 이용해 끝까지 파싱해야만 포맷 일치 여부를 알 수 있고, \n만 보내는 클라이언트에 대응하고, 미리 알 수 없는 컨텐츠 길이에 대해 걱정하던 부분이 해소되었다</p><li>Type</li><table class="no-sort"><tr><td>0</td><td>DATA</td><td>데이터</td></tr><tr><td>1</td><td>HEADERS</td><td>HTTP 헤더</td></tr><tr><td>2</td><td>PRIORITY</td><td>스트림 우선순위</td></tr><tr><td>4</td><td>SETTINGS</td><td>연결 매개변수 설정</td></tr><tr><td>5</td><td>PUSH_PROMISE</td><td>서버 푸시</td></tr><tr><td>6</td><td>PING</td><td>연결 시험</td></tr><tr><td>8</td><td>WINDOW_UPDATE</td><td>흐름제어</td></tr><tr><td>9</td><td>CONTINUATION</td><td>HEADERS, PUSH_PROMISE, CONTINUATION을 한 프레임으로 전송을 끝내지 못하는 경우, 나머지 연장 부분</td></tr><tr><td>3</td><td>RST_STREAM</td><td>스트림 즉시 종료</td></tr><tr><td>7</td><td>GOAWAY</td><td>연결 종료</td></tr></table><li>Stream Identifier : 프레임이 속한 스트림 표시</li></ul><li>x번 스트림으로 요청된 프레임은 동일한 x번 스트림을 통해 응답받는다</li></ul></div><h2>HTTP/3</h2><ul><li>TCP 대신 UDP 기반 프로토콜, QUIC(<a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://datatracker.ietf.org/doc/html/rfc9000">rfc9000</a>)으로 전환</li><p>HTTP/2가 애플리케이션 계층의 HOL 문제를 해소했지만, 여전히 TCP 자체의 HOL 문제가 남아있었다</p><li>TCP가 제공하는 혼잡 제어 등의 기능이 커널 공간에서 동작하는 반면, HTTP/3은 유저 공간에서 실행하는 대신 알고리즘을 자주 업데이트 가능</li><li>TLS 대신 이에 상응하는 DTLS를 이용해 보안 통신 가능</li></ul><h2>성능 최적화</h2><ul><li>DNS prefetch</li><p><strong>↓ html</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="html">&lt;link rel="dns-prefetch" href="//...com"&gt;</div><li>TLS preconnect</li><p><strong>↓ html</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="html">&lt;link rel="preconnect" href="//...com" crossorigin&gt;</div><li>리다이렉션하지 않기</li><li>클라이언트에 캐싱하기</li><li>onload 이벤트 전에 js가 실행되야 하는 경우</li><p><strong>↓ html</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="html">&lt;script async src="...js"&gt;</div><li>DOM 로드 후에 js를 실행해도 되는 경우</li><p><strong>↓ html</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="html">&lt;script defer src="...js"&gt;</div><li>디바이스 해상도에 맞추어 이미지 다운로드</li></ul></div></div><hr><ul><li>&copy; 2020. <a href="mailto:hi.donggi@gmail.com">Donggi Kim</a> all rights reserved. <a class="w3-btn w3-round-xxlarge w3-small w3-green" href="/LICENSE">MIT License</a></li><li><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://www.w3schools.com/w3css">w3css</a> : No license</li><li><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://highlightjs.org/">highlight</a> : <a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://github.com/highlightjs/highlight.js/blob/main/LICENSE">BSD-3-Clause License</a></li><li><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://github.com/mathjax/MathJax">MathJax</a> : <a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://github.com/mathjax/MathJax/blob/master/LICENSE">Apache License 2.0</a></li><li><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://github.com/davidshimjs/qrcodejs">qrcodejs</a> : <a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://github.com/davidshimjs/qrcodejs/blob/master/LICENSE">MIT License</a></li></ul></div></body></html>