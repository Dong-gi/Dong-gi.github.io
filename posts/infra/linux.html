<!DOCTYPE html><html lang="ko-KR"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="google-site-verification" content="aH-DyzdytYQ0NPHNQFcs5dVoiu5YNs6CEEHYgqDmAFM"><meta name="author" content="Donggi Kim &lt;hi.donggi@gmail.com&gt;"><meta name="description" content="Linux 정리"><title>Linux</title><link rel="icon" href="/imgs/favicon.png"><link id="w3css" rel="stylesheet" href="/source/w3.css"><link id="highlight-style" rel="stylesheet" href="/source/xcode.css"><link id="default-style" rel="stylesheet" href="/source/default.css"><script>window.wizFuncQueue = [];</script></head><body><div class="w3-bar-block w3-sidebar w3-animate-left" id="sidebar"><hr><a class="w3-bar-item w3-button" href="javascript:closeSidebar();">Close &times;</a><hr><div id="marker-list"></div><hr><div id="post-list"></div><hr><details class="w3-small file-list" open="open"><summary>LICENSE</summary><ul><li>&copy; <a href="mailto:hi.donggi@gmail.com">Donggi Kim</a> →<a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://github.com/Dong-gi/Dong-gi.github.io/blob/master/LICENSE">MIT License</a></li><li><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://www.w3schools.com/w3css">w3css</a> → No license</li><li><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://highlightjs.org/">highlight.js</a> →<a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://github.com/highlightjs/highlight.js/blob/main/LICENSE">BSD-3-Clause License</a></li><li><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://github.com/mathjax/MathJax">MathJax</a> →<a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://github.com/mathjax/MathJax/blob/master/LICENSE">Apache License 2.0</a></li><li><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://github.com/davidshimjs/qrcodejs">qrcodejs</a> →<a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://github.com/davidshimjs/qrcodejs/blob/master/LICENSE">MIT License</a></li></ul></details><hr></div><article id="main"><div class="w3-bar w3-blue w3-large" id="nav" style="position:-webkit-sticky;position:sticky;top:0px;vertical-align:middle"><button class="w3-bar-item w3-button w3-hover-theme" onclick="toggleSidebar()">&#9776;</button><input class="w3-bar-item" id="query" type="text" placeholder="search" style="max-width:35%"><a class="w3-bar-item w3-button w3-hover-theme" href="/">Home</a></div><div class="w3-padding" id="contents"><h1>참고자료</h1><ul><li><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://tldp.org/">The Linux Documentation Project</a></li><ul><li><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://tldp.org/guides.html">LDP Guides</a></li><ol><li><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://tldp.org/LDP/abs/html/index.html">Advancd Bash-Scripting Guide; 03/2014</a></li><p>Public Domain. No copyright!</p><li><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://tldp.org/LDP/Bash-Beginners-Guide/html/index.html">Bash Guide for Beginners; 12/2008</a></li><details><summary>Copyright</summary><p><strong>↓text</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">* Copyright (c) 2002-2007, Machtelt Garrels
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the author, Machtelt Garrels, nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL THE AUTHOR AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</div></details><li><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://tldp.org/LDP/intro-linux/html/index.html">Introduction to Linux; 06/2008</a></li><details><summary>Copyright</summary><p><strong>↓text</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">* Copyright (c) 2002-2007, Machtelt Garrels
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the author, Machtelt Garrels, nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL THE AUTHOR AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</div></details></ol></ul><li><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://www.gnu.org/manual/">GNU Manual</a></li><li><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://www.kernel.org/doc/man-pages/">Linux man-pages</a></li><li><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://centoshelp.org/resources/commands/linux-system-commands/">CentOS - commands</a></li></ul><h1>Linux History</h1><ul><li>표준이 없던 초창기. 크고 비싼 컴퓨터들은 제각기의 운영체제를 갖고 있었고, 한 컴퓨터에서 작동하는 프로그램이 다른 컴퓨터에서 작동할 것이라는 보장도 할 수 없었다</li><li>Bell Labs에서 재사용 가능한 C 기반의 운영체제 UNIX를 개발했다</li><li>UNIX를 이용함으로써 각 시스템을 위한 전용 코드의 작성을 줄일 수 있게 되었다. &lt;- 이 전용 코드가 바로 커널(kernel)</li><li>Linux는 리눅스 커널(리누스 토발즈 최초 개발)을 이용하는 UNIX 구현체로, 다수의 GNU tool을 이용한다</li></ul><h1>시스템 ON/OFF</h1><div><h2>부팅 과정</h2><ol><li>BIOS 실행</li><li>POST 수행 &lt;- 장치 검사, 초기화</li><li>부트로더 실행 : 커널 로드. BIOS 종료</li><p>GRUB : GNU 프로젝트의 부트로더. 대부분 운영 체제의 커널을 불러올 수 있다</p><li>init 프로세스 실행 : /etc/inittab</li><p><strong>systemd가 사용되는 경우, inittab은 사용되지 않는다</strong></p><li>init 프로세스 중에 /etc/rc.d/rc.local 스크립트를 실행한다</li><p><strong>해당 파일은 호환을 위해 아직 남아있지만, 사용자 정의 systemd 서비스나 udev 규칙을 만드는 것이 권장된다</strong><a class="w3-btn w3-round-xxlarge w3-small w3-green goto" href="#pos1984153269" target="_self">service</a></p></ol><h2>shutdown : 시스템 종료</h2><p><strong>리눅스는 무정지 목적으로 설계됨에 유의</strong></p><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ shutdown [OPTIONS...] time [warning-message]</div><ol><li>-H : 시스템 종료</li><li>-P : 시스템 종료 + 전원 차단(하드웨어 지원 필요)</li><li>-r : 재부팅</li><li>-c : 대기중인 shutdown 취소</li><li>time : now | +<i>number</i> | yymmddhhmm</li><p>+number 단위(기본: 분)를 지정하려면 접미사 "s", "sec", "m", "min", "h", "hour" 이용</p><li>warning-message : 로그인한 유저들에게 보낼 브로드캐스팅 메시지</li></ol><h2>init : 일시적인 runlevel 변경</h2><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ init runlevel
# runlevel : 0(종료), 6(재부팅), 1(복구), 2(multiuser without NFS), 3(multiuser; TUI), 5(X11; GUI)

# 시스템 기본 runlevel 확인
$ systemctl get-default
</div></div><h1>파일 시스템</h1><p><strong>↓text</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">UNIX에서 모든 것은 파일이다. 파일이 아닌 것이 있다면, 프로세스다</div><div><h2>파일 종류</h2><ul><li>regular file(-) : 일반적인 데이터(텍스트, 바이너리)를 갖는 파일</li><li>directory(d) : 다른 파일의 목록을 갖는 파일</li><li>special file(c) : IO에 이용. 대부분 /dev 경로에 존재</li><li>link(l) : 다른 파일/디렉터리를 가리키는 파일</li><li>socket(s) : 프로세스 간 통신에 이용. TCP/IP 소켓과 유사</li><li>named pipe(p) : 프로세스 간 통신에 이용. 네트워크 소켓 semantic를 사용하지 않음</li><li>block device(b) : 하드디스크, DVD 등 블록/섹터 단위 IO 장치파일</li></ul><h2>디렉터리 구조</h2><table><tr><th>디렉터리</th><th>내용</th></tr><tr><td>/bin</td><td>시스템, 관리자, 일반 사용가 모두가 공유하는 명령어</td></tr><tr><td>/boot</td><td>시동에 필요한 파일</td></tr><tr><td>/dev</td><td>주변장치파일</td></tr><tr><td>/etc</td><td>환경설정</td></tr><tr><td>/home</td><td>유저 개인 파일</td></tr><tr><td>/lib</td><td>라이브러리, 커널 모듈</td></tr><tr><td>/mnt, /media</td><td>보조기억장치 mount point</td></tr><tr><td>/net</td><td>원격 파일 시스템 mount point</td></tr><tr><td>/opt</td><td>3rd party 프로그램</td></tr><tr><td>/proc</td><td>시스템 리소스 정보</td></tr><tr><td>/root</td><td>관리자 전용 홈 디렉터리</td></tr><tr><td>/sbin</td><td>시스템 및 관리자용 프로그램</td></tr><tr><td>/tmp</td><td>임시 파일. 재부팅 시 삭제되므로 저장용으로 사용하지 말 것</td></tr><tr><td>/usr</td><td>응용(not system)프로그램</td></tr><tr><td>/var</td><td>자주 변경하는 파일</td></tr></table><h2>I-node</h2><p>파일의 이름을 제외한 모든 정보. ID는 각 파일에 고유하게 부여된다</p></div><h1>서비스 관리<span id="pos1984153269" style="padding:0!important;margin:0!important;width:0!important;height:0!important;overflow:hidden!important"></span></h1><table><tr><th>구분</th><th>init</th><th>systemd</th></tr><tr><td>시작</td><td>/etc/init.d/${service} start</td><td>systemctl start ${service}</td></tr><tr><td>종료</td><td>/etc/init.d/${service} stop</td><td>systemctl stop ${service}</td></tr><tr><td>재시작</td><td>/etc/init.d/${service} restart</td><td>systemctl restart ${service}</td></tr><tr><td>상태</td><td>/etc/init.d/${service} status</td><td>systemctl status ${service}</td></tr><tr><td>자동 시작 O</td><td>chkconfig ${service} on</td><td>systemctl enable ${service}</td></tr><tr><td>자동 시작 X</td><td>chkconfig ${service} off</td><td>systemctl disable ${service}</td></tr><tr><td>자동 시작 상태</td><td>chkconfig --list ${service}</td><td>systemctl is-enabled ${service}</td></tr><tr><td>서비스 목록</td><td>ls /etc/init.d</td><td>systemctl --type service</td></tr></table><div><h2>init 사용자 정의 서비스</h2><ol><li>서비스 작성</li><p><strong>↓/etc/init.d/my</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="bash">#!/bin/bash
# chkconfig: 2345 20 30
# description: My Custom Service

LOG=/var/log/my.log

start() {
    echo 'Service started...' >> $LOG
}

stop() {
    echo 'Service stopped...' >> $LOG
}

case "$1" in
    start)
        start
        ;;
    stop)
        stop
        ;;
    restart)
        stop
        start
        ;;
    status)
        echo "OK"
        ;;
    *)
        echo "Usage: $0 {start|stop|restart|status}"
esac

exit 0
</div><p><strong>chkconfig: 2345 20 30</strong> -> runlevel이 {2, 3, 4, 5} 중 하나면 실행. 시작 우선순위 20, 종료 우선순위 30</p><li>실행 권한 부여</li><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ chmod +x /etc/init.d/my</div><li>자동 실행 설정</li><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ chkconfig my on</div></ol><h2>systemd 사용자 정의 서비스</h2><ol><li>서비스 작성</li><p><strong>↓/etc/systemd/system/myd.service</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="bash">[Unit]
Description=My Daemon

[Service]
Type=simple
ExecStart=/root/my.sh
Restart=on-failure

[Install]
WantedBy=multi-user.target
</div><li>최초 서비스 실행</li><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ systemctl start myd</div><li>자동 실행 설정</li><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ systemctl enable myd</div></ol></div><h1>셸</h1><ol><li>유저의 기본 셸은 /etc/passwd에 설정된다</li><li>echo $SHELL : 사용중인 셸 확인</li><li>종류</li><ul><li>Login shell</li><p>최초 실행 시 유저명과 비밀번호를 묻고 진입하는 셸</p><li>Non login shell</li><p>기존 셸에서 인증없이 새로 시작한 셸</p></ul></ol><h1>Bash</h1><div><h2>Special character</h2><table class="no-sort"><tr><td>#</td><td>주석 시작</td></tr><tr><td>;</td><td>커맨드 구분자</td></tr><tr><td>;;</td><td>case 옵션 종결자</td></tr><tr><td>;;&amp;, ;&amp;</td><td>case 옵션 종결자 Since bash 4<a class="w3-btn w3-round-xxlarge w3-small w3-green goto" href="#pos3046192" target="_self">case</a></td></tr><tr><td>.</td><td><ul><li>커맨드로 사용 : source 커맨드와 동일</li><li>파일명 접두에 위치 : ls에는 보여지지 않음</li><li>정규표현식 : 임의 글자에 매칭</li></ul></td></tr><tr><td>""</td><td>partial quoting<a class="w3-btn w3-round-xxlarge w3-small w3-green goto" href="#pos664382521" target="_self">quoting</a></td></tr><tr><td>''</td><td>full quoting<a class="w3-btn w3-round-xxlarge w3-small w3-green goto" href="#pos664382521" target="_self">quoting</a></td></tr><tr><td>,</td><td><ul><li>연산자 : 산술 연산이 순서대로 처리되고, 마지막 결과를 반환</li><li>대소문자 변환 in<a class="w3-btn w3-round-xxlarge w3-small w3-green goto" href="#pos2034571796" target="_self">parameter substitution</a> Since bash 4</li></ul></td></tr><tr><td>\</td><td>이스케이프. 바로 뒤의 문자를 리터럴로 취급</td></tr><tr><td>/</td><td>파일 경로 구분자</td></tr><tr><td>``</td><td><a class="w3-btn w3-round-xxlarge w3-small w3-green goto" href="#pos464872882" target="_self">command substitution</a></td></tr><tr><td>:</td><td>아무것도 하지않는 null command</td></tr><tr><td>*</td><td>GLOB 패턴 매칭에서, 해당 디렉터리 내 임의 파일명에 매칭</td></tr><tr><td>?</td><td>GLOB 패턴 매칭에서, 임의 1글자에 매칭</td></tr><tr><td>(command1; command2; ...)</td><td>Command group. 새 서브셸에서 커맨드를 실행한다; 따라서 외부에서 참조 불가</td></tr><tr><td>{x,y,z,...}, {a..z}</td><td><a class="w3-btn w3-round-xxlarge w3-small w3-green goto" href="#pos-1667999982" target="_self">brace expansion</a></td></tr><tr><td>{}</td><td>코드 블록 정의. 컨텍스트는 유지되므로 외부에서도 변수 참조 가능. 코드 블록에 대해 IO 리디렉션 가능<p><strong>↓bash</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="bash">{
    echo 'hello'
    echo 'world'
} >> test.log</div></td></tr><tr><td>[ EXPRESSION ], [[ EXPRESSION ]]</td><td><a class="w3-btn w3-round-xxlarge w3-small w3-green goto" href="#pos3556498" target="_self">test</a></td></tr><tr><td>$[ EXPRESSION ]</td><td>Deprecated. 정수 연산</td></tr><tr><td>(( EXPRESSION ))</td><td>정수 연산</td></tr><tr><td>리다이렉션</td><td><ul><li>></li><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ script.sh > test.log
# STDOUT을 test.log로. 파일이 없다면 생성하고, 있다면 덮어쓴다

$ script.sh >&2
# STDOUT을 STDERR(2)로

$ script.sh > test.log 2>&1
# STDOUT을 test.log로 && STDERR(2)를 STDOUT(1)으로</div><li>&amp;></li><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ not_exist.sh &> /dev/null # STDOUT, STDERR 모두 /dev/null로(==버림)
$ echo $?                   # non-zero</div><li>>></li><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ script.sh >> test.log
# STDOUT을 test.log로. 파일이 없다면 생성하고, 있다면 append</div><li>&lt; : 파일을 STDIN으로</li><li>&lt;></li><p><strong>↓bash</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="bash">LOG_FILE=test.log
echo '1234567890' > $LOG_FILE

exec 777&lt;> $LOG_FILE # open file and assign FD 777

read -n 4 &lt;&777
echo -n "." >&777    # write without new line

exec 777>&-   # close output FD 777
cat $LOG_FILE # 1234.67890</div></ul></td></tr><tr><td>&lt;&lt;</td><td><strong>here document</strong><ul><li>limit string 사이의 문자열을 COMMAND의 STDIN으로 리다이렉션</li><p><strong>↓bash</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="bash">COMMAND &lt;&lt;EOF
command1
command2
...
EOF
# EOF 외 다른 문자열도 limit string으로 사용 가능
# 동일한 텍스트를 갖는 파일(input)을 `COMMAND &lt; input`으로 실행하는 것과 유사하다</div><li>here document 내부에서 parameter substitution을 수행한다</li><p><strong>↓bash</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="bash">x=3
cat &lt;&lt;END
Hello~
x=$x
END    # x=3</div><li>limit string을 따옴표로 감싸면 parameter substitution을 수행하지 않는다</li><p><strong>↓bash</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="bash">x=3
cat &lt;&lt;END
Hello~
x=$x
END    # x=$x</div><li>동일 스크립트 내의 함수 입력으로 사용할 수 있다</li><p><strong>↓bash</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="bash">set_variables ()
{
    read a
    read b
    read c
}
print_variables ()
{
    echo "a=$a, b=$b, c=$c"
}

set_variables &lt;&lt;DATA1
123
456
789
DATA1

print_variables    # a=123, b=456, c=789

set_variables &lt;&lt;DATA2
321
654
987
DATA2

print_variables    # a=321, b=654, c=987</div></ul></td></tr><tr><td>&lt;&lt;&lt;</td><td><strong>here string</strong><p><strong>↓bash</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="bash"># here document의 축약 버전
COMMAND &lt;&lt;&lt; text

x=123
bash &lt;&lt;&lt; "echo Hello World. x=$x"

# COMMAND &lt;&lt;&lt; $WORD 와 다를 바 없다
text="echo Hello World. x=$x"
bash &lt;&lt;&lt; $text</div></td></tr><tr><td>|</td><td>파이프라인. 이전 커맨드의 STDOUT을 다음 커맨드 또는 셸의 STDIN으로 연결</td></tr><tr><td>&amp;&amp;</td><td>COMMAND1 &amp;&amp; COMMAND2 : COMMAND1이 성공할 때만 COMMAND2 실행</td></tr><tr><td>-</td><td><p>file 대신 STDIN으로부터 읽도록 또는 STDOUT으로 쓰도록 리다이렉션</p><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell"># STDIN을 STDOUT으로 echo
$ cat -</div><p><strong>↓bash</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="bash"># /source/directory 를 /dest/directory 로 복사
(cd /source/directory &amp;&amp; tar cf - . ) | (cd /dest/directory &amp;&amp; tar xpvf -)</div></td></tr><tr><td>제어 문자</td><td><ul><li>Ctrl + A : 커서를 커맨드 라인 맨 앞으로</li><li>Ctrl + C : 포그라운드 작업 종료</li><li>Ctrl + D : Shell 로그아웃 or EOF or STDIN 입력 종료</li><li>Ctrl + L : clear</li><li>Ctrl + U : 커맨드 라인의 커서 앞부분 제거. 설정에 따라, 전체 라인을 지우는 경우도 있다</li><li>Ctrl + V : 직후 입력된 제어 문자 1개를 텍스트로 입력</li><li>Ctrl + W : 커서 앞 단어 제거</li><li>Ctrl + Y : Ctrl + U, Ctrl + W로 제거한 텍스트 붙여넣기</li><li>Ctrl + Z : 포그라운드 작업 일시정지</li></ul></td></tr></table><h2>자동 실행 스크립트</h2><ul><li>Login shell : /etc/profile, ~/.bash_profile or ~/.bash_login or ~/.profile, ~/.bash_logout</li><p>/etc/profile은 /etc/bash.bashrc, /etc/profile.d/*.sh 들도 실행한다</p><li>Non login shell : ~/.bashrc</li><p>~/.bashrc 파일은 보통 ~/.bash_profile, ~/.profile 등에서도 실행한다</p></ul><h2>스크립트 디버깅</h2><ul><li>전체 스크립트 : bash -x filename</li><li>일부분 : 스크립트 내에서 플래그 조정</li><p><strong>↓bash</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="bash"># ...
set -x # start debugging
w
set +x # stop debugging</div><li>현재 셸에서 직접 플래그 조정</li><ul><li>set -f : disable file name generation using metacaracters</li><li>set -v : print shell input lines</li><li>set -x : print command traces before executing command</li></ul></ul><h2>변수, 매개변수</h2><div><p>bash의 변수는 엄밀한 타입이 없다 - 모두 문자열. 숫자로만 구성된 경우, 일부 컨텍스트에서 산술 연산을 수행한다</p><h3>Variable substitution</h3><p>변수 이름을 이용해 값을 참조하는 것. $를 이름 앞에 붙임으로써 이루어진다</p><div><h4>Indirect referencing Since bash 2</h4><p><strong>↓bash</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="bash">x=other
other="Hello World"

echo "Direct x=$x"
echo "Indirect x=${!x}"
</div></div><h3>변수 할당</h3><ul><strong>공백에 주의해야 한다</strong><li>name=123  # OK. "name" 변수에 123 할당</li><li>name =123 # NG. "name" 커맨드를 "=123"를 인자로 실행</li><li>name= 123 # NG. 환경 변수 name=""으로 "123" 커맨드 실행</li></ul><h3>환경 변수</h3><ul><li>프로세스의 실행에 영향을 줄 수 있는 변수들</li><li>각 프로세스는 하나의 '환경' - 환경 변수 집합을 가지며, 자식 프로세스는 최초 실행 시 이를 상속받는다</li><li>env 또는 printenv 명령으로 목록 확인 가능</li></ul><h3>지역 변수</h3><ul><li>현재 셸 | 코드 블록 | 함수 내에서만 접근 가능</li><li>목록 확인</li><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ (set -o posix; set | sort) > set.sorted
$ (printenv | sort) > printenv.sorted
$ diff set.sorted printenv.sorted | grep "&lt;" | awk '{ print $2 }'</div><li>변수 선언</li><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ varName="value"
$ let varName="value"</div><li>환경 변수로 전달</li><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell"># child process에서 사용할 수 있게 된다
$ export varName
$ export varName="value"
$ export PATH="$PATH:/usr/java/jdk-13.0.2/bin
</div></ul><h3>예약 변수</h3><table class="no-sort"><tr><th>name</th><th>definition</th></tr><tr><td>BASH</td><td>bash의 절대경로</td></tr><tr><td>BASH_ENV</td><td>로그인 셸에서, 파일로 설정된 경우, 셸 스크립트를 실행하기 전에 먼저 읽는다</td></tr><tr><td>BASHPID</td><td>현재 bash PID</td></tr><tr><td>BASH_SUBSHELL</td><td>subshell level Since bash 3</td></tr><tr><td>BASH_VERSION</td><td>bash 버전</td></tr><tr><td>BASH_VERSINFO</td><td>bash 버전 정보에 대한 읽기 전용 수열</td></tr><tr><td>COLUMNS</td><td>터미널 출력 너비</td></tr><tr><td>COMP_CWORD</td><td>$COMP_WORDS에서 현재 커서가 위치하는 단어의 index</td></tr><tr><td>COMP_LINE</td><td>현재 커맨드 라인</td></tr><tr><td>COMP_POINT</td><td>현재 커맨드에서 커서 상대 위치</td></tr><tr><td>COMP_WORDS</td><td>현재 커맨드를 배열로</td></tr><tr><td>COMPREPLY</td><td>제시할 자동완성 단어 배열<a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://devmanual.gentoo.org/tasks-reference/completion/index.html">예시</a></td></tr><tr><td>EUID</td><td>명령을 실행 중인 현재 유저의 ID</td></tr><tr><td>FUNCNAME</td><td>현재 실행 중인 셸 함수 이름</td></tr><tr><td>GLOBIGNORE</td><td>glob 매칭에서 제외할 패턴 목록</td></tr><tr><td>GROUPS</td><td>현재 유저가 속한 그룹으로 구성된 배열</td></tr><tr><td>HISTFILE</td><td>커맨드 이력. 기본값 ~/.bash_history</td></tr><tr><td>HISTFILESIZE</td><td>저장할 최대 이력 수</td></tr><tr><td>HOME</td><td><ul><li>현재 유저의 home directory</li><li>'~'로도 획득 가능</li><li>홈디렉터리는 /etc/skel의 파일을 /home/${USER_NAME}에 복사하여 만들어진다</li></ul></td></tr><tr><td>HOSTFILE</td><td>/etc/hosts와 동일한 포맷의 파일을 지정하면, 호스트 구성에 사용</td></tr><tr><td>HOSTNAME</td><td>현재 호스트</td></tr><tr><td>HOSTTYPE</td><td>머신 종류; e.g. x86_64</td></tr><tr><td>IFS</td><td><a class="w3-btn w3-round-xxlarge w3-small w3-green goto" href="#pos1693926290" target="_self">Word splitting</a></td></tr><tr><td>LANG</td><td>LC_* 변수에서 지정하지 않은 경우, 이 로캐일이 사용된다</td></tr><tr><td>LC_ALL</td><td>LANG 및 다른 모든 LC_* 변수에 우선한다</td></tr><tr><td>LC_COLLATE</td><td>파일명, 패턴 비교에 사용하는 로캐일</td></tr><tr><td>LC_CTYPE</td><td>파일명, 패턴 등의 문자 로캐일</td></tr><tr><td>LC_MESSAGES</td><td>&quot;$&quot; 해석에 사용할 로캐일</td></tr><tr><td>LC_NUMERIC</td><td>숫자 표현에 사용할 로캐일</td></tr><tr><td>LINENO</td><td>현재 라인 번호</td></tr><tr><td>MACHTYPE</td><td>CPU-COMPANY-SYSTEM</td></tr><tr><td>MAIL</td><td>MAILPATH가 설정되지 않은 경우, MAIL이 가리키는 파일에 신규 메일이 있으면 bash가 알려준다</td></tr><tr><td>MAILCHECK</td><td>메일 확인 주기(초)</td></tr><tr><td>MAILPATH</td><td>:으로 구별된 MAIL 파일들. 신규 메일이 있으면 bash가 알려준다</td></tr><tr><td>OLDPWD</td><td>이전 PWD</td></tr><tr><td>OPTARG</td><td>getopts가 마지막으로 처리한 옵션 인자의 값</td></tr><tr><td>OPTIND</td><td>getopts가 마지막으로 처리한 옵션 인자의 인덱스</td></tr><tr><td>OSTYPE</td><td>e.g. linux-gnu</td></tr><tr><td>PATH</td><td>:으로 구별된 디렉터리들. 커맨드가 존재하는지 shell이 찾아본다</td></tr><tr><td>PIPESTATUS</td><td>가장 최근 포그라운드에서 종료된 프로세스들의 종료 코드 배열</td></tr><tr><td>PPID</td><td>현재 셸의 PPID</td></tr><tr><td>PROMPT_COMMAND</td><td>매 PS1 출력 전에 실행할 명령</td></tr><tr><td>PS1</td><td>Prompt string 1; Primary; default &quot;\s-\v\$ &quot;</td></tr><tr><td>PS2</td><td>Prompt string 2; Secondary; &quot;&gt; &quot;</td></tr><tr><td>PS3</td><td>select 커맨드에 사용되는 prompt. default &quot;#?&quot;</td></tr><tr><td>PS4</td><td>-x 옵션으로 커맨드 라인 실행 전에 echo 출력할 때 사용할 prefix; default &quot;+ &quot;</td></tr><tr><td>PWD</td><td>Print Working Directory</td></tr><tr><td>RANDOM</td><td>0 ~ 32767 사이 임의 정수; 할당하는 경우 seed로 전달된다</td></tr><tr><td>REPLY</td><td>read로 읽어온 문자열</td></tr><tr><td>SECONDS</td><td>셸 시작 후 ?초</td></tr><tr><td>SHELLOPTS</td><td>:으로 구별된, 활성 셸 옵션들</td></tr><tr><td>SHLVL</td><td>부모 bash 인스턴스 수 + 1</td></tr><tr><td>TMOUT</td><td>read 제한 시간(초)</td></tr><tr><td>UID</td><td>실제 현재 유저 ID</td></tr></table><h3>특별 변수</h3><table class="no-sort"><tr><th>character</th><th>definition</th></tr><tr><td>$1~$9, ${10}~</td><td>n번째 실행 인자 반환</td></tr><tr><td>$#</td><td>실행 인자 개수 반환</td></tr><tr><td>$*</td><td>전체 실행 인자. 전체 인자를 ' '로 조인한 문자열로 취급</td></tr><tr><td>$@</td><td>전체 실행 인자. 인자 각각을 한 문자열로 취급<p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ bash test.sh "hello world" hello world

Listing args with "$*":
Arg #1 = hello world hello world

Listing args with "$@":
Arg #1 = hello world
Arg #2 = hello
Arg #3 = world</div></td></tr><tr><td>$?</td><td>마지막 포그라운드 프로세스/함수/스크립트 종료 상태</td></tr><tr><td>$$</td><td>셸 PID</td></tr><tr><td>$!</td><td>가장 최근 백그라운드 PID</td></tr><tr><td>$0</td><td>셸 or 스크립트 이름</td></tr></table><h3>declare로 변수 선언<span id="pos1542341994" style="padding:0!important;margin:0!important;width:0!important;height:0!important;overflow:hidden!important"></span></h3><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ declare OPTION(S) VAR_NAME=value</div><ul><li>-a : 배열</li><li>-f : 이름에 해당하는 함수 정의 출력</li><li>-i : 정수</li><li>-p : 이름에 해당하는 변수 정의 출력</li><li>-r : 읽기 전용 변수로 고정</li><li>-x : export</li><li>옵션에 - 대신 +를 쓰면 해당 옵션을 끈다</li></ul><h3>Array</h3><ul><li>배열 길이 제한 없음</li><li>임의 인덱스 할당 가능</li><li>배열 선언 + 초기화</li><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ arr=(value1 value2 valueN)</div><li>암시적 배열 변수 선언</li><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ arr[3]=value</div><li>배열 참조</li><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ echo ${arr[*]}
$ echo ${arr[2]}
</div></ul><h3>변수에 대한 연산<span id="pos2034571796" style="padding:0!important;margin:0!important;width:0!important;height:0!important;overflow:hidden!important"></span></h3><ul><li>${VAR_NAME^} : 첫번째 글자를 대문자로. Since bash 4</li><li>${VAR_NAME^^} : 전부 대문자로. Since bash 4</li><li>${VAR_NAME,} : 첫번째 글자를 소문자로. Since bash 4</li><li>${VAR_NAME,,} : 전부 소문자로. Since bash 4</li><li>${#VAR_NAME} | ${#*}, ${#@} | ${#arr[*]}, ${#arr[@]} : 변수 값의 길이 | 인자 개수 | 배열 길이</li><li>${VAR_NAME-WORD} : 변수가 없으면 WORD 반환</li><li>${VAR_NAME:-WORD} : 변수가 없거나 null이면 WORD 반환</li><li>${VAR_NAME=WORD} : 변수가 없으면 WORD 할당 후 반환</li><li>${VAR_NAME:=WORD} : 변수가 없거나 null이면 WORD 할당 후 반환</li><li>${VAR_NAME?WORD} : 변수가 없으면 실행 위치와 WORD 출력 후 exit code 1로 종료</li><li>${VAR_NAME:?WORD} : 변수가 없거나 null이면 실행 위치와 WORD 출력 후 exit code 1로 종료</li><li>${VAR_NAME+WORD} : 변수가 존재하면 WORD 반환. 아니면 null</li><li>${VAR_NAME:+WORD} : 변수가 존재하고 non-null이면 WORD 반환. 아니면 null</li><li>${VAR_NAME:OFFSET:LENGTH} : OFFSET(0 based index)부터 LENGTH(생략 시 끝까지)개 문자 출력</li><li>${VAR_NAME#WORD} : 접두 WORD패턴(shortest) 삭제</li><li>${VAR_NAME##WORD} : 접두 WORD패턴(longest) 삭제</li><li>${VAR_NAME%WORD} : 접미 WORD패턴(shortest) 삭제</li><li>${VAR_NAME%%WORD} : 접미 WORD패턴(longest) 삭제</li><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ arr=(aaab aabb abbb bbbb)
$ echo ${arr[*]#a*}
aab abb bbb bbbb
$ echo ${arr[*]##a*}
bbbb
$ echo ${arr[*]%*b}
aaa aab abb bbb
$ echo ${arr[*]%%*b}</div><li>${VAR_NAME/PATTERN/REPLACEMENT} : 최초 1회 치환</li><li>${VAR_NAME/#PATTERN/REPLACEMENT} : 접두와 일치하는 경우 치환</li><li>${VAR_NAME/%PATTERN/REPLACEMENT} : 접미와 일치하는 경우 치환</li><li>${VAR_NAME//PATTERN/REPLACEMENT} : 전체 치환</li><li>${!prefix*}, ${!prefix@} : 접두가 일치하는 모든 변수 이름 배열 반환</li></ul></div><h2>Quoting<span id="pos664382521" style="padding:0!important;margin:0!important;width:0!important;height:0!important;overflow:hidden!important"></span></h2><ul><li>\ : 다음 글자를 리터럴로 간주</li><li>'' : 내부 문자열을 리터럴로 간주</li><li>"" : 내부 문자열을 리터럴로 간주; 단 $, `, \ 제외. 여러줄에 걸쳐 작성 가능</li></ul><h2>Expansion</h2><ol><li>각 커맨드 토큰들은 순서대로 해석되며, 모든 해석이 끝난 뒤 quote가 제거된다</li><li>Brace expansion<span id="pos-1667999982" style="padding:0!important;margin:0!important;width:0!important;height:0!important;overflow:hidden!important"></span></li><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ echo ab{c,d,e}fg      # abcfg abdfg abefg
$ mv name.{txt,txt.old}
$ for n in {1..20}; do echo $n; done
$ for n in log-{100..20}.txt; do echo $n; done
$ for n in {z..A}; do echo $n; done</div><li>Tilde expansion</li><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ echo ~          # 현재 유저의 home directory
$ echo ~USER_NAME # 특정 유저의 home directory
$ echo ~+         # PWD
$ echo ~-         # OLDPWD</div><li>Parameter(and variable) expansion</li><ul><li>${VAR_NAME}, $VAR_NAME</li><p>{}는 옵션이다. ${INSTALL_DIR}_old/ 처럼 뒤에 곧바로 다른 문자가 오는 경우 구분을 위해 사용</p><li>${VAR_NAME:=value}</li><p>변수가 존재하지 않으면 초기화하고 반환</p><li>$0~$9, ${10}~</li><p>n번째 실행 인자 획득. 2글자 넘어가면 {} 필수</p></ul><li>Command substitution : $(command), `command`<span id="pos464872882" style="padding:0!important;margin:0!important;width:0!important;height:0!important;overflow:hidden!important"></span></li><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell"># command 실행 결과(STDOUT)로 치환
$ echo $(echo $(echo abcd))</div><li>Arithmetic expansion : $(( EXPRESSION )), $[ EXPRESSION ]</li><ul><li>EXPRESSION은 "로 감싸인 걸로 간주된다. " 자체는 특별한 의미를 갖지 않는다</li><li>EXPRESSION 내부 토큰들도 parameter expansion, command substitution, quote removal을 거친다</li><li>EXPRESSION은 중첩될 수 있다</li><li>EXPRESSION 연산은 고정폭 정수로 행해지며, overflow 검사는 하지 않는다</li><li>0으로 시작하는 상수는 8진수, 0x는 16진수로 간주된다</li><li>2#10 ~ 64#12abAB@_ 표기로 2~64진법 표현 가능. 36진법 이하에서 대소문자는 구별되지 않는다</li></ul><table class="no-sort"><caption>Operators</caption><tr><td>VAR++, VAR--</td><td>단항 연산(후위)</td></tr><tr><td>++VAR, --VAR</td><td>단항 연산(전위)</td></tr><tr><td>-, +</td><td>단항 연산</td></tr><tr><td>!, ~</td><td>논리/비트 NOT</td></tr><tr><td>**</td><td>거듭제곱</td></tr><tr><td>*, /, %</td><td>곱, 몫, 나머지</td></tr><tr><td>+, -</td><td>이항 연산</td></tr><tr><td>&lt;&lt;, &gt;&gt;</td><td>비트 이동</td></tr><tr><td>&lt;=, &gt;=, &lt;, &gt;</td><td>비교 연산</td></tr><tr><td>==, !=</td><td>동등 비교</td></tr><tr><td>&amp;</td><td>비트 AND</td></tr><tr><td>^</td><td>비트 XOR</td></tr><tr><td>|</td><td>비트 OR</td></tr><tr><td>&amp;&amp;</td><td>논리 AND</td></tr><tr><td>||</td><td>논리 OR</td></tr><tr><td>expr ? expr : expr</td><td>삼항 연산</td></tr><tr><td>=, *=, /=, %=, +=, -=, &lt;&lt;=, &gt;&gt;=, &amp;=, ^=, |=</td><td>대입 연산</td></tr><tr><td>,</td><td>표현식 구별. 가장 마지막 표현식 결과가 리턴된다</td></tr></table><li>Process substitution<span id="pos969020718" style="padding:0!important;margin:0!important;width:0!important;height:0!important;overflow:hidden!important"></span></li><ul><li>x &lt;(COMMAND_LIST) y : COMMAND_LIST대로 프로세스를 실행하고, 그 결과를 갖는 임시 파일(/dev/fd/N)과 y를 순서대로 x의 인자로 전달</li><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ cat &lt;(ls -a) &lt;(ls -al)</div><li>x &gt;(COMMAND_LIST) y : x /dev/fd/N y를 실행하고, /dev/fd/N는 다시 COMMAND_LIST 프로세스의 인자로 전달</li><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ tar -cf >(cat) test.sh tmp.txt
# test.sh0000774000000000000000000000002614004476247011101 0ustar  rootroot
# Content of 'test.sh'
# tmp.txt0000664000000000000000000000002614004476253011122 0ustar  rootroot
# Content of 'tmp.txt'</div></ul><li>Word splitting<span id="pos1693926290" style="padding:0!important;margin:0!important;width:0!important;height:0!important;overflow:hidden!important"></span></li><ul><li>Parameter expansion, command substitution, arithmetic expansion의 결과에 대해 단어를 분할한다</li><li>단어의 분할은 IFS(Internal Field Separator) 변수에 설정(기본값 ' \t\n')된 문자들을 구분자로 하여 진행된다</li><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ echo $IFS

$ IFS=123
$ str=a1b2c3d4e5
$ echo $str
a b c d4e5
$ echo "$str"
a1b2c3d4e5
$ echo $IFS

$ echo "$IFS"
123
$ IFS=' \t\n'
$ echo $str
a1b2c3d4e5</div></ul><li>File name expansion</li><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ echo t* # 배열로 반환
test.sh tmp.txt</div><p><strong>↓test.sh</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ echo $1
$ echo $#</div><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ cat &lt;("${PWD}/"t*)
/workspace/donggi-github/tmp.txt
1
$ cat &lt;("${PWD}/"t*.sh)

0
</div></ol><h2>Aliases</h2><ul><li>목록 확인 : alias</li><li>설정 : alias text='COMMAND_LIST'</li><li>해제 : unalias text</li><li>alias는 자식 프로세스에 상속되지 않는다</li></ul><h2>POSIX 정규표현식</h2><table class="no-sort"><tr><td>^</td><td>line 시작</td></tr><tr><td>$</td><td>line 끝</td></tr><tr><td>\b</td><td>word 경계</td></tr><tr><td>\B</td><td>not \b. 즉 2글자 이상의 word 내부</td></tr><tr><td>\&lt;</td><td>word 시작</td></tr><tr><td>\&gt;</td><td>word 끝</td></tr><tr><td>[:CLASS:]</td><td><ul><li>보통 [[:CLASS:]]처럼 2겹으로 감싸야 된다</li><li>alnum, alpha, ascii, blank, cntrl, digit, graph, lower, print, punct, space, upper, word, xdigit</li></ul></td></tr></table><h2>Test<span id="pos3556498" style="padding:0!important;margin:0!important;width:0!important;height:0!important;overflow:hidden!important"></span></h2><div><h3>if - General</h3><ul><li>가장 단순한 구문</li><p><strong>↓bash</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="bash">if TEST-COMMANDS; then COMMANDS; fi
# TEST-COMMANDS가 성공적으로 종료(exit code==0)하면 then 실행

if true; then echo hello; fi
if false; then echo hello; fi</div><li>조건식</li><table><tr><th>식</th><th>TRUE</th></tr><tr><td>[ -a FILE ]</td><td>deprecated. FILE 존재</td></tr><tr><td>[ -b FILE ]</td><td>FILE 존재 &amp;&amp; block device</td></tr><tr><td>[ -c FILE ]</td><td>FILE 존재 &amp;&amp; character device</td></tr><tr><td>[ -d FILE ]</td><td>FILE 존재 &amp;&amp; directory</td></tr><tr><td>[ -e FILE ]</td><td>FILE 존재</td></tr><tr><td>[ -f FILE ]</td><td>FILE 존재 &amp;&amp; regular file</td></tr><tr><td>[ -g FILE ]</td><td>FILE 존재 &amp;&amp; SGID bit set; 해당 디렉터리에 생성된 파일은 자동으로 디렉터리 소유 그룹의 것이 된다</td></tr><tr><td>[ -h FILE ]</td><td>FILE 존재 &amp;&amp; symbolic link</td></tr><tr><td>[ -k FILE ]</td><td>FILE 존재 &amp;&amp; sticky bit set; 파일에 설정된 경우, 빠른 접근을 위해 캐시 메모리에 저장된다. 디렉터리에 설정된 경우, 해당 디렉터리에 쓰기 권한을 가진 유저(디렉터리 소유자, root 제외)는 자기가 소유한 파일에 대해서만 변경 가능하다</td></tr><tr><td>[ -p FILE ]</td><td>FILE 존재 &amp;&amp; pipe</td></tr><tr><td>[ -r FILE ]</td><td>FILE 존재 &amp;&amp; redable</td></tr><tr><td>[ -s FILE ]</td><td>FILE 존재 &amp;&amp; size &gt; 0</td></tr><tr><td>[ -t FD ]</td><td>FD가 터미널에 연결됨<p><strong>↓bash</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="bash">if [ -t 0 ]; then echo hello; fi # STDIN
if [ -t 1 ]; then echo hello; fi # STDOUT
if [ -t 2 ]; then echo hello; fi # STDERR</div></td></tr><tr><td>[ -u FILE ]</td><td>FILE 존재 &amp;&amp; SUID bit set; 바이너리를 누가 실행하든 지정 유저 권한으로 실행된다</td></tr><tr><td>[ -w FILE ]</td><td>FILE 존재 &amp;&amp; writable</td></tr><tr><td>[ -x FILE ]</td><td>FILE 존재 &amp;&amp; executable</td></tr><tr><td>[ -O FILE ]</td><td>FILE 존재 &amp;&amp; 현재(effective) 유저가 소유</td></tr><tr><td>[ -G FILE ]</td><td>FILE 존재 &amp;&amp; 현재(effective) 그룹이 소유</td></tr><tr><td>[ -L FILE ]</td><td>FILE 존재 &amp;&amp; symbolic link</td></tr><tr><td>[ -N FILE ]</td><td>FILE 존재 &amp;&amp; 마지막으로 읽은 시점 이후에 수정됨</td></tr><tr><td>[ -S FILE ]</td><td>FILE 존재 &amp;&amp; socket</td></tr><tr><td>[ FILE1 -nt FILE2 ]</td><td>Newer than ::= FILE1이 FILE2보다 최근에 수정됨 || FILE1은 있지만 FILE2는 없음</td></tr><tr><td>[ FILE1 -ot FILE2 ]</td><td>Older than ::= FILE1이 FILE2보다 이전에 수정됨 || FILE2는 있지만 FILE1은 없음</td></tr><tr><td>[ &quot;$a&quot; -eq &quot;$b&quot; ]</td><td>산술 비교; equal to</td></tr><tr><td>[ &quot;$a&quot; -ne &quot;$b&quot; ]</td><td>산술 비교; not equal to</td></tr><tr><td>[ &quot;$a&quot; -gt &quot;$b&quot; ]</td><td>산술 비교; greater than</td></tr><tr><td>[ &quot;$a&quot; -ge &quot;$b&quot; ]</td><td>산술 비교; greater than or equal to</td></tr><tr><td>[ &quot;$a&quot; -lt &quot;$b&quot; ]</td><td>산술 비교; less than</td></tr><tr><td>[ &quot;$a&quot; -le &quot;$b&quot; ]</td><td>산술 비교; less than or equal to</td></tr><tr><td>(( &quot;$a&quot; &gt; &quot;$b&quot; ))</td><td>산술 비교; greater than</td></tr><tr><td>(( &quot;$a&quot; &gt;= &quot;$b&quot; ))</td><td>산술 비교; greater than or equal to</td></tr><tr><td>(( &quot;$a&quot; &lt; &quot;$b&quot; ))</td><td>산술 비교; less than</td></tr><tr><td>(( &quot;$a&quot; &lt;= &quot;$b&quot; ))</td><td>산술 비교; less than or equal to</td></tr><tr><td>[ &quot;$a&quot; == &quot;$b&quot; ]</td><td>문자열; equal to</td></tr><tr><td>[ &quot;$a&quot; != &quot;$b&quot; ]</td><td>문자열; not equal to</td></tr><tr><td>[ &quot;$a&quot; \&lt; &quot;$b&quot; ], [[ &quot;$a&quot; &lt; &quot;$b&quot; ]]</td><td>현재 로캐일상 문자열 a가 앞섬</td></tr><tr><td>[ &quot;$a&quot; \&gt; &quot;$b&quot; ], [[ &quot;$a&quot; &gt; &quot;$b&quot; ]]</td><td>현재 로캐일상 문자열 b가 앞섬</td></tr><tr><td>[ -z &quot;$a&quot; ]</td><td>문자열 길이 == 0</td></tr><tr><td>[ -n &quot;$a&quot; ] or [ &quot;$a&quot; ]</td><td>문자열 길이 &gt; 0</td></tr><tr><td>[ -o OPTIONNAME ]</td><td>셸 옵션이 켜 있음</td></tr><tr><td>[ ! EXPRESSION ]</td><td>not EXPRESSION</td></tr><tr><td>[ (EXPRESSION) ]</td><td>연산 우선순위 조정 가능</td></tr><tr><td>[ EXPRESSION1 -a EXPRESSION2 ], [[ EXPRESSION1 &amp;&amp; EXPRESSION2 ]]</td><td>and; &amp;&amp;는 short-circuit</td></tr><tr><td>[ EXPRESSION1 -o EXPRESSION2 ], [[ EXPRESSION1 || EXPRESSION2 ]]</td><td>or; ||는 short-circuit</td></tr></table></ul><h3>if - Advanced</h3><ul><li>[] vs [[]]</li><ul><li>[[]] Since bash 2.02</li><li>[]는 "test" 커맨드와 동일하지만, [[]]는 커맨드가 아닌 키워드</li><li>[[]]는 변수 값에 대한 word splitting을 수행하지 않는다</li><li>[[]]는 file name expansion을 수행하지 않는다</li><li>[[]]는 glob 패턴 매칭 수행</li><p><strong>↓bash</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="bash">if [[ "hello" == h* ]]; then echo hello; fi</div></ul><li>(()), let</li><p>산술연산을 수행하고, 그 결과가 0이 아니면 0 종료</p><p><strong>↓bash</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="bash">(( 0 &amp;&amp; 1 ))
echo $?                # 1
let "x = (( 0 &amp;&amp; 1))"
echo $x                # 0
echo $?                # 1</div><li>else</li><p><strong>↓bash</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="bash">if ...; then ... else ... fi</div><li>elif</li><p><strong>↓bash</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="bash">if ...; then ... elif ...; then ... fi</div><li>if 구문 중첩 가능</li></ul><h3>case<span id="pos3046192" style="padding:0!important;margin:0!important;width:0!important;height:0!important;overflow:hidden!important"></span></h3><ul><li>;; -> case 옵션 종결 &amp;&amp; case 구문 종료</li><li>;;&amp; -> case 옵션 종결 &amp;&amp; 다음 패턴 검사 실행. Since bash 4</li><li>;&amp; -> case 옵션 종결 &amp;&amp; 다음 옵션 무조건 실행. Since bash 4</li></ul><p><strong>↓bash</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="bash">case "$1" in
    start) # POSIX range, class 사용 가능
        start
        ;;
    restart)
        stop
        sleep 5
        start
        ;;
    *)
        echo "Usage $0 {start|restart}"
        exit 1
esac

case $num in
    10 | 20 ) echo $num' is 10 or 20';;
    *) echo $num' is not 10 nor 20';;
esac
</div></div><h2>Repetitive tasks</h2><div><h3>for</h3><p><strong>↓bash</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="bash">for NAME; do COMMANDS; done         # 실행 인자 순회
for NAME in LIST; do COMMANDS; done # LIST 순회

# e.g.
for n in 10 20 30; do echo $n; done
for n in {1..20}; do echo $n; done
for n in log-{100..20}.txt; do echo $n; done
for n in {z..A}; do echo $n; done
for f in *; do cp "$f" "$f.bak"; done</div><h3>select</h3><p><strong>↓bash</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="bash">select NAME; do COMMANDS; done         # 실행 인자 중 선택
select NAME in LIST; do COMMANDS; done # LIST 중 선택</div><ol><li>stderr에 목록 출력 -> PS3 출력 -> stdin으로부터 한 줄 입력</li><li>입력이 숫자로 구성되었고, 해당하는 항목이 존재하는 경우 : NAME에 항목 설정, REPLY에 입력 라인 설정</li><li>입력이 비어있는 경우, goto 1</li><li>입력이 EOF인 경우 반복 종료</li><li>그 외의 경우 NAME은 null string, REPLY에 입력 라인 설정</li></ol><h3>while</h3><p><strong>↓bash</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="bash">while CONTROL-COMMAND; do COMMANDS; done</div><h3>until</h3><p><strong>↓bash</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="bash">until TEST-COMMAND; do COMMANDS; done</div><h3>break</h3><p>즉시 반복 중단</p><h3>continue</h3><p>즉시 다음 순회로</p><h3>shift</h3><p><strong>↓bash</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="bash">shift   # $1 인자 버려짐
shift 3 # $1, $2 인자 버려짐

while (( "$#" ));
do
    echo $1
    shift
done
</div></div><h2>Function</h2><p><strong>↓bash</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="bash"># 선언 1
function FUNCNAME { COMMANDS; }
# 선언 2
FUNCNAME () { COMMANDS; }
# 호출 1
FUNCNAME
# 호출 2
FUNCNAME param1 param2 # &lt;- 함수 안에서 $1, $2, ...로 접근
# 호출 3
test () {
    return 33
}

test
echo $?
val=$?

exit $val
</div><h2>Catching signal</h2><div><h3>Signal</h3><table class="no-sort"><tr><td>SIGHUP</td><td>1</td><td>Hangup</td></tr><tr><td>SIGINT</td><td>2</td><td>Interrupt frmo keyboard; Ctrl+C</td></tr><tr><td>SIGKILL</td><td>9</td><td>Kill; 강제 종료</td></tr><tr><td>SIGTERM</td><td>15</td><td>Termination; 정상 종료</td></tr><tr><td>SIGSTOP</td><td>17, 19, 23</td><td>Stop</td></tr></table><p>SIGKILL, SIGSTOP은 잡거나, 지연시키거나, 무시할 수 없다</p><h3>Trap</h3><p><strong>↓bash</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="bash">trap COMMANDS SIGNALS
# e.g.
trap "{ echo \"Good Bye!\"; exit 255; }" EXIT
exit 0</div><ul><li>SIGNALS 중의 신호를 감지하면 COMMANDS가 실행된다</li><li>SIGNALS ::= 신호 이름(SIG 접두 생략 가능) 또는 정수</li></ul></div></div><h1>Commands</h1><div><h2>기타</h2><div><h3>:</h3><p>아무것도 하지 않는 null 명령</p><h3>history</h3><p>명령 실행 내역</p><p><strong>↓기록 지우기</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ history -c; &gt; $HISTFILE</div><h3>read</h3><p>표준입력으로부터 변수 할당; 변수명 지정하지 않은 경우 REPLY 예약 변수로 접근 가능</p><h3>let</h3><p>변수에 대한 산술 연산 수행</p><h3>eval</h3><p>인자를 모아 실행한다. 각 인자는 실행하기 전에 평가된다</p><p><strong>↓bash</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="bash">a='$b'
b='$c'
c=d

echo $a             # $b
eval echo $a        # $c
eval eval echo $a   # d
</div><h3>set</h3><ul><li>set value1 value2 ... : positional parameter 초기화</li><li>set -abCefhmnuvx, set +abCefhmnuvx : 셸 속성 변경</li></ul><h3>unset : 변수 제거</h3><h3>export</h3><p>자식 프로세스의 환경 변수로 전달</p><h3>declare, typeset</h3><a class="w3-btn w3-round-xxlarge w3-small w3-green goto" href="#pos1542341994" target="_self">declare</a><h3>readonly</h3><p>변수를 변경할 수 없게 설정한다</p><h3>source, .</h3><ul><li>커맨드 라인에서 호출시 해당 스크립트 실행</li><li>스크립트 내에서 호출시 해당 파일 텍스트를 삽입</li></ul><h3>exit : 스크립트/셸 종료</h3><h3>exec</h3><ol><li>fork : 새 프로세스는 기존 프로세스(parent)가 PID만 다른 복제본을 생성함으로써 만들어진다</li><li>exec : 지정 커맨드 정보로 현재 프로세스 주소 공간을 덮어쓴다</li></ol><h3>caller</h3><p>함수 내에서 사용하면 호출자 정보를 표준 출력</p><h3>true : 0으로 즉시 종료</h3><h3>false : 1로 즉시 종료</h3><h3>type</h3><p>변수, 커맨드 등에 대한 식별 정보를 표준 출력</p><h3>help</h3><p>builtin에 대한 설명 확인</p><h3>uname : 시스템 정보</h3><h3>yes</h3><p>끊임없이 y(지정 가능)를 표준 출력</p><h3>tee</h3><p>파이프라인을 끊지 않으면서 파일로도 저장</p></div><h2>메모리 관련</h2><div><h3>vmstat : Virtual memory statistics</h3><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ vmstat 1 # 1초마다 출력</div><h3>free : 메모리 사용 현황</h3><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ free -m -w -h -s 1
    # -m : 메가바이트 단위
    # -w : wide output
    # -h : human-readable output
    # -s 1 : 1초마다
</div></div><h2>프로세스 관련</h2><div><h3>ps : Process Snapshot</h3><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ ps -ef # -e(전체 프로세스), -f(full-format)</div><h3>top : 실행 중인 작업 보기</h3><h3>Job</h3><ul><li>백그라운드 프로세스는 별개 job 번호를 할당받는다</li><li>커맨드 또는 루프 뒤에 &amp;를 붙이면 백그라운드 job으로 실행한다</li><li>Job 식별자</li><table><tr><td>Notation</td><td>Meaning</td></tr><tr><td>%N</td><td>Job number [N]</td></tr><tr><td>%S</td><td>Invocation (command-line) of job begins with string S</td></tr><tr><td>%?S</td><td>Invocation (command-line) of job contains within it string S</td></tr><tr><td>%%</td><td>&quot;current&quot; job (last job stopped in foreground or started in background)</td></tr><tr><td>%+</td><td>&quot;current&quot; job (last job stopped in foreground or started in background)</td></tr><tr><td>%-</td><td>Last job</td></tr><tr><td>$!</td><td>Last background process</td></tr></table></ul><h3>jobs</h3><p>백그라운드 job 리스트</p><h3>disown</h3><ol><li>job을 셸의 job table에서 제거</li><li>-h : job table에서 제거하지는 않지만, 셸이 종료해도 SIGHUP 신호를 보내지 않음으로써 job 계속 실행</li></ol><h3>nohup</h3><p>SIGHUP 신호를 무시하고 계속 실행</p><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ nohup name.sh &amp;>/dev/null &amp;</div><h3>bg ↔ fg %n</h3><p>백그라운드 job으로 계속 실행 ↔ 포그라운드로 전환</p><h3>nice : 백그라운드 job 우선순위 변경</h3><p>19(lowest), -20(highest); 음수 우선순위는 root만 설정할 수 있다</p><h3>wait, wait PID, wait %n</h3><p>전체 백그라운드 job/특정 프로세스/특정 백그라운드 job 종료 대기</p><h3>suspend, Ctrl + Z</h3><p>현재 프로세스를 백그라운드로 전환하고 일시정지</p><h3>logout : 로그인 셸 종료</h3><h3>kill : 프로세스 종료</h3><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ kill -9 pid # 15(일반 종료), 2(종료; 무시 가능), 9(강제종료; 무시 불가), 1(구성 파일 다시 읽기; 데몬 프로세스)
$ kill %n     # 백그라운드 잡 종료
</div><h3>crond : 작업 예약</h3><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ systemctl status crond # 상태 확인
$ crontab -l             # 작업 목록 출력
    # -e : edit
    # -u : 사용자 지정</div><ul><li>유저가 아닌 시스템 단위의 작업은 /etc/crontab 직접 수정</li><li>crontab path 설정</li><p><strong>↓text</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">PATH=/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin</div></ul><h3>screen : 백그라운드에서 실행되는 가상 터미널</h3><p>ssh 연결이 끊어지더라도 세션에 다시 연결할 수 있다</p><ul><li>screen 세션 시작</li><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ screen</div><li>세션이 끊어진 경우, 다시 로그인하고 사용 가능한 스크린 목록 확인</li><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ screen -ls</div><li>이전 명령에서 확인한 pid로 스크린에 연결</li><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ screen -r 17793</div><li>screen 세션 종료</li><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ exit</div></ul></div><h2>파일 관련</h2><div><h3>cd</h3><p>Working directory 변경</p><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ cd            # 자신의 HOME_DIR로
$ cd DIR        # 지정 디렉터리로
$ cd ~USER_NAME # 유저 HOME_DIR로
</div><h3>pwd</h3><p>Print Working Directory</p><h3>pushd, popd, dirs</h3><p>Working directory 스태킹</p><h3>du : 디렉터리 크기 출력(재귀)</h3><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ du | sort -nr | head</div><h3>df : 파일시스템 사용률</h3><h3>stat : 파일 속성</h3><h3>ls : 파일 목록</h3><p>-a(.로 시작하는 경로 포함), -c(with -lt: 시간순, with -l: 이름순), -X(확장자순), -S(크기순), -r(역정렬), -l(자세히), 등...</p><p><strong>↓출력 예</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">d rwx r-x r-x # 디렉터리, 소유자 권한, 그룹 권한, 기타 사용자 권한 755(read, write, execute)
- rw- r-- r-- # 파일, (상동) 644
l r-- r-- r-- # 링크, (상동) 444
</div><h3>cat, tac</h3><ul><li>cat : 파일을 순서대로 위-gt;아래 라인 순으로 표준 출력</li><p>-n(줄 번호), -E(줄 끝에 $), -s(반복적인 빈 라인 생략), -T(탭을 ^T로 표기)</p><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ cat file1 file2 file3 &gt; file123</div><li>tac : 파일을 순서대로 아래-&gt;위 라인 순으로 표준 출력</li></ul><h3>rev</h3><p>파일 위-&gt;아래 라인을 순서대로 뒤집어 표준 출력</p><h3>cp : 파일 복사</h3><p>-a(파일 속성 유지), -b(목적지에 이미 있으면 백업하고 복사), -r(재귀 실행), -s(심볼릭 링크 생성), ...</p><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ cp [options] source dest_path
$ cp [options] [sources] [target_directory]
</div><h3>mv : cp + 원본 삭제</h3><h3>rm : 파일 삭제</h3><p>-f(파일이 없으면 무시), -i(각 파일 삭제 확인), -r(재귀 실행), 등...</p><p><strong>↓my_dir 디렉터리 및 내부 파일 모두 삭제</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ rm -rf ./my_dir</div><h3>rmdir : 빈 디렉터리 삭제</h3><h3>mkdir : 디렉터리 생성</h3><p>-m(권한, 기본 755), -p(경로상의 모든 디렉터리 생성)</p><h3>파일 권한 변경</h3><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ chmod [options] 8진수 [paths]
# 예. 모든 .sh 파일 실행 권한 부여
$ chmod +x *.sh
# 예. bin/ 디렉터리 하위 전체에 실행 권한 부여
$ chmod -R +x ./bin/

# 예. tmp/ 디렉터리 하위 전체 소유자 변경
$ chown -R readonly ./tmp/

# 예. tmp/ 디렉터리 하위 전체 소유 그룹 변경
$ chgrp -R readonly ./tmp/
</div><h3>chattr : 파일 속성 변경</h3><p><strong>↓bash</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="bash">chattr +i name.txt # 켜진 경우, 파일 변경 불가. root에서만 속성 on/off 가능
chattr +s name.txt # 켜진 경우, 파일을 지우면 블록을 0으로 쓴다
chattr +c name.txt # 켜진 경우, 자동 압축
</div><h3>ln : 링크 생성</h3><p><strong>↓bash</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="bash">ln old_file hard_link # hard link
    # mirror copy. old_file 이름을 변경해도 참조 지속
    # inode 동일
    # 다른 파일시스템의 파일 참조 불가
    # 디렉터리 참조 불가
ln -s old_file soft_link # soft link
    # file name 참조. old_file 이름을 변경하면 참조 불가
    # inode 다름
    # 다른 파일시스템, 디렉터리 참조 가능
</div><h3>find : 파일 찾기</h3><ul><li>파일명 패턴으로 GLOB 가능</li><li>표현식 앞에 !이나 -not을 붙일 수 있다</li><li>표현식들 사이를 -and, -or로 엮을 수 있다</li></ul><p><strong>↓bash</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="bash"># home directory 이하(재귀)의 모든 *.txt 파일 찾기
find ~/ -name '*.txt'

# home directory 이하(재귀)의 모든 *.txt 파일 출력
find ~/ -name '*.txt' -exec cat {} \;

# 24시간 내에 수정된 모든 파일 찾기
find ./ -mtime -1
# ctime : last attribute change time
# atime : last access time

# 24시간 전에 수정된 모든 파일 찾기
find ./ ! -mtime -1

# 5분 내에 수정된 모든 파일 찾기
find ./ -mmin -5
# cmin, amin

# full path가 정규식에 일치하는 모든 파일 찾기
find ./ -regex '.*/.*\.pug'
</div><h3>touch</h3><p>파일 access, modification 시각을 현재로 변경. 파일이 없으면 생성한다(크기 0).</p><h3>man, info : 커맨드, 유틸리티 도움말</h3><h3>sum, cksum, md5sum, sha1sum : 체크섬 계산</h3><h3>tar : 압축</h3><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ tar [options] file       # 압축해제
$ tar [options] file paths # 압축</div><ul><li>Main Operation : -A(append), -r(append), -c(create), -d(파일 시스템과의 차분 출력), -t(목록 출력), -u(update), -x(압축해제)</li><li>포맷 : --bzip2, --xz, --lzip, --lzma, --gzip</li><li>-h(링크 자체 대신, 링크가 가리키는 파일을 압축한다)</li></ul></div><h2>시간 관련</h2><div><h3>date : 시각 출력/변경</h3><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ date                # 현재 시각 출력
$ date "+%Y-%m-%d %T" # 포맷 지정

$ date -s time_string # 시각 변경
$ date -s "2019-01-01 12:34:56"
</div><h3><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://nxmnpg.lemoda.net/8/ntpdate">ntpdate</a> : 시각 동기화</h3><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ ntpdate server    # 동기화
$ ntpdate -d server # 오차 출력</div><p>NTP : Network Time Protocol. 시간 동기화를 위한 프로토콜<a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://zetawiki.com/wiki/공용_NTP_서버_목록">공용_NTP_서버_목록</a></p><h3>cal : 달력 출력</h3><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ cal [[month] year]</div><h3>sleep : do nothing</h3><h3>usleep : 마이크로초 단위 sleep</h3></div><h2>텍스트 관련</h2><div><h3>echo</h3><ul><li>표현식 또는 변수를 newline 문자를 덧붙여 표준 출력</li><li>항상 0 종료</li><li>-e : 이스케이프 해석</li><li>-n : newline 문자를 끝에 붙이지 않음</li></ul><h3>printf</h3><p>포맷대로 표준 출력. 처리에 따라 종료 상태 다를 수 있음</p><h3>xargs -n $num : 줄당 최대 $num개 열로 출력</h3><h3>fold -w $num : 줄당 최대 $num 글자로 출력</h3><p>-s 옵션 사용 시, 가능하면 단어 중간에 라인을 바꾸지 않게 조정한다</p><h3>sort : 오름차순 정렬</h3><p>-r : 내림차순 정렬</p><h3>uniq : 중복 제거</h3><p>-c : 카운트</p><h3>wc : 단어 개수</h3><p>-w(단어 개수만), -l(줄 개수만), -c(바이트 크기만), -m(문자 개수만), -L(가장 긴 라인의 길이만)</p><h3>expand : tab -&gt; space</h3><h3>unexpand : space -&gt; tab</h3><h3>head : 파일 위 n(default 10)줄 출력</h3><h3>tail : 파일 아래 n(default 10)줄 출력</h3><p>-f : 변경 추적</p><h3>tr : 텍스트 치환</h3><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell"># 치환
echo "a1b2c3d4e5" | tr '[:alpha:]' +
# ==&gt; +1+2+3+4+5
echo "a1b2c3d4e5" | tr 'b-d' '7-9'
# ==&gt; a1728394e5

# 반전
echo "a1b2c3d4e5" | tr -c '[:alpha:]' +
# ==&gt; a+b+c+d+e++
# 줄바꿈 문자도 변경됨에 주목

# 삭제
echo "abcdef" | tr -d 'b-d'
# ==&gt; aef

# 축약
echo "abbbbcccd" | tr --squeeze-repeats 'a-b'
# ==&gt; abcccd
</div><h3>nl : 줄 번호 매기기(빈 줄 제외)</h3><h3>diff : 두 텍스트 파일 비교</h3><h3>diff3 : 세 텍스트 파일 비교</h3><h3>grep : 텍스트 검색</h3><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ grep [options] pattern [files]</div><p>-E(ERE), -G(BRE), -P(Perl Regexp), -e(정규표현식), -i(ignore case), -w(패턴에 단어 전체가 매칭되는 경우만), -x(패턴에 줄 전체가 매칭되는 경우만), -m(최대 출력 개수), -n(줄 번호 같이 출력), -o(매칭된 부분만 출력), -l(매칭된 파일들의 이름만 출력), -L(매칭되지 않는 파일들의 이름만 출력), -A(매칭 후 n개 라인도 출력), -B(매칭 전 n개 라인도 출력) 등...</p><h3>sed; Stream EDitor</h3><div><p>sed는 표준 입력 또는 파일로부터 편집을 수행(원본 수정은 없다)하고 표준 출력한다</p><table class="no-sort"><caption>Commands</caption><tr><td>a\text</td><td>각 줄 아래에 text를 쓴다</td></tr><tr><td>c\text</td><td>각 줄을 text로 치환</td></tr><tr><td>/pattern/d</td><td>패턴이 포함된 줄 지우기</td></tr><tr><td>3d</td><td>3번째 줄 지우기</td></tr><tr><td>2,4d</td><td>2~4번째 줄 지우기</td></tr><tr><td>2,$d</td><td>2~마지막 줄 지우기</td></tr><tr><td>i\text</td><td>각 줄 위에 text를 쓴다</td></tr><tr><td>/pattern/p</td><td>pattern이 매칭되는 줄만 출력</td></tr><tr><td>s/pattern/replacement/</td><td>찾아 바꾸기; 줄당 최초 1회</td></tr><tr><td>2,4s/pattern/replacement/</td><td>찾아 바꾸기; 2~4줄에서 각 줄당 최초 1회</td></tr><tr><td>2,/pattern1/s/pattern2/replacement/</td><td>찾아 바꾸기; 2줄부터 pattern1이 존재하는 줄까지, 각 줄당 최초 1회</td></tr><tr><td>/pattern1/,/pattern2/s/pattern3/replacement/</td><td>찾아 바꾸기; pattern1이 존재하는 줄부터 pattern2가 존재하는 줄까지, 각 줄당 최초 1회</td></tr><tr><td>s/pattern/replacement/gi</td><td>찾아 바꾸기; 대소문자 구별없이(i), 해당 줄의 모든 매칭(g)에 대해 변환 수행</td></tr><tr><td>y/letters1/letters2/</td><td>tr과 유사. 글자 치환 수행</td></tr><tr><td>3q</td><td>3줄까지만 처리하고 종료</td></tr></table><table class="no-sort"><caption>Options</caption><tr><td>-e script</td><td>script 커맨드들도 실행한다</td></tr><tr><td>-f script-file</td><td>script-file의 커맨드들도 실행한다</td></tr><tr><td>-n</td><td>매칭 라인만 출력</td></tr></table></div><h3>awk</h3><div><h4>개요</h4><p>스트림 편집 프로그램; 및 프로그래밍 언어</p><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ awk { PROGRAM } inputFile(s)        # 각 파일 모든 라인들에 대해 PROGRAM 실행
$ awk '/REGEX/(gmi) { PROGRAM } inputFile(s) # 각 파일 REGEX 일치 라인들에 대해 PROGRAM 실행
$ awk -f programFile inputFile(s)
</div><h4>print</h4><ul><li>default input field separator ::= [ \t]+</li><li>$1, $2, ... ::= 라인의 i번째 필드</li><li>$0 ::= 라인 전체</li><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ ls -al | awk '{ print $9 }'</div><li>formatting</li><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ ls -al | awk '{ print $9 " with formatting -> [" $9 "]" }'</div><li>전처리/후처리</li><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ ls -al | awk 'BEGIN { print "Hello\n" } { print $9 } END { print "Bye\n" }'</div></ul><h4>variable</h4><ul><li>FS : field separator</li><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ ls -al | awk 'BEGIN { FS="t+" } { print $1 }'</div><li>OFS : output field separator</li><li>ORS : output record separator</li><li>NR : number of record</li><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ ls -alh | awk 'BEGIN { OFS=" = "; ORS="\n>>> line " } { print NR "\n" $9,$5 "B" }'</div><li>User defined variable</li><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ ls -al | awk 'BEGIN { totalSize=0 } { totalSize=totalSize + $5 } END { print "Total size = " totalSize "bytes" }'</div></ul></div></div><h2>네트워크 관련</h2><div><h3>curl : 유저 상호작용 없이 다양한 프로토콜 통신</h3><h3>wget : 유저 상호작용 없이 웹, ftp 파일 다운로드</h3><h3>ssh : Secure shell</h3><h3>ifconfig : 네트워크 인터페이스 정보</h3><h3>netstat : 네트워크 사용 정보</h3><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ netstat -anp | grep 10080</div></div><h2>산술</h2><div><h3>factor : 소인수분해</h3><h3>awk를 이용한 부동소수 연산</h3><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ echo 1234567 | awk '{ printf("%3.7f\n", sqrt($1)) }'</div></div><h2>사용자 관련</h2><div><h3>w, who, users : 로그인한 유저 목록</h3><h3>groups : 현재 유저가 속한 그룹 목록</h3><h3>useradd : 사용자 추가</h3><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ useradd [options] USER_NAME</div><p>-d(HOME_DIR), -g(group id or name), -p(password), -D(기본값 출력/설정), 등...</p><h3>passwd : 비밀번호 설정</h3><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ passwd [options] USER_NAME</div><p>-d(삭제), -l(잠금), -u(잠금 해제), -e(강제 만료)</p><h3>usermod : 사용자 수정</h3><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ usermod [options] USER_NAME</div><p>-d(HOME_DIR), -m(HOME_DIR 변경 시 파일 이동), -L(잠금), -p(password), 등...</p><h3>userdel : 사용자 삭제</h3><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ userdel [options] USER_NAME</div><h3>groupadd : 사용자 그룹 추가</h3><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ groupadd [options] GROUP_NAME</div><p>-g(수동 GID), -p(password)</p><h3>groupdel : 사용자 그룹 삭제</h3><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ groupdel [options] GROUP_NAME</div><h3>su : 다른 사용자 권한으로 실행</h3><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ su [options] [-] [USER_NAME [arg]...]</div><p>USER_NAME이 없으면 root. 단순히 '-'만 있으면 '-l'과 동일하다</p><h3>sudo : 다른 사용자 권한으로 실행</h3><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ sudo -u USER_NAME COMMAND</div><p>유저 지정하지 않으면 superuser로 실행</p><p>cf. sudo 없이 docker 실행할 수 있도록 docker 유저 그룹에 ec2-user 추가</p><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ sudo usermod -a -G docker ec2-user</div><h3>사용자 목록 : /etc/passwd</h3><p><strong>↓text</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">ID:Password(x):UID:GID:Comment:HOME_DIR:SHELL
root:x:0:0:root:/root:/bin/bash
dgkim:x:1000:1000:dgkim:/home/dgkim:/bin/bash
</div><h3>비밀번호 목록 : /etc/shadow</h3><p>!!는 비밀번호가 설정되지 않았음을 의미</p></div><h2>패키지 관련</h2><div><h3>RPM : Redhat Package Manager</h3><p>{package_name}-{version}-{release}.{architecture}.rpm</p><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ rpm [options]</div><p>-a(전체 패키지 검증), -i(install), -U(설치 또는 upgrade), -F(기존 패키지 upgrade), -v(verbose), -h(진행과정을 #로), -e(erase), -qa(설치된 패키지 목록), -qi(패키지 상세 정보) 등...</p><h3>yum</h3><ul><li>인터넷 저장소로부터 패키지를 다운로드하여 설치. 의존 패키지까지 자동 설치한다</li><li>Commands : clean(캐시 삭제), check-update, downgrade, erase, info, install, list, reinstall, search, update, version, 등...</li></ul><h3>EPEL(Extra Packages for Enterprise Linux) 허용</h3><ol><li>서드 파티 패키지를 설치하려면 EPEL을 허용해야 한다</li><li>RHEL 6.x / CentOS 6.x</li><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-6.noarch.rpm</div><li>RHEL 7.x / CentOS 7.x</li><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm</div><p>또는</p><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ yum install epel-release.noarch</div></ol></div></div><h1>FTP Server : vsftpd</h1><ol><li>설치</li><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ yum install vsftpd</div><li>설정 : /etc/vsftpd/vsftpd.conf</li><p><strong>↓properties</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="properties">anonymous_enable=NO # 익명 차단
listen_ipv6=NO # IPv4 사용
</div><li>방화벽 허용</li><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ firewall-cmd --permanent --add-service=ftp
$ firewall-cmd --permanent --add-port=21/tcp
$ firewall-cmd --reload
# ↓ 잘 됐는지 확인
$ firewall-cmd --zone=public --list-all
</div><li>SELinux 관련 정책 확인</li><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ getsebool -a | grep ftp
$ setsebool ftp_home_dir on # 필요한 권한은 허용
</div><li>시스템 시작</li><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ systemctl enable vsftpd
$ systemctl restart vsftpd</div></ol><ul><li>root 로그인 허용</li><p>/etc/vsftpd/ftpusers, /etc/vsftpd/user_list에서 root 제거</p><li>사용자 홈 디렉터리 외부 접근 허용</li><p>/etc/vsftpd/chroot_list : chroot_list_enable=YES</p><li>Active Mode 사용 : 20포트</li><p>/etc/vsftpd/vsftpd.conf : pasv_enable=NO</p><li>Passive Mode 사용</li><ol><li>/etc/vsftpd/vsftpd.conf</li><p><strong>↓properties</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="properties">connect_from_port_20=NO
pasv_enable=YES
pasv_min_port=50000
pasv_max_port=50010</div><li>방화벽에서 [pasv_min_port,pasv_max_port]/tcp 허용</li></ol></ul><h1>SELinux</h1><ol><li>SELinux 모드 : enforce, permissive, disable</li><p>setenforce 1 # enforce로 임시 변경<br>setenforce 0 # permissive로 임시 변경<br>getenforce # 모드 확인</p><li>부팅시 사용되는 기본 모드는 /etc/selinux/config에 정의돼있다</li><li>SELinux 로그 위치 : /var/log/audit/audit.log</li><li>SELinux 로그 분석 유티릴티 : setroubleshoot</li><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ yum install setroubleshoot
$ sealert -a /var/log/audit/audit.log
</div></ol><h1>/etc/hosts</h1><p><strong>address hostname[[ alias1]...]</strong></p><p><strong>↓text</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">127.0.0.1   localhost localhost4
::1         localhost localhost6
</div><h1>vi</h1><div><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://vim.rtorr.com/lang/ko/">Vim Cheat Sheet »</a><h2>모드</h2><ol><li>처음 vi를 실행하면 normal mode(command mode)</li><p>insert mode와 visual mode에서 esc를 누르면 normal mode로 회귀</p><li>i를 누르면 insert mode</li><li>v를 누르면 visual mode</li><li>:를 누르고 명령어 실행</li><ul><li>:set nu # 줄 번호 표시</li><li>:syn on, :syn enable # 키워드 및 문맥 강조</li></ul></ol><h2>저장</h2><ol><li>:w</li><li>:w! 덮어쓰기</li><li>:w 파일명 // 새 파일인 경우</li><li>:saveas 파일명</li></ol><h2>종료</h2><ol><li>:q</li><li>:wq : 저장 후 종료</li><li>:q! : 저장하지 않고 종료</li></ol><h2>vim</h2><ol><li>열기</li><ul><li>:edit 파일명</li><li>:tabnew 파일명</li><li>$ vim 파일명1 파일명2 ...</li><p>:n으로 열린 파일 선택. 파일을 탭으로 열고 싶다면 -p 옵션</p></ul><li>복사/붙여넣기</li><ul><li>복사 : Ctrl + Insert</li><li>붙여넣기 : Shift + Insert</li><p>~/.vimrc 에서<br>set mouse=a 로 되어있던게 문제였습니다. set mouse=c 로 변경하니까 vim 에서 텍스트의 복사하기 붙여넣기 잘 되는군요<br>a 는 마우스를 사용하겠다는 것이고 c 는 마우스를 사용치 않겠다는 것 같은데, c 로 해놔도 마우스로 커서 옮기고 스크롤하는 것 등은 잘 되더군요.. 출처 : https://kldp.org/node/129456</p></ul></ol><h2>지우기</h2><ol><li>n dd : 커서로부터 n 줄 삭제</li><li>n dw : 커서로부터 n 단어 삭제</li><li>gg -> dG : 첫줄로 이동 -> 끝까지 삭제</li></ol></div><h1>사용 사례</h1><div><h2>파티션 확장</h2><ul><li>lsblk 명령으로 디스크가 놀고 있는 것을 확인했고, 파티션이 LVM에 사용되고 있지 않다면 growpart 명령으로 파티션을 확장할 수 있다</li><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">[ec2-user ~]$ sudo growpart /dev/nvme0n1 1
# growpart DEVICE_NAME PARTITION_NO</div><li>확장된 파티션에 맞춰 파일 시스템도 확장해야 한다<a class="w3-btn w3-round-xxlarge w3-small w3-green goto" href="#pos-333606740" target="_self">파일 시스템 확장</a></li></ul><h2>Oracle Linux에서 LVM 파티션 확장</h2><p>200GB 블록 볼륨의 150GB가 놀고 있는 상황에서 LVM 파티션을 확장하는 절차</p><ol><li>상태 확인</li><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">[opc@xxx]$ sudo fdisk -l
Disk /dev/sda: 200 GiB, 214748364800 bytes, 419430400 sectors

Device        Start       End   Sectors   Size Type
/dev/sda1      2048    206847    204800   100M EFI System
/dev/sda2    206848   2303999   2097152     1G Linux filesystem
/dev/sda3   2304000  97675263  95371264  45.5G Linux LVM
</div><li>파티션 추가</li><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">[opc@xxx]$ sudo fdisk /dev/sda
Command (m for help): n
# 기본값을 계속 선택하면, 비어있는 모든 섹터를 차지하는 파티션을 정의한다
Command (m for help): w
</div><li>논리적 볼륨 그룹 확인</li><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">[opc@xxx]$ sudo vgdisplay
  --- Volume group ---
  VG Name               ocivolume
</div><li>논리적 볼륨 그룹에 파티션 추가 할당</li><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">[opc@xxx]$ sudo vgextend ocivolume /dev/sda4
  Physical volume "/dev/sda4" successfully created.
  Volume group "ocivolume" successfully extended
</div><li>논리적 볼륨 확인</li><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">[opc@xxx]$ df -hT
Filesystem                 Type      Size  Used Avail Use% Mounted on
/dev/mapper/ocivolume-root xfs        36G   15G   21G  42% /
/dev/mapper/ocivolume-oled xfs        10G  189M  9.9G   2% /var/oled
</div><li>논리적 볼륨 확장</li><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">[opc@xxx]$ sudo lvextend /dev/mapper/ocivolume-root -l +100%FREE
Size of logical volume ocivolume/root changed from 35.47 GiB (9081 extents) to 188.89 GiB (48357 extents).
Logical volume ocivolume/root successfully resized.
</div><span id="pos-333606740" style="padding:0!important;margin:0!important;width:0!important;height:0!important;overflow:hidden!important"></span><li>파일 시스템 확장</li><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">[opc@xxx]$ sudo xfs_growfs /dev/mapper/ocivolume-root
data blocks changed from 9298944 to 49517568
# ext 파일시스템에서는 sudo resize2fs /dev/mapper/ocivolume-root
</div><li>적용 확인</li><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">[opc@xxx]$ df -hT
Filesystem                 Type      Size  Used Avail Use% Mounted on
/dev/mapper/ocivolume-root xfs       189G   16G  174G   9% /
/dev/mapper/ocivolume-oled xfs        10G  189M  9.9G   2% /var/oled

[opc@xxx]$ lsblk
NAME               MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT
sda                  8:0    0   200G  0 disk
|-sda1               8:1    0   100M  0 part /boot/efi
|-sda2               8:2    0     1G  0 part /boot
|-sda3               8:3    0  45.5G  0 part
| |-ocivolume-root 252:0    0 188.9G  0 lvm  /
| `-ocivolume-oled 252:1    0    10G  0 lvm  /var/oled
`-sda4               8:4    0 153.4G  0 part
  `-ocivolume-root 252:0    0 188.9G  0 lvm  /
</div></ol><h2>Amazon EBS 볼륨을 Linux에서 사용</h2><p>루트 디바이스용 EBS 볼륨이 있는 EC2 인스턴스에 새로운 EBS 볼륨을 연결한 경우,</p><ol><li>상태 확인</li><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">[ec2-user ~]$ lsblk
NAME    MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
xvda    202:0    0    8G  0 disk
-xvda1  202:1    0    8G  0 part /
xvdf    202:80   0   10G  0 disk</div><p>/dev/xvdf 디스크에는 파티션이 존재하지 않음을 알 수 있다</p><li>파일 시스템이 있는지 확인</li><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">[ec2-user ~]$ sudo file -s /dev/xvdf
/dev/xvdf: data</div><p>data만 표시된다면, 파일 시스템이 없다는 의미</p><li>파일 시스템(XFS) 생성</li><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">[ec2-user ~]$ sudo yum install xfsprogs     # XFS 도구가 없다면 설치
[ec2-user ~]$ sudo mkfs -t xfs /dev/xvdf
</div><li>볼륨 탑재</li><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">[ec2-user ~]$ sudo mount /dev/xvdf /data</div><p>/data는 적당한 탑재 지점(디렉터리)</p><li>재부팅 시 볼륨 자동 탑재</li><ol><li>디스크 UUID 확인</li><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">[ec2-user ~]$ sudo blkid
# 또는
[ec2-user ~]$ sudo lsblk -o +UUID</div><li>/etc/fstab 추가</li><p><strong>↓/etc/fstab</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">UUID=aebf131c-6957-451e-8d34-ec978d9581ae  /data  xfs  defaults,nofail  0  2</div><li>/etc/fstab 파일이 정상적으로 설정됐는지 확인</li><p><strong>↓shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">[ec2-user ~]$ sudo umount /data
[ec2-user ~]$ sudo mount -a</div></ol></ol></div></div></article><hr><script id="google-analytics" src="https://www.googletagmanager.com/gtag/js?id=UA-143098403-1" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-143098403-1');</script><script id="highlight-js" src="/source/highlight.pack.js" defer></script><script id="default-js" src="/source/default.min.js" defer></script></body></html>