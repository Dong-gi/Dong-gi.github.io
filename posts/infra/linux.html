<html lang="ko"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="google-site-verification" content="aH-DyzdytYQ0NPHNQFcs5dVoiu5YNs6CEEHYgqDmAFM"><meta name="author" content="Donggi Kim &lt;hi.donggi@gmail.com&gt;"><meta name="keywords" content="Linux, AmazonLinux, CentOS"><meta name="description" content="Linux 정리"><title>Linux</title><link id="w3css" rel="stylesheet" href="/source/w3.css"><link id="highlight-style" rel="stylesheet" href="/source/xcode.css"><link id="default-style" rel="stylesheet" href="/source/default.css"><script id="highlight-js" src="/source/highlight.pack.js"></script><script id="default-js" src="/source/default.min.js"></script><script id="dsq-count-scr" src="//donggi.disqus.com/count.js" async></script><script id="kakao-ads" src="//t1.daumcdn.net/kas/static/ba.min.js" async></script><script id="google-ads" data-ad-client="ca-pub-7897366614471210" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><script id="google-analytics" src="https://www.googletagmanager.com/gtag/js?id=UA-143098403-1" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-143098403-1');</script></head><body><div class="w3-bar-block w3-sidebar w3-animate-left" id="sidebar"><hr><a class="w3-bar-item w3-button" href="javascript:closeSidebar();">Close &times;</a><hr><div id="marker-list"></div><hr><div id="post-list"></div><hr><div class="w3-center"><ins class="kakao_ad_area" style="display:none;" data-ad-unit="DAN-1k1r635zxb6g3" data-ad-width="300" data-ad-height="250"></ins></div><hr><div id="file-list"></div><hr></div><div id="main"><div class="w3-bar w3-blue w3-large" id="nav" style="position:-webkit-sticky;position:sticky;top:0px;vertical-align:middle"><button class="w3-bar-item w3-button w3-hover-theme" onclick="toggleSidebar()">&#9776;</button><input class="w3-bar-item" id="query" type="text" placeholder="search" style="max-width:35%"><a class="w3-bar-item w3-button w3-hover-theme" href="/">Home</a></div><div class="w3-padding" id="contents"><h1>참고자료</h1><ul><li><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://tldp.org/">The Linux Documentation Project</a></li><ul><li><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://tldp.org/guides.html">LDP Guides</a></li><ol><li><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://tldp.org/LDP/abs/html/index.html">Advancd Bash-Scripting Guide; 03/2014</a></li><p>Public Domain. No copyright!</p><li><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://tldp.org/LDP/Bash-Beginners-Guide/html/index.html">Bash Guide for Beginners; 12/2008</a></li><details><summary>Copyright</summary><p><strong>↓ text</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">* Copyright (c) 2002-2007, Machtelt Garrels
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the author, Machtelt Garrels, nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL THE AUTHOR AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</div></details><li><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://tldp.org/LDP/intro-linux/html/index.html">Introduction to Linux; 06/2008</a></li><details><summary>Copyright</summary><p><strong>↓ text</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">* Copyright (c) 2002-2007, Machtelt Garrels
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the author, Machtelt Garrels, nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL THE AUTHOR AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</div></details></ol></ul><li><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://www.gnu.org/manual/">GNU Manual</a></li><li><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://www.kernel.org/doc/man-pages/">Linux man-pages</a></li><li><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://centoshelp.org/resources/commands/linux-system-commands/">CentOS - commands</a></li></ul><h1>Linux History</h1><ul><li>표준이 없던 초창기. 크고 비싼 컴퓨터들은 제각기의 운영체제를 갖고 있었고, 한 컴퓨터에서 작동하는 프로그램이 다른 컴퓨터에서 작동할 것이라는 보장도 할 수 없었다.</li><li>Bell Labs에서 재사용 가능한 C 기반의 운영체제 UNIX를 개발했다.</li><li>UNIX를 이용함으로써 각 시스템을 위한 전용 코드의 작성을 줄일 수 있게 되었다. <- 이 전용 코드가 바로 커널(kernel)</li><li>Linux는 리눅스 커널(리누스 토발즈 최초 개발)을 이용하는 UNIX 구현체로, 다수의 GNU tool을 이용한다.</li></ul><h1>시스템 ON/OFF</h1><div><h2>부팅 과정</h2><ol><li>BIOS 실행</li><li>POST 수행 ::= 장치 검사, 초기화</li><li>부트로더 실행 : 커널 로드. BIOS 종료</li><p>GRUB : GNU 프로젝트의 부트로더. 대부분 운영 체제의 커널을 불러올 수 있다</p><li>init 프로세스 실행 : /etc/inittab</li><p><strong>systemd가 사용되는 경우, inittab은 사용되지 않는다</strong></p><li>init 프로세스 중에 /etc/rc.d/rc.local 스크립트를 실행한다</li><p><strong>해당 파일은 호환을 위해 아직 남아있지만, 사용자 정의 systemd 서비스나 udev 규칙을 만드는 것이 권장된다</strong><a class="w3-btn w3-round-xxlarge w3-small w3-green goto" href="#pos1984153269" target="_self">Goto - service</a></p></ol><h2>shutdown : 시스템 종료</h2><p><strong>리눅스는 무정지 목적으로 설계됨에 유의</strong></p><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ shutdown [OPTIONS...] time [warning-message]</div><ol><li>-H : 시스템 종료</li><li>-P : 시스템 종료 + 전원 차단(하드웨어 지원 필요)</li><li>-r : 재부팅</li><li>-c : 대기중인 shutdown 취소</li><li>time : now | +<i>number</i> | yymmddhhmm</li><p>+number 단위(기본: 분)를 지정하려면 접미사 "s", "sec", "m", "min", "h", "hour" 이용</p><li>warning-message : 로그인한 유저들에게 보낼 브로드캐스팅 메시지</li></ol><h2>init : 일시적인 runlevel 변경</h2><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ init runlevel</div><ol><li>runlevel : 0(종료), 6(재부팅), 1(복구), 2(multiuser without NFS), 3(multiuser; TUI), 5(X11; GUI)</li><li>시스템 기본 runlevel 확인</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ systemctl get-default</div></ol></div><h1>서비스 관리<span id="pos1984153269" style="padding:0!important;margin:0!important;width:0!important;height:0!important;overflow:hidden!important"></span></h1><table><tr><th>구분</th><th>init</th><th>systemd</th></tr><tr><td>시작</td><td>/etc/init.d/${service} start</td><td>systemctl start ${service}</td></tr><tr><td>종료</td><td>/etc/init.d/${service} stop</td><td>systemctl stop ${service}</td></tr><tr><td>재시작</td><td>/etc/init.d/${service} restart</td><td>systemctl restart ${service}</td></tr><tr><td>상태</td><td>/etc/init.d/${service} status</td><td>systemctl status ${service}</td></tr><tr><td>자동 시작 O</td><td>chkconfig ${service} on</td><td>systemctl enable ${service}</td></tr><tr><td>자동 시작 X</td><td>chkconfig ${service} off</td><td>systemctl disable ${service}</td></tr><tr><td>자동 시작 상태</td><td>chkconfig --list ${service}</td><td>systemctl is-enabled ${service}</td></tr><tr><td>서비스 목록</td><td>ls /etc/init.d</td><td>systemctl --type service</td></tr></table><div><h2>init 사용자 정의 서비스</h2><ol><li>서비스 작성</li><p><strong>↓ /etc/init.d/my</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="bash">#!/bin/bash
# chkconfig: 2345 20 30
# description: My Custom Service

LOG=/var/log/my.log

start() {
    echo 'Service started...' >> $LOG
}

stop() {
    echo 'Service stopped...' >> $LOG
}

case "$1" in
    start)
        start
        ;;
    stop)
        stop
        ;;
    restart)
        stop
        start
        ;;
    status)
        echo "OK"
        ;;
    *)
        echo "Usage: $0 {start|stop|restart|status}"
esac

exit 0
</div><p><strong>chkconfig: 2345 20 30</strong> -> runlevel이 {2, 3, 4, 5} 중 하나면 실행. 시작 우선순위 20, 종료 우선순위 30</p><li>실행 권한 부여</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ chmod +x /etc/init.d/my</div><li>자동 실행 설정</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ chkconfig my on</div></ol><h2>systemd 사용자 정의 서비스</h2><ol><li>서비스 작성</li><p><strong>↓ /etc/systemd/system/myd.service</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="bash">[Unit]
Description=My Daemon

[Service]
Type=simple
ExecStart=/root/my.sh
Restart=on-failure

[Install]
WantedBy=multi-user.target
</div><li>최초 서비스 실행</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ systemctl start myd</div><li>자동 실행 설정</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ systemctl enable myd</div></ol></div><h1>쉘</h1><ol><li>유저의 기본 쉘은 /etc/passwd에 설정된다</li><li>echo $SHELL : 사용중인 쉘 확인</li><li>종류</li><ul><li>Login shell</li><p>최초 실행 시 유저명과 비밀번호를 묻고 진입하는 쉘.</p><li>Non login shell</li><p>기존 쉘에서 인증없이 새로 시작한 쉘.</p></ul></ol><h1>Bash</h1><div><h2>Special character</h2><table class="no-sort"><tr><td>#</td><td>주석 시작</td></tr><tr><td>;</td><td>커맨드 구분자</td></tr><tr><td>;;</td><td>case 옵션 종결자</td></tr><tr><td>;;&amp;, ;&amp;</td><td>case 옵션 종결자 Since bash 4<a class="w3-btn w3-round-xxlarge w3-small w3-green goto" href="#pos3046192" target="_self">Goto - case</a></td></tr><tr><td>.</td><td><ul><li>커맨드로 사용 : source 커맨드와 동일</li><li>파일명 접두에 위치 : ls에는 보여지지 않음</li><li>정규표현식 : 임의 글자에 매칭</li></ul></td></tr><tr><td>""</td><td>partial quoting<a class="w3-btn w3-round-xxlarge w3-small w3-green goto" href="#pos664382521" target="_self">Goto - quoting</a></td></tr><tr><td>''</td><td>full quoting<a class="w3-btn w3-round-xxlarge w3-small w3-green goto" href="#pos664382521" target="_self">Goto - quoting</a></td></tr><tr><td>,</td><td><ul><li>연산자 : 산술 연산이 순서대로 처리되고, 마지막 결과를 반환</li><li>대소문자 변환 in <a class="w3-btn w3-round-xxlarge w3-small w3-green goto" href="#pos2034571796" target="_self">Goto - parameter substitution</a> Since bash 4</li></ul></td></tr><tr><td>\</td><td>이스케이프. 바로 뒤의 문자를 리터럴로 취급</td></tr><tr><td>/</td><td>파일 경로 구분자</td></tr><tr><td>``</td><td><a class="w3-btn w3-round-xxlarge w3-small w3-green goto" href="#pos464872882" target="_self">Goto - command substitution</a></td></tr><tr><td>:</td><td>아무것도 하지않는 null command</td></tr><tr><td>*</td><td>GLOB 패턴 매칭에서, 해당 디렉터리 내 임의 파일명에 매칭</td></tr><tr><td>?</td><td>GLOB 패턴 매칭에서, 임의 1글자에 매칭</td></tr><tr><td>(command1; command2; ...)</td><td>Command group. 새 서브쉘에서 커맨드를 실행한다; 따라서 외부에서 참조 불가</td></tr><tr><td>{x,y,z,...}, {a..z}</td><td><a class="w3-btn w3-round-xxlarge w3-small w3-green goto" href="#pos-1667999982" target="_self">Goto - brace expansion</a></td></tr><tr><td>{}</td><td>코드 블록 정의. 컨텍스트는 유지되므로 외부에서도 변수 참조 가능. 코드 블록에 대해 IO 리디렉션 가능<p><strong>↓ bash</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="bash">{
    echo 'hello'
    echo 'world'
} >> test.log</div></td></tr><tr><td>[ EXPRESSION ], [[ EXPRESSION ]]</td><td><a class="w3-btn w3-round-xxlarge w3-small w3-green goto" href="#pos3556498" target="_self">Goto - test</a></td></tr><tr><td>$[ EXPRESSION ]</td><td>Deprecated. 정수 연산</td></tr><tr><td>(( EXPRESSION ))</td><td>정수 연산</td></tr><tr><td>리디렉션</td><td><ul><li>></li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ script.sh > test.log
# STDOUT을 test.log로. 파일이 없다면 생성하고, 있다면 덮어쓴다.

$ script.sh >&2
# STDOUT을 STDERR(2)로

$ script.sh > test.log 2>&1
# STDOUT을 test.log로 && STDERR(2)를 STDOUT(1)으로</div><li>&amp;></li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ not_exist.sh &> /dev/null # STDOUT, STDERR 모두 /dev/null로(==버림)
$ echo $?                   # non-zero</div><li>>></li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ script.sh >> test.log
# STDOUT을 test.log로. 파일이 없다면 생성하고, 있다면 append</div><li>&lt; : 파일을 STDIN으로.</li></ul></td></tr></table><h2>자동 실행 스크립트</h2><ul><li>Login shell : /etc/profile, ~/.bash_profile or ~/.bash_login or ~/.profile, ~/.bash_logout</li><p>/etc/profile은 /etc/bash.bashrc, /etc/profile.d/*.sh 들도 실행한다</p><li>Non login shell : ~/.bashrc</li><p>~/.bashrc 파일은 보통 ~/.bash_profile, ~/.profile 등에서도 실행한다</p></ul><h2>스크립트 디버깅</h2><ul><li>전체 스크립트 : bash -x filename</li><li>일부분 : 스크립트 내에서 플래그 조정</li><p><strong>↓ bash</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="bash"># ...
set -x # start debugging
w
set +x # stop debugging</div><li>현재 쉘에서 직접 플래그 조정</li><ul><li>set -f : disable file name generation using metacaracters</li><li>set -v : print shell input lines</li><li>set -x : print command traces before executing command</li></ul></ul><h2>변수</h2><div><h3>전역 변수</h3><ul><li>모든 쉘에서 접근 가능</li><li>env 또는 printenv 명령으로 목록 확인 가능</li></ul><h3>지역 변수</h3><ul><li>현재 쉘에서만 접근 가능</li><li>목록 확인</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ (set -o posix; set | sort) > set.sorted
$ (printenv | sort) > printenv.sorted
$ diff set.sorted printenv.sorted | grep "<" | awk '{ print $2 }'</div><li>변수 선언</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ varName="value"
$ let varName="value"</div><li>변수 전달</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell"># child process에서 사용할 수 있게 된다
$ export varName
$ export varName="value"</div></ul><h3>예약 변수</h3><table class="no-sort"><tr><th>name</th><th>definition</th></tr><tr><td>BASH</td><td>bash의 절대경로</td></tr><tr><td>BASH_ENV</td><td>로그인 쉘에서, 파일로 설정된 경우, 쉘 스크립트를 실행하기 전에 먼저 읽는다</td></tr><tr><td>BASH_VERSION</td><td>bash 버전</td></tr><tr><td>BASH_VERSINFO</td><td>bash 버전 정보에 대한 읽기 전용 수열</td></tr><tr><td>COLUMNS</td><td>터미널 출력 너비</td></tr><tr><td>COMP_CWORD</td><td>$COMP_WORDS에서 현재 커서가 위치하는 단어의 index</td></tr><tr><td>COMP_LINE</td><td>현재 커맨드 라인</td></tr><tr><td>COMP_POINT</td><td>현재 커맨드에서 커서 상대 위치</td></tr><tr><td>COMP_WORDS</td><td>현재 커맨드를 배열로</td></tr><tr><td>COMPREPLY</td><td>제시할 자동완성 단어 배열<a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://devmanual.gentoo.org/tasks-reference/completion/index.html">예시</a></td></tr><tr><td>EUID</td><td>명령을 실행 중인 현재 유저의 ID</td></tr><tr><td>FUNCNAME</td><td>현재 실행 중인 쉘 함수 이름</td></tr><tr><td>GROUPS</td><td>현재 유저가 속한 그룹으로 구성된 배열</td></tr><tr><td>HISTFILE</td><td>커맨드 이력. 기본값 ~/.bash_history</td></tr><tr><td>HISTFILESIZE</td><td>저장할 최대 이력 수</td></tr><tr><td>HOME</td><td>현재 유저의 home directory. ~ 기호로도 획득 가능</td></tr><tr><td>HOSTFILE</td><td>/etc/hosts와 동일한 포맷의 파일을 지정하면, 호스트 구성에 사용</td></tr><tr><td>HOSTNAME</td><td>현재 호스트</td></tr><tr><td>HOSTTYPE</td><td>머신 종류; e.g. x86_64</td></tr><tr><td>LANG</td><td>LC_* 변수에서 지정하지 않은 경우, 이 로캐일이 사용된다</td></tr><tr><td>LC_ALL</td><td>LANG 및 다른 모든 LC_* 변수에 우선한다</td></tr><tr><td>LC_COLLATE</td><td>파일명, 패턴 비교에 사용하는 로캐일</td></tr><tr><td>LC_CTYPE</td><td>파일명, 패턴 등의 문자 로캐일</td></tr><tr><td>LC_MESSAGES</td><td>&quot;$&quot; 해석에 사용할 로캐일</td></tr><tr><td>LC_NUMERIC</td><td>숫자 표현에 사용할 로캐일</td></tr><tr><td>LINENO</td><td>현재 라인 번호</td></tr><tr><td>MACHTYPE</td><td>CPU-COMPANY-SYSTEM</td></tr><tr><td>MAIL</td><td>MAILPATH가 설정되지 않은 경우, MAIL이 가리키는 파일에 신규 메일이 있으면 bash가 알려준다</td></tr><tr><td>MAILCHECK</td><td>메일 확인 주기(초)</td></tr><tr><td>MAILPATH</td><td>:으로 구별된 MAIL 파일들. 신규 메일이 있으면 bash가 알려준다</td></tr><tr><td>OLDPWD</td><td>이전 PWD</td></tr><tr><td>OPTARG</td><td>getopts가 마지막으로 처리한 옵션 인자의 값</td></tr><tr><td>OPTIND</td><td>getopts가 마지막으로 처리한 옵션 인자의 인덱스</td></tr><tr><td>OSTYPE</td><td>e.g. linux-gnu</td></tr><tr><td>PATH</td><td>:으로 구별된 디렉터리들. 커맨드가 존재하는지 shell이 찾아본다</td></tr><tr><td>PIPESTATUS</td><td>가장 최근 포그라운드에서 종료된 프로세스들의 종료 코드 배열</td></tr><tr><td>PPID</td><td>현재 쉘의 PPID</td></tr><tr><td>PROMPT_COMMAND</td><td>매 PS1 출력 전에 실행할 명령</td></tr><tr><td>PS1</td><td>Prompt string 1; Primary; default &quot;\s-\v\$ &quot;</td></tr><tr><td>PS2</td><td>Prompt string 2; Secondary; &quot;&gt; &quot;</td></tr><tr><td>PS3</td><td>select 커맨드에 사용되는 prompt. default &quot;#?&quot;</td></tr><tr><td>PS4</td><td>-x 옵션으로 커맨드 라인 실행 전에 echo 출력할 때 사용할 prefix; default &quot;+ &quot;</td></tr><tr><td>PWD</td><td>Print Working Directory</td></tr><tr><td>RANDOM</td><td>0 ~ 32767 사이 임의 정수; 할당하는 경우 seed로 전달된다</td></tr><tr><td>REPLY</td><td>read로 읽어온 문자열</td></tr><tr><td>SECONDS</td><td>쉘 시작 후 ?초</td></tr><tr><td>SHELLOPTS</td><td>:으로 구별된, 활성 쉘 옵션들</td></tr><tr><td>SHLVL</td><td>부모 bash 인스턴스 수 + 1</td></tr><tr><td>TMOUT</td><td>read 제한 시간(초)</td></tr><tr><td>UID</td><td>실제 현재 유저 ID</td></tr></table><h3>특별 변수</h3><table class="no-sort"><tr><th>character</th><th>definition</th></tr><tr><td>$#</td><td>$1~$9, ${10}~로 n번째 실행 인자 획득. $# 자체는 매개변수 개수 획득</td></tr><tr><td>$@</td><td>전체 인자를 ' '로 구분된 한 단어로 반환</td></tr><tr><td>$?</td><td>마지막 포그라운드 프로세스 종료 상태</td></tr><tr><td>$$</td><td>쉘 PID</td></tr><tr><td>$!</td><td>가장 최근 백그라운드 PID</td></tr><tr><td>$0</td><td>쉘 or 스크립트 이름</td></tr></table><h3>declare 로 변수 선언</h3><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ declare OPTION(S) VAR_NAME=value</div><ul><li>-a : 배열</li><li>-f : 이름에 해당하는 함수 정의 출력</li><li>-i : 정수</li><li>-p : 이름에 해당하는 변수 정의 출력</li><li>-r : 읽기 전용 변수로 고정</li><li>-x : export</li><li>옵션에 - 대신 +를 쓰면 해당 옵션을 끈다</li></ul><h3>Array</h3><ul><li>원소 타입 제한 없음</li><li>배열 길이 제한 없음</li><li>임의 인덱스 할당 가능</li><li>배열 선언 + 초기화</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ arr=(value1 value2 valueN)</div><li>암시적 배열 변수 선언</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ arr[3]=value</div><li>배열 참조</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ echo ${arr[*]}
$ echo ${arr[2]}</div></ul><h3>변수에 대한 연산<span id="pos2034571796" style="padding:0!important;margin:0!important;width:0!important;height:0!important;overflow:hidden!important"></span></h3><ul><li>${VAR_NAME^} : 첫번째 글자를 대문자로. Since bash 4</li><li>${VAR_NAME^^} : 전부 대문자로. Since bash 4</li><li>${VAR_NAME,} : 첫번째 글자를 소문자로. Since bash 4</li><li>${VAR_NAME,,} : 전부 소문자로. Since bash 4</li><li>${#VAR_NAME} | ${#*}, ${#@} | ${#arr[*]}, ${#arr[@]} : 변수 값의 길이 | 인자 개수 | 배열 길이</li><li>${VAR_NAME-WORD} : 변수가 없으면 WORD 반환</li><li>${VAR_NAME:-WORD} : 변수가 없거나 null이면 WORD 반환</li><li>${VAR_NAME=WORD} : 변수가 없으면 WORD 할당 후 반환</li><li>${VAR_NAME:=WORD} : 변수가 없거나 null이면 WORD 할당 후 반환</li><li>${VAR_NAME?WORD} : 변수가 없으면 실행 위치와 WORD 출력 후 exit code 1로 종료</li><li>${VAR_NAME:?WORD} : 변수가 없거나 null이면 실행 위치와 WORD 출력 후 exit code 1로 종료</li><li>${VAR_NAME+WORD} : 변수가 존재하면 WORD 반환. 아니면 null</li><li>${VAR_NAME:+WORD} : 변수가 존재하고 non-null이면 WORD 반환. 아니면 null</li><li>${VAR_NAME:OFFSET:LENGTH} : OFFSET(0 based index)부터 LENGTH(생략 시 끝까지)개 문자 출력</li><li>${VAR_NAME#WORD} : 접두 WORD패턴(shortest) 삭제</li><li>${VAR_NAME##WORD} : 접두 WORD패턴(longest) 삭제</li><li>${VAR_NAME%WORD} : 접미 WORD패턴(shortest) 삭제</li><li>${VAR_NAME%%WORD} : 접미 WORD패턴(longest) 삭제</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ arr=(aaab aabb abbb bbbb)
$ echo ${arr[*]#a*}
aab abb bbb bbbb
$ echo ${arr[*]##a*}
bbbb
$ echo ${arr[*]%*b}
aaa aab abb bbb
$ echo ${arr[*]%%*b}</div><li>${VAR_NAME/PATTERN/REPLACEMENT} : 최초 1회 치환</li><li>${VAR_NAME/#PATTERN/REPLACEMENT} : 접두와 일치하는 경우 치환</li><li>${VAR_NAME/%PATTERN/REPLACEMENT} : 접미와 일치하는 경우 치환</li><li>${VAR_NAME//PATTERN/REPLACEMENT} : 전체 치환</li><li>${!prefix*}, ${!prefix@} : 접두가 일치하는 모든 변수 이름 배열 반환</li></ul></div><h2>Quoting<span id="pos664382521" style="padding:0!important;margin:0!important;width:0!important;height:0!important;overflow:hidden!important"></span></h2><ul><li>\ : 다음 글자를 리터럴로 간주</li><li>'' : 내부 문자열을 리터럴로 간주</li><li>"" : 내부 문자열을 리터럴로 간주; 단 $, `, \ 제외. 여러줄에 걸쳐 작성 가능.</li></ul><h2>Expansion</h2><ol><li>각 커맨드 토큰들은 순서대로 해석되며, 모든 해석이 끝난 뒤 quote가 제거된다</li><li>Brace expansion<span id="pos-1667999982" style="padding:0!important;margin:0!important;width:0!important;height:0!important;overflow:hidden!important"></span></li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ echo ab{c,d,e}fg
# abcfg abdfg abefg
$ mv name.{txt,txt.old}
$ for n in {1..20}; do echo $n; done
$ for n in log-{100..20}.txt; do echo $n; done
$ for n in {z..A}; do echo $n; done</div><li>Tilde expansion</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ echo ~          # 현재 유저의 home directory
$ echo ~USER_NAME # 특정 유저의 home directory
$ echo ~+         # PWD
$ echo ~-         # OLDPWD</div><li>Parameter(and variable) expansion</li><ul><li>${VAR_NAME}, $VAR_NAME</li><p>{}는 옵션이다. ${INSTALL_DIR}_old/ 처럼 뒤에 곧바로 다른 문자가 오는 경우 구분을 위해 사용</p><li>${VAR_NAME:=value}</li><p>변수가 존재하지 않으면 초기화하고 반환</p><li>$0~$9, ${10}~</li><p>n번째 실행 인자 획득. 2글자 넘어가면 {} 필수</p></ul><li>Command substitution : $(command), `command`<span id="pos464872882" style="padding:0!important;margin:0!important;width:0!important;height:0!important;overflow:hidden!important"></span></li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell"># command 실행 결과(STDOUT)로 치환
$ echo $(echo $(echo abcd))</div><li>Arithmetic expansion : $(( EXPRESSION )), $[ EXPRESSION ]</li><ul><li>EXPRESSION은 "로 감싸인 걸로 간주된다. " 자체는 특별한 의미를 갖지 않는다.</li><li>EXPRESSION 내부 토큰들도 parameter expansion, command substitution, quote removal을 거친다</li><li>EXPRESSION은 중첩될 수 있다</li><li>EXPRESSION 연산은 고정폭 정수로 행해지며, overflow 검사는 하지 않는다.</li><li>0으로 시작하는 상수는 8진수, 0x는 16진수로 간주된다.</li><li>2#10 ~ 64#12abAB@_ 표기로 2~64진법 표현 가능. 36진법 이하에서 대소문자는 구별되지 않는다.</li></ul><table class="no-sort"><caption>Operators</caption><tr><td>VAR++, VAR--</td><td>단항 연산(후위)</td></tr><tr><td>++VAR, --VAR</td><td>단항 연산(전위)</td></tr><tr><td>-, +</td><td>단항 연산</td></tr><tr><td>!, ~</td><td>논리/비트 NOT</td></tr><tr><td>**</td><td>거듭제곱</td></tr><tr><td>*, /, %</td><td>곱, 몫, 나머지</td></tr><tr><td>+, -</td><td>이항 연산</td></tr><tr><td>&lt;&lt;, &gt;&gt;</td><td>비트 이동</td></tr><tr><td>&lt;=, &gt;=, &lt;, &gt;</td><td>비교 연산</td></tr><tr><td>==, !=</td><td>동등 비교</td></tr><tr><td>&amp;</td><td>비트 AND</td></tr><tr><td>^</td><td>비트 XOR</td></tr><tr><td>|</td><td>비트 OR</td></tr><tr><td>&amp;&amp;</td><td>논리 AND</td></tr><tr><td>||</td><td>논리 OR</td></tr><tr><td>expr ? expr : expr</td><td>삼항 연산</td></tr><tr><td>=, *=, /=, %=, +=, -=, &lt;&lt;=, &gt;&gt;=, &amp;=, ^=, |=</td><td>대입 연산</td></tr><tr><td>,</td><td>표현식 구별. 가장 마지막 표현식 결과가 리턴된다</td></tr></table><li>Process substitution</li><ul><li>x &lt;(COMMAND_LIST) y : COMMAND_LIST대로 프로세스를 실행하고, 그 결과를 갖는 임시 파일(/dev/fd/N)과 y를 순서대로 x의 인자로 전달</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ cat &lt;(ls -a) &lt;(ls -al)</div><li>x &gt;(COMMAND_LIST) y : x /dev/fd/N y를 실행하고, /dev/fd/N는 다시 COMMAND_LIST 프로세스의 인자로 전달</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ tar -cf >(cat) test.sh tmp.txt
# test.sh0000774000000000000000000000002614004476247011101 0ustar  rootroot
# Content of 'test.sh'
# tmp.txt0000664000000000000000000000002614004476253011122 0ustar  rootroot
# Content of 'tmp.txt'</div></ul><li>Word splitting</li><ul><li>Parameter expansion, command substitution, arithmetic expansion의 결과에 대해 단어를 분할한다</li><li>단어의 분할은 IFS 변수(Internal Field Separator)에 설정(기본값 ' \t\n')된 문자들을 구분자로 하여 진행된다.</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ echo $IFS

$ IFS=123
$ str=a1b2c3d4e5
$ echo $str
a b c d4e5
$ echo "$str"
a1b2c3d4e5
$ echo $IFS
  
$ echo "$IFS"
123
$ IFS=' \t\n'
$ echo $str
a1b2c3d4e5</div></ul><li>File name expansion</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ echo t* # 배열로 반환
test.sh tmp.txt</div><p><strong>↓ test.sh</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ echo $1
$ echo $#</div><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ cat <("${PWD}/"t*)
/workspace/donggi-github/tmp.txt
1
$ cat <("${PWD}/"t*.sh)

0
</div></ol><h2>Aliases</h2><ul><li>목록 확인 : alias</li><li>설정 : alias text='COMMAND_LIST'</li><li>해제 : unalias text</li><li>alias는 자식 프로세스에 상속되지 않는다</li></ul><h2>Test<span id="pos3556498" style="padding:0!important;margin:0!important;width:0!important;height:0!important;overflow:hidden!important"></span></h2><h2>정규표현식</h2><table class="no-sort"><tr><td>^</td><td>line 시작</td><td>$</td><td>line 끝</td></tr><tr><td>\b</td><td>word 경계</td><td>\B</td><td>not \b. 즉 2글자 이상의 word 내부</td></tr><tr><td>\&lt;</td><td>word 시작</td><td>\&gt;</td><td>word 끝</td></tr><tr><td>[[CLASS]]</td><td>alnum, alpha, ascii, blank, cntrl, digit, graph, lower, print, punct, space, upper, word, xdigit</td></tr></table><h2>sed; Stream EDitor</h2><div><p>sed는 표준 입력 또는 파일로부터 편집을 수행(원본 수정은 없다)하고 표준 출력한다.</p><table class="no-sort"><caption>Commands</caption><tr><td>a\text</td><td>각 줄 아래에 text를 쓴다</td></tr><tr><td>c\text</td><td>각 줄을 text로 치환</td></tr><tr><td>/pattern/d</td><td>패턴이 포함된 줄 지우기</td></tr><tr><td>2,4d</td><td>2~4 줄 지우기</td></tr><tr><td>2,$d</td><td>2~마지막 줄 지우기</td></tr><tr><td>i\text</td><td>각 줄 위에 text를 쓴다</td></tr><tr><td>/pattern/p</td><td>pattern이 매칭되는 줄만 출력</td></tr><tr><td>s/pattern/replacement/</td><td>찾아 바꾸기; 줄당 최초 1회</td></tr><tr><td>2,4s/pattern/replacement/</td><td>찾아 바꾸기; 2~4줄에서 각 줄당 최초 1회</td></tr><tr><td>2,/pattern1/s/pattern2/replacement/</td><td>찾아 바꾸기; 2줄부터 pattern1이 존재하는 줄까지, 각 줄당 최초 1회</td></tr><tr><td>/pattern1/,/pattern2/s/pattern3/replacement/</td><td>찾아 바꾸기; pattern1이 존재하는 줄부터 pattern2가 존재하는 줄까지, 각 줄당 최초 1회</td></tr><tr><td>s/pattern/replacement/gi</td><td>찾아 바꾸기; 대소문자 구별없이(i), 해당 줄의 모든 매칭(g)에 대해 변환 수행</td></tr><tr><td>3q</td><td>3줄까지만 처리하고 종료</td></tr></table><table class="no-sort"><caption>Options</caption><tr><td>-e script</td><td>script 커맨드들도 실행한다</td></tr><tr><td>-f script-file</td><td>script-file의 커맨드들도 실행한다</td></tr><tr><td>-n</td><td>매칭 라인만 출력</td></tr></table></div><h2>awk</h2><div><h3>개요</h3><p>스트림 편집 프로그램; 및 프로그래밍 언어</p><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ awk { PROGRAM } inputFile(s)        # 각 파일 모든 라인들에 대해 PROGRAM 실행
$ awk '/REGEX/(gmi) { PROGRAM } inputFile(s) # 각 파일 REGEX 일치 라인들에 대해 PROGRAM 실행
$ awk -f programFile inputFile(s)
</div><h3>print</h3><ul><li>default input field separator ::= [ \t]+</li><li>$1, $2, ... ::= 라인의 i번째 필드</li><li>$0 ::= 라인 전체</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ ls -al | awk '{ print $9 }'</div><li>formatting</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ ls -al | awk '{ print $9 " with formatting -> [" $9 "]" }'</div><li>전처리/후처리</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ ls -al | awk 'BEGIN { print "Hello\n" } { print $9 } END { print "Bye\n" }'</div></ul><h3>variable</h3><ul><li>FS : field separator</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ ls -al | awk 'BEGIN { FS="t+" } { print $1 }'</div><li>OFS : output field separator</li><li>ORS : output record separator</li><li>NR : number of record</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ ls -alh | awk 'BEGIN { OFS=" = "; ORS="\n>>> line " } { print NR "\n" $9,$5 "B" }'</div><li>User defined variable</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ ls -al | awk 'BEGIN { totalSize=0 } { totalSize=totalSize + $5 } END { print "Total size = " totalSize "bytes" }'</div></ul><h3>printf</h3></div><h2>Conditional statements</h2><div><h3>if - General</h3><ul><li>가장 단순한 구문</li><p><strong>↓ bash</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="bash">if TEST-COMMANDS; then COMMANDS; fi
# TEST-COMMANDS가 성공적으로 종료(exit code==0)하면 then 실행

if true; then echo hello; fi
if false; then echo hello; fi</div><li>조건식</li><table><tr><th>식</th><th>TRUE</th></tr><tr><td>[ -a FILE ]</td><td>FILE 존재</td></tr><tr><td>[ -b FILE ]</td><td>FILE 존재 &amp;&amp; block device</td></tr><tr><td>[ -c FILE ]</td><td>FILE 존재 &amp;&amp; character device</td></tr><tr><td>[ -d FILE ]</td><td>FILE 존재 &amp;&amp; directory</td></tr><tr><td>[ -e FILE ]</td><td>FILE 존재</td></tr><tr><td>[ -f FILE ]</td><td>FILE 존재 &amp;&amp; regular file</td></tr><tr><td>[ -g FILE ]</td><td>FILE 존재 &amp;&amp; SGID bit set</td></tr><tr><td>[ -h FILE ]</td><td>FILE 존재 &amp;&amp; symbolic link</td></tr><tr><td>[ -k FILE ]</td><td>FILE 존재 &amp;&amp; sticky bit set</td></tr><tr><td>[ -p FILE ]</td><td>FILE 존재 &amp;&amp; pipe</td></tr><tr><td>[ -r FILE ]</td><td>FILE 존재 &amp;&amp; redable</td></tr><tr><td>[ -s FILE ]</td><td>FILE 존재 &amp;&amp; size &gt; 0</td></tr><tr><td>[ -t FD ]</td><td>FD가 터미널에 연결됨</td><p><strong>↓ bash</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="bash">if [ -t 1 ]; then echo hello; fi
if [ -t 2 ]; then echo hello; fi</div></tr><tr><td>[ -u FILE ]</td><td>FILE 존재 &amp;&amp; SUID bit set</td></tr><tr><td>[ -w FILE ]</td><td>FILE 존재 &amp;&amp; writable</td></tr><tr><td>[ -x FILE ]</td><td>FILE 존재 &amp;&amp; executable</td></tr><tr><td>[ -O FILE ]</td><td>FILE 존재 &amp;&amp; 현재(effective) 유저가 소유</td></tr><tr><td>[ -G FILE ]</td><td>FILE 존재 &amp;&amp; 현재(effective) 그룹이 소유</td></tr><tr><td>[ -L FILE ]</td><td>FILE 존재 &amp;&amp; symbolic link</td></tr><tr><td>[ -N FILE ]</td><td>FILE 존재 &amp;&amp; 마지막으로 읽은 시점 이후에 수정됨</td></tr><tr><td>[ -S FILE ]</td><td>FILE 존재 &amp;&amp; socket</td></tr><tr><td>[ FILE1 -nt FILE2 ]</td><td>Newer than ::= FILE1이 FILE2보다 최근에 수정됨 || FILE1은 있지만 FILE2는 없음</td></tr><tr><td>[ FILE1 -ot FILE2 ]</td><td>Older than ::= FILE1이 FILE2보다 이전에 수정됨 || FILE2는 있지만 FILE1은 없음</td></tr><tr><td>[ -o OPTIONNAME ]</td><td>쉘 옵션이 켜 있음</td></tr><tr><td>[ -z STRING ]</td><td>STRING 길이 == 0</td></tr><tr><td>[ -n STRING ] or [ STRING ]</td><td>STRING 길이 &gt; 0</td></tr><tr><td>[ STRING1 == STRING2 ]</td><td></td></tr><tr><td>[ STRING1 != STRING2 ]</td><td></td></tr><tr><td>[ STRING1 &lt; STRING2 ]</td><td>현재 로캐일상 STRING1이 앞섬</td></tr><tr><td>[ STRING1 &gt; STRING2 ]</td><td>현재 로캐일상 STRING2가 앞섬</td></tr><tr><td>[ ARG1 OP ARG2 ]</td><td>정수 비교. OP in (-eq, -ne, -lt, -le, -gt, -ge)</td></tr><tr><td>[ ! EXPRESSION ]</td><td>not EXPRESSION</td></tr><tr><td>[ (EXPRESSION) ]</td><td>연산 우선순위 조정 가능</td></tr><tr><td>[ EXPRESSION1 -a EXPRESSION2 ]</td><td>EXPRESSION1 and EXPRESSION2</td></tr><tr><td>[ EXPRESSION1 -o EXPRESSION2 ]</td><td>EXPRESSION1 or EXPRESSION2</td></tr></table></ul><h3>if - Advanced</h3><ul><li>[] vs [[]]</li><ul><li>[[]]는 변수 값에 대한 word splitting을 수행하지 않는다</li><li>[[]]는 file name expansion을 수행하지 않는다</li><li>[[]]는 glob 패턴 매칭 수행</li><p><strong>↓ bash</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="bash">if [[ "hello" == h* ]]; then echo hello; fi</div></ul><li>else</li><p><strong>↓ bash</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="bash">if ...; then ... else ... fi</div><li>elif</li><p><strong>↓ bash</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="bash">if ...; then ... elif ...; then ... fi</div><li>if 구문 중첩 가능</li></ul><h3>case<span id="pos3046192" style="padding:0!important;margin:0!important;width:0!important;height:0!important;overflow:hidden!important"></span></h3><ul><li>;; -> case 옵션 종결 &amp;&amp; case 구문 종료.</li><li>;;&amp; -> case 옵션 종결 &amp;&amp; 다음 패턴 검사 실행. Since bash 4</li><li>;&amp; -> case 옵션 종결 &amp;&amp; 다음 옵션 무조건 실행. Since bash 4</li></ul><p><strong>↓ bash</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="bash">case "$1" in
    start)
        start
        ;;
    restart)
        stop
        sleep 5
        start
        ;;
    *)
        echo "Usage $0 {start|restart}"
        exit 1
esac

case $num in
    10 | 20 ) echo $num' is 10 or 20';;
    *) echo $num' is not 10 nor 20';;
esac
</div></div><h2>Repetitive tasks</h2><div><h3>for</h3><p><strong>↓ bash</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="bash">for NAME; do COMMANDS; done         # 실행 인자 순회
for NAME in LIST; do COMMANDS; done # LIST 순회

# e.g.
for n in 10 20 30; do echo $n; done
for n in {1..20}; do echo $n; done
for n in log-{100..20}.txt; do echo $n; done
for n in {z..A}; do echo $n; done
for f in *; do cp "$f" "$f.bak"; done</div><h3>select</h3><p><strong>↓ bash</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="bash">select NAME; do COMMANDS; done         # 실행 인자 중 선택
select NAME in LIST; do COMMANDS; done # LIST 중 선택</div><ol><li>stderr에 목록 출력 -> PS3 출력 -> stdin으로부터 한 줄 입력</li><li>입력이 숫자로 구성되었고, 해당하는 항목이 존재하는 경우 : NAME에 항목 설정, REPLY에 입력 라인 설정</li><li>입력이 비어있는 경우, goto 1</li><li>입력이 EOF인 경우 반복 종료</li><li>그 외의 경우 NAME은 null string, REPLY에 입력 라인 설정</li></ol><h3>while</h3><p><strong>↓ bash</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="bash">while CONTROL-COMMAND; do COMMANDS; done</div><h3>until</h3><p><strong>↓ bash</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="bash">until TEST-COMMAND; do COMMANDS; done</div><h3>break</h3><p>즉시 반복 중단</p><h3>continue</h3><p>즉시 다음 순회로</p><h3>shift</h3><p><strong>↓ bash</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="bash">shift   # $1 인자 버려짐
shift 3 # $1, $2 인자 버려짐

while (( "$#" ));
do
    echo $1
    shift
done
</div></div><h2>Function</h2><p><strong>↓ bash</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="bash"># 선언 1
function FUNCNAME { COMMANDS; }
# 선언 2
FUNCNAME () { COMMANDS; }
# 호출 1
FUNCNAME
# 호출 2
FUNCNAME param1 param2 # <- 함수 안에서 $1, $2, ...로 접근
# 호출 3
test () {
    return 33
}

test
echo $?
val=$?

exit $val
</div><h2>Catching signal</h2><div><h3>Signal</h3><table class="no-sort"><tr><td>SIGHUP</td><td>1</td><td>Hangup</td></tr><tr><td>SIGINT</td><td>2</td><td>Interrupt frmo keyboard; Ctrl+C</td></tr><tr><td>SIGKILL</td><td>9</td><td>Kill; 강제 종료</td></tr><tr><td>SIGTERM</td><td>15</td><td>Termination; 정상 종료</td></tr><tr><td>SIGSTOP</td><td>17, 19, 23</td><td>Stop</td></tr></table><p>SIGKILL, SIGSTOP은 잡거나, 지연시키거나, 무시할 수 없다</p><h3>Trap</h3><p><strong>↓ bash</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="bash">trap COMMANDS SIGNALS
# e.g.
trap "{ echo \"Good Bye!\"; exit 255; }" EXIT
exit 0</div><ul><li>SIGNALS 중의 신호를 감지하면 COMMANDS가 실행된다</li><li>SIGNALS ::= 신호 이름(SIG 접두 생략 가능) 또는 정수</li></ul></div></div><h1>Commands</h1><div><h2>:</h2><p>아무것도 하지 않는 null 명령.</p><h2>echo</h2><p>end-of-line 문자를 덧붙여 stdout으로 단순 출력. 항상 0 종료</p><h2>printf</h2><p>포맷대로 stdout 출력. 처리에 따라 종료 상태 다를 수 있음.</p><h2>source == .</h2></div><h1>사용자 관리</h1><ol><li>useradd : 사용자 추가</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ useradd [options] USER_NAME</div><p>-d(HOME_DIR), -g(group id or name), -p(password), -D(기본값 출력/설정), 등...</p><li>passwd : 비밀번호 설정</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ passwd [options] USER_NAME</div><p>-d(삭제), -l(잠금), -u(잠금 해제), -e(강제 만료)</p><li>usermod : 사용자 수정</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ usermod [options] USER_NAME</div><p>-d(HOME_DIR), -m(HOME_DIR 변경 시 파일 이동), -L(잠금), -p(password), 등...</p><li>userdel : 사용자 삭제</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ userdel [options] USER_NAME</div><li>groupadd : 사용자 그룹 추가</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ groupadd [options] GROUP_NAME</div><p>-g(수동 GID), -p(password)</p><li>groupdel : 사용자 그룹 삭제</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ groupdel [options] GROUP_NAME</div><li>su : 다른 사용자 권한 사용</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ su [options] [-] [USER_NAME [arg]...]</div><p>다른 사용자의 권한으로 쉘을 실행한다. USER_NAME이 없으면 root로 간주한다. 단순히 '-'만 있으면 '-l'과 동일하다.</p><li>사용자 목록 : /etc/passwd</li><p><strong>↓ text</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">ID:Password(x):UID:GID:Comment:HOME_DIR:SHELL
root:x:0:0:root:/root:/bin/bash
dgkim:x:1000:1000:dgkim:/home/dgkim:/bin/bash</div><li>비밀번호 목록 : /etc/shadow</li><p>!!는 비밀번호가 설정되지 않았음을 의미</p><li>사용자의 홈디렉터리는 /etc/skel의 파일을 /home/${USER_NAME}에 복사하여 만들어진다</li></ol><h1>파일 시스템</h1><p><strong>↓ text</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">UNIX에서 모든 것은 파일이다. 파일이 아닌 것이 있다면, 프로세스다.</div><ol><li>파일 종류</li><ul><li>regular file(-) : 일반적인 데이터(텍스트, 바이너리)를 갖는 파일</li><li>directory(d) : 다른 파일의 목록을 갖는 파일</li><li>special file(c) : IO에 이용. 대부분 /dev 경로에 존재</li><li>link(l) : 다른 파일/디렉터리를 가리키는 파일</li><li>socket(s) : 프로세스 간 통신에 이용. TCP/IP 소켓과 유사</li><li>named pipe(p) : 프로세스 간 통신에 이용. 네트워크 소켓 semantic를 사용하지 않음</li><li>block device(b) : 하드디스크, DVD 등 블록/섹터 단위 IO 장치파일</li></ul><li>디렉터리 구조</li><table><tr><th>디렉터리</th><th>내용</th></tr><tr><td>/bin</td><td>시스템, 관리자, 일반 사용가 모두가 공유하는 명령어</td></tr><tr><td>/boot</td><td>시동에 필요한 파일</td></tr><tr><td>/dev</td><td>주변장치파일</td></tr><tr><td>/etc</td><td>환경설정</td></tr><tr><td>/home</td><td>유저 개인 파일</td></tr><tr><td>/lib</td><td>라이브러리, 커널 모듈</td></tr><tr><td>/mnt, /media</td><td>보조기억장치 mount point</td></tr><tr><td>/net</td><td>원격 파일 시스템 mount point</td></tr><tr><td>/opt</td><td>3rd party 프로그램</td></tr><tr><td>/proc</td><td>시스템 리소스 정보</td></tr><tr><td>/root</td><td>관리자 전용 홈 디렉터리</td></tr><tr><td>/sbin</td><td>시스템 및 관리자용 프로그램</td></tr><tr><td>/tmp</td><td>임시 파일. 재부팅 시 삭제되므로 저장용으로 사용하지 말 것</td></tr><tr><td>/usr</td><td>응용(not system)프로그램</td></tr><tr><td>/var</td><td>자주 변경하는 파일</td></tr></table><li>자신의 홈 디렉터리 확인 : echo $HOME</li><li>I-node</li><p>파일의 이름을 제외한 모든 정보. ID는 각 파일에 고유하게 부여된다</p><li>pwd : 작업 디렉터리 절대경로 출력. Print working directory</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ pwd</div><li>cd : 작업 디렉터리 변경</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ cd            # 자신의 HOME_DIR로
$ cd DIR        # 지정 디렉터리로
$ cd ~USER_NAME # 유저 HOME_DIR로
</div><li>ls : 파일 목록 출력</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ ls [options] [paths]</div><ul><li>options</li><p>-a(.로 시작하는 경로 포함), -c(with -lt: 시간순, with -l: 이름순), -X(확장자순), -S(크기순), -r(역정렬), -l(자세히), 등...</p><li>출력 예</li><p><strong>↓ text</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">d rwx r-x r-x # 디렉터리, 소유자 권한, 그룹 권한, 기타 사용자 권한 755(read, write, execute)
- rw- r-- r-- # 파일, (상동) 644
l r-- r-- r-- # 링크, (상동) 444
</div></ul><li>mkdir : 디렉터리 생성</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ mkdir [options] [directories]</div><p>-m(권한, 기본 755), -p(경로상의 모든 디렉터리 생성)</p><li>rm : 파일 삭제</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ rm [options] [paths]</div><ul><li>options</li><p>-f(파일이 없으면 무시), -i(각 파일 삭제 확인), -r(재귀 실행), 등...</p><li>예. my_dir 디렉터리 및 내부 파일 모두 삭제</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ rm -rf ./my_dir</div></ul><li>touch : 파일 시각 변경</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ touch [options] [files]</div><p>각 파일에 대해 시간 정보를 현재 시각으로 변경한다. 파일이 없으면 생성한다(크기 0).</p><li>파일 권한 변경</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ chmod [options] 8진수 [paths]
# 예. 모든 .sh 파일 실행 권한 부여
$ chmod +x *.sh
# 예. bin/ 디렉터리 하위 전체에 실행 권한 부여
$ chmod -R +x ./bin/

# 예. tmp/ 디렉터리 하위 전체 소유자 변경
$ chown -R readonly ./tmp/

# 예. tmp/ 디렉터리 하위 전체 소유 그룹 변경
$ chgrp -R readonly ./tmp/
</div><li>cp : 파일 복사</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ cp [options] source dest_path
$ cp [options] [sources] [target_directory]</div><p>-a(파일 속성 유지), -b(목적지에 이미 있으면 백업하고 복사), -r(재귀 실행), -s(심볼릭 링크 생성), 등...</p><li>mv : cp + 원본 삭제</li><li>cat : 파일 텍스트 출력</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ cat [options] [files]</div><p>-n(줄 번호), -E(줄 끝에 $), -s(반복적인 빈 라인 생략), -T(탭을 ^T로 표기)</p><li>find</li><p>파일명 표현에 와일드카드 *, ?가 허용된다. 표현식 앞에 !이나 -not을 붙일 수 있다. 표현식들 사이를 -and, -or로 엮을 수 있다.</p><li>grep : 텍스트 검색</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ grep [options] pattern [files]</div><p>-E(ERE), -G(BRE), -P(Perl Regexp), -e(정규표현식), -i(ignore case), -w(패턴에 단어 전체가 매칭되는 경우만), -x(패턴에 줄 전체가 매칭되는 경우만), -m(최대 출력 개수), -n(줄 번호 같이 출력), -o(매칭된 부분만 출력), -l(매칭된 파일들의 이름만 출력), -L(매칭되지 않는 파일들의 이름만 출력), -A(매칭 후 n개 라인도 출력), -B(매칭 전 n개 라인도 출력) 등...</p><li>| : 파이프라인</li><p>프로세스들의 출력과 입력을 잇는 파이프라인을 구성한다.</p><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ history | grep psql</div><li>tar : 압축</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ tar [options] file       # 압축해제
$ tar [options] file paths # 압축</div><p>Main Operation : -A(append), -r(append), -c(create), -d(파일 시스템과의 차분 출력), -t(목록 출력), -u(update), -x(압축해제)<br>포맷 : --bzip2, --xz, --lzip, --lzma, --gzip<br>-h(링크 자체 대신, 링크가 가리키는 파일을 압축한다)</p></ol><h1>패키지 관리</h1><ol><li>RPM : Redhat Package Manager</li><p>{package_name}-{version}-{release}.{architecture}.rpm</p><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ rpm [options]</div><p>-a(전체 패키지 검증), -i(install), -U(설치 또는 upgrade), -F(기존 패키지 upgrade), -v(verbose), -h(진행과정을 #로), -e(erase), -qa(설치된 패키지 목록), -qi(패키지 상세 정보) 등...</p><li>yum</li><p>인터넷 저장소로부터 패키지를 다운로드하여 설치. 의존 패키지까지 자동 설치한다.<br>Commands : clean(캐시 삭제), check-update, downgrade, erase, info, install, list, reinstall, search, update, version, 등...</p></ol><h1>EPEL(Extra Packages for Enterprise Linux) 허용</h1><ol><li>서드 파티 패키지를 설치하려면 EPEL을 허용해야 한다</li><li>RHEL 6.x / CentOS 6.x</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-6.noarch.rpm</div><li>RHEL 7.x / CentOS 7.x</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm</div><p>또는</p><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ yum install epel-release.noarch</div></ol><h1>시간 관련</h1><ol><li>date : 시각 출력/변경</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ date                # 현재 시각 출력
$ date "+%Y-%m-%d %T" # 포맷 지정

$ date -s time_string # 시각 변경
$ date -s "2019-01-01 12:34:56"
</div><li><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://nxmnpg.lemoda.net/8/ntpdate">ntpdate</a> : 시각 동기화</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ ntpdate server    # 동기화
$ ntpdate -d server # 오차 출력</div><p>NTP : Network Time Protocol. 시간 동기화를 위한 프로토콜.</p><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://zetawiki.com/wiki/공용_NTP_서버_목록">공용_NTP_서버_목록</a></ol><h1>crond : 작업 예약</h1><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ systemctl status crond # 상태 확인
$ crontab -l             # 작업 목록 출력
    # -e : edit
    # -u : 사용자 지정</div><ul><li>유저가 아닌 시스템 단위의 작업은 /etc/crontab 직접 수정</li><li>crontab path 설정</li><p><strong>↓ text</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">PATH=/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin</div></ul><h1>프로세스 관련</h1><ol><li>새 프로세스 실행</li><ol><li>fork : 새 프로세스는 기존 프로세스(parent)가 PID만 다른 복제본을 생성함으로써 만들어진다.</li><li>exec : 새 프로세스의 정보로 주소 공간을 덮어쓴다</li></ol><li>ps : 프로세스 출력. Process Snapshot</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ ps -ef # -e(전체 프로세스), -f(full-format)</div><li>w : 로그인한 유저와 무엇을 실행중인지 출력</li><li>kill : 프로세스 종료</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ kill -9 pid # 15(일반 종료), 2(종료; 무시 가능), 9(강제종료; 무시 불가), 1(구성 파일 다시 읽기; 데몬 프로세스)</div><li>top : 실행 중인 작업 보기.</li><li>백그라운드 작업</li><ul><li>%n : 모든 백그라운드 프로세스는 번호를 할당받으며, %n으로 참조할 수 있다</li><li>Ctrl + Z : 현재 프로세스를 백그라운드로 전환하고 suspend</li><li>bg : 백그라운드 job으로 계속 실행 ↔ fg %n</li><li>jobs : 백그라운드 job 리스트</li><p>명령행 끝에 &를 붙이면 즉시 백그라운드 job으로 실행시킬 수 있다<br>현재 터미널 세션이 종료해도 n번 백그라운드 job을 계속하게 하려는 경우 : disown -h %n</p><li>nohup name.sh &>/dev/null &</li><ul><li>nohup : 세션이 종료해도 프로세스는 계속 실행</li><li>& : 백그라운드로 실행</li></ul></ul></ol><h1>메모리 관련</h1><ol><li>vmstat : Report virtual memory statistics</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ vmstat 1 # 1초마다 출력</div><li>free : Display amount of free and used memory in the system.</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ free -m -w -h -s 1
    # -m : 메가바이트 단위
    # -w : wide output
    # -h : human-readable output
    # -s 1 : 1초마다
</div></ol><h1>환경변수</h1><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ printenv [VAR_NAMES]
$ echo $VAR_NAME
$ export VAR_NAME[=value]
# export PATH="$PATH:/usr/java/jdk-13.0.2/bin
</div><h1>FTP Server : vsftpd</h1><ol><li>설치</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ yum install vsftpd</div><li>설정 : /etc/vsftpd/vsftpd.conf</li><p><strong>↓ properties</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="properties">anonymous_enable=NO # 익명 차단
listen_ipv6=NO # IPv4 사용
</div><li>방화벽 허용</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ firewall-cmd --permanent --add-service=ftp
$ firewall-cmd --permanent --add-port=21/tcp
$ firewall-cmd --reload
# ↓ 잘 됐는지 확인
$ firewall-cmd --zone=public --list-all
</div><li>SELinux 관련 정책 확인</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ getsebool -a | grep ftp
$ setsebool ftp_home_dir on # 필요한 권한은 허용
</div><li>시스템 시작</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ systemctl enable vsftpd
$ systemctl restart vsftpd</div></ol><ul><li>root 로그인 허용</li><p>/etc/vsftpd/ftpusers, /etc/vsftpd/user_list에서 root 제거</p><li>사용자 홈 디렉터리 외부 접근 허용</li><p>/etc/vsftpd/chroot_list : chroot_list_enable=YES</p><li>Active Mode 사용 : 20포트</li><p>/etc/vsftpd/vsftpd.conf : pasv_enable=NO</p><li>Passive Mode 사용</li><ol><li>/etc/vsftpd/vsftpd.conf</li><p><strong>↓ properties</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="properties">connect_from_port_20=NO
pasv_enable=YES
pasv_min_port=50000
pasv_max_port=50010</div><li>방화벽에서 [pasv_min_port,pasv_max_port]/tcp 허용</li></ol></ul><h1>SELinux</h1><ol><li>SELinux 모드 : enforce, permissive, disable</li><p>setenforce 1 # enforce로 임시 변경<br>setenforce 0 # permissive로 임시 변경<br>getenforce # 모드 확인</p><li>부팅시 사용되는 기본 모드는 /etc/selinux/config에 정의돼있다</li><li>SELinux 로그 위치 : /var/log/audit/audit.log</li><li>SELinux 로그 분석 유티릴티 : setroubleshoot</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ yum install setroubleshoot
$ sealert -a /var/log/audit/audit.log
</div></ol><h1>/etc/hosts</h1><p><strong>address hostname[[ alias1]...]</strong></p><p><strong>↓ text</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">127.0.0.1   localhost localhost4
::1         localhost localhost6
</div><h1>vi</h1><div><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://vim.rtorr.com/lang/ko/">Vim Cheat Sheet »</a><h2>모드</h2><ol><li>처음 vi를 실행하면 normal mode(command mode)</li><p>insert mode와 visual mode에서 esc를 누르면 normal mode로 회귀.</p><li>i를 누르면 insert mode</li><li>v를 누르면 visual mode</li><li>:를 누르고 명령어 실행</li><ul><li>:set nu # 줄 번호 표시</li><li>:syn on, :syn enable # 키워드 및 문맥 강조</li></ul></ol><h2>저장</h2><ol><li>:w</li><li>:w! 덮어쓰기</li><li>:w 파일명 // 새 파일인 경우</li><li>:saveas 파일명</li></ol><h2>종료</h2><ol><li>:q</li><li>:wq : 저장 후 종료</li><li>:q! : 저장하지 않고 종료</li></ol><h2>이동</h2><div><img class="w3-round" src="http://cfile8.uf.tistory.com/image/141F57474F4732890DE706"></div><h2>vim</h2><ol><li>열기</li><ul><li>:edit 파일명</li><li>:tabnew 파일명</li><li>$ vim 파일명1 파일명2 ...</li><p>:n으로 열린 파일 선택. 파일을 탭으로 열고 싶다면 -p 옵션</p></ul><li>복사/붙여넣기</li><ul><li>복사 : Ctrl + Insert</li><li>붙여넣기 : Shift + Insert</li><p>~/.vimrc 에서<br>set mouse=a 로 되어있던게 문제였습니다. set mouse=c 로 변경하니까 vim 에서 텍스트의 복사하기 붙여넣기 잘 되는군요.<br>a 는 마우스를 사용하겠다는 것이고 c 는 마우스를 사용치 않겠다는 것 같은데, c 로 해놔도 마우스로 커서 옮기고 스크롤하는 것 등은 잘 되더군요.. 출처 : https://kldp.org/node/129456</p></ul></ol><h2>지우기</h2><ol><li>n dd : 커서로부터 n 줄 삭제</li><li>n dw : 커서로부터 n 단어 삭제</li><li>gg -> dG : 첫줄로 이동 -> 끝까지 삭제</li></ol></div><details><summary>정리 필요</summary><h2>Quickstart</h2><div><h3>Absolute basics</h3><div><h4>commands</h4><p>ls, cd, passwd, file filename, cat textfile, pwd, exit, logout, man command, info command, whatis command, apropos string, command --help</p><h4>Bash features</h4><p>Ctrl+A : 커서를 맨 앞으로
C : 실행 중인 프로그램 종료
D : 현재 쉘 로그아웃
E : 커서를 맨 끝으로
H : backspace
L : Clear
R : 히스토리 탐색
Z : 실행 중인 프로그램 일시 정지
ArrowLeft, ArrowRight : 커서 이동
ArrowUp, ArrowDown : 히스토리 탐색
Shift+PageUp/PageDown : 터미널 버퍼 이동
Tab : 자동 완성
Tab Tab : 완성 가능 목록</p></div></div><h1><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://tldp.org/HOWTO/HOWTO-INDEX/index.html">Linux HOWTO</a></h1><div><h2><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://tldp.org/HOWTO/HOWTO-INDEX/os.html">The Linux OS</a></h2><div><h3>Getting Started</h3></div></div></details><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-7897366614471210" data-ad-slot="6629226643" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({})</script></div><hr>&copy; 2020. <a href="mailto:hi.donggi@gmail.com">Donggi Kim</a> all rights reserved.<a class="w3-btn w3-round-xxlarge w3-small w3-green" href="/LICENSE">LICENSE</a></div></body></html>