<ul>
    <li>기본 자료형</li>
    1. 네임스페이스 특정 이름만 using으로 포함시킬 수 있다.<br>
    2. short &lt;= int &lt;= long &lt;= long long, unsigned -<br>
    3. float &lt;= double &lt;= long double<br>
    4. char(8bits) &lt; char16_t &lt; char32_t, wchar_t<br>
    5. bool, auto(c#의 var과 유사), decltype(x) : x와 같은 타입
    <button type="button" class="btn btn-primary btn-sm btn-code" path="VS/C++ Basic/Type.cpp" lan="cpp">Type.cpp »</button>

    <li>복합 자료형</li>
    1. enum Name { CONST1, CONST2 = num1, CONST3, ... };<br>
    2. enum class Name { CONST1, ... }; // Type Safe<br>
    » C#과 마찬가지로 enum class는 정수 타입을 상속함으로써 표현된다. enum class Name : long<br>
    3. struct Name { [fields] };<br>
    4. std::array : vector와 달리 크기가 고정되어 오버헤드가 적다.
    <button type="button" class="btn btn-primary btn-sm btn-code" path="VS/C++ Basic/Type.cpp" lan="cpp">Type.cpp »</button>

    <li>변수</li>
    1. new ~ delete는 번거로우므로, unique_ptr이 도입되었다. 변수가 스코프를 벗어나면 자동으로 해제한다.<br>
    2. 물론 정적 할당된 객체는 선언된 영역을 벗어나면 해제된다. 정적 할당된 객체를 전달할 경우 복사생성자가 호출되어 복사본이 전달되며, const를 사용할 경우 참조가 전달된다.<br>
    3. 값에 의한 전달 : 주소값에 의한 전달 : 참조에 의한 전달(변수만 가능)<br>
    4. try ~ (catch) : catch 생략 가능. exception ~ bad_alloc, bad_cast, bad_exception, logic_error, runtime_error 등
    <button type="button" class="btn btn-primary btn-sm btn-code" path="VS/C++ Basic/Exception.cpp" lan="cpp">Exception.cpp »</button>

    <li>클래스</li>
    1. 보통 헤더 파일에 선언, 구현 파일에 정의<br>
    » class Name { Name() 생성자, ~Name() 소멸자 }<br>
    » 명시적 디폴트 생성자 : Name() = default;<br>
    » 유틸리티 클래스 : Name() = delete; // 생성자를 가지지 않는다.<br>
    2. 멤버 초기화는 선언된 순서대로만 진행된다. 소멸시 반대 방향으로 소멸된다.<br>
    3. 접근제한자 : public, protected, private
    <button type="button" class="btn btn-primary btn-sm btn-code" path="VS/C++ Basic/Class.h" lan="cpp">Class.h »</button>
    <button type="button" class="btn btn-primary btn-sm btn-code" path="VS/C++ Basic/Class.cpp" lan="cpp">Class.cpp »</button><br>
    4. 명시적 대입 연산자 : Name&amp; operator=(const Name&amp; rValue) = default | delete<br>
    5. 객체 복제 배제 : 복사생성자와 =연산자를 private으로.<br>
    6. 두 클래스가 서로를 필요로 할 때, 일반적인 #include로는 해결할 수 없어 포워드 선언을 한다.<br>
    7. const 멤버는 const 메서드만 이용할 수 있다.<br>
    8. mutable 멤버의 변경은 메서드의 const 선언을 해치지 않는다고 간주한다.
    <button type="button" class="btn btn-primary btn-sm btn-code" path="VS/C++ Basic/ClassA.h" lan="cpp">ClassA.h »</button>
    <button type="button" class="btn btn-primary btn-sm btn-code" path="VS/C++ Basic/ClassB.h" lan="cpp">ClassB.h »</button><br>
    9. 오버로딩 메서드 시그너쳐에 delete 선언하면 호출할 수 없다.<br>
    10. inline 함수는 호출 지점에 코드 자체가 복사되어 메서드 콜 오버헤드를 줄인다. 클래스 헤더에서 직접 구현하면 inline 키워드 없이도 자동적으로 inline 검사 대상이 된다.<br>
    11. friend : 다른 클래스 또는 메서드에서 모든 멤버/메서드에 접근 허용.<br>
    12. 연산자 오버로딩 : 타입 A를 갖는 생성자가 존재한다면 타입 A의 인스턴스와 직접 연산 가능.<br>
    13. 복합 대입 연산자 오버로딩 : 임시 객체 없이 좌변 객체 변경후 객체 참조 리턴.
    <button type="button" class="btn btn-primary btn-sm btn-code" path="VS/C++ Basic/ClassC.h" lan="cpp">ClassC.h »</button><br>

    <li>상속</li>
    1. class Sub : public Super<br>
    2. virtual이 없는 경우 발생하는 모호함(다형성 미지원)을 해소하기 위해 소멸자까지 기본적으로 virtual로 선언한다.<br>
    3. 재정의, 확장 방지 : final<br>
    » "class Name final", "type method(param) final"<br>
    4. 다중 상속 가능. 부모 메서드를 호출하기 위해 단일 키워드 대신 명시적으로 부모 이름을 이용.<br>
    5. 공변 리턴 : 메서드 리턴 타입이 클래스에 대한 포인터나 참조면 오버라이딩하면서 그 자식 타입의 것으로 변경 가능.<br>
    6. static method는 재정의될 수(virtual할 수) 없다.<br>
    7. method를 재정의하면 부모의 모든 오버로딩된 메서드들이 가려진다. 하지만 포인터를 통해(업캐스팅) 호출할 수는 있다.<br>
    8. Java와 달리 private method도 재정의할 수 있다. C++에서 접근 제한자는 호출자만을 제한한다. 접근 범위를 강화할수도 있다.
    <button type="button" class="btn btn-primary btn-sm btn-code" path="VS/C++ Basic/SuperClass.h" lan="cpp">SuperClass.h »</button>
    <button type="button" class="btn btn-primary btn-sm btn-code" path="VS/C++ Basic/SubClass.h" lan="cpp">SubClass.h »</button><br>

    <li>참조 타입</li>
    1. 참조 타입 변수는 생성과 동시에 초기화되어야만 한다.<br>
    2. 참조 타입 변수의 참조 대상은 불변하다. 역참조가 허용되지 않아 안전하다.<br>
    3. int*&amp; ref : 포인터에 대한 참조 타입 변수. cf. 참조에 대한 참조, 참조에 대한 포인터는 불가능.<br>
    4. 참조 대상을 변경해야 하는 경우, 메모리 해제가 필요한 경우만 포인터 이용.<br>
    5. &amp;&amp; : rvalue 참조. 금방 해제될 객체, 지역 변수, 상수 참조 가능.
    » std::move() : lvalue를 rvalue로 변환<br>
    6. move constructor, move assignment operator : rvalue 참조 매개변수로 받은 객체로부터 값을 복사한 후 원본을 null로 변경하여 메모리 소유권 이동.(복사보다 이동이 좋다.)

    <li>const</li>
    1. const 키워드는 왼쪽에 적용된다. 단, 맨 처음 등장하는 "type const"는 "const type"과 같다.<br>
    » const int * : const int를 가리키는 포인터, int * const : int 포인터 변수 고정<br>
    » const int * const * const * const ip = nullptr;<br>
    2. const method는 mutable 멤버 외의 멤버를 변경할 수 없다.<br>
    3. constexpr : 상수표현식으로 사용 가능.<br>
    » constexpr constructor : 사용자 정의 객체를 상수 표현 변수로 이용 가능.<br>
    » constexpr를 이용한 함수/메서드/생성자는 매개변수로 상수만 받을 수 있어야 하며, 호출 전에 컴파일러에 의해 body가 해석되어야 한다.
    <button type="button" onclick="javascript:showCode('Concepts/constexpr.cpp', 'cpp');" class="btn btn-primary btn-sm">
        View Code : constexpr »
    </button>

    <li>static</li>
    1. static 멤버는 객체 유무와 무관하게 클래스 자체에 속한다.<br>
    2. static linking : 같은 소스에서의 함수/변수 참조<br>
    » static void func();는 외부에서 참조 불가.<br>
    » static 의미 자체와 연관이 없어 anonymous namespace 도입 : namespace { void func(); }<br>
    3. extern : external link 명시<br>
    4. 함수 내 static 변수 : 해당 함수에서만 이용가능한 전역 변수와 같다.

    <li>형 변환</li>
    1. "typedef int INT32" == "using INT32 = int"
    <br>"typedef int (*FuncType)(int, int)" == "using FuncType = int (*)(int, int)"
    <br>
    <br>2. const_cast : const 변수의 상수 속성을 제거. const_cast&lt;int*&gt;(p)
    <br>static_cast : 언어 자체에서 허용하는 변환을 명시적으로 수행, 생성자나 변환 연산자가 구현되어 있을 때 명시적으로 변환, 같은 클래스 계층의 두 클래스 간
    변환
    <br>dynamic_cast : 같은 클래스 계층의 두 클래스 간 변환(타입 검사 수행)
    <br>
    <br>3. 명시적 형 변환 : explicit
    <button type="button" onclick="javascript:showCode('Concepts/explicit.cpp', 'cpp');" class="btn btn-primary btn-sm">
        View Code : explicit »
    </button>

    <li>초기화</li>
    1. 클래스에서도 {}로 초기화 가능. public Name(int, int);
    <br>» Name n(1, 2) -&gt; Name n = {1, 2} 가능, Name n{1, 2} 가능
    <br>» vector&lt;string&gt; names = {"name1", "name2", "name3"}
    <br>
    <br>2. initializer list를 이용한 단일 타입 가변 길이 매개변수 함수 작성 가능.
    <button type="button" onclick="javascript:showCode('Concepts/initializer_list.cpp', 'cpp');" class="btn btn-primary btn-sm">
        View Code : initializer_list »
    </button>
</ul>