<ul>
    백그라운드 쓰레드에서 미래에 실행될 작업들을 스케쥴링하는 기능을 제공한다. 작업은 일회용일수도, 일정한 주기를 가지고 반복될 수도 있다. 한 타이머의 모든 작업들은 하나의 백그라운드 쓰레드를 공유하기 때문에, 작업의 실행은 직렬적이며, 따라서 각 작업들은 가능한 한 빠르게 종료되어야 한다. 그렇지 않은 경우, 뒤에 대기하는 모든 작업이 밀려 제대로 실행되지 않을 수 있다.<br>
    기본적으로 타이머의 백그라운드 쓰레드는 데몬 쓰레드가 아니다. 따라서 타이머의 작업이 전체 프로그램의 종료를 지연시킬 수 있다. 백그라운드 쓰레드는 타이머 임의의 생성자에 의해 시작된다.<br>
    * 이 클래스는 쓰레드-안전하다.<br>
    * 이 클래스는 정시성을 보장하지 않는다. 스케쥴은 Object.wait(long) 메서드를 통해 이루어진다.<br>
    java.util.concurrent 패키지의 ScheduledThreadPoolExecutor가 더 나은 대안으로 이용될 수 있다.
    <li>public Timer()</li>
    <li>public Timer(boolean isDaemon)</li>
    기본적으로 백그라운드 쓰레드는 데몬으로 실행되지 않지만, 이를 변경할 수 있다.
    <li>public Timer(String name) Since 1.5</li>
    <li>public Timer(String name, boolean isDaemon) Since 1.5</li>
    <li>void schedule(TimerTask task, long delay)</li>
    delay밀리초 이후 task가 실행되도록 스케쥴.
    <li>void schedule(TimerTask task, Date time)</li>
    time에 task가 실행되도록 스케쥴. time이 과거라면 즉시 실행
    <li>void schedule(TimerTask task, long delay, long period)</li>
    delay밀리초 이후 period 주기를 갖고 task가 실행되도록 스케쥴.
    <li>void schedule(TimerTask task, Date firstTime, long period)</li>
    <li>void scheduleAtFixedRate(TimerTask task, long delay, long period)</li>
    period가 이전 task 종료가 아닌 최초 실행 시점을 기준으로 작동한다. 따라서 어떤 이유로 이전 작업이 지연된 경우, 시간당 작업률을 맞추기 위해 이후 작업이 연속적으로 실행될 수 있다.
    <li>void scheduleAtFixedRate(TimerTask task, Date firstTime, long period)</li>
    <li>void cancel()</li>
    타이머를 종료한다. 스케쥴된 모든 작업을 버리고, 현재 실행중인 작업에는 간섭하지 않는다. 타이머 종료 후 백그라운드 쓰레드도 우아하게 종료되어 GC 대상이 된다. 이후 더 이상의 스케쥴은 불가능하다.
    <li>int purge() Since 1.5</li>
    호출할 일이 거의 없는 메서드. 많은 작업을 한번에 취소한 경우, 취소한 작업들을 제거하여 참조가 없는 경우 GC 대상이 되도록 한다.
</ul>