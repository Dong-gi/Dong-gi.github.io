<!DOCTYPE html><html lang="ko-KR"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Mathematics for Computer Science</title><link rel="stylesheet" href="/source/default.css"><meta name="google-site-verification" content="aH-DyzdytYQ0NPHNQFcs5dVoiu5YNs6CEEHYgqDmAFM"><meta name="author" content="Donggi Kim &lt;hi.donggi@gmail.com&gt;"><meta name="description" content="MIT 공개 강의 &gt; 컴퓨터공학도를 위한 수학 정리"><link rel="icon" href="/imgs/favicon.png"><script id="google-analytics" src="https://www.googletagmanager.com/gtag/js?id=UA-143098403-1" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-143098403-1');</script><script id="MathJax-script" src="/source/tex-chtml.js" defer></script><script>MathJax={tex:{tags:'ams',inlineMath:[['식[', ']식']]}};</script><script id="highlight-js" src="/source/highlight.pack.js" defer></script><script id="default-js" src="/source/default.min.js" defer></script></head><body><aside class="w3-animate-left" id="sidebar"><hr><div id="marker-list"></div><hr><div id="post-list"></div><hr><details class="w3-small file-list"><summary>LICENSE</summary><table class="w3-table-all w3-card w3-small"><tr><td>Author</td><td>License</td></tr><tr><td>&copy; <a href="mailto:hi.donggi@gmail.com">Donggi Kim</a></td><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/Dong-gi/Dong-gi.github.io/blob/master/LICENSE">MIT</a></td></tr><tr><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://www.w3schools.com/w3css">w3css</a></td><td>No license</td></tr><tr><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://highlightjs.org/">highlight.js</a></td><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/highlightjs/highlight.js/blob/main/LICENSE">BSD-3-Clause</a></td></tr><tr><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/mathjax/MathJax">MathJax</a></td><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/mathjax/MathJax/blob/master/LICENSE">Apache-2.0</a></td></tr><tr><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/davidshimjs/qrcodejs">QRCode.js</a></td><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/davidshimjs/qrcodejs/blob/master/LICENSE">MIT</a></td></tr><tr><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/terrastruct/d2">D2</a></td><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/terrastruct/d2/blob/master/LICENSE.txt">MPL-2.0</a></td></tr></table></details><hr></aside><main id="main"><nav class="w3-bar w3-blue" id="nav"><button class="w3-bar-item w3-button w3-hover-theme" id="nav-toggle-btn">&#9776;</button><form role="search"><input class="w3-bar-item" id="query" type="search" placeholder="search" style="max-width:35%"></form><a class="w3-bar-item w3-button w3-hover-theme" href="/">Home</a></nav><article id="contents"><p class="fake-h1">0.<a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://dong-gi.github.io/files/mcs.pdf">도서</a>정보</p><div class="w3-row"><div class="w3-col s2 w3-center"><figure class="w3-center w3-margin-bottom"><img class="w3-round" src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQew5ZrEOtvLqafGH3aEaTctFKCSV4qjsRoZS4tT7Ci_lJXjSIV" alt="Can't load image" loading="lazy" style="max-height:210px;"/><figcaption>&lt;도서></figcaption></figure></div><div class="w3-col s10"><table class="w3-table-all w3-card w3-small"><tr><td>표제/저자사항</td><td>Mathematics for Computer Science / Eric Lehman, F Thomson Leighton, Albert R Meyer</td></tr><tr><td>ISBN 정보</td><td>979-11-88621-12-5 [93000]</td></tr><tr><td>Copyright</td><td>2017, Eric Lehman, F Tom Leighton,<a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="http://people.csail.mit.edu/meyer">Albert R Meyer</a>. This work is available under the terms of the<a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-ShareAlike 3.0 license.</a></td></tr></table></div></div><p class="fake-h1">I. Proofs</p><hr><div><p class="fake-h2">Introduction</p><span class="pos-span" id="pos1647752"></span><p>간단히 말해 증명은 참을 수립하는 과정이다. "참"은 보는 사람, 분야에 따라 다르기 때문에 수학적 증명 역시 자기만의 정의를 갖는다.</p><p><b>정의.</b> 명제(proposition)에 대한 수학적 증명이란, 기본 공리(axiom)들과 이미 증명된 다른 명제들로부터 결론에 도달하는 일련의 논리적 연역(deduction)이다</p><ul><li>귀납(Induction) : 관찰된 사실들로부터 결론을 도출하는 과정</li><p>e.g. 모든 백조는 하얗다</p><li>연역(Deduction) : 참인 전제들로부터 결론을 도출하는 과정</li><p>참고. 수학적 귀납법은 연역논증이다</p></ul><span class="pos-span" id="pos49"></span><h2>What is a Proof?</h2><div><span class="pos-span" id="pos48564"></span><h3>Propositions</h3><p><b>정의.</b> 명제(proposition)란 참 또는 거짓인 문장이다</p><p>예를 들어, 다음 2개 문장은 모두 명제다. 첫 번째는 참이고, 두 번째는 거짓이다.</p><span class="pos-span" id="pos1936905038"></span><p><b>명제 1.1.1.</b> 2 + 3 = 5</p><span class="pos-span" id="pos1936905039"></span><p><b>명제 1.1.2.</b> 1 + 1 = 3</p><p>참/거짓이 되는 문장에는 제한이 없을 것 같지만, 실제로는 "미술관은 어디로 가면 되나요?", "A학점 주세요!"와 같은 문장들과, 진리값이 상황에 따라 변하는 "지금은 5시야", "내일 증시는 상승 마감할 거야" 같은 문장들은 명제가 될 수 없다.</p><p>불행히도 명제의 참과 거짓을 밝히는 일이 항상 쉽지만은 않다.</p><span class="pos-span" id="pos1988974018"></span><p><b>주장 1.1.3.</b> 음이 아닌 모든 정수 n에 대하여, n^2 + n + 41은 소수(prime)다.</p><p>이 명제를 실험해보자. Let\[p(n) ::= n^2 + n + 41\]
p(0) = 41부터 시작하여, p(1) = 43, ..., p(39) = 1601까지 모두 소수임을 확인할 수 있다. 그러나 p(40) = 41 * 41은 소수가 아니다. 따라서<a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos1988974018" target="_self">주장 1.1.3</a>은 거짓이다. 사실 음이 아닌 모든 정수를 소수로 매핑하는 다항식(상수식 제외)은 존재할 수 없지만, 여기서 말하고자 하는 바는 무한 집합을 대상으로 하는 명제를 유한한 표본들─개수가 많더라도─만으로 검증하기는 일반적으로 요원하다는 점이다.</p><p>위처럼 모든 숫자 또는 특정한 종류의 모든 항목에 대한 명제는 매우 흔하며, 이를 위한 특별한 표기도 존재한다. 이를 이용하면<a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos1988974018" target="_self">주장 1.1.3</a>은 아래와 같이 표기할 수 있다.
\[\forall n \in \mathbb{N}.\quad\text{p(n) is prime.}\]
여기서 기호 식[\forall]식은 "for all"라고 읽고, 식[\mathbb{N}]식은 음이 아닌 정수 집합을 의미한다.</p><p><b>추측 (오일러 추측).</b> 방정식 식[a^4+b^4+c^4=d^4]식을 만족하는 양의 정수 a, b, c, d는 존재하지 않는다</p><p>이를 아래와 같이 표현할 수 있다\[\forall a, b, c, d \in \mathbb{Z}^{+}.\quad a^4+b^4+c^4 \ne d^4.\]
한편 이 명제는 거짓으로 판명되었다. a = 95800, b = 217519, c = 414560, d = 422481</p><span class="pos-span" id="pos1936905041"></span><p><b>명제 1.1.4 (Four Color Theorem).</b> 모든 평면 지도는 4가지 색으로 모든 인접한 두 지역의 색이 서로 다르도록 칠할 수 있다.</p><p>이 명제가 참이라는 것을 증명하는 데 컴퓨터가 사용되었다. 증명해야 하는 데이터 셋이 크다면 컴퓨터의 사용은 필수불가결한데, 컴퓨터의 계산에 오차가 존재하지 않는다고 보장할 수 있는 사람은 존재하지 않는다. 그렇다고 방대한 데이터를 일일이 검산할 사람 역시 존재하지 않는다.</p><span class="pos-span" id="pos1936905042"></span><p><b>명제 1.1.5 (Fermat's Last Theorem).</b> 식[n \in \mathbb{N}.\quad n > 2.\quad x^n + y^n = z^n]식을 만족하는 양의 정수 x, y, z는 존재하지 않는다.</p><p>페르마는 이 명제를 적으면서 여백이 부족해 증명을 적지 않았다고 한다. 1994년 영국의 수학자 Andrew Wiles가 명제가 참임을 증명했고, 이 증명은 여백에 적을만한 분량은 아니었다.</p><p>마지막으로 간결하지만, 아직 증명되지 않은 명제를 살펴보자.</p><span class="pos-span" id="pos-1378111575"></span><p><b>추측 1.1.6 (Goldbach).</b> 2보다 큰 모든 짝수는 2개의 소수의 합으로 표현할 수 있다.</p><p>골드바흐의 추측은 10^18까지 참임이 알려져 있지만, 전체가 참인지는 아직 증명되지 않았다.</p><span class="pos-span" id="pos48565"></span><h3>Predicates</h3><span class="pos-span" id="pos655935895"></span><p><b>정의.</b> Predicate ::= 변수에 의해 진리값이 결정되는 문제</p><p>일반적인 수학 함수와 다르게, 출력은 항상 true 또는 false다.</p><p>예. P(n) ::= "n은 완전제곱수다"</p><span class="pos-span" id="pos48566"></span><h3>The Axiomatic Method</h3><p>표준 증명 절차는 유클리드가 기원전에 발명했다. 그는 부정할 수 없는 5가지 기하학에 관한 추측을 기반으로 증명했는데, 예컨데 "임의의 2개의 점 사이에는 1개의 직선이 존재한다"가 그 중 하나다. 이처럼 자명하게 참인 명제를 공리(axiom)라 한다.<a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos1647752" target="_self">증명</a>에 사용되는 이미 증명된 명제들은 그 역할과 비중에 따라 몇 가지 용어들로 참조된다.</p><ul><li>정리(Theorem) ::= 중요한 참 명제</li><li>보조정리(Lemma) ::= 이후 명제를 증명하는 데 필요한 예비 명제</li><li>따름정리(Corollary) ::= 정리로부터 쉽게 도출되는 명제</li></ul><p>위 용어들을 엄격하게 구별하여 사용할 필요는 없다.</p><span class="pos-span" id="pos48567"></span><h3>Our Axioms</h3><div><p><b>정의.</b> Implication ::= "If P, then Q."처럼 조건을 갖는 명제</p><p>종종 식[P\text{ IMPLIES }Q]식 또는 식[P \longrightarrow Q]식로 표현한다</p><p>증명을 간결하게 하기 위해 여기서는 중등 수학의 공리(Axiom)들을 증명없이 이용한다</p><span class="pos-span" id="pos46674362"></span><h4 class="fake">Logical Deductions</h4><p>논리적 연역(logical deduction) 또는 추론 규칙(inference rule)은 이미 증명된 명제들로부터 새로운 명제를 증명하는 데 이용된다.</p><p>기초가 되는 규칙은 <i>긍정 논법(modus ponens)</i>으로, P와 P IMPLIES Q가 참이라면 Q도 참이라는 규칙이다. 긍정 논법은 아래와 같이 표현할 수 있다.</p><p><b>규칙.</b> \[{P, P \implies Q \over Q}\]</p><p>이 표기법은 선분 위의 문장들(antecedents)이 참으로 증명되면, 선분 아래 문장(conclusion, consequent) 역시 참으로 간주할 수 있음을 나타낸다. 이외에도 자연스럽고 간결한 추론 규칙들이 존재한다.</p><p><b>규칙.</b> \[{P \implies Q, Q \implies R \over P \implies R}\]</p><p><b>규칙.</b> \[{\operatorname{NOT}(Q) \implies \operatorname{NOT}(P) \over P \implies Q}\]</p></div><span class="pos-span" id="pos48568"></span><h3>Proving an Implication</h3><div><h4 class="fake">Method #1</h4><ol><li>다음과 같이 쓴다. "P가 참이라고 가정한다"</li><li>Q가 논리적으로 도출됨을 보인다</li></ol><p class="fake-h4">Example</p><span class="pos-span" id="pos-1788086190"></span><p><b>정리 1.5.1.</b> If 0&lt;=x&lt;=2, then 식[-x^3 + 4x + 1 \gt 0]식.</p><p>증명을 써내려가기에 앞서, 왜 이것이 참인지 구상해야 한다. 왼쪽 부등식은 x=0인 경우를 포함하며, 이 때 오른쪽 부등식은 1 > 0으로 참이다. 다음으로, 0 &lt; x &lt;=2의 구간에서, 4x는 식[-x^3]식보다 지배적(식[-x^3+4x \ge 0]식)이다. 따라서 [0, 2] 전체 구간에서 오른쪽 부등식은 참일 것 같다.</p><p>여기서 "참일 것 같다"는 부분을 논리적으로 견고한 표현으로 바꾸어야 하는데, 인수분해가 이를 도와준다\[-x^3 + 4x + 1 = x(2 - x)(2 + x) + \gt 0\]</p><p><i>증명.</i> 0&lt;=x&lt;=2가 참이라고 가정하자.<br>그러면 x, 2-x, 2+x 모두 음이 아니며, 따라서 이들의 곱도 음이 아니다.
<br>이에 1을 더하면 양수임이 명백하며, 따라서 명제는 참이다.</p><p class="w3-right-align">■</p><h4 class="fake">Method #2 - 대우 증명</h4><ol><li>다음과 같이 쓴다. "대우명제를 통해 증명한다"</li><li>식[{\operatorname{NOT}(Q) \implies \operatorname{NOT}(P)}]식을 Method #1으로 증명한다</li></ol><p class="fake-h4">Example</p><span class="pos-span" id="pos-1788086189"></span><p><b>정리 1.5.2.</b> r이 무리수면, 식[\sqrt{r}]식도 무리수다.</p><p><i>증명.</i> 대우명제를 통해 증명한다: 식[\sqrt{r}]식이 유리수면, r도 유리수다.<br>식[\sqrt{r}]식이 유리수라고 가정하자. 그러면 식[\sqrt{r}]식 = m / n을 만족하는 두 정수 m, n이 존재한다.
<br>이때 양변을 제곱하면: r = m^2 / n^2
<br>m과 n이 모두 정수이므로 m^2, n^2도 모두 정수이며, 따라서 r도 유리수다.</p><p class="w3-right-align">■</p></div><span class="pos-span" id="pos48569"></span><h3>Proving an "If and Only If"</h3><div><h4 class="fake">Method #1</h4><ol><li>다음과 같이 쓴다. "식[P \implies Q]식과 그 역을 증명한다."</li><li>다음과 같이 쓴다. "먼저 식[P \implies Q]식를 증명한다". 이후<a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos48568" target="_self">1.5</a>대로 증명</li><li>다음과 같이 쓴다. "다음으로 식[Q \implies P]식를 증명한다". 이후<a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos48568" target="_self">1.5</a>대로 증명</li></ol><h4 class="fake">Method #2 : Iff 체인</h4><ol><li>다음과 같이 쓴다. "If-and-only-if 조건 명제의 체인을 만든다."</li><li>어떠한 식(들)이 P와 동치임을 보이고, 다시 Q와도 동치임을 보인다</li></ol><p class="fake-h4">Example</p><p>표본 x1, ..., xn에 대한 표준편차는 다음과 같이 정의된다: \[\sqrt{(x_1 - \mu)^2 + \cdots + (x_n - \mu)^2 \over n} \tag*{(1.3)}\]</p><span class="pos-span" id="pos-1788085229"></span><p><b>정리 1.6.1.</b> 표본 x1, ..., xn에 대한 표준편차는 0이다 iff 모든 표본이 평균과 같다</p><p><i>증명.</i> "iff" 조건 명제의 체인을 만든다. 표준 편차 (1.3)가 0인 조건식으로부터 시작한다.\[\sqrt{(x_1 - \mu)^2 + \cdots + (x_n - \mu)^2 \over n} = 0 \tag*{(1.4)}\]
오직 0만 제곱근이 0이므로, (1.4) iff
\[(x_1 - \mu)^2 + \cdots + (x_n - \mu)^2 = 0 \tag*{(1.5)}\]
실수의 제곱은 항상 음이 아니므로, (1.5) 좌변의 모든 항도 음이 아니다. 따라서 (1.5) iff
\[\text{(1.5) 좌변의 모든 항 }(x_i - \mu)^2 \text{은 0이다.} \tag*{(1.6)}\]
이때, 식[(x_i-\mu)^2 = 0 \iff x_i = \mu]식이므로, (1.6)가 참이다 iff
\[\text{모든 } x_i = \mu\]</p><p class="w3-right-align">■</p></div><span class="pos-span" id="pos48570"></span><h3>Proof by Cases</h3><p>명제가 가능한 모든 경우의 수에 대해 성립함을 보일 수 있다면 참임을, 단 하나의 경우라도 거짓임을 보인다면 거짓임을 증명할 수 있다</p><span class="pos-span" id="pos48571"></span><h3>Proof by Contradiction</h3><p>간접 증명(indirect proof)이라고도 한다.</p><ol><li>다음과 같이 쓴다. "모순(Contradiction)을 통해 증명한다."</li><li>다음과 같이 쓴다. "P가 거짓이라고 가정한다"</li><li>논리적으로 모순임(거짓임이 알려진 명제가 참이 됨)을 보인다</li><li>다음과 같이 쓴다. "이는 모순이며, 따라서 P는 참이다"</li></ol><div><p class="fake-h4">Example</p><span class="pos-span" id="pos-1788083307"></span><p><b>정리 1.8.1.</b> 식[\sqrt{2}]식는 무리수다</p><p><i>증명.</i> 모순을 통해 증명한다. 명제가 거짓이라 가정하자. 식[\sqrt{2}]식가 유리수라면, 이를 표현할 수 있는 기약분수 식[n / d]식이 존재해야 한다(식[\sqrt{2}=1.4\cdots]식가 정수가 아님은 자명하다)<br>양변을 제곱하면 식[2 = n^2 / d^2]식이 성립하며, 따라서 식[2d^2 = n^2]식이다. 이는 n이 2의 배수여야 함을 의미하며, 또다시 식[2d^2]식는 4의 배수여야 함을 의미한다
<br>결국 n과 d모두 2의 배수여야 하지만, 이는 식[n / d]식이 기약분수라는 것에 위배된다. 이는 모순이며, 따라서 식[\sqrt{2}]식는 무리수다</p><p class="w3-right-align">■</p></div><span class="pos-span" id="pos48572"></span><h3>Good Proofs in Practice</h3><p>증명은 계산이 아니라 에세이다</p><h3>Problems</h3><div><h4 class="fake">문제 1.1.</h4><p>Albert는 그의 강의에서 다음 주에 서프라이즈 퀴즈를 치를 것을 예고했다.<br>학생들은 먼저 다음 주 금요일에 퀴즈가 있을 지 생각해봤다. 그리고 그럴 수 없다고 추론했다: 만약 금요일 전까지 서프라이즈 퀴즈가 없었다면, 퀴즈는 당연히 금요일에 치뤄질 것이고, 이는 더 이상 서프라이즈가 아니기 때문이다.
<br>다음으로 학생들은 퀴즈가 목요일에 있을 지 생각해봤다. 목요일 전까지 퀴즈가 없었다면, 금요일은 퀴즈가 없을 것이므로 당연히 목요일에 퀴즈를 치룰 것이고, 이 또한 이제 서프라이즈가 아니다. 마찬가지로 학생들은 수요일, 화요일, 월요일도 서프라이즈가 될 수 없음을 추론했고, 따라서 다음 주에 서프라이즈 퀴즈를 치루는 것은 불가능하다는 결론에 이르렀다. 즉 Albert는 허풍으로 퀴즈를 예고한 것이다.
<br>학생들의 추론에 문제가 존재하는가?</p><p>→ '다음 주 금요일이 시험날이 될 수 없다'는 중간 결론은 '금요일 전까지 시험을 내지 않았다'는 가정이 참일 때만 유효하며, 해당 가정의 진리값은 실제로 다음 주 금요일 자정을 넘기지 않는 이상 알 수 없으므로, 적절한 수학적 명제로 볼 수 없다. 또한 부적절한 추론 결과인 '다음 주 금요일이 시험날이 아니다'를 이용한 이후의 모든 추론 역시 적절하지 않다.</p><h4 class="fake">문제 1.3.</h4><p>What's going on here? \[1=\sqrt{1}=\sqrt{(-1)(-1)}=\sqrt{-1}\sqrt{-1}=\left(\sqrt{-1}\right)^2=-1\]</p><p><b>(a)</b> Precisely identify and explain the mistake(s) in this <i>bogus</i> proof.</p><p>식[\sqrt{ab} = \sqrt{a}\sqrt{b}]식는 식[a,b\in \mathbb{R}^{0+}]식인 경우만 성립한다. 따라서 식[\sqrt{(-1)(-1)}=\sqrt{-1}\sqrt{-1}]식 이후의 추론은 모두 잘못됐다</p><p><b>(b)</b> Prove (correctly) that if 1 = -1, then 2 = 1.</p><p>1 = -1 양변에 1을 더하면 2 = 0. 다시 양변을 2로 나누면 1 = 0. 따라서 2 = 0 = 1이 성립한다</p><p><b>(c)</b> 모든 양의 실수 r은 양과 음의 2가지 제곱근을 가진다. 실수의 곱셈에 관한 성질을 이용해 양의 실수 r, s에 대하여 다음이 성립함을 보여라. \[\sqrt{rs}=\sqrt{r}\sqrt{s}\]</p><p>주어진 식의 우변을 제곱하면 식[\sqrt{r}\sqrt{s}\sqrt{r}\sqrt{s}]식이다. 곱셈에 관한 교환법칙에 의해 식[\sqrt{r}\sqrt{s}\sqrt{r}\sqrt{s}=\sqrt{r}\sqrt{r}\sqrt{s}\sqrt{s}]식이고, 곱셈에 관한 결합법칙에 의해 식[\sqrt{r}\sqrt{r}\sqrt{s}\sqrt{s}=(\sqrt{r}\sqrt{r})(\sqrt{s}\sqrt{s})=rs]식이다. 양변에서 양의 제곱근을 취하면, 곱셈에 관한 결합법칙에 의해 식[\sqrt{\sqrt{r}\sqrt{s}\sqrt{r}\sqrt{s}} = \sqrt{(\sqrt{r}\sqrt{s})(\sqrt{r}\sqrt{s})} = \sqrt{r}\sqrt{s} = \sqrt{rs}]식임을 알 수 있다.</p><h4 class="fake">문제 1.4.</h4><p>Identify exactly where the bugs are in each of the following bogus proofs.</p><p><b>(b)</b> <i>Bogus proof</i> : 식[1¢ = $0.01 = ($0.1)^2 = (10¢)^2 = 100¢ = $1]식 ■</p><p>식[$0.01 = $(0.1)^2]식, 식[$^2(0.1)^2=($0.1)^2]식 각각은 성립하지만 식[$ \ne 1, $ \ne 0]식이므로 식[$(0.1)^2 = $^2(0.1)^2]식은 성립하지 않는다</p><h4 class="fake">문제 1.5.</h4><p>음이 아닌 임의의 두 실수 a, b에 대한 산술 평균은 기하 평균 이상이다. \[{a+b \over 2} \ge \sqrt{ab}\] 다음 증명 과정 중의 문제점을 찾고, 바르게 고치시오</p><p><i>Bogus proof.</i>\begin{align*}
  {a+b \over 2} \ge & \sqrt{ab}, && so \\
  a+b \ge & 2\sqrt{ab}, && so \\
  a^2+2ab+b^2 \ge & 4ab, && so \\
  a^2-2ab+b^2 \ge & 0, && so \\
  (a-b)^2 \ge & 0 && \text{which we know is true.}
\end{align*}
a - b가 실수고, 실수의 거듭제곱은 음이 아니므로 마지막 문장은 참이다. 따라서 명제는 참이다.</p><p class="w3-right-align">■</p><p>→ 증명해야 하는 명제를 가정에서 참으로 이용하고 있으므로 시작부터 잘못된 증명이다. 또, 증명 순서가 반대로 됐다</p><h4 class="fake">문제 1.7.</h4><p>양의 정수 n에 대하여, 식[\operatorname{log}_{7}n]식이 항상 정수 또는 무리수임을 증명하시오. 익숙한 수학적 사실들을 이용하되, 증명에 명시할 것.</p><p>→ 모순을 통해 증명한다. 식[\operatorname{log}_{7}n]식이 정수가 아닌 유리수라면, 이를 표현할 수 있는 기약분수 식[{a \over b}]식가 존재해야 한다<br>\[\operatorname{log}_{7}n = {a \over b} \iff n = 7^{a \over b} \iff n^b=7^a\]
<br>따라서 n은 7의 배수여야 한다. n을 소인수분해하면 식[n=2^{x_1} \cdot 3^{x_2} \cdot 5^{x_3} \cdot 7^{x_4} \cdots prime_k^{x_k} = 7^a]식
<br>이때, 우변의 식[7^a]식은 7외의 소수로 나눌 수 없으므로 식[n=2^{0} \cdot 3^{0} \cdot 5^{0} \cdot 7^{x_4} \cdots prime_k^{0} = 7^{x_4}]식
<br>따라서 식[n^b = 7^{x_4 b} = 7^a]식이며, 식[x_4 b = a \iff {a \over b} = x_4]식이다. 하지만 이는 식[a \over b]식가 기약분수라는 가정에 위배된다
<br>이는 모순이며, 따라서 식[\operatorname{log}_{7}n]식은 정수거나 무리수다</p><p class="w3-right-align">■</p><h4 class="fake">문제 1.9.</h4><p>무리수를 무리수의 지수로 올렸을 때, 결과가 유리수가 될 수 있을까? 식[\sqrt{2}^{\sqrt{2}}]식를 고려하여 가능함을 보여라.</p><p>→ case 1. 식[\sqrt{2}^{\sqrt{2}}]식가 유리수인 경우, 명제가 참이 되는 경우가 존재함을 알 수 있다<br>case 2. 식[\sqrt{2}^{\sqrt{2}}]식가 무리수인 경우, 식[\left(\sqrt{2}^{\sqrt{2}}\right)^\sqrt{2} = \sqrt{2}^{\sqrt{2}\sqrt{2}} = \sqrt{2}^2 = 2]식이므로 명제가 참이 되는 경우가 존재함을 알 수 있다.</p><h4 class="fake">문제 1.12.</h4><p>식[a^{\sqrt{3}}]식이 유리수인 무리수 a가 존재함을 보여라. 식[\sqrt[3]{2}^{\sqrt{3}}]식을 고려하여 가능함을 보여라.</p><p>→ case 1. 식[\sqrt[3]{2}^{\sqrt{3}}]식이 유리수인 경우, 명제가 참이 되는 경우가 존재함을 알 수 있다.<br>case 2. 식[\sqrt[3]{2}^{\sqrt{3}}]식이 무리수인 경우, 식[\left(\sqrt[3]{2}^{\sqrt{3}}\right)^\sqrt{3} = \sqrt[3]{2}^{\sqrt{3}\sqrt{3}} = \sqrt[3]{2}^3 = 2]식이므로 명제가 참이 되는 경우가 존재함을 알 수 있다.</p><h4 class="fake">문제 1.16.</h4><p>서로 다른 자연수 m, n에 대하여, n^2은 m의 배수이지만, n은 m의 배수가 아닌 경우를 제시하라. m이 n보다 작은 경우도 존재할 수 있을까?</p><p>→ m = 4, n = 6</p><span class="pos-span" id="pos367342671"></span><h4 class="fake">문제 1.17.</h4><p><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos-1788083307" target="_self">정리 1.8.1</a>을 얼마나 일반화할 수 있을까? 예를 들어, 식[\sqrt{3}]식은 어떠한가?</p><p><i>증명.</i> 모순을 통해 증명한다. 식[\sqrt{3}]식이 유리수라면, 이를 표현할 수 있는 기약분수 식[n / d]식이 존재해야 한다(식[\sqrt{3}=1.7\cdots]식이 정수가 아님은 자명하다)<br>양변을 제곱하면 식[3 = n^2 / d^2]식이 성립하며, 따라서 식[3d^2 = n^2]식이다. 이는 n이 3의 배수여야 함을 의미하며, 또다시 식[3d^2]식는 9의 배수여야 함을 의미한다
<br>결국 n과 d모두 3의 배수여야 하지만, 이는 식[n / d]식이 기약분수라는 것에 위배된다. 이는 모순이며, 따라서 식[\sqrt{3}]식은 무리수다</p><p class="w3-right-align">■</p><h4 class="fake">문제 1.19.</h4><p>모순을 이용해 식[\sqrt{3}+\sqrt{2}]식가 무리수임을 증명하라. <i>Hint</i> : 식[(\sqrt{3}+\sqrt{2})(\sqrt{3}-\sqrt{2})]식</p><p><i>증명.</i> 모순을 통해 증명한다. 식[\sqrt{3}+\sqrt{2}]식가 유리수라면, 이를 표현할 수 있는 기약분수 식[n / d]식이 존재해야 한다(식[\sqrt{3}+\sqrt{2}=3.14\cdots]식이 정수가 아님은 자명하다)<br>이때, 식[(\sqrt{3}+\sqrt{2})(\sqrt{3}-\sqrt{2})=1]식이므로, 식[\sqrt{3}-\sqrt{2}=d/n]식이다
<br>따라서 식[(\sqrt{3}+\sqrt{2})+(\sqrt{3}-\sqrt{2})=2\sqrt{3}=n / d + d / n]식이며, 이는 식[\sqrt{3}]식이 유리수임을 의미한다
<br>그러나<a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos367342671" target="_self">문제 1.17.</a>에서 증명하였듯 이는 식[\sqrt{3}]식이 무리수라는 것에 위배된다. 이는 모순이며, 따라서 식[\sqrt{3}+\sqrt{2}]식는 무리수다</p><p class="w3-right-align">■</p><h4 class="fake">문제 1.20.</h4><p>여기에서<a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos367342671" target="_self">문제 1.17.</a>의 일반화를 보인다.</p><p><b>보조정리.</b> 모든 계수가 정수인 다항식 \[a_0+a_1x+a_2x^2+\cdots+a_{m-1}x^{m-1}+x^m\]의 임의의 실수 해는 정수거나 무리수다</p><p><b>(a)</b> 보조정리를 이용해 어떤 정수의 m 거듭제곱이 아닌 임의의 정수 k에 대하여 식[\sqrt[m]{k}]식가 무리수임을 보여라</p><p><i>증명.</i> 모순을 통해 증명한다. 보조정리에 따라, 정수 n에 대한 방정식 식[n - k^m = 0]식의 실수 해 k는 정수거나 무리수다<br>k가 정수라고 가정하자. 그러면 식[n=k^m]식으로부터 식[k=\sqrt[m]{n}]식을 얻는다
<br>그러나 이는 k가 어떤 정수의 m 거듭제곱이 아니라는 전제에 위배된다. 이는 모순이며, 따라서 k는 무리수다</p><p class="w3-right-align">■</p><p><b>(b)</b> 보조정리를 증명하라</p><p><i>증명.</i> 모순을 통해 증명한다. 실수 해 x가 정수가 아닌 유리수라고 가정하자. 그러면 x는 두 정수 d, n으로 이루어진 기약분수로 표현할 수 있다. 식[x = n / d]식<br>식[a_0+a_1(n/d)+a_2(n/d)^2+\cdots+a_{m-1}(n/d)^{m-1}+(n/d)^m = 0]식
<br>양변에 식[d^m]식을 곱하면, 식[a_0d^m+a_1nd^{m-1}+a_2n^2d^{m-2}+\cdots+a_{m-1}n^{m-1}d+n^m = d(a_0d^{m-1}+a_1nd^{m-2}+a_2n^2d^{m-3}+\cdots+a_{m-1}n^{m-1})+n^m = 0]식
<br>이는 d를 n으로 나눌 수 있음을 의미한다. 그러나 이는 n / d가 기약분수라는 가정에 위배된다. 이는 모순이며, 따라서 실수 해 x는 정수가 아닌 유리수가 아니다. 다시 말해 실수 해 x는 정수거나 무리수다</p><p class="w3-right-align">■</p><h4 class="fake">문제 1.26.</h4><p>다항식 p(n) ::= n^2 + n + 41에 대하여, n = 40일 때는 소수가 아님을<a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos1988974018" target="_self">주장 1.1.3</a>에서 보였다. 여기서는 모든 계수가 정수인 임의 다항식 q(n)이 소수만 생성할 수는 없음을 보인다. c ::= q(0)를 q의 상수항이라고 하자. 식[q(n) ::= c + c_1x + c_2x^2 + \cdots + c_ix^i]식</p><p><b>(a)</b> 식[\forall{m} \in \mathbb{Z}.]식 q(cm)이 c의 배수임을 보여라</p><p>→ 식[q(cm) = c + c_1(cm) + c_2(cm)^2 + \cdots + c_i(cm)^i = c\left(1 + c_1m + c_2cm^2 + \cdots + c_ic^{i-1}m^i\right)]식</p><p><b>(b)</b> q가 상수가 아닌 다항식이고 c > 1일때, 음이 아닌 정수 식[n \in \mathbb{N}]식에 대하여 소수가 아닌 식[q(n) \in \mathbb{Z}]식가 무한히 존재함을 보여라</p><p>→ (a)에 의해 2이상의 모든 정수 m에 대하여 q(cm)이 c의 배수 -- 즉 소수가 아님을 알 수 있다</p><p><b>(c)</b> 상수가 아닌 임의 다항식 q에 대하여, q(n)이 소수가 아닌 식[n \in \mathbb{N}]식이 항상 존재함을 결론지어라</p><p>→ c &lt;= 1인 임의 다항식 q는 q(0)이 소수가 아니므로, 마찬가지로 소수가 아닌 q(n)이 존재함을 알 수 있다</p></div></div><span class="pos-span" id="pos50"></span><h2>The Well Ordering Principle</h2><div><p>Every <i>nonempty</i> set of <i>nonnegative integers</i> has a <i>smallest</i> element.</p><span class="pos-span" id="pos49525"></span><h3>Well Ordering Proofs</h3><p>앞서 식[\sqrt{2}]식가 무리수임을 증명할 때, 임의의 양의 정수 m, n에 대하여, m/n의 기약분수 표기가 존재함을 이용했다. WOP를 이용하여 기약분수가 존재함을 증명해보자</p><p>→ 기약분수 표현이 존재하지 않는 분수 m/n에 대하여, 그러한 분자들의 집합을 C라고 하자. 그러면 식[m \in \mathbb{C}]식이므로, C는 공집합이 아니다<br>WOP에 의하여, C에는 최소 원소 식[m_0 \in \mathbb{C}]식가 존재한다. 그러면 기약분수 표현이 존재하지 않는 식[m_0 / n_0]식가 존재한다(식[n_0]식는 양의 정수)
<br>식[m_0 / n_0]식가 기약분수가 아니므로, 식[m_0, n_0]식에 대한 소수 공약수 p가 존재한다. 그러면 식[{m_0/p \over n_0/p} = m_0 / n_0]식이고, 좌변의 분수 역시 기약분수 표현이 존재하지 않아야 한다
<br>C의 정의에 의해, 분자 식[m_0/p]식 역시 C의 원소여야 한다. 하지만 이는 식[m_0]식가 C의 최소 원소라는 것에 모순이다. 따라서 C는 공집합이어야 한다. 다시 말해, 기약분수로 표현할 수 없는 식[m/n]식은 존재하지 않는다</p><p class="w3-right-align">■</p><span class="pos-span" id="pos49526"></span><h3>Template for WOP Proofs</h3><p>WOP을 이용해 식[P(n)\text{ is true for all }n \in \mathbb{N}]식을 증명하기</p><ol><li>P(n)의 반례집합 C를 정의한다. 식[C ::= \left\{n \in \mathbb{N} | \operatorname{NOT}(P(n))\text{ is true.}\right\}]식</li><li>모순을 이용한 증명을 위해 C가 공집합이 아니라고 가정한다</li><li>WOP에 의해, C에는 최소 원소 c가 존재해야 한다</li><li>모순에 도달한다</li><p>e.g. P(c)가 참임을 보이기, c보다 작은 원소가 C에 존재함을 보이기</p><li>C는 공집합이다. 따라서 P(n)은 항상 참이다</li></ol><div><span class="pos-span" id="pos-1787165552"></span><h4 class="fake">Summing the Integers</h4><span class="pos-span" id="pos432442782"></span><p><b>정리 2.2.1.</b> \[\forall n \in \mathbb{N}.\quad\sum_{1 \le i \le n} = n(n+1)/2\]</p><p><i>증명.</i> 반례집합 식[C ::= \left\{n \in \mathbb{N} | \sum_{1 \le i \le n} \ne n(n+1)/2\right\}]식가 공집합임을 보여 증명한다<br>C가 원소를 가진다고 가정하자. WOP에 의해 C에는 최소 원소 c가 존재한다. 이때, n=0일때 식[\sum_{1 \le i \le 0}=0]식이므로 c > 0이다
<br>c-1 >= 0이므로, 식[\sum_{1 \le i \le (c-1)}=(c-1)c/2]식가 성립한다. 양변에 c를 더하면 식[\sum_{1 \le i \le c} = (c-1)c/2 + c = c(c+1)/2]식이므로, 식[c \notin C]식이다
<br>이는 c가 C의 최소 원소라는 것에 모순이므로, C는 공집합이며, 따라서 명제는 참이다</p><p class="w3-right-align">■</p></div><span class="pos-span" id="pos49527"></span><h3>Factoring into Primes</h3><span class="pos-span" id="pos432472573"></span><p><b>정리 2.3.1.</b> 1보다 큰 모든 자연수는 소수의 곱으로 표현할 수 있다</p><p><i>증명.</i> 반례집합 C가 원소를 가진다고 가정하자. WOP에 의해 C에는 최소 원소 n > 1이 존재한다<br>이때, n은 소수일 수 없으므로 식[1 &lt; a, b &lt; n]식를 만족하는 두 자연수 a, b의 곱이다
<br>n이 C의 최소원소이므로 식[a, b \notin C]식며, 따라서 a, b 각각은 소인수분해 가능하다
<br>하지만 이는 식[n = ab]식 역시 소인수분해 가능하며, 이는 C가 원소를 가질 수 없음을 의미한다. 따라서 명제는 참이다</p><p class="w3-right-align">■</p><span class="pos-span" id="pos49528"></span><h3>Well Ordered Sets</h3><p>어떤 실수 집합에 대하여, 공집합이 아닌 모든 부분집합이 최소 원소를 갖는 경우, 이 집합은 well ordered set이다</p><p>최소 원소를 갖는 집합이 항상 well ordered set은 아니다. e.g. 음이 아닌 유리수 집합은 최소 원소 0을 갖지만, 그 부분집합인 양의 유리수 집합은 최소 원소가 존재하지 않는다</p><span class="pos-span" id="pos432502364"></span><p><b>정리 2.4.1.</b> 음이 아닌 임의 정수 n에 대하여, 집합 식[S=\left\{m \in \mathbb{N}|m\ge -n\right\}]식는 well ordered set이다</p><p><i>증명.</i> S의 모든 원소에 n을 더한 새로운 집합 S+n을 생각해보자. WOP에 의해 S+n은 0 이상의 최소 원소를 가진다. 또, S+n의 공집합이 아닌 모든 부분집합 역시 WOP에 의해 0 이상의 최소 원소를 가진다<br>다시 S+n 집합의 모든 원소에서 n을 뺀 집합 S를 생각해보면, S와 공집합이 아닌 S의 모든 부분집합은 -n 이상의 최소 원소를 가짐을 알 수 있다</p><p class="w3-right-align">■</p><span class="pos-span" id="pos1415114575"></span><p><b>정의 2.4.2.</b> 실수 집합 S의 하한(lower bound) ::= 식[\forall s \in S. s \ge b]식를 만족하는 실수 b<br>실수 집합 S의 상한(upper bound) ::= 식[\forall s \in S. s \le b]식를 만족하는 실수 b</p><span class="pos-span" id="pos-1079432506"></span><p><b>따름정리 2.4.3.</b> Lower bound를 갖는 임의의 정수 집합은 well ordered set이다</p><p><i>증명.</i> 정수 집합이 lower bound로 식[b \in \mathbb{R}]식를 갖는 경우, 정수 식[n = \lfloor b \rfloor]식 역시 집합의 lower bound다. 따라서<a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos432502364" target="_self">정리 2.4.1.</a>에 의하여 집합이 well ordered set임을 알 수 있다</p><p class="w3-right-align">■</p><span class="pos-span" id="pos-1079432475"></span><p><b>따름정리 2.4.4.</b> Upper bound를 갖는 임의의 정수 집합은 최대 원소가 존재한다</p><p><i>증명.</i> 정수 집합 S가 upper bound로 식[b \in \mathbb{R}]식를 가질 때, 모든 원소에 -1을 곱한 집합 -S를 생각해보자.<a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos-1079432506" target="_self">따름정리 2.4.3.</a>에 의해 -S가 well ordered set이고, 최소 원소 -m을 가짐을 알 수 있으며, 다시 -S의 모든 원소에 -1을 곱한 집합 S는 최대 원소 m을 가짐을 알 수 있다</p><p class="w3-right-align">■</p><span class="pos-span" id="pos931743836"></span><p><b>보조정리 2.4.5.</b> 공집합이 아닌 모든 유한 실수 집합은 well ordered set이다</p><p><i>증명.</i> 유한 집합 크기에 관한 WOP로 증명한다<br>Well ordered set이 아닌 유한 실수 집합의 크기 n에 대한 집합 C를 생각하자. WOP에 의해 C는 최소 원소 m을 갖는다. 이때, 원소가 하나인 집합이 well ordered set임은 자명하므로 m >= 2다
<br>이제 원소를 m개 갖는 유한 실수 집합 F를 생각하자. F의 임의 원소 식[r_0]식를 F에서 제거한 집합을 F'이라고 하자. 이때, F'의 크기는 m-1이므로 최소 원소 식[r_1]식을 가진다
<br>따라서 식[r_0, r_1]식 중 작은 값이 F의 최소 원소가 됨을 알 수 있으며, 이는 m이 C의 원소라는 것에 위배된다. 이는 모순이며, 따라서 C는 공집합이다</p><p class="w3-right-align">■</p><div><span class="pos-span" id="pos47597883"></span><h4 class="fake">A Different Well Ordered Set(Optional)</h4><p>n/(n+1) 꼴로 표현되는 집합 식[\mathbb{F}]식는 well ordered set이다\[{0 \over 1},{1 \over 2},{2 \over 3},\cdots,{n \over n+1},\cdots\]
간단하게 분자가 가장 작은 원소가 최소 원소다</p><span class="pos-span" id="pos931743867"></span><p><b>보조정리 2.4.6.</b> 식[\mathbb{N}+\mathbb{F}]식는 well ordered set이다</p><p><i>증명.</i> 식[\mathbb{N}+\mathbb{F}]식의 공집합이 아닌 임의 부분집합 S를 생각한다. S의 임의 원소는 n + f로 표현 가능하다 -- where 식[n\in\mathbb{N_s},f\in\mathbb{F_s},\mathbb{N_s}\subset\mathbb{N},\mathbb{F_s}\subset\mathbb{F}]식<br>식[\mathbb{N}]식이 well ordered set이므로, 식[\mathbb{N_s}]식는 최소원소 식[n_s]식를 가진다
<br>이제 S의 원소 중 식[n_s + f_s]식로 표현 가능한 모든 원소들을 생각해보자 -- where 식[f_s\in\mathbb{F_ss},\mathbb{F_ss}\subset\mathbb{F_s}]식
<br>식[\mathbb{F}]식가 well ordered set이므로, 식[\mathbb{F_ss}]식는 최소원소 식[f_{ss}]식를 가진다</p><ul><li>n > 식[n_s]식인 n이 식[\mathbb{N_s}]식에 존재하지 않는 경우 : 식[n_s+f_{ss}]식가 S의 최소원소임은 자명하다</li><li>n > 식[n_s]식인 n이 식[\mathbb{N_s}]식에 존재하는 경우 :</li><p>가능한 모든 n + f에 대하여 식[n - n_s >= 1]식, 식[f - f_{ss} > -1]식이 각각 성립하므로 식[(n - n_s) + (f - f_{ss}) > 0]식이 성립한다. 따라서 식[n + f > n_s + f_{ss}]식이며, 식[n_s+f_{ss}]식가 S의 최소원소임을 알 수 있다</p></ul><p class="w3-right-align">■</p></div><h3>Problems</h3><div><h4 class="fake">문제 2.5.</h4><p>WOP를 이용하여 다음 방정식의 해가 모두 양의 정수인 경우는 존재하지 않음을 증명하라 \[4a^3+2b^3=c^3\]</p><p>→ 가능한 모든 해에 대하여, 식[s = a+b+c]식의 집합 S을 생각해보자. 만약 해가 존재한다면 WOP에 의해 S는 최소 원소 식[s_m=a_m+b_m+c_m]식을 갖는다<br>식[4a^3+2b^3=c^3]식의 양변을 2로 나누면 식[2a^3+b^3=c^3/2]식이며, 이를 통해 c가 2의 배수(식[c=2c']식)임을 알 수 있다. 식[2a^3+b^3=4c'^3]식
<br>마찬가지로 b, a도 2의 배수(식[a=2a', b=2b']식)임을 알 수 있으며, 이제 식[a_m/2, b_m/2, c_m/2]식도 방정식의 해임을 보여 S가 공집합임을 보이겠다
<br>식[4(a_m/2)^3+2(b_m/2)^3=(c_m/2)^3]식의 양변에 8을 곱하면 식[4a_m^3+2b_m^3=c_m^3]식이며, 따라서 식[s_m]식은 S의 최소 원소가 아님을 알 수 있다. 따라서 S는 공집합이며, 방정식의 해가 모두 양의 정수인 경우는 존재하지 않는다</p><p class="w3-right-align">■</p><h4 class="fake">문제 2.6.</h4><p>1, 2, 4, ..., 식[2^m]식 달러가 각각 들어있는 봉투들을 하나씩 받았다. 다음과 같은 정의가 주어질 때,</p><P><b>속성</b> <i>m</i> : 주어진 봉투들 중 일부를 선택한 금액의 합계로 식[2^{m+1}]식보다 작은 임의의 음이 아닌 정수를 만들 수 있다</P><p>WOP를 이용하여 이것이 음이 아닌 모든 정수 m에 대하여 참임을 증명하라</p><p>→ WOP를 적용하기 앞서 반례가 될 수 없는 경우를 살펴본다.</p><ul><li>m=0 : [0, 1)를 모두 만들 수 있는가?</li><p>봉투를 하나도 선택하지 않는 경우 0을 만들 수 있으므로 m=0은 반례가 될 수 없다</p></ul><p>이제 속성을 만족하지 않는 음이 아닌 정수 m의 집합 C를 생각하자. C가 공집합이 아니라면 WOP에 의해 최소 원소 c > 0가 존재한다. 이제 관건은 1, 2, ..., 식[2^c]식의 조합으로 [0, 식[2^{c+1}]식)을 모두 만들 수 있는가?가 된다. 이때, 구간을 2개로 나눌 수 있음에 주목하자</p><ul><li>[0, 식[2^c]식)</li><p>c-1은 속성을 만족하므로, 식[2^c]식 봉투를 제외한 조합으로 모두 만들 수 있다</p><li>[식[2^c]식, 식[2^{c+1}]식)</li><p>구간 [0, 식[2^c]식)에 속하는 모든 수에 대하여, 해당 수를 만드는 봉투 조합에 식[2^c]식를 추가함으로써 구간 [식[2^c]식, 식[2^{c+1}]식)의 모든 수 역시 1, 2, ..., 식[2^c]식의 조합으로 만들 수 있음을 알 수 있다</p></ul><p>이는 c가 속성을 만족함을 의미하며, 따라서 C는 공집합이고, 속성은 음이 아닌 모든 정수에 대하여 참이다</p><p class="w3-right-align">■</p><h4 class="fake">문제 2.7.</h4><p>WOP를 이용하여 8 이상의 임의 정수를 3의 배수와 5의 배수의 합으로 표현할 수 있음을 증명하라</p><p>→ WOP를 적용하기 앞서 반례가 될 수 없는 경우를 살펴본다</p><ul><li>8 = 3 + 5</li><li>9 = 3 * 3</li><li>10 = 2 * 5</li></ul><p>이제, 3의 배수와 5의 배수의 합으로 표현할 수 없는 8 이상의 정수의 집합 C를 생각하자. C가 공집합이 아니라면 WOP에 의해 최소 원소 c >= 11가 존재한다<br>이때, c - 3 >= 8은 C의 원소가 아니므로 3의 배수와 5의 배수의 합으로 표현할 수 있다: \[c - 3 = 3a + 5b\]
여기서 양변에 3을 더하면 c = 3(a + 1) + 5b. 이는 c가 C의 원소라는 것에 모순이다. 따라서 C는 공집합이고, 명제는 참이다</p><p class="w3-right-align">■</p><h4 class="fake">문제 2.10.</h4><p>WOP를 이용하여 \[n\le 3^{n/3} \tag*{(2.6)}\]이 임의의 음이 아닌 정수 n에 대하여 성립함을 보여라</p><p>→ 부등식은 식[n^3 \le 3^n]식과 동치다. 먼저 반례가 될 수 없는 경우를 살펴본다</p><ul><li>n = 0. 0 ≤ 1</li><li>n = 1. 1 ≤ 3</li><li>n = 2. 8 ≤ 9</li><li>n = 3. 27 ≤ 27</li></ul><p>반례 집합 C의 최소 원소 c >= 4가 존재한다고 가정하자. 식[c^3 \gt 3^c]식. 이때, c-1은 C의 원소가 아니므로 부등식이 성립한다. 식[(c-1)^3 \le 3^{c-1}]식<br>양변에 식[\left({c \over c-1}\right)^3]식을 곱하면 식[c^3 \le \left({c \over c-1}\right)^3 3^{c-1}]식
<br>따라서 식[\left({c \over c-1}\right)^3 3^{c-1} \gt 3^c]식이 성립해야 한다
<br>\begin{align*}
\iff & \left({c \over c-1}\right)^3 = \left(1 + {1 \over c-1}\right)^3 \gt 3 \\
\iff & {1 + {1 \over c-1}} \gt 1.44\cdots \\
\iff & {1 \over c-1} \gt 0.44\cdots \\
\iff & 1 \gt (c-1)\cdot 0.44\cdots
\end{align*}
이때, c-1 >= 3이므로 부등식은 성립하지 않는다. 따라서 C는 공집합이며, 명제는 참이다</p><p class="w3-right-align">■</p></div></div><span class="pos-span" id="pos51"></span><h2>Logical Formulas</h2><div><span class="pos-span" id="pos50486"></span><h3>Propositions from Propositions</h3><p>Propositional variables 또는 Boolean variable은 T(true) 또는 F(false) 값만 가질 수 있는 변수다</p><div><span class="pos-span" id="pos48518521"></span><h4 class="fake">NOT, AND, OR</h4><p>명제를 결합하는 데 NOT, AND, OR 등의 연산을 이용한다. 이러한 연산의 의미는 진리표(truth table)를 이용하여 표현할 수 있다. 예를 들어 명제 "NOT(P)"는 P에 의해 그 값이 결정되며, 진리표는 다음과 같다</p><table class="w3-table-all w3-card w3-small"><tr><th>P</th><th>NOT(P)</th></tr><tr><td>T</td><td>F</td></tr><tr><td>F</td><td>T</td></tr></table><table class="w3-table-all w3-card w3-small"><tr><th>P</th><th>Q</th><th>P AND Q</th><th>P OR Q</th><th>P XOR Q</th></tr><tr><td>T</td><td>T</td><td>T</td><td>T</td><td>F</td></tr><tr><td>T</td><td>F</td><td>F</td><td>T</td><td>T</td></tr><tr><td>F</td><td>T</td><td>F</td><td>T</td><td>T</td></tr><tr><td>F</td><td>F</td><td>F</td><td>F</td><td>F</td></tr></table><span class="pos-span" id="pos48518522"></span><h4 class="fake">If and Only If</h4><p>IFF는 동치 -- 즉 두 진리값이 일치하는 경우에만 참이다</p><table class="w3-table-all w3-card w3-small"><tr><th>P</th><th>Q</th><th>P IFF Q</th></tr><tr><td>T</td><td>T</td><td>T</td></tr><tr><td>T</td><td>F</td><td>F</td></tr><tr><td>F</td><td>T</td><td>F</td></tr><tr><td>F</td><td>F</td><td>T</td></tr></table><span class="pos-span" id="pos48518523"></span><h4 class="fake">IMPLIES</h4><table class="w3-table-all w3-card w3-small"><tr><th>P</th><th>Q</th><th>P IMPLIES Q</th></tr><tr><td>T</td><td>T</td><td>T</td></tr><tr><td>T</td><td>F</td><td>F</td></tr><tr><td>F</td><td>T</td><td>T</td></tr><tr><td>F</td><td>F</td><td>T</td></tr></table><ul><li>P IMPLIES Q == NOT(P) OR Q</li><li>골드바흐의 추측이 참이라면, 임의 실수 x에 대하여 식[x^2 \ge 0]식이다</li><p>전제와 무관하게 결론이 항상 참이므로 명제는 참이다</p><li>돼지가 날 수 있다면, 당신의 계정은 해킹당하지 않는다</li><p>전제가 거짓이므로 명제는 참이다</p><li>전제가 거짓일 때 명제가 참이 되는 것은 일반 상식과 거리가 있지만, 오히려 이것이 일상의 문제보다 수학적 implication을 간결하고 유용하게 해준다</li><p>예를 들어, 아래와 같은 12개의 규칙을 갖는 시스템 명세를 생각해보자</p><p><strong>↓ text</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">If  the     system sensors are in condition 1,
    then    the system takes action 1.
...
If  the     system sensors are in condition 12,
    then    the system takes action 12.</div><p>다음과 같이 정의하자</p><p><strong>↓ text</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">Ci ::= 시스템이 상태 i를 감지?
Ai ::= 시스템이 동작 i를 취함?</div><p>그러면 시스템 명세는 다음과 같이 간결한 하나의 논리식으로 표현할 수 있다</p><span class="pos-span" id="pos38505947"></span><p><strong>↓ (3.1)</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">(C1 IMPLIES A1) AND (C2 IMPLIES A2) AND ... AND (C12 IMPLIES A12)</div><p>이제 시스템이 C2, C5 상태만을 감지하고, 실제로 A2, A5 동작을 실행한 경우를 생각해보자. 시스템은 명세에 따라 작동했으며, 우리는 식<a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos38505947" target="_self">(3.1)</a>이 참이길 바란다. 하지만 식<a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos38505947" target="_self">(3.1)</a>이 참이기 위해서는, 전제가 거짓인 나머지 10개의 IMPLIES 항들 모두가 참이어야 한다. 바로 이것이 수학적 implication 규칙으로부터 얻는 간결함이다</p></ul></div><span class="pos-span" id="pos50487"></span><h3>Propositional Logic in Computer Programs</h3><div><span class="pos-span" id="pos48519482"></span><h4 class="fake">Truth Table Calculation</h4><p>진리표를 이용하여 서로 다른 두 논리식이 동치임을 한 눈에 파악할 수 있다. 복잡한 식은 보다 간결한 동치 식으로 교체함으로써 가독성을 높이고, 계산에 필요한 연산을 줄일 수 있다</p><span class="pos-span" id="pos48519483"></span><h4 class="fake">Cryptic Notation</h4><p>프로그래머나 전자공학자와 마찬가지로 수학자들도 AND, OR 등의 논리 연산을 표현하는 연산자를 사용한다</p><table class="w3-table-all w3-card w3-small"><tr><th>English</th><th>한국어</th><th>Symbolic Notation</th></tr><tr><td>NOT(P)</td><td>(명제의) 부정(negation)</td><td>식[\neg{P}]식 또는 식[\overline{P}]식</td></tr><tr><td>P AND Q</td><td>(명제의) 논리곱(conjunction)</td><td>식[P \land Q]식</td></tr><tr><td>P OR Q</td><td>(명제의) 논리합(disjunction)</td><td>식[P \lor Q]식</td></tr><tr><td>P IMPLIES Q, if P then Q</td><td>조건 명제(implication)</td><td>식[P \longrightarrow Q]식</td></tr><tr><td>P IFF Q</td><td>P는 Q이기 위한 필요충분조건</td><td>식[P \iff Q]식</td></tr><tr><td>P XOR Q</td><td>(명제의) 배타적 논리합</td><td>식[P \oplus Q]식</td></tr></table></div><span class="pos-span" id="pos50488"></span><h3>Equivalence and Validity</h3><div><span class="pos-span" id="pos48520443"></span><h4 class="fake">Implications and Contrapositives</h4><ul><li>명제의 대우(Contrapositive)</li><p>Implication과 그의 대우는 동치다. P IMPLIES Q == NOT(Q) IMPLIES NOT(P)</p><li>명제의 역(Converse)</li><p>IFF는 implication과 그의 역 모두가 참인 경우와 동치다. P IFF Q == (P IMPLIES Q) AND (Q IMPLIES P)</p></ul><span class="pos-span" id="pos48520444"></span><h4 class="fake">Validity and Satisfiability</h4><ul><li><i>Valid</i> formula : 변수와 무관하게 항상 참인 식</li><p>두 식 F, G에 대하여, (F IFF G)가 valid면 F와 G는 동치다</p><li><i>Satisfiable</i> formula : 변수에 따라 참/거짓이 바뀌는 식</li><p>(식 P가 satisfiable이다) IFF (NOT(P)는 valid하지 않다)</p></ul></div><span class="pos-span" id="pos50489"></span><h3>The Algebra of Propositions</h3><div><span class="pos-span" id="pos48521404"></span><h4 class="fake">Propositions in Normal Form</h4><span class="pos-span" id="pos461131515"></span><p><b>정리 3.4.1.</b> 모든 명제 식은 그와 동치인 full DNF, full CNF가 존재한다</p><p>e.g. A AND (B OR C)</p><table class="w3-table-all w3-card w3-small"><tr><th>A</th><th>B</th><th>C</th><th>A AND (B OR C)</th></tr><tr><td>T</td><td>T</td><td>T</td><td>T</td></tr><tr><td>T</td><td>T</td><td>F</td><td>T</td></tr><tr><td>T</td><td>F</td><td>T</td><td>T</td></tr><tr><td>T</td><td>F</td><td>F</td><td>F</td></tr><tr><td>F</td><td>T</td><td>T</td><td>F</td></tr><tr><td>F</td><td>T</td><td>F</td><td>F</td></tr><tr><td>F</td><td>F</td><td>T</td><td>F</td></tr><tr><td>F</td><td>F</td><td>F</td><td>F</td></tr></table><ul><li>DNF(Disjunctive normal form) : Sum-of-products. 서로 다른 변수들의 AND 절들을 OR 연산으로 연결한 것</li><li>Full DNF : 식이 참이 되는 행들을 OR로 연결한다</li><p>(A AND B AND C) OR (A AND B AND NOT(C)) OR (A AND NOT(B) AND C)</p><li>Full DNF를 보다 간결한 동치 DNF로 표현할 수 있는 경우도 있다</li><p>(A AND B) OR (A AND C)</p><li>CNF(Conjunctive normal form) : 서로 다른 변수들의 OR 절들을 AND 연산으로 연결한 것</li><li>Full CNF : 식이 거짓이 되는 행들의 NOT 표현을 AND로 연결한다</li><p>(NOT(A) OR B OR C) AND (A OR NOT(B) OR NOT(C)) AND (A OR NOT(B) OR C) AND (A OR B OR NOT(C)) AND (A OR B OR C)</p></ul><span class="pos-span" id="pos48521405"></span><h4 class="fake">Proving Equivalences</h4><ul><li>변수가 늘어날 때 검사해야 되는 진리표의 크기는 기하급수로 늘어난다</li><li>두 식이 동치임을 보이는 데 진리표보다는, 대수학이 유용할 수 있다. 첫 번째 단계는 논리식에 사용되는 다양한 연산자들을 모두 AND, OR, NOT의 조합으로 변환하는 것이다</li></ul><table class="w3-table-all w3-card w3-small"><tr><td>교환법칙 of AND</td><td>A AND B = B AND A</td></tr><tr><td>결합법칙 of AND</td><td>A AND (B AND C) = (A AND B) AND C</td></tr><tr><td>분배법칙 of AND over OR</td><td>A AND (B OR C) = (A AND B) OR (A AND C)</td></tr><tr><td>분배법칙 of OR over AND</td><td>A OR (B AND C) = (A OR B) AND (A OR C)</td></tr><tr><td>항등원 of AND</td><td>T AND A = A</td></tr><tr><td>zero of AND</td><td>F AND A = F</td></tr><tr><td>멱등 of AND</td><td>A AND A = A</td></tr><tr><td>contradiction of AND</td><td>A AND NOT(A) = F</td></tr><tr><td>double negation</td><td>NOT(NOT(A)) = A</td></tr><tr><td>validity of OR</td><td>A OR NOT(A) = T</td></tr><tr><td>De Morgan for AND</td><td>NOT(A AND B) = NOT(A) OR NOT(B)</td></tr><tr><td>De Morgan for OR</td><td>NOT(A OR B) = NOT(A) AND NOT(B)</td></tr></table><span class="pos-span" id="pos461131546"></span><p><b>정리 3.4.2.</b> 위 동치 관계를 이용하여 임의 논리식을 하나의 정규식과 동치임을 보일 수 있다</p><p>예를 들어 A, B, C 세 변수로 이루어진 논리식 NOT((A AND B) OR (A AND C))을 full DNF로 정규화하는 절차는 아래와 같다</p><ol><li>AND, OR, NOT 외의 연산자는 AND, OR, NOT으로 변환</li><li>식을 AND 항의 OR 합으로 변환</li><ul><li>NOT(A AND B) AND NOT(A AND C)</li><li>= (NOT(A) OR NOT(B)) AND (NOT(A) OR NOT(C))</li><li>= (NOT(A) AND (NOT(A) OR NOT(C))) OR (NOT(B) AND (NOT(A) OR NOT(C)))</li><li>= (NOT(A) AND NOT(A)) OR (NOT(A) AND NOT(C)) OR (NOT(A) AND NOT(B)) OR (NOT(B) AND NOT(C))</li><li>= NOT(A) OR (NOT(A) AND NOT(B)) OR (NOT(A) AND NOT(C)) OR (NOT(B) AND NOT(C))</li></ul><li>변수가 3개 미만인 AND 항은 나머지 변수를 붙여 확장</li><ul><li>NOT(A) = (NOT(A) AND B AND C) OR (NOT(A) AND B AND NOT(C)) OR (NOT(A) AND NOT(B) AND C) OR (NOT(A) AND NOT(B) AND NOT(C))</li><li>(NOT(A) AND NOT(B)) = (NOT(A) AND NOT(B) AND C) OR (NOT(A) AND NOT(B) AND NOT(C))</li><li>(NOT(A) AND NOT(C)) = (NOT(A) AND B AND NOT(C)) OR (NOT(A) AND NOT(B) AND NOT(C))</li><li>(NOT(B) AND NOT(C)) = (A AND NOT(B) AND NOT(C)) OR (NOT(A) AND NOT(B) AND NOT(C))</li></ul><li>동일항 제거</li><p>= (A AND NOT(B) AND NOT(C)) OR (NOT(A) AND B AND C) OR (NOT(A) AND B AND NOT(C)) OR (NOT(A) AND NOT(B) AND C) OR (NOT(A) AND NOT(B) AND NOT(C))</p></ol><span class="pos-span" id="pos461131577"></span><p><b>정리 3.4.3.</b> 두 논리식이 동치다 iff 두 논리식이 위에 제시된 공리들을 이용해 같음을 보일 수 있다</p></div><span class="pos-span" id="pos50490"></span><h3>The SAT Problem</h3><ul><li><b>SAT</b> ::= 명제가 참일 수 있는 지(satisfiable)에 대한 일반적인 결정 문제</li><li>일반적으로 입력 크기 n에 대하여 복잡도가 다항식 이하면 효율적인 알고리즘으로 간주한다 -- O(n^a)</li><li>SAT에 대한 효율적인 일반 해법은 아직 없다</li><li>SAT에 대한 효율적인 해법이 등장하면 좋을 것 같지만, 심각한 문제도 동시에 발생한다 -- 기존 암호학의 무력화</li><li>SAT에 대해 다항 시간 해법이 존재하지 않는다는 증명도 아직 없다 -- P vs NP 문제</li></ul><span class="pos-span" id="pos50491"></span><h3>Predicate Formulas</h3><div><span class="pos-span" id="pos48523326"></span><h4 class="fake">Quantifiers</h4><ul><li>for all : 식[\forall]식</li><li>there exists : 식[\exists]식</li><li>Universal quantification : 명제가 항상 참이라고 한정하는 것</li><li>Existential quantification : 명제가 참일 수 있다고 한정하는 것</li></ul><span class="pos-span" id="pos48523327"></span><h4 class="fake">Mixing Quantifiers</h4><p>e.g. 식[\forall{n}\in\text{Evens }\exists{p}\in\text{Primes }\exists{q}\in\text{Primes.}\quad n=p+q.]식</p><span class="pos-span" id="pos48523328"></span><h4 class="fake">Order of Quantifiers</h4><p>서로 다른 종류의 한정자 순서를 변경하면 보통 명제의 의미가 달라짐에 유의</p><span class="pos-span" id="pos48523329"></span><h4 class="fake">Variables Over One Domain</h4><p>모든 변수의 정의역이 동일하다면 표기에서 생략할 수 있다</p><p>e.g. 식[\forall{n}.\ n\in\text{Evens}\quad\text{IMPLIES}\quad(\exists{p}\exists{q}.\ p\in\text{Primes AND }q\in\text{Primes AND }n=p+q)]식</p><span class="pos-span" id="pos48523330"></span><h4 class="fake">Negating Quantifiers</h4><p>De Morgan's Laws for Quantifiers</p><ul><li>식[NOT(\forall{x}. P(x))]식 == 식[\exists{x}. NOT(P(x))]식</li><li>식[NOT(\exists{x}. P(x))]식 == 식[\forall{x}. NOT(P(x))]식</li></ul><span class="pos-span" id="pos48523331"></span><h4 class="fake">Validity for Predicate Formulas</h4><ul><li>식[\exists{x}\forall{y}.P(x,y)\quad\text{IMPLIES}\quad\forall{y}\exists{x}.P(x,y)]식은 항상 참</li><li>식[\forall{x}\exists{y}.P(x,y)\quad\text{IMPLIES}\quad\exists{x}\forall{y}.P(x,y)]식은 항상 참은 아님</li></ul></div><h3>Problems</h3><div><h4 class="fake">문제 3.3.</h4><p>수학자가 학생에게 "함수가 연속이 아니면, 미분 불가능하다"라고 말했다. D를 "함수가 미분 가능하다", C를 "함수가 연속이다"라고 했을 때, 수학자의 발언은 "NOT(C) IMPLIES NOT(D)" 또는 "D IMPLIES C"로 변환할 수 있다<br>그런데 어머니가 자식에게 "숙제를 하지 않으면, TV를 볼 수 없다"라고 말한 경우를 생각해보자. T를 "TV를 볼 수 있다", H를 "숙제를 했다"라고 했을 때, 어머니의 발언은 "NOT(H) IFF NOT(T)" 또는 "H IFF T"로 변환된다
<br>왜 똑같은 IF-THEN 구조 문장을 서로 다르게 변환하는 것이 합당한지 설명하라</p><p>→ 수학자의 발언은 함수의 미분 가능성을 위하여 함수의 연속을 요구하는 것이 아니다. 그러나 어머니의 발언은 TV를 보기 위해 숙제를 할 것을 요구하는 것을 내포하고 있다 -- "숙제를 하면, TV를 볼 수 있다". 즉, 어머니의 발언은 "(NOT(H) IMPLIES NOT(T)) AND (H IMPLIES T) = H IFF T"으로 변환된다.</p><h4 class="fake">문제 3.6.</h4><p>이진수 덧셈 식[a_{1}a_{0}+b]식를 처리하는 2비트 반가산기는 3개 비트 식[cs_{1}c_{0}]식를 출력한다. 여기서 c는 carry bit라고 부른다 -- 다음 자릿수에 전달되어 연산에 사용되므로. 이를 아래와 같이 표현할 수 있다.\begin{align*}
  c_0 =& b \\
  s_0 =& a_0\text{ XOR }c_0 \\
  c_1 =& a_0\text{ AND }c_0 && \text{the carry into column 1} \\
  s_1 =& a_1\text{ XOR }c_1 \\
  c_2 =& a_1\text{ AND }c_1 && \text{the carry into column 2} \\
  c   =& c_2
\end{align*}</p><p><b>(a)</b> 위 논리식을 n+1비트 반가산기로 일반화하라. 즉, 식[a_{n} \cdots a_{1}a_{0}]식와 b를 입력으로 받아 식[cs_{n} \cdots s_{1}s_{0}]식를 출력한다.</p><p>→ \begin{align*}  c_0 =& b \\
  s_i =& a_i\text{ XOR }c_i \\
  c_{i+1} =& a_i\text{ AND }c_i \\
  c   =& c_{n+1}
\end{align*}</p><p><b>(b)</b> 유사하게, 두 개의 n+1비트 식[a_{n} \cdots a_{1}a_{0}]식, 식[b_{n} \cdots b_{1}b_{0}]식를 입력으로 받는 가산기의 출력에 대한 일반식을 작성하라</p><p>→ \begin{align*}  c_0 =& 0 \\
  s_i =& a_i\text{ XOR }b_i\text{ XOR }c_i \\
  c_{i+1} =& (a_i\text{ AND }b_i)\text{ OR }(b_i\text{ AND }c_i)\text{ OR }(c_i\text{ AND }a_i) \\
  c   =& c_{n+1}
\end{align*}</p><p><b>(c)</b> 위 <b>(b)</b>에서 작성한 계산기는 작동을 위해 몇 번의 논리 연산을 수행하는가?</p><p>→ 2(n+1)번의 XOR 연산, 3(n+1)번의 AND 연산, 2(n+1)번의 OR 연산을 수행한다</p><h4 class="fake">문제 3.7</h4><ul><li>회로의 속도 또는 지연은 입력과 출력 사이의 경로들 중 가장 게이트가 많이 존재하는 경로에 의해 결정된다</li><li>문제 3.6의 ripple-carry 반가산기는 이전 비트의 캐리 비트가 다음 비트의 계산에 필요하므로, 반가산기의 입력을 2배로 늘릴 때마다 소요 시간도 2배로 늘어난다</li><li>만약 가산기의 모든 비트가 동시에 계산된다면, 입력을 2배로 늘려도 소요 시간은 크게 늘지 않는다</li><li>식[a_{3}a_{2}a_{1}a_{0} + b_{3}b_{2}b_{1}b_{0} = cs_{3}s_{2}s_{1}s_{0}]식를 수행하는 자리올림수 예측 가산기(carry-lookahead adder) 구현을 생각해보자</li><ul><li>자리올림이 발생하는 경우</li><ul><li>두 입력의 동일 자리가 모두 1이면 반드시 자리올림수가 발생한다 : G(A, B) = A AND B</li><li>두 입력 중 하나만 1인 경우, 자리올림수가 발생할 수 있다 : P(A, B) = A XOR B</li></ul><li>한 자리의 계산</li><ul><li>문제 3.6 - (b)의 답과 다름 없음</li><li>식[s_{i} = P_{i}\text{ XOR }c_{i} = a_i\text{ XOR }b_i\text{ XOR }c_i]식</li><li>식[c_{i+1} = G_{i}\text{ OR }(P_{i}\text{ AND }c_{i}) = (a_i\text{ AND }b_i)\text{ OR }(b_i\text{ AND }c_i)\text{ OR }(c_i\text{ AND }a_i)]식</li></ul><li>식 전개</li><ul><li>s0 = P0 XOR 0</li><li>c1 = G0</li><li>s1 = P1 XOR c1 = P1 XOR G0</li><li>c2 = G1 OR (P1 AND c1) = G1 OR (P1 AND G0)</li><li>s2 = P2 XOR c2 = P2 XOR (G1 OR (P1 AND G0))</li><li>c3 = G2 OR (P2 AND c2) = G2 OR (P2 AND (G1 OR (P1 AND G0)))</li><li>s3 = P3 XOR c3 = P3 XOR (G2 OR (P2 AND (G1 OR (P1 AND G0))))</li><li>c4 = G3 OR (P3 AND c3) = G3 OR (P3 AND (G2 OR (P2 AND (G1 OR (P1 AND G0)))))</li></ul><li>시간이 적게 소요되는 대신 회로 복잡도가 크게 증가한다 -- O(n^2)</li></ul></ul><h4 class="fake">문제 3.15.</h4><p><b>(d)</b> 논리식 집합 {P1, ..., Pk}이 consistent하다 iff 모든 논리식이 참이 되는 환경이 존재한다. 이때, "집합 {P1, ..., Pk}이 consistent하지 않다 iff S는 valid하다"를 만족하는 논리식 S를 작성하라</p><p>→ S = NOT(P1 AND P2 ... AND Pk)</p><ul><li>집합 {P1, ..., Pk}이 consistent하지 않다면, 원소 중 하나라도 false가 존재하므로 S가 항상 true다</li><li>S가 valid하다면, (P1 AND P2 ... AND Pk)가 항상 false이므로 집합 {P1, ..., Pk}이 consistent하지 않다</li></ul><h4 class="fake">문제 3.17.</h4><p>모든 논리식의 연산자를 AND, OR, NOT의 조합으로 치환할 수 있다</p><ul><li><b>(a)</b> A IFF B, A XOR B 각각에 대해 AND, OR, NOT의 조합으로만 이루어진 동치식을 작성하라</li><ul><li>A IFF B = (A AND B) OR (NOT(A) AND NOT(B))</li><li>A XOR B = (A AND NOT(B)) OR (NOT(A) AND B)</li></ul><li><b>(b)</b> AND 연산자를 추가로 생략 가능한데, 그 이유를 설명하라</li><p>→ A AND B = NOT(NOT(A) OR NOT(B))</p><li><b>(c)</b> NAND 연산자 하나만으로 모든 연산자를 치환할 수 있는데, 그 이유를 설명하라</li><ul><li>A AND B = (A NAND B) NAND (A NAND B)</li><li>NOT(A) = A NAND A</li><li>A OR B = NOT(NOT(A) AND NOT(B)) = X NAND X<br>where X = (Y NAND Z) NAND (Y NAND Z), Y = A NAND A, Z = B NAND B</li></ul><li><b>문제 3.18.</b> NOR 연산자 하나만으로 모든 연산자를 치환할 수 있는데, 그 이유를 설명하라</li><ul><li>NOT(A) = A NOR A</li><li>A OR B = NOT(A NOR B) = (A NOR B) NOR (A NOR B)</li><li>A AND B = NOT(NOT(A) OR NOT(B)) = X NOR X</li><br>where X = (Y NOR Z) NOR (Y NOR Z), Y = A NOR A, Z = B NOR B</ul></ul><h4 class="fake">문제 3.19.</h4><p>Disjunctive form 논리식으로부터 conjunctive form 논리식을 직접 도출할 수 있음을 보여라</p><p>→ 임의 DNF 식[P_1\text{ OR }P_2\text{ OR }\cdots\text{ OR }P_n]식, where 식[P_i=Q_{i1}\text{ AND }Q_{i2}\text{ AND }\cdots\text{ AND }Q_{im_i}]식에 대하여,\begin{align*}
& \text{ NOT}(P_1\text{ OR }P_2\text{ OR }\cdots\text{ OR }P_n) \\
=& \text{ NOT}(P_1)\text{ AND }\text{ NOT}(P_2)\text{ AND }\cdots\text{ AND }\text{ NOT}(P_n) \\
=& (\text{ NOT}(Q_{11})\text{ OR }\text{ NOT}(Q_{12})\text{ OR }\cdots\text{ OR }\text{ NOT}(Q_{1m_1})))\text{ AND } \\
& (\text{ NOT}(Q_{21})\text{ OR }\text{ NOT}(Q_{22})\text{ OR }\cdots\text{ OR }\text{ NOT}(Q_{2m_1})))\text{ AND } \\
& \vdots \\
& (\text{ NOT}(Q_{n1})\text{ OR }\text{ NOT}(Q_{n2})\text{ OR }\cdots\text{ OR }\text{ NOT}(Q_{2n_1})))
\end{align*}</p><h4 class="fake">문제 3.32.</h4><p>이 문제는 이진 문자열에 대한 정의를 논리식으로 변환하는 걸 목표로 한다. 정의역은 모든 유한 길이 이진 문자열이다: λ(빈 문자열 표현 상수), 0, 1, 00, 01, ...<br>문자열 표현에 사용된 변수는 앞뒤 리터럴과의 접합을 의미한다. 예를 들어, x=011, y=1111일 때 01x0y=0101101111
<br>그 외, 아래 3가지 함수를 풀이에 사용할 수 있다</p><table class="w3-table-all w3-card w3-small"><tr><th>이름</th><th>논리식</th><th>의미</th></tr><tr><td>PREFIX(x, y)</td><td>식[\exists{z}. xz = y]식</td><td>x is a prefix of y</td></tr><tr><td>SUBSTRING(x, y)</td><td>식[\exists{u}\exists{v}. uxv = y]식</td><td>x is a substring of y</td></tr><tr><td>NO-1S(x)</td><td>NOT(SUBSTRING(1, x))</td><td>x is empty or a string of 0's</td></tr></table><ul><li><b>(a)</b> x는 어떤 문자열을 3번 이어 붙인 것과 같다</li><p>→ 식[\exists{y}. x=yyy]식</p><li><b>(b)</b> x는 0으로만 이루어진 짝수 길이 문자열이다</li><p>→ PREFIX(x, 00x)</p><li><b>(d)</b> x는 2^k + 1의 이진수 표현. k는 0이상의 정수</li><p>→ x = 10 OR (1y1 where NO-1S(y))</p></ul><h4 class="fake">문제 3.36.</h4><p>다음 문장을 predicate 식으로 변환하라 : "서로 다른 학생 최대 2명에게 이메일을 보낸 학생이 있다(본인에게 보내는 것도 허용된다)"<br>정의역은 교실 내 전체 학생 집합이며, 작성할 식에서 사용할 수 있는 predicate은 아래 2가지 뿐이다</p><ul><li>동등 비교</li><li>E(x, y) ::= x는 y에게 이메일을 보냈다</li></ul><p>→ let Y(x) ::= {y | E(x, y)}. 식[\exists{x}. \lceil |Y(x)| \rceil = 2]식</p></div></div><span class="pos-span" id="pos52"></span><h2>Mathematical Data Types</h2><div><span class="pos-span" id="pos51447"></span><h3>Sets</h3><div><span class="pos-span" id="pos49442042"></span><h4 class="fake">Some Popular Sets</h4><ul><li>식[\emptyset]식 : Empty set</li><li>식[\mathbb{N}]식 : Nonnegative integers</li><li>식[\mathbb{Z}]식 : Integers</li><li>식[\mathbb{Q}]식 : Rational numbers</li><li>식[\mathbb{R}]식 : Real numbers</li><li>식[\mathbb{C}]식 : Complex numbers</li></ul><p>어깨 글자로 쓰인 +는 집합을 양의 원소로 한정한다. 예를 들어, 식[\mathbb{R}^{+}]식는 양의 실수 집합을 의미한다. 유사하게 식[\mathbb{Z}^{-}]식는 음의 정수 집합을 의미한다.</p><span class="pos-span" id="pos49442043"></span><h4 class="fake">Comparing and Combining Sets</h4><ul><li>식[S \subseteq T]식 : S is a subset of T</li><li>식[S \subset T]식 : S is a strict subset of T</li></ul><span class="pos-span" id="pos1472283473"></span><p><b>정의 4.1.1.</b></p><ul><li>두 집합 A, B의 union(합집합)은 정확히 A 또는 B의 모든 원소를 갖는 집합이다</li><p>식[x \in A \cup B \qquad \text{IFF} \qquad x \in A\text{ OR }x \in B]식</p><li>두 집합 A, B의 intersection(교집합)은 A와 B 모두에 포함되는 원소 전체로 구성된 집합이다</li><p>식[x \in A \cap B \qquad \text{IFF} \qquad x \in A\text{ AND }x \in B]식</p><li>두 집합 A, B의 difference(차집합)은 A에만 포함되는 원소 전체로 구성된 집합이다</li><p>식[x \in A - B \qquad \text{IFF} \qquad x \in A\text{ AND }x \notin B]식</p><li>정의역 D의 부분집합 A의 Complement(여집합)은 A에 포함되지 않는 D의 원소 전체로 구성된 집합이다</li><p>식[\overline{A} ::= D - A]식</p></ul><span class="pos-span" id="pos49442044"></span><h4 class="fake">Power Set</h4><p>집합의 모든 부분집합을 원소로 갖는 집합을 power set(멱집합)이라 한다. \[B \in \operatorname{pow}(A) \quad\text{IFF}\quad B \subseteq A.\]</p><span class="pos-span" id="pos49442045"></span><h4 class="fake">Set Builder Notation</h4><p><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos655935895" target="_self">Predicate</a>을 이용하여 집합을 정의하는 방법</p><span class="pos-span" id="pos49442046"></span><h4 class="fake">Proving Set Equalities</h4><p>두 집합은 모든 원소를 공유할 때 서로 같다고 정의된다</p><span class="pos-span" id="pos489671324"></span><p><b>정리 4.1.2.</b> 집합에 관한 분배법칙. 세 집합 A, B, C에 대하여 다음이 성립한다 \[A \cap (B \cup C) = (A \cap B) \cup (A \cap C)\]</p></div><span class="pos-span" id="pos51448"></span><h3>Sequences</h3><ul><li>시퀀스는 중복이 허용되는 요소들의 순서 있는 리스트로, 짧은 시퀀스는 보통 (a, b, c)처럼 괄호를 이용해 표현한다</li><li>λ ::= empty sequence</li><li>집합에 관한 데카르트 곱(Cartesian product)은 원소들의 시퀀스로 이루어진 집합을 생성한다</li><ul><li>e.g. 식[\mathbb{N}\times \{a, b\} = \{(0,a), (0, b), (1, a), (1, b), ...\}]식</li><li>식[\{a, b\}^3 = \{a, b\} \times \{a, b\} \times \{a, b\}]식</li></ul></ul><span class="pos-span" id="pos51449"></span><h3>Functions</h3><div><span class="pos-span" id="pos49443964"></span><h4 class="fake">Domains and Images</h4><ul><li>함수는 domain 집합의 원소를 codomain(공역) 집합의 원소로 할당하는 연산이다.\[f:A\rightarrow B\]</li><li>Partial function : domain 일부 원소에 대해 정의되지 않은 함수</li><p>domain에서 함수가 정의된 모든 원소의 집합을 함수의 support라고 한다</p><li>Total function : domain 모든 원소에 대해 정의된 함수</li><li>range(f) ::= f(domain(f))</li><p>range(치역)는 함수가 산출하는 모든 공역 원소들의 집합</p><li>image of S under f ::= f(S) where 식[S \subseteq A]식</li><p>domain의 부분집합 S에 대한 함수의 image(상)는 함수가 산출하는 codomain 원소들의 집합</p></ul><span class="pos-span" id="pos49443965"></span><h4 class="fake">Function Composition</h4><span class="pos-span" id="pos1472343055"></span><p><b>정의 4.3.1.</b> 두 함수 식[f:A\rightarrow B]식, 식[g:B\rightarrow C]식에 대한 합성함수 식[g\circ f]식는 다음과 같이 정의된다: \[\forall{x}\in A. (g\circ f)(x) ::= g(f(x))\]</p></div><span class="pos-span" id="pos51450"></span><h3>Binary Relations</h3><span class="pos-span" id="pos1472372846"></span><p><b>정의 4.4.1.</b> 이항 관계 R은 다음의 요소들로 구성된다. R의 domain A, R의 codomain B, 식[A \times B]식의 부분집합인 R의 그래프</p><ul><li>함수와 마찬가지로 식[R : A \rightarrow B]식로 표기한다</li><li>"a R b"는 R의 그래프에 원소 (a, b)가 존재함을 의미한다</li></ul><div><span class="pos-span" id="pos49444925"></span><h4 class="fake">Relation Diagrams</h4><p>domain 원소로부터 codomain 원소로 이어지는 화살표를 이용하여 이항 관계를 도식화할 수 있다</p><figure class="w3-center w3-margin-bottom"><img class="w3-round" src="/imgs/2022-05-20 170744.png" alt="Can't load image" loading="lazy"/><figcaption>&lt;이항 관계 도식 예></figcaption></figure><span class="pos-span" id="pos1472372877"></span><p><b>정의 4.4.2.</b> 이항관계 R은</p><ul><li>[≤1 arrow out] 속성을 가진 경우 function</li><li>[≥1 arrows in] 속성을 가진 경우 surjective</li><li>[≥1 arrows out] 속성을 가진 경우 total</li><li>[≤1 arrows in] 속성을 가진 경우 injective</li><li>[=1 arrows in], [=1 arrows out] 속성을 모두 가진 경우 bijective</li></ul><span class="pos-span" id="pos49444926"></span><h4 class="fake">Relational Images</h4><p>함수의 image 개념은 이항 관계로 바로 확장할 수 있다</p><span class="pos-span" id="pos-783788093"></span><p><b>정의 4.4.4.</b></p><ul><li>이항 관계 R에 대하여, domain A의 부분집합 Y에 대한 이항 관계의 image는 R(Y)로 표기하며, Y에 대하여 이항 관계가 산출하는 codomain 원소들의 집합을 의미한다</li><li>이항 관계의 치역, range(R)은 R(A)와 같다</li></ul><span class="pos-span" id="pos1472372970"></span><p><b>정의 4.4.5.</b> 이항 관계 식[R : A \rightarrow B]식의 역, 식[R^{-1}: B \rightarrow A]식는 다음을 만족하는 이항 관계다. \[b\ R^{-1}\ a \quad\text{IFF}\quad a\ R\ b\]</p><span class="pos-span" id="pos1472373001"></span><p><b>정의 4.4.6.</b></p><ul><li>B의 부분집합 X에 대한 inverse image는 식[R^{-1}(X)]식로 정의된다</li><li>support(R) = 식[R^{-1}(B)]식이며, R의 'domain of definition'이라고도 부른다</li></ul></div><span class="pos-span" id="pos51451"></span><h3>Finite Cardinality</h3><span class="pos-span" id="pos260793149"></span><p><b>Definition 4.5.1.</b> If A is a finite set, the cardinality(= size) |A| is the number of elements in A</p><span class="pos-span" id="pos260793180"></span><p><b>Definition 4.5.2.</b> Let A, B be sets. Then</p><ul><li>A surj B iff there is a surjective function from A to B</li><p>전사함수 ::= 공역과 치역이 동일</p><li>A inj B iff there is an injective total relation from A to B</li><p>단사함수 ::= 정의역의 서로 다른 원소는 공역의 서로 다른 원소에 대응</p><li>A bij B iff there is a bijection from A to B</li><p>전단사함수 ::= 정의역과 공역이 일대일 대응</p></ul><span class="pos-span" id="pos489790550"></span><p><b>정리 4.5.4.</b> [Mapping Rules] For finite sets A, B,</p><ul><li>A surj B iff |A| >= |B|</li><li>A inj B iff |A| &lt;= |B|</li><li>A bij B iff |A| = |B|</li></ul></div><h2>Induction</h2>139p<div><h3>Ordinary Induction</h3><h3>b Induction</h3><h3>b Inductions vs. Induction vs. Well Ordering</h3></div><h2>State Machines</h2><div><h3>States and Transitions</h3><h3>The Invariant Principle</h3><h3>Partial Correctness &amp; Termination</h3><h3>The Stable Marriage Problem</h3></div><h2>Recursive Data Types</h2><div><h3>Recursive Definitions and Structural Induction</h3><h3>Strings of Matched Brackets</h3><h3>Recursive Functions on Nonnegative Integers</h3><h3>Arithmetic Expressions</h3><h3>Games as a Recursive Data Type</h3><h3>Induction in Computer Science</h3></div><h2>Infinite Sets</h2><div><h3>Infinite Cardinality</h3><h3>The Halting Problem</h3><h3>The Logic of Sets</h3><h3>Does All This Really Work?</h3></div></div><p class="fake-h1">II. Structures</p><hr><div><p class="fake-h2">Introduction</p><h2>Number Theory</h2><div><h3>Divisibility</h3><h3>The Greatest Common Divisor</h3><h3>Prime Mysteries</h3><h3>The Fundamental Theorem of Arithmetic</h3><h3>Alan Turing</h3><h3>Modular Arithmetic</h3><h3>Remainder Arithmetic</h3><h3>Turing's Code (Version 2.0)</h3><h3>Multiplicative Inverses and Cancelling</h3><h3>Euler's Theorem</h3><h3>RSA Public Key Encryption</h3><h3>What has SAT got to do with it?</h3><h3>Problems</h3></div><h2>Directed graphs &amp; Partial Orders</h2><div><h3>Vertex Degrees</h3><h3>Walks and Paths</h3><h3>Adjacency Matrices</h3><h3>Walk Relations</h3><h3>Directed Acyclic Graphs &amp; Scheduling</h3><h3>Partial Orders</h3><h3>Representing Partial Orders by Set Containment</h3><h3>Linear Orders</h3><h3>Product Orders</h3><h3>Equivalence Relations</h3><h3>Summary of Relational Properties</h3><h3>Problems</h3></div><h2>Communication Networks</h2><div><h3>Routing</h3><h3>Routing Measures</h3><h3>Network Designs</h3></div><h2>Simple Graphs</h2><div><h3>Vertex Adjacency and Degrees</h3><h3>Sexual Demographics in America</h3><h3>Some Common Graphs</h3><h3>Isomorphism</h3><h3>Bipartite Graphs &amp; Matchings</h3><h3>Coloring</h3><h3>Walks in Simple Graphs</h3><h3>Connectivity</h3><h3>Special Walks and Tours</h3><h3>k-connected Graphs</h3><h3>Forests &amp; Trees</h3><h3>Problems</h3></div><h2>Planar Graphs</h2><div><h3>Drawing Graphs in the Plane</h3><h3>Definitions of Planar Graphs</h3><h3>Euler's Formula</h3><h3>Bounding the Number of Edges in a Plannar Graph</h3><h3>Returning to 식[K_5]식 and 식[K_{3,3}]식</h3><h3>Coloring Planar Graphs</h3><h3>Classifying Polyhedra</h3><h3>Another Characterization for Planar Graphs</h3></div></div><p class="fake-h1">III. Counting</p><hr><div><p class="fake-h2">Introduction</p><h2>Sums and Asymptotics</h2><div><h3>The Value of an Annuity</h3><h3>Sums of Powers</h3><h3>Approximating Sums</h3><h3>Hanging Out Over the Edge</h3><h3>Products</h3><h3>Double Trouble</h3><h3>Asymptotic Notation</h3></div><h2>Cardinality Rules</h2><div><h3>Counting One Thing by Counting Another</h3><h3>Counting Sequences</h3><h3>The Generalized Product Rule</h3><h3>The Division Rule</h3><h3>Counting Subsets</h3><h3>Sequences with Repetitions</h3><h3>Counting Practice: Poker Hands</h3><h3>The Pigeonhole Principle</h3><h3>Inclusion-Exclusion</h3><h3>Combinatorial Proofs</h3><h3>Problems</h3></div><h2>Generating Functions</h2><div><h3>Infinite Series</h3><h3>Counting with Generating Functions</h3><h3>Partial Fractions</h3><h3>Solving Linear Recurrences</h3><h3>Formal Power Series</h3><h3>Problems</h3></div></div><p class="fake-h1">IV. Probability</p><hr><div><p class="fake-h2">Introduction</p><h2>Events and Probability Spaces</h2><div><h3>Let's Make a Deal</h3><h3>The Four Step Method</h3><h3>Strange Dice</h3><h3>The Birthday Principle</h3><h3>Set Theory and Probability</h3><h3>Problems</h3></div><h2>Conditional Probability</h2><div><h3>Month Hall Confusion</h3><h3>Definition and Notation</h3><h3>The Four-Step Method for Conditional Probability</h3><h3>Why Tree Diagrams Work</h3><h3>The Law of Total Probability</h3><h3>Simpson's Paradox</h3><h3>Independence</h3><h3>Mutual Independence</h3><h3>Probability versus Confidence</h3></div><h2>Random Variables</h2><div><h3>Random Variable Examples</h3><h3>Independence</h3><h3>Distribution Functions</h3><h3>Great Expectations</h3><h3>Linearity of Expectation</h3></div><h2>Deviation from the Mean</h2><div><h3>Markov's Theorem</h3><h3>Chebyshev's Theorem</h3><h3>Properties of Variance</h3><h3>Estimation by Random Sampling</h3><h3>Confidence in an Estimation</h3><h3>Sums of Random Variables</h3><h3>Really Great Expectations</h3></div><h2>Random Walks</h2><div><h3>Gambler's Ruin</h3><h3>Random Walks on Graphs</h3></div></div><p class="fake-h1">V. Recurrences</p><hr><div><p class="fake-h2">Introduction</p><h2>Recurrences</h2><div><h3>The Towers of Hanoi</h3><h3>Merge Sort</h3><h3>Linear Recurrences</h3><h3>Divide-and-Conquer Recurrences</h3><h3>A Feel for Recurrences</h3></div></div></article></main></body></html>