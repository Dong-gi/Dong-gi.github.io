<html lnag="ko"><meta charset="UTF-8"><meta name="viewport"content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name="google-site-verification"content="aH-DyzdytYQ0NPHNQFcs5dVoiu5YNs6CEEHYgqDmAFM"><meta name="author"content="Donggi Kim &lt;hi.donggi@gmail.com&gt;"><meta name="keywords"content="Docker"><meta name="description"content="Docker 정리"><title>Docker</title><link id="w3css"rel="stylesheet"href="/source/w3.css"><link id="highlight-style"rel="stylesheet"href="/source/xcode.css"><link id="default-style"rel="stylesheet"href="/source/default.css"><script id="highlight-js"src="/source/highlight.pack.js"></script><script id="default-js"src="/source/default.min.js"></script><script id="dsq-count-scr"src="//donggi.disqus.com/count.js"async></script><script id="google-analytics"src="https://www.googletagmanager.com/gtag/js?id=UA-143098403-1"async></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-143098403-1")</script><div id="sidebar"class="w3-bar-block w3-sidebar w3-animate-left"><hr><a href="javascript:closeSidebar();"class="w3-bar-item w3-button">Close &times;</a><hr><div id="marker-list"></div><hr><div id="post-list"><details open=""id="dir-1627423780"class="w3-small file-list"title="카테고리"><summary>카테고리</summary><ul><details id="dir--1093871206"class="w3-small file-list"title="카테고리/.NET"open=""><summary>/.NET</summary><ul><li><a href="/posts/dotnet/csharp_basic.html">C# 기초</a><li><a href="/posts/dotnet/csharp_library.html">C# 라이브러리</a><li><a href="/posts/dotnet/wpf_basic.html">WPF 기초</a></ul></details><details id="dir-1275489025"class="w3-small file-list"title="카테고리/단일 주제"open=""><summary>/단일 주제</summary><ul><li><a href="/posts/single/sdkman.html">SDKMAN; The Software Development Kit Manager</a></ul></details><details id="dir-992513986"class="w3-small file-list"title="카테고리/독서"open=""><summary>/독서</summary><ul><li><a href="/posts/book/001.html">1만 시간의 재발견</a><li><a href="/posts/book/002.html">마음의 탄생</a><li><a href="/posts/book/003.html">생각하는 삶을 위한 철학의 역사</a><li><a href="/posts/book/004.html">쇼펜하우어, 돌이 별이 되는 철학</a><li><a href="/posts/book/005.html">인생의 모든 의미</a><li><a href="/posts/book/009.html">인지 편향</a><li><a href="/posts/book/006.html">지식의 착각</a><li><a href="/posts/book/007.html">키르케고르 실존 극장</a><li><a href="/posts/book/008.html">Gamification by Design</a></ul></details><details id="dir-453420171"class="w3-small file-list"title="카테고리/알고리즘"open=""><summary>/알고리즘</summary><ul><li><a href="/posts/algorithm/book01.html">『알고리즘 도감』</a><li><a href="/posts/algorithm/linear_algebra.html">선형대수</a><li><a href="/posts/algorithm/algo.html">알고리즘 일반</a><li><a href="/posts/algorithm/probability.html">확률</a></li><details id="dir--1451989604"class="w3-small file-list"title="카테고리/알고리즘/KOREATECH"open=""><summary>/KOREATECH</summary><ul><li><a href="/posts/algorithm/koreatech/1003.html">1003: 0을 만들자</a><li><a href="/posts/algorithm/koreatech/1008.html">1008: 순환 소수</a><li><a href="/posts/algorithm/koreatech/1018.html">1018: 문자열 거리 최소화 하기</a><li><a href="/posts/algorithm/koreatech/1048.html">1048: AP 배분</a><li><a href="/posts/algorithm/koreatech/1095.html">1095: 자연스러운 정렬</a><li><a href="/posts/algorithm/koreatech/1034.html">1034,1041: 최소 이동 거리</a><li><a href="/posts/algorithm/koreatech/1011.html">동적계획법(DP) 문제</a><li><a href="/posts/algorithm/koreatech/1010.html">소수(Prime) 관련 문제</a></ul></details></ul></details><details id="dir-1817032068"class="w3-small file-list"title="카테고리/작성 중지"open=""><summary>/작성 중지</summary><ul><li><a href="/posts/algorithm/ai.html">AI</a></ul></details></ul></details></div><hr><div id="file-list"></div><hr></div><div id="main"><div id="nav"style="position:-webkit-sticky;position:sticky;top:0;vertical-align:middle"class="w3-bar w3-blue w3-large"><button onclick="toggleSidebar()"class="w3-bar-item w3-button w3-hover-theme">&#9776;</button><input id="query"placeholder="search"class="w3-bar-item"></div><div id="contents"class="w3-padding"><h1 class="marker">시작하기</h1><ol><li>도커 엔진(Apache 2.0 license)은 REST API로 통신하는 서버-클라이언트로 구성된다<li class="marker">Docker daemon</li><p>도커 서버는 오랫동안 실행되는 dockerd 데몬 프로세스로, Docker object들을 관리한다</p><li class="marker">Docker client</li><p>CLI 클라이언트로 docker 커맨드가 사용된다. 도커 서버, 클라이언트는 서로 별개의 호스트에서 작동할 수 있다</p><li>Docker registry</li><p>이미지 저장소.<a class="w3-btn w3-round w3-round-xxlarge w3-small w3-green"target="_blank"href="https://hub.docker.com/">Docker Hub</a>는 누구나 이용할 수 있는 퍼블릭 레지스트리로, 도커에서 기본적으로 검색하는 저장소다<p>Private registry 생성<div lan="shell"class="as-code code-div w3-leftbar w3-border-green">docker service create --name registry -p 5000:5000 registry</div><li>Docker object</li><p>IMAGE : 컨테이너를 작성하는 절차를 담은 읽기 전용 템플릿<br>CONTAINER : 실행 가능한 IMAGE 인스턴스<br><a class="w3-btn w3-round w3-round-xxlarge w3-small w3-green"target="_blank"href="https://docs.docker.com/engine/reference/builder/">Dockerfile</a> : 이미지 빌드 절차</ol><h1 class="marker">Dockerfile</h1><ul><li class="marker">Format</li><ul><li># 주석<li>INSTRUCTION param...</li><p>INSTRUCTION은 대소문자 구별이 없지만, 관례적으로 대문자만 사용한다</ul><li class="marker">Directive</li><ul><li># directive=value 형태의 특별한 주석</li><p>directive가 아닌 줄을 읽으면 더 이상 directive를 찾지 않으므로, Dockerfile의 최상단에 있어야 한다.</p><li># syntax=[remote image reference]</li><p>Buildkit을 이용하는 경우 유효</p><li># escape=`</li><p>기본값은 \</ul><li class="marker">환경 변수</li><ul><li>환경 변수 참조1 : $var_name 또는 ${var_name}<li>환경 변수 참조2 : ${var_name:-word}</li><p>환경 변수가 없다면 word가 사용된다. word는 임의의 문자열이며, 다른 환경변수를 포함할 수도 있다</p><li>환경 변수 참조3 : ${var_name:+word}</li><p>환경 변수가 있다면 word가 사용된다. 없으면 빈 문자열. word는 임의의 문자열이며, 다른 환경변수를 포함할 수도 있다</p><li>환경 변수 설정 : ENV key=value 또는 ENV key value<li>환경 변수 지원 명령어 : ADD, COPY, ENV, EXPOSE, FROM, LABEL, STOPSIGNAL, USER, VOLUME, WORKDIR, ONBUILD(Since 1.4)</ul><li class="marker">FROM</li><ul><li>FROM &lt;image>[:&lt;tag>] [AS &lt;name>]<li>FROM &lt;image>[@&lt;digest>] [AS &lt;name>]<li>한 Dockerfile 내에서 FROM을 여러 번 사용할 수 있다 : 여러 중간 이미지 + 최종 이미지</ul><li class="marker">RUN</li><ul><li>RUN &lt;command></li><p>쉘(기본값 /bin/sh -c, SHELL 명령으로 변경 가능)로 실행. \로 여러 줄 작성 가능</p><li>RUN ["executable", "param1", "param2"]</li><p>JSON 배열로 파싱되어 실행에 이용된다. 반드시 "로 감싸야 하며, \ 이스케이핑에 주의해야 한다</p><li>RUN apt-get update와 apt-get install은 항상 한 번에 실행할 것</li><div lan="text"class="as-code code-div w3-leftbar w3-border-green">RUN apt-get update && apt-get install -y \ package-bar \ package-foo=1.3.* \</div><li>RUN rm -rf /var/lib/apt/lists/*, RUN apt-get clean 등으로 캐시를 지워주면 용량에 좋다</ul><li class="marker">CMD</li><ul><li>CMD ["executable", "param1", "param2"]</li><p>JSON 배열로 파싱되어 실행에 이용된다</p><li>CMD command param1 param2</li><p>쉘로 실행</p><li>CMD의 목적은 컨테이너 실행 시 기본값을 제공하는 것으로, Dockerfile내에서 여러 번 작성됐더라도 마지막 것만 사용된다. 항상 동일하게 실행된다면 ENTRYPOINT 사용을 고려</li><p>docker run 인자로 명시하는 경우, CMD를 오버라이딩한다</ul><li class="marker">ENTRYPOINT</li><ul><li>ENTRYPOINT ["executable", "param1", "param2"]</li><p>JSON 배열로 파싱되어 실행에 이용된다. CMD는 ENTRYPOINT의 매개변수로 뒤에 덧붙여진다</p><li>ENTRYPOINT command param1 param2</li><p>쉘 실행. CMD directive와 docker run 매개변수를 모두 무시한다. 컨테이너의 실행은 docker exec을 통해 이루어져야 한다.</ul><li class="marker">LABEL</li><ul><li>LABEL &lt;key>=&lt;value></li><p>이미지 메타데이터 설정. 공백이 필요하다면 "로 감싸면 된다. LABEL 하나에 여러 값을 설정하는 것은 이미지 크기에 영향을 미치지 않는다(Since 1.10)</ul><li class="marker">EXPOSE</li><ul><li>EXPOSE &lt;port>[/&lt;protocol>]...</li><p>리스닝하는 포트들을 명시한다(여기서 개방해주는 것은 아님). 프로토콜 기본값은 TCP. 실제 포트를 개방하기 위해서는 docker run에서 -p 옵션으로 포워딩 설정</ul><li class="marker">ADD</li><ul><li>ADD [--chown=&lt;user>:&lt;group>] &lt;src>... &lt;dest><li>ADD [--chown=&lt;user>:&lt;group>] ["&lt;src>",... "&lt;dest>"]</li><p>경로에 공백이 있는 경우 " 이용</p><li>dest로 파일들을 복사한다. 파일명 이스케이핑, 와일드카드 사용은 Go 언어 규칙을 따른다. chown이 주어지지 않으면 UID, GID 모두 0으로 설정된다. 유저와 그룹을 직접 ID로 지정한 경우, /etc/passwd, /etc/group 파일을 조사하지 않는다<li>src가 원격지 파일 URL인 경우, 복사된 파일의 권한은 600. 인증이 필요한 경우 wget, crul 등을 이용.<li>컨텍스트 안의 파일들만 데몬으로 전송되므로, src는 "../something"처럼 컨텍스트 밖의 파일을 가리킬 수 없다.<li>src가 컨텍스트 내의 tar 압축 파일인 경우, 디렉터리로 압축 해제된다<li>dest가 존재하지 않는 경우, 모든 필요한 디렉터리를 생성한다</ul><li class="marker">COPY</li><ul><li>COPY [--chown=&lt;user>:&lt;group>] &lt;src>... &lt;dest><li>COPY [--chown=&lt;user>:&lt;group>] ["&lt;src>",... "&lt;dest>"]</li><p>경로에 공백이 있는 경우 " 이용</p><li>ADD보다 제한됨 : 컨테이너 내부 파일만 복사 가능. 로컬 tar 자동 압축 해제 X</li><p>중간 이미지로부터 복사 예 : COPY --from=build /bin/project /bin/project</ul><li class="marker">VOLUME</li><ul><li>예. VOLUME /var/log /var/db</li><p>Mount point를 정의한다. 호스트나 다른 컨테이너에 마운트되어 공유될 수 있다. VOLUME 선언 이후 해당 볼륨 내 변경은 무시된다. Dockerfile 내부에서 마운트될 호스트 디렉터리를 지정할 수는 없다 → 컨테이너 생성 시 지정해야 한다.</ul><li class="marker">WORKDIR</li><ul><li>예. WORKDIR /path/to/workdir</li><p>RUN, CMD, ENTRYPOINT, COPY, ADD의 작업 디렉터리를 설정한다</ul><li class="marker">ARG</li><ul><li>ARG &lt;name>[=&lt;default value>]</li><p>docker build --build-arg &lt;varname>=&lt;value>로 넘겨받는 변수를 선언한다. docker history로 넘긴 변수를 볼 수 있으므로, 비밀 정보를 이를 통해 넘기는 건 부적절하다.</p><li>ARG는 빌드 단계에서만 유효하며, 새로운 FROM 이후엔 새로 선언해야 한다</ul><li class="marker">ONBUILD</li><ul><li>ONBUILD [INSTRUCTION]</li><p>이미지가 베이스로 이용되는 경우, 마치 FROM 이후에 바로 삽입된 것처럼 실행된다</ul><li class="marker">SHELL</li><ul><li>SHELL ["executable", "param1", "param2"]<li>RUN, CMD, ENTRYPOINT 기본 쉘 변경</ul></ul><h1 class="marker"><a class="w3-btn w3-round w3-round-xxlarge w3-small w3-green"target="_blank"href="https://docs.docker.com/engine/reference/commandline/docker/">Commands</a></h1><div><h2 class="marker">docker build [OPTIONS] PATH | URL | -</h2><div lan="shell"class="as-code code-div w3-leftbar w3-border-green">docker image build [OPTIONS] PATH | URL | - # 와 동일</div><ol><li>향상된 기능을 제공하는 moby/buildkit을 이용하려면(Since 18.09) 실행 전에 환경 변수 DOCKER_BUILDKIT=1를 설정하면 된다<li>빌드 과정에서 "컨텍스트"란 지정된 PATH | URL에 존재하는 파일들을 의미한다. 빌드 과정에서 컨텍스트 임의의 파일을 참조할 수 있다</li><p>.dockerignore 파일을 통해 컨텍스트에서 파일/디렉터리들을 제외할 수 있다</p><li>URL은 다음 중 하나가 될 수 있다 : Git 저장소, pre-packaged tarball, plain text file</li><ul><li><div lan="shell"class="as-code code-div w3-leftbar w3-border-green">docker build https://github.com/docker/rootfs.git#container:docker # container 브랜치의 docker 디렉터리 지정</div></li><p>Git 저장소를 가리키는 경우, 해당 저장소의 서브모듈까지 재귀적으로 가져온다<table class="no-sort"><tr><th>Build Syntax Suffix<th>Commit Used<th>Build Context Used<tr><td>myrepo.git<td>refs/heads/master<td>/<tr><td>myrepo.git#mytag<td>refs/tags/mytag<td>/<tr><td>myrepo.git#mybranch<td>refs/heads/mybranch<td>/<tr><td>myrepo.git#pull/42/head<td>refs/pull/42/head<td>/<tr><td>myrepo.git#:myfolder<td>refs/heads/master<td>/myfolder<tr><td>myrepo.git#master:myfolder<td>refs/heads/master<td>/myfolder<tr><td>myrepo.git#mytag:myfolder<td>refs/tags/mytag<td>/myfolder<tr><td>myrepo.git#mybranch:myfolder<td>refs/heads/mybranch<td>/myfolder</table><li><div lan="shell"class="as-code code-div w3-leftbar w3-border-green">docker build http://server/context.tar.gz</div></li><p>표준 tar 포맷이어야 한다. 압축 기법은 xz, bzip2, gzip, identity 중 하나</p><li><div lan="shell"class="as-code code-div w3-leftbar w3-border-green">docker build - &lt; Dockerfile # STDIN 입력</div></li><div lan="shell"class="as-code code-div w3-leftbar w3-border-green">curl example.com/remote/Dockerfile | docker build -f - .</div></ul><li>--build-arg : 빌드 환경변수 설정<li>--compress : 컨텍스트 gzip 압축<li>--disable-content-trust true : 이미지 검증 생략<li>--file, -f : Dockerfile 파일명. 기본값은 'PATH/Dockerfile'<li>--label : 이미지 메타데이터 설정<li>--tag, -t : 이미지 태그 설정</ol><h2 class="marker">docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</h2><ol><li>컨테이너의 변경사항이 반영된 새 이미지를 만든다<li>--author, -a : 저자<li>--change, -c : 새 이미지에 적용할 INSTRUCTION 추가</li><div lan="shell"class="as-code code-div w3-leftbar w3-border-green">docker commit --change "ENV DEBUG true" c3f279d17e0a svendowideit/testimage:version3</div><li>--message, -m : 커밋 메시지<li>--pause, -p : 커밋 도중 컨테이너 일시 정지(default true)</ol><h2 class="marker">docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]</h2><ol><div lan="shell"class="as-code code-div w3-leftbar w3-border-green">docker tag 0e5574283393 fedora/httpd:version1.0</div><li>Docker Hub로 올리려는 경우, &lt;Docker Hub Id>/&lt;Repository Name>:&lt;tag></li><div lan="shell"class="as-code code-div w3-leftbar w3-border-green">docker tag bulletinboard:1.0 gordon/bulletinboard:1.0</div><li>Private repository로 푸시하려면 해당 주소를 붙여줘야 한다</li><div lan="shell"class="as-code code-div w3-leftbar w3-border-green">docker tag 0e5574283393 myregistryhost:5000/fedora/httpd:version1.0</div></ol><h2 class="marker">docker push [OPTIONS] NAME[:TAG]</h2><div lan="shell"class="as-code code-div w3-leftbar w3-border-green">docker image push [OPTIONS] NAME[:TAG] # 와 동일</div><ol><li>이미지를 저장소로 업로드한다. 올바른 이미지 태그에 대해서는 docker tag 명령 참고</ol><h2 class="marker">docker run [OPTIONS] IMAGE[:TAG|@DIGEST] [COMMAND] [ARG...]</h2><div lan="shell"class="as-code code-div w3-leftbar w3-border-green">docker container run [OPTIONS] IMAGE[:TAG|@DIGEST] [COMMAND] [ARG...] # 와 동일</div><ol><li>새 컨테이너를 만들고(create) 실행(start)한 뒤, 그 안에서 명령을 실행한다<li>--publish, -p : 포트 포워딩. -p 80:8080, -p 8888:8080/tcp<li>--detach, -d : 지정한 경우 백그라운드 실행. 커맨드가 리턴하면 컨테이너도 종료.</li><p>-d를 지정하지 않은 경우(default) 포그라운드로 실행되며, STDIN, STDOUT, STDERR가 콘솔에 연결된다(default).</p><li>-it : -i(--interactive, STDIN 계속 열어두기) + -t(-tty, Pseudo-tty 할당)<li>--name : 컨테이너 이름 할당. 지정하지 않는 경우 docker 데몬이 랜덤하게 할당<li>--pid : 기본적으로 각 컨테이너는 별개의 프로세스 네임스페이스에서 실행된다.</li><p>--pid=host, --pid="container:&lt;name|id>"를 이용해 네임스페이스 공유 가능</p><li>--network="" : bridge(default), none, container:&lt;name|id>, host(빠름)</li><p>host : --mac-address 무효<br>container : --add-host, --hostname, --dns, --dns-search, --dns-option, --mac-address, --publish, --publish-all, --expose 무효</p><li>--add-host="" : host:IP형식으로 적으면 /etc/hosts에 추가한다<li>--ip="", --ip6="", --mac-address="" : 주소 할당<li>--restart : no(default), on-failure[:max-retries](0이 아닌 상태로 종료된 경우 재시작), always(항상 재시작), unless-stopped(명시적으로 stop하기 전까지 항상 재시작)<li>--rm : 컨테이너 종료 시 삭제<li>--memory="", -m : 메모리 제한. 최소 4m<li>--stop-timeout : 지정 시간 경과 뒤 종료<li>--privileged : 컨테이너에 모든 커널 작업 권한 부여</ol><div><h3 class="marker">Dockerfile 오버라이딩</h3><ol><li>CMD : r run [OPTIONS] IMAGE[:TAG|@DIGEST] [COMMAND] [ARG...]<li>ENTRYPOINT : --entrypoint=""</li><div lan="shell"class="as-code code-div w3-leftbar w3-border-green">--entrypoint /bin/bash example/redis -c ls -l</div><li>EXPOSE(incoming port) : --expose=[]<li>ENV : -e, --env, --env-file</li><div lan="shell"class="as-code code-div w3-leftbar w3-border-green">-e "deep=purple" -e today # 값을 지정하지 않으면 현재 값이 전파된다</div><li>VOLUME : -v, --volume=[host-src:]container-dest[:&lt;options>]<li>USER : -u="", --user=""<li>WORKDIR : -w=""</ol></div><h2 class="marker">docker rm [OPTIONS] CONTAINER [CONTAINER...]</h2><div lan="shell"class="as-code code-div w3-leftbar w3-border-green">docker container rm [OPTIONS] CONTAINER [CONTAINER...] # 와 동일</div><ol><li>도커 컨테이너 제거</li><p>docker rm $(docker ps -a -q) # 중지한 모든 컨테이너 제거</p><li>--force, -f : 실행 중인 컨테이너 중지 후 제거<li>--link, -l : 링크 제거<li>--volumes, -v : 볼륨 제거</ol><h2 class="marker">파일 복사</h2><ol><li>docker-machine scp</li><div lan="shell"class="as-code code-div w3-leftbar w3-border-green">docker-machine scp source destination # 예. 파일을 가상 머신으로 복사 docker-machine scp /root/file.war devvm:/home/docker/ # 예. 디렉터리 복사 docker-machine scp -r /root/directory/ devvm:/home/docker/</div><li>docker cp</li><div lan="shell"class="as-code code-div w3-leftbar w3-border-green">docker cp source destination # 예. 파일을 컨테이너로 복사 docker cp file.war web:/usr/local/tomcat/webapps/ # 예. 디렉터리 복사 docker cp directory/ web:/root/</div></ol><h2 class="marker">docker ps [OPTIONS]</h2><ol><li>컨테이너 리스트<li>--all, -a : 실행중이지 않은 컨테이너도 표시<li>--filter, -f : 필터링 옵션은 https://docs.docker.com/engine/reference/commandline/ps/#filtering 참고<li>--format : Go 템플릿 포맷. https://docs.docker.com/engine/reference/commandline/ps/#formatting 참고</li><div lan="shell"class="as-code code-div w3-leftbar w3-border-green">docker ps --format "{{.ID}}: {{.Command}}"</div><li>--size, -s : 전체 파일 크기 표시</ol><h2 class="marker">docker images [OPTIONS] [REPOSITORY[:TAG]]</h2><ol><li>이미지 리스트<li>--all, -a : 중간 이미지도 표시<li>--digests : Digest 표시</ol><h2 class="marker">docker start [OPTIONS] CONTAINER [CONTAINER...]</h2><div lan="shell"class="as-code code-div w3-leftbar w3-border-green">docker container start [OPTIONS] CONTAINER [CONTAINER...] # 와 동일</div><h2 class="marker">docker search [OPTIONS] TERM</h2><ol><li>Docker Hub 이미지 검색<li>--filter stars=3 : 최소 3성 이상<li>--filter "is-official=true" : 공식 이미지만</ol><h2 class="marker">docker pull [OPTIONS] NAME[:TAG|@DIGEST]</h2><p>저장소로부터 이미지 다운로드<div lan="shell"class="as-code code-div w3-leftbar w3-border-green">docker pull ubuntu:14.04 docker pull ubuntu@sha256:45b23dee08af5e43a7fea6c4cf9c25ccf269ee113168c19722f87876677c5cb2 docker pull myregistry.local:5000/testing/test-image</div><h2 class="marker">docker rmi [OPTIONS] IMAGE [IMAGE...]</h2><p>이미지 제거<h2 class="marker">docker attach [OPTIONS] CONTAINER</h2><ol><li>docker container attach [OPTIONS] CONTAINER<li>STDIN, STDOUT, STDERR를 실행 중인 컨테이너에 연결한다<li>--detach-keys : 스트림 연결 해제 키 재설정</li><p>-it 옵션으로 실행중이라면, Ctrl + P, Ctrl + Q로 컨테이너를 정지하지 않고 나올 수 있다</p><li>--no-stdin : STDIN은 연결하지 않음</ol><h2 class="marker">docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</h2><div lan="shell"class="as-code code-div w3-leftbar w3-border-green">docker container exec [OPTIONS] CONTAINER COMMAND [ARG...] # 와 동일</div><ol><li>컨테이너 안에서 명령을 실행한다</li><div lan="shell"class="as-code code-div w3-leftbar w3-border-green">docker exec -it tomcat /bin/bash</div><li>--detach, -d : 백그라운드로 실행시킨다<li>--env, -e : 환경 변수 설정 Since 1.25<li>--workdir, -w : 워킹 디렉터리 설정 Since 1.35</ol></div><h1 class="marker">컨테이너 오케스트레이션</h1><div><h2 class="marker">Kubernetes; K8s</h2><p>Empty<h2 class="marker">Swarm</h2><div lan="text"class="as-code code-div w3-leftbar w3-border-green">docker swarm init docker service create --name demo alpine:3.5 ping 1.1.1.1 docker service ps docker service logs demo docker service rm demo # docker service scale</div></div></div><hr>&copy; 2020. <a href="mailto:hi.donggi@gmail.com">Donggi Kim</a> all rights reserved.<a class="w3-btn w3-round w3-round-xxlarge w3-small w3-green"href="/LICENSE"target="_blank">/LICENSE</a></div>