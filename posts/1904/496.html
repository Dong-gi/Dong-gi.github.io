<strong>시작하기</strong><br>
<ul>
    템플릿은 임의의 텍스트 파일이 될 수 있으며, HTML로 한정되지 않는다.<br>
    출력 텍스트의 아래 요소들은 FreeMarker에서 처리되고, 나머지는 있는 그대로 출력된다.
    <li>${...} : FreeMarker는 출력 텍스트에서 이 부분을 중괄호 안 표현식의 값으로 치환한다. Interpolation이라고 부른다.</li>
    
    <li>FTL(FreeMarker Template Language) 태그 = directive : HTML 태그와 유사하지만, #으로 시작한다. 사용자 정의 태그는 @으로 시작한다. 출력에 포함되지 않는다.</li>
    Directive 예 : &lt;#if&gt;, &lt;#elseif&gt;, &lt;#else&gt;, ...
    
    <li>주석 : &lt;#-- --&gt;. HTML 주석과 다르게 출력에 포함되지 않는다.</li>
    
    <li>Built-in : FreeMarker 데이터 모델이 지원하는 메서드.</li>
    Built-in 예 : ?upper_case, ?length, ?size, ...
</ul>

<hr>

Undefined Variable Error 방지.
<ul>
    FreeMarker는 null 예외나 찾을 수 없는 식별자 예외를 동일하게 "undefined variable" error를 발생시킨다.
    <li>기본값 설정 : !</li>
    예. name이 설정되지 않았으면 "Anonymous"를 대신 출력 » ${name!"Anonymous"}
    
    <li>존재 여부 확인 : ??</li>
    예. name이 설정된 경우에만 실행 » &lt;#if name??&gt;Hello ${name}!&lt;/#if&gt;

    <li>검사 범위 설정 : ()</li>
    a.b.c! 또는 a.b.c??는 c의 존재 여부만 체크하지만, (a.b.c)! 또는 (a.b.c)??는 데이터 모델 구조상 모든 노드의 존재 여부를 체크한다.
</ul>

<hr>

이스케이프
<ul>
    <li>적절히 설정되었다면 ${...}을 통해 출력되는 &amp;, &lt;, &gt;, &quot;, &#39; 등은 자동으로 이스케이프 처리된다.</li>
    <li>.ftlh 파일을 이용하면 HTML에 맞추어 자동으로 이스케이프 처리된다.</li>
    <li>.ftlx 파일을 이용하면 XML에 맞추어 자동으로 이스케이프 처리된다.</li>
</ul>

<hr>
<strong>타입</strong>
<ul>
    <li>Scalar</li>
    <ul>
        <li>String : 문자열 리터럴은 "", '' 둘 다 이용 가능.</li>
        <li>Number : 단일 숫자 타입을 이용하기 때문에, 3/2가 1로 평가되는 일은 없다.</li>
        <li>Boolean : true or false</li>
        <li>Date : Date | Time | Date-time</li>
    </ul>

    <li>Container</li>
    <ul>
        <li>Hash : (String 키, 임의 값) 쌍 저장.</li>
        <li>Sequence : 요소들을 일렬로 저장. 0부터 시작하는 인덱스 존재. 요소들의 타입을 같지 않아도 된다.</li>
        Hash인 동시에 Sequence일 수 있다.
        <li>Collection : 제한된 sequence로 크기에 접근할 수 없고, 인덱스 참조도 안 되지만 &lt;#list&gt;에 이용될 수 있다.</li>
    </ul>

    <li>Subroutines</li>
    <ul>
        <li>FreeMarker에서 method/function은 일급 객체다.</li>
        <li>사용자 정의 directive 역시 subroutine이며, 일급 객체다.</li>
    </ul>
</ul>

<hr>

<strong>템플릿</strong> - 구문
<ul>
    <li>리터럴</li>
    <ul>
        <li>문자열 : "", '' 모두 가능. 이스케이핑 가능(유니코드 : \xXXXX). Raw string 표현을 위해 접두 문자 'r' 사용 가능(예. ${r"C:\Program Files\"})</li>
        <li>숫자 : 10진수 표현만 가능. 지수 표현 불가능. 소수점 앞 '0' 생략 불가능.</li>
        <li>Boolean : true, false</li>
        <li>Sequence : [] 안에 각 표현식을 콤마로 구분한다. ["foo", "bar", 123.45, [name, 1+1]]</li>        
        <li>Range</li>
        Range 표현식 자체가 []를 포함하지는 않는다. 할당하고자 할 때는 [] 안에 range 표현식을 작성해야 한다.
        <ul>
            <li>start .. end</li>
            1..4 → [1, 2, 3, 4]<br>
            4..1 → [4, 3, 2, 1]

            <li>start ..&lt; end or start ..! end</li>
            1..&lt;4 → [1, 2, 3]<br>
            4..&lt;1 → [4, 3, 2]

            <li>start ..* length Since 2.3.21</li>
            10..*4 → [10, 11, 12, 13]<br>
            10..*-4 → [10, 9, 8, 7]

            <li>start ..</li>
            1.. → [1, 2, 3, ...]
        </ul>
        <li>Hash : {"key": "value", keyStringExpression: valueExpression}</li>
    </ul>

    <li>변수 참조</li>
    <ul>
        <li>Top-level variables: user</li>
        <li>Hash: user.name, user["name"]</li>
        <li>Sequence: products[5]</li>
        <li>Object: .variable_name</li>
    </ul>

    <li>문자열 연산</li>
    <ul>
        <li>Interpolation and concatenation: "Hello ${user}!" or "Hello " + user + "!"</li>
        문자열 내부에서 Interpolation이 이용되는 경우, 자동 이스케이핑 대상에서 제외된다.<br>
        두 경우 모두 로캐일 설정에 의해 변화된다. 로캐일과 무관하게 처리하려면 "someUrl?id=" + id?c 처럼 ?c를 붙인다.
        
        <li>Getting a character: name[0]</li>
        <li>String slice: Inclusive end: name[0..4], Exclusive end: name[0..<5], Length-based (lenient): name[0..*5], Remove
                starting: name[5..]</li>
    </ul>
    <li>Sequence operations</li>
    <ul>
        <li>Concatenation: users + ["guest"]</li>
        <li>Sequence slice: Inclusive end: products[20..29], Exclusive end: products[20..<30], Length-based (lenient):
                products[20..*10], Remove starting: products[20..]</li> <li>Hash operations</li>
    </ul>
    <ul>
        <li>Concatenation: passwords + { "joe": "secret42" }</li>
        <li>Arithmetical calculations: (x * 1.5 + 10) / 2 - y % 100</li>
        <li>Comparison: x == y, x != y, x < y, x> y, x >= y, x <= y, x lt y, x lte y, x gt y, x gte y, ...etc.</li> <li>
                    Logical operations: !registered && (firstVisit || fromEurope)</li>
        <li>Built-ins: name?upper_case, path?ensure_starts_with('/')</li>
        <li>Method call: repeat("What", 3)</li>
        <li>Missing value handler operators:</li>
    </ul>
    <ul>
        <li>Default value: name!"unknown" or (user.name)!"unknown" or name! or (user.name)!</li>
        <li>Missing value test: name?? or (user.name)??</li>
        <li>Assignment operators: =, +=, -=, *=, /=, %=, ++, --</li>
    </ul>
</ul>
    