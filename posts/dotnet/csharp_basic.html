<html lnag="ko"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="google-site-verification" content="aH-DyzdytYQ0NPHNQFcs5dVoiu5YNs6CEEHYgqDmAFM"><meta name="author" content="Donggi Kim &lt;hi.donggi@gmail.com&gt;"><meta name="keywords" content="C#, .NET"><meta name="description" content="C#.NET 문법 정리"><title>C#.NET</title><link id="w3css" rel="stylesheet" href="/source/w3.css"><link id="highlight-style" rel="stylesheet" href="/source/xcode.css"><link id="default-style" rel="stylesheet" href="/source/default.css"><script id="highlight-js" src="/source/highlight.pack.js"></script><script id="default-js" src="/source/default.min.js"></script><script id="dsq-count-scr" src="//donggi.disqus.com/count.js" async></script><script id="kakao-ads" src="//t1.daumcdn.net/kas/static/ba.min.js" async></script><script id="google-ads" data-ad-client="ca-pub-7897366614471210" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><script id="google-analytics" src="https://www.googletagmanager.com/gtag/js?id=UA-143098403-1" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-143098403-1');</script></head><body><div id="sidebar" class="w3-bar-block w3-sidebar w3-animate-left"><hr><a href="javascript:closeSidebar();" class="w3-bar-item w3-button">Close &times;</a><hr><div id="marker-list"></div><hr><div id="post-list"></div><hr><div class="w3-center"><ins style="display:none;" data-ad-unit="DAN-1k1r635zxb6g3" data-ad-width="300" data-ad-height="250" class="kakao_ad_area"></ins></div><hr><div id="file-list"></div><hr></div><div id="main"><div id="nav" style="position:-webkit-sticky;position:sticky;top:0px;vertical-align:middle" class="w3-bar w3-blue w3-large"><button onclick="toggleSidebar()" class="w3-bar-item w3-button w3-hover-theme">&#9776;</button><input id="query" type="text" placeholder="search" class="w3-bar-item"></div><div id="contents" class="w3-padding"><h1 class="marker">.NET Framework 개요</h1><div><h2>프레임워크</h2><p>제어 역전이 있는 대규모 라이브러리. 프로그램의 초기화부터 종료까지 직접 관리하며, 개발자는 일부분만 작성.</p><h2 class="marker">CLI; Common Language Infrastructure</h2><p>닷넷 표준 규약. 자바와 마찬가지로 CLI 사양을 준수한 구현체에서 동작하는 파일은 다른 구현체에서도 실행된다.</p><ul><li>CIL; Common Intermediate Language == IL. 중간 언어</li><p>IL은 자체 문법을 가지며 ILASM.EXE라는 전용 컴파일러도 있다.</p><li>CTS; Common Type System</li><p>닷넷 언어가 지켜야 할 타입의 표준. 전체를 구현하진 않아도 된다.</p><li>CLS; Common Language Specification</li><p>닷넷 언어가 지켜야 하는 최소 사양</p><li>메타데이터</li><p>실행 파일(exe/dll)은 외부에서 리플렉션을 통해 접근할 수 있는 메타데이터를 제공한다.</p><li>어셈블리</li><p>exe/dll 실행파일을 어셈블리라고 부른다.</p><li>모듈</li><p>어셈블리는 1개 이상의 모듈로 구성되며, 하나의 모듈은 하나의 파일에 대응된다.</p><li>매니페스트</li><p>여러 모듈이 하나의 어셈블리를 구성하는 경우, 모듈 중 하나는 모듈의 목록을 관리하는 매니페스트 데이터를 갖는다. 매니페스트를 포함하는 경우 확장자는 exe/dll, 그 외의 모듈은 보통
netmodule이지만, 일반적으로 모든 어셈블리는 1개의 파일로 구성된다.</p></ul><h2 class="marker">닷넷 구현체</h2><ul><li>.NET Framework</li><p>CLR; Common Language Runtime + BCL; Base Class Library</p><p>CLR : CLI를 구현한 가상 머신. 중간 언어를 JIT 컴파일러를 이용해 기계어로 변환하고, GC를 운용한다.</p><li>.NET Core</li><p>CoreCLR + Core Library</p><p>윈도우, macOS, 리눅스에서 실행 가능</p><li>Mono</li><p>현재는 자마린에서 개발 중. 윈도우, macOS, 리눅스, 솔라리스, 안드로이드, 엑스박스 360 등에서 실행 가능</p></ul></div><h1 class="marker">개발 환경</h1><ol><li>윈도우에는 기본적으로 닷넷 프레임워크가 설치돼있다. 또는 비주얼 스튜디오 설치 시 같이 설치된다.</li><li>C# 컴파일러 : C:\Windows\Microsoft.NET\...\csc.exe</li><li>닷넷 역컴파일러 : .NET Reflector(유료), JustDecompile(무료) 등</li><li>IDE : Visual Studio, Visual Studio for Mac, Visual Studio Code, Xamarin Studio, Rider</li></ol><h1 class="marker">문법</h1><div><h2 class="marker">기본 자료형</h2><div><h3 class="marker">정수형</h3><table class="no-sort"><tr><td>sbyte</td><td>signed byte</td><td>System.Sbyte</td></tr><tr><td>byte</td><td>unsigned byte</td><td>System.Byte</td></tr><tr><td>short</td><td>signed 2bytes</td><td>System.Int16</td></tr><tr><td>ushort</td><td>unsigned short</td><td>System.UInt16</td></tr><tr><td>int</td><td>signed 4bytes</td><td>System.Int32</td></tr><tr><td>uint</td><td>unsigned int</td><td>System.UInt32</td></tr><tr><td>long</td><td>signed 8bytes</td><td>System.Int64</td></tr><tr><td>ulong</td><td>unsigned long</td><td>System.UInt64</td></tr></table><h3 class="marker">실수형</h3><table class="no-sort"><tr><td>float</td><td>4바이트. 리터럴 접미사 f</td><td>System.Single</td></tr><tr><td>double</td><td>8바이트</td><td>System.Double</td></tr><tr><td>decimal</td><td>16바이트. 리터럴 접미사 m</td><td>System.Decimal</td></tr></table><h3>숫자 리터럴</h3><p>16진수 표현 0xFFFF, 2진수 표현 0b1010, 구분 문자 '_' 사용 가능</p><h3 class="marker">문자형</h3><table class="no-sort"><tr><td>char</td><td>2바이트(유니코드)</td><td>System.Char</td></tr><tr><td>string</td><td>동적 크기. Indexer 구현</td><td>System.String</td></tr></table><h3>문자열 리터럴</h3><ul><li>@"" : \ 이스케이프를 하지 않는다. ""로 일반 문자열의 \"를 대신할 수 있다</li><li>$"" Since C# 6 : 간편한 포맷 문자열을 제공한다. {<i>표현식</i>[,<i>alignment</i>][:<i>formatString</i>]}<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/VisualStudio/csharp_interpolated_string.cs" lan="cs">View Code »</button></li><li>Since C# 8 : @$"", $@"" 모두 유효. 이전에는 $@""만 가능</li></ul><h3>Boolean</h3><table><tr><td>bool</td><td>true or false</td><td>System.Boolean</td></tr></table><h3>Boolean 연산 &&, ||는 Short-circuit</h3></div><h2 class="marker">배열</h2><ul><li>배열 초기화시 기본값으로 채워진다.</li><li>다차원 배열 [,] : 배열 차원 고정. 메모리 상에서는 일차원 배열처럼 존재.</li><li>Jagged Array [][] : 배열의 차원이 가변적</li><p><strong>↓ cs</strong></p><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">int[] arr1 = new int[3];
int[] arr2 = new int[] { 1, 2, 3 };
int[] arr3 = { 1, 2, 3 };
int[,] arr4 = new int[2, 2];
int[,] arr5 = new int[,] { { 1, 2 }, { 3, 4 } };
</div></ul><h2 class="marker">형변환</h2><ul><li>암시적 형변환 : 보다 큰 정의의 자료형으로 자동 변환.</li><p>Boxing : Value type 데이터를 Reference type으로 변환. 컴파일러가 묵시적으로 수행.</p><li>명시적 변환 : 괄호 이용.</li><p>Unboxing : Reference type 데이터를 Value type으로 변환. 캐스팅을 통해 명시적으로 수행.</p><li>if (o is Mammal m) { }</li><li>as 연산자를 이용한 명시적 변환은, null을 허용하는 참조 자료형만 가능하다.</li></ul><h2 class="marker">구문</h2><ul><li>if ~ else if ~ else</li><li>switch</li><p>정수, bool, char, string, enum에 대해 동작. case문 다음이 빈 문장일 때만 break 생략 가능</p><p>Since C# 7.0 : null이 아닌 모든 표현식 가능</p><li>while, do ~ while</li><li>for(초기식; 조건식; 증감식)</li><li>foreach(var obj in IEnumerable)</li><li>점프</li><p>break, continue, goto(관례상 레이블은 대문자로만), return, throw</p><li>checked/unchecked 블록</li><p>기본적으로는 프로그램 실행 시 오버플로/언더플로를 무시한다.</p><p>checked/unchecked 블록은 이를 각각 명시적인 예외로 처리/비처리 하도록 한다.</p><button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/VisualStudio/CSharp/Basic/CheckedExample.cs" displayRange="[13, 39]" lan="cs">View Code »</button><li>예외 처리</li><p><strong>↓ cs</strong></p><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">throw e; // e는 System.Exception 및 파생 클래스의 인스턴스
try {} catch {} finally {}
try {} catch (ExceptionType) {}
try {} catch { throw; }
try {} catch (ExceptionType e) {}
try {} catch () when (!filePath.Contains(".tmp")) {} // when 필터를 사용하는 경우, 같은 타입을 여러 번 catch 가능
try {} finally { iDisposable.Dispose(); } // 다음과 동일 : using(var iDisposable = ~) { }
</div></ul><h2 class="marker">네임스페이스</h2><p><strong>↓ cs</strong></p><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">namespace MyProgram.Model { }
using System.Collections.Generic;
using static MyProgram.Model.Constants;
</div></div><h1 class="marker">객체지향</h1><div><h2 class="marker">클래스</h2><ul><li>프로퍼티 → (히든) 필드에 대한 getter/setter 메서드<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/VisualStudio/csharp_property.cs" lan="cs">ViewModel에서의 사용 예 »</button></li><li>익명 객체 → new { PropertyName = value } : 생성 후 읽기만 가능</li><li>정적 생성자 → static 클래스이름() { }</li><p>첫 번째 인스턴스가 만들어지거나 정적 멤버가 참조되기 전에 자동으로 호출된다.</p><li>partial class ClassName {} : 프로젝트 내 여러 파일에 걸쳐 클래스 작성 가능</li><li>접근 제한자 → public, protected(파생 클래스까지), private, internal(같은 어셈블리), protected internal</li></ul><div><h3 class="marker">상속</h3><ul><li>class SubClass : BaseClass</li><li>is 연산자로 호환 여부 확인 가능</li><li>this 키워드 : 클래스의 현재 인스턴스<br>base 키워드 : 부모 클래스 메서드 또는 생성자 호출<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/VisualStudio/csharp_base_keyword.cs" lan="cs">View Code »</button></li><li>sealed 키워드 → 상속/재정의 불가</li><li>부모 클래스 인스턴스를 자식 클래스로 다운캐스팅 불가.</li><li>모든 자료형의 조상은 System.Object : ToString(), GetType(), Equals(), GetHashCode()<br>모든 값 형식의 조상은 System.ValueType<br>모든 배열의 조상은 System.Array : Sort(), BinarySearch&lt;T>(), IndexOf(), ..., Length, Rank</li></ul><h3 class="marker">다형성</h3><ul><li>virtual, override 키워드를 사용해 명시한다. virtual 메서드는 body를 정의해야 한다.</li><li>new : 부모 메서드 숨기기. override와 달리 형 변환을 통해 부모 메서드에 접근 가능.</li><li>abstract class : 인스턴스화 불가능<br>abstract method : 서브 클래스에서 반드시 override</li><li>연산자 오버로딩</li>public static 반환타입 operator 연산자(타입1 변수1, 타입2 변수2) {}<li>형 변환 정의</li><p><strong>↓ cs</strong></p><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">public static implicit operator 타입2(타입1 변수1) {};
public static explicit operator 타입2(타입1 변수1) {};
</div></ul></div><h2 class="marker">델리게이트</h2><ul><li>메서드를 참조하는 자료형<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/VisualStudio/CSharp/Basic/DelegateExample.cs" lan="cs">View Code »</button></li><li>델리게이트로 변환될 수 있는 익명 메서드 생성</li><ol><li>delegate 연산자 → delegate (int a, int b) { return a + b; }</li><li>람다 Since C# 3 → (a, b) => a + b;</li></ol><li>델리게이트에는 BeginInvoke 및 EndInvoke 메서드가 자동으로 추가되며, 이를 통해 임의 메서드를 비동기 호출할 수 있다</li><button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/VisualStudio/CSharp/Basic/DelegateExample.cs" displayRange="[12, 22, 49, 64]" lan="cs">비동기 호출 예 »</button><button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/VisualStudio/CSharp/Basic/DelegateExample.cs" displayRange="[12, 22, 66, 86]" lan="cs">비동기 호출 대기 예 »</button><li>델리게이트 체인</li><p><strong>↓ cs</strong></p><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">myDelegate += obj.Func;
myDelegate -= obj.Func;</div><li class="marker">Func</li><p>결과를 반환하는 메서드를 참조하는, 미리 정의된 델리게이트. 매개변수 0 ~ 16개, 총 17가지.</p><li class="marker">Action</li><p>void 리턴 메서드를 참조하는, 미리 정의된 델리게이트. 매개변수 0 ~ 16개, 총 17가지.</p><li class="marker">이벤트</li><ol><li>일반화된 델리게이트. 간단하게 구독/해지 가능. 클래스 밖에서 호출 불가.</li><li>이벤트의 첫 번째 인자는 이벤트 발생 객체. 두 번째 인자는 EventArgs 호환 객체.</li><p><strong>↓ cs</strong></p><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">public event EventHandler SomeEvent = delegate { };</div><button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/VisualStudio/CSharp/Basic/EventExample.cs" lan="cs">View Code »</button></ol></ul><h2 class="marker">인터페이스</h2><ol><li>인터페이스도 프로퍼티를 가질 수 있다(get/set 지정만 가능). 구현하는 클래스에서 프로퍼티를 구현한다.</li><li>class SubClass : BaseClass, Interface1, Interface2, ...</li><li>interface Interface1 : Interface2</li></ol><h2 class="marker">구조체 struct</h2><ol><li>사용자 정의 ValueType.</li><li>ValueType이므로 생성자 호출 없이 선언만으로 초기화가 진행된다. 사용되는 기본 생성자는 컴파일러가 자동으로 추가하며, 재정의할 수 없다.</li><li>모든 타입은 Object의 파생 클래스이므로, 구조체도 new 키워드로 인스턴스를 생성할 수 있다. 인자를 받는 생성자는 모든 필드를 초기화해야 한다.</li><li>ValueType이므로 할당 시 깊은 복사가 이루어진다.</li></ol><h2 class="marker">열거형 enum</h2><ol><li>정수형을 상속받아 정의할 수 있는 ValueType. 기본 int</li><li>[Flags] // 열거형을 비트필드로 이용하는 애트리뷰트</li></ol><p><strong>↓ cs</strong></p><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">[Flags] enum Authority { READ = 1, WRITE = 2, EXECUTE = 4 }
var authority = READ | WRITE;
Console.WriteLine(authority.HasFlag(WRITE));
</div><h2 class="marker">제네릭</h2><ul><li>Generic Method</li><p><strong>↓ cs</strong></p><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">public void Write&lt;T>(T value) => OnWrite(value?.ToString() ?? "");</div><li>Generic Class</li><p><strong>↓ cs</strong></p><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">public class List&lt;T> : IList&lt;T>, ICollection&lt;T>, IEnumerable&lt;T>, (생략)</div><li>Type Bound</li><p><strong>↓ cs</strong></p><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">class MyGenereic&lt;T, U> where T : struct where U : class { }
// 값 형식         where T : struct
// 참조 형식       where T : class
// 기본 생성자 보유 where T : new()
// 호환 여부 검사   where T : BaseClassName | InterfaceName | U // U는 다른 형식 매개 변수
// where T : A[, B[, C[...]]]</div><li>제네릭 별명</li><p><strong>↓ cs</strong></p><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">using Commands = System.Collections.Generic.Dictionary&lt;string, System.Windows.Input.ICommand>;</div></ul></div><h1 class="marker">추가 기능 ~ C# 8.0 (2019. 02. 12)</h1><div><h2 class="marker">타입</h2><ol><li class="marker">BigInteger : 크기 제한없는 정수. 연산자 오버로딩 덕에 편리</li><li class="marker">dynamic : 파이썬처럼 타입 검사를 런타임에 하여 Duck-typing을 가능하게 한다.</li><li class="marker">IntPtr : 32/64비트 프로그램에서 각각 4/8바이트. 포인터 외에 운영체제 핸들값을 저장하는 용도로도 사용.</li><li class="marker">var : 지역변수 초기화시 사용 가능한 자동형식</li><li class="marker">Nullable&lt;T> : null을 허용하는 래퍼 클래스. int?는 Nullable&lt;int>와 동일하다.</li></ol><div><h3 class="marker">튜플 : System.ValueTuple</h3><ul><li>익명 튜플 : 멤버의 기본 이름은 Item1, Item2, ...</li><p><strong>↓ cs</strong></p><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">var unnamed = ("one", "two");</div><li>명명 튜플 : 컴파일하면 멤버명은 Item*으로 변경된다</li><p><strong>↓ cs</strong></p><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">var named = (first: "one", second: "two");</div><li>튜플 프로젝션 이니셜라이저 : 변수명을 자동으로 요소 이름으로 사용</li><p><strong>↓ cs</strong></p><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">var accumulation = (count, sum);</div><li>Since C# 7.3 ==, != 연산자 지원(short-circuit)</li><ul><li>Nullable인 튜플이나 멤버에 대해 자동으로 변환을 수행한다</li><p><strong>↓ cs</strong></p><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">var left = (a: 5, b: 10);
var right = (a: 5, b: 10);
(int a, int b)? nullableTuple = right;
Console.WriteLine(left == nullableTuple); // true</div><p><strong>↓ cs</strong></p><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">var left = (a: 5, b: 10);
(int? a, int? b) nullableMembers = (5, 10);
Console.WriteLine(left == nullableMembers); // true</div><li>튜플 멤버에 대한 암시적 변환을 수행한다</li><p><strong>↓ cs</strong></p><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">(long a, int b) longFirst = (5, 10);
(int a, long b) longSecond = (5, 10);
Console.WriteLine(longFirst == longSecond); // true</div></ul><li>메서드 튜플 반환</li><p><strong>↓ cs</strong></p><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">static (int Count, double Sum, double SumOfSquares) ComputeSumAndSumOfSquares(IEnumerable&lt;double> sequence) { }
static (int, double, double) ComputeSumAndSumOfSquares(IEnumerable&lt;double> sequence) { }
(int count, double sum, double sumOfSquares) = ComputeSumAndSumOfSquares(sequence);
(int count, var sum, var sumOfSquares) = ComputeSumAndSumOfSquares(sequence);
var (count, sum, sumOfSquares) = ComputeSumAndSumOfSquares(sequence);
var result = ComputeSumAndSumOfSquares(sequence);</div><li>메서드 튜플 매개변수</li><p><strong>↓ cs</strong></p><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">public void Print((int Count, double Sum, double SumOfSquares) data) { }
public void Print((int, double, double) data) { }</div><li>out 매개변수 튜플</li><p><strong>↓ cs</strong></p><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">var dict = new Dictionary&lt;int, (int, string)>();
dict.TryGetValue(2, out (int num, string place) pair);</div><li>튜플 분해</li><p><strong>↓ cs</strong></p><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">public class Rectangle
{
    public int X { get; set; }
    public int Y { get; set; }
    public int Width { get; set; }
    public int Height { get; set; }
    public void Deconstruct(out int x, out int y, out int width, out int height)
        => (x, y, width, height) = (X, Y, Width, Height);
}
// 또는 다른 형식에 대한 확장 메서드를 작성하여 분해를 지원할 수 있다
public static void Deconstruct(this Rectangle rect, out int x, out int y, out int width, out int height)
    => (x, y, width, height) = (rect.X, rect.Y, rect.Width, rect.Height);
var rect = new Rectangle(1, 2, 3, 4);
var (_, _, w, h) = rect;
</div></ul></div><h2 class="marker">연산자</h2><ul><li class="marker">await : 피연산자가 나타내는 비동기 작업이 완료될 때까지 바깥쪽 비동기 메서드의 평가를 일시 중단</li><li class="marker">default(Type) : 타입에 대한 기본값/인스턴스 반환한다.</li><p>Since C# 7.1 : default 리터럴로 기본값을 표현할 수 있다.</p><li class="marker">nameof(Identifier) : 식별자 문자열 반환</li><li class="marker">Null 조건부 연산자 ?. 및 ?[]<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/VisualStudio/CSharp/Basic/NullableExample.cs" lan="cs">View Code »</button></li><ul><li>피연산자가 null이 아니면 멤버 액세스 ?. 또는 요소 액세스 ?[] 연산을 적용한다.</li><li>null이면 그대로 null 반환</li><li>null 조건부 연산자를 연쇄적으로 이용할 때, 중간에서 null이 반환된 경우, 나머지는 처리되지 않는다.</li></ul><li class="marker">stackalloc : 값 형식의 배열을 스택에 할당한다. fixed 문으로 고정하지 않아도 된다. 메서드 반환 시 자동 삭제된다; 임의 해제 불가</li><p><strong>↓ cs</strong></p><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">int* numbers = stackalloc int[100]; // 포인터는 unsafe 컨텍스트를 사용해야 한다
Span&lt;int> numbers = stackalloc int[100]; // Since C# 7.2 : Span, ReadOnlySpan에 할당 가능
var idx = numbers.IndexOfAny(stackalloc[] { 1, 2, 3, 4 }); // Since C# 8.0 : 다른 식 내부에서 stackalloc 사용 가능</div><li class="marker">?? 연산자 : 좌측 피연산자가 null이면 우측 피연산자를 반환</li><li class="marker">??= 연산자 Since C# 8.0 : 왼쪽 피연산자가 null로 평가되는 경우, 오른쪽 피연산자의 값을 대입</li><li class="marker">^ 연산자 Since C# 8.0 : 끝부터 시작하는 인덱스</li><p><strong>↓ cs</strong></p><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">// 시퀀스 길이가 length인 경우, ^1은 마지막 요소, ^length는 첫번째 요소, ^n은 length - n번째 요소
int[] xs = new[] { 0, 10, 20, 30, 40 };
int last = xs[^1];</div><li class="marker">범위 연산자 .. Since C# 8.0 : start..end // [start, end)</li><ul><li>a.. == a..^0</li><li>..b == 0..b</li><li>.. == 0..^0</li></ul><p><strong>↓ cs</strong></p><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">Console.WriteLine($"The last word is {words[^1]}");
var lazyDog = words[^2..^0];
var allWords = words[..]; // contains "The" through "dog".
var firstPhrase = words[..4]; // contains "The" through "fox"
var lastPhrase = words[6..]; // contains "the, "lazy" and "dog"
Range phrase = 1..4;
var text = words[phrase];
</div></ul><h2 class="marker">한정자</h2><ul><li class="marker">async : 메서드, 람다식, 익명 메서드(delegate 연산자)를 비동기로 지정.</li><ul><li>void 리턴 : await할 수 없으며, 따라서 예외를 catch할 수 없다</li><li>Task, Task&lt;TResult> : await 가능</li><li>Since C# 7.0 : 액세스 가능한 GetAwaiter() 메서드가 있는 모든 형식 리턴 가능</li><p>System.Threading.Tasks.ValueTask&lt;TResult>은 패키지 System.Threading.Tasks.Extensions가 제공하는 구현</p></ul><li class="marker">private protected : 동일 어셈블리 내의 클래스 및 파생 클래스에서 엑세스 가능</li><li class="marker">ref</li><ul><li>ref 매개변수 : 참조 전달. 호출자 스코프의 변수를 그대로 사용하는 효과. 참조가 존재하기 위해 호출 전에 초기화 필요</li><p><strong>↓ cs</strong></p><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">void Method(ref int refArgument)</div><li>ref 반환 : 참조 반환</li><li>ref 지역 변수 : ref 반환값으로 초기화되는 지역 변수</li><p>Since C# 7.3 : foreach 반복 변수는 ref 또는 ref readonly 지역 변수일 수 있다</p><li>ref readonly 반환 : 반환된 참조에 대한 쓰기는 비허용</li></ul><p><strong>↓ cs</strong></p><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">public ref decimal GetCurrentPrice() {
        // ...
        return ref DecimalArray[0];
}
ref decimal estValue = ref GetCurrentPrice();
ref decimal copyValue = ref estValue;</div><li class="marker">in 매개변수 : 참조 전달. 메서드에서 수정 불가</li><li class="marker">out 매개변수 : 참조 전달. 호출 전에 초기화되지 않아도 되지만, 반환 전에 할당돼야 한다</li><p><strong>↓ cs</strong></p><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">// 선언과 동시에 out 매개변수로 사용 가능
int.TryParse("12", out var result);
int.TryParse("21", out var _); // 출력 무시</div><li class="marker">ref struct : 스택에 할당되는 struct. 클래스의 멤버가 될 수 없다. 인터페이스를 구현할 수 없다<br>readonly struct : 모든 필드가 readonly인 struct</li><li class="marker">unsafe : unsafe로 한정한 타입, 메서드, 블록에서는 포인터를 사용할 수 있다.</li><p>컴파일 시 -unsafe 옵션을 지정해야 한다 : 비주얼 스튜디오는 "프로젝트 속성 - 빌드 - 안전하지 않은 코드 허용"<br>관련 클래스 : System.Runtime.InteropServices.Marshal</p></ul><h2 class="marker">메서드</h2><ol><li class="marker">매개변수 명시</li><p><strong>↓ cs</strong></p><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">Divide(a: 10, b: 3, q: out q, r: out r);</div><li class="marker">선택적 매개변수</li><p><strong>↓ cs</strong></p><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">Method(int a = 0, int b = 0) {}</div><li class="marker">가변 길이 매개변수 params<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/VisualStudio/CSharp/Basic/ParamsExample.cs" displayRange="[11, 17]" lan="cs">View Code »</button></li><li class="marker">확장 메서드 : 기존 클래스에 static method 추가됨.<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/VisualStudio/CSharp/Basic/ExtensionExample.cs" lan="cs">View Code »</button></li><li class="marker">람다 식 사용 확장 : 생성자, 소멸자, 이벤트 add/remove, 속성 set, 인덱서 set</li><li class="marker">메서드 안에 지역 함수 정의 가능</li><p>static 지역 함수로 선언하면 외부 변수 참조 불가</p><li class="marker">extern 메서드 : 메서드의 body가 없어도 컴파일 되도록 한다.</li><p>호출할 메서드가 있는 dll을 [DllImport] Attribute로 지정해주면 해당 메서드를 호출한다. http://www.pinvoke.net/</p><li class="marker">Caller information</li><p><strong>↓ cs</strong></p><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">static void Log(string text,
                [CalleMemberName] string memberName = "",
                [CallerFilePath] string filePath = "",
                [CallerLineNumber] int lineNumber = 0) { }</div><li>Main 메서드에 async 허용</li></ol><h2 class="marker">구문</h2><ol><li class="marker">인덱서 구문 : 하나 이상의 인수로 참조되는 속성을 반환. string, List&lt;T> 등은 인덱서를 구현함.<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/VisualStudio/CSharp/Basic/IndexerExample.cs" lan="cs">View Code »</button></li><li class="marker">switch case 필터 Since C# 7.0</li><p><strong>↓ cs</strong></p><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">switch(item) {
    case 100:
    case null:
    case DateTime dt:
    case int i when i > 300:
    case var i when i.어쩌구저쩌구():
}</div><li class="marker">전처리 지시문 #define, #undef, #if, #elif, #else, #endif, ..., #region, #endregion</li><li class="marker">fixed 문 : unsafe 컨텍스트에서, GC가 변수를 재배치하지 않도록 하여 포인터의 유효함을 보장한다</li></ol><div><h3 class="marker">yield 반복기</h3><p><strong>↓ cs</strong></p><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">public static IEnumerable&lt;int> InfiniteSeries(int limit) {
    var num = 0;
    if(num &lt;= limit)
        yield return ++start;
    yield break;
}
public class Galaxies
{
    public IEnumerable&lt;Galaxy> NextGalaxy
    {
        get
        {
            yield return new Galaxy { Name = "Tadpole", MegaLightYears = 400 };
            yield return new Galaxy { Name = "Pinwheel", MegaLightYears = 25 };
            yield return new Galaxy { Name = "Milky Way", MegaLightYears = 0 };
            yield return new Galaxy { Name = "Andromeda", MegaLightYears = 3 };
        }
    }
}
</div><h3 class="marker">LINQ; Language INtegrated Query</h3><ol><button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/VisualStudio/CSharp/Basic/LinqExample.cs" lan="cs">View Code »</button><li>MoreLinq 패키지에서 추가적인 편의성을 제공한다.</li><li>from : LINQ query는 from으로 시작한다. from의 대상은 IEnumarable&lt;T></li><p>LINQ query 결과도 IEnumerable&lt;T></p><li>where + bool 판정식</li><li>orderby + 정렬 기준 [(ascending) | descending]</li><li>select + 결과</li><p><strong>↓ cs</strong></p><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">from mQuest in Get&lt;MQuest>()
where mQuest.quest_group_id.Equals(mQuestGroup.quest_group_id)
orderby mQuest.quest_name
select mQuest</div><li>let : LINQ 내에서의 변수 선언; let x = 10</li><li>중첩 질의</li><p><strong>↓ cs</strong></p><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">from student in students
from score in student.Scores</div><li>Grouping : 결과는 IGrouping&lt;T> 형식</li><p><strong>↓ cs</strong></p><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">from p in profiles
group p by p.Height &lt; 160 into lowGroup
select new { Key = lowGroup.Key, Profiles = lowGroup };</div><li>Inner Join</li><p><strong>↓ cs</strong></p><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">from a in A
join b in B on a.X equals b.Y</div><li>Outer Join : inner join 결과를 임시 컬렉션으로 치환하고, 임시 컬렉션의 빈 항목을 기본 값으로</li><p><strong>↓ cs</strong></p><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">from profile in profiles
join product in products on profile.Name equals product.Name into result
from product in result.DefaultIfEmpty( new Product() { Title = "없음” } )
select new { Name = profile.Name, Work = product.Title };</div><li>Expression Tree : System.Linq.Expressions</li><p><strong>↓ cs</strong></p><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">var const1 = Expression.Constant(1);
var param1 = Expression.Parameter(typeof(int), "x");
var exp = Expression.Add(const1, param1);
var lambda = Expression&lt;Func&lt;int, int>>.Lambda&lt;Func&lt;int, int>>(exp, new ParameterExpression[] { (ParameterExpression)param1 });
var compiledFunc = lambda.Compile();
Console.WriteLine(compiledFunc(3));
</div></ol></div><h2 class="marker">Attribute</h2><ol><li>자바의 애너테이션처럼 요소를 장식한다.<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/VisualStudio/CSharp/Basic/AttributeExample.cs" lan="cs">AttributeExample.cs 전체 코드 »</button></li><li>사용자 정의 특성은 System.Attribute를 상속하여 만든다.<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/VisualStudio/CSharp/Basic/AttributeExample.cs" displayRange="[12, 19]" lan="cs">View Code »</button></li><li>명명시 Attribute를 접미하고, 실제 사용할 땐 생략 가능하다.<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/VisualStudio/CSharp/Basic/AttributeExample.cs" displayRange="[21, 24]" lan="cs">View Code »</button></li><li>특성 적용 대상 제한 : System.AttributeUsage 생성자에 AttributeTargets 전달. 생략시 기본값은 AttributeTargets.All<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/VisualStudio/CSharp/Basic/AttributeExample.cs" displayRange="[12, 13]" lan="cs">View Code »</button></li><li>적용 대상 명시 : assembly, module, type, method, property, field, event, param, return, typevar<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/VisualStudio/CSharp/Basic/AttributeExample.cs" displayRange="[23, 24]" lan="cs">View Code »</button></li></ol><h2 class="marker">App.config</h2><ol><li>supportedRuntime</li><p>실행에 필요한 닷넷 버전 지정. 비주얼 스튜디오가 자동으로 추가해주는듯</p><button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/VisualStudio/CSharp/Basic/App.config" lan="xml">App.config »</button><li>appSettings</li><button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/VisualStudio/CSharp/Basic/App.config" lan="xml">App.config »</button><button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/VisualStudio/CSharp/Basic/Program.cs" lan="cs">Program.cs »</button></ol><h2 class="marker">디버그 모드</h2><ol><li>전처리 상수 #if DEBUG ... #endif</li><li>[Conditional("DEBUG")] 적용된 클래스, 메서드는 릴리스 빌드 시 포함되지 않는다</li><li>System.Diagnostics.Debug.WriteLine() : 디버그 출력</li></ol><h2 class="marker">Reflection 리플렉션</h2><ul><li>AppDomain → Assembly ← Module ← Type</li><p>AppDomain : EXE 프로세스 내에서 CLR에 의해 구현된 격리 공간. 최초 실행 시 기본적으로 1개 생성(AppDomain.CurrentDomain).</p><p>static 멤버들은 AppDomain 안에서 유일하다. 프로세스의 여러 AppDomain에서 동일한 클래스를 로드했다면 static 멤버들은 각 도메인마다 하나씩 존재</p><p><strong>↓ cs</strong></p><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">var appDomain = AppDomain.CreateDomain("MyDomain");
ObjectHandle handle = appDomain.CreateInstanceFrom(dllPath, "Namespace.ClassName");
...
AppDomain.Unload(appDomain);</div><li>Object.getType() or typeof 연산자</li><li>Type :: GetConstructors(), GetEvents(), GetFields(), GetMethods(), ...</li><li>동적 생성 : System.Activator.CreateInstance(Type);</li><li>동적 타입 정의 : System.Reflection.Emit</li><ol><li>System.AppDomain.DefineDynamicAssembly()로 AssemblyBuilder 객체 획득</li><li>AssemblyBuilder.DefineDynamicModule()로 ModuleBuilder 획득</li><li>ModuleBuilder.DefineType()으로 클래스 생성(TypeBuilder)</li><li>TypeBuilder.DefineMethod()로 MethodBuilder 획득</li><li>MethodBuilder.GetILGenerator()로 ILGenerator 객체 획득</li><li>ILGenerator.Emit()으로 메서드 내용 추가</li><li>TypeBuilder.CrateType()으로 인스턴스 생성 가능</li></ol></ul><h2 class="marker">재귀 패턴 매칭 Since C# 8.0</h2><p><strong>↓ cs</strong></p><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">int? x = null;
if (x is int n1)
    Console.WriteLine(n1);
else
    Console.WriteLine("Not a int");
x = 3;
if (x is int n2)
    Console.WriteLine(n2);</div><p><strong>↓ cs</strong></p><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">var (a, b) = (1, 2);
switch(a, b)
{
    case (0, _):
        Console.WriteLine("a is 0");
        break;
    case (1, _):
        Console.WriteLine("a is 1");
        break;
}</div><p><strong>↓ cs</strong></p><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">public static bool IsComplete(int n) =>
    n switch
    {
        6 => true,
        28 => true,
        496 => true,
        8128 => true,
        33550336 => true,
        _ => false
    };</div><p><strong>↓ cs</strong></p><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">public static bool IsComplete(int n) =>
    n switch
    {
        int x when new int[] { 6, 28, 496, 8128, 33550336 }.Contains(x) => true,
        _ => false
    };</div><p><strong>↓ cs</strong></p><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">var newState = (GetState(), action, hasKey) switch {
    (DoorState.Closed, Action.Open, _) => DoorState.Opened,
    (DoorState.Opened, Action.Close, _) => DoorState.Closed,
    (DoorState.Closed, Action.Lock, true) => DoorState.Locked,
    (DoorState.Locked, Action.Unlock, true) => DoorState.Closed,
    (var state, _, _) => state };</div><p><strong>↓ cs</strong></p><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">var msg = "Hello";
if (msg is string { Length: 5 } five)
    Console.WriteLine($"Right. {msg} is a 5 length string");</div><p><strong>↓ cs</strong></p><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">public static decimal ComputeSalesTax(Address location, decimal salePrice) =>
    location switch {
        { State: "WA" } => salePrice * 0.06M,
        { State: "MI" } => salePrice * 0.05M,
        _ => 0M
    };</div><p><strong>↓ cs</strong></p><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">static Quadrant GetQuadrant(Point point) => point switch {
    (0, 0) => Quadrant.Origin,
        var (x, y) when x > 0 && y > 0 => Quadrant.One,
        var (x, y) when x &lt; 0 && y > 0 => Quadrant.Two,
        var (x, y) when x &lt; 0 && y &lt; 0 => Quadrant.Three,
        var (x, y) when x > 0 && y &lt; 0 => Quadrant.Four,
        var (_, _) => Quadrant.OnBorder,
        _ => Quadrant.Unknown
    };
</div></div><h1 class="marker">.NET 정규표현식</h1><ul><p>Java와 동일한 부분은 생략</p><li>\nn 또는 \nnn : 8진수 ASCII</li><li>\w : \p{L} | \p{Mn} | \p{Nd} | \p{Pc}</li><li>\Z : \z | (?=\n)</li><li>(?&lt;name>X) == (?'name'X)</li><ul><li>\k'name'역참조 가능. replace에서 ${name}참조 가능, GroupCollection의 인덱서로 참조 가능</li><li>그룹 오버로딩 가능 : (?&lt;1>a)(?&lt;1>\1b) // 스택처럼 정의가 쌓이며 '-name'으로 가장 최근 정의 삭제 가능</li></ul><li class="marker">균형 조정 그룹; Balancing group</li><ul><li>(?&lt;name1-name2>X) == (?'name1-name2'X)</li><p>name1은 현재 그룹(Optional)이고, name2는 이전에 정의된 그룹. 균형 조정 그룹은 마지막(백트래킹) name2 정의를 삭제하고, name1에 name2와 name1 사이 간격을 저장한다.</p><p><strong>↓ cs</strong></p><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">var html = "&lt;html>&lt;body>Hello&lt;p>World&lt;/p>olleH&lt;/body>&lt;/html>Plain Text&lt;script>console.log('hello world');&lt;/script>Plain Text&lt;yes>Text&lt;/no>";
Console.WriteLine($"All text : {html}");
foreach (Match match in Regex.Matches(html, @"&lt;(?'tag'\w+)>(.(?&lt;!&lt;/\k&lt;tag>>))*(?'-tag'&lt;/\k&lt;tag>>)", RegexOptions.IgnoreCase))
    Console.WriteLine($"HTML part : {match.Groups[0]}");
// All text : &lt;html>&lt;body>Hello&lt;p>World&lt;/p>olleH&lt;/body>&lt;/html>Plain Text&lt;script>console.log('hello world');&lt;/script>Plain Text&lt;yes>Text&lt;/no>
// HTML part : &lt;html>&lt;body>Hello&lt;p>World&lt;/p>olleH&lt;/body>&lt;/html>
// HTML part : &lt;script>console.log('hello world');&lt;/script></div></ul><li>옵션</li><ul><li>(?imnsx-imnsx:X) // X 내에 옵션 적용/비적용. 이 자체는 캡처링 그룹이 아님</li><li>(?imnsx-imnsx) // 이후 식에 옵션 적용/비적용</li><li>System.Text.RegularExpressions.RegexOptions // Regex 생성자 또는 정적 메서드에 전체 옵션 지정</li><table class="no-sort"><tr><td>IgnoreCase</td><td>i</td><td>대소문자 구별X</td></tr><tr><td>Multiline</td><td>m</td><td>^, $이 \n에서도 동작</td></tr><tr><td>ExplicitCapture</td><td>n</td><td>명명된 캡처링 그룹만 유효</td></tr><tr><td>Singleline</td><td>s</td><td>.이 \n포함</td></tr><tr><td>IgnorePatternWhitespace</td><td>x</td><td>이스케이프되지 않은 공백을 패턴에서 제거하고 주석을 #으로 표시 가능</td></tr><tr><td>Compiled</td><td></td><td>어셈블리로 컴파일</td></tr><tr><td>RightToLeft</td><td></td><td>우→좌 검색</td></tr><tr><td>ECMAScript</td><td></td><td></td></tr><tr><td>CultureInvariant</td><td></td><td></td></tr><tr><td>None</td><td></td><td>옵션 없음 명시</td></tr></table></ul><li>(?>X) : Non-backtracking</li><li class="marker">Replace 구문</li><ul><li>$n, ${name} : 캡처링 그룹</li><li>$& : 전체 매칭 문자열</li><li>$` : 매칭 문자열 앞부분</li><li>$' : 매칭 문자열 뒷부분</li><li>$+ : 마지막 캡처링 그룹</li><li>$_ : 전체 입력 문자열</li></ul><li>인라인 주석 : (?#comment)</li></ul><details><summary class="marker">지원 Unicode class : \p{name} ↔ \P{name}</summary><table class="no-sort"><tr><th>Category</th><th>Description</th></tr><tr><td>Lu</td><td>Letter, Uppercase</td></tr><tr><td>Ll</td><td>Letter, Lowercase</td></tr><tr><td>Lt</td><td>Letter, Titlecase</td></tr><tr><td>Lm</td><td>Letter, Modifier</td></tr><tr><td>Lo</td><td>Letter, Other</td></tr><tr><td>L</td><td>Lu + Ll + Lt + Lm + Lo</td></tr><tr><td>Mn</td><td>Mark, Nonspacing</td></tr><tr><td>Mc</td><td>Mark, Spacing Combining</td></tr><tr><td>Me</td><td>Mark, Enclosing</td></tr><tr><td>M</td><td>Mn + Mc + Me</td></tr><tr><td>Nd</td><td>Number, Decimal Digit</td></tr><tr><td>Nl</td><td>Number, Letter</td></tr><tr><td>No</td><td>Number, Other</td></tr><tr><td>N</td><td>Nd + Nl + No</td></tr><tr><td>Pc</td><td>Punctuation, Connector</td></tr><tr><td>Pd</td><td>Punctuation, Dash</td></tr><tr><td>Ps</td><td>Punctuation, Start[Open]</td></tr><tr><td>Pe</td><td>Punctuation, End[Close]</td></tr><tr><td>Pi</td><td>Punctuation, Initial quote</td></tr><tr><td>Pf</td><td>Punctuation, Final quote</td></tr><tr><td>Po</td><td>Punctuation, Other</td></tr><tr><td>P</td><td>Pc + Pd + Ps + Pe + Pi + Pf + Po</td></tr><tr><td>Sm</td><td>Symbol, Math</td></tr><tr><td>Sc</td><td>Symbol, Currency</td></tr><tr><td>Sk</td><td>Symbol, Modifier</td></tr><tr><td>So</td><td>Symbol, Other</td></tr><tr><td>S</td><td>Sm + Sc + Sk + So</td></tr><tr><td>Zs</td><td>Separator, Space</td></tr><tr><td>Zl</td><td>Separator, Line</td></tr><tr><td>Zp</td><td>Separator, Paragraph</td></tr><tr><td>Z</td><td>Zs + Zl + Zp</td></tr><tr><td>Cc</td><td>Other, Control</td></tr><tr><td>Cf</td><td>Other, Format</td></tr><tr><td>Cs</td><td>Other, Surrogate</td></tr><tr><td>Co</td><td>Other, Private Use</td></tr><tr><td>Cn</td><td>Other, Not Assigned</td></tr><tr><td>C</td><td>Cc + Cf + Cs + Co + Cn</td></tr></table><table class="no-sort"><tr><th>Code point range</th><th>Block name</th></tr><tr><td>0000 - 007F</td><td>IsBasicLatin</td></tr><tr><td>0080 - 00FF</td><td>IsLatin-1Supplement</td></tr><tr><td>0100 - 017F</td><td>IsLatinExtended-A</td></tr><tr><td>0180 - 024F</td><td>IsLatinExtended-B</td></tr><tr><td>0250 - 02AF</td><td>IsIPAExtensions</td></tr><tr><td>02B0 - 02FF</td><td>IsSpacingModifierLetters</td></tr><tr><td>0300 - 036F</td><td>IsCombiningDiacriticalMarks</td></tr><tr><td>0370 - 03FF</td><td>IsGreek or IsGreekandCoptic</td></tr><tr><td>0400 - 04FF</td><td>IsCyrillic</td></tr><tr><td>0500 - 052F</td><td>IsCyrillicSupplement</td></tr><tr><td>0530 - 058F</td><td>IsArmenian</td></tr><tr><td>0590 - 05FF</td><td>IsHebrew</td></tr><tr><td>0600 - 06FF</td><td>IsArabic</td></tr><tr><td>0700 - 074F</td><td>IsSyriac</td></tr><tr><td>0780 - 07BF</td><td>IsThaana</td></tr><tr><td>0900 - 097F</td><td>IsDevanagari</td></tr><tr><td>0980 - 09FF</td><td>IsBengali</td></tr><tr><td>0A00 - 0A7F</td><td>IsGurmukhi</td></tr><tr><td>0A80 - 0AFF</td><td>IsGujarati</td></tr><tr><td>0B00 - 0B7F</td><td>IsOriya</td></tr><tr><td>0B80 - 0BFF</td><td>IsTamil</td></tr><tr><td>0C00 - 0C7F</td><td>IsTelugu</td></tr><tr><td>0C80 - 0CFF</td><td>IsKannada</td></tr><tr><td>0D00 - 0D7F</td><td>IsMalayalam</td></tr><tr><td>0D80 - 0DFF</td><td>IsSinhala</td></tr><tr><td>0E00 - 0E7F</td><td>IsThai</td></tr><tr><td>0E80 - 0EFF</td><td>IsLao</td></tr><tr><td>0F00 - 0FFF</td><td>IsTibetan</td></tr><tr><td>1000 - 109F</td><td>IsMyanmar</td></tr><tr><td>10A0 - 10FF</td><td>IsGeorgian</td></tr><tr><td>1100 - 11FF</td><td>IsHangulJamo</td></tr><tr><td>1200 - 137F</td><td>IsEthiopic</td></tr><tr><td>13A0 - 13FF</td><td>IsCherokee</td></tr><tr><td>1400 - 167F</td><td>IsUnifiedCanadianAboriginalSyllabics</td></tr><tr><td>1680 - 169F</td><td>IsOgham</td></tr><tr><td>16A0 - 16FF</td><td>IsRunic</td></tr><tr><td>1700 - 171F</td><td>IsTagalog</td></tr><tr><td>1720 - 173F</td><td>IsHanunoo</td></tr><tr><td>1740 - 175F</td><td>IsBuhid</td></tr><tr><td>1760 - 177F</td><td>IsTagbanwa</td></tr><tr><td>1780 - 17FF</td><td>IsKhmer</td></tr><tr><td>1800 - 18AF</td><td>IsMongolian</td></tr><tr><td>1900 - 194F</td><td>IsLimbu</td></tr><tr><td>1950 - 197F</td><td>IsTaiLe</td></tr><tr><td>19E0 - 19FF</td><td>IsKhmerSymbols</td></tr><tr><td>1D00 - 1D7F</td><td>IsPhoneticExtensions</td></tr><tr><td>1E00 - 1EFF</td><td>IsLatinExtendedAdditional</td></tr><tr><td>1F00 - 1FFF</td><td>IsGreekExtended</td></tr><tr><td>2000 - 206F</td><td>IsGeneralPunctuation</td></tr><tr><td>2070 - 209F</td><td>IsSuperscriptsandSubscripts</td></tr><tr><td>20A0 - 20CF</td><td>IsCurrencySymbols</td></tr><tr><td>20D0 - 20FF</td><td>IsCombiningDiacriticalMarksforSymbols or IsCombiningMarksforSymbols</td></tr><tr><td>2100 - 214F</td><td>IsLetterlikeSymbols</td></tr><tr><td>2150 - 218F</td><td>IsNumberForms</td></tr><tr><td>2190 - 21FF</td><td>IsArrows</td></tr><tr><td>2200 - 22FF</td><td>IsMathematicalOperators</td></tr><tr><td>2300 - 23FF</td><td>IsMiscellaneousTechnical</td></tr><tr><td>2400 - 243F</td><td>IsControlPictures</td></tr><tr><td>2440 - 245F</td><td>IsOpticalCharacterRecognition</td></tr><tr><td>2460 - 24FF</td><td>IsEnclosedAlphanumerics</td></tr><tr><td>2500 - 257F</td><td>IsBoxDrawing</td></tr><tr><td>2580 - 259F</td><td>IsBlockElements</td></tr><tr><td>25A0 - 25FF</td><td>IsGeometricShapes</td></tr><tr><td>2600 - 26FF</td><td>IsMiscellaneousSymbols</td></tr><tr><td>2700 - 27BF</td><td>IsDingbats</td></tr><tr><td>27C0 - 27EF</td><td>IsMiscellaneousMathematicalSymbols-A</td></tr><tr><td>27F0 - 27FF</td><td>IsSupplementalArrows-A</td></tr><tr><td>2800 - 28FF</td><td>IsBraillePatterns</td></tr><tr><td>2900 - 297F</td><td>IsSupplementalArrows-B</td></tr><tr><td>2980 - 29FF</td><td>IsMiscellaneousMathematicalSymbols-B</td></tr><tr><td>2A00 - 2AFF</td><td>IsSupplementalMathematicalOperators</td></tr><tr><td>2B00 - 2BFF</td><td>IsMiscellaneousSymbolsandArrows</td></tr><tr><td>2E80 - 2EFF</td><td>IsCJKRadicalsSupplement</td></tr><tr><td>2F00 - 2FDF</td><td>IsKangxiRadicals</td></tr><tr><td>2FF0 - 2FFF</td><td>IsIdeographicDescriptionCharacters</td></tr><tr><td>3000 - 303F</td><td>IsCJKSymbolsandPunctuation</td></tr><tr><td>3040 - 309F</td><td>IsHiragana</td></tr><tr><td>30A0 - 30FF</td><td>IsKatakana</td></tr><tr><td>3100 - 312F</td><td>IsBopomofo</td></tr><tr><td>3130 - 318F</td><td>IsHangulCompatibilityJamo</td></tr><tr><td>3190 - 319F</td><td>IsKanbun</td></tr><tr><td>31A0 - 31BF</td><td>IsBopomofoExtended</td></tr><tr><td>31F0 - 31FF</td><td>IsKatakanaPhoneticExtensions</td></tr><tr><td>3200 - 32FF</td><td>IsEnclosedCJKLettersandMonths</td></tr><tr><td>3300 - 33FF</td><td>IsCJKCompatibility</td></tr><tr><td>3400 - 4DBF</td><td>IsCJKUnifiedIdeographsExtensionA</td></tr><tr><td>4DC0 - 4DFF</td><td>IsYijingHexagramSymbols</td></tr><tr><td>4E00 - 9FFF</td><td>IsCJKUnifiedIdeographs</td></tr><tr><td>A000 - A48F</td><td>IsYiSyllables</td></tr><tr><td>A490 - A4CF</td><td>IsYiRadicals</td></tr><tr><td>AC00 - D7AF</td><td>IsHangulSyllables</td></tr><tr><td>D800 - DB7F</td><td>IsHighSurrogates</td></tr><tr><td>DB80 - DBFF</td><td>IsHighPrivateUseSurrogates</td></tr><tr><td>DC00 - DFFF</td><td>IsLowSurrogates</td></tr><tr><td>E000 - F8FF</td><td>IsPrivateUse or IsPrivateUseAreaIsPrivateUse or IsPrivateUseArea</td></tr><tr><td>F900 - FAFF</td><td>IsCJKCompatibilityIdeographs</td></tr><tr><td>FB00 - FB4F</td><td>IsAlphabeticPresentationForms</td></tr><tr><td>FB50 - FDFF</td><td>IsArabicPresentationForms-A</td></tr><tr><td>FE00 - FE0F</td><td>IsVariationSelectors</td></tr><tr><td>FE20 - FE2F</td><td>IsCombiningHalfMarks</td></tr><tr><td>FE30 - FE4F</td><td>IsCJKCompatibilityForms</td></tr><tr><td>FE50 - FE6F</td><td>IsSmallFormVariants</td></tr><tr><td>FE70 - FEFF</td><td>IsArabicPresentationForms-B</td></tr><tr><td>FF00 - FFEF</td><td>IsHalfwidthandFullwidthForms</td></tr><tr><td>FFF0 - FFFF</td><td>IsSpecials</td></tr></table></details></div><hr>&copy; 2020. <a href="mailto:hi.donggi@gmail.com">Donggi Kim</a> all rights reserved.<a class="w3-btn w3-round w3-round-xxlarge w3-small w3-green" href="/LICENSE" target="_blank">LICENSE</a></div></body></html>