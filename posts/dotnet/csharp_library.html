<html lnag="ko"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="google-site-verification" content="aH-DyzdytYQ0NPHNQFcs5dVoiu5YNs6CEEHYgqDmAFM"><meta name="author" content="Donggi Kim &lt;hi.donggi@gmail.com&gt;"><meta name="keywords" content="C#, .NET, 라이브러리"><meta name="description" content="C#.NET 라이브러리 정리"><title>C# 라이브러리</title><link id="w3css" rel="stylesheet" href="/source/w3.css"><link id="highlight-style" rel="stylesheet" href="/source/xcode.css"><link id="default-style" rel="stylesheet" href="/source/default.css"><script id="highlight-js" src="/source/highlight.pack.js"></script><script id="default-js" src="/source/default.min.js"></script><script id="dsq-count-scr" src="//donggi.disqus.com/count.js" async></script><script id="kakao-ads" src="//t1.daumcdn.net/kas/static/ba.min.js" async></script><script id="google-ads" data-ad-client="ca-pub-7897366614471210" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><script id="google-analytics" src="https://www.googletagmanager.com/gtag/js?id=UA-143098403-1" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-143098403-1');</script></head><body><div id="sidebar" class="w3-bar-block w3-sidebar w3-animate-left"><hr><a href="javascript:closeSidebar();" class="w3-bar-item w3-button">Close &times;</a><hr><div id="marker-list"></div><hr><div id="post-list"></div><hr><div class="w3-center"><ins style="display:none;" data-ad-unit="DAN-1k1r635zxb6g3" data-ad-width="300" data-ad-height="250" class="kakao_ad_area"></ins></div><hr><div id="file-list"></div><hr></div><div id="main"><div id="nav" style="position:-webkit-sticky;position:sticky;top:0px;vertical-align:middle" class="w3-bar w3-blue w3-large"><button onclick="toggleSidebar()" class="w3-bar-item w3-button w3-hover-theme">&#9776;</button><input id="query" type="text" placeholder="search" class="w3-bar-item"></div><div id="contents" class="w3-padding"><h1 class="marker">표준 입출력</h1><ol><li>Console.Read() : 한 글자</li><li>Console.ReadLine() : 한 줄</li><li>Console.Write(), Console.WriteLine()</li></ol><h1 class="marker">텍스트</h1><ol><li>String.Format ::= {N[, W][: formatCharacter]}</li><ul><li>N : 매개 변수 위치 지정. 0부터 시작</li><li>W : 출력될 자릿수 폭. '-'를 붙이면 왼쪽 정렬.</li><li>formatCharacter : d(10진수, DateTime), n(천 단위 구분 10진수), e(지수 표기), f(소수), g(e, f중 간략한 형태), p(백분율), x(16진수)</li></ul><li>String Interpolation : "C# 시작하기 - 문법 - 기본 자료형 - 문자열 리터럴" 참고</li><li>System.Text.StringBuilder</li><li>System.Text.Encoding : Encoding.UTF8.GetBytes()</li><li>System.Text.RegularExpressions.Regex</li></ol><h1 class="marker">시간</h1><ol><li>System.DateTime : 닷넷 시간 기준은 1년 1월 1일. Tick 간격은 천만 분의 일초</li><li>System.TimeSpan : DateTime의 - 연산 결과</li><li>System.Diagnostics.Stopwatch</li></ol><h1 class="marker">직렬화</h1><ul><li>System.BitConverter</li><p>기본 타입의 직렬화/역직렬화 제공. 리틀/빅 엔디언 구분 필요</p><li>System.Runtime.Serialization.Formatters.Binary.BinaryFormatter</li><ul><li>new BinaryFormatter().Serialize()</li><li>[Serializable] 특성 표기한 사용자 정의 클래스 직렬화.</li><li>직렬화에 배제할 요소는 [NonSerialized] 특성 표기</li></ul><li>System.Xml.Serialization.XmlSerializer</li><ul><li>new XmlSerializer(typeof(ClassName)).Serialize()</li><li>기본 생성자가 있는 public 클래스의 public 필드에 대해 직렬화 제공.</li></ul><li>System.Runtime.Serialization.Json.DataContractJsonSerializer</li><strong>↓ cs</strong><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">new DataContractJsonSerializer(typeof(ClassName)).WriteObject()</div></ul><h1 class="marker">스트림</h1><ul><li>System.IO.MemoryStream : 바이트 단위 스트림</li><li>System.IO.StreamWriter, StreamReader</li><li>System.IO.BinaryWriter, BinaryReader</li><li>System.IO.FileStream : 비동기 메서드 BeginRead, EndRead, BeginWrite, EndWrite</li></ul><h1 class="marker">파일</h1><ul><li>System.IO.File, System.IO.Directory : 클래스 메서드</li><li>System.IO.FileInfo, System.IO.DirectoryInfo : 인스턴스 메서드</li><li>System.IO.Path</li><ul><li>Path.Combine() : 경로 접합 시에 디렉터리 구분 문자를 넣어야 되는지 알아서 판단해서 처리해준다</li><li>임시 폴더/파일에 관한 기능 제공</li></ul></ul><h1 class="marker">Collection</h1><ul><li>System.Collections.ArrayList : Object에 대한 동적 배열은 List</li><li>System.Collections.Hashtable : Object 키-값 쌍 저장은 Dictionary</li><li>System.Collections.SortedList + SortedDictionary</li><p>Hashtable과 유사. 삽입과 동시에 키를 기준으로 정렬이 이루어진다.</p><li>System.Collections.Stack + Queue</li><li>컬렉션 초기화 구문</li><ul><li>ICollection&lt;T> 타입은 {}로 초기화 가능.</li><strong>↓ cs</strong><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">new List&lt;int> {0, 1, 2}</div><li>Since C# 6.0 : 확장 메서드로 Add()가 정의됐으면 {} 초기화 가능</li></ul></ul><h1 class="marker">스레딩</h1><ul><li>System.Threading.Thread</li><ul><li>thread.Start(obj) : 인자 하나를 받고 스레드 시작</li><li>thread.Abort() : 스레드 강제 종료</li><li>thread.Join() : 스레드 종료 대기</li><li>thread.Interrupt() : 스레드가 WaitJoinSleep 상태일 때 종료</li></ul><li>System.Threading.ThreadPool</li><li>System.Threading.EventWaitHandle</li><ul><li>EventWaitHandle은 대기중인 스레드를 깨울 수 있다.</li><li>EventWaitHandle 인스턴스는 Signal, Non-signal 두 가지 상태를 가지며, 상태 전이 메서드도 Set(→ Signal), Reset(→ Non-signal) 2가지가 있다.</li><li>스레드가 WaitOne 메서드를 호출하면 이벤트가 Signal 상태가 될 때까지 대기한다.</li><li>EventResetMode : 자동(Set 호출 뒤 자동으로 Non-signal 상태로 전이), 수동(Reset 직접 호출)</li><p>자동 리셋의 경우 대기하는 스레드 중 하나만 깨우고 상태를 변경한다</p></ul><li>System.Threading.Interlocked : int, long에 대한 원자 연산 제공</li><li>System.Threading.Monitor 스레드 간 동기화</li><strong>↓ cs</strong><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">Monitor.Enter(/* ojbect */);
try { /* body */ } finally{ Monitor.Exit(/* object */); }</div><li>Monitor 구문과 동치인 lock 블록</li><strong>↓ cs</strong><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">lock (/* object */) { /* body */ }</div><li>lock 블록과 Monitor를 혼용하여 대기 스레드들을 직접 관리</li><strong>↓ cs</strong><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">readonly var myLock = new object();
var isDone = false;
lock (myLock)
{
    // Monitor#Wait : 스레드를 WaitSleepJoin 상태로 만들고 lock을 해제한 뒤 Waiting Queue로 진입
    while(!isDone) { Monitor.Wait(myLock); }
    isDone = false;
    // ToDo
    isDone = true;
    // Monitor#Pulse : Waiting Queue의 첫번째 스레드를 깨워 Ready Queue로 입력.
    Monitor.Pulse(myLock);
}</div><li>비동기 처리 System.Threading.Tasks.Task</li><strong>↓ cs</strong><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">var task = new Task(() => { Thread.Sleep(1000); Console.WriteLine("Async"); });
task.start(); task.Wait();</div><strong>↓ cs</strong><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">var task = Task.Run(() => { Thread.Sleep(1000); Console.WriteLine("Async"); });
task.Wait();</div><strong>↓ cs</strong><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">await Task.Run(() => { Thread.Sleep(1000); Console.WriteLine("Async"); });</div><ul><li>await Task.Delay() : 입력시간 후 태스크 반환</li><li>Task.WaitAll(t1, t2, ...)</li><li>await Task.WhenAll(t1, t2, ...)</li><li>Task.Factory.StartNew()</li><li>Task.Factory.StartNew&lt;TResult>()</li></ul><li>비동기 실행 결과 취합 Task&lt;TResult&gt:</li><strong>↓ cs</strong><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">var task = Task&lt;List&lt;int>>.Run(() => {
    Thread.Sleep(1000);
    return new List&lt;int> { 2 };
});
var myList = new List&lt;int>(new int[] { 1 });
task.Wait();
myList.AddRange(task.Result);</div><li>병렬 처리 System.Threading.Tasks.Parallel</li><strong>↓ cs</strong><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">void DoSomething(int i) => Console.WriteLine(i);
Parallel.For(0, 100, DoSomething);
</div></ul><h1 class="marker">네트워킹</h1><ul><li>System.Net.IPAddress</li><li>System.Net.IPEndPoint : IPAddress + port</li><li>System.Net.Dns : Dns.GetHostEntry()</li><li>System.Net.Sockets.Socket</li><p>Socket(IPv4/6, Stream, Tcp) or Socket(IPv4/6, Dgram, Udp)</p><li>System.Net.HttpWebRequest : WebRequest.Create() as HttpWebRequest</li><li>System.Net.WebClient</li></ul><h1 class="marker">DB : ADO.NET</h1><ul><li>ADO.NET : DBMS 통신 닷넷 구현 라이브러리. 각 DBMS마다 만들어진 걸 이용하면 된다. 아래의 공통 인터페이스를 구현한다.</li><li>System.Data.IDbConnection</li><li>트랜잭션 1</li><strong>↓ cs</strong><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">using(var transaction = sqlConnection.BeginTransaction) {
    var command = new SqlCommand();
    command.Connection = sqlConnection;
    command.Transaction = transaction;
    // ...
    transaction.Commit();
}</div><li>트랜잭션 2</li><strong>↓ cs</strong><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">using(var sqlConnection = new SqlConnection(connectionString);
    var transactionScope = new TransactionScope()) {
    sqlConnection.Open();
    // ...
    transactionScope.Complete();
}</div><li>System.Data.IDbCommand : DB 서버로 쿼리 전달</li><ul><li>ExecuteNonQuery : INSERT, UPDATE, DELETE → 영향 받은 행의 수 반환</li><li>ExecuteScalar : SELECT → 단일값 반환</li><li>ExecuteReader : SELECT → 다중 레코드 반환</li></ul><li>System.Data.IDataReader : 쿼리 결과 해석</li><li>System.Data.IDbDataParameter : Parameterized command에 사용될 매개변수</li><strong>↓ cs</strong><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">var email = new SqlParameter("email", SqlDbType.NVarChar, 120);
sqlCommand.CommandText = "INSERT INTO t_account(account_id, email) VALUES(@account_id, @email)";</div><li>System.Data.IDbDataAdapter</li><p>System.Data.DataTable ↔ 닷넷 클래스(POCO; 자바의 POJO와 유사한 개념) 사이의 어댑터</p><strong>↓ cs</strong><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">var dataSet = new DataSet();
new SqlDataAdapter("select * from t_account", sqlConnection).Fill(dataSet, "t_account");</div><li>ORM</li><ul><li>MS SQL 서버 또는 Azure와 연결하여 자동으로 모델을 구성할 수 있다.</li><li>추가 - 새 항목 - [데이터] ADO.NET 엔터티 데이터 모델</li><li>MySQL, PostgreSQL도 확장을 설치하거나 하면 된다는 것 같은데...</li><li>https://dev.mysql.com/downloads/windows/visualstudio/</li><li>https://dev.mysql.com/doc/visual-studio/en/visual-studio-entity-framework.html</li><li>https://stackoverflow.com/q/32045852/7369515</li></ul></ul><h1 class="marker">윈도우 레지스트리</h1><strong>↓ cs</strong><div lan="cs" class="as-code code-div w3-leftbar w3-border-green">Registry.ClassesRoot : HKEY_CLASSES_ROOT
Registry.CurrentUser : HEKY_CURRENT_USER
Registry.LocalMachine : HKEY_LOCAL_MACHINE
Registry.Users : HKEY_USERS
Registry.CurrentConfig : HKEY_CURRENT_CONFIG
Registry.LocalMachine.OpenSubKey(@"HARDWARE\DESCRIPTION\System\BIOS").GetValue("Key")
Registry.LocalMachine.OpenSubKey(@"HARDWARE\DESCRIPTION\System\BIOS", true).SetValue("Key", value)
REG_SZ → string
REG_BINARY → byte[]
REG_DWORD → int
REG_QWORD → long
REG_MULTI_SZ → string[]</div></div><hr>&copy; 2020. <a href="mailto:hi.donggi@gmail.com">Donggi Kim</a> all rights reserved.<a class="w3-btn w3-round w3-round-xxlarge w3-small w3-green" href="/LICENSE" target="_blank">LICENSE</a></div></body></html>