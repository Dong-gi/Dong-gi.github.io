        <th>Truth Value Testing</th>
            1. 모든 객체는 if 조건, while 조건, Boolean 연산에 이용하기 위한 진리값 판별이 가능하다.
            <br>
            <br>2. 기본적으로 __bool__() 메서드가 false를 반환하거나 __len__() 메서드가 0을 반환하지 않는 객체는 참이다.

            <th>Boolean Operations</th>
            1. and(short-circuit 연산), or(short-circuit 연산), not

            <th>Comparisons</th>
            1. 연속적인 비교가 가능하다. 예를 들어 x &lt; y &lt;= z는 y가 한번만 계산된다는 것만 빼곤 x &lt; y and y &lt;= z와 동일하다. 두 경우 모두에서 x &lt; y가 거짓이면 z는 계산되지
            않는다.
            <br>
            <br>2. &lt;, &lt;=, &gt;, &gt;=, ==, !=, is(object identity), is not
            <br>
            <br>3. __eq__() 메서드를 정의하지 않는 이상 인스턴스들은 보통 같지 않다고 판단한다.
            <br>
            <br>4. __lt__(), __le__(), __gt__(), __ge__() 등을 충분히 정의하지 않으면 정렬이 불가능하다. 보통 __lt__()와 __eq__()로 충분하다.

            <th>Numeric Types</th>
            1. int, float, complex
            <br>&raquo; int 정밀도는 제한이 없다.
            <br>&raquo; 정밀도 등 float에 관한 정보는 sys.float_info를 통해 확인할 수 있다.
            <br>&raquo; complex의 실수부(z.real) 허수부(z.imag)는 각각 float이다.
            <br>
            <br>2. fractions(유리수), decimal(사용자 정의 정밀도 부동소수)
            <br>
            <br>3. x + y, x - y, x * y, x / y, x // y, x % y, -x, +x, abs(x), int(x), float(x), complex(re, im),
            c.conjugate() 켤레복소수, divmod(x, y), pow(x, y), x ** y
            <br>
            <br>4. Bitwise Operations : x | y, x ^ y, x &amp; y, x &lt;&lt; n, x &gt;&gt; n, ~x
            <br>
            <br>5. Since 3.1 int.bit_length()
            <br>Since 3.2 int.to_bytes(length, byteorder, *, signed=False)
            <br>&raquo; byteorder : "big", "little". 음수의 경우 sys.byteorder를 이용한다.
            <br>Since 3.2 classmethod int.from_bytes(bytes, byteorder, *, signed=False)
            <br>&raquo; bytes는 bytes-like object거나 byte 반복자여야 한다.
            <br>&raquo; byteorder : "big", "little". 음수의 경우 sys.byteorder를 이용한다.
            <br>
            <br>6. float은 numbers.Real 추상 클래스의 구현이며, 아래의 추가 메서드를 갖는다.
            <br>float.as_integer_ratio() : (분자, 분모) 튜플을 반환한다. 분모는 양수.
            <br>float.is_integer()
            <br>float.hex() : 0x로 시작하고 p로 끝난뒤 지수가 붙는다. 지수의 base는 2
            <br>classmethod float.fromhex(s) : C의 %a 포맷과 Java의 Double.toHexString()의 결과를 받아들일 수 있다.
            <br>
            <br>7. Hashing : modulo P for a fixed prime P. sys.hash_info에서 P를 확인할 수 있다.

            <th>Iterator Types</th>
            1. container.__iter__()
            <br>&raquo; container가 iteration을 지원하려면 정의해야 한다. 반환하는 객체는 iterator protocol을 지원해야 된다.
            <br>
            <br>2. iterator.__iter__()
            <br>&raquo; Return the iterator object itself.
            <br>
            <br>3. iterator.__next__()
            <br>&raquo; 다음 요소 반환. 없으면 StopIteration 예외 발생.
            <br>
            <br>4. Generator
            <br>&raquo; Generator는 iterator protocol을 쉽게 제공한다. container의 __iter__()가 generator로 정의된 경우, 자동으로
            __iter__()와 __next__()를 지원하는 iterator 객체를 반환한다.

            <th>Sequence Types</th>
            1. list, tuple, range
            <br>
            <br>2. Common Sequence Operations
            <br>&raquo; collections.abc.Sequence는 사용자 정의 sequence 타입의 연산 정의를 도와준다.
            <br>&raquo; x in s, x not in s, s + t 접합, s * n or n * s // s의 n번 동시 접근, s[i], s[i:j], s[i:j:k],
            len(s), min(s), max(s), s.index(x[, i[, j]]) // s[i:j]중 처음 등장하는 x, s.count(x)
            <br>Notes
            <br>&raquo; str, bytes, bytearray도 subsequence 검사에 in을 이용할 수 있다.
            <br>&raquo; s * n은 s를 n번 복제하는 것이 아니라 s를 n번 접근하는 것이다.
            <br>&gt;&gt;&gt; lists = [[]] * 3
            <br>&gt;&gt;&gt; lists[0].append(3)
            <br>&gt;&gt;&gt; lists
            <br>[[3], [3], [3]]
            <br>&raquo; 같은 것을 여러 개 복제하려면 list comprehension을 이용한다. 예: [[] for i in range(3)]
            <br>&raquo; index가 음수일 경우 len(s) + i가 대신 쓰인다. 단, -0 == 0
            <br>&raquo; 불변 sequence들의 접합은 항상 새로운 객체를 생성하며, 시간 비용이 이차방정식이다. 보다 빠른 접합: str의 경우 str.join() 또는 io.StringIO
            이용, bytes의 경우 bytes.join() 또는 io.BytesIO 또는 bytearray 이용, tuple의 경우 list를 대신 이용
            <br>
            <br>3. Immutable Sequence Types : hash()를 지원한다.
            <br>
            <br>4. Mutable Sequence Types
            <br>&raquo; collections.abc.MutableSequence는 사용자 정의 sequence 타입의 연산 정의를 도와준다.
            <br>&raquo; s[i] = x, x[i:j] = t, del s[i:j], s[i:j:k] = t 길이가 일치해야 한다, del s[i:j:k], s.append(x),
            s.clear(), s.copy(), s.extend(t) or s += t, s *= n, s.insert(i, x), s.pop([i]), s.remove(x),
            s.reverse()
            <br>
            <br>5. Lists
            <br>&raquo; class list([iterable]) : 주로 같은 타입 요소들에 대한 변경 가능 시퀀스로 이용
            <br>&raquo; sort(*, key=None, reverse=False) : key는 정렬 함수로, 각 요소들의 결과값들이 정렬에 이용된다.
            <br>
            <br>6. Tuples
            <br>&raquo; class tuple([iterable]) : 주로 같은 타입 요소들에 대한 변경 불가 시퀀스로 이용
            <br>&raquo; collections.namedtuple() : 이종 요소들로 이루어져 이름으로 접근하는 튜플
            <br>
            <br>7. Ranges
            <br>&raquo; class range(stop)
            <br>&raquo; class range(start, stop[, step]) : range는 start, stop, step만 기억하면 되므로 메모리를 적게 사용한다.

            <th>Text Sequence Type</th>
            1. str 객체 또는 유니코드 시퀀스 strings로 표현하며, 모두 내용은 변경 불가능하다.
            <br>
            <br>2. class str(object=")
            <br>class str(object=b", encoding='utf-8', errors='strict')
            <br>&raquo; encoding, errors 둘 다 없으면 object.__str__() 또는 repr(object) 반환
            <br>&raquo; encoding, errors 하나라도 있으면 object는 bytes-like object여야 한다. bytes.decode(encoding, errors)를
            반환한다.
            <br>
            <br>3. String Methods
            <br>&raquo; str.capitalize(), str.casefold() : lower()보다 강한 변환, str.upper(), str.lower(), str.swapcase()
            : 두 번 적용한 것이 원본과 항상 같지는 않다, str.title() : 제목 문자열(각 단어의 시작만 대문자)을 반환한다
            <br>&raquo; str.center(width[, fillchar]), str.ljust(width[, fillchar]), str.rjust(width[, fillchar])
            <br>&raquo; str.count(sub[, start[, end]]), str.find(sub[, start[, end]]), str.rfind(sub[, start[,
            end]]), str.index(sub[, start[, end]]), str.rindex(sub[, start[, end]])
            <br>* find : 처음 등장하는 위치를 반환한다. 없으면 -1. 단순 포함 여부 확인은 in 연산자를 이용한다.
            <br>* index : find와 같으나 없으면 ValueError 발생.
            <br>&raquo; str.endswith(suffix[, start[, end]]), str.startswith(prefix[, start[, end]]) : suffix,
            prefix에 튜플도 가능
            <br>&raquo; str.encode(encoding="utf-8", errors="strict")
            <br>&raquo; str.expandtabs(tabsize=8) : 오피스 문서와 같은 탭 작업. 문자열 끝에 탭이 존재하면 결과적으로 반환된 문자열은 tabsize의 배수
            길이가 된다.
            <br>&raquo; str.format(*args, **kwargs), str.format_map(mapping) : str.format(**mapping)과 유사.
            <button onclick='javascript:showCode("samples/format_map_example.py", "python");' class="btn btn-primary btn-sm">
                예제 &raquo;
            </button>
            <a role="button" class="btn btn-info btn-sm" href="https://docs.python.org/3/library/stdtypes.html#str.format_map">출처: https://docs.python.org/3/library/stdtypes.html#str.format_map</a>
            <br>&raquo; str.isalnum(), str.isalpha(), str.isdecimal() : 10진 숫자만, str.isdigit(), str.isidentifier(),
            str.islower(), str.isnumeric() : digit보다 광범위, str.isprintable(), str.isspace(), str.istitle(),
            str.isupper()
            <br>&raquo; str.join(iterable) : iterable 문자열들을 str로 접합
            <br>&raquo; str.strip([chars]), str.lstrip([chars]), str.rstrip([chars]) : 연속한 chars에 속하는 문자들을 제거한다.
            인자가 없는 경우 연속적인 공백을 제거한다.
            <br>&raquo; static str.maketrans(x[, y[, z]]) : str.translate()에 쓰일 번역 테이블을 생성한다. 인자가 하나 주어진 경우 아래
            서술한 table이어야 하고, 2개 주어진 경우 같은 길이의 문자열이어야 한다. 3개 주어진 경우 마지막 문자열의 각 문자들은 None에 매핑된다.
            <br>&raquo; str.translate(table) : table의 key는 유니코드 정수여야 하고, 대응하는 value는 유니코드 정수값이나 문자열이 가능하다.
            <button onclick='javascript:showCode("samples/translate_example.py", "python");' class="btn btn-primary btn-sm">
                예제 &raquo;
            </button>
            <button onclick='javascript:showCode("samples/con17.txt", "text");' class="btn btn-primary btn-sm">
                Console &raquo;
            </button>
            <br>&raquo; str.partition(sep), str.rpartition(sep) : 처음 만나는 sep을 기준으로 분리하여, (앞부분, sep, 뒷부분)을 반환.
            sep이 없을 경우 (sep, '', '')반환.
            <br>&raquo; str.split(sep=None, maxsplit=-1), str.rsplit(sep=None, maxsplit=-1) : sep으로 분리한 부분 문자열
            리스트 반환. sep이 주어지지 않은 경우 공백문자로 분리하며, 연속적인 공백문자도 하나의 공백으로 처리하고 결과에 빈 문자열은 포함하지 않는다.
            <br>&raquo; str.splitlines([keepends]) : keepends=True면 줄바꿈 문자를 결과에 포함한다.
            <br>&raquo; str.replace(old, new[, count])
            <br>&raquo; str.zfill(width) : '0'을 문자열 앞에 붙인다. 처음 등장하는 '+', '-'는 위치 유지.

            <th>Binary Sequence Types</th>
            1. bytes, bytearray, memoryview : 핵심 자료형은 bytes, bytearray며, memoryview는 다른 이진 객체를 복사하지 않고 buffer protocol을 통해 접근한다.
            <br>
            <br>2. Bytes Objects : 변경불가.
            <br>&raquo; class bytes([source[, encoding[, errors]]])
            <br>* b'hello'처럼 b로 시작하는 문자열 리터럴은 bytes 리터럴이다. 단, ASCII 문자만 가능하다.
            <br>* 0으로 초기화된 특정 길이 bytes : bytes(size)
            <br>* 정수 iterable로부터 생성 : bytes(iterable)
            <br>* 기존 이진 객체(buffer protocol)로부터 생성 : bytes(obj)
            <br>&raquo;&raquo; classmethod fromhex(string) : 16진수 표기 문자열로부터 생성. string은 반드시 1바이트당 2개 16진수를 포함해야하고,
            ' '는 무시된다.
            <br>&raquo;&raquo; Since 3.5 hex() : 16진수 표기 문자열 반환.
            <br>&raquo; 문자열과 달리 bytes 객체 b의 b[0]는 정수, b[0:1]는 길이 1의 bytes 객체다.
            <br>&raquo; bytes 객체는 보통 바이너리 문자열로 표현되며, 각 바이트 숫자를 확인하는 데는 list(b)가 유용하다.
            <br>
            <br>3. Bytearray Objects
            <br>&raquo; class bytearray([source[, encoding[, errors]]])
            <br>* 빈 bytearray 객체 : bytearray()
            <br>* 0으로 초기화된 특정 길이 bytearray 객체 : bytearray(size)
            <br>* 정수 iterable로부터 생성 : bytearray(iterable)
            <br>* 기존 이진 객체(buffer protocol)로부터 생성 : bytearray(buf)
            <br>&raquo;&raquo; classmethod fromhex(string) : bytes와 비슷한 동작을 한다.
            <br>&raquo;&raquo; Since 3.5 hex() : bytes와 비슷한 동작을 한다.
            <br>
            <br>4. Bytes and Bytearray Operations
            <br>&raquo; bytes.count(sub[, start[, end]]), bytearray.count(sub[, start[, end]])
            <br>* sub는 bytes-like object 거나 (Since 3.3) [0, 255] 사이의 정수여야 한다.
            <br>&raquo; bytes.decode(encoding="utf-8", errors="strict"), bytearray.decode(encoding="utf-8", errors="strict")
            <br>&raquo; bytes.endswith(suffix[, start[, end]]), bytearray.endswith(suffix[, start[, end]]), bytes.startswith(prefix[,
            start[, end]]), bytearray.startswith(prefix[, start[, end]])
            <br>* suffix, prefix는 찾고자 하는 것들의 튜플일 수 있다.
            <br>&raquo; bytes.find(sub[, start[, end]]), bytearray.find(sub[, start[, end]]), bytes.rfind(sub[,
            start[, end]]), bytearray.rfind(sub[, start[, end]])
            <br>* 처음 등장하는 위치를 반환한다. 없으면 -1. 단순히 포함 여부는 in 연산자를 사용한다.
            <br>* Since 3.3 sub로 [0, 255] 사이의 정수도 가능
            <br>&raquo; bytes.index(sub[, start[, end]]), bytearray.index(sub[, start[, end]]), bytes.rindex(sub[,
            start[, end]]), bytearray.rindex(sub[, start[, end]])
            <br>* find와 같지만 포함하지 않으면 ValueError를 발생한다.
            <br>* Since 3.3 sub로 [0, 255] 사이의 정수도 가능
            <br>&raquo; bytes.join(iterable), bytearray.join(iterable)
            <br>&raquo; Since 3.1 static bytes.maketrans(from, to), Since 3.1 static bytearray.maketrans(from,
            to)
            <br>* from, to는 같은 길이의 bytes-like 객체여야 한다. translate()에 이용할 테이블을 생성한다.
            <br>&raquo; bytes.translate(table, delete=b''), bytearray.translate(table, delete=b'')
            <br>* 포함하는 delete 안의 바이트들을 모두 제거한 뒤 table에 따라 변환한다. table은 길이 256의 bytes 객체여야 한다.
            <br>&raquo; bytes.partition(sep), bytearray.partition(sep), bytes.rpartition(sep), bytearray.rpartition(sep)
            <br>* sep으로 구분하여 (before, sep, after)를 반환한다. 없으면 (sep, b'' | bytearray(b''), b'' | bytearray(b''))
            반환
            <br>* Since 3.6 delete가 키워드 인자로 변경.
            <br>&raquo; bytes.center(width[, fillbyte]), bytearray.center(width[, fillbyte]), bytes.ljust(width[,
            fillbyte]), bytearray.ljust(width[, fillbyte]), bytes.rjust(width[, fillbyte]), bytearray.rjust(width[,
            fillbyte])
            <br>&raquo; bytes.strip([chars]), bytearray.strip([chars]), bytes.lstrip([chars]), bytearray.lstrip([chars]),
            bytes.rstrip([chars]), bytearray.rstrip([chars])
            <br>* 연속한 chars에 속하는 문자들을 제거한다. 인자가 없는 경우 연속적인 공백을 제거한다.
            <br>&raquo; bytes.split(sep=None, maxsplit=-1), bytearray.split(sep=None, maxsplit=-1), bytes.rsplit(sep=None,
            maxsplit=-1), bytearray.rsplit(sep=None, maxsplit=-1)
            <br>* sep으로 분리한 부분 이진 문자열 리스트 반환. sep이 주어지지 않은 경우 공백문자로 분리하며, 연속적인 공백문자도 하나의 공백으로 처리하고 결과에 빈 이진 문자열은
            포함하지 않는다.
            <br>&raquo; bytes.expandtabs(tabsize=8), bytearray.expandtabs(tabsize=8)
            <br>* 오피스 문서와 같은 탭 작업. 문자열 끝에 탭이 존재하면 결과적으로 반환된 문자열은 tabsize의 배수 길이가 된다.
            <br>&raquo; bytes.splitlines(keepends=False), bytearray.splitlines(keepends=False)
            <br>* 줄 바꿈 문자를 기준으로 나누며, 결과에 줄 바꿈 문자를 포함할지는 keepends로 결정한다.
            <br>&raquo; bytes.capitalize(), bytearray.capitalize(), bytes.lower(), bytearray.lower(), bytes.swapcase(),
            bytearray.swapcase(), bytes.title(), bytearray.title(), bytes.upper(), bytearray.upper()
            <br>&raquo; bytes.isalnum(), bytearray.isalnum(), bytes.imalpha(), bytearray.isalpha(), bytes.isdigit(),
            bytearray.isdigit(), bytes.islower(), bytearray.islower(), bytes.isspace(), bytearray.isspace(),
            bytes.istitle(), bytearray.istitle(), bytes.isupper(), bytearray.isupper()
            <br>&raquo; bytes.zfill(width), bytearray.zfill(width)
            <br>* width가 될 때까지 b'0'을 앞에 채운다. 맨 처음 등장하는 b'+', b'-'는 위치를 유지한다.
            <br>
            <br>5. printf-style Bytes Formatting Since 3.5
            <br>&raquo; % 연산자 : (format 문자열) % 인자
            <br>&raquo; '%' + opt. (key) + opt. flags + opt. min field width + opt. precision + type
            <br>&raquo; 인자가 dictionary 또는 다른 mapping 타입인 경우, format 문자열은 반드시 key를 포함해야 한다.
            <br>&raquo; flag : '0'(zero pad), '-'(왼쪽정렬), ' '(양수 앞에 공백 추가), '+'(양수 앞에 부호 표기)
            <br>&raquo; type : 'd'|'i'|'u'(10진 정수), 'o'(8진수), 'x'|'X'(16진수), 'e'|'E'(지수 표기), 'f'|'F'(10진 부동소수),
            'g'|'G', 'c'(single byte), 'b'(bytes), 's', 'a'|'r'(bytes: repr(obj).encode('ascii', 'backslashreplace')),
            '%'(변환 없이 '%' 삽입)
            <br>
            <br>6. Memory Views
            <br>&raquo; class memoryview(obj)
            <br>* obj가 수정 가능할 경우, 1차원 slice 할당이 가능하다. 단, 크기 변경은 불가능하다.
            <br>* Since 3.3 1차원 memoryview는 slicing 가능
            <br>* Since 3.4 memoryview는 자동으로 collections.abc.Sequence
            <br>* Since 3.5 정수 tuple로 indexing 가능
            <br>&raquo; __eq__(exporter) : struct 모듈이 지원하지 않는 객체의 비교는 False
            <br>&raquo; tobytes() : bytes 생성자 호출과 같은 결과
            <br>&raquo; hex() Since 3.5 : 16진수 문자열(not binary) 반환
            <br>&raquo; tolist() : 버퍼 데이터를 리스트로 반환
            <br>&raquo; release() Since 3.2 : memoryview가 더 이상 buffer를 사용하지 않는다. view로 인해 생긴 buffer의 제한이 사라진다.
            <br>&raquo; cast(format[, shape]) Since 3.3 : shape 기본값은 [byte_length//new_itemsize], 같은 buffer를
            참조하는 새 memoryview 객체를 반환한다.
            <br>&raquo; obj Since 3.3 : view 객체의 buffer
            <br>&raquo; nbytes Since 3.3 : 바이트 크기
            <br>&raquo; readonly
            <br>&raquo; format : struct 모듈 스타일의 format string
            <br>&raquo; itemsize : 요소 하나의 바이트 크기
            <br>&raquo; ndim, shape, strides : 각 차원 원소의 바이트 크기들

            <th>Set Types</th>
            1. set, frozenset : 해쉬 가능한 순서 없는 collection. frozenset은 불변이며, 다른 set의 원소가 될 수 있다.
            <br>
            <br>2. class set([iterable])
            <br>class frozenset([iterable])
            <br>* 연산자 버전이 있는 메서드들은 인자로 iterable도 받을 수 있다.
            <br>* set과 frozenset 두 가지에 대한 연산 결과는 첫번째 피연산자의 타입이다.
            <br>&raquo; len(s), x in s, x not in s, for x in set
            <br>&raquo; isdisjoint(other) : 교집합이 공집합인지 여부
            <br>&raquo; issubset(other) : 연산자 &lt;=, &lt;로도 가능
            <br>&raquo; issuperset(other) : 연산자 &gt;=, &gt;로도 가능
            <br>&raquo; union(*others) : 연산자 |로도 가능
            <br>&raquo; intersection(*others) : 연산자 &amp;로도 가능
            <br>&raquo; difference(*others) : 연산자 -로도 가능
            <br>&raquo; symmetric_difference(other) : 연산자 ^로도 가능
            <br>&raquo; update(*others) : others의 모든 원소 추가. set |= other | ...
            <br>&raquo; intersection_update(*others) : 호출자를 포함한 모든 집합에 속하는 공통 원소들만. set &amp;= other &amp; ...
            <br>&raquo; difference_update(*others) : 호출자에 속하는 원소들만. set -= other | ...
            <br>&raquo; symmetric_difference_update(other) : set ^= other
            <br>&raquo; copy(), add(elem), remove(elem) : 없으면 KeyError, discard(elem) : 포함하면 삭제, pop() : 임의 원소
            빼기, clear()
            <br>* elem은 set일 수 있다.

            <th>Mapping Types</th>
            1. dict : mapping 객체는 해쉬가능한 값을 임의의 객체로 매핑한다.
            <br>
            <br>2. class dict(**kwarg)
            <br>class dict(mapping, **kwarg)
            <br>class dict(iterable, **kwarg)
            <br>&nbsp;&nbsp;&nbsp;&nbsp;a = dict(one=1, two=2, three=3)
            <br>&nbsp;&nbsp;&nbsp;&nbsp;b = {'one': 1, 'two': 2, 'three': 3}
            <br>&nbsp;&nbsp;&nbsp;&nbsp;c = dict(zip(['one', 'two', 'three'], [1, 2, 3]))
            <br>&nbsp;&nbsp;&nbsp;&nbsp;d = dict([('two', 2), ('one', 1), ('three', 3)])
            <br>&nbsp;&nbsp;&nbsp;&nbsp;e = dict({'three': 3, 'one': 1, 'two': 2})
            <br>&nbsp;&nbsp;&nbsp;&nbsp;a == b == c == d == e
            <br>
            <br>3. Dictionary Operations
            <br>&raquo; len(d), d[key], d[key] = value, del d[key], key in d, key not in d, iter(d)
            <br>&raquo; copy(), clear()
            <br>&raquo; classmethod fromkeys(seq[, value]) : seq를 키로 하는 딕셔너리 반환. value의 기본값은 None
            <br>&raquo; get(key[, default]) : key가 없으면 default 반환
            <br>&raquo; items() : (key, value)쌍에 대한 view 반환, keys() : key에 대한 view 반환, values() : value에 대한 view
            반환
            <br>&raquo; pop(key[, default]), popitem() : 임의의 (key, value) 빼기
            <br>&raquo; setdefault(key[, default]) : key가 있으면 value 반환, 없으면 default로 추가하고 defualt 반환. 둘 다 없으면
            KeyError
            <br>&raquo; update([other]) : other에는 dict 생성 인자들 모두 허용된다.
            <br>
            <br>4. Dictionary view objects
            <br>* dict의 변화는 view에도 반영된다.
            <br>&raquo; len(dictview), iter(dictview) : dict 수정 중엔 RuntimeError 가능성, x in dictview

            <th>Context Manager Types</th>
            1. with statement : context manager가 정의한 runtime context를 지원
            <br>&raquo; contextmanager.__enter__() : 반환된 객체는 with문의 as 절의 식별자에 bound된다.
            <br>&raquo; contextmanager.__exit__(exc_type, exc_val, exc_tb) : 억제된 예외가 있는지 여부 반환. True면 인자에 예외
            타입, 값, traceback 정보가 넘어간다.

            <th>Special Attributes</th>
            &raquo; object.__dict__, instance.__class__, class.__bases__, definition.__name__, class.subclasses__()
            <br>&raquo; class.__mro__ : method를 찾는 순서, class.mro() : 재정의 가능. __mro__ 반환.
            <br>&raquo; Since 3.3 definition.__qualname__ : qualified name(모듈의 글로벌 스코프부터 호출자까지 '.'으로 구분)
