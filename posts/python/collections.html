<script src="/source/redirect.js?200226_1657"></script>
<hr>

<details>
    <summary>class ChainMap(_collections_abc.MutableMapping) Since 3.3</summary>
    <ul>
        <li>class collections.ChainMap(*maps)</li>
        <ul>
            <li>여러 dict, 매핑을 한데 모아 갱신 가능한 view를 만든다.</li>
            <li>maps : 뷰 내부의 리스트로 저장된다. ─ self.maps = list(maps) or [{}]</li>
            <li>__setitem__, __delitem__, popitem(), pop(), clear()는 self.maps[0]에만 적용된다</li>
        </ul>
        <li>maps : __getitem__에서 리스트 순서대로 탐색하며, 변경 가능하다.</li>
        <li>new_child(m=None)</li>
        x.new_child(m) == ChainMap(m if m != None else {}, *x.maps)
        <li>parents</li>
        x.super() == ChainMap(*x.maps[1:])
    </ul>
</details>

<hr>

<details>
    <summary>class Counter(dict) Since 3.1</summary>
    <ul>
        <li>class collections.Counter([iterable-or-mapping])</li>
        <ul>
            <li>def __init__(self, iterable=None, /, **kwds)</li>
            self.update(iterable, **kwds)
            <li>Counter는 없는 키에 대하여 KeyError를 발생하지 않고, 새로운 키를 추가하고 0을 반환한다.</li>
        </ul>
        <li>elements()</li>
        각 원소들을 각 카운트만큼 반복하는 iterator를 반환한다.
        <li>most_common([n])</li>
        가장 많은 n개의 원소들을 개수와 함께 반환한다.
        <li>update([iterable-or-mapping]) ↔ subtract()</li>
        <ul>
            <li>('gallahad') # iterable 각 요소 1씩 카운트</li>
            <li>({'red': 4, 'blue': 2}) # 각 value만큼 카운트</li>
            <li>(cats=4, dogs=8) # 각 value만큼 카운트</li>
        </ul>
    </ul>
</details>

<hr>

<details>
    <summary>deque</summary>
    <ul>
        <li>class collections.deque([iterable[, maxlen]])</li>
        <ul>
            <li>iterable이 존재하면 좌→우 순서대로 append()</li>
            <li>스레드-안전, 메모리 효율적인 O(1)에 근접한 기능을 제공.</li>
            <li>list도 비슷한 기능을 제공하나, 고정 길이 연산에 적합하며, 길이가 바뀌는 연산은 O(n) 메모리 이동이 발생</li>
            <li>maxlen이 주어졌다면 추가적인 삽입은 반대쪽 원소의 제거와 동시에 일어난다. 최근 n개만 관심 있는 경우 등에 유용.</li>
        </ul>
        <li>삽입</li>
        <ul>
            <li>append(x) + appendleft</li>
            <li>extend(iterable) + extendleft</li>
            <li>insert(i, x) Since 3.5</li>
        </ul>
        <li>삭제</li>
        <ul>
            <li>clear()</li>
            <li>pop() + popleft</li>
            <li>remove(value)</li>
        </ul>
        <li>copy() Since 3.5 : 얕은 복사</li>
        <li>count(x) Since 3.2</li>
        <li>index(x[, start[, stop]]) Since 3.5</li>
        <li>reverse() Since 3.2 : 제자리에서 순서를 변경하고 None 반환</li>
        <li>rotate(n=1) : n번 우로 이동(d.appendleft(d.pop())). 음수면 좌로 이동.</li>
        <li>maxlen Since 3.1 : 없으면 None</li>
        이외에 iteration, pickling(Python 객체 직렬화), len(d), reversed(d), copy.copy(d), copy.deepcopy(d), in 연산자, index 접근(느림) 지원.
        <li>Since 3.5 : __add__(), __mul__(), __imul__() 지원</li>
    </ul>
</details>

<hr>

<details>
    <summary>defaultdict</summary>
    <ul>
        <li>class collections.defaultdict([default_factory[, ...]])</li>
        <ul>
            <li>dict을 상속한다.</li>
            <li>무인자 함수 default_factory(기본값 None)로 기본값을 제공한다.</li>
            예. 기본값으로 리스트 사용 → defaultdict(list)
            <li>나머지 인자는 dict의 생성자에서 받아들이는 것과 동일하다.</li>
        </ul>
        <li>__missing__(key)</li>
        default_factory가 None이면 KeyError, 아니면 default_factory 호출.
        <li>default_factory</li>
    </ul>
</details>

<hr>

<details>
    <summary>namedtuple</summary>
    <ul>
        <li>collections.namedtuple(typename, field_names, *, rename=False, defaults=None, module=None)</li>
        <ul>
            <li>이름이 typename인 tuple의 서브클래스를 반환. 인스턴스들은 유용한 docstring과 __repr__()을 갖는다.</li>
            <li>filed_names</li>
            _fields 속성. 문자열의 시퀀스거나, 'x y'또는 'x, y'처럼 분리한 단일 문자열일 수 있다.
            <li>rename Since 3.1</li>
            True면 유효하지 않은 필드명은 '_1'처럼 인덱스 이름으로 설정된다
            <li>defaults Since 3.7</li>
            _field_defaults 속성. None 아니면 iterable을 제공. 기본값의 수는 필드보다 적어도 되지만, 기본값을 갖는 필드들은 우측부터임에 유의
            <li>module Since 3.6</li>
            __module__ 속성
        </ul>
        <li>classmethod somenamedtuple._make(iterable)</li>
        <li>somenamedtuple._asdict() : OrderedDict 반환</li>
        <li>somenamedtuple._replace(**kwargs)</li>
        값을 변경한 새 튜플 반환
        <li>getattr(somenamedtuple, 'attr_name') 가능</li>
        <li>somenamedtuple(**somedict) 가능</li>
        <li>class Sub(somenamedtuple): 가능</li>
        <li>Since 3.5 : 생성된 클래스의 __doc__ 속성 쓰기 가능</li>
    </ul>
</details>

<hr>

<details>
    <summary>class OrderedDict(dict) Since 3.1</summary>
    <ul>
        <li>class collections.OrderedDict([items])</li>
        <li>popitem(last=True)</li>
        <li>move_to_end(key, last=True) Since 3.2</li>
        last=True면 우측 끝으로, 아니면 왼쪽 끝으로
        <li>OrderedDict 객체끼리의 비교는 순서가 중요하지만, 다른 Mapping 객체와의 비교에서는 순서 상관없다.</li>
        <li>Since 3.5 : OrderedDict의 items, keys, values view들이 reversed() 지원.</li>
    </ul>
</details>

<hr>

<details>
    <summary>class UserDict(_collections_abc.MutableMapping)</summary>
    dict를 상속하기 쉽게 만든 래퍼 클래스. self.data에 실제 dict가 존재
</details>

<hr>

<details>
    <summary>class UserList(_collections_abc.MutableSequence)</summary>
    list를 상속하기 쉽게 만든 래퍼 클래스. self.data에 실제 list가 존재
</details>

<hr>

<details>
    <summary>class UserString(_collections_abc.Sequence)</summary>
    str을 상속하기 쉽게 만든 래퍼 클래스. self.data에 실제 str이 존재
</details>

<hr>