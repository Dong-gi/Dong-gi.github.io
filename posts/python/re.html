<script src="/source/redirect.js?200226_1657"></script>
<hr>

<details>
    <summary>Regular Expression Syntax</summary>
    <ul>
        <li>str과 bytes모두 지원하지만, 찾는 패턴과 대상의 타입은 일치해야 한다.</li>
        <li>이스케이프하지 않는 raw string(r'')을 이용하면 편리하다</li>
        ↓ 자바 정규표현식과 동일한 부분은 생략했음
        <li>[] : 문자 집합</li>
        <ul>
            <li>문자열 리터럴 표준 이스케이프 \a, \b, \f, \n, \r, \t, \u Since 3.3, \U Since 3.3, \v, \x, \\를 이용할 수 있다.</li>
            <li>\w, \S 등의 character class는 의미를 그대로 갖는다.</li>
        </ul>
        <li>(?...) : 확장 표현</li>
        <ul>
            <li>(?#...) : 주석</li>
            <li>(?aiLmsux)</li>
            'a', 'i', 'L', 'm', 's', 'u', 'x'중 하나 이상 사용. 각각 re.A, re.I, re.L, re.M, re.S, re.U, re.X 플래그를 설정한다
            <li>(?aiLmsux-imsx:...) Since 3.7</li>
            '-' 이후의 옵션들은 관계된 플래그를 해제한다는 의미
            <li>(?P&lt;name&gt;...)</li>
            Named capturing group. name은 Python 식별자 규칙을 따라야 한다.
            <li>(?P=name) : Named capturing group에 대한 backreference</li>
            <li>(?&lt;=...)</li>
            Positive lookbehind. (...)이 매칭하는 문자열은 고정 길이여야 한다. group 참조 가능(Since 3.5)
            <li>(?&lt;!...)</li>
            Negative lookbehind. (...)이 매칭하는 문자열은 고정 길이여야 한다.
            <li>(?(id/name)yes-pattern|no-pattern)</li>
            id or name의 그룹이 매칭되면 yes-pattern을, 아니면 no-pattern을 매칭. no-pattern은 없어도 된다.
        </ul>
        <li>\number # 해당 순번의 그룹에 대한 backreference. 그룹 번호는 [1, 99]</li>
        <li>\A ↔ \Z # 문자열 시작 경계 매칭</li>
        <li>\b ↔ \B # Word의 시작 또는 끝 경계 매칭. \w와 \W 사이의 경계로 정의된다.</li>
        <li>\d ↔ \D # 십진 숫자 매칭. 바이트 패턴에서는 [0-9]만 매칭.</li>
        <li>\s ↔ \S # 공백 문자 매칭. 바이트 패턴에서는 [ \t\n\r\f\v]만 매칭.</li>
        <li>\w ↔ \W # Word 문자 매칭. 바이트 패턴에서는 [a-zA-Z0-9_]만 매칭.</li>
        <li>Since 3.3 # \uXXXX, \UXXXX 가능</li>
        <li>Since 3.8 # \N{name} 가능</li>
    </ul>
</details>

<hr>

<details>
    <summary>Module Contents</summary>
    <ul>
        <li>Since 3.6 # Flag 상수들은 이제 RegexFlag(enum.IntFlag)의 인스턴스다.</li>
        <li>re.compile(pattern, flags=0)</li>
        <ul>
            <li>re.I, re.IGNORECASE</li>
            <li>re.M, re.MULTILINE</li>
            <li>re.S, re.DOTALL # '.'이 newline 문자 포함하여 매칭</li>
            <li>re.X, re.VERBOSE # 주석을 달아 이해하기 쉬운 패턴 작성 가능</li>
            <li>re.A, re.ASCII # 유니코드 패턴에서 \w, \W, \b, \B, \d, \D, \s, \S가 아스키코드만 매칭</li>
            <li>re.DEBUG # 디버그 정보 출력</li>
        </ul>
        <li>re.search(pattern, string, flags=0) # 처음 매칭되는 부분 문자열에 대해 match 객체 반환. 없으면 None</li>
        <li>re.match(pattern, string, flags=0) # 문자열 시작 위치에서 매칭되면 match 객체 반환. 없으면 None</li>
        <li>re.fullmatch(pattern, string, flags=0) Since 3.4 : 문자열 전체가 매칭되면 match 객체 반환. 없으면 None</li>
        <li>re.split(pattern, string, maxsplit=0, flags=0) # 매칭된 패턴들로 분리. pattern에 그룹이 있으면 매칭된 문자열들도 결과에 포함된다. 결과의 빈 문자열에 유의</li>
        re.split(r'(.*)', '')
        <li>re.findall(pattern, string, flags=0)</li>
        문자열을 좌에서 우로 스캔하며 매칭된, 겹치지 않는 부분 문자열들을 리스트로 반환한다. 패턴에 그룹이 있는 경우 튜플로 표현된다.
        <li>re.finditer(pattern, string, flags=0)</li>
        findall과 동일한 방식으로 매칭하면서 match 객체를 하나씩 yield
        <li>re.sub(pattern, repl, string, count=0, flags=0)</li>
        string에서 pattern에 매칭된, 겹치지 않는 부분 문자열들을 repl로 변경하여 반환. repl은 문자열이거나 함수일 수 있다. 문자열의 경우 backreference, \g&lt;name&gt;, \g&lt;number&gt; 가능. 함수의 경우 match 객체 하나를 먹고 문자열을 반환
        <li>re.subn(pattern, repl, string, count=0, flags=0)</li>
        re.sub()와 같은 작업을 하고, (new_string, number_of_subs_made) 반환
        <li>re.escape(pattern) # 패턴 문자열을 이스케이프. 이 결과를 패턴으로 이용하면 단 하나의 문자열만 매칭된다</li>
        <li>re.purge() # RE 캐시 삭제</li>
        <li>exception re.error(msg, pattern=None, pos=None)</li>
    </ul>
</details>

<hr>

<details>
    <summary>Regular Expression Objects</summary>
    <ul>
        컴파일된 RE 객체는 아래의 메서드와 속성을 지원한다. 각 메서드는 re 모듈의 함수와 유사하다
        <li>regex.search(string[, pos[, endpos]])</li>
        pos가 지정되더라도 '^'는 실제 문자열 시작에만 매칭된다. endpos가 지정된 호출과 rx.search(string[:endpos], pos)는 동등하다
        <li>regex.match(string[, pos[, endpos]])</li>
        <li>regex.fullmatch(string[, pos[, endpos]]) Since 3.4</li>
        <li>regex.split(string, maxsplit=0)</li>
        <li>regex.findall(string[, pos[, endpos]])</li>
        <li>regex.finditer(string[, pos[, endpos]])</li>
        <li>regex.sub(repl, string, count=0)</li>
        <li>regex.subn(repl, string, count=0)</li>
        <li>regex.flags # compile()에서 전달받은 플래그들과 (?...) 인라인 플래그들.</li>
        <li>regex.groups # 패턴 내부 capturing group 수</li>
        <li>regex.groupindex # (?P&lt;name&gt;)로 정의된 symbolic group 이름으로부터 그룹 숫자로의 dictionary 매핑</li>
        <li>regex.pattern # 패턴 문자열</li>
        <li>Since 3.7 # copy.copy(), copy.deepcopy() 지원. 컴파일된 정규표현식 객체는 원자적이다</li>
    </ul>
</details>

<hr>

<details>
    <summary>Match Objects</summary>
    <ul>
        <li>매칭이 없다면 None을 반환하므로, match 객체는 항상 True로 간주된다.</li>
        <li>match.expand(template)</li>
        sub() 메서드가 하듯이, template 내부의 \ 대체 문자열을 알맞게 변경한다. \1, \g&lt;1&gt;, \g&lt;name&gt;와 같은 backreference들은 각각 연관된 그룹의 내용으로 대체된다.
        <li>match.group([group1, ...])</li>
        매칭된 그룹(들)을 반환한다. 여러 번 매칭된 경우 마지막 문자열이 반환된다. 지정되지 않은 경우 group1은 0(전체 매칭 문자열). (?P&lt;name&gt;...) 그룹이 패턴에 존재하면 groupN 인자로 문자열도 가능
        <li>match.__getitem__(g) Since 3.6 # == m.group(g). m[0], m[1], ...</li>
        <li>match.groups(default=None) # 각 그룹들의 매칭 문자열(없으면 default)들을 튜플로 반환한다.</li>
        <li>match.groupdict(default=None) # groups()를 dictoinary로 표현</li>
        <li>match.start([group]) # 그룹 시작 인덱스<br>
            match.end([group]) # 그룹 종료 인덱스</li>
        <li>match.span([group]) # (m.start(group), m.end(group)) 반환</li>
        <li>match.pos # search(), match()에서 전달받은 탐색 시작 위치</li>
        <li>match.endpos # search(), match()에서 전달받은 탐색 종료 위치</li>
        <li>match.lastindex # 마지막으로 매칭된 그룹 index. 없으면 None</li>
        <li>match.lastgroup # 마지막으로 매칭된 그룹 이름. 없으면 None</li>
        <li>match.re # RE 객체</li>
        <li>match.string # match(), search()에서 전달받은 탐색 대상 문자열</li>
    </ul>
</details>

<hr>