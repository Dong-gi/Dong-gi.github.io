<script src="/source/utility.js?200203_1003"></script>
<script src="/source/redirect.js?200203_0949"></script>
<ul>
	<li>datetime.MINYEAR == 1</li>
	<li>datetime.MAXYEAR == 9999</li>
</ul>

<hr>

<details>
	<summary>class datetime.date : year, month, day</summary>
	<ul>
		<li>class datetime.date(year, month, day)</li>
		인스턴스는 변경 불가능 + 해시 가능하다
		<li>클래스 메서드</li>
		<ul>
			<li>classmethod date.today() : date.fromtimestamp(time.time())와 동일</li>
			<li>classmethod date.fromtimestamp(timestamp) : 1970 ~ 2038년 외의 경우 에러발생 가능.</li>
			<li>classmethod date.fromordinal(ordinal) : ordinal[1, date.max.toordinal()]. 1년 1월 ordinal == 1</li>
			<li>classmethod date.fromisoformat(date_string) Since 3.7 : 'YYYY-MM-DD'</li>
			<li>classmethod date.fromisocalendar(year, week, day) Since 3.8</li>
		</ul>
		<li>클래스 속성</li>
		<ul>
			<li>date.min == date(MINYEAR, 1, 1)</li>
			<li>date.max == date(MAXYEAR, 12, 31)</li>
			<li>date.resolution == timedelta(days=1)</li>
		</ul>
		<li>인스턴스 속성(읽기 전용)</li>
		<ul>
			<li>year[MINYEAR, MAXYEAR]</li>
			<li>month[1, 12]</li>
			<li>day[1, 해당 연월의 일수]</li>
		</ul>
		<li>지원 연산</li>
        <table class="no-sort">
            <tr><td>date2 = date1 + timedelta</td></tr>
            <tr><td>date2 = date1 - timedelta</td></tr>
            <tr><td>timedelta = date1 - date2</td></tr>
            <tr><td>산술 비교</td></tr>
        </table>
		<li>인스턴스 메서드</li>
		<ul>
			<li>replace(year=self.year, month=self.month, day=self.day)</li>
			<li>timetuple() : time.struct_time을 반환한다.</li>
			<li>toordinal() : ordinal 반환</li>
			<li>weekday() : 월요일(0) ~ 일요일(6)</li>
			<li>isoweekday() : 월요일(1) ~ 일요일(7)</li>
			<li>isocalendar() : (ISO year, ISO week number, ISO weekday) 튜플 반환</li>
			<li>isoformat() : 'YYYY-MM-DD' 반환</li>
			<li>__str__() : str(d) == d.isoformat()</li>
			<li>__format__(format) == strftime(format) : 문자열 format에 따라 변환.</li>
		</ul>
	</ul>
</details>

<hr>

<details>
	<summary>class datetime.time : hour, minute, second, microsecond, tzinfo</summary>
	<ul>
        <li>class datetime.time(hour=0, minute=0, second=0, microsecond=0, tzinfo=None, *, fold=0)</li>
		<ul>
            <li>인스턴스는 변경 불가능 + 해시 가능하다</li>
            <li>fold Since 3.6 : 0 or 1</li>
            서머 타임이나 윤초 적용처럼, 특정 시각이 2가지로 해석되는 경우의 선후 관계를 나타낸다. 예를 들어 0은 서머 타임 적용 전 8시, 1은 서머 타임 적용 후 8시를 나타낼 수 있다.
        </ul>
        <li>클래스 메서드</li>
        <ul>
            <li>classmethod time.fromisoformat(time_string) Since 3.7</li>
            <ul>
                <li>HH[:MM[:SS[.fff[fff]]]][+HH:MM[:SS[.ffffff]]]</li>
                <li>time.isoformat()의 역함수로 설계되었기에 모든 ISO 8601 포맷을 인식하지는 못한다.</li>
            </ul>
        </ul>
		<li>클래스 속성</li>
        <ul>
            <li>min == time(0, 0, 0, 0)</li>
            <li>max == time(23, 59, 59, 999999)</li>
            <li>resolution == timedelta(microseconds=1)</li>
        </ul>
        <li>인스턴스 속성(읽기 전용)</li>
        hour, minute, second, microsecond, tzinfo, fold(의미는 ↑ 생성자 참고) Since 3.6
        <li>지원 연산</li>
        <table class="no-sort">
            <tr><td>산술 비교</td></tr>
        </table>
        <ul>
            <li>naive한 객체는 동등 비교에서 True를 반환하지 않는다</li>
            <li>Boolean 평가 시 항상 True로 간주된다; 3.5 이전에는 UTC 자정을 false로 간주했다</li>
        </ul>
        <li>인스턴스 메서드</li>
        <ul>
            <li>replace(hour=self.hour, minute=self.minute, second=self.second, microsecond=self.microsecond, tzinfo=self.tzinfo, *, fold=0)</li>
            <li>time.isoformat(timespec='auto')</li>
            <table>
                <tr><td>Format</td><td>Case</td></tr>
                <tr><td>HH:MM:SS.ffffff</td><td>microsecond > 0</td></tr>
                <tr><td>HH:MM:SS</td><td>microsecond == 0</td></tr>
                <tr><td>HH:MM:SS.ffffff+HH:MM[:SS[.ffffff]]</td><td>utcoffset() != None</td></tr>
                <tr><td>HH:MM:SS+HH:MM[:SS[.ffffff]]</td><td>microsecond == 0 and utcoffset() != None</td></tr>
            </table>
            <table>
                <tr><td>Format</td><td>timespec</td></tr>
                <tr><td>'seconds' # microsecond == 0<br>'microseconds' # microsecond > 0</td><td>'auto'</td></tr>
                <tr><td>HH</td><td>'hours'</td></tr>
                <tr><td>HH:MM</td><td>'minutes'</td></tr>
                <tr><td>HH:MM:SS</td><td>'seconds'</td></tr>
                <tr><td>HH:MM:SS.sss</td><td>'milliseconds'</td></tr>
                <tr><td>HH:MM:SS.ffffff</td><td>'microseconds'</td></tr>
            </table>
            <li>__str__() == isoformat()</li>
            <li>strftime(format)</li>
            <li>__format__(format) == strftime(format)</li>
        </ul>
	</ul>
</details>

<hr>

<details>
	<summary>class datetime.datetime : date + time</summary>
	<ul>
        <li>datetime은 date를 상속</li>
        <li>class datetime.datetime(year, month, day, hour=0, minute=0, second=0, microsecond=0, tzinfo=None, *, fold=0)</li>
		<ul>
            <li>인스턴스는 변경 불가능 + 해시 가능하다</li>
            <li>fold Since 3.6 : 0 or 1</li>
            서머 타임이나 윤초 적용처럼, 특정 시각이 2가지로 해석되는 경우의 선후 관계를 나타낸다. 예를 들어 0은 서머 타임 적용 전 8시, 1은 서머 타임 적용 후 8시를 나타낼 수 있다.
        </ul>
		<li>클래스 메서드</li>
        <ul>
            <li>classmethod datetime.now(tz=None)</li>
            <li>classmethod datetime.combine(date, time, tzinfo=self.tzinfo)</li>
            tzinfo Since 3.6 : 지정되지 않은 경우, time.tzinfo가 사용된다
            <li>classmethod datetime.fromisoformat(date_string) Since 3.7</li>
            <ul>
                <li>YYYY-MM-DD[*HH[:MM[:SS[.fff[fff]]]][+HH:MM[:SS[.ffffff]]]] // *는 임의 1글자</li>
                <li>datetime.isoformat()의 역함수로 설계되었기에 모든 ISO 8601 포맷을 인식하지는 못한다.</li>
            </ul>
            <li>classmethod datetime.strptime(date_string, format)</li>
            == datetime(*(time.strptime(date_string, format)[0:6]))
        </ul>
		<li>클래스 속성</li>
        <ul>
            <li>min == datetime(MINYEAR, 1, 1, tzinfo=None)</li>
            <li>max == datetime(MAXYEAR, 12, 31, 23, 59, 59, 999999, tzinfo=None)</li>
            <li>resolution == timedelta(microseconds=1)</li>
        </ul>
        <li>인스턴스 속성(읽기 전용)</li>
        year, month, day, hour, minute, second, microsecond, tzinfo, fold(의미는 ↑ 생성자 참고) Since 3.6
        <li>지원 연산</li>
        <table class="no-sort">
            <tr><td>datetime2 = datetime1 + timedelta</td></tr>
            <tr><td>datetime2 = datetime1 - timedelta</td></tr>
            <tr><td>timedelta = datetime1 - datetime2</td></tr>
            <tr><td>산술비교</td></tr>
        </table>
        <li>인스턴스 메서드</li>
        <ul>
            <li>tzinfo가 설정되지 않은 naive한 datetime이 UTC로 잘 작동하기 위해서는 timezone.utc로 설정해야 한다</li>
            <li>date() + time, timetz</li>
            <li>astimezone(tz=None)</li>
            동일한 UTC 시각을 다른 시간대로 변환하여 반환한다.
        </ul>
	</ul>
</details>

<hr>

<details>
	<summary>class datetime.timedelta : date, time, datetime 사이의 microsecond 차이</summary>
	<ul>
		<li>class datetime.timedelta(days=0, seconds=0, microseconds=0, milliseconds=0, minutes=0, hours=0, weeks=0)</li>
		<li>차분 대상의 타임존 유무 여부는 timedelta 값에 영향을 끼치지 않는다</li>
		<li>클래스 속성</li>
		<ul>
			<li>timedelta.min == timedelta(-999999999)</li>
			<li>timedelta.max == timedelta(days=999999999, seconds=86399, microseconds=999999)</li>
			<li>timedelta.resolution == timedelta(microseconds=1)</li>
		</ul>
        <li>인스턴스 속성(읽기 전용)</li>
		<ul>
			<li>days[-999999999, 999999999]</li>
			<li>seconds[0, 86400)</li>
			<li>microseconds[0, 1000000)</li>
		</ul>
		<li>지원 연산</li>
		<table>
			<tr><td>t1 + t2</td><td>t1 - t2</td><td>t1 * num [round even]</td><td>t1 / t2</td></tr>
			<tr><td>t1 / num [round even]</td><td>t1 // int</td><td>t1 // t2</td><td>t1 % t2</td></tr>
			<tr><td>divmod(t1, t2)</td><td>+t1</td><td>-t1</td><td>abs(t)</td></tr>
			<tr><td>str(t)</td><td>repr(t)</td><td>산술 비교</td><td>동등 비교</td></tr>
		</table>
		<li>인스턴스 메서드</li>
		<ul>
			<li>timedelta.total_seconds() Since 3.2 : td / timedelta(seconds=1)과 동일.</li>
		</ul>
	</ul>
</details>

<hr>

<details>
	<summary>class datetime.tzinfo : 타임존 ABC</summary>
    <ul>
        <li>dt : datetime | time</li>
        <li>utcoffset(dt)</li>
        <ul>
            <li>UTC와 현지 시각의 차이(timedelta) 반환</li>
            <li>DST(daylight saving time) 값이 있다면 합산하여 반환함이 바람직하다</li>
            <li>utcoffset()이 None을 반환하지 않으면 dst()도 그러해야 한다</li>
        </ul>
        <li>dst(dt)</li>
        timedelta로 반환. 모르면 None. 비활성화면 timedelta(0) 반환
        <li>tzname(dt)</li>
        <li>fromutc(dt)</li>
        datetime.astimezone()에서 호출한다. 이때 dt.tzinfo == slef이고 dt의 시각은 UTC므로, 오차를 더해 반환(dt + dt.utcoffset())하면 된다
    </ul>
</details>

<hr>

<details>
	<summary>class datetime.timezone Since 3.2 : tzinfo 구현체</summary>
	<ul>
        <li>class datetime.timezone(offset, name=None)</li>
        <ul>
            <li>인스턴스는 변경 불가능 + 해시 가능하다</li>
            <li>timezone 클래스는 tzinfo의 서브클래스</li>
            <li>고정된 UTC offset을 표현하며, 변경 불가능하다</li>
        </ul>
	</ul>
</details>

<hr>

<details>
	<summary>strftime(), strptime() 사양</summary>
    <table>
        <tr><th>Directive</th><th>의미</th></tr>    
        <tr><td>%a</td><td>요일명 - 약어 - 로캐일 적용</td></tr>
        <tr><td>%A</td><td>요일명 - 풀네임 - 로캐일 적용</td></tr>
        <tr><td>%w</td><td>요일 - 0(일요일) ~ 6(토요일)</td></tr>
        <tr><td>%d</td><td>일 - zero-pad : 01 ~ 31</td></tr>
        <tr><td>%b</td><td>월 - 약어 - 로캐일 적용</td></tr>
        <tr><td>%B</td><td>월 - 풀네임 - 로캐일 적용</td></tr>
        <tr><td>%m</td><td>월 - zero-pad : 01 ~ 12</td></tr>
        <tr><td>%y</td><td>년 - 세기 제외, zero-pad : 00 ~ 99</td></tr>
        <tr><td>%Y</td><td>년 - 세기 포함, zero-pad : 0001 ~ 9999</td></tr>
        <tr><td>%H</td><td>시(24h) - zero-pad : 00 ~ 23</td></tr>
        <tr><td>%I</td><td>시(12h) - zero-pad : 01 ~ 12</td></tr>
        <tr><td>%p</td><td>AM or PM - 로캐일 적용</td></tr>
        <tr><td>%M</td><td>분 - zero-pad : 00 ~ 59</td></tr>
        <tr><td>%S</td><td>초 - zero-pad : 00 ~ 59</td></tr>
        <tr><td>%f</td><td>마이크로초 - zero-pad : 000000 ~ 999999</td></tr>
        <tr><td>%z</td><td>UTC 차이 : +HHMM or -HHMM</td></tr>
        <tr><td>%Z</td><td>Timezone 이름</td></tr>
        <tr><td>%j</td><td>일 - 연중 n번째, zero-pad : 001 ~ 366</td></tr>
        <tr><td>%U</td><td>주(일요일 기준) - 연중 n번째, zero-pad : 00 ~ 53</td></tr>
        <tr><td>%W</td><td>주(월요일 기준) - 연중 n번째, zero-pad : 00 ~ 53</td></tr>
        <tr><td>%c</td><td>날짜와 시각 표현 - 로캐일 적용</td></tr>
        <tr><td>%x</td><td>날짜 표현 - 로캐일 적용</td></tr>
        <tr><td>%X</td><td>시각 표현 - 로캐일 적용</td></tr>
        <tr><td>%%</td><td>리터럴 '%'</td></tr>
        <tr><td>%G</td><td>년 - 세기 포함, ISO 8601 : 0001 ~ 9999</td></tr>
        <tr><td>%u</td><td>요일 - 1(월요일) ~ 7(일요일), ISO 8601</td></tr>
        <tr><td>%V</td><td>주(월요일 기준) - 연중 n번째, ISO 8601 : 01 ~ 53<br>01번째 주는 1월 4일을 포함</td></tr>
    </table>
</details>

<hr>