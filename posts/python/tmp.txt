* 특별 메서드를 구현하면 사용자 정의 객체도 내장형 객체처럼 작동하게 된다.

http://docs.python.org/3/reference/datamodel.html

__repr__, __str__, __format__, __bytes__
__abs__, __bool__, __complex__, __int__, __float__, __hash__, __index__
__len__, __getitem__, __setitem__, __delitem__, __contains__
__iter__, __reversed__, __next__
__call__
__enter__, __exit__
__new__, __init__, __del__
__getattr__, __getattribute__, __setattr__, __delattr__, __dir__
__get__, __set__, -_delete__
__prepare__, __instancecheck__, __subclasscheck__

__neg__, __pos__, __abs__
__lt__, __le__, __eq__, __ne__, __gt__, __ge__
__add__, __sub__, __mul__, __truediv__, __floordiv__, __mod__, __divmod__, __pow__, __round__
__radd__, __rsub__, __rmul__, __rtruediv__, __rfloordiv__, __rmod__, __rdivmod__, __rpow__
__iadd__, __isub__, __imul__, __itruediv__, __ifloordiv__, __imod__, __ipow__
__invert__, __lshift__, __rshift__, __and__, __or__, __xor__
__rlshift__, __rrshift__, __rand__, __rxor__, __rxor__
__ilshift__, __irshift__, __iand__, __ixor__, __ior__


import collections

Card = collections.namedtuple('Card', ['rank', 'suit'])

class FrenchDeck:
    ranks = [str(n) for n in range(2, 11)] + list('JQKA')
    suits = 'spades,diamonds,clubs,hearts'.split(',')

    def __init__(self):
        self._cards = [Card(rank, suit) for suit in self.suits for rank in self.ranks]

    def __len__(self):
        return len(self._cards)
    
    def __getitem__(self, position):
        return self._cards[position]

card1 = Card('7', 'diamonds')

deck = FrenchDeck()
len(deck) # __len__ 구현으로 호출된다.
deck[-1] # __getitem__ 구현으로 호출된다.
deck[12::13] # __getitem__()이 리스트의 []에 작업을 위임하므로 호출된다.

from random import choice
choice(deck) # __getitem__ 구현으로 호출된다.

# for in : __iter__() 호출
for card in reversed(deck): # __getitem__ 구현으로 호출된다.
    print(card)

# __contains__() 메서드가 없으면 in 연산자는 요소를 차례대로 검색한다
Card('Q', 'hearts') in deck # True
Card('7', 'heart') in deck # False

suit_values = dict(spades=4, hearts=2, diamonds=1, clubs=0)
def spades_high(card):
    return FrenchDeck.ranks.index(card.rank) * len(suit_values) + suit_values[card.suit]
for card in sorted(deck, key=spades_high):
    print(card)

# Monkey patching :  소스 코드를 건드리지 않고 런타임에 클래스나 모듈을 변경하는 행위
from random import shuffle
def set_card(self, position, card):
    self._cards[position] = card

FrenchDeck.__setitem__ = set_card
shuffle(deck)






from math import hypot

class Vector:
    def __init__(self, x=0, y=0):
        self.x = x
        self.y = y
    
    def __repr__(self):
        return 'Vector(%r, %r)' % (self.x, self.y)
    # __str__()은 print()에서 호출되며, 없는 경우 __repr__() 메서드를 호출 시도한다.

    def __abs__(self):
        return hypot(self.x, self.y)
    
    def __bool__(self):
        return bool(abs(self))
    # 사용자 정의 클래스에 대한 bool() 호출시 __bool__()을 호출하며, 없는 경우 __len__()를 호출한다. 둘 다 없으면 True로 간주한다.

    def __add__(self, other):
        x = self.x + other.x
        y = self.y + other.y
        return Vector(x, y)
    
    # 스칼라가 우측 피연산자일 때만 동작한다. 반대 경우는 __rmul__()
    def __mul__(self, scalar):
        return Vector(self.x * scalar, self.y * scalar)

시퀀스
    내장 시퀀스 개요
        Container sequence : 자료형 구분없이 항목들을 담을 수 있다. list, tuple, collections.deque
        Flat sequence : 단일 자료형의 항목들만 담을 수 있다. str, bytes, bytearray, memoryview, array.array

        Mutable sequence : __setitem__, __delitem__, insert, append, reverse, extend, pop, remove, __iadd__
        Sequence : __getitem__, __contains__, __iter__, __reversed__, index, count
        Container : __contains__
        Iterable : __iter__
        Sized : __len__

        파이썬 3에서 comprehension은 함수처럼 고유한 지역 범위를 가진다.
        List comprehension : [x for x in 'abc']
        // 파이썬 2에서는 기존 x에 할당된 값이 덮어 씌여진다. 따라서 중복되지 않는 변수명을 이용해야 한다.
        Generator comprehension
            symbols = '$%^*#'
            tuple(ord(symbol) for symbol in symbols)
        
        print('%s/%s' % ('hello', 'world')) # 튜플 언패킹
        a, b = b, a # 튜플 언패킹
        divmod(*(1, 2)) # 튜플 언패킹
        a, b, *c = range(5)
        a, *b, c = range(5)
        *a, b, c = range(5)
        a, (b, c) = (1, (2, 3))
        
        collections.namedtuple() : 필드명과 클래스명을 추가한 튜플의 서브클래스를 생성하는 팩터리 함수
            _fields, _make(iterable), _asdict()
        
        슬라이스
            a:b:c 표기법은 인덱스 연산을 수행하는 []안에서만 사용 가능하며, slice(a, b, c) 객체를 생성한다.
            slice 객체를 변수에 담아 이용하면 가독성이 높아진다.

            l = list(range(10))
            l[3::2] = [11, 22] # 할당문의 대상이 슬라이스인 경우, 우측 피연산자는 반복 가능한 객체여야 한다.

        
        객체를 직접 변경하는 함수나 메서드는 새로운 객체가 생성되지 않았음을 알려주기 위해 None을 반환해야 한다.
        메서드 체이닝을 의도하는 경우는 예외.

        bisect.insort() 정렬을 유지한 채로 삽입

        array.array : frombytes(), fromfile(), fromlist(), tobytes(), tofile(), tolist(), byteswap(), typecode

        memoryview
        
        deque : append()와 popleft()는 원자성을 갖는다. 초과되면 오래된 항목을 버린다.
        queue 모듈 : Queue, LifoQueue, PriorityQueue : 초과되면 빈 공간이 생길 때까지 대기
        multiprocessing 모듈 : Queue, JoinableQueue
        asyncio 모듈 : Queue, LifoQueue, PriorityQueue, JoinableQueue

딕셔너리와 집합
    MutableMapping : __setitem__, __delitem__, clear, pop, popitem, setdefault, update
    Mapping : __getitem__, __contains__, __eq__, __ne__, get, items, keys, values

    isinstance(test_target, collections.abc.Mapping)

    Dictionary comprehension : {key: value for key, value in KEY_VALUE_SEQUENCE}
    기본값 설정 : setdefault 메서드 이용 or defaultdict 사용 or 매핑 타입을 상속하여 __missing__() 메서드 정의
    collections.OrderedDict : 키의 삽입 순서 유지. 순회 순서 예측 가능.
    collections.ChainMap : 여러 매핑을 차례로 검색.
    collections.Counter
    collections.UserDict : 상속하여 확장하기 위한 용도. 내부에 data 객체를 갖는다.

    매핑의 읽기 전용 객체 반환 : MappingProxyType


    set, frozenset
        a | b 합, a & b 교, a - b 차
    MutableSet : add, discard, remove, pop, clear, __ior__, __iand__, __ixor__, __isub__
    Set : isdisjoint, __le__, __lt__, __gt__, __ge__, __eq__, __ne__, __and__, __or__, __sub__, __xor__


텍스트와 바이트
    cafe = bytes('cafe', encoding='utf_8')
    bytearray(cafe)

    bytes와 bytearray는 str이 제공하는 메서드들을 거의 지원하며, casefold(), isdecimal(), encode() 등 유니코드 관련 메서드를 지원한다.
    이진 시퀀스로 정규 표현식을 컴파일하면 이진 시퀀스에 적용 가능


    import struct
    fmt = '<3s3sHH' # <(리틀엔디언), 3s3s(3바이트 시퀀스 2개), HH(16비트 정수 2개)
    with open('filter.gif', 'rb') as fp:
        img = memoryview(fp.read())
    
    header = img[:10]
    struct.unpack(fmt, header)
    del header
    del img

    + mmap 모듈

    \u0301 같은 결합문자를 제대로 비교하기 위해 유니코드 정규화를 거쳐야 한다.
    s = 'cafe\u0301'
    unicodedata.normalize() : NFC, NFD, NFKC, NFKD
        NFC : 코드 포인트를 조합해서 가장 짧은 동일 문자열을 생성
        NFD : 조합된 문자를 기본 문자와 결합 문자로 분리
        * 라틴 기반 문자에서 발음 구별 기호 제거
        import unicodedata
        import string
        def shave_marks(txt):
            norm_txt = unicodedata.normalize('NFD', txt)
            latin_base = False
            keepers = []
            for c in norm_txt:
                if unicodedata.combining(c) and latin_base:
                    continue
                keepers.append(c)
                if not unicodedata.combining(c):
                    latin_base = c in string.ascii_letters
            shaved = ''.join(keepers)
            return unicodedata.normalize('NFC', shaved)
        NFKC, NFKD : 예. ½(U+00BD)를 '1/2'로, 마이크로 문자(U+00B5)는 뮤(U+03BC)로 치환
    
    str.casefold() : 문자열을 소문자로 변환
    str.translate()?
    
    locale.strxfrm() 함수는 문자열을 현지어 비교에 사용할 수 있는 문자열로 변환한다.
    또는 PyUCA 라이브러리 이용.

    
    re모듈 대신 regex 모듈

    __call__() 메서드를 구현하면 함수처럼 동작 가능

    class C: pass
    obj = C()
    def func(): pass
    sorted(set(dir(func)) - set(dir(obj)))
        __annotations__ : 매개변수 및 반환값에 대한 주석
        __call__
        __closure__ : 함수 클로저
        __code__ : 바이트코드로 컴파일된 함수 메타데이터 및 함수 본체
        __defaults__ : 형식 매개변수의 기본값

    함수 시그니처 추출
    from clip import clip
    from inspect import signature
    sig = signature(func)
    print(sig)
    for name, param in sig.parameters.items():
        print(param.kind, ':', name, '=', param.default)

    애너테이션
    def dlip(text:str, max_len:'int > 0'=80) -> str:
        """max_len 앞이나 뒤의 ...
        """
        pass

    함수의 인자를 고정한 부분 함수
    from functools import partial
    new_func = partial(func, key=value)


    def make_averager():
        count = 0
        total = 0

        def averager(new_value):
            nonlocal count, total
            count += 1
            total += new_value
            return total / count
        return averager


    functools.lru_cache()를 이용한 메모이제이션
    import functools
    @functools.lru_cache(maxsize=x, typed=False) # typed가 True면 인수의 자료형이 다르면 결과를 따로 저장
    def fibonacci(n):
        if n < 2:
            return n;
        return fibonacci(n-2) + fibonacci(n-1)


    functools.singledispatch() # 일련의 함수가 첫 번째 인수의 자료형에 따라 서로 다른 연산을 수행. 메서드 오버로딩 흉내
    from functools import singledispatch
    from collections import abc
    import numbers
    import html

    @singledispatch
    def htmlize(obj):
        content = html.escape(repr(obj))
        return '<pre>{}</pre>'.format(content)
    
    @htmlize.register(str)
    def _(text):
        content = html.escape(text).replace('\n', '<br>\n')
        return '<p>{0}</p>'.format(content)
    
    @htmlize.register(numbers.Integral)
    def _(n):
        return '<pre>{0} (0x{0:x})</pre>'.format(n)
    
    @htmlize.register(tuple)
    @htmlize.register(abc.MutableSequence)
    def _(seq):
        inner = '</li>\n<li>'.join(htmlize(item) for item in seq)
        return '<ul>\n<li' + inner + '</li>\n</ul>'

    매개변수를 받는 데커레이터 : 인자를 받아 데커레이터를 반환하는 팩터리를 만들어 호출

from copy import deepcopy
c = deepcopy(a) # __copy__(), __deepcopy__()를 구현하면 copy(), deepcopy() 동작을 제어할 수 있다.


weakref.finalize(참조변수, 콜백) # 객체 소멸시 실행될 콜백 등록

약한 참조 : 캐시와 같이 객체 카운트를 증가시키지 않고 객체를 참조.
약한참조변수 = weakref.ref(참조변수)
WeakValueDictionary : 약한 참조를 값으로 가지는 가변 매핑. 객체가 GC 수집되면 키가 자동으로 제거된다.
+ WeakSet


won_to_dollar = 1182.50
format(won_to_dollar, '0.4f')
'$1 = {rate:0.4f} won'.format(rate=won_to_dollar)
# 'b' 이진수, 'x' 16진수, 'f' 고정소수, '%' 백분율



사용자 정의 클래스
    객체 표현
        __repr__() : 개발자에게 유용한 형태의 문자열로 반환
        __str__() : 엔드 유저에게 유용한 형태의 문자열로 반환
        __bytes__() : bytes() 메서드에 의해 호출되어 객체를 바이트 시퀀스로 표현
        __format__() : 객체를 표현하는 포맷 문자열 반환. 정의되지 않은 경우 format()은 str(obj)를 반환한다.
        __hash__() : 해시 가능해진다. set, 매핑에 이용 가능

        class Vector2d:
            __slots__ = ('_x', '_y') # __slots__ 속성은 인터프리터가 객체 속성을 딕셔너리 대신 튜플에 저장하게 만든다. 인터프리터는 상속된 __slots__ 속성을 무시한다.
            # 다른 최적화 작업과 마찬가지로 필요성이 정당화되고 신중히 프로파일링해서 효과가 입증된 경우에만 __slots__를 사용해야 한ㄷ아.
            # 객체가 약한 참조를 지원하려면 __weakref__ 속성이 필요하다. __slots__를 정의했다면 __weakref__를 리스트에 추가해야 한다.
            typecode = 'd' # 클래스 속성을 객체를 통해 수정하는 경우, 객체에 같은 이름의 별개 속성이 정의된다. 클래스 속성의 수정은 클래스를 통해야 한다.

            @classmethod
            def frombytes(cls, octets):
                typecode = chr(octets[0])
                memv = memoryview(octets[1:]).cast(typecode)
                return cls(*memv)

            def __init__(self, x, y):
                slef._x = float(x)
                self._y = float(y)

            @property
            def x(self):
                return self._x
            
            @property
            def y(self):
                return self._y

            def __iter__(self):
                return (i for i in (self.x, self.y))

            def __repr__(self):
                class_name = type(self).__name__
                return '{}({!r}, {!r})'.format(class_name, *self)

            def __str__(self):
                return str(tuple(self))
            
            def __bytes__(self):
                return (bytes([ord(self.typecode)]) + bytes(array(self.typecode, self)))

            def __format__(self, fmt_spec=''):
                components = (format(c, fmt_spec) for c in self)
                return '({}, {})'.format(*components)
            
            def __eq__(self, other):
                return tuple(self) == tuple(other)

            def __abs__(self):
                return math.hypot(self.x, self.y)
            
            def __bool__(self):
                return bool(abs(self))
            
            def __hash__(self):
                return hash(str(self))

        v1 = Vector2d(3, 4)
        format(v1)
        format(v1, '.2f')
        format(v1, '.3e')

시퀀스 해킹, 해시, 슬라이스
    from array import array
    import reprlib
    import math

    class Vector:
        typecode = 'd'

        def __init__(self, components):
            self._components = array(self.typecode, components)
        
        def __iter__(self):
            return iter(self._components)
        
        def __repr__(self):
            components = reprlib.repr(self._components)
            components = components[components.find('['):-1]
            return 'Vector({})'.format(components)
        
        def __str__(self):
            return str(tuple(self))

        def __len__(self):
            return len(self._components)
        
        def __getitem__(self, index):
            cls = type(self)
            if isinstance(index, slice):
                return cls(self._components[index])
            elif isinstance(index, numbers.Integral):
                return self._components[index]
            else:
                msg = '{cls.__name__} indices must be integers'
                raise TypeError(msg.format(cls=cls))
        
        #속성을 찾지 못하면 인터프리터는 __getattr__() 메서드를 호출한다.
        shortcut_names = 'xyzt' # 벡터의 1~4번째 값은 xyzt로 접근 가능하게 하려고 함
        def __getattr__(self, name):
            cls = type(self)
            if len(name) == 1:
                pos = cls.shortcut_names.find(name)
                if 0 <= pos < len(self._components):
                    return self._components[pos]

        # __getattr__() 구현으로 속성을 동적으로 접근하게 만들었다면, 해당 속성을 통한 할당을 지원할 것인지도 고려해야 한다.
        def __setattr__(self, name, value):
            cls = type(self)
            if len(name) == 1:
                pos = cls.shortcut_names.find(name)
                if 0 <= pos < len(self._components):
                    self._components[pos] = value
            else:
                super().__setattr__(name, value)

        def __hash__(self):
            hashes = map(hash, self._components)
            return functools.redue(operator.xor, hashes)

        def __eq__(self, other):
            if len(self) != len(other):
                return False
            for a, b in zip(self, other): # 긴 쪽에 맞추려면 itertools.zip_longest() 이용
                if a != b:
                    return False
            return True
        
    슬라이싱의 작동
    class Seq:
        def __getitem__(self, index):
            return index
    
    s = Seq()
    s[1]
    s[1:4]
    s[1:4:2]
    s[1:4:2, 9]
    s[1:4:2, 7:9]

    functools.reduce(lambda a, b: a*b, range(1, 6))

특별 메서드를 직접 구현하기보다는 ABC를 상속하는 것이 낫다.
import collections

Card = collections.namedtuple('Card', ['rank', 'suit'])

class FrenchDeck2(collections.MutableSequence)
    ranks = [str(n) for n in range(2, 11)] + list('JQKA')
    suits = 'spades diamonds clubs hearts'.split()

collections.abc
    Iterable, Container, Sized, Callable, Hashable
    Iterator, Sequence, MutableSequence, Mapping, MutableMapping, Set, MutableSet, MappingView, ItemsView, Keyiew, ValuesView

numbers
    Number, Complex, Real, Rational, Integral


Sequence.register(tuple) # collections.abc에서 tuple을 비롯한 내장 자료형이 Sequence의 가상 서브클래스로 등록되어 있다.
isinstance(tuple(1, 2, 3), Sequence) == True

class Test:
    def __len__(self):
        return 1
isinstance(Test(), abc.Sized) == True # abc.Sized가 __subclasshook__()라는 특별 클래스 메서드에서 __len__() 메서드를 발견하면 가상 서브클래스로 간주하기 때문

class Sized(metaclass=ABCMeta):
    __slots__ = ()
    @abstractmethod
    def __len__(self):
        return 0
    @classmethod
    def __subclasshook__(cls, C):
        if cls is Sized:
            if any("__len__" in B.__dict__ for B in C.__mro__):
                return True
        return NotImplemented
    # C.__mro__ : C와 C의 수퍼클래스


내장 자료형을 직접 상속하지 말고, 해당하는 파이썬 클래스를 상속하자. 파이썬 구현에 따라서 내장 자료형의 오버라이딩 메서드를 무시하는 경우가 있다.


다중 상속
class C(A, B):
    pass
# 파이썬에서 메서드 결정 순서(Method Resolution Order)는 __mro__ 속성을 따른다.

super().ping() == A.ping(self) # 클래스를 통해 호출하는 경우, 메서드가 바인드되지 않으므로 객체 자신도 인자로 넘겨줘야 한다.

def print_mro(cls):
    print(', '.join(c.__name__ for c in cls.__mro__))

내적 연산자 @
특별 메서드는 __matmul__(), __rmatmul__()


반복자에 대한 표준 인터페이스
    __next__() : 다음 항목 반환. 없으면 StopIteration 발생
    __iter__() : self를 반환하여 for 루프 등에서 사용할 수 있게 한다.

다중 반복을 지원하려면 동일한 반복형 객체로부터 여러 독립적인 반복자를 가질 수 있어야 하며, 각 반복자는 고유한 내부 상태를 유지해야 한다. 따라서 iter(my_iterable)을 호출할 때마다 독립적인 반복자가 새로 만들어져야 한다. → 클래스에 대한 Iterator 클래스를 별도로 작성
이를 파이썬스럽게 구현하려면 새로운 Iterator 클래스 대신 제너레이터 함수를 작성하면 된다.
    def __iter__(self):
        for word in self.words:
            yield word
    

    RE_WORD = re.compile('\w+')
    def __iter__(self):
        for match in RE_WORD.finditer(self.text):
            yield match.group()

    # Generator comprehension
    def __iter__(self):
        return (match.group() for match in RE_WORD.finditer(self.text))

itertools : 제너레이터 함수 제공
    itertools.count() : 숫자를 생성하는 제너레이터 반환
    itertools.takewhile() : 다른 제너레이터를 소비하면서 조건식이 False가 되면 중단하는 제너레이터 반환
    itertools.compress(it, selector_it) : 두 반복형을 병렬로 소비한다. selector_it의 항목이 참일 때마다 it에서 항목을 생성한다.
    itertools.dropwhile(predicate, it)
    itertools.takewhile(predicate, it)
    itertools.filterfalse(predicate, it)
    itertools.islice(it.stop), islice(it, start, stop, step=1) : s[:stop], s[start:stop:step]과 비슷하게 it의 슬라이스 항목 생성
    itertools.accumulate(it,[func])
    itertools.starmap(func, it) : it의 각 항목에 func를 적용해서 결과를 생성한다. func(*iit). iit는 it에서 생성한 항목
    itertools.chain(it1, ..., itN)
    itertools.chain.from_iterable(it) : 반복형 객체를 생성하는 제너레이터 it를 일렬로 펼친다.
    itertools.product(it1, ..., itN, repeat=1) : 데카르트 곱. repeat는 it가 두 번 이상 소비되도록 허요앟ㄴ다.
    itertools.zip_longest(it1, ..., itN, fillvalue=None)
    itertools.combinations(it, out_len)
    itertools.combinations_with_replacement(it, out_len)
    itertools.count(start=0, step=1)
    itertools.cycle(it)
    itertools.permutations(it, out_len=None)
    itertools.repeat(item, [times])
    itertools.groupby(it, key=None) : (키, 그룹) 튜플을 생성한다.
    itertools.tee(it, n=2)

filter(predicate, it)
enumerate(it, start=0) : (인덱스, 항목) 튜플을 생성
map(func, it1, [it2, ..., itN]) : func를 각 it에 적용해서 결과를 생성한다. N은 func의 인자 수
zip(it1, ..., itN)
reversed(seq)

all(it)
any(it)
max(it, [key=,] [default=])
min(it, [key=,] [default=])
functools.reduce(func, it, [initial])
sum(it, start=0)

def chain(*iterables):
    for it in iterables:
        for i in it:
            yield i

def chain(*iterables):
    for i in iterables:
        yield from i



def dice():
    return randint(1, 6)

for roll in iter(dice, 1) # 1이 나올 때까지 주사위를 굴린다.
    print(roll)


with open('mydata.txt') as fp:
    for line in iter(fp.readline, ''): # 빈 줄을 발견하거나 파일의 끝에 도달할 때까지 한 줄씩 읽어서 처리
        process_line(line)


Coroutines via Enhanced Generators
    send() 메서드는 __next__()와 마찬가지로 제너레이터가 다음 yield로 넘어가게 만들면서, 추가로 데이터를 보낼 수 있다.

def f():
    def do_yield(n):
        yield n
    x = 0
    while True:
        x += 1
        yield from do_yield(x)


for/else : for 루프가 완전히 실행된 후에(break로 멈추지 않고) else 블록이 실행된다.
while/else : 조건식이 거짓이 되어 while 루프를 빠져나온 후에(break로 멈추지 않고) else 블록이 실행
try/else : try 블록에서 예외가 발생하지 않은 경우 else 블록 실행

with : 컨텍스트 관리 객체의 __enter__(), __exit__() 메서드가 반드시 호출됨을 보장

contextlib 모듈
    closing() : close() 메서드를 제공하는 개체로부터 컨텍스트 관리 객체 생성
    suppress : 지정한 예외를 무시하는 컨텍스트 관리 객체
    @contextmanager : 클래스를 생성하고 프로토콜을 구현하는 대신, 제너레이터 함수로 컨텍스트 관리 객체 생성하도록
        __enter__(), __exit__() 메서드를 갖는 클래스를 작성하는 대신, __enter__() 메서드가 반환할 것을 생성하는 yield문을 가진 제너레이터만 구현하면 된다.
        yield 앞부분이 __enter__(), 뒷부분은 __exit__()에 대응된다.
        __exit__() 메서드는 예외 처리를 완료했음을 인터프리터에 알려주기 위해 True를 반환한다. 값을 반환하지 않으면 인터프리터가 None을 받고 예외를 전파한다.
        @contextmanager 데커레이터를 이용하는 경우 처리하지 않은 예외는 명시적으로 throw해줘야 된다.
        팁. yield문 주변을 try/finally나 with 블록으로 감싼다.
    ExitStack : 여러 컨테스트 관리 객체를 사용. with 블록이 끝나면 LIFO 순으로 __exit__() 호출



코루틴
    yield문의 실행 제어 효과를 이용

    def simple_coroutine():
        print('코루틴 시작')
        x = yield
        print('받은 값 ', x)

    coroutine = simple_coroutine()
    next(coroutine) # coroutine.send(None) 호출로 같은 효과를 볼 수 있다.
    coroutine.send(111)

    코루틴의 4가지 상태
        GEN_CREATED : 실행 대기
        GEN_RUNNING : 실행중
        GEN_SUSPENDED : yield 문에서 대기
        GEN_CLOSED : 실행 완료


    코루틴을 이용한 평균 예
    def averager():
        total = 0.0
        count = 0
        average = None
        while True:
            term = yield average
            total += term
            count += 1
            average = total/count
    
    코루틴 자동 기동
    from functools import wraps
    def coroutine(func):
        """데커레이터: 'func'를 기동해서 첫 번째 'yield'까지 진행한다."""
        @wraps(func)
        def primer(*args, **kwargs):
            gen = func(*args, **kwargs)
            next(gen)
            return gen
        return primer
    
    generator.throw(exc_type[, exc_value[, traceback]])
        제너레이터가 중단한 곳의 yield 표현식에 예외를 전달한다. 제너레이터가 예외를 처리하면 제어 흐름이 다음 yield 문까지 진행되고, 생성된 값은 generator.throw() 호출 값이 된다. 제너레이터가 예외를 처리하지 않으면 코루틴은 중단되고 호출자까지 예외가 전파된다.
    generator.close()
        제너레이터가 실행을 중단한 yield 표현식이 GeneratorExit 예외를 발생하게 만든다. GeneratorExit 예외를 받으면 제너레이터는 아무런 값도 생성하지 않아야 한다.

    코루틴에서 값 반환하기
    from collections import namedtuple
    Result = namedtuple('Result', 'count average')
    def averager():
        total = 0.0
        count = 0
        average = None
        while True:
            term = yield
            if term is None:
                break
            total += term
            count += 1
            average = total/count
        return Result(count, average)

    avg = averager()
    next(avg)
    avg.send(1)
    avg.send(2)
    avg.send(3)
    avg.send(None) # StopIteration의 value 속성에 반환값이 있다.

    yield from은 StopIteration 예외를 내부적으로 잡아서 자동으로 처리한다.
    yield from x 표현식은 iter(x)를 호출해서 x의 반복자를 가져온다.
    yield from은 가장 바깥쪽 호출자와 가장 안쪽의 하위 제너레이터 사이에 양방향 채널을 열어준다.

    delegating generator : yield from 표현식을 갖는 제너레이터 함수
    subgenerator : yield from 표현식이 가져온 제너레이터.
    caller : delegating generator를 호출하는 코드

    from collections import namedtuple
    Result = namedtuple('Result', 'count average')
    def averager():
        total = 0.0
        count = 0
        average = None
        while True:
            term = yield
            if term is None:
                break
            total += term
            count += 1
            average = total/count
        return Result(count, average)

    def grouper(results, key):
        while True:
            results[key] = yield from averager()
            # 매 반복마다 averager 객체가 생성되어 코루틴으로 작동한다.

    def main(data):
        results = {}
        for key, values in data.items():
            group = grouper(results, key)
            next(group)
            for value in values:
                group.send(value)
                # value는 subgenerator에 곧바로 전달되며, delegating generator는 값을 볼 수 없다.
                # None이라면 하위 제너레이터의 __next__()가 호출되고, None이 아니면 send(value) 그대로 호출된다.
                # 하위 제너레이터에서 StopIteration 예외가 발생하면 delegating generator의 실행이 재개된다. 그 외의 예외는 delegating generator에 전달된다.
                # 하위 제너레이터에서 return expr 문을 실행하면 StopIteration(expr) 예외가 발생한다.
                # 하위 제너레이터가 실행을 마친 후 발생한 StopIteration 예외의 첫 번째 인수가 yield from 표현식의 값이 된다.
            group.send(None)
        
        print(results)

    data = {
        'girls;kg': [1, 2, 3, 4, 5],
        'girls;m': [10, 20, 30, 40, 50]
    }

    main(data)

병행제어
    concurrent.futures
        ThreadPoolExecutor

            MAX_WORKERS = 20

            def download_one(cc):
                image = get_flag(cc)
                show(cc)
                save_flag(image, cc.lower() + '.gif')
                return cc

            def download_namy(cc_list):
                workers = min(MAX_WORKERS, len(cc_list))
                with futures.ThreadPoolExecutor(workers) as executor:
                    res = executor.map(download_one, sorted(cc_list))
                    # executor.map()은 호출되는 순서 그대로 결과를 반환한다. 따라서 첫번째 호출이 지연되면 나머지 결과의 반환도 지연된다.
                    # 작어이 완료되는 순서대로 결과를 받으려면 Executor.submit(), futures.as_completed()를 함께 사용해야 한다.
                return len(list(res))

            //
            to_do_map = {}
            for cc in sorted(cc_list):
                future = executor.submit(download_one, cc, base_url, verbose)
                to_do_map[future] = cc
            done_iter = futures.as_completed(to_do_map)
            for future in done_iter:
                try:
                    res = future.result()

        ProcessPoolExecutor

    concurrency.futures.Future의 result() : 완료되지 않은 경우 대기(블로킹). timeout을 지정할 수 있다.
    asyncio.Future의 result() : timeout을 지원하지 않으며, yield from을 통해 Future 객체를 가져오는 것이 선호된다.


import threading
import itertools
import time
import sym

class Signal:
    go = True # 스레드 종료 제어를 위해

def spin(msg, signal):
    while True:
        try:
            yield from asyncio.sleep(.1)
        except asyncio.CacelledError:
            break # Task.cancel() 호출로 인해 asyncio.CancelledError가 발생한다.

def slow_function():
    time.sleep(3)
    return 0

def supervisor():
    signal = Signal()
    spinner = threading.Thread(target=spin, args=('xx', signal))
    spinner.start()
    result = slow_function() # 시간이 오래 걸리는 작업을 하는 동안 다른 스레드에서 spin 작업을 계속 실행
    signal.go = False # 오래 걸리는 작업이 끝나면 spin 작업도 종료. 스레드르 직접 종료시키는 API는 없다.
    spinner.join() # spin 작업 종료 대기
    return result

코루틴으로 동일한 작업 작성
import asyncio
import itertools
import sys

@asyncio.coroutine
def spin(msg):
    pass

@asyncio.coroutine
def slow_function():
    yield from asyncio.sleep(3)
    return 0

@asyncio.coroutine
def supervisor():
    spinner = asyncio.async(spin('xx'))
    result = yield from slow_function()
    spinner.cancel()
    return result

def main():
    loop = asyncio.get_event_loop()
    result = loop.run_until_complete(supervisor())
    loop.close()


asyncio.async(coroutine_or_future, *, loop=None)
    Future나 Task객체면 그대로 반환
    코루틴이면 loop.create_task()를 호출해서 Task를 생성
    loop 키워드 매개변수를 생략하면 asyncio.get_event_loop()를 호출해서 루프 객체를 가져온다.
BaseEventLoop.create_task(coroutine)
    코루틴을 실행하기 위해 스케줄링하고 asyncio.Task 객체를 반환한다.


def test():
    return 1

x = yield from test() # 가능?
    # test()가 코루틴 함수거나, Future나 Task 객체를 반환하면 가능.



resp = yield from aiohttp.request('GET', url)
image = yield from resp.read()


asyncio.wait() 코루틴은 Future 객체나 코루틴의 반복형을 받고, 각 코루틴은 Task 안에 래핑하여 모든 객체가 Future에 호환되게 한다.
    wait()은 코루틴 제너레이터 객체를 반환한다. 실행이 완료되면 (실행 완료된 Future 집합, 미완 Future 집합) 튜플을 반환한다.
    보통은 모두 완료되지만, 일부가 완료되지 않아도 반환하게 만드는 timeout과 return_when 키워드 인자가 있다.

to_do = [download_one(cc) for cc in sorted(cc_list)]
wait_coro = asyncio.wait(to_do)
res, _ = loop.run_until_complete(wait_coro)
loop.close()


__class__ : 객체의 클래스에 대한 참조. 파이썬은 __getattr__()과 같은 특별 메서드를 객체 자체가 아니라 객체의 클래스에서만 검색한다
__dict__ : 객체나 클래스의 쓰기 가능 속성을 저장하는 매핑.
__slots__ : 객체가 가질 수 있는 속성을 제한하려는 클래스에 정의하려는 속성. __dict__가 __slots__에 들어있지 않으면, 이 클래스의 객체는 자체적인 __dict__를 가질 수 없고, __slots__에 나열된 속성만 가질 수 있다.

dir(obj)
getattr(obj, name[, default])
hasattr(obj, name)
setattr(obj, name, value)

__delattr__(self, name) : Class.__delattr__(obj, name)
__dir__(self) : Class.__dir__(obj)
__getattr__(self, name) : 객체, 클래스, 수퍼클래스 순으로 검색하여 name 속성이 없는 경우 호출된다.
    obj.name, getattr(obj, 'name')은 Class.__getattr__(obj, 'name')을 호출한다.
__getattribute__(self, name) : 특별 속성이나 메서드가 아닌 속성을 가져올 때 언제나 호출된다. 점 표기법 및 getattr() 내장 함수가 이 메서드를 호출한다.
    __getattr__()는 이 메서드가 AttributeError를 발생시킨 후 호출된다.
__setattr__(self, name, value) : 속성에 값을 설정할 때 언제나 호출된다.


디스크립터 : __get__(), __set__(), __delete__() 프로토콜을 (일부) 구현한 클래스

class Quantity:
    def __init__(self, name):
        self.name = name
    
    def __set__(self, obj, value):
        if value > 0:
            obj.__dict__[self.name] = value # obj에 설정되므로 굳이 __get__()을 구현할 필요가 없다.
        else:
            raise ValueError('value must be > 0')

class LineItem:
    weight = Quantity('weight')
    price = Quantity('price')

    def __init__(self, weight, price):
        self.weight = weight
        self.price = price


모든 사용자 정의 함수는 __get__() 메서드가 정의된 디스크립터다.
사용자 정의 함수가 객체의 메서드로 바인드되고, 바인딩된 메서드 객체는 __call__() 메서드를 가지며, __self__ 속성을 첫 번째 인자로 전달해서 __func__ 속성이 참조하는 원래 함수를 호출한다.

property() 내장 함수, @property는 세터 메서드를 정의하지 않은 경우에도 __set__()과 __get__() 메서드를 모두 구현하는 디스크립터를 생성한다.
기본 __set__() 메서드는 'AttributeError: can't set attribute' 예외를 발생시키므로, 프로퍼티는 읽기 전용 속성을 만드는 가장 간단한 방법이다.



클래스 데커레이터를 이용하는 예
def data(cls):
    for name, value in cls.__dict__.items():
        if isinstance(value, Quantity):
            type_name = type(value).__name__
            value.name = '_' + type_name + '#' + name
    return cls

@data
class LineItem:
    weight = Quantity()
    ...



메타클래스를 이용하는 예
class LineItem(Data):
    weight = Quantity()
    ...

class Data(metaclass=Metadata)
    pass

class Metadata(type):
    def __init__(cls, name, bases, attr_dict):
        super().__init__(name, bases, attr_dict)
        for name, value in attr_dict.items():
            if isinstance(value, Quantity):
                type_name = type(attr).__name__
                value.name = '_' + type_name + '#' + name




import requests
requests.get(url).content

reprlib.repr()














def func(a, b, *, c = None) # * 뒷부분은 명시적으로만 받는다



// linux : crul

Scott Meyers : All non-leaf classes should be abstract