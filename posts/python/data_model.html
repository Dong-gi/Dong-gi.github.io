<hr>

<details>
    <summary>Objects, values, and types</summary>
    <ol>
        <li>모든 객체는 id, type, value를 갖는다.</li>
        <li>id는 생성된 후에는 불변하며, CPython의 경우 id(obj)는 obj의 메모리 주소다.</li>
        <li>type(obj)으로 obj의 타입을 얻을 수 있으며, id와 마찬가지로 불변하다.</li>
        <li>Container : 다른 객체에 대한 참조를 포함하는 객체</li>
    </ol>
</details>

<hr>

<details>
    <summary>The standard type hierarchy</summary>
    <ul>
        <li>None</li>
        None 식별자로 이 타입의 싱글톤 객체를 얻을 수 있다. 값이 없음을 알리기 위해 사용된다.

        <li>NotImplemented</li>
        NotImplemented 식별자로 이 타입의 싱글톤 객체를 얻을 수 있다. 산수 메서드, 비교 메서드는 연산이 구현되지 않은 경우 이를 반환해야 한다.

        <li>Ellipsis</li>
        리터럴 ... 이나 Ellipsis 식별자로 이 타입의 싱글톤 객체를 얻을 수 있다. 다음은 NumPy에서 "전체 차원"을 의미하는 ...
        <button class="btn-code" path="posts/python/data_model.py" displayRange="[1,1,10,39]" lan="python">예시</button>
    </ul>

    <details>
        <summary>numbers.Number; 수</summary>
        <ol>
            <li>numbers.Integral; 정수</li>
            <ol>
                <li>int; 크기 제약 없는 정수</li>
                <li>bool; <button class="btn-code" path="posts/python/data_model.py" displayRange="[42,45]" lan="python">int의 subtype</button>이며, True, False는 대부분 상황에서 <button class="btn-code" path="posts/python/data_model.py" displayRange="[46,47]" lan="python">1, 0처럼 동작</button>한다.</li>
            </ol>
            <li>numbers.Real (float); double precision 부동 소수</li>
            <li>numbers.Complex (complex); 실수부, 허수부 모두 float인 복소수.</li>
        </ol>
    </details>

    <details>
        <summary>시퀀스</summary>
        <ol>
            <li>음이 아닌 정수로 인덱싱 ─ seq[i] ─ 될 수 있는 유한 길이의 순서 있는 집합</li>
            <li>내장함수 len(seq)는 시퀀스가 가진 항목의 수를 반환한다</li>
            <li>seq[i:j], seq[i:j:k] 슬라이싱 지원</li>
        </ol>
        <details>
            <summary>불변 시퀀스</summary>
            <ol>
                <li>문자열</li>
                <ul>
                    <li>U+0000 ~ U+10FFFF 유니코드 코드 포인트를 표현하는 값들의 시퀀스. 코드 포인트 값은 내장 함수 ord()로 획득 가능</li>
                    <li>char 타입이 없는 대신, 각 문자열의 코드 포인트들은 길이 1인 문자열 객체.</li>
                    <li>str.encode()는 주어진 인코딩으로 str을 bytes로 변환하고, bytes.decode()는 그 역을 수행한다.</li>
                </ul>

                <li>튜플; tuple</li>
                <ul>
                    <li>임의 객체들로 이루어진 시퀀스.</li>
                    <li>항목이 2개 이상 : 콤마로 분리한 표현식의 나열로 튜플 생성</li>
                    <li>항목이 1개 : 표현식이 콤마를 붙여서 생성</li>
                    <li>항목이 0개 : 한 쌍의 빈 괄호로 <button type="button" class="btn btn-primary btn-sm btn-code" path="posts/python/data_model.py" displayRange="[50,55]" lan="python">생성</button></li>
                </ul>

                <li>bytes</li>
                <ul>
                    <li>바이트(0 ~ 255) 단위 불변 배열</li>
                    <li>리터럴 생성 : b'Hello World'</li>
                    <li>생성자 이용 : bytes()</li>
                </ul>
            </ol>
        </details>
        <details>
            <summary>가변 시퀀스</summary>
            <ol>
                Subscription ─ seq[i]와 슬라이싱은 대입문과 del 문의 대상으로 사용될 수 있다
                <li>list</li>
                []안에 표현식을 콤마로 분리하여 표현함으로써 생성
                <li>bytearray</li>
                bytes와 같은 인터페이스와 기능을 제공.
                <li>확장 모듈 array, collections는 추가적인 가변 시퀀스 타입을 제공한다</li>
            </ol>
        </details>
    </details>

    <ul>
        <li>집합</li>
        중복없는 불변 객체들의 순서없는 유한집합. 인덱싱할 수는 없지만 이터레이팅은 가능하다.<br>
        가변 집합 set과 불변 집합 frozenset이 있다.
        
        <li>매핑</li>
        임의의 인덱스 집합으로 인덱싱되는 객체들의 유한집합. 매핑에서 인덱스 표기법 map[k]는 매핑 map에서 k로 인덱스 되는 객체를 선택한다. 이는 표현식에 사용되거나 del 문의 대상이 될 수 있다.<br>
        내장 매핑형은 dict 하나가 존재하며, 키로 사용할 수 있는 것은 불변 객체뿐 ─ 키의 해시값이 불변할 것을 요구하기 때문 ─ 이다.
    </ul>

    <details>
        <summary>Callable type; 호출 가능 타입</summary>
        <ol>
            <li>사용자 정의 함수</li>
            함수 정의를 통해 사용자 정의 함수 객체가 생성된다.
            <details>
                <summary>Special attributes</summary>
                <table>
                    <thead>
                        <tr>
                            <th>속성</th>
                            <th>의미</th>
                            <th>제한</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>__doc__</td>
                            <td>함수 도움말 문자열. 없는 경우 None. 상속되지 않는다.</td>
                            <td>쓰기 가능</td>
                        </tr>
                        <tr>
                            <td>__name__</td>
                            <td>함수명</td>
                            <td>쓰기 가능</td>
                        </tr>
                        <tr>
                            <td>__qualname__</td>
                            <td>정규화된 함수명. Since 3.3</td>
                            <td>쓰기 가능</td>
                        </tr>
                        <tr>
                            <td>__module__</td>
                            <td>함수가 정의된 모듈명. 없는 경우 None.</td>
                            <td>쓰기 가능</td>
                        </tr>
                        <tr>
                            <td>__defaults__</td>
                            <td>인자의 기본값 ─ 없는 경우 None으로 만들어진 튜플.</td>
                            <td>쓰기 가능</td>
                        </tr>
                        <tr>
                            <td>__code__</td>
                            <td>컴파일된 함수의 바디(body)를 나타내는 코드 객체</td>
                            <td>쓰기 가능</td>
                        </tr>
                        <tr>
                            <td>__globals__</td>
                            <td>함수의 전역 변수들을 가진 딕셔너리에 대한 참조</td>
                            <td>읽기 전용</td>
                        </tr>
                        <tr>
                            <td>__dict__</td>
                            <td>함수에 할당된 이름 공간.</td>
                            <td>쓰기 가능</td>
                        </tr>
                        <tr>
                            <td>__annotations__</td>
                            <td>매개변수의 어노테이션을 가진 dict. dict의 키는 매개변수의 이름인데, 반환 값 어노테이션이 있다면 'return'을 키로 사용</td>
                            <td>쓰기 가능</td>
                        </tr>
                        <tr>
                            <td>__kwdefaults__</td>
                            <td>키워드 형태로만 전달 가능한 매개변수들의 기본값을 가진 dict.</td>
                            <td>쓰기 가능</td>
                        </tr>
                    </tbody>
                </table>
            </details>

            <li>Instance method</li>
            <ol>
                <li>인스턴스 메서드는 클래스, 클래스 인스턴스, 다른 콜러블 객체를 결합한다</li>
                <li>__self__ ::= 클래스 인스턴스 객체<br>
                    __func__ ::= 함수 객체<br>
                    __doc__ == __func__.__doc__<br>
                    __name__ == __func__.__name__</li>
                <li>기저 함수의 함수 속성을 읽을 수 있다. 쓰기는 불가</li>
            </ol>

            <li>Generator function</li>
            yield 문을 사용하는 함수나 메서드. 이터레이터 객체를 반환한다.

            <li>Coroutine function</li>
            async def로 정의된 함수나 메서드. 코루틴 객체를 반환한다.

            <li>Asynchronous generator function</li>
            async def로 정의된 함수가 yield 문을 사용하는 경우. async for문에서 사용되는 비동기 이터레이터 객체를 반환한다.<br>
            비동기 이터레이터의 aiterator.__anext__() 메서드를 호출하면 awaitable을 반환하는데, await할 때 yield 문이 값을 제공할 때까지 함수가 실행된다.

            <li>Built-in function</li>
            C 함수를 래핑

            <li>Built-in method</li>
            내장 함수에 전달될 묵시적 객체를 자동으로 설정한다

            <li>Class</li>
            자신의 새 인스턴스를 만드는 팩터리로 동작한다. 호출 인자는 __new__(), __init__()으로 전달된다.

            <li>Class instance</li>
            클래스에서 __call__() 메서드를 정의하면 클래스 인스턴스를 콜러블로 만들 수 있다
        </ol>
    </details>

    <ul>
        <li>Internal type - Slice object</li>
        __getitem__() 메서드를 위한 슬라이스 객체. 내장 함수 slice()로도 생성 가능. 읽기 전용 속성 start, stop, step과 메서드
        <button class="btn-code" path="posts/python/data_model.py" displayRange="[58,65]" lan="python">indices()</button>를 가진다.
    </ul>
</details>

<hr>

<details>
    <summary>특별 메서드</summary>
    특별 메서드를 구현하면 사용자 정의 객체도 내장형 객체처럼 작동하게 된다.
    <details>
        <summary>Basic customization</summary>
        <ol>
            <li>object.__new__(clazz[, ...])</li>
            <ol>
                <li>클래스 clazz의 새 인스턴스를 만들기 위해 호출된다.</li>
                <li>첫 번째 인자는 만들려는 인스턴스의 클래스, 나머지는 생성자에 전달될 것들</li>
                <li>__new__()가 clazz 인스턴스를 반환한다면 인스턴스의 __init__() 메서드가 __init__(self[, ...])처럼 호출된다.</li>
                <li>주로 int, str, tuple 등 불변형 클래스의 서브 클래스의 인스턴스 생성을 위해 사용하고, 일반적인 구현은 super().__new__(cls[, ...])를 호출한 뒤에 나머지 작업 수행</li>
            </ol>

            <li>object.__init__(self[, ...])</li>
            <ol>
                <li>베이스 클래스가 __init__() 메서드를 갖고 있다면, 서브 클래스 __init__() 구현 시 명시적으로 호출해주는 것이 옳다.</li>
                <li>__new__() 메서드가 생성하고 __init__() 메서드가 값을 설정하므로, __init__()은 None만을 반환할 수 있다.</li>
            </ol>

            <li>object.__del__(self)</li>
            <ol>
                <li>베이스 클래스가 __del__() 메서드를 갖고 있다면, 서브 클래스에서 명시적으로 호출해줘야 한다.</li>
                <li>del x는 x의 참조 횟수를 감소시키고, x.__del__()은 참조 횟수가 0이 될 때 호출된다.</li>
                <li>인터프리터 종료 시 남아있는 객체들의 __del__() 호출은 보장되지 않는다.</li>
            </ol>

            <li>object.__repr__(self)</li>
            <ol>
                <li>repr() 내장 함수에 의해 호출되며, 객체에 대한 정형적인 문자열 표현을 계산한다.</li>
                <li>객체의 문자열 표현 자체가 객체를 만들 수 있는 표현식이 되는 것이 좋다</li>
                <li>__str__()이 없는 경우, 추가적으로 호출될 수 있다</li>
            </ol>

            <li>object.__str__(self)</li>
            <ol>
                <li>str(object)와 내장 함수 format(), print()에 의해 호출된다</li>
                <li>읽기 좋은 객체의 문자열 표현을 반환하면 된다</li>
                <li>object에 정의된 기본 구현은 object.__repr__()을 호출한다</li>
            </ol>

            <li>object.__bytes__(self)</li>
            bytes 생성자에 의해 호출되며, 객체의 바이트열 표현을 반환하면 된다.

            <li>object.__format__(self, format_spec)</li>
            format() 내장 함수, 포맷 문자열 리터럴 계산, str.format() 메서드에 의해 호출된다. 정의되지 않은 경우 str(x)가 호출된다.

            <li>object.__lt__(self, other) + le, eq, ne, gt, ge</li>
            각각 &lt;, &lt;=, ==, !=, &gt;, &gt;=로 호출된다.

            <li>object.__hash__(self)</li>
            <ol>
                <li>내장 함수 hash()와 set, frozenset, dict과 같은 해시형 컬렉션에서 호출된다.</li>
                <li>사용자 정의 클래스는 기본적으로 인스턴스의 고유값을 반환하는 __hash__()와 __eq__()를 갖는다.</li>
                <li>__eq__()를 재정의하면 __hash__()는 None으로 설정된다. __hash__()를 재정의할 때, __eq__()를 같이 정의해줘야 컬렉션에서 정상 작동된다.</li>
                <li>__eq__()를 재정의하지 않고 __hash__()를 지원하지 않으려는 경우, __hash__ = None 설정을 직접 해줘야 한다.</li>
            </ol>
            
            <li>object.__bool__(self)</li>
            <ol>
                <li>논리값 검사와 내장 연산 bool()에서 호출된다.</li>
                <li>재정의하지 않은 경우, __len__()이 정의됐다면 return __len__() != 0</li>
                <li>재정의하지 않았고, __len__()도 없다면 참으로 취급</li>
            </ol>
        </ol>
    </details>

    <details>
        <summary>Customizing attribute access</summary>
        <ol>
            <li>object.__getattribute__(self, name)</li>
            <ol>
                <li>인스턴스의 속성을 접근할 때 항상 호출된다.</li>
                <li>인스턴스의 속성값을 반환하거나 AttributeError를 일으켜야 한다.</li>
                <li>재정의할 때, 무한 재귀의 발생을 방지하기 위해 object.__getattribute__(self, name)처럼 베이스 클래스의 메서드를 호출해야 한다.</li>
            </ol>

            <li>object.__getattr__(self, name)</li>
            __getattribute__()가 AttributeError를 일으키거나 __get__()이 AttributeError를 일으킬 때 호출된다.
            
            <li>object.__setattr__(self, name, value)</li>
            속성명(name)에 대한 값(value)을 별개 객체가 아닌, 인스턴스(self)의 속성에 직접 대입하는 경우, object.__setattr__(self, name, value)처럼 베이스 클래스의 메서드를 호출해야 한다.

            <li>object.__delattr__(self, name)</li>
            del obj.name이 의미가 있는 경우에만 재정의해야 한다.

            <li>object.__dir__(self)</li>
            객체에 dir()이 호출될 때 호출된다. 시퀀스를 반환해야 한다.
        </ol>
        <details>
            <summary>Customizing module attribute access</summary>
            모듈 수준의 __getattr__, __dir__ 정의 가능. 다른 특별 메서드들도 정의해주고 싶다면 모듈 객체의 __class__ 속성을 types.ModuleType의 서브 클래스로 설정.
            <a role="button" target="_blank" class="btn btn-info btn-sm" href="https://docs.python.org/ko/3/reference/datamodel.html#customizing-module-attribute-access">참고자료 1</a>
            <a role="button" target="_blank" class="btn btn-info btn-sm" href="https://www.python.org/dev/peps/pep-0562/">참고자료 2</a>
            <button class="btn-code" path="Repositories/Python/Basic/large_module.py" lan="python">large_module.py »</button>
            <button class="btn-code" path="Repositories/Python/Basic/test_module.py" lan="python">test_module.py »</button>
            <button class="btn-code" path="Repositories/Python/Basic/module_example.py" lan="python">module_example.py »</button>
        </details>
        <details>
            <summary>Implementing Descriptors</summary>
            <ol>
                다음의 메서드들은, 메서드가 정의된 클래스의 인스턴스가 소유자(owner) 클래스에 등장할 때만 적용된다. 속성(attribute)들은 소유자 클래스의 __dict__의 키로 이용되는 속성을 가리킨다.
                <li>object.__get__(self, instance, owner)</li>
                <ol>
                    <li>소유자 클래스 속성 접근, 소유자 클래스 인스턴스의 속성 접근시 호출된다.</li>
                    <li>owner는 항상 소유자 클래스며, 클래스 속성 접근 시 instance는 None.</li>
                    <li>속성값을 반환하거나 AttributeError를 일으켜야 한다</li>
                </ol>
                <li>object.__set__(self, instance, value)</li>
                <li>object.__delete__(self, instance)</li>
                <li>object.__set_name__(self, owner, name)</li>
                소유자 클래스 owner가 생성될 때 호출되어 이 디스크립터를 name에 할당한다.
                <button class="btn-code" path="Repositories/Python/Basic/descriptor_example.py" lan="python">descriptor_example.py »</button>
            </ol>
            <details>
                <summary>디스크립터 호출</summary>
                <ol>
                    <li>디스크립터 : __get__(), __set__(), __delete__() 중 하나라도 정의한 클래스</li>
                    <ul>
                        <li>Data descriptor : __set__()이나 __delete__() 중 하나라도 정의한 경우</li>
                        보통 데이터 디스크립터는 __get__()과 __set__()을 모두 정의한다. 이 경우 데이터 디스크립터는 인스턴스의 __dict__에 있는 값보다 우선한다.<br>
                        <a role="button" target="_blank" class="btn btn-info btn-sm" href="https://docs.python.org/ko/3/library/functions.html#property">property() 함수</a>는 데이터 디스크립터로 구현되기 때문에, 인스턴스가 property의 동작을 변경할 수 없다. property는 __set__()을 자동 구현하므로, 읽기 전용 속성을 만들기 쉽다.
                        <button class="btn-code" path="Repositories/Python/Basic/property_example.py" displayRange="[1,17,20,35]" lan="python">property_example.py »</button>
                        <li>Non-data descriptor : 인스턴스 __dict__보다 우선순위가 낮다</li>
                        파이썬 메서드(staticmethod(), classmethod() 포함)는 비데이터 디스크립터로 구현되기 때문에, 인스턴스가 메서드를 새로 정의하거나 덮어쓸 수 있다. 따라서 같은 클래스의 다른 인스턴스들과는 다른 동작을 할 수 있다.<br>
                        → 모든 사용자 정의 함수는 __get__() 메서드가 정의된 디스크립터다. 사용자 정의 함수가 객체의 메서드로 바인드되고, 바인딩된 메서드 객체는 __call__() 메서드를 가지며, __self__ 속성을 첫 번째 인자로 전달해서 __func__ 속성이 참조하는 원래 함수를 호출한다.
                    </ul>
                    
                    <li>속성 접근(obj.name) 기본 절차</li>
                    obj.__dict__['name'] → type(obj).__dict__['name'] → type(obj)의 메타 클래스를 제외한 베이스 클래스 조회
    
                    <li>속성 접근 기본 절차 대신 디스크립터가 호출되는 경우</li>
                    <ol>
                        <li>직접 호출 : name.__get__(obj)</li>
                        <li>인스턴스 결합 : obj.name → type(obj).__dict__['name'].__get__(obj, type(obj))</li>
                        <li>클래스 결합 : Clazz.name → Clazz.__dict__['name'].__get__(None, Clazz)</li>
                        <li>Super 결합</li>
                        super(Child, obj).method() → obj.__class__.__mro__에서 Child 바로 다음 나오는 베이스 클래스 Parent를 찾은 뒤, Parent.__dict__['method'].__get__(obj, obj.__class__)
                    </ol>
                </ol>
            </details>
        </details>
        <details>
            <summary>object.__slots__</summary>
            <ol>
                <li>멤버를 명시적으로 선언하고 __dict__와 __weakref__ 생성을 거부할 수 있다. 이를 통해 공간 절약 + 속성 접근 속도 향상을 기대할 수 있다.</li>
                <li>__slots__가 없는 클래스를 상속하면 인스턴스의 __dict__와 __weakref__ 속성은 항상 존재한다</li>
                <li>__dict__가 생성되지 않으므로, __slots__에 없는 새 속성을 할당할 수 없다(AttributeError).</li>
                동적으로 새로운 속성을 할당하는 것이 필요하다면 __slots__에 '__dict__'를 추가한다
                <li>__weakref__가 생성되지 않으므로, 인스턴스에 대한 약한 참조를 지원하지 않는다.</li>
                약한 참조 지원이 필요하다면 __slots__에 '__weakref__'를 추가한다.
                <li>__slots__는 각 변수 이름마다 디스크립터를 만드는 방식으로 클래스 수준에서 구현된다</li>
                <li>부모가 선언한 __slots__는 자식 클래스에도 제공된다</li>
                자식 클래스가 __slots__(새로 추가되는 변수명만 포함)을 정의하지 않으면 __dict__와 __weakref__를 갖게 된다
            </ol>
        </details>
    </details>
    
    <details>
        <summary>Customizing class creation</summary>
        <ol>
            <li><i>classmethod</i> object.__init_subclass__(cls)</li>
            클래스를 상속하는 경우, 베이스 클래스의 __init_subclass__가 호출된다. 클래스 데코레이터는 직접 적용할 클래스를 지정해줘야 하지만, __init_subclass__는 미래에 정의될 모든 서브 클래스에 적용된다.<br>
            새 클래스에 주어진 키워드 인자들(metaclass 제외)은 부모 클래스의 __init_subclass__로 전달된다. __init_subclass__에서는 필요한 키워드 인자들만 사용하고, 나머지는 베이스 클래스로 전달해야 한다.
            <button class="btn-code" path="Repositories/Python/Basic/init_subclass.py" lan="python">예시 코드 »</button>

            <li>metaclass</li>
            <ol>
                <li><a role="button" target="_blank" class="btn btn-info btn-sm" href="https://stackoverflow.com/a/6581949/7369515">https://stackoverflow.com/a/6581949/7369515</a></li>
                <li>기본적으로 클래스는 type(name, bases, dict)을 사용해서 만들어진다.</li>
                <li>메타클래스는 type(name, bases, dict)의 동작을 대신 수행할 수 있는 함수/클래스다. __new__, __init__, __call__을 후킹하여 복잡한 작업을 뒤에서 처리할 수 있게 해준다.</li>
            </ol>
        </ol>
    </details>
        <li>__getitem__() : 이 메서드를 구현한 클래스의 인스턴스 x에 대하여, x[i] == type(x).__getitem__(x, i)</li>
    
</details>

<hr>

<button class="btn-code" path="Repositories/Python/Basic/descriptor_example.py" lan="python">descriptor_example.py »</button>