<html lnag="ko"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="google-site-verification" content="aH-DyzdytYQ0NPHNQFcs5dVoiu5YNs6CEEHYgqDmAFM"><meta name="author" content="Donggi Kim &lt;hi.donggi@gmail.com&gt;"><meta name="keywords" content="Python, Built-in, Type"><meta name="description" content="Python 내장 자료형 정리"><title>Python Built-in Types</title><link id="w3css" rel="stylesheet" href="/source/w3.css"><link id="highlight-style" rel="stylesheet" href="/source/xcode.css"><link id="default-style" rel="stylesheet" href="/source/default.css"><script id="highlight-js" src="/source/highlight.pack.js"></script><script id="default-js" src="/source/default.min.js"></script><script id="dsq-count-scr" src="//donggi.disqus.com/count.js" async></script><script id="google-analytics" src="https://www.googletagmanager.com/gtag/js?id=UA-143098403-1" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-143098403-1');</script></head><body><div id="sidebar" class="w3-bar-block w3-sidebar w3-animate-left"><hr><a href="javascript:closeSidebar();" class="w3-bar-item w3-button">Close &times;</a><hr><div id="marker-list"></div><hr><div id="post-list"><details open="" id="dir-1627423780" class="w3-small file-list" title="카테고리"><summary>카테고리</summary><ul><details id="dir-1275377989" class="w3-small file-list" title="카테고리/단일 문서" open=""><summary>/단일 문서</summary><ul><li><a href="/posts/single/refactoring.html">디자인 패턴 + 리팩터링</a></li><li><a href="/posts/single/aws.html">AWS</a></li><li><a href="/posts/single/centos.html">CentOS</a></li><li><a href="/posts/single/docker.html">Docker</a></li><li><a href="/posts/single/fp.html">FP; Functional Programming</a></li><li><a href="/posts/single/git.html">Git</a></li><li><a href="/posts/single/nginx.html">Nginx</a></li><li><a href="/posts/single/rpi.html">Raspberry Pi 3 + OpenCV(python)</a></li><li><a href="/posts/single/sdkman.html">SDKMAN; The Software Development Kit Manager</a></li><li><a href="/posts/single/tomcat.html">tomcat</a></li><li><a href="/posts/single/vi.html">vi</a></li></ul></details><details id="dir-992513986" class="w3-small file-list" title="카테고리/독서" open=""><summary>/독서</summary><ul><li><a href="/posts/book/001.html">1만 시간의 재발견</a></li><li><a href="/posts/book/002.html">마음의 탄생</a></li><li><a href="/posts/book/003.html">생각하는 삶을 위한 철학의 역사</a></li><li><a href="/posts/book/004.html">쇼펜하우어, 돌이 별이 되는 철학</a></li><li><a href="/posts/book/005.html">인생의 모든 의미</a></li><li><a href="/posts/book/009.html">인지 편향</a></li><li><a href="/posts/book/006.html">지식의 착각</a></li><li><a href="/posts/book/007.html">키르케고르 실존 극장</a></li><li><a href="/posts/book/008.html">Gamification by Design</a></li></ul></details><details id="dir-453420171" class="w3-small file-list" title="카테고리/알고리즘" open=""><summary>/알고리즘</summary><ul><li><a href="/posts/algorithm/book01.html">『알고리즘 도감』</a></li><li><a href="/posts/algorithm/linear_algebra.html">선형대수</a></li><li><a href="/posts/algorithm/algo.html">알고리즘 일반</a></li><li><a href="/posts/algorithm/probability.html">확률</a></li><details id="dir--1451989604" class="w3-small file-list" title="카테고리/알고리즘/KOREATECH" open=""><summary>/KOREATECH</summary><ul><li><a href="/posts/algorithm/koreatech/1003.html">1003: 0을 만들자</a></li><li><a href="/posts/algorithm/koreatech/1008.html">1008: 순환 소수</a></li><li><a href="/posts/algorithm/koreatech/1018.html">1018: 문자열 거리 최소화 하기</a></li><li><a href="/posts/algorithm/koreatech/1048.html">1048: AP 배분</a></li><li><a href="/posts/algorithm/koreatech/1095.html">1095: 자연스러운 정렬</a></li><li><a href="/posts/algorithm/koreatech/1034.html">1034,1041: 최소 이동 거리</a></li><li><a href="/posts/algorithm/koreatech/1011.html">동적계획법(DP) 문제</a></li><li><a href="/posts/algorithm/koreatech/1010.html">소수(Prime) 관련 문제</a></li></ul></details></ul></details><details id="dir-1817032068" class="w3-small file-list" title="카테고리/작성 중지" open=""><summary>/작성 중지</summary><ul><li><a href="/posts/single/quantum_computer.html">양자 컴퓨터</a></li><li><a href="/posts/algorithm/ai.html">AI</a></li><li><a href="/posts/single/unity.html">Unity</a></li></ul></details><details id="dir-991040073" class="w3-small file-list" title="카테고리/DB" open=""><summary>/DB</summary><ul><li><a href="/posts/db/concept.html">DB 기초</a></li><li><a href="/posts/db/mongodb.html">MongoDB</a></li><li><a href="/posts/db/mysql.html">MySQL</a></li><li><a href="/posts/db/psql_to_sqlite.html">PostgreSQL → SQLite3 마이그레이션</a></li><li><a href="/posts/db/psql_admin.html">PostgreSQL 서버 관리</a></li><li><a href="/posts/db/psql_programming.html">PostgreSQL 서버 프로그래밍</a></li><li><a href="/posts/db/psql_tutorial.html">PostgreSQL 시작하기</a></li><li><a href="/posts/db/psql_sql.html">PostgreSQL SQL 언어</a></li></ul></details><details id="dir-68539214" class="w3-small file-list" title="카테고리/Programming" open=""><summary>/Programming</summary><ul><details id="dir--681806672" class="w3-small file-list" title="카테고리/Programming/.NET" open=""><summary>/.NET</summary><ul><li><a href="/posts/dotnet/csharp_basic.html">C# 기초</a></li><li><a href="/posts/dotnet/csharp_library.html">C# 라이브러리</a></li><li><a href="/posts/dotnet/wpf_basic.html">WPF 기초</a></li></ul></details><details id="dir-1549890375" class="w3-small file-list" title="카테고리/Programming/FreeMarker" open=""><summary>/FreeMarker</summary><ul><li><a href="/posts/front/freemarker/template_guide.html">템플릿 작성 가이드 2.3.28</a></li><li><a href="/posts/front/freemarker/programming_guide.html">프로그래밍 가이드 2.3.28</a></li><li><a href="/posts/front/freemarker/built_in.html">Built-in 목록 2.3.28</a></li><li><a href="/posts/front/freemarker/xml_guide.html">XML 처리 가이드 2.3.28</a></li></ul></details><details id="dir-362107912" class="w3-small file-list" title="카테고리/Programming/Front" open=""><summary>/Front</summary><ul><li><a href="/posts/front/css.html">CSS</a></li><li><a href="/posts/front/html.html">HTML</a></li><li><a href="/posts/front/http.html">HTTP 1.1</a></li></ul></details><details id="dir--680952733" class="w3-small file-list" title="카테고리/Programming/Java" open=""><summary>/Java</summary><ul><li><a href="/posts/java/effective_java.html">『Effective Java』</a></li><li><a href="/posts/java/android.html">Android</a></li><li><a href="/posts/java/oop.html">Java 객체지향</a></li><li><a href="/posts/java/version.html">Java 버전별 추가사항</a></li><li><a href="/posts/java/basic.html">Java 시작하기</a></li><li><a href="/posts/java/jni.html">Java Native Interface</a></li><li><a href="/posts/java/java_ee.html">JavaEE</a></li><li><a href="/posts/java/javafx.html">JavaFX</a></li><li><a href="/posts/java/performance.html">JVM 옵션 및 성능 관련사항</a></li><details id="dir--741032455" class="w3-small file-list" title="카테고리/Programming/Java/3rd" open=""><summary>/3rd</summary><ul><li><a href="/posts/java/apache.commons.collections.html">Apache Commons Collections 4.4</a></li><li><a href="/posts/java/apache.commons.lang.html">Apache Commons Lang 3.9</a></li><li><a href="/posts/java/apache.commons.math.html">Apache Commons Math 3.6.1</a></li><li><a href="/posts/java/apache.commons.rng.html">Apache Commons RNG Core 1.2</a></li><li><a href="/posts/java/gson.html">Gson 2.8.6</a></li><li><a href="/posts/java/guava.html">Guava 23.0</a></li><li><a href="/posts/java/jackson.html">Jackson 2.10.1</a></li><li><a href="/posts/java/logback.html">Logback with SLF4J</a></li><li><a href="/posts/java/lombok.html">lombok 1.18.10</a></li></ul></details><details id="dir-76588809" class="w3-small file-list" title="카테고리/Programming/Java/Standard" open=""><summary>/Standard</summary><ul><li><a href="/posts/java/javax.annotation.processing.html">Annotation Processing API</a></li><li><a href="/posts/java/com.sun.nio.sctp.html">com.sun.nio.sctp Since 1.7</a></li><li><a href="/posts/java/java.base.html">java.base 12</a></li></ul></details></ul></details><details id="dir-1907368718" class="w3-small file-list" title="카테고리/Programming/JavaScript" open=""><summary>/JavaScript</summary><ul><li><a href="/posts/javascript/basic2.html">브라우저 JavaScript</a></li><li><a href="/posts/javascript/basic.html">코어 JavaScript</a></li><li><a href="/posts/javascript/jquery.html">jQuery</a></li><li><a href="/posts/javascript/node.html">Node</a></li></ul></details><details id="dir--1366657315" class="w3-small file-list" title="카테고리/Programming/Python" open=""><summary>/Python</summary><ul><li><a href="/posts/python/pandas.html">3rd/pandas : 데이터 처리</a></li><li><a href="/posts/python/standard.html">표준 라이브러리</a></li><li><a href="/posts/python/data_model.html">Python 3.8 데이터 모델</a></li><li><a href="/posts/python/basic.html">Python 3.8 시작하기</a></li><li><a href="/posts/python/built_in_constant.html">Python Built-in Constants 3.8</a></li><li><a href="/posts/python/built_in_exception.html">Python Built-in Exceptions 3.8</a></li><li><a href="/posts/python/built_in_function.html">Python Built-in Functions 3.8</a></li><li><a href="/posts/python/built_in_type.html">Python Built-in Types 3.8</a></li><li><a href="/posts/python/persistence.html">Python Data Persistence</a></li></ul></details></ul></details><details id="dir--419676146" class="w3-small file-list" title="카테고리/Project" open=""><summary>/Project</summary><ul><li><a href="/posts/project/tip.html">잡다한 팁</a></li><li><a href="/posts/project/wpf_data_tool.html">C#.NET, WPF - 데이터 작업 툴</a></li><li><a href="/posts/project/snippets.html">Code Snippets</a></li><li><a href="/posts/project/error.html">Exceptions + Errors</a></li></ul></details></ul></details></div><hr><div id="file-list"></div><hr></div><div id="main"><div id="nav" style="position:-webkit-sticky;position:sticky;top:0px;vertical-align:middle" class="w3-bar w3-blue w3-large"><button onclick="toggleSidebar()" class="w3-bar-item w3-button w3-hover-theme">&#9776;</button><input id="query" type="text" placeholder="search" class="w3-bar-item"></div><div id="contents" class="w3-padding"><h1 class="marker">진리값 판별</h1><p>모든 객체는 if 조건, while 조건, Boolean 연산에 이용하기 위한 진리값 판별이 가능하다.</p><p>기본적으로 __bool__() 메서드가 false를 반환하거나 __len__() 메서드가 0을 반환하지 않는 객체는 참이다.</p><h1 class="marker">논리 연산</h1><p>and(short-circuit), or(short-circuit), not</p><h1 class="marker">비교 연산</h1><ol><li>&lt;, &lt;=, >, >=, ==, !=, is(object identity), is not</li><li>연속적인 비교가 가능하다.</li><p>x &lt; y &lt;= z는 y가 한번만 계산된다는 것만 빼곤 x &lt; y and y &lt;= z와 동일하다.</p><li>__eq__() 메서드를 정의하지 않는 이상 인스턴스들은 보통 같지 않다고 판별된다</li><li>__lt__(), __le__(), __gt__(), __ge__() 등을 충분히 정의하지 않으면 정렬이 불가능하다. 보통 __lt__()와 __eq__()로 충분하다.</li></ol><h1 class="marker">숫자 타입</h1><div lan="python" class="as-code code-div w3-leftbar w3-border-green">int                # 정밀도는 제한이 없다.
float              # 관련 정보는 sys.float_info를 통해 확인할 수 있다.
complex            # 실수부(z.real) 허수부(z.imag)는 각각 float이다.
fractions.Fraction # 유리수
decimal.Decimal    # 사용자 정의 정밀도 부동소수

# 산술 연산
x + y
x - y
x * y
x / y
x // y
x % y
-x
+x
abs(x)
int(x)
float(x)
complex(re, im)
c.conjugate() # 켤레복소수
divmod(x, y)
pow(x, y)
x ** y

# 비트 연산
x | y
x ^ y
x & y
x &lt;&lt; n
x >> n
~x

# int(numbers.Integral 구현체) 확장 연산
int.bit_length()
    # Since 3.1, 비트 길이
int.to_bytes(length, byteorder, *, signed=False)
    # Since 3.2, byteorder : "big" | "little" | sys.byteorder
classmethod int.from_bytes(bytes, byteorder, *, signed=False)
    # Since 3.2, bytes는 bytes-like object거나 byte iterable이어야 한다

# float(numbers.Real 구현체) 확장 연산
float.as_integer_ratio()
    # (분자, 분모) 튜플을 반환한다. 분모는 양수.
float.is_integer()
float.hex()
    # 0x로 시작하고 p로 끝난뒤 지수가 붙는다. 지수의 base는 2
classmethod float.fromhex(s)
    # C의 %a 포맷과 Java의 Double.toHexString()의 결과를 받아들일 수 있다.

# Hashing
#     해시값은 modulo P 안에서 선택된다. P는 고정된 소수로, sys.hash_info에서 확인 가능
</div><h1 class="marker">Iterator Types</h1><div lan="python" class="as-code code-div w3-leftbar w3-border-green">container.__iter__()
    # container가 iteration을 지원하려면 정의해야 한다.
    # 반환하는 객체는 iterator protocol(아래의 2개 특별 메서드)을 지원해야 된다.
iterator.__iter__()
    # iterator 자기 자신을 반환하면 된다
iterator.__next__()
    # 다음 요소 반환. 없으면 StopIteration 발생.</div><div><h2 class="marker">Generator Types</h2><p>generator는 iterator protocol을 쉽게 제공한다. container의 __iter__()가 generator로 정의된 경우, 자동으로 __iter__()와 __next__()를 지원하는 iterator 객체를 반환한다.<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Python/Basic/syntax.py" displayRange="[143,150]" lan="python">예시 1 »</button><button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Python/Basic/syntax.py" displayRange="[70,76]" lan="python">예시 2»</button></p></div><h1 class="marker">Sequence Types</h1><ul><li>list, tuple, range # 3가지 기본 시퀀스 타입</li><li class="marker">Common Sequence Operations</li><div lan="python" class="as-code code-div w3-leftbar w3-border-green">x in s
x not in s
s[i]
s[i:j]
s[i:j:k]
len(s)
min(s)
max(s)
s.count(x)
s + t # 접합
s * n # 셀프 접합
n * s # 셀프 접합
s.index(x[, i[, j]]) # s[i:j]중 처음 등장하는 x의 위치</div><ul><li>collections.abc.Sequence는 사용자 정의 sequence 타입의 연산 정의를 도와준다.</li><li>str, bytes, bytearray도 subsequence 검사에 in을 이용할 수 있다.</li><li>s * n은 s를 n번 복제하는 것이 아니라 s를 n번 접근하는 것이다. 복제하려면 list comprehension 이용</li><li>index가 음수일 경우 len(s) + i가 대신 쓰인다. 단, -0 == 0</li><li>불변 sequence들의 접합은 항상 새로운 객체를 생성하며, 시간 비용은 n^2</li><ul><p>↓ 보다 빠른 접합</p><li>str : str.join() 이용 | io.StringIO 객체에 쓰기</li><li>bytes : bytes.join() 이용 | io.BytesIO 객체에 쓰기 | bytearray 이용</li><li>tuple : list를 대신 이용</li></ul></ul><li>Immutable Sequence Types : hash()를 지원할 수 있다</li><li>Mutable Sequence Types</li><div lan="python" class="as-code code-div w3-leftbar w3-border-green">s[i] = x
x[i:j] = t
del s[i:j]
del s[i:j:k]
s.append(x)
s.clear()
s.copy()
s.extend(t)
s += t
s *= n
s.insert(i, x)
s.pop([i])
s.remove(x)
s.reverse()</div><ul><li>collections.abc.MutableSequence는 사용자 정의 sequence 타입의 연산 정의를 도와준다.</li><li>슬라이스에 대한 할당(s[i:j:k] = t)은 길이가 일치해야 한다</li></ul></ul><h1 class="marker">Text Sequence Type</h1><p>str 객체 또는 유니코드 시퀀스 strings로 표현하며, 모두 내용은 변경 불가능하다.<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Python/Basic/format_map_example.py" lan="python">format_map 예시 »</button><button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Python/Basic/translate_example.py" lan="python">translate 예시 »</button></p><div lan="python" class="as-code code-div w3-leftbar w3-border-green">casefold() # lower()보다 강한 변환
swapcase() # 두 번 적용한 것이 원본과 항상 같지는 않다

center(width[, fillchar])
ljust(width[, fillchar])
rjust(width[, fillchar])

count(sub[, start[, end]])
find(sub[, start[, end]]), str.rfind(sub[, start[, end]])
    # 첫 등장 위치. 없으면 -1. 단순 포함 여부는 in 연산자
index(sub[, start[, end]]), str.rindex(sub[, start[, end]])
    # find와 같으나 없으면 ValueError

endswith(suffix[, start[, end]])
startswith(prefix[, start[, end]])
    # suffix, prefix에 튜플도 가능

encode(encoding="utf-8", errors="strict")

expandtabs(tabsize=8)
    # 오피스 문서와 같은 탭 작업.
    # 문자열 끝에 탭이 존재하면, 반환된 문자열의 길이는 tabsize의 배수가 된다.

format(*args, **kwargs)
format_map(mapping) # str.format(**mapping)과 유사

isalnum()
isdecimal() # [0-9]만
isdigit()
isnumeric() # digit보다 광범위

strip([chars])
lstrip([chars])
rstrip([chars])
    # 연속한 chars 문자들을 제거한다. 인자가 없는 경우 연속적인 공백을 제거한다.

static maketrans(x[, y[, z]])
    # str.translate()에 쓰일 번역 테이블을 생성한다.
    # (x) : translate()에서 서술하는 table
    # (x, y) : 같은 길이의 문자열
    # (x, y, z) : 마지막 문자열의 각 문자들은 None에 매핑
translate(table)
    # table의 key는 유니코드 정수여야 하고, 대응하는 value는 유니코드 정수값이나 문자열이 가능하다.

partition(sep)
rpartition(sep)
    # 처음 만나는 sep을 기준으로 분리하여, (앞부분, sep, 뒷부분)을 반환. sep이 없을 경우 (sep, '', '')반환.

join(iterable)
    # iterable 문자열들을 str로 접합
split(sep=None, maxsplit=-1)
rsplit(sep=None, maxsplit=-1)
    # sep으로 분리한 부분 문자열 리스트 반환. sep이 주어지지 않은 경우 공백문자로 분리하며, 연속적인 공백문자도 하나의 공백으로 처리하고 결과에 빈 문자열은 포함하지 않는다.
splitlines([keepends])
    # keepends=True면 줄바꿈 문자를 결과에 포함한다.

replace(old, new[, count])
zfill(width)
    # '0'을 문자열 앞에 붙인다. 처음 등장하는 '+', '-'는 위치 유지.
</div><h1 class="marker">Binary Sequence Types</h1><ul><li>bytes, bytearray, memoryview</li><p>핵심 자료형은 bytes, bytearray며, memoryview는 다른 이진 객체를 복사하지 않고 buffer protocol을 통해 접근한다.</p><li class="marker">class bytes([source[, encoding[, errors]]]) # 변경불가</li><ul><li>b'hello'처럼 b로 시작하는 문자열은 bytes 리터럴이다. 단, ASCII 문자만 가능.</li><li>문자열과 달리 bytes 객체 b의 b[0]는 정수, b[0:1]는 길이 1의 bytes 객체다.</li><li>각 바이트 숫자를 확인하는 데는 list(b)가 유용</li><li>0으로 초기화 → bytes(size)</li><li>정수 iterable로부터 생성 → bytes(iterable)</li><li>기존 이진 객체(buffer protocol)로부터 생성 → bytes(obj)</li><li>classmethod fromhex(string) ↔ hex() Since 3.5</li><p>16진수 표기 문자열로부터 생성. string은 반드시 1바이트당 2개 16진수를 포함해야하고, 공백(' ')은 무시된다.</p></ul><li class="marker">class bytearray([source[, encoding[, errors]]]) # 가변</li><ul><li>빈 bytearray 객체 → bytearray()</li><li>0으로 초기화 → bytearray(size)</li><li>정수 iterable로부터 생성 → bytearray(iterable)</li><li>기존 이진 객체(buffer protocol)로부터 생성 → bytearray(buf)</li><li>classmethod fromhex(string) ↔ hex() Since 3.5 # bytes와 비슷</li></ul><li class="marker">bytes and bytearray Operations</li><div lan="python" class="as-code code-div w3-leftbar w3-border-green">decode(encoding="utf-8", errors="strict")

# str 유사 메서드가 많다. 아래는 차이점만 기술
count(), find(), index()
    # sub는 bytes-like object거나 [0, 255] 사이의 정수(Since 3.3)여야 한다.
static maketrans(from, to)
    # Since 3.1, from, to는 같은 길이의 bytes-like object여야 한다. translate()에 이용할 테이블을 생성한다.
translate(table, delete=b'')
    # 포함하는 delete 안의 바이트들을 모두 제거한 뒤 table에 따라 변환한다. table은 길이 256의 bytes 객체여야 한다.
partition(), rpartition()
    # 없으면 (sep, b'', b'') 또는 (sep, bytearray(b''), bytearray(b'')) 반환
</div><li class="marker">class memoryview(obj)</li><ul><li>obj가 수정 가능할 경우, 1차원 slice 할당이 가능하다. 단, 크기 변경은 불가능하다.</li><li>Since 3.3 → 1차원 memoryview는 slicing 가능</li><li>Since 3.4 → memoryview는 자동으로 collections.abc.Sequence</li><li>Since 3.5 → 정수 tuple로 indexing 가능</li><button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Python/Basic/tobytes_example.py" lan="python">tobytes 예 »</button><button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Python/Basic/cast_example.py" lan="python">cast 예 »</button></ul><div lan="python" class="as-code code-div w3-leftbar w3-border-green">__eq__(exporter)
    # struct 모듈이 지원하지 않는 객체와의 비교는 False
tobytes(order=None)
    # bytes 생성자 호출과 같은 결과
    # Snice 3.8 → order는 'C'(default, C 순서), 'F'(Fortran 순서), 'A'(메모리 복사) 중 하나
hex()
    # Since 3.5, 16진수 문자열 반환
tolist()
    # 버퍼 데이터를 리스트로 반환
toreadonly()
    # Since 3.8
release()
    # Since 3.2, buffer 해제. 이후 다른 연산은 ValueError

cast(format[, shape])
    # Since 3.3, 같은 buffer를 참조하는 새 memoryview 객체를 반환한다.
    # format은 struct syntax로 지정하며, 가능한 포맷은 'B'(unsigned char), 'b'(signed char), 'c'(char)
    # shape 기본값은 [byte_length//new_itemsize]

// 인스턴스 프로퍼티
obj          # Since 3.3, memoryview의 기저 객체
readonly     # 객체가 readonly인지 여부
format       # struct 모듈 스타일의 format string
nbytes       # Since 3.3, 바이트 크기
itemsize     # 요소 하나의 바이트 크기
ndim         # 몇 차원 배열인지
shape        # 크기가 ndim인 튜플로 표현되는 배열 모양
strides      # 크기가 ndim인 튜플로 표현되는 각 차원 원소의 바이트 크기
c_contiguous # Since 3.3, 메모리가 C-contiguous인지
f_contiguous # Since 3.3, 메모리가 Fortran contiguous인지
contiguous   # Since 3.3, 메모리가 contiguous인지
</div></ul><h1 class="marker">Set Types</h1><div><h2 class="marker">class set([iterable])<br>class frozenset([iterable])</h2><ul><li>해시 가능한 순서 없는 collection. frozenset은 불변이며, 다른 set의 원소가 될 수 있다.</li><li>연산자 버전이 있는 메서드들은 인자로 iterable도 받을 수 있다.</li><li>set과 frozenset 두 가지에 대한 연산 결과는 첫번째 피연산자의 타입이다.</li></ul><div lan="python" class="as-code code-div w3-leftbar w3-border-green">len(s)
x in s
x not in s
for x in set

isdisjoint(other)                  # 교집합이 공집합인지 여부
issubset(other)                    # 연산자 &lt;=, &lt;로도 가능
issuperset(other)                  # 연산자 >=, >로도 가능
union(*others)                     # 연산자 |로도 가능
intersection(*others)              # 연산자 &로도 가능
difference(*others)                # 연산자 -로도 가능
symmetric_difference(other)        # 연산자 ^로도 가능
update(*others)                    # others의 모든 원소 추가. set |= other | ...
intersection_update(*others)       # 모든 집합에 속하는 공통 원소들만 보존. set &= other & ...
difference_update(*others)         # 호출자에 속하는 원소들만 보존. set -= other | ...
symmetric_difference_update(other) # set ^= other

# ↓ elem은 set일 수 있다.
copy()
add(elem)
discard(elem) # 포함하면 삭제
remove(elem)  # 없으면 KeyError
pop()         # 임의 원소 삭제
clear()
</div></div><h1 class="marker">Mapping Types</h1><div><h2 class="marker">class dict(**kwarg)<br>class dict(mapping, **kwarg)<br>class dict(iterable, **kwarg)</h2><p>mapping 객체는 해시 가능한 값을 임의 객체로 매핑한다.</p><div lan="python" class="as-code code-div w3-leftbar w3-border-green">a = dict(one=1, two=2, three=3)
b = {'one': 1, 'two': 2, 'three': 3}
c = dict(zip(['one', 'two', 'three'], [1, 2, 3]))
d = dict([('two', 2), ('one', 1), ('three', 3)])
e = dict({'three': 3, 'one': 1, 'two': 2})

a == b == c == d == e</div><div><h3 class="marker">Dictionary Operations</h3><div lan="python" class="as-code code-div w3-leftbar w3-border-green">len(d)
d[key]
d[key] = value
del d[key]
key in d
key not in d
iter(d)
copy()
clear()
list(d) # 키 리스트 반환

classmethod fromkeys(seq[, value])
    # seq를 키로 하는 dict 반환. value의 기본값은 None
get(key[, default])
    # key가 없으면 default 반환
items()
    # (key, value)쌍에 대한 view 반환
keys()
    # key에 대한 view 반환
values()
    # value에 대한 view 반환

pop(key[, default])
popitem() # 임의 키-값 쌍 제거

setdefault(key[, default])
    # key가 있으면 value 반환, 없으면 default로 추가하고 defualt 반환. 둘 다 없으면 KeyError
update([other])
    # other에는 dict 생성 인자들 모두 허용된다.

# Since 3.8 → dict 순서를 reversed()로 뒤집을 수 있다
</div><h3 class="marker">Dictionary view objects</h3><p>dict.keys(), dict.values(), dict.items()로 반환된 뷰. dict의 변화는 뷰에도 반영된다.</p><div lan="python" class="as-code code-div w3-leftbar w3-border-green">len(dictview)
iter(dictview) # dict 수정 중엔 RuntimeError 발생 가능
x in dictview
reversed(dictview) # Since 3.8
</div></div></div><h1 class="marker">Context Manager Types</h1><ul><li>with statement</li><p>Context manager가 정의한 runtime context를 지원</p><li>contextmanager.__enter__()</li><p>반환된 객체는 with문의 as 절의 식별자에 bound된다.</p><li>contextmanager.__exit__(exc_type, exc_val, exc_tb)</li><p>억제된 예외가 있는지 여부 반환. True면 인자에 예외 타입, 값, traceback 정보가 넘어간다.</p></ul><h1 class="marker">Special Attributes</h1><div lan="python" class="as-code code-div w3-leftbar w3-border-green">object.__dict__
instance.__class__
class.__bases__
definition.__name__
class.subclasses__()
class.__mro__ # method를 찾는 순서
class.mro() # __mro__ 반환. 재정의 가능.
definition.__qualname__
    # Since 3.3, Qualified name(모듈의 글로벌 스코프부터 호출자까지 '.'으로 구분)</div></div><hr>&copy; 2020. <a href="mailto:hi.donggi@gmail.com">Donggi Kim</a> all rights reserved.<a class="w3-btn w3-round w3-round-xxlarge w3-small w3-green" href="/LICENSE" target="_blank">/LICENSE</a></div></body></html>