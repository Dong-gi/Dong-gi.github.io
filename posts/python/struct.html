<ul>
    <li>struct는 bytes 객체로 표현된 C 구조체와 Python 값 사이의 변환을 지원한다.</li>
    <li>struct.pack(fmt, v1, v2, ...) : 포맷 문자열 fmt에 따라 v1, v2, ... 들을 포장한 bytes 객체 반환</li>
    <li>struct.pack_into(fmt, buffer, offset, v1, v2, ...) : pack의 결과를 쓰기 가능한 buffer의 offset 위치에 쓴다</li>
    <li>struct.unpack(fmt, buffer) : 포맷 문자열 fmt에 따라 포장된 buffer를 풀어 값의 튜플로 반환</li>
    <li>struct.unpack_from(fmt, buffer, offset=0) : unpack과 유사</li>
    <li>struct.iter_unpack(fmt, buffer) Since 3.4 : unpack 순회하는 iterator 반환. buffer 크기는 반드시 fmt의 정수배 == calcsize(fmt)</li>
    <li>struct.calcsize(fmt) : format 표현에 필요한 바이트 크기</li>
</ul>

<details>
    <summary>Format String</summary>
    <li>Byte Order, Size, and Alignment</li>
    <table>
        <tr><th>Char</th><th>Byte order</th><th>Size</th><th>Alignment</th></tr>
        <tr><td>@(default)</td><td>native</td><td>native</td><td>native</td></tr>
        <tr><td>=</td><td>native</td><td>standard</td><td>none</td></tr>
        <tr><td>&lt;</td><td>little-endian</td><td>standard</td><td>none</td></tr>
        <tr><td>&gt;</td><td>big-endian</td><td>standard</td><td>none</td></tr>
        <tr><td>!</td><td>network(=big-endian)</td><td>standard</td><td>none</td></tr>
    </table>
    <ul>
        <li>Native byte order : 호스트 시스템으로 결정</li>
        <li>Native size, alignment : C 컴파일러의 sizeof로 결정</li>
    </ul>
    <li>Format Character</li>
    <table>
        <tr><th>Char</th><th>C type</th><th>Python type</th><th>Standard size</th></tr>
        <tr><td>x</td><td>pad byte</td><td>no value</td><td></td></tr>
        <tr><td>c</td><td>char</td><td>bytes of length 1</td><td>1</td></tr>
        <tr><td>b</td><td>signed char</td><td>integer</td><td>1</td></tr>
        <tr><td>B</td><td>unsigned char</td><td>integer</td><td>1</td></tr>
        <tr><td>?</td><td>_Bool</td><td>bool</td><td>1</td></tr>
        <tr><td>h</td><td>short</td><td>integer</td><td>2</td></tr>
        <tr><td>H</td><td>unsigned short</td><td>integer</td><td>2</td></tr>
        <tr><td>i</td><td>int</td><td>integer</td><td>4</td></tr>
        <tr><td>I</td><td>unsigned int</td><td>integer</td><td>4</td></tr>
        <tr><td>l</td><td>long</td><td>integer</td><td>4</td></tr>
        <tr><td>L</td><td>unsigned long</td><td>integer</td><td>4</td></tr>
        <tr><td>q</td><td>long long</td><td>integer</td><td>8</td></tr>
        <tr><td>Q</td><td>unsigned long long</td><td>integer</td><td>8</td></tr>
        <tr><td>n Since 3.3</td><td>ssize_t</td><td>integer</td><td>@에서만 가능</td></tr>
        <tr><td>N Since 3.3</td><td>size_t</td><td>integer</td><td>@에서만 가능</td></tr>
        <tr><td>e Since 3.6</td><td>반배 정밀도 부동소수</td><td>float</td><td>2</td></tr>
        <tr><td>f</td><td>float</td><td>float</td><td>4</td></tr>
        <tr><td>d</td><td>double</td><td>float</td><td>8</td></tr>
        <tr><td>s</td><td>char[]</td><td>bytes</td><td></td></tr>
        <tr><td>p</td><td>char[]</td><td>bytes</td><td></td></tr>
        <tr><td>P</td><td>void*</td><td>integer</td><td>@,=에서만 가능</td></tr>
    </table>
    <ul>
        <li>포맷 문자 앞에 정수가 오면 반복을 의미한다. 포맷 문자 사이의 공백은 무시한다.</li>
        <li>s의 경우 앞에 오는 정수는 반복이 아닌 바이트 크기다. 주어지지 않는다면 기본은 1. 패킹 과정에서 크기를 맞추기 위해 null 바이트가 포함될 수 있다. 언패킹에선 bytes 객체의 크기가 딱 알맞다.</li>
    </ul>
</details>
            **
            **
            ** 0s는 빈 문자열을 의미한다.(0c는 0개 문자)
            ** p는 "Pascal string"으로, 첫 바이트는 문자열 길이를 담는다.

            4. 예제
            &raquo; https://docs.python.org/3/library/struct.html#examples
            &gt;&gt;&gt; from struct import *
            &gt;&gt;&gt; pack('hhl', 1, 2, 3)
            b'\x00\x01\x00\x02\x00\x00\x00\x03'
            &gt;&gt;&gt; unpack('hhl', b'\x00\x01\x00\x02\x00\x00\x00\x03')
            (1, 2, 3)
            &gt;&gt;&gt; calcsize('hhl')
            8

            5. Classes
            &raquo; class struct.Struct(format)
            * pack(v1, v2, ...), pack_into(buffer, offset, v1, v2, ...), unpack(buffer), unpack_from(buffer,
            offset=0), iter_unpack(buffer) Since 3.4, format, size
