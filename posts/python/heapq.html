<script src="/source/redirect.js?200226_1657"></script>
<ul>
    <li>부모 노드 &lt; 자식 노드인 힙을 이용한 큐</li>
    <li>인덱스 접근 heap[i] 가능</li>
    <strong>heapq 모듈은 명시적인 클래스를 제공하지 않음에 유의</strong> 리스트 자체를 힙처럼 이용한다.
    <li>우선순위 큐 구현 시 유의사항</li>
    <ol>
        <li>우선순위가 동일할 때, 힙에 들어온 순서가 영향을 끼치는 지 여부</li>
        예. 노드 속성에 삽입 순서를 추가
        <li>이미 삽입된 노드의 우선순위가 도중에 변경된 경우 위치를 어떻게 옮길 것인지</li>
        예. 기존 노드는 비활성화 처리하고, 새로 힙에 추가
    </ol>
</ul>
<ol>
    <li>heapq.heapify(x) : 리스트 x를 힙으로 제자리(in-place) 변환</li>
    <li>heapq.heappush(heap, item)</li>
    <li>heapq.heappop(heap) : heap[0] 노드를 제거하고 반환한다</li>
    <li>heapq.heappushpop(heap, item) : push 후 pop</li>
    <li>heapq.heapreplace(heap, item) : pop 후 push</li>
    <li>heapq.merge(*iterables, key=None, reverse=False)</li>
    미리 오름차순 정렬된 여러 Iterable에 대해, 크기순으로 하나씩 순회하는 새 Iterable을 반환한다. reverse=True인 경우, 입력 Iterable들은 내림차순 정렬돼있어야 한다.
    <li>heapq.nsmallest(n, iterable, key=None) == sorted(iterable, key=key)[:n]</li>
    <li>heapq.nlargest(n, iterable, key=None) == sorted(iterable, key=key, reverseTrue)[:n]</li>
</ol>