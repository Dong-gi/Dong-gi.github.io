<hr>

<details>
    <summary>SQL Syntax</summary>
    <details>
        <summary>Lexical Structure</summary>
        <ol>
            <li>식별자와 키워드</li>
            select라는 이름의 컬럼을 가져오려면 select "select" from table_name;처럼 이용한다. 그로지 말자...
            <ul>
                <li>select, from : 키워드</li>
                <li>"select" : ""로 감싼 식별자. U&"d\0061t\+000061"처럼 유니코드 코드 포인트를 이용할 수 있다.</li>
                <li>table_name : Unquoted 식별자. 대소문자를 구별하지 않는다.</li>
            </ul>

            <li>상수</li>
            문자열 상수 : '문자열'<br>
            달러 인용 문자열 상수 : 달러 인용 문자열은 이스케이프되지 않는다.<br>
            예1. $$Dianne's horse$$, $SomeTag$Dianne's horse$SomeTag$<br>
            예2. CREATE OR REPLACE FUNCTION change_inaba_name() RETURNS TRIGGER AS $$<br>
            BEGIN<br>
            　　NEW.status_text = REPLACE(NEW.status_text, 'イナバ', '이나바');<br>
            　　RETURN NEW;<br>
            END;<br>
            $$ LANGUAGE plpgsql;
        </ol>
    </details>

    <details>
        <summary>Value Expressions</summary>
        <ol>
            <li>열 참조</li>
            correlation.columnname // correlation은 테이블 이름이나 alias

            <li>위치 매개변수</li>
            함수 정의의 매개변수 위치를 이용해 변수 참조<br>
            예. 문자열을 2번 반복해서 반환하는 함수<br>
            CREATE OR REPLACE FUNCTION test(text) RETURNS text AS $body$ SELECT $1 || $1 $body$ LANGUAGE sql;
        
            <li>배열 요소 참조</li>
            expression[subscript] // subscript는 integer 값을 내는 표현식
            expression[lower_subscript:upper_subscript]

            <li>필드 선택</li>
            expression.fieldname : 특정 행의 열 참조 // expression은 row type 또는 열집합<br>
            일반적으로 expression은 괄호로 감싸져야 하지만, 테이블이나 위치 매개변수의 경우 생략할 수 있다.<br>
            .*로 모든 필드를 얻을 수 있다.

            <li>
                <details>
                    <summary>집계 함수 호출</summary>
                    <ul>
                        <li>집계 함수(aggregate function)란 여러 입력 행들을 하나의 결과행으로 줄이는 함수.</li>
                        <li>집계 함수의 형태</li>
                        <ul>
                            <li>aggregate_name (expression [ , ... ] [ order_by_clause ] ) [ FILTER ( WHERE filter_clause ) ] -- default로 ALL이므로 2번째와 동일</li>
                            <li>aggregate_name (ALL expression [ , ... ] [ order_by_clause ] ) [ FILTER ( WHERE filter_clause ) ]</li>
                            <li>aggregate_name (DISTINCT expression [ , ... ] [ order_by_clause ] ) [ FILTER ( WHERE filter_clause ) ]</li>
                            <li>aggregate_name ( * ) [ FILTER ( WHERE filter_clause ) ] -- 보통 count에서만 사용되는 형태</li>
                            <li>aggregate_name ( [ expression [ , ... ] ] ) WITHIN GROUP ( order_by_clause ) [ FILTER ( WHERE filter_clause ) ]</li>
                            <li>위의 expression은 집계 함수나 윈도우 함수 호출을 포함하지 않아야 한다.</li>
                            <li>복수의 인자를 받는 집계 함수에서는 ORDER BY 절이 전체 인자가 끝나고 등장해야 한다.</li>
                            SELECT string_agg(str, ',' ORDER BY str) FROM table;
                        </ul>
                        <li>SELECT count(*) AS unfiltered, count(*) FILTER (WHERE num < 5) AS filtered FROM generate_series(1,10) AS num;</li>
                        <li>내장 집계 함수 : <a role="button" target="_blank" class="btn btn-info btn-sm" href="http://postgresql.kr/docs/9.6/functions-aggregate.html">http://postgresql.kr/docs/9.6/functions-aggregate.html</a></li>
                    </ul>            
                </details>
            </li>
            
            <li>
                <details>
                    <summary>윈도우 함수 호출</summary>
                    <ul>
                        <li>윈도우 함수는 집계 함수와 비슷하지만, 입력 행들이 결과에 그대로 나타난다.</li>
                        <li>윈도우 함수의 형태</li>
                        <ul>
                            <li>function_name ([expression [, expression ... ]]) [ FILTER ( WHERE filter_clause ) ] OVER window_name</li>
                            <li>function_name ([expression [, expression ... ]]) [ FILTER ( WHERE filter_clause ) ] OVER ( window_definition )</li>
                            <li>function_name ( * ) [ FILTER ( WHERE filter_clause ) ] OVER window_name</li>
                            <li>function_name ( * ) [ FILTER ( WHERE filter_clause ) ] OVER ( window_definition )</li>
                        
                            <li>window_name은 WINDOW 절로 정의된 윈도우 이름.</li>
                            OVER window_name과 OVER (window_name)은 다르다. 후자의 경우 윈도우 정의를 복사하여 적용하며, frame 절을 포함하는 경우 수행되지 않는다.
                        
                            <li>window_definition</li>
                            [ existing_window_name ]<br>
                            [ PARTITION BY expression [, ...] ]<br>
                            [ ORDER BY expression [ ASC | DESC | USING operator ] [ NULLS { FIRST | LAST } ] [, ...] ]<br>
                            [ frame_clause ]<br>
                            <br>
                            PARTITION BY 옵션은 행 그룹을 만든다. GROUP BY와 달리 출력-열이나 숫자를 지정할 수 없다.<br>
                            ORDER BY 절도 마찬가지로 출력-열이나 숫자를 지정할 수 없다.
                        
                            <li>frame_clause</li>
                            <ol>
                                <li>{ RANGE | ROWS } frame_start -- default로 frame_end는 CURRENT ROW</li>
                                <li>{ RANGE | ROWS } BETWEEN frame_start AND frame_end</li>
                            </ol>
                            frame_clause는 윈도우 함수가 전체 파티션이 아닌, 현재까지의 파티션을 대상으로 계산을 수행하게 한다.<br>
                            UNBOUNDED PRECEDING으로 지정된 frame_start는 파티션의 첫 행, UNBOUNDED FOLLOWING으로 지정된 frame_end는 파티션 마지막 행을 의미한다.
                        
                            <li>frame_start, frame_end</li>
                            <ol>
                                <li>UNBOUNDED PRECEDING</li>
                                <li>value PRECEDING</li>
                                <li>CURRENT ROW</li>
                                <li>value FOLLOWING</li>
                                <li>UNBOUNDED FOLLOWING</li>
                            </ol>
                            value PRECEDING, FOLLOWING은 ROWS 모드에서만 사용 가능하고, 현재 행을 전후로 하여 프레임 크기를 설정한다.
                        
                            <li>frame_exclusion</li>
                            <ol>
                                <li>EXCLUDE CURRENT ROW</li>
                                <li>EXCLUDE GROUP</li>
                                <li>EXCLUDE TIES</li>
                                <li>EXCLUDE NO OTHERS</li>
                            </ol>
                        
                            <li>expression은 윈도우 함수 호출을 포함하지 않아야 한다.</li>
                        </ul>
                    
                        <li>내장 윈도우 함수 : <a role="button" target="_blank" class="btn btn-info btn-sm" href="http://postgresql.kr/docs/9.6/functions-window.html#FUNCTIONS-WINDOW-TABLE">http://postgresql.kr/docs/9.6/functions-window.html#FUNCTIONS-WINDOW-TABLE</a></li>
                    </ul>
                </details>
            </li>
            
            <li>
                <details>
                    <summary>Collation Expressions</summary>
                    예. 로캐일에 따른 정렬
                    <ul>
                        <li>SELECT * FROM tbl WHERE ... ORDER BY a COLLATE "C"; // 결과 정렬</li>
                        <li>SELECT * FROM tbl WHERE a &gt; 'foo' COLLATE "C"; // 입력 정렬</li>
                        <li>SELECT * FROM tbl WHERE a COLLATE "C" &gt; 'foo'; // 입력 정렬</li>
                        <li>SELECT * FROM tbl WHERE (a &gt; 'foo') COLLATE "C"; // 에러. 연산 결과인 boolean은 non-collatable</li>
                    </ul>

                    LC_COLLATE를 설정하여 기본적으로 로캐일에 따른 정렬을 수행
                    <ol>
                        <li>데이터베이스 최초 생성 시 LC_COLLATE 변수 값을 'C'로 설정</li>
                        <li>기존 데이터베이스를 dump하고, LC_COLLATE를 'C'로 설정한 데이터베이스를 만들어 복구</li>
                        db_name=# DROP DATABASE [db_name];<br>
                        db_name=# CREATE DATABASE [db_name] LC_COLLATE 'C';<br>
                        -- 데이터베이스는 생성될 때 기본적으로 template1 데이터베이스를 복제하여 생성된다. 하지만 이는 로캐일이 이미 설정되어 충돌하여 에러가 발생할 수 있다.<br>
                        db_name=# CREATE DATABASE [db_name] TEMPLATE template0 LC_COLLATE 'C';
                    </ol>
                </details>
            </li>

            <li>Scalar Subqueries</li>
            한 행 또는 한 컬럼을 반환하는, 괄호에 감싸인 SELECT 쿼리<br>
            SELECT name, (SELECT max(pop) FROM cities WHERE cities.state = states.name) FROM states;
            
            <li>
                <details>
                    <summary>배열 생성자</summary>
                    SELECT ARRAY[1,2,3+4];<br>
                    SELECT ARRAY[1,2,22.7]::integer[];<br>
                    SELECT ARRAY[]::integer[]; // 빈 배열도 형식은 필요<br>
                    SELECT ARRAY[ARRAY[1,2], ARRAY[3,4]];<br>
                    SELECT ARRAY(SELECT oid FROM pg_proc WHERE proname LIKE 'bytea%');<br>
                    <br>
                    CREATE TABLE arr(f1 int[], f2 int[]);<br>
                    INSERT INTO arr VALUES (ARRAY[[1,2],[3,4]], ARRAY[[5,6],[7,8]]);
                </details>
            </li>

            <li>
                <details>
                    <summary>행 생성자</summary>
                    SELECT ROW(1,2.5,'this is a test');<br>
                    SELECT ROW(t.*, 42) FROM t; // t는 행 값<br>
                    예. SELECT ROW(t.*, 42) FROM (SELECT ROW(1,2.5,'this is a test')) as t;<br>
                    <br>
                    CREATE TABLE mytable(f1 int, f2 float, f3 text);<br>
                    CREATE OR REPLACE FUNCTION getf1(mytable) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;<br>
                    -- No cast needed since only one getf1() exists<br>
                    SELECT getf1(ROW(1,2.5,'this is a test'));<br>
                    CREATE TYPE myrowtype AS (f1 int, f2 text, f3 numeric);<br>
                    CREATE OR REPLACE FUNCTION getf1(myrowtype) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;<br>
                    -- Now we need a cast to indicate which function to call:<br>
                    SELECT getf1(ROW(1,2.5,'this is a test')::mytable);<br>
                    SELECT getf1(CAST(ROW(11,'this is a test',2.5) AS myrowtype));
                </details>
            </li>

            <li>Expression Evaluation Rules</li>
            <ul>
                <li>SELECT true OR somefunc();와 SELECT somefunc() OR ture; 모두 somefunc()가 호출되지 않는다. short-circuit 연산과 다르다.</li>
                <li>SELECT ... WHERE CASE WHEN x &gt; 0 THEN y/x &gt; 1.5 ELSE false END;</li>
                <li>SELECT CASE WHEN x &gt; 0 THEN x ELSE 1/0 END FROM tab;</li>
                주의. IMMUTABLE 함수는 값이 먼저 평가되기 때문에, 실제로 x가 항상 0보다 크더라도 1/0이 미리 평가되어 에러가 발생한다.
                <a role="button" target="_blank" class="btn btn-info btn-sm" href="http://postgresql.kr/docs/current/xfunc-volatility.html">http://postgresql.kr/docs/current/xfunc-volatility.html</a>
            </ul>
        </ol>
    </details>
            
    <details>
        <summary>함수 호출</summary>
        PostgreSQL의 함수의 인자는 이름과 위치 둘 다로 참조할 수 있다.<br>
        CREATE FUNCTION concat_lower_or_upper(a text, b text, uppercase boolean DEFAULT false) RETURNS text AS $$<br>
        　　SELECT CASE<br>
        　　　　WHEN $3 THEN UPPER($1 || ' ' || $2)<br>
        　　　　ELSE LOWER($1 || ' ' || $2)<br>
        　　END;<br>
        $$ LANGUAGE SQL IMMUTABLE STRICT;
        
        <ul>
            <li>Using Positional Notation</li>
            SELECT concat_lower_or_upper('Hello', 'World');
            
            <li>Using Named Notation</li>
            SELECT concat_lower_or_upper(a =&gt; 'Hello', b =&gt; 'World');
            
            <li>Using Mixed Notation</li>
            키워드 인자는 나머지보다 뒤에 위치해야 한다.<br>
            SELECT concat_lower_or_upper('Hello', 'World', uppercase =&gt; true);
        </ul>
    </details>
</details>

<hr>

<details>
    <summary>Data Definition</summary>
    <details>
        <summary>Default Values</summary>
        기본값으로 표현식을 사용할 수 있다. 가장 흔히 쓰이는 것은 timestamp 열이 CURRENT_TIMESTAMP 값을 갖게 하는 것.<br>
        CREATE TABLE products (<br>
        　　product_no integer DEFAULT nextval('products_product_no_seq'),<br>
        　　...<br>
        );<br>
    </details>

    <details>
        <summary>Constraints</summary>
        <ol>
            <li>
                <details>
                    <summary>Check Constraints</summary>
                    CREATE TABLE products ( product_no integer, price numeric CHECK (price &gt; 0) );<br>
                    <br>
                    식별자를 줄 수 있다.<br>
                    CREATE TABLE products ( product_no integer, price numeric CONSTRAINT positive_price CHECK (price &gt; 0) );<br>
                    <br>
                    여러 열을 체크할 수 있다.<br>
                    CREATE TABLE products (<br>
                    　　product_no integer,<br>
                    　　name text,<br>
                    　　price numeric CHECK (price &gt; 0),<br>
                    　　discounted_price numeric CHECK (discounted_price &gt; 0), CHECK (price &gt; discounted_price)<br>
                    );<br>
                    <br>
                    열 삽입 제약 조건을 테이블 제약 조건으로 사용할 수 있다.<br>
                    CREATE TABLE products (<br>
                    　　product_no integer,<br>
                    　　name text,<br>
                    　　price numeric CHECK (price &gt; 0),<br>
                    　　discounted_price numeric,<br>
                    　　CHECK (discounted_price &gt; 0 AND price &gt; discounted_price)<br>
                    );
                </details>
            </li>

            <li>Not-Null Constraints</li>
            CREATE TABLE products ( product_no integer NOT NULL, price numeric );

            <li>Unique Constraints</li>
            CREATE TABLE products ( product_no integer UNIQUE, price numeric );<br>
            CREATE TABLE products ( product_no integer, price numeric, UNIQUE (product_no) );<br>
            CREATE TABLE example ( a integer, b integer, c integer, UNIQUE (a, c) );<br>
            <br>
            식별자를 부여할 수 있다.<br>
            CREATE TABLE products ( product_no integer CONSTRAINT must_be_different UNIQUE, price numeric );

            <li>Primary Keys</li>
            CREATE TABLE example ( a integer, b integer, c integer, PRIMARY KEY (a, c) );

            <li>
                <details>
                    <summary>Foreign Keys</summary>
                    CREATE TABLE orders (<br>
                    　　order_id integer PRIMARY KEY,<br>
                    　　product_no integer REFERENCES products (product_no),<br>
                    　　quantity integer<br>
                    );<br>
                    <br>
                    CREATE TABLE t1 (<br>
                    　　a integer PRIMARY KEY,<br>
                    　　b integer,<br>
                    　　c integer,<br>
                    　　FOREIGN KEY (b, c) REFERENCES other_table (c1, c2)<br>
                    );<br>
                    <br>
                    외래키와 기본키 혼용<br>
                    CREATE TABLE order_items (<br>
                    　　product_no integer REFERENCES products,<br>
                    　　order_id integer REFERENCES orders,<br>
                    　　quantity integer,<br>
                    　　PRIMARY KEY (product_no, order_id)<br>
                    );
                </details>
            </li>

            <li>무결성 제약 : ON DELETE, ON UPDATE에 사용</li>
            CREATE TABLE order_items (<br>
            　　product_no integer REFERENCES products ON DELETE RESTRICT, -- 참조하는 행이 삭제되지 않음.<br>
            　　order_id integer REFERENCES orders ON DELETE CASCADE, -- 참조하는 행이 삭제되면 같이 삭제됨.<br>
            　　quantity integer,<br>
            　　PRIMARY KEY (product_no, order_id)<br>
            );
        </ol>
    </details>
    
    <details>
        <summary>System Columns</summary>
        oid : object_id. 테이블을 WITH OIDS로 생성하거나, default with oids이 설정된 경우 생성되는 열. 타입 이름도 oid.<br>
        <a role="button" target="_blank" class="btn btn-info btn-sm" href="http://postgresql.kr/docs/9.6/ddl-system-columns.html">http://postgresql.kr/docs/9.6/ddl-system-columns.html</a>
    </details>
    
    <details>
        <summary>Modifying Tables</summary>
        <ol>
            <li>Adding a Column</li>
            ALTER TABLE products ADD COLUMN description text;<br>
            ALTER TABLE products ADD COLUMN description text CHECK (description != '');

            <li>Removing a Column</li>
            ALTER TABLE products DROP COLUMN description;<br>
            <br>
            외래키로 참조중인 경우, 제약을 명시해줘야 반영된다.<br>
            ALTER TABLE products DROP COLUMN description CASCADE;

            <li>Adding a Constraint</li>
            ALTER TABLE products ADD CHECK (name != '');<br>
            ALTER TABLE products ADD CONSTRAINT some_name UNIQUE (product_no);<br>
            ALTER TABLE products ADD FOREIGN KEY (product_group_id) REFERENCES product_groups;<br>
            ALTER TABLE products ALTER COLUMN product_no SET NOT NULL;

            <li>Removing a Constraint</li>
            ALTER TABLE products DROP CONSTRAINT some_name;<br>
            ALTER TABLE products ALTER COLUMN product_no DROP NOT NULL;

            <li>Changing a Column's Default Value</li>
            ALTER TABLE products ALTER COLUMN price SET DEFAULT 7.77;<br>
            ALTER TABLE products ALTER COLUMN price DROP DEFAULT;

            <li>Changing a Column's Data Type</li>
            ALTER TABLE products ALTER COLUMN price TYPE numeric(10,2);<br>
            기존 값이 새로운 타입으로 암묵적으로 변환된다면 위의 것으로 충분. 복잡한 변환을 명시하려면 USING 절을 추가 사용.

            <li>Renaming a Column</li>
            ALTER TABLE products RENAME COLUMN product_no TO product_number;

            <li>Renaming a Table</li>
            ALTER TABLE products RENAME TO items;
        </ol>
    </details>
    
    <details>
        <summary>Privileges</summary>
        권한 : SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER, CREATE, CONNECT, TEMPORARY, EXECUTE, USAGE &lt;&lt; ALL
        <ul>
            <li>GRANT UPDATE ON table_name TO username;</li>
            <li>REVOKE ALL ON table_name FROM username;</li>
            <li>GRANT SELECT ON ALL TABLES IN SCHEMA public TO user;</li>
            <li>GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO user;</li>
        </ul>
    </details>
    
    <details>
        <summary>Row Security Policies</summary>
        예. 관리자 그룹에 속한 사용자가, 자신과 관련한 행만 접근<br>
        CREATE TABLE accounts (manager text, company text, contact_email text);<br>
        ALTER TABLE accounts ENABLE ROW LEVEL SECURITY;<br>
        CREATE POLICY account_managers ON accounts TO managers USING (manager = current_user);<br>
        <a role="button" target="_blank" class="btn btn-info btn-sm" href="http://postgresql.kr/docs/current/ddl-rowsecurity.html">http://postgresql.kr/docs/current/ddl-rowsecurity.html</a>
    </details>
    
    <details>
        <summary>Schemas</summary>
        CREATE SCHEMA myschema; -- Schema의 테이블은 schema.table 또는 database.schema.table로 접근<br>
        CREATE TABLE myschema.mytable ( ... );<br>
        <br>    
        DROP SCHEMA myschema;<br>
        DROP SCHEMA myschema CASCADE; -- 포함된 내용도 삭제<br>
        <br>
        모든 새 데이터베이스는 public이라는 스키마를 갖고 있다. 따라서 아래 두 문장은 서로 같다.<br>
        CREATE TABLE products ( ... );<br>
        CREATE TABLE public.products ( ... );
    </details>

    <details>
        <summary>Table Partitioning</summary>
        <ol>
            <li>개요</li>
            <ul>
                <li>Table partitioning : 논리적으로 하나인 거대한 테이블을 물리적으로 여러 개로 쪼개 저장하는 것.</li>
                <li>Range partitioning : 중복되지 않는 열 집합의 구간들로 분할</li>
                <li>List partitioning : 명시적인 키값 리스트로 분할</li>
                <li>Hash partitioning : 모듈로 n 공간에서 키값의 나머지가 같은 것들로 분할</li>
                <li>상속을 이용한 파티셔닝 : 자식 테이블은 추가적인 컬럼을 가질 수 있으며, 다중 상속도 가능하다.</li>
            </ul>

            <li>파티셔닝</li>
            CHECK, NOT NULL 제약 조건은 파티션 테이블에 상속된다. NO INHERIT 마킹된 CHECK 제약조건은 제외.<br>
            <br>
            예. create table api_access_log ( account_id int, access_time datetime, request_uri text ) partition by range(access_time);<br>
            create table api_access_log_201901 partition of api_access_log for values from ('2019-01-01') to ('2019-02-01');<br>
            <br>
            파티션 테이블을 파티셔닝할 수 있다.<br>
            create table api_access_log_201901 partition of api_access_log for values from ('2019-01-01') to ('2019-02-01') partition by range(account_id % 100);

            <li>주의</li>
            <ul>
                <li>값 변경으로 인해 행이 한 파티션에서 다른 파티션으로 이동되는 경우, 예약된 UPDATE, DELETE 작업이 실패할 수 있다.</li>
                <li>BEFORE ROW 트리거는 각 파티션 테이블에 따로 정의해야 한다.</li>
            </ul>

            <li>Partition Pruning</li>
            SET enable_partition_pruning = on;을 통해 옵션을 켤 수 있다. 켜 있는 게 디폴트.<br>
            가지치기 옵션이 켜있는 경우, 파티셔닝된 테이블의 정의(인덱스의 정의가 아니라)를 살펴, 스캔하지 않아도 되는 테이블들은 제외한다.<br>
            가지치기 시점 : 쿼리 플랜 초기화 시, 쿼리 플랜 실행 중(Append 노드 타입에 한하여)
        </ol>
    </details>
</details>

<hr>

<details>
    <summary>Data Manipulation</summary>
    <ol>
        <li>Inserting Data<br>
            Updating Data<br>
            Deleting Data</li>
        DB - PostgreSQL 시작하기 - SQL 언어 참고
            
        <li>Returning Data From Modified Rows</li>
        INSERT INTO users (firstname, lastname) VALUES ('Joe', 'Cool') RETURNING id;<br>
        UPDATE products SET price = price * 1.10 WHERE price <= 99.99 RETURNING name, price AS new_price;<br>
        DELETE FROM products WHERE obsoletion_date = 'today' RETURNING *;
    </ol>
</details>

<hr>

<details>
    <summary>Queries</summary>
    <details>
        <summary>Table Expressions</summary>
        <details>
            <summary>FROM 절</summary>
            <ol>
                <li>일반 : FROM table_reference [, table_reference [, ...]]</li>

                <li>Cartesian product(Cross join) : FROM T1 CROSS JOIN T2</li>
                또는 콤마로 구분 : FROM T1, T2

                <li>판별식을 이용한 조인 : FROM T1 { [INNER] | { LEFT | RIGHT | FULL } [OUTER] } JOIN T2 ON boolean_expression</li>
                두 테이블에 대해 판별식이 참일 경우에만 결과 행으로 반환된다.

                <li>컬럼 셋을 이용한 조인 : FROM T1 { [INNER] | { LEFT | RIGHT | FULL } [OUTER] } JOIN T2 USING ( join column list )</li>
                두 테이블의 컬럼 셋이 일치하는 경우에만 결과 행으로 반환된다.

                <li>자연 조인 : FROM T1 NATURAL { [INNER] | { LEFT | RIGHT | FULL } [OUTER] } JOIN T2</li>
                두 테이블의 공통된 컬럼 리스트를 USING한 것과 동일한 결과를 산출한다.

                <li>테이블 별명 : FROM table_reference [AS] alias</li>
                셀프 조인을 위해선 필수적으로 사용된다. 모호함을 피하기 위해 괄호를 이용할 수도 있다.<br>
                SELECT * FROM (my_table AS a CROSS JOIN my_table) AS b ...<br>
                컬럼에도 별명을 붙일 수 있다. FROM table_reference [AS] alias ( column1 [, column2 [, ...]] )

                <li>서브쿼리 사용을 위한 별명 : FROM (SELECT * FROM table1) AS alias</li>

                <li>Table function에 별명 사용</li>
                Table function : 행 집합을 반환하는 함수.<br>
                <br>
                CREATE TABLE foo (fooid int, foosubid int, fooname text);<br>
                CREATE FUNCTION getfoo(int) RETURNS SETOF foo AS $$ SELECT * FROM foo WHERE fooid = $1; $$ LANGUAGE SQL;<br>
                SELECT * FROM getfoo(1) AS t1;

                <li>LATERAL 서브쿼리 : 키워드 좌측의 테이블들을 참조할 수 있다</li>
                예, unknown_log 테이블로부터 각 로그의 첫 30글자, 삽입 시각, 로그 길이를 가져오기<br>
                SELECT substring(log.log, 1, 30), log.insert_datetime, len FROM unknown_log log LEFT JOIN LATERAL LENGTH(log.log) len ON true;<br>
                LEFT JOIN ON true == CROSS JOIN. 사실 LATERAL 빼도 잘 동작하며, 실제로 사용할 일이 있을진 모르겠음...<br>
            </ol>
        </details>

        <details>
            <summary>WHERE 절</summary>
            <li>GROUPING SETS, CUBE, ROLLUP</li>
            한 테이블에 대해 같은 조건으로 여러 그룹에 대해 SELECT해야하는 경우, 이를 한 번에 질의할 수 있다.<br>
            <br>
            SELECT brand, size, sum(sales) FROM items_sold GROUP BY GROUPING SETS ((brand), (size), ());<br>
            → 브랜드별 판매량, 사이즈별 판매량, 전체 판매량 각각이 한 테이블에 모두 표시된다<br>
            <br>
            GROUP BY CUBE ( a, b ) : a, b, c의 파워 셋에 대해 질의한 것과 같다. ((), (a), (b), (a, b))<br>
            GROUP BY ROLLUP ( a, b ) : 공집합부터 a, b, c를 순서대로 추가한 집합들에 대해 질의한 것과 같다. ((), (a), (a, b))<br>
            CUBE, ROLLUP의 요소로 리스트가 올 수 있다. ROLLUP(a, (b, c)) == ((), (a), (a, b, c))<br>
            <br>
            여러 그루핑 조건을 같이 쓰는 경우, 마지막 조건에 대해 cross product가 이루어진다<br>
            GROUP BY a, CUBE (b, c), GROUPING SETS (d, e) → ((a, d), (a, e), (a, b, d), (a, b, e), ..., (a, b, c, e))<br>
            <br>
            GROUP BY 절에서 행 생성자의 이용은 ROW(a, b)를 통해 할 수 있다
        </details>
    </details>
    
    <details>
        <summary>Select Lists</summary>
        SELECT DISTINCT select_list ... : 각 열집합에 대해 고유한 행들만 선택한다<br>
        SELECT DISTINCT ON (expression [, expression ...]) select_list ... : 모든 행에 대해 expression이 평가된다. 두 행의 모든 평가값이 같은 경우 두 행은 같다고 간주한다.
    </details>
    
    <details>
        <summary>Combining Queries</summary>
        query1 UNION [ALL] query2
        query1 INTERSECT [ALL] query2
        query1 EXCEPT [ALL] query2
    </details>
    
    <details>
        <summary>Sorting Rows</summary>
        <ul>
            <li>ORDER BY sort_expression1 [ASC | DESC] [NULLS { FIRST | LAST }] [, sort_expression2 ...]</li>
            <li>ASC, DESC : 기본값은 ASC</li>
            <li>NULLS FIRST, NULLS LAST : null값에 대한 정렬 순서를 의미하며, 기본값은 ASC의 경우 NULLS LAST, DESC의 경우 NULLS FIRST</li>
        </ul>
    </details>
    
    <details>
        <summary>LIMIT and OFFSET</summary>
        <ul>
            <li>SELECT select_list FROM table_expression [ ORDER BY ... ] [ LIMIT { number | ALL } ] [ OFFSET number ]</li>
            <li>LIMIT : 출력 행의 개수 제한</li>
            <li>OFFSET : 산출된 순서대로 n개 행을 출력하지 않고 무시</li>
        </ul>
    </details>
    
    <details>
        <summary>VALUES Lists</summary>
        <ul>
            <li>VALUES ( expression [, ...] ) [, ...]</li>
            SELECT * FROM (VALUES (1, 'one'), (2, 'two'), (3, 'three')) AS t (num,letter);

            <li>실제 디스크 상에 테이블을 만들지 않으면서 상수 테이블을 만드는 방법.</li>
            
            <li>문법적으로 "SELECT select_list FROM table_expression"과 동일하게 취급된다.</li>
        </ul>
    </details>
    
    <details>
        <summary>WITH Queries</summary>
        <details>
            <summary>SELECT in WITH</summary>
            <ol>
                <li>여러 개의 SELECT 서브 쿼리를 날리는 대신 WITH을 이용하여 분리할 수 있다.</li>
                with tmp1 AS (SELECT ...), tmp2 AS (SELECT ...) SELECT ... WHERE tmp1...

                <li>RECURSIVE를 이용하여 iteration 연산이 가능하다.</li>
                <ol>
                    연산 순서
                    <li>non-recursive 부분을 계산한다. UNION을 위해 (not UNION ALL) 중복되는 행을 제거한다. 남은 행들을 결과에 포함시키고, 임시 작업 테이블로 설정한다.</li>
                    <li>작업 테이블이 빌 때까지 아래를 반복한다.</li>
                    <ol>
                        <li>recursive 부분을 계산하고, 작업 테이블 내용을 덮어쓴다. UNION을 위해 (not UNION ALL) 중복된 행(이전 결과와도 비교)들을 제거한다. 남은 행들을 결과에 포함시키고, 임시 중간 테이블로 설정한다.</li>
                        <li>작업 테이블의 내용을 중간 테이블 내용으로 대체한다. 중간 테이블은 비운다.</li>
                </ol>
                
                <li>
                    <details>
                        <summary>예. 10~100의 합계.</summary>
                        WITH RECURSIVE t(n) AS ( VALUES (10) UNION SELECT n+1 FROM t WHERE n &lt; 100 )<br>
                        SELECT sum(n) FROM t;

                        <table class="table">
                            <tr><th>t</th><th>working_table</th></tr>
                            <tr><td>empty</td><td>empty</td></tr>
                            <tr><td>10</td><td>10</td></tr>
                            <tr><td>10, 11</td><td>11</td></tr>
                            <tr><td>10, 11, 12</td><td>12</td></tr>
                            <tr><td>...</td><td>...</td></tr>
                            <tr><td>10, 11, 12, 13, ..., 100</td><td>100</td></tr>
                            <tr><td>10, 11, 12, 13, ..., 100</td><td>empty</td></tr>
                        </table>
                    </details>
                </li>

                <li>RECURSIVE 연산은 계층 구조나 트리 형태의 데이터에 유용하다.</li>
                WITH RECURSIVE search_graph(id, link, data, depth) AS (<br>
                　　SELECT g.id, g.link, g.data, 1 FROM graph g<br>
                　UNION ALL<br>
                　　SELECT g.id, g.link, g.data, sg.depth + 1 FROM graph g, search_graph sg WHERE g.id = sg.link<br>
                ) SELECT * FROM search_graph;
            </ol>
        </details>

        <details>
            <summary>Data-Modifying Statements in WITH</summary>
            INSERT, UPDATE, DELETE를 WITH과 함께 사용할 수 있다.<br>
            <br>
            WITH moved_rows AS ( DELETE FROM products WHERE isnert_datetime < '2010-11-01' RETURNING * )<br>
            INSERT INTO products_log SELECT * FROM moved_rows;
        </details>
    </details>
</details>

<hr>

<details>
    <summary>Data Types</summary>
    <details>
        <summary>Numeric Types</summary>
        <table class="table">
            <thead>
                <tr><th>Name</th><th>Size</th><th>Description</th></tr>
            </thead>
            <tbody>
                <tr><td>smallint, int2</td><td>2 bytes</td><td>signed integer</td></tr>
                <tr><td>integer, int, int4</td><td>4 bytes</td><td>signed integer</td></tr>
                <tr><td>bigint, int8</td><td>8 bytes</td><td>signed integer</td></tr>
                <tr><td>decimal(p, s), numeric(p, s)</td><td>variable</td><td>임의 개수의 유효숫자와 소수 정밀도를 가진 10진수</td></tr>
                <tr><td>real, float4</td><td>4 bytes</td><td>IEEE 754 단일 정밀도 부동소수(최소 유효숫자 6자리)</td></tr>
                <tr><td>double precision, float8</td><td>8 bytes</td><td>IEEE 754 배 정밀도 부동소수(최소 유효숫자 15자리)</td></tr>
                <tr><td>smallserial, serial2</td><td>2 bytes</td><td>자동 증가 정수</td></tr>
                <tr><td>serial, serial4</td><td>4 bytes</td><td>자동 증가 정수</td></tr>
                <tr><td>bigserial, serial8</td><td>8 bytes</td><td>자동 증가 정수</td></tr>
            </tbody>
        </table>
        <ul>
            <li>decimal, numeric</li>
            <ol>
                <li>p(precision) : 유효숫자 수</li>
                
                <li>s(scale) : 소수 정밀도</li>
                예. 3.141592의 precision = 7, scale = 6.<br>
                정수는 scale = 0인 numeric으로 간주해도 무방
                
                <li>NUMERIC(precision) : scale = 0</li>
                
                <li>NUMERIC : 임의 유효숫자, 소수 정밀도의 10진수 모두 저장 가능</li>
                무한히 큰 수를 지원하진 않는다. 소수점 전 131072 자리, 소수점 후 16383 자리까지 지원.

                <li>'NaN' 상수 지원</li>
                'NaN'에 대한 연산 결과는 'NaN'

                <li>Rounding mode</li>
                numeric 타입의 반올림은 0에서 멀어지는 방향으로 이루어진다.
            </ol>

            <li>real, double precision</li>
            'NaN', 'Infinity', '-Infinity' 상수 지원

            <li>serial</li>
            serial 타입은 1부터 시작하여 자동으로 1씩 증가하는 정수에 대한 표현 편의를 제공한다. 9.6 버전에서는 sequence를 이용함으로써 구현한다.
        </ul>
    </details>

    <details>
        <summary>Character Types</summary>
        <table class="table">
            <thead>
                <tr><th>Name</th><th>Description</th></tr>
            </thead>
            <tbody>
                <tr><td>character [ (n) ], char [ (n) ]</td><td>고정 길이(n) 문자열. 스페이스가 덧붙여진다.</td></tr>
                <tr><td>character varying [ (n) ], varchar [ (n) ]</td><td>가변 길이(최대 n) 문자열</td></tr>
                <tr><td>text</td><td>가변 길이 문자열</td></tr>        
            </tbody>
        </table>
    </details>

    <details>
        <summary>Binary Data Type : bytea</summary>
        <ol>
            <li>로캐일에 의존하지 않는 이진 문자열을 표현한다</li>
            <li>bytea의 출력에는 'hex', 'escape' 두 가지 방식(bytea_output)이 있으며, 기본값은 'hex'로 설정되어 있다.</li>
            hex : 각 바이트를 16진수 2자리로 표현. 예. '\xDEADBEEF'<br>
            escape : 출력 가능 아스키 문자(32 ~ 126)는 있는 그대로, 백슬래시는 \\, 그 외는 \xxx로 표현한다. 예. 'abc klm *\251T'
        </ol>
    </details>

    <details>
        <summary>Date/Time Types</summary>
        <table class="table">
            <thead>
                <tr><th>Name</th><th>Size</th><th>Description</th><td>Range</td><td>Resolution</td></tr>
            </thead>
            <tbody>
                <tr><td>timestamp [ (p) ] [ without time zone ]</td><td>8 bytes</td><td>date and time (no time zone)</td><td>4713 BC ~ 294276 AD</td><td>1μs</td></tr>
                <tr><td>timestamp [ (p) ] with time zone, timestamptz</td><td>8 bytes</td><td>date and time, including time zone</td><td>4713 BC ~ 294276 AD</td><td>1μs</td></tr>
                <tr><td>date</td><td>4 bytes</td><td>date</td><td>4713 BC ~ 5874897 AD</td><td>1 day</td></tr>
                <tr><td>interval [ fields ] [ (p) ]</td><td>16 bytes</td><td>time span</td><td>-178000000 years ~ 178000000 years</td><td>1μs</td></tr>
                <tr><td>time [ (p) ] [ without time zone ]</td><td>8 bytes</td><td>time of day (no time zone)</td><td>00:00:00 ~ 24:00:00</td><td>1μs</td></tr>
                <tr><td>time [ (p) ] with time zone, timetz</td><td>12 bytes</td><td>time of day, with time zone</td><td>00:00:00+1459 ~ 24:00:00-1459</td><td>1μs</td></tr>
            </tbody>
        </table>
        <ul>
            <li>p</li>
            초 단위 소수 precision. 0 ~ 6까지 가능하며, 기본값은 없다(설정되지 않은 상태).

            <li>interval field</li>
            YEAR, MONTH, DAY, HOUR, MINUTE, SECOND, YEAR TO MONTH, DAY TO HOUR, DAY TO MINUTE, DAY TO SECOND, HOUR TO MINUTE, HOUR TO SECOND, MINUTE TO SECOND

            <li>Special Date/Time Input String</li>
            <table class="table">
                <thead>
                    <tr><th>String</th><th>Valid Types</th><th>Description</th></tr>
                </thead>
                <tbody>
                    <tr><td>epoch</td><td>date, timestamp</td><td>1970-01-01 00:00:00+00 (Unix system time zero)</td></tr>
                    <tr><td>infinity</td><td>date, timestamp</td><td>later than all other time stamps</td></tr>
                    <tr><td>-infinity</td><td>date, timestamp</td><td>earlier than all other time stamps</td></tr>
                    <tr><td>now</td><td>date, time, timestamp</td><td>	current transaction's start time</td></tr>
                    <tr><td>today</td><td>date, timestamp</td><td>midnight today</td></tr>
                    <tr><td>tomorrow</td><td>date, timestamp</td><td>midnight tomorrow</td></tr>
                    <tr><td>yesterday</td><td>date, timestamp</td><td>midnight yesterday</td></tr>
                    <tr><td>allballs</td><td>time</td><td>00:00:00.00 UTC</td></tr>
                </tbody>
            </table>
        </ul>
    </details>
    
    <details>
        <summary>boolean, bool</summary>    
        <ol>
            <li>TRUE, 't', 'true', 'y', 'yes', 'on', '1'</li>
            <li>FALSE, 'f', 'false', 'n', 'no', 'off', '0'</li>
        </ol>
    </details>

    <details>
        <summary>Enumerated Types</summary>
        CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy'); // 대소문자 구분한다
    </details>

    <details>
        <summary>Geometric Types</summary>
        <table class="table">
            <thead><th>Name</th><th>Size</th><th>Description</th><th>Representation</th></thead>
            <tbody>
                <tr><td>point</td><td>16 bytes</td><td>xy 좌표계 상의 점</td><td>(x, y)</td></tr>
                <tr><td>line</td><td>32 bytes</td><td>직선</td><td>{A, B, C} // Ax + By + C = 0<br>또는 직선 상의 두 점을 콤마로 구분하여 제공</td></tr>
                <tr><td>lseg</td><td>32 bytes</td><td>선분</td><td>((x1, y1), (x2, y2))</td></tr>
                <tr><td>box</td><td>32 bytes</td><td>모든 변이 축과 평행한 직사각형</td><td>((x1, y1), (x2, y2))</td></tr>
                <tr><td>path</td><td>16n bytes</td><td>Closed path</td><td>((x1, y1), ...)</td></tr>
                <tr><td>path</td><td>16n bytes</td><td>Open path</td><td>[(x1, y1), ...]</td></tr>
                <tr><td>polygon</td><td>40+16n bytes</td><td>Polygon</td><td>((x1, y1), ...)</td></tr>
                <tr><td>circle</td><td>24 bytes</td><td>Circle</td><td>&lt;(x, y), r&gt;</td></tr>
            </tbody>
        </table>
    </details>

    <details>
        <summary>JSON Types : json, jsonb</summary>
        <ul>
            <li>jsonb : 이진 포맷으로 저장하여 입력 시 조금 느리지만, 처리는 json보다 빠르다.</li>
            <li>배열 포함 여부 확인 예. SELECT '[1, 2, 3]'::jsonb @> '[3, 1]'::jsonb;</li>
            <li>배열 원소 존재 유무 확인 예. SELECT '["foo", "bar", "baz"]'::jsonb ? 'bar';</li>
            <li>key의 존재 유무 확인 예. SELECT '{"foo": "bar"}'::jsonb ? 'foo';</li>
            <li>key로 접근 예. select '{"key":"value"}'::jsonb -> 'key';</li>
        </ul>
    </details>

    <details>
        <summary>Array</summary>
        <ol>
            <li>배열 타입 정의</li>
            PostgreSQL은 배열 크기를 제한하지 않는다.<br>
            create table test( nums integer[] );<br>
            create table test( nums integer ARRAY );<br>
            create table test( matrix integer[][] );

            <li>배열 표현</li>
            insert into test values( '{1, 2, 3, 4}'::int[] ); // insert시엔 ::int[]같은 캐스팅 생략 가능<br>
            insert into test values( ARRAY[[1, 2], [3, 4]] ); // 배열 생성자는 애초에 배열을 반환하므로 캐스팅 불필요

            <li>배열 참조</li>
            <ul>
                <li>원소 참조 arr[idx]</li>

                <li>슬라이스 arr[start : end]</li>
                슬라이스의 경우 모든 차원이 슬라이스한다고 간주된다. arr[1:2][2]는 arr[1:2][1:2]와 같다.
                
                <li>배열 차원 반환 array_dims()</li>

                <li>지정된 차원에 대해 배열 크기 반환 array_length()</li>

                <li>전체 원소 수 반환 cardinality()</li>

                <li>현재 배열 크기보다 큰 인덱스에 값을 할당하는 경우, 중간은 null로 채워진다.</li>

                <li>배열 연결</li>
                연산자 || : n차원 배열과 n차원 배열의 연결 또는 n차원 배열에 n-1차원 배열(값)을 추가해준다.<br>
                array_prepend() : 1차원 배열 앞에 원소를 추가한다.<br>
                array_append() : 1차원 배열 뒤에 원소를 추가한다.<br>
                array_cat() : 다차원 배열들에 대해 || 연산과 같은 작업을 한다. 단, 배열만 인자로 사용 가능하다. 0차원 값은 안 된다.
            </ul>

            <li>배열 검색</li>
            <ul>
                <li>배열의 원소 중 하나라도 100 : SELECT ... WHERE 100 = ANY(arr);</li>
                <li>배열의 원소 모두가 100 : SELECT ... WHERE 100 = ALL(arr);</li>
                <li>generate_subscripts() : 주어진 배열과 차원에 대해 subscript의 집합을 반환한다</li>
                <ul>
                    <li>SELECT generate_subscripts('{{"1,1","1,2"},{"2,1","2,2"},{"3,1","3,2"}}'::text[][], 1) AS s;</li>
                    1차원 subscripts → 1, 2, 3
                    <li>SELECT generate_subscripts('{{"1,1","1,2"},{"2,1","2,2"},{"3,1","3,2"}}'::text[][], 2) AS s;</li>
                    2차원 subscripts → 1, 2
                    <li>WITH arr AS (SELECT '{{"1,1","1,2"},{"2,1","2,2"},{"3,1","3,2"}}'::text[][] AS arr),<br>
                        dims AS (SELECT arr, s1, s2, arr[s1][s2] FROM arr, generate_subscripts(arr, 1) AS s1, generate_subscripts(arr, 2) AS s2)<br>
                        SELECT * FROM dims;</li>
                    배열 펼치기
                </ul>
            </ul>
        </ol>
    </details>

    <details>
        <summary>Composite Types</summary>
        <ol>
            <li>CREATE TYPE complex AS ( r float4, i float4 );</li>
            
            <li>테이블을 만들면 그와 동일한 이름의 타입이 생성된다.</li>
            CREATE TABLE m_item ( item_id int, name text );<br>
            CREATE TABLE t_user_item ( user_id bigint, item m_item, count int );
            
            <li>Literal composite value</li>
            포맷 : '( val1 , val2 , ... )'<br>
            INSERT INTO table_name (complex_column_name) VALUES((1.1,2.2));<br>

            <li>SET 바로 다음엔 괄호가 없어도 되지만, 등호 다음엔 필요하다.</li>
            UPDATE table_name SET complex_column.r = (complex_column).r + 1 WHERE ...;
        </ol>
    </details>

    <details>    
        <summary>Range Types</summary>
        <ol>
            <li>int4range — Range of integer</li>
            <li>int8range — Range of bigint</li>
            <li>numrange — Range of numeric</li>
            <li>tsrange — Range of timestamp without time zone</li>
            <li>tstzrange — Range of timestamp with time zone</li>
            <li>daterange — Range of date</li>
            <a role="button" target="_blank" class="btn btn-info btn-sm" href="http://postgresql.kr/docs/current/functions-range.html#RANGE-OPERATORS-TABLE">http://postgresql.kr/docs/current/functions-range.html#RANGE-OPERATORS-TABLE</a>
            <a role="button" target="_blank" class="btn btn-info btn-sm" href="http://postgresql.kr/docs/current/functions-range.html#RANGE-FUNCTIONS-TABLE">http://postgresql.kr/docs/current/functions-range.html#RANGE-FUNCTIONS-TABLE</a>
        </ol>
    </details>

    <details>
        <summary>Domain Types</summary>
        <ol>
            <li>기저 타입을 토대로 제약을 추가하여 새로 정의하는 타입</li>
            <li>CREATE DOMAIN non_negative_int AS integer CHECK (VALUE &gt;= 0);</li>
        </ol>
    </details>

    <details>
        <summary>Pseudo Types</summary>
        <table class="table">
            <thead>
                <tr><th>Name</th><th>Description</th></tr>
            </thead>
            <tbody>
                <tr><td>any</td><td>Indicates that a function accepts any input data type.</td></tr>
                <tr><td>anyelement</td><td>Indicates that a function accepts any data type</td></tr>
                <tr><td>anyarray</td><td>Indicates that a function accepts any array data type</td></tr>
                <tr><td>anynonarray</td><td>Indicates that a function accepts any non-array data type</td></tr>
                <tr><td>anyenum</td><td>Indicates that a function accepts any enum data type</td></tr>
                <tr><td>anyrange</td><td>Indicates that a function accepts any range data type</td></tr>
                <tr><td>cstring</td><td>Indicates that a function accepts or returns a null-terminated C string.</td></tr>
                <tr><td>internal</td><td>Indicates that a function accepts or returns a server-internal data type.</td></tr>
                <tr><td>language_handler</td><td>A procedural language call handler is declared to return language_handler.</td></tr>
                <tr><td>fdw_handler</td><td>A foreign-data wrapper handler is declared to return fdw_handler.</td></tr>
                <tr><td>index_am_handler</td><td>An index access method handler is declared to return index_am_handler.</td></tr>
                <tr><td>tsm_handler</td><td>A tablesample method handler is declared to return tsm_handler.</td></tr>
                <tr><td>record</td><td>Identifies a function taking or returning an unspecified row type.</td></tr>
                <tr><td>trigger</td><td>A trigger function is declared to return trigger.</td></tr>
                <tr><td>event_trigger</td><td>An event trigger function is declared to return event_trigger.</td></tr>
                <tr><td>pg_ddl_command</td><td>Identifies a representation of DDL commands that is available to event triggers.</td></tr>
                <tr><td>void</td><td>Indicates that a function returns no value.</td></tr>
                <tr><td>unknown</td><td>Identifies a not-yet-resolved type, e.g. of an undecorated string literal.</td></tr>
                <tr><td>opaque</td><td>An obsolete type name that formerly served many of the above purposes.</td></tr>
            </tbody>
        </table>
    </details>

    <details>
        <summary>기타 내장 자료형 표</summary>
        <table class="table">
            <thead>
                <tr><th>Name</th><th>Size</th><th>Description</th></tr>
            </thead>
            <tbody>
                <tr><td>money</td><td>8 bytes</td><td>고정 소수 표현을 이용하며, lc_monetary 설정에 따라 조정된다.</td></tr>
                <tr><td>cidr</td><td>7 or 19 bytes</td><td>IPv4 or IPv6 network address</td></tr>
                <tr><td>inet</td><td>7 or 19 bytes</td><td>IPv4 or IPv6 host address</td></tr>
                <tr><td>macaddr</td><td>6 bytes</td><td>MAC (Media Access Control) address</td></tr>
                <tr><td>macaddr8</td><td>8 bytes</td><td>MAC (Media Access Control) address (EUI-64 format)</td></tr>
                <tr><td>bit [ (n) ]</td><td>variable</td><td>fixed-length bit string</td></tr>
                <tr><td>bit varying [ (n) ], varbit [ (n) ]</td><td>variable</td><td>variable-length bit string</td></tr>
                <tr><td>tsquery</td><td>variable</td><td>text search query</td></tr>
                <tr><td>tsvector</td><td>variable</td><td>text search document</td></tr>
                <tr><td>uuid</td><td>variable</td><td>universally unique identifier; RFC 4122, ISO/IEC 9834-8:2005</td></tr>
                <tr><td>xml</td><td>variable</td><td>XML data</td></tr>
            </tbody>
        </table>
    </details>
</details>

<hr>

<details>
    <summary>Functions and Operations</summary>
    <details>
        <summary>Logical Operators</summary>
        <ol>
            <li>AND, OR, NOT</li>
            <li>TRUE, FALSE외에 NULL도 논리 상태로 이용한다</li>
            TRUE AND NULL = NULL, FALSE AND NULL = FALSE<br>
            TRUE OR NULL = TRUE, FALSE OR NULL = NULL<br>
            NULL AND NULL = NULL OR NULL = NOT NULL = NULL
        </ol>
    </details>

    <details>
        <summary>Comparison Functions and Operators</summary>
        <ol>
            <li>&lt;, &gt;, &lt;=, &gt;=, =, &lt;&gt; or !=</li>
            
            <li>a [NOT] BETWEEN x AND y</li>
            a [NOT] BETWEEN SYMMETRIC x AND y : x, y 대소관계를 판별하여 적절히 비교한다

            <li>a IS DISTINCT FROM b</li>
            a != b과 같지만 null을 일반적인 값으로 취급한다는 차이가 있다

            <li>expression IS [NOT] NULL</li>

            <li>boolean_expression IS [NOT] TRUE // FALSE, UNKNOWN</li>
        </ol>
    </details>

    <details>
        <summary>Mathematical Functions and Operators</summary>
        <ol>
            <li>+, -, *, /, %, @(절댓값)</li>
            <li>^(거듭제곱), |/(제곱근), ||/(삼중근), !(팩토리얼, 후위), !!(팩토리얼, 전위)</li>
            <li>비트 연산자 &, |, #(XOR), ~, &lt;&lt;, &gt;&gt;</li>
            <li>abs(x), sqrt(x), cbrt(x), ceil(x), floor(x), exp(x), div(x, y), round(x, y), ...</li>
            <li>random() : x ∈ [0.0, 1.0), setseed(dp) : dp ∈ [-1.0, 1.0]</li>
        </ol>
    </details>

    <details>
        <summary>String Functions and Operators</summary>
        <ol>
            <li>문자열 연결 연산자 ||</li>
            비문자열도 피연산자 중 한쪽이 될 수 있다
            
        </ol>
    </details>

    <details>
            string || string                                        String concatenation
            string || non-string or non-string || string            String concatenation with one non-string input
            bit_length(string)                                      Number of bits in string
            char_length(string) or character_length(string)         Number of characters in string
            lower(string)                                           Convert string to lower case
            overlay(string placing string from int [for int])       Replace substring
            position(substring in string)                           Location of specified substring
            substring(string [from int] [for int])                  Extract substring
            substring(string from pattern)                          Extract substring matching POSIX regular expression
            substring(string from pattern for escape)               Extract substring matching SQL regular expression
            trim([leading | trailing | both] [characters] from string)
            
            chr(int)                                                Character with the given code. For UTF8 the argument is treated as a Unicode code point.
            concat(str "any" [, str "any" [, ...] ])
            concat_ws(sep text, str "any" [, str "any" [, ...] ])   Concatenate all but the first argument with separators
            encode(data bytea, format text)                         base64, hex, escape. escape
            decode(string text, format text)
            format(formatstr text [, formatarg "any" [, ...] ])
            length(string)
            length(string bytea, encoding name )
            lpad(string text, length int [, fill text])
            ltrim(string text [, characters text])
            md5(string)
                - http://postgresql.kr/docs/9.6/functions-string.html
            
            
            10.5 Pattern matching
            10.5.1 LIKE
            string LIKE pattern [ESCAPE escape-character]
            string NOT LIKE pattern [ESCAPE escape-character]
            
            'abc' LIKE 'abc'    true
            'abc' LIKE 'a%'     true
            'abc' LIKE '_b_'    true
            'abc' LIKE 'c'      false
            
            10.5.2 SIMILAR TO
            | : or
            * : 0 or more
            + : 1 or more
            ? : 0 or 1
            {m} : exactly m times
            {m, } : m or more
            {m, n} : m~n times
            () : 하나의 논리적 항목으로 그루핑
            [] : 집합 원소 중 하나
            
            'abc' SIMILAR TO 'abc'      true
            'abc' SIMILAR TO 'a'        false
            'abc' SIMILAR TO '%(b|d)%'  true
            'abc' SIMILAR TO '(b|c)%'   false
            
            10.5.3 POSIX
            ~ : case sensitive match
            ~* : case insensitive match
            !~ : case sensitive 'not' match
            !~* : case insensitive 'not' match
            
            'abc' ~ 'abc'    true
            'abc' ~ '^a'     true
            'abc' ~ '(b|d)'  true
            'abc' ~ '^(b|c)' false
            
            *?	    non-greedy version of *
            +?	    non-greedy version of +
            ??	    non-greedy version of ?
            {m}?	non-greedy version of {m}
            {m,}?	non-greedy version of {m,}
            {m,n}?	non-greedy version of {m,n}
            
            . : 임의 문자 하나
            [chars] : chars 문자 중 하나
            \c : c는 alphanumeric 문자. 이스케이프
                \a : alert character
                \b : backspace
                \B : \\
                \cX : X는 임의 문자. 하위 5개 비트가 같고 나머지 비트가 모두 0
                ...
                \uwxyz : 16진수 4개
                \xy : 8진수 2개
                ...
                \d : [[:digit:]]
                \s : [[:space:]]
                \w : [[:alnum:]_] // underscore included
                \D : [^[:digit:]]
                \S : [^[:space:]]
                \W : [^[alnum:]_] // underscore included
                ...
                \A : 문자열 앞부분 매칭
                \m : 단어 앞 매칭
                \M : 단어 끝 매칭
                \y : 단어 앞 또는 뒤 매칭
                \Y : not \y
                \Z : 문자열 끝 매칭
                ...
                \m : m은 nonzero digit. m'th 표현식 참조
            \k : k는 non-alphanumeric 문자. 문자 k 자체 매칭.
            x : 문자 x 자체 매칭.
            
            - ARE Embedded-option Letters
            b	rest of RE is a BRE
            c	case-sensitive matching (overrides operator type)
            e	rest of RE is an ERE
            i	case-insensitive matching (see 9.7.3.5절) (overrides operator type)
            m	historical synonym for n
            n	newline-sensitive matching (see 9.7.3.5절)
            p	partial newline-sensitive matching (see 9.7.3.5절)
            q	rest of RE is a literal ("quoted") string, all ordinary characters
            s	non-newline-sensitive matching (default)
            t	tight syntax (default; see below)
            w	inverse partial newline-sensitive ("weird") matching (see 9.7.3.5절)
            x	expanded syntax (see below)
            
            10.6 JSON Functions and Operators
            Operator	Right Operand Type	Description	                                                                        Example	                                            Example Result
            ->	        int	                Get JSON array element (indexed from zero, negative integers count from the end)	'[{"a":"foo"},{"b":"bar"},{"c":"baz"}]'::json->2	{"c":"baz"}
            ->	        text	            Get JSON object field by key	                                                    '{"a": {"b":"foo"}}'::json->'a'	                    {"b":"foo"}
            ->>	        int	                Get JSON array element as text	                                                    '[1,2,3]'::json->>2	                                3
            ->>	        text	            Get JSON object field as text	                                                    '{"a":1,"b":2}'::json->>'b'	                        2
            #>	        text[]	            Get JSON object at specified path	                                                '{"a": {"b":{"c": "foo"}}}'::json#>'{a,b}'	        {"c": "foo"}
            #>>	        text[]	            Get JSON object at specified path as text	                                        '{"a":[1,2,3],"b":[4,5,6]}'::json#>>'{a,2}'	        3
            http://postgresql.kr/docs/9.6/functions-json.html
    </details>
</details>

<hr>

<details>
    <summary>Type Conversion</summary>
    <ol>

    </ol>
</details>

<hr>

<details>
    <summary>Indexes</summary>
    <ol>

    </ol>
</details>

<hr>

<details>
    <summary>Full Text Search</summary>
    <ol>

    </ol>
</details>

<hr>

<details>
    <summary>동시성 제어</summary>
    <ol>

    </ol>
</details>

<hr>

<details>
    <summary>Performance Tips</summary>
    <ol>

    </ol>
</details>

<hr>

<details>
    <summary>병렬 쿼리</summary>
    <ol>

    </ol>
</details>

<hr>