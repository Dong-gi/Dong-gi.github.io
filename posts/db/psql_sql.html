<hr>

<details>
    <summary>SQL Syntax</summary>
    <details>
        <summary>Lexical Structure</summary>
        <ol>
            <li>식별자와 키워드</li>
            select라는 이름의 컬럼을 가져오려면 select "select" from table_name;처럼 이용한다. 그로지 말자...
            <ul>
                <li>select, from : 키워드</li>
                <li>"select" : ""로 감싼 식별자. U&"d\0061t\+000061"처럼 유니코드 코드 포인트를 이용할 수 있다.</li>
                <li>table_name : Unquoted 식별자. 대소문자를 구별하지 않는다.</li>
            </ul>

            <li>상수</li>
            문자열 상수 : '문자열'<br>
            달러 인용 문자열 상수 : 달러 인용 문자열은 이스케이프되지 않는다.<br>
            예1. $$Dianne's horse$$, $SomeTag$Dianne's horse$SomeTag$<br>
            예2. CREATE OR REPLACE FUNCTION change_inaba_name() RETURNS TRIGGER AS $$<br>
            BEGIN<br>
            　　NEW.status_text = REPLACE(NEW.status_text, 'イナバ', '이나바');<br>
            　　RETURN NEW;<br>
            END;<br>
            $$ LANGUAGE plpgsql;
        </ol>
    </details>

    <details>
        <summary>Value Expressions</summary>
        <ol>
            <li>열 참조</li>
            correlation.columnname // correlation은 테이블 이름이나 alias

            <li>위치 매개변수</li>
            함수 정의의 매개변수 위치를 이용해 변수 참조<br>
            예. 문자열을 2번 반복해서 반환하는 함수<br>
            CREATE OR REPLACE FUNCTION test(text) RETURNS text AS $body$ SELECT $1 || $1 $body$ LANGUAGE sql;
        
            <li>배열 요소 참조</li>
            expression[subscript] // subscript는 integer 값을 내는 표현식
            expression[lower_subscript:upper_subscript]

            <li>필드 선택</li>
            expression.fieldname : 특정 행의 열 참조 // expression은 row type 또는 열집합<br>
            일반적으로 expression은 괄호로 감싸져야 하지만, 테이블이나 위치 매개변수의 경우 생략할 수 있다.<br>
            .*로 모든 필드를 얻을 수 있다.

            <li>
                <details>
                    <summary>집계 함수 호출</summary>
                    <ul>
                        <li>집계 함수(aggregate function)란 여러 입력 행들을 하나의 결과행으로 줄이는 함수.</li>
                        <li>집계 함수의 형태</li>
                        <ul>
                            <li>aggregate_name (expression [ , ... ] [ order_by_clause ] ) [ FILTER ( WHERE filter_clause ) ] -- default로 ALL이므로 2번째와 동일</li>
                            <li>aggregate_name (ALL expression [ , ... ] [ order_by_clause ] ) [ FILTER ( WHERE filter_clause ) ]</li>
                            <li>aggregate_name (DISTINCT expression [ , ... ] [ order_by_clause ] ) [ FILTER ( WHERE filter_clause ) ]</li>
                            <li>aggregate_name ( * ) [ FILTER ( WHERE filter_clause ) ] -- 보통 count에서만 사용되는 형태</li>
                            <li>aggregate_name ( [ expression [ , ... ] ] ) WITHIN GROUP ( order_by_clause ) [ FILTER ( WHERE filter_clause ) ]</li>
                            <li>위의 expression은 집계 함수나 윈도우 함수 호출을 포함하지 않아야 한다.</li>
                            <li>복수의 인자를 받는 집계 함수에서는 ORDER BY 절이 전체 인자가 끝나고 등장해야 한다.</li>
                            SELECT string_agg(str, ',' ORDER BY str) FROM table;
                        </ul>
                        <li>SELECT count(*) AS unfiltered, count(*) FILTER (WHERE num < 5) AS filtered FROM generate_series(1,10) AS num;</li>
                        <li>내장 집계 함수 : <a role="button" target="_blank" class="btn btn-info btn-sm" href="http://postgresql.kr/docs/9.6/functions-aggregate.html">http://postgresql.kr/docs/9.6/functions-aggregate.html</a></li>
                    </ul>            
                </details>
            </li>
            
            <li>
                <details>
                    <summary>윈도우 함수 호출</summary>
                    <ul>
                        <li>윈도우 함수는 집계 함수와 비슷하지만, 입력 행들이 결과에 그대로 나타난다.</li>
                        <li>윈도우 함수의 형태</li>
                        <ul>
                            <li>function_name ([expression [, expression ... ]]) [ FILTER ( WHERE filter_clause ) ] OVER window_name</li>
                            <li>function_name ([expression [, expression ... ]]) [ FILTER ( WHERE filter_clause ) ] OVER ( window_definition )</li>
                            <li>function_name ( * ) [ FILTER ( WHERE filter_clause ) ] OVER window_name</li>
                            <li>function_name ( * ) [ FILTER ( WHERE filter_clause ) ] OVER ( window_definition )</li>
                        
                            <li>window_name은 WINDOW 절로 정의된 윈도우 이름.</li>
                            OVER window_name과 OVER (window_name)은 다르다. 후자의 경우 윈도우 정의를 복사하여 적용하며, frame 절을 포함하는 경우 수행되지 않는다.
                        
                            <li>window_definition</li>
                            [ existing_window_name ]<br>
                            [ PARTITION BY expression [, ...] ]<br>
                            [ ORDER BY expression [ ASC | DESC | USING operator ] [ NULLS { FIRST | LAST } ] [, ...] ]<br>
                            [ frame_clause ]<br>
                            <br>
                            PARTITION BY 옵션은 행 그룹을 만든다. GROUP BY와 달리 출력-열이나 숫자를 지정할 수 없다.<br>
                            ORDER BY 절도 마찬가지로 출력-열이나 숫자를 지정할 수 없다.
                        
                            <li>frame_clause</li>
                            <ol>
                                <li>{ RANGE | ROWS } frame_start -- default로 frame_end는 CURRENT ROW</li>
                                <li>{ RANGE | ROWS } BETWEEN frame_start AND frame_end</li>
                            </ol>
                            frame_clause는 윈도우 함수가 전체 파티션이 아닌, 현재까지의 파티션을 대상으로 계산을 수행하게 한다.<br>
                            UNBOUNDED PRECEDING으로 지정된 frame_start는 파티션의 첫 행, UNBOUNDED FOLLOWING으로 지정된 frame_end는 파티션 마지막 행을 의미한다.
                        
                            <li>frame_start, frame_end</li>
                            <ol>
                                <li>UNBOUNDED PRECEDING</li>
                                <li>value PRECEDING</li>
                                <li>CURRENT ROW</li>
                                <li>value FOLLOWING</li>
                                <li>UNBOUNDED FOLLOWING</li>
                            </ol>
                            value PRECEDING, FOLLOWING은 ROWS 모드에서만 사용 가능하고, 현재 행을 전후로 하여 프레임 크기를 설정한다.
                        
                            <li>frame_exclusion</li>
                            <ol>
                                <li>EXCLUDE CURRENT ROW</li>
                                <li>EXCLUDE GROUP</li>
                                <li>EXCLUDE TIES</li>
                                <li>EXCLUDE NO OTHERS</li>
                            </ol>
                        
                            <li>expression은 윈도우 함수 호출을 포함하지 않아야 한다.</li>
                        </ul>
                    
                        <li>내장 윈도우 함수 : <a role="button" target="_blank" class="btn btn-info btn-sm" href="http://postgresql.kr/docs/9.6/functions-window.html#FUNCTIONS-WINDOW-TABLE">http://postgresql.kr/docs/9.6/functions-window.html#FUNCTIONS-WINDOW-TABLE</a></li>
                    </ul>
                </details>
            </li>
            
            <li>
                <details>
                    <summary>Collation Expressions</summary>
                    예. 로캐일에 따른 정렬
                    <ul>
                        <li>SELECT * FROM tbl WHERE ... ORDER BY a COLLATE "C"; // 결과 정렬</li>
                        <li>SELECT * FROM tbl WHERE a &gt; 'foo' COLLATE "C"; // 입력 정렬</li>
                        <li>SELECT * FROM tbl WHERE a COLLATE "C" &gt; 'foo'; // 입력 정렬</li>
                        <li>SELECT * FROM tbl WHERE (a &gt; 'foo') COLLATE "C"; // 에러. 연산 결과인 boolean은 non-collatable</li>
                    </ul>

                    LC_COLLATE를 설정하여 기본적으로 로캐일에 따른 정렬을 수행
                    <ol>
                        <li>데이터베이스 최초 생성 시 LC_COLLATE 변수 값을 'C'로 설정</li>
                        <li>기존 데이터베이스를 dump하고, LC_COLLATE를 'C'로 설정한 데이터베이스를 만들어 복구</li>
                        db_name=# DROP DATABASE [db_name];<br>
                        db_name=# CREATE DATABASE [db_name] LC_COLLATE 'C';<br>
                        -- 데이터베이스는 생성될 때 기본적으로 template1 데이터베이스를 복제하여 생성된다. 하지만 이는 로캐일이 이미 설정되어 충돌하여 에러가 발생할 수 있다.<br>
                        db_name=# CREATE DATABASE [db_name] TEMPLATE template0 LC_COLLATE 'C';
                    </ol>
                </details>
            </li>

            <li>Scalar Subqueries</li>
            한 행 또는 한 컬럼을 반환하는, 괄호에 감싸인 SELECT 쿼리<br>
            SELECT name, (SELECT max(pop) FROM cities WHERE cities.state = states.name) FROM states;
            
            <li>
                <details>
                    <summary>배열 생성자</summary>
                    SELECT ARRAY[1,2,3+4];<br>
                    SELECT ARRAY[1,2,22.7]::integer[];<br>
                    SELECT ARRAY[]::integer[]; // 빈 배열도 형식은 필요<br>
                    SELECT ARRAY[ARRAY[1,2], ARRAY[3,4]];<br>
                    SELECT ARRAY(SELECT oid FROM pg_proc WHERE proname LIKE 'bytea%');<br>
                    <br>
                    CREATE TABLE arr(f1 int[], f2 int[]);<br>
                    INSERT INTO arr VALUES (ARRAY[[1,2],[3,4]], ARRAY[[5,6],[7,8]]);
                </details>
            </li>

            <li>
                <details>
                    <summary>행 생성자</summary>
                    SELECT ROW(1,2.5,'this is a test');<br>
                    SELECT ROW(t.*, 42) FROM t; // t는 행 값<br>
                    예. SELECT ROW(t.*, 42) FROM (SELECT ROW(1,2.5,'this is a test')) as t;<br>
                    <br>
                    CREATE TABLE mytable(f1 int, f2 float, f3 text);<br>
                    CREATE OR REPLACE FUNCTION getf1(mytable) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;<br>
                    -- No cast needed since only one getf1() exists<br>
                    SELECT getf1(ROW(1,2.5,'this is a test'));<br>
                    CREATE TYPE myrowtype AS (f1 int, f2 text, f3 numeric);<br>
                    CREATE OR REPLACE FUNCTION getf1(myrowtype) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;<br>
                    -- Now we need a cast to indicate which function to call:<br>
                    SELECT getf1(ROW(1,2.5,'this is a test')::mytable);<br>
                    SELECT getf1(CAST(ROW(11,'this is a test',2.5) AS myrowtype));
                </details>
            </li>

            <li>Expression Evaluation Rules</li>
            <ul>
                <li>SELECT true OR somefunc();와 SELECT somefunc() OR ture; 모두 somefunc()가 호출되지 않는다. short-circuit 연산과 다르다.</li>
                <li>SELECT ... WHERE CASE WHEN x &gt; 0 THEN y/x &gt; 1.5 ELSE false END;</li>
                <li>SELECT CASE WHEN x &gt; 0 THEN x ELSE 1/0 END FROM tab;</li>
                주의. IMMUTABLE 함수는 값이 먼저 평가되기 때문에, 실제로 x가 항상 0보다 크더라도 1/0이 미리 평가되어 에러가 발생한다.
                <a role="button" target="_blank" class="btn btn-info btn-sm" href="http://postgresql.kr/docs/current/xfunc-volatility.html">http://postgresql.kr/docs/current/xfunc-volatility.html</a>
            </ul>
        </ol>
    </details>
            
    <details>
        <summary>함수 호출</summary>
        PostgreSQL의 함수의 인자는 이름과 위치 둘 다로 참조할 수 있다.<br>
        CREATE FUNCTION concat_lower_or_upper(a text, b text, uppercase boolean DEFAULT false) RETURNS text AS $$<br>
        　　SELECT CASE<br>
        　　　　WHEN $3 THEN UPPER($1 || ' ' || $2)<br>
        　　　　ELSE LOWER($1 || ' ' || $2)<br>
        　　END;<br>
        $$ LANGUAGE SQL IMMUTABLE STRICT;
        
        <ul>
            <li>Using Positional Notation</li>
            SELECT concat_lower_or_upper('Hello', 'World');
            
            <li>Using Named Notation</li>
            SELECT concat_lower_or_upper(a =&gt; 'Hello', b =&gt; 'World');
            
            <li>Using Mixed Notation</li>
            키워드 인자는 나머지보다 뒤에 위치해야 한다.<br>
            SELECT concat_lower_or_upper('Hello', 'World', uppercase =&gt; true);
        </ul>
    </details>
</details>

<hr>

<details>
    <summary>Data Definition</summary>
    <details>
        <summary>Default Values</summary>
        기본값으로 표현식을 사용할 수 있다. 가장 흔히 쓰이는 것은 timestamp 열이 CURRENT_TIMESTAMP 값을 갖게 하는 것.<br>
        CREATE TABLE products (<br>
        　　product_no integer DEFAULT nextval('products_product_no_seq'),<br>
        　　...<br>
        );<br>
    </details>

    <details>
        <summary>Constraints</summary>
        <ol>
            <li>
                <details>
                    <summary>Check Constraints</summary>
                    CREATE TABLE products ( product_no integer, price numeric CHECK (price &gt; 0) );<br>
                    <br>
                    식별자를 줄 수 있다.<br>
                    CREATE TABLE products ( product_no integer, price numeric CONSTRAINT positive_price CHECK (price &gt; 0) );<br>
                    <br>
                    여러 열을 체크할 수 있다.<br>
                    CREATE TABLE products (<br>
                    　　product_no integer,<br>
                    　　name text,<br>
                    　　price numeric CHECK (price &gt; 0),<br>
                    　　discounted_price numeric CHECK (discounted_price &gt; 0), CHECK (price &gt; discounted_price)<br>
                    );<br>
                    <br>
                    열 삽입 제약 조건을 테이블 제약 조건으로 사용할 수 있다.<br>
                    CREATE TABLE products (<br>
                    　　product_no integer,<br>
                    　　name text,<br>
                    　　price numeric CHECK (price &gt; 0),<br>
                    　　discounted_price numeric,<br>
                    　　CHECK (discounted_price &gt; 0 AND price &gt; discounted_price)<br>
                    );
                </details>
            </li>

            <li>Not-Null Constraints</li>
            CREATE TABLE products ( product_no integer NOT NULL, price numeric );

            <li>Unique Constraints</li>
            CREATE TABLE products ( product_no integer UNIQUE, price numeric );<br>
            CREATE TABLE products ( product_no integer, price numeric, UNIQUE (product_no) );<br>
            CREATE TABLE example ( a integer, b integer, c integer, UNIQUE (a, c) );<br>
            <br>
            식별자를 부여할 수 있다.<br>
            CREATE TABLE products ( product_no integer CONSTRAINT must_be_different UNIQUE, price numeric );

            <li>Primary Keys</li>
            CREATE TABLE example ( a integer, b integer, c integer, PRIMARY KEY (a, c) );

            <li>
                <details>
                    <summary>Foreign Keys</summary>
                    CREATE TABLE orders (<br>
                    　　order_id integer PRIMARY KEY,<br>
                    　　product_no integer REFERENCES products (product_no),<br>
                    　　quantity integer<br>
                    );<br>
                    <br>
                    CREATE TABLE t1 (<br>
                    　　a integer PRIMARY KEY,<br>
                    　　b integer,<br>
                    　　c integer,<br>
                    　　FOREIGN KEY (b, c) REFERENCES other_table (c1, c2)<br>
                    );<br>
                    <br>
                    외래키와 기본키 혼용<br>
                    CREATE TABLE order_items (<br>
                    　　product_no integer REFERENCES products,<br>
                    　　order_id integer REFERENCES orders,<br>
                    　　quantity integer,<br>
                    　　PRIMARY KEY (product_no, order_id)<br>
                    );
                </details>
            </li>

            <li>무결성 제약 : ON DELETE, ON UPDATE에 사용</li>
            CREATE TABLE order_items (<br>
            　　product_no integer REFERENCES products ON DELETE RESTRICT, -- 참조하는 행이 삭제되지 않음.<br>
            　　order_id integer REFERENCES orders ON DELETE CASCADE, -- 참조하는 행이 삭제되면 같이 삭제됨.<br>
            　　quantity integer,<br>
            　　PRIMARY KEY (product_no, order_id)<br>
            );
        </ol>
    </details>
    
    <details>
        <summary>System Columns</summary>
        oid : object_id. 테이블을 WITH OIDS로 생성하거나, default with oids이 설정된 경우 생성되는 열. 타입 이름도 oid.<br>
        <a role="button" target="_blank" class="btn btn-info btn-sm" href="http://postgresql.kr/docs/9.6/ddl-system-columns.html">http://postgresql.kr/docs/9.6/ddl-system-columns.html</a>
    </details>
    
    <details>
        <summary>Modifying Tables</summary>
        <ol>
            <li>Adding a Column</li>
            ALTER TABLE products ADD COLUMN description text;<br>
            ALTER TABLE products ADD COLUMN description text CHECK (description != '');

            <li>Removing a Column</li>
            ALTER TABLE products DROP COLUMN description;<br>
            <br>
            외래키로 참조중인 경우, 제약을 명시해줘야 반영된다.<br>
            ALTER TABLE products DROP COLUMN description CASCADE;

            <li>Adding a Constraint</li>
            ALTER TABLE products ADD CHECK (name != '');<br>
            ALTER TABLE products ADD CONSTRAINT some_name UNIQUE (product_no);<br>
            ALTER TABLE products ADD FOREIGN KEY (product_group_id) REFERENCES product_groups;<br>
            ALTER TABLE products ALTER COLUMN product_no SET NOT NULL;

            <li>Removing a Constraint</li>
            ALTER TABLE products DROP CONSTRAINT some_name;<br>
            ALTER TABLE products ALTER COLUMN product_no DROP NOT NULL;

            <li>Changing a Column's Default Value</li>
            ALTER TABLE products ALTER COLUMN price SET DEFAULT 7.77;<br>
            ALTER TABLE products ALTER COLUMN price DROP DEFAULT;

            <li>Changing a Column's Data Type</li>
            ALTER TABLE products ALTER COLUMN price TYPE numeric(10,2);<br>
            기존 값이 새로운 타입으로 암묵적으로 변환된다면 위의 것으로 충분. 복잡한 변환을 명시하려면 USING 절을 추가 사용.

            <li>Renaming a Column</li>
            ALTER TABLE products RENAME COLUMN product_no TO product_number;

            <li>Renaming a Table</li>
            ALTER TABLE products RENAME TO items;
        </ol>
    </details>
    
    <details>
        <summary>Privileges</summary>
        권한 : SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER, CREATE, CONNECT, TEMPORARY, EXECUTE, USAGE &lt;&lt; ALL<br>
        GRANT UPDATE ON table_name TO username;<br>
        REVOKE ALL ON table_name FROM username;
    </details>
    
    <details>
        <summary>Row Security Policies</summary>
        예. 관리자 그룹에 속한 사용자가, 자신과 관련한 행만 접근<br>
        CREATE TABLE accounts (manager text, company text, contact_email text);<br>
        ALTER TABLE accounts ENABLE ROW LEVEL SECURITY;<br>
        CREATE POLICY account_managers ON accounts TO managers USING (manager = current_user);<br>
        <a role="button" target="_blank" class="btn btn-info btn-sm" href="http://postgresql.kr/docs/current/ddl-rowsecurity.html">http://postgresql.kr/docs/current/ddl-rowsecurity.html</a>
    </details>
    
    <details>
        <summary>Schemas</summary>
        CREATE SCHEMA myschema; -- Schema의 테이블은 schema.table 또는 database.schema.table로 접근<br>
        CREATE TABLE myschema.mytable ( ... );<br>
        <br>    
        DROP SCHEMA myschema;<br>
        DROP SCHEMA myschema CASCADE; -- 포함된 내용도 삭제<br>
        <br>
        모든 새 데이터베이스는 public이라는 스키마를 갖고 있다. 따라서 아래 두 문장은 서로 같다.<br>
        CREATE TABLE products ( ... );<br>
        CREATE TABLE public.products ( ... );
    </details>

    <details>
        <summary>Table Partitioning</summary>
        <ol>
            <li>개요</li>
            <ul>
                <li>Table partitioning : 논리적으로 하나인 거대한 테이블을 물리적으로 여러 개로 쪼개 저장하는 것.</li>
                <li>Range partitioning : 중복되지 않는 열 집합의 구간들로 분할</li>
                <li>List partitioning : 명시적인 키값 리스트로 분할</li>
                <li>Hash partitioning : 모듈로 n 공간에서 키값의 나머지가 같은 것들로 분할</li>
                <li>상속을 이용한 파티셔닝 : 자식 테이블은 추가적인 컬럼을 가질 수 있으며, 다중 상속도 가능하다.</li>
            </ul>

            <li>파티셔닝</li>
            CHECK, NOT NULL 제약 조건은 파티션 테이블에 상속된다. NO INHERIT 마킹된 CHECK 제약조건은 제외.<br>
            <br>
            예. create table api_access_log ( account_id int, access_time datetime, request_uri text ) partition by range(access_time);<br>
            create table api_access_log_201901 partition of api_access_log for values from ('2019-01-01') to ('2019-02-01');<br>
            <br>
            파티션 테이블을 파티셔닝할 수 있다.<br>
            create table api_access_log_201901 partition of api_access_log for values from ('2019-01-01') to ('2019-02-01') partition by range(account_id % 100);

            <li>주의</li>
            <ul>
                <li>값 변경으로 인해 행이 한 파티션에서 다른 파티션으로 이동되는 경우, 예약된 UPDATE, DELETE 작업이 실패할 수 있다.</li>
                <li>BEFORE ROW 트리거는 각 파티션 테이블에 따로 정의해야 한다.</li>
            </ul>

            <li>Partition Pruning</li>
            SET enable_partition_pruning = on;을 통해 옵션을 켤 수 있다. 켜 있는 게 디폴트.<br>
            가지치기 옵션이 켜있는 경우, 파티셔닝된 테이블의 정의(인덱스의 정의가 아니라)를 살펴, 스캔하지 않아도 되는 테이블들은 제외한다.<br>
            가지치기 시점 : 쿼리 플랜 초기화 시, 쿼리 플랜 실행 중(Append 노드 타입에 한하여)
        </ol>
    </details>
</details>

<hr>

<details>
    <summary>Data Manipulation</summary>
    <ol>
        <li>Inserting Data<br>
            Updating Data<br>
            Deleting Data</li>
        DB - PostgreSQL 시작하기 - SQL 언어 참고
            
        <li>Returning Data From Modified Rows</li>
        INSERT INTO users (firstname, lastname) VALUES ('Joe', 'Cool') RETURNING id;<br>
        UPDATE products SET price = price * 1.10 WHERE price <= 99.99 RETURNING name, price AS new_price;<br>
        DELETE FROM products WHERE obsoletion_date = 'today' RETURNING *;
    </ol>
</details>

<hr>

<details>
    <summary>Queries</summary>
    <details>
        <summary>Table Expressions</summary>
        <details>
            <summary>FROM 절</summary>
            <ol>
                <li>일반 : FROM table_reference [, table_reference [, ...]]</li>

                <li>Cartesian product(Cross join) : FROM T1 CROSS JOIN T2</li>
                또는 콤마로 구분 : FROM T1, T2

                <li>판별식을 이용한 조인 : FROM T1 { [INNER] | { LEFT | RIGHT | FULL } [OUTER] } JOIN T2 ON boolean_expression</li>
                판별식이 참일 경우에만 결과 행으로 반환된다.

                <li>컬럼 셋을 이용한 조인 : FROM T1 { [INNER] | { LEFT | RIGHT | FULL } [OUTER] } JOIN T2 USING ( join column list )</li>
                컬럼 셋이 일치하는 경우에만 결과 행으로 반환된다.

                <li>자연 조인 : FROM T1 NATURAL { [INNER] | { LEFT | RIGHT | FULL } [OUTER] } JOIN T2</li>
                두 테이블의 공통된 컬럼 리스트를 USING한 것과 동일한 결과를 산출한다.

                <li>테이블 별명 : FROM table_reference [AS] alias</li>
                셀프 조인을 위해선 필수적으로 사용된다. 모호함을 피하기 위해 괄호를 이용할 수도 있다. SELECT * FROM (my_table AS a CROSS JOIN my_table) AS b ...<br>
                컬럼에도 별명을 붙일 수 있다. FROM table_reference [AS] alias ( column1 [, column2 [, ...]] )

                <li>서브쿼리 사용을 위한 별명 : FROM (SELECT * FROM table1) AS alias</li>

                <li>Table function에 별명 사용</li>
                Table function : 행 집합을 반환하는 함수.<br>
                <br>
                CREATE TABLE foo (fooid int, foosubid int, fooname text);<br>
                CREATE FUNCTION getfoo(int) RETURNS SETOF foo AS $$ SELECT * FROM foo WHERE fooid = $1; $$ LANGUAGE SQL;<br>
                SELECT * FROM getfoo(1) AS t1;

                <li>LATERAL 서브쿼리 : 키워드 좌측의 테이블들을 참조할 수 있다</li>
                예, unknown_log 테이블로부터 각 로그의 첫 30글자, 삽입 시각, 로그 길이를 가져오기<br>
                SELECT substring(log.log, 1, 30), log.insert_datetime, len FROM unknown_log log LEFT JOIN LATERAL LENGTH(log.log) len ON true;<br>
                LEFT JOIN ON true == CROSS JOIN. 사실 LATERAL 빼도 잘 동작하며, 실제로 사용할 일이 있을진 모르겠음...<br>
            </ol>
        </details>

        <details>
            <summary>WHERE 절</summary>
            <li>GROUPING SETS, CUBE, ROLLUP</li>
            한 테이블에 대해 같은 조건으로 여러 그룹에 대해 SELECT해야하는 경우, 이를 한 번에 질의할 수 있다.
            SELECT brand, size, sum(sales) FROM items_sold GROUP BY GROUPING SETS ((brand), (size), ());
            → 브랜드별 판매량, 사이즈별 판매량, 전체 판매량 각각이 한 테이블에 모두 표시된다
                
            GROUP BY CUBE ( a, b ) : a, b, c의 파워 셋에 대해 질의한 것과 같다. ((), (a), (b), (a, b))
            GROUP BY ROLLUP ( a, b ) : 공집합부터 a, b, c를 순서대로 추가한 집합들에 대해 질의한 것과 같다. ((), (a), (a, b))
            CUBE, ROLLUP의 요소로 리스트가 올 수 있다. ROLLUP(a, (b, c)) == ((), (a), (a, b, c))

            여러 그루핑 조건을 같이 쓰는 경우, 마지막 조건에 대해 cross product가 이루어진다
            GROUP BY a, CUBE (b, c), GROUPING SETS (d, e) → ((a, d), (a, e), (a, b, d), (a, b, e), ..., (a, b, c, e))

            GROUP BY 절에서 행 생성자의 이용은 ROW(a, b)를 통해 할 수 있다
        </details>
    </details>
    
    <details>
        <summary>Select Lists</summary>
        SELECT DISTINCT select_list ... : 각 열집합에 대해 고유한 행들만 선택한다
        SELECT DISTINCT ON (expression [, expression ...]) select_list ... : 모든 행에 대해 expression이 평가된다. 두 행의 모든 평가값이 같은 경우 두 행은 같다고 간주한다

    </details>
    
    <details>
        <summary>Combining Queries</summary>
        query1 UNION [ALL] query2
        query1 INTERSECT [ALL] query2
        query1 EXCEPT [ALL] query2
    </details>
    
    <details>
        <summary>Sorting Rows</summary>
        
    </details>
    
    <details>
        <summary>LIMIT and OFFSET</summary>
        LIMIT : 출력 행의 개수 제한<br>
        OFFSET : 산출된 순서대로 n개 행을 출력하지 않고 무시
        SELECT select_list
                FROM table_expression
                [ ORDER BY ... ]
                [ LIMIT { number | ALL } ] [ OFFSET number ]
    </details>
    
    <details>
        <summary>VALUES Lists</summary>
        - 실제 디스크 상에 테이블을 만들지 않으면서 상수 테이블을 만드는 방법.
        VALUES ( expression [, ...] ) [, ...]
        - 문법적으로 "SELECT select_list FROM table_expression"과 동일하게 취급된다.
        
        => SELECT * FROM (VALUES (1, 'one'), (2, 'two'), (3, 'three')) AS t (num,letter);
         num | letter
        -----+--------
           1 | one
           2 | two
           3 | three
        (3 rows)
    </details>
    
    <details>
        <summary>WITH Queries</summary>
        8.6 WITH Queries
            8.6.1 SELECT in WITH
            - 여러 개의 SELECT 서브 쿼리를 날리는 대신 WITH을 이용하여 분리할 수 있다.
            WITH regional_sales AS (
                    SELECT region, SUM(amount) AS total_sales
                    FROM orders
                    GROUP BY region
                 ), top_regions AS (
                    SELECT region
                    FROM regional_sales
                    WHERE total_sales > (SELECT SUM(total_sales)/10 FROM regional_sales)
                 )
            SELECT region,
                   product,
                   SUM(quantity) AS product_units,
                   SUM(amount) AS product_sales
            FROM orders
            WHERE region IN (SELECT region FROM top_regions)
            GROUP BY region, product;
            
            - RECURSIVE를 이용하여 iteration 연산이 가능하다. 아래는 1~100의 합계.
            WITH RECURSIVE t(n) AS (
                    VALUES (1)
                UNION ALL
                    SELECT n+1 FROM t WHERE n < 100
            )
            SELECT sum(n) FROM t;
            
                - RECURSIVE 연산은 아래의 순으로 이루어진다.
                1. non-recursive 부분을 계산한다. UNION을 위해 (not UNION ALL) 중복되는 행을 제거한다. 남은 행들을 결과에 포함시키고, 임시 작업 테이블로 설정한다.
                2. 작업 테이블이 빌 때까지 아래를 반복한다.
                    1. recursive 부분을 계산하고, 작업 테이블 내용을 덮어쓴다. UNION을 위해 (not UNION ALL) 중복된 행(이전 결과와도 비교)들을 제거한다. 남은 행들을 결과에 포함시키고, 임시 중간 테이블로 설정한다.
                    2. 작업 테이블의 내용을 중간 테이블 내용으로 대체한다. 중간 테이블은 비운다.
            
                - 계산 순서
            time    working_table(n)   t
            0                    1
            1       2               1, 2
            2       3               1, 2, 3
            ...
            99      100             1, 2, 3, ..., 100
            100     empty           1, 2, 3, ..., 100
            
            
                - RECURSIVE 연산은 계층 구조나 트리 형태의 데이터에 유용하다.
            WITH RECURSIVE included_parts(sub_part, part, quantity) AS (
                SELECT sub_part, part, quantity FROM parts WHERE part = 'our_product'
              UNION ALL
                SELECT p.sub_part, p.part, p.quantity
                FROM included_parts pr, parts p
                WHERE p.part = pr.sub_part
              )
            SELECT sub_part, SUM(quantity) as total_quantity
            FROM included_parts
            GROUP BY sub_part
            
            8.6.2 Data-Modifying Statements in WITH
            - INSERT, UPDATE, DELETE를 WITH과 함께 사용할 수 있다.
            WITH moved_rows AS (
                DELETE FROM products
                WHERE
                    "date" >= '2010-10-01' AND
                    "date" < '2010-11-01'
                RETURNING *
            )
            INSERT INTO products_log
            SELECT * FROM moved_rows;
    </details>
</details>

<hr>

<details>
    <summary>Data Types</summary>
    <ol>
            9. Data Type
            9.1 Numeric Types
            smallint            2bytes
            smallserial         2bytes : 1 ~ 2^15-1
            integer             4bytes
            serial              4bytes : 1 ~ 2^31-1
            bigint              8bytes
            bigserial           8bytes : 1 ~ 2^63-1
            
            decimal             variable : user-specified precision, exact
            numeric             variable : decimal과 동일
            
            real                4bytes
            double precision    8bytes
            
            9.2 Character Types
            varchar(n)  variable-length with limit
            char(n)     fixed-length, blank padded
            text        variable unlimited length
            
            9.3 Date/Time Types
            timestamp   8bytes  date and time | 4713 BC ~ 294276AD | 1ms
            date        4bytes  date, no time | 4713 BC ~ 5874897AD | 1day
            time        8bytes  time, no date | 00:00:00 ~ 24:00:00 | 1ms
            time with time zone 12bytes       | 00:00:00+1459 ~ 24:00:00-1459 | 1ms
            interval    16bytes time interval | -178000000years ~ 178000000years | 1ms
            
            - Recommended date format : 1999-01-08
            - Time :
                04:05
                04:05:06
                040506
                04:05:06.789
            
                04:05-08:00
                04:05:06-08:00
                040506-08
                04:05:06.789-8
            
            - Time Zone :
                -8
                -800
                -8:00
            
            - Time Stamp : date + time
                1999-01-08 04:05:06
                1999-01-08 04:05:06 -8:00
            
            - Special Date/Time
                string      valid type              description
                epoch       date, timestamp         1970-01-01 00:00:00+00 (Unix system time zero)
                infinity	date, timestamp	        later than all other time stamps
                -infinity	date, timestamp	        earlier than all other time stamps
                now	        date, time, timestamp	current transaction's start time
                today	    date, timestamp	        midnight today
                tomorrow	date, timestamp	        midnight tomorrow
                yesterday	date, timestamp	        midnight yesterday
                allballs	time	                00:00:00.00 UTC
            
            9.4 boolean
            
            9.5 Enumerated Types
            CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy');
            
            9.6 Geometric Types
            point	16 bytes	    Point on a plane	(x,y)
            line	32 bytes	    Infinite line	    {A,B,C} // Ax + By + C = 0
            lseg	32 bytes	    Finite line segment	((x1,y1),(x2,y2))
            box	    32 bytes	    Rectangular box	    ((x1,y1),(x2,y2))
            path	16+16n bytes	Closed path         ((x1,y1),...)
            path	16+16n bytes	Open path	        [(x1,y1),...]
            polygon	40+16n bytes	Polygon             ((x1,y1),...)
            circle	24 bytes	    Circle	            <(x,y),r>
            
            9.7 Declaration of Composite Types
            CREATE TYPE complex AS (
                r       double precision,
                i       double precision
            );
            
            - 테이블을 만들면 그와 동일한 이름의 타입이 생성된다.
            CREATE TABLE inventory_item (
                name            text,
                supplier_id     integer REFERENCES suppliers,
                price           numeric CHECK (price > 0)
            );
            
            CREATE TABLE on_hand (
                item      inventory_item,
                count     integer
            );
            
            INSERT INTO on_hand VALUES (ROW('fuzzy dice', 42, 1.99), 1000);
            
            - Literal Composite CONSTRAINT
            '( val1 , val2 , ... )'
            
            - 갱신
            INSERT INTO mytab (complex_col) VALUES((1.1,2.2));
            
                - SET 바로 다음엔 괄호가 없어도 되지만, 등호 다음엔 필요하다.
            UPDATE mytab SET complex_col.r = (complex_col).r + 1 WHERE ...;
            
            9.8 Range Types
            int4range — Range of integer
            int8range — Range of bigint
            numrange — Range of numeric
            tsrange — Range of timestamp without time zone
            tstzrange — Range of timestamp with time zone
            daterange — Range of date
    </ol>
</details>

<hr>

<details>
    <summary>Functions and Operations</summary>
    <ol>

    </ol>
</details>

<hr>

<details>
    <summary>Type Conversion</summary>
    <ol>

    </ol>
</details>

<hr>

<details>
    <summary>Indexes</summary>
    <ol>

    </ol>
</details>

<hr>

<details>
    <summary>Full Text Search</summary>
    <ol>

    </ol>
</details>

<hr>

<details>
    <summary>동시성 제어</summary>
    <ol>

    </ol>
</details>

<hr>

<details>
    <summary>Performance Tips</summary>
    <ol>

    </ol>
</details>

<hr>

<details>
    <summary>병렬 쿼리</summary>
    <ol>

    </ol>
</details>

<hr>