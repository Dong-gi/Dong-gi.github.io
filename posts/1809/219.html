<ol>
    <li>Map::of, Map::ofEntries, Map::copyOf 팩터리 메서드로 변경 불가능한 맵을 만들 수 있다. 변경 불가능한 맵은 키와 값 모두 null을 허용하지 않으며, 모든 키와 값이 serializable하면
        맵도 그러하다. 또, value-based므로 identity-sensitive한 연산은 피해야 한다.</li>
    <li>int size()</li>
    <li>boolean isEmpty()</li>
    <li>boolean containsKey(Object key)</li>
    <li>boolean containsValue(Object value)</li>
    <li>V get(Object key)</li>
    <li>V put(K key, V value) : 이전 값은 반환된다.</li>
    <li>V remove(Object key)</li>
    <li>void putAll(Map&lt;? extends K, ? extends V&gt; m)</li>
    <li>void clear()</li>
    <li>Collection&lt;V&gt; values()</li>
    <li>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()</li>
    <li>default V getOrDefault(Object key, V defaultValue) Since 1.8</li>
    <li>default void forEach(BiConsumer&lt;? super K, ? super V&gt; action) Since 1.8</li>
    <li>default void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function) Since 1.8
        <br>» 모든 값을 연산 결과로 대체한다.</li>
    <li>default V putIfAbsent(K key, V value) Since 1.8</li>
    <li>default boolean remove(Object key, Object value) Since 1.8</li>
    <li>default boolean replace(K key, V oldValue, V newValue) Since 1.8</li>
    <li>default V replace(K key, V value) Since 1.8 : key가 있을 때만 대체</li>
    <li>default V computeIfAbsent(K key, Function&lt;? super K, ? extends V&gt; mappingFunction) Since 1.8
        <br>» key가 맵에 없거나, 대응하는 값이 null인 경우 새로운 값을 계산하여 넣는다. 단, 새로운 값이 null이거나 도중 예외가 발생하는 경우, 기록되지 않는다.</li>
    <li>default V computeIfPresent(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) Since 1.8</li>
    <li>default V compute(K key, BiFUnction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) Since 1.8</li>
    <li>default V merge(K key, V value, BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) Since 1.8
        <br>» key가 맵에 없거나, 대응하는 값이 null인 경우 null이 아닌 value로 연결. 그 외의 경우 주어진 함수를 통해 새로운 값에 연결하거나, 결과가 null인 경우 맵에서 제거.
        <br>* 예: map.merge(key, msg, String::concat)</li>
    <li>static &lt;K, V&gt; Map&lt;K, V&gt; of() Since 9</li>
    <li>static &lt;K, V&gt; Map&lt;K, V&gt; of(K k1, V v1) Since 9 ...</li>
    <li>@SafeVarargs static &lt;K, V&gt; Map&lt;K, V&gt; ofEntries(Map.ENtry&lt;? extends K, ? extends V&gt;... entries)
        Since 9
        <br>» Map::entry()와 함께 이용하면 맵 초기화를 편리하게 할 수 있다.</li>
    <li>static &lt;K, V&gt; Map.Entry&lt;K, V&gt; entry(K k, V v) Since 9</li>
    <li>static &lt;K, V&gt; Map&lt;K, V&gt; copyOf(Map&lt;? extends K, ? extends V&gt; map) Since 10</li>
</ol>