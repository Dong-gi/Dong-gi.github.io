<ol>
    <li>쓰레드는 실행 우선순위를 가지며, 그 초깃값은 쓰레드를 생성한 쓰레드의 것과 같다. 데몬 쓰레드로부터 생성된 쓰레드도 데몬 쓰레드다.</li>
    <li>JVM이 시작되면 하나의 non-daemon 쓰레드가 존재하며, 전형적으로 main 메서드를 호출한다. JVM은 다음의 상황 중 하나라도 일어나기 전까지 실행을 계속한다.
        <br>» 1. Runtime 클래스의 exit 메서드 호출, 또는 SecurityManager의 exit 허용
        <br>» 2. 모든 데몬 쓰레드가 아닌 쓰레드들의 종료 : run 메서드의 반환이든 예외 발생이든 관계없이</li>
    <li>static enum Thread.State Since 1.5
        <br>» NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED</li>
    <li>@FunctionalInterface static interface Thread.UncaughtExceptionHandler Since 1.5
        <br>» 처리되지 않은 예외로 인해 쓰레드가 종료되는 상황을 대비한 핸들러. 그러한 상황에서, 먼저 Thread.getUncaughtExceptionHandler()를 통해 얻은 핸들러에 해당 쓰레드와
        예외 객체를 전달한다.
        <br>» 만일 쓰레드에 핸드러가 설정되지 않은 경우, ThreadGroup의 핸들러를 이용하며, ThreadGroup에도 없는 경우 default 핸들러를 이용할 수 있다.
        <br>» void uncaughtException(Thread t, Throwable e)</li>
    <li>필드
        <ul>
            <li>public static final int MIN_PRIORITY</li>
            <li>public static final int NORM_PRIORITY</li>
            <li>public static final int MAX_PRIORITY</li>
        </ul>
    </li>
    <li>생성자
        <ul>
            <li>public Thread()</li>
            <li>public Thread(Runnable target)</li>
            <li>public Thread(ThreadGroup group, Runnable target)</li>
            <li>public Thread(String name)</li>
            <li>public Thread(ThreadGroup group, String name)</li>
            <li>public Thread(Runnable target, String name)</li>
            <li>public Thread(ThreadGroup group, Runnable target, String name)</li>
            <li>public Thread(ThreadGroup group, Runnable target, String name, long stackSize) Since 1.4 : stackSize는 쓰레드에
                할당하는 바이트 크기를 가리키나, 플랫폼에 따라 그 효과는 다르다.</li>
            <li>public Thread(ThreadGroup group, Runnable target, String name, long stackSize, boolean inheritThreadLocals)
                Since 9</li>
        </ul>
    </li>
    <li>static Thread currentThread()</li>
    <li>static void yield()</li>
    <li>static void sleep(long millis)</li>
    <li>static void sleep(long millis, int nanos)</li>
    <li>static void onSpinWait() Since 9</li>
    <li>» Spin-wait 루프에서 조건이 충족되어 루프를 벗어나기를 기다린다.
        <br>예.
        <br>class EventHandler {
        <br>&nbsp;&nbsp;&nbsp;&nbsp;volatile boolean eventNotificationNotReceived;
        <br>&nbsp;&nbsp;&nbsp;&nbsp;void waitForEventAndHandleIt() {
        <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while ( eventNotificationNotReceived ) {
        <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;java.lang.Thread.onSpinWait();
        <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
        <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;readAndProcessEvent();
        <br>&nbsp;&nbsp;&nbsp;&nbsp;}
        <br>&nbsp;&nbsp;&nbsp;&nbsp;
        <br>&nbsp;&nbsp;&nbsp;&nbsp;void readAndProcessEvent() {
        <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Read event from some source and process it
        <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; . . .
        <br>&nbsp;&nbsp;&nbsp;&nbsp;}
        <br>}
    </li>
    <li>void start() : JVM이 run()을 호출. 쓰레드를 재시작하는 것은 허용되지 않는다.</li>
    <li>void run() : 관련된 Runnable의 run() 호출</li>
    <li>void interrupt()
        <br>» checkAccess()가 호출된다. wait, join, sleep으로 블록된 경우 인터럽트 상태가 초기화되고, InterruptedException 발생.
        <br>» InterruptibleChannel로 I/O 작업 중 블록된 경우, 인터럽트 상태가 설정되고 채널은 닫힌다. ClosedByInterruptException 발생.
        <br>» Selector에서 블록된 경우, 인터럽트 상태가 설정되고 selection 연산에서 즉시 반환된다. 그 외의 경우 인터럽트 상태가 설정된다.</li>
    <li>static boolean interrupted() : 현재 쓰레드가 인터럽드됐는지 여부. 쓰레드의 인터럽트 상태는 이 메서드로 인해 초기화된다.</li>
    <li>boolean isInterrupted() : 쓰레드의 인터럽트 상태를 변경하지 않고 반환한다.</li>
    <li>final boolean isAlive()</li>
    <li>final void setPriority(int newPriority)</li>
    <li>final int getPriority()</li>
    <li>final void setName(String name)</li>
    <li>final String getName()</li>
    <li>final ThreadGroup getThreadGroup()</li>
    <li>static int activeCount() : 현재 쓰레드 그룹 하위의, 활동중인 쓰레드 추정치 반환.</li>
    <li>static int enumerate(Thread[] tarray) : 현재 쓰레드 그룹 하위의 모든 활동 쓰레드를 배열에 복사하고 그 갯수를 반환한다.</li>
    <li>final void join(long millis) : 이 쓰레드가 중지되기까지 일시 대기. 0이면 무기한 대기.</li>
    <li>final void join(long millis, int nanos)</li>
    <li>final void join() : join(0)과 동일</li>
    <li>static void dumpStack() : 현재 쓰레드의 스택 추적을 표준 에러 출력</li>
    <li>final void setDaemon(boolean on) : 쓰레드를 daemon 또는 user 쓰레드로 변경. user 쓰레드가 하나도 없으면 프로그램은 종료된다. 쓰레드가 시작되기 전에 호출돼야한다.</li>
    <li>final boolean isDaemon()</li>
    <li>final void checkAccess() : 현재 쓰레드가 이 쓰레드를 변경할 수 없으면 SecurityException 발생</li>
    <li>ClassLoader getContextClassLoader() Since 1.2</li>
    <li>static boolean holdsLock(Object obj) Since 1.4
        <br>» 특정 객체를 lock으로 갖는지 확인하기 위해 만들어짐. assert Thread.holdsLock(obj);</li>
    <li>StackTraceElement[] getStackTrace() Since 1.5 : 현재 쓰레드의 스택 추적 반환</li>
    <li>static Map&lt;Thread, StackTraceElement[]&gt; getAllstackTraces() Since 1.5 : 전체 쓰레드에 대해 스택 추적 반환</li>
    <li>long getId() Since 1.5</li>
    <li>Thread.State getState() Since 1.5</li>
    <li>static void setDefaultUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh) Since 1.5
    </li>
    <li>static Thread.uncaughtExceptionHandler getDefaultUncaughtExceptionHandler() Since 1.5</li>
    <li>Thread.UncaughtExceptionHandler getUncaughtExceptionHandler() Since 1.5</li>
    <li>void setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh) Since 1.5</li>
</ol>