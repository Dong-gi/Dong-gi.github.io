<hr>

<details>
    <summary>class AccessibleObject implements AnnotatedElement Since 1.2</summary>
    <ol>
        <li>Field, Method, Constructor의 base 클래스. 리플렉트된 객체를 사용하기 전에 suppressing check 표시한다.</li>
        <li>static void setAccessible(AccessibleObject[] array, boolean flag)</li>
        배열의 각 원소들을 setAccessible(boolean)으로 설정할 수 있을 때, 한번에 하기 위한 메서드
        <li>void setAccessible(boolean flag)</li>
        <li>final boolean trySetAccessible() Since 9</li>
        아마도 변경되었을 accessible flag 값을 반환한다. 실패할 경우 예외를 발생하지 않고 false를 반환.
        <li>final boolean canAccess(Object obj) Since 9</li>
    </ol>
</details>

<hr>

<details>
    <summary>final class Field extends AccessibleObject implements Member Since 1.1</summary>
    <ol>
        <li>boolean isEnumConstant() Since 1.5</li>
        <li>boolean isSynthetic() Since 1.5</li>
        <li>Class&lt;?&gt; getType()</li>
        <li>Type getGenericType() Since 1.5</li>
        <li>String toGenericString() Since 1.5</li>
        <li>Object get(Object obj)</li>
        <li>boolean getBoolean(Object obj)</li>
        <li>byte getByte(Object obj)</li>
        <li>char getChar(Object obj)</li>
        <li>short getShort(Object obj)</li>
        <li>int getInt(Object obj)</li>
        <li>long getLong(Object obj)</li>
        <li>float getFloat(Object obj)</li>
        <li>double getDouble(Object obj)</li>
        <li>void set(Object obj, Object value)</li>
        <li>void setBoolean(Object obj, boolean z)</li>
        <li>void setByte(Object obj, byte b)</li>
        <li>void setChar(Object obj, char c)</li>
        <li>void setShort(Object obj, short s)</li>
        <li>void setInt(Object obj, int i)</li>
        <li>void setLong(Object obj, long l)</li>
        <li>void setFloat(Object obj, float f)</li>
        <li>void setDouble(Object obj, double d)</li>
        <li>AnnotatedType getAnnotatedType() Since 1.8</li>
    </ol>
</details>

<hr>

<details>
    <summary>abstract class Executable extends AccessibleObject implements Member, GenericDeclaration Since 1.8</summary>
    <ol>
        <li>Method, Constructor의 공통 기능</li>
        <li>abstract Class&lt;?&gt;[] getParameterTypes()</li>
        <li>int getParameterCount()</li>
        <li>Type[] getGenericParameterTypes()</li>
        <li>Parameter[] getParameters()</li>
        <li>abstract Class&lt;?&gt;[] getExceptionTypes()</li>
        <li>Type[] getGenericExceptionTypes()</li>
        <li>abstract Annotation[][] getParameterAnnotations()</li>
        <li>abstract AnnotatedType getAnnotatedReturnType()</li>
        <li>AnnotatedType getAnnotatedReceiverType()</li>
        <li>AnnotatedType[] getAnnotatedParameterTypes()</li>
        <li>AnnotatedType[] getAnnotatedExceptionTypes()</li>
        <li>abstract String toGenericString()</li>
        <li>boolean isVarArgs()</li>
        <li>boolean isSynthetic()</li>
    </ol>
</details>

<hr>

<details>
    <summary>final class Method extends Executable Since 1.1</summary>
    <ol>
        <li>Class&lt;&?&gt; getReturnType()</li>
        <li>Type getGenericReturnType() Since 1.5</li>
        <li>Object getDefaultValue() Since 1.5</li>
        <li>Object invoke(Object obj, Object... args)</li>
        <li>boolean isBridge()</li>
        <li>boolean isDefault() Since 1.8</li>
    </ol>
</details>

<hr>

<details>
    <summary>final class Constructor&lt;T&gt; extends Executable Since 1.1</summary>
    T newInstance(Object... initargs)
</details>

<hr>

<details>
    <summary>final class Parameter implements AnnotatedElement</summary>
    <ol>
        <li>메서드 인자에 관한 정보.</li>
        <li>boolean isNamePresent()</li>
        <li>boolean isImplicit()</li>
        <li>boolean isSynthetic()</li>
        <li>boolean isVarArgs()</li>
        <li>Executable getDeclaringExecutable()</li>
        <li>int getModifiers()</li>
        <li>String getName()</li>
        <li>Type getParameterizedType()</li>
        <li>Class&lt;?&gt; getType()</li>
        <li>AnnotatedType getAnnotatedType()</li>
    </ol>
</details>

<hr>

<details>
    <summary>final class Array Since 1.1</summary>
    <ol>
        <li>동적으로 자바 배열을 생성하고 접근하는 static 메서드들을 제공.</li>
        <li>static Object newInstance(Class&lt;?&gt; componentType, int length)</li>
        <li>static Object newInstance(Class&lt;?&gt; componentType, int... dimensions)</li>
        <li>static int getLength(Object array)</li>
        <li>static Object get(Object array, int index)</li>
        <li>static boolean getBoolean(Object array, int index)</li>
        <li>static byte getByte(Object array, int index)<br>
            ... static double getDouble(Object array, int index)</li>
        <li>static void set(Object array, int index, Object value)</li>
        <li>static void setBoolean(Object array, int index, boolean z)<br>
            ... static void setDouble(Object array, int index, double d)</li>
    </ol>
</details>

<hr>

<details>
    <summary>class Modifier Since 1.1</summary>
    <ol>
        <li>public static final int PUBLIC, PRIVATE, PROTECTED, STATIC, FINAL, SYNCHRONIZED, VOLATILE, TRANSIENT, NATIVE, INTERFACE, ABSTRACT, STRICT</li>
        <li>public Modifier()</li>
        <li>static boolean isPublic(int mod)<br>
            ... static boolean isStrict(int mod)</li>
        <li>static String toString(int mod)</li>
        <li>사용할 수 있는 제한자들을 OR하여 반환</li>
        <ul>
            <li>static int classModifiers() Since 1.7</li>
            <li>static int interfaceModifiers() Since 1.7</li>
            <li>static int constructorModifiers() Since 1.7</li>
            <li>static int methodModifiers() Since 1.7</li>
            <li>static int fieldModifiers() Since 1.7</li>
            <li>static int parameterModifiers() Since 1.8</li>
        </ul>
    </ol>
</details>

<hr>

<details>
    <summary>class Proxy implements Serializable Since 1.3</summary>
    <ol>
        <li>Proxy는 인터페이스 익명 객체처럼 행동하면서 사용자 정의 메서드를 호출할 수 있는 객체를 생성하는 static 메서드를 제공한다.</li>
        예. 인터페이스 Foo의 프록시 인스턴스 생성 : proxy instanceof Foo == true, (Foo) proxy : ok<br>
        InvocationHandler handler = new MyInvocationHandler(...);<br>
        Foo f = (Foo) Proxy.newProxyInstance(Foo.class.getClassLoader(), new Class&lt;?&gt;[] { Foo.class }, handler);
        <li>프록시 클래스 속성</li>
        "$Proxy"로 이름이 시작. final and non-abstract. java.lang.reflect.Proxy를 상속. 생성시 주어진 인터페이스들을 차례대로 구체화. ProtectionDomain은 bootstrap 클래스 로더가 로드한 시스템 클래스들과 동일.
        <li>protected InvocationHandler h</li>
        <li>protedtec Proxy(InvocationHandler h)</li>
        <li>static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</li>
        <li>static boolean isProxyClass(Class&lt;?&gt; cl)</li>
        <li>static InvocationHandler getInvocationHandler(Object proxy)</li>
    </ol>
</details>

<hr>
