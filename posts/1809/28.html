<hr>

<details>
    <summary>interface Closeable extends AutoCloseable Since 1.5</summary>
    <ol>
        <li>데이터의 출발지나 도착지를 닫을 수 있으면 Closeable하다.</li>
        <li>void close()</li>
        <ul>
            <li>스트림 및 이와 관련된 시스템 자원을 해제한다. 이미 호출되었다면 아무 일도 하지 않는다.</li>
            <li>close() 실패했을 때, 예외를 던지는 대신 사용하던 자원을 모두 포기하고 Closeable 객체 내부적으로 '닫혔다(closed)'고 마크하길 권장한다.</li>
        </ul>
    </ol>
</details>

<hr>

<details>
    <summary>interface Flushable Since 1.5</summary>
    <ol>
        <li>void flush() : 버퍼에 저장된 데이터를 스트림에 모두 씀으로써 flush</li>
    </ol>
</details>

<hr>

<details>
    <summary>interface DataInput Since 1.0</summary>
    <ol>
        <li>binary stream으로부터 바이트들을 읽고, 또 이를 자바 기본 타입 또는 String으로 만들어 반환하는 기능을 제공한다.</li>
        <li>Modified UTF-8 : DataInput과 DataOutput 인터페이스는 수정된 UTF-8을 이용한다.</li>
        <ul>
            <li>'\u0001' ~ '\u007F'는 1바이트(0???????)로 표현한다.</li>
            <li>null('\u0000'), '\u0080' ~ '\u07FF'는 2바이트(110????? 10??????)로 표현한다.</li>
            <li>'\u0800' ~ '\uFFFF'는 3바이트(1110??? 10?????? 10??????)로 표현한다.</li>
        </ul>
        <li>void readFully(byte[] b) » b.length만큼의 바이트를 읽어와 b에 저장한다.</li>
        <li>void readFully(byte[] b, int off, int len) » len만큼의 바이트를 읽어와 b의 off번째 바이트부터 저장한다.</li>
        <li>int skipBytes(int n) » 입력 스트림의 n바이트를 무시한다. 실제로 무시한 바이트 길이가 반환된다.</li>
        <li>입력은 1바이트 단위로 이루어진다.</li>
        <ol>
            <li>boolean readBoolean() : 1바이트를 읽어 0이면 false, 그 외엔 true 반환</li>
            <li>byte readByte() : 1바이트를 읽어 그대로 반환</li>
            <li>int readUnsignedByte() : 1바이트를 읽어 int로 반환</li>
            <li>short readShort() : 1바이트씩 순서대로 읽은 a, b에 대하여 (short)((a &lt;&lt; 8) | (b &amp; 0xff)) 반환</li>
            <li>...</li>
            <li>float readFloat() : readInt()한 비트 순서 그대로 float으로 변환하여 반환</li>
            <li>double readDouble() : readLong()한 비트 순서 그대로 double로 변환하여 반환</li>
        </ol>
        <li>String readLine()</li>
        <ul>
            <li>줄의 끝이나 파일 끝을 만나기까지의 문자열을 반환한다.</li>
            <li>각 바이트들을 0 패딩하여 char로 변환하므로, 유니코드를 읽기는 부적합하다.</li>
            <li>아무것도 읽지 못한 경우, 빈 문자열이 아닌 null이 반환된다.</li>
        </ul>
        <li>String readUTF()</li>
        <ul>
            <li>먼저 readUnsignedShort()와 같은 방법으로 2개 바이트를 읽어와 UTF 길이를 구한다.</li>
            <li>구한 길이만큼의 바이트를 읽으면서 상기한 Modified UTF-8에 맞춰 String을 만든다.</li>
            <li>길이만큼의 바이트를 다 읽기 전에 EOF를 만나면 예외를 던진다.</li>
        </ul>
    </ol>
</details>

<hr>

<details>
    <summary>interface DataOutput Since 1.0</summary>
    <ol>
        <li>DataInput과 대칭</li>
        <li>void write(int b) » 하위 8개 비트만 스트림에 쓴다. 나머지는 무시한다.</li>
        <li>void writeBoolean(boolean v) » true면 (byte)1, false면 (byte)0.</li>
        <li>void writeShort(int v) : 다음 순으로 2개 바이트를 쓴다. (byte)(0xff &amp; (v &gt;&gt; 8)), (byte)(0xff &amp; v)</li>
        <li>void writeBytes(String s) » s의 각 글자의 하위 8개 비트만 쓴다.</li>
        <li>void writeChars(String s) » s의 각 글자를 저장.</li>
        <li>void writeUTF(String s) » Modified UTF-8을 이용하여 저장한다. 총 길이 정보를 2바이트로 먼저 기록한다.</li>
    </ol>
</details>

<hr>

<details>
    <summary>interface Serializable Since 1.1</summary>
    <ol>
        <li>직렬화와 역질렬화를 지원하는 마커 인터페이스. ObjectInputStream, ObjectOutputStream의 메서드들을 이용해 알아서 저장/복구한다.
            <button type="button" class="btn btn-primary btn-sm btn-code" path="Java/JavaSE/src/io/SerializableExample.java" lan="java">예시 코드 »</button></li>
        <li>직렬화하지 않을 멤버는 transient 키워드로 표시한다.</li>
        <li>직접 구현하고 싶다면 Externalizable 인터페이스를 구체화하거나, 다음의 메서드들을 작성한다.</li>
        <ul>
            <li>private void writeObject(java.io.ObjectOutputStream out)</li>
            <li>private void readObject(java.io.ObjectInputStream in)</li>
            <li>private void readObjectNoData() : 객체들의 버전이 다르거나, 기타 이유로 객체를 초기화할 필요가 있는 경우 사용</li>
        </ul>
        <li>대체 객체를 이용해 저장 : ANY-ACCESS-MODIFIER Object writeReplace()</li>
        <li>대체 객체를 이용해 복구 : ANY-ACCESS-MODIFIER Object readResolve()</li>
        <li>클래스 버전</li>
        정의되지 않은 경우 기본값을 사용하지만, 명시할 것을 권장하고 있다.<br>
        ANY-ACCESS-MODIFIER static final long serialVersionUID = (version number)L;
    </ol>
</details>

<hr>

<details>
    <summary>interface Externalizable extends Serializable Since 1.1</summary>
    <ol>
        <li>객체 직렬화를 직접 구현하고자 할 때 이를 구체화한다. 객체 직렬화는 빈 객체를 만든 뒤 각 속성의 값을 쓰므로 기본 생성자가 필요하다.
            <button type="button" class="btn btn-primary btn-sm btn-code" path="Java/JavaSE/src/io/ExternalizableExample.java" lan="java">예시 코드 »</button></li>
        <li>void writeExternal(ObjectOutput out) » 객체를 out을 통해 저장한다.</li>
        <li>void readExternal(ObjectInput in) » in을 통해 객체를 복구한다.</li>
    </ol>
</details>

<hr>

<details>
    <summary>interface ObjectInput extends DataInput, AutoCloseable Since 1.1</summary>
    <ol>
        <li>DataInput을 통해 기본 자료형을 읽어오고, 추가적으로 객체를 읽어오는 작업을 지원한다.</li>
        <li>Object readObject()</li>
    </ol>
</details>

<hr>

<details>
    <summary>interface ObjectOutput extends DataOutput, AutoCloseable Since 1.1</summary>
    <ol>
        <li>객체 쓰기 작업을 지원한다.</li>
        <li>flush(), writeObject(Object obj)</li>
    </ol>
</details>

<hr>

<details>
    <summary>@FunctionalInterface interface FileFilter Since 1.2</summary>
    <ol>
        <li>파일명 필터링에 사용되며 File::listFiles의 매개변수로 객체가 넘겨진다.</li>
        <li>boolean accept(File pathname)
            <button type="button" class="btn btn-primary btn-sm btn-code" path="Java/JavaSE/src/io/FileFilterExample.java" lan="java">예시 코드 »</button></li>
    </ol>
</details>

<hr>

<details>
    <summary>@FunctionalInterface interface FilenameFilter Since 1.0</summary>
    <ol>
        <li>특정 디렉터리에서의 파일명 필터링에 사용되며 FileDialog::setFilenameFilter, File::list, File::listFiles의 매개변수로 객체가 넘겨진다.</li>
        <li>boolean accept(File dir, String name)
            <button type="button" class="btn btn-primary btn-sm btn-code" path="Java/JavaSE/src/io/FilenameFilterExample.java" lan="java">예시 코드 »</button></li>
    </ol>
</details>

<hr>