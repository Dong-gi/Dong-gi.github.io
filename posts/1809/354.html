1. 정규표현식의 컴파일된 표현.
<br>
<br>
<b>2. 정규표현식 상수</b>
<br>x » 문자 x 자체
<br>\\ » 백슬래시 문자
<br>\0n 또는 \0nn 또는 \0mnn» » 8진수 표현 문자
<br>\xhh 또는 \uhhhh 또는 \u{h...h} » 16진수 표현 문자
<br>\N{name} » 유니코드 이름으로 표현된 문자
<br>\t » 탭 \u0009
<br>\n » newline \u000A
<br>\r » carriage-return \u000D
<br>\f » form-feed \u000C
<br>\a » alert \u0007
<br>\e » escape \u001B
<br>\cx » x에 관한 제어 문자
<br>
<br>[abc] » a, b, or c(단순 집합)
<br>[^abc] » a, b, c를 제외한 임의 문자(여집합)
<br>[a-zA-Z] » a ~ z or A ~ Z, inclusive(범위)
<br>[a-d[m-p]] » a ~ d or m ~ p : [a-dm-p](합집합)
<br>[a-z&amp;&amp;[def]] » d, e, or f(교집합)
<br>[a-z&amp;&amp;[^bc]] » a ~ z, b와 c는 제외(차집합)
<br>[a-z&amp;&amp;[^m-p]] » a ~ z, m ~ p는 제외 : [a-lq-z](차집합)
<br>
<br>. » 임의 문자(줄 끝은 매치되지 않을수도 있음)
<br>\d » [0-9]
<br>\D » [^0-9]
<br>\h » 수평 공백 문자: [ \t\xA0\u1680\u180e\u2000-\u200a\u202f\u205f\u3000]
<br>\H » [^\h]
<br>\s » 공백 문자: [ \t\n\x0B\f\r]
<br>\S » [^\s]
<br>\v » 수직 공백 문자: [\n\x0B\f\r\x85\u2028\u2029]
<br>\V » [^\v]
<br>\w » [a-zA-Z_0-9]
<br>\W » [^w]
<br>
<br>\p{Lower} » [a-z]
<br>\p{Upper} » [A-Z]
<br>\p{ASCII} » All ASCII:[\x00-\x7F]
<br>\p{Alpha} » [\p{Lower}\p{Upper}]
<br>\p{Digit} » [0-9]
<br>\p{Alnum} » [\p{Alpha}\p{Digit}]
<br>\p{Punct} » Punctuation: One of !"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\]^_`{|}~
<br>\p{Graph} » A visible character: [\p{Alnum}\p{Punct}]
<br>\p{Print} » A printable character: [\p{Graph}\x20]
<br>\p{Blank} » A space or a tab: [ \t]
<br>\p{Cntrl} » A control character: [\x00-\x1F\x7F]
<br>\p{XDigit} » A hexadecimal digit: [0-9a-fA-F]
<br>\p{Space} » A whitespace character: [ \t\n\x0B\f\r]
<br>
<br>\p{javaLowerCase} » Equivalent to java.lang.Character.isLowerCase()
<br>\p{javaUpperCase} » Equivalent to java.lang.Character.isUpperCase()
<br>\p{javaWhitespace} » Equivalent to java.lang.Character.isWhitespace()
<br>\p{javaMirrored} » Equivalent to java.lang.Character.isMirrored()
<br>
<br>\p{IsLatin} » A Latin script character (script)
<br>\p{InGreek} » A character in the Greek block (block)
<br>\p{Lu} » An uppercase letter (category)
<br>\p{IsAlphabetic} » An alphabetic character (binary property)
<br>\p{Sc} » A currency symbol
<br>\P{InGreek} » Any character except one in the Greek block (negation)
<br>[\p{L}&amp;&amp;[^\p{Lu}]] » Any letter except an uppercase letter (subtraction)
<br>
<br>^ » The beginning of a line
<br>$ » The end of a line
<br>\b » A word boundary
<br>\b{g} » A Unicode extended grapheme cluster boundary
<br>\B » A non-word boundary
<br>\A » The beginning of the input
<br>\G » The end of the previous match
<br>\Z » The end of the input but for the final terminator, if any
<br>\z » The end of the input
<br>\R » Any Unicode linebreak sequence, is equivalent to \u000D\u000A|[\u000A\u000B\u000C\u000D\u0085\u2028\u2029]
<br>
<br>
<b>Greedy quantifiers
    <a role="button" target="_blank" class="btn btn-info btn-sm" href="https://stackoverflow.com/questions/5319840/greedy-vs-reluctant-vs-possessive-quantifiers">참고자료</a>
</b>
<br>» 처음에 매치할 수 있는 만큼 최대한 매치. 그 다음 요소의 매칭이 없으면 백트래킹.
<br>X? » X, once or not at all
<br>X* » X, zero or more times
<br>X+ » X, one or more times
<br>X{n} » X, exactly n times
<br>X{n,} » X, at least n times
<br>X{n,m} » X, at least n but not more than m times
<br>
<br>
<b>Reluctant quantifiers</b>
<br>» non-greedy. 처음에 최소한만 매치. 그 다음 요소의 매칭이 없으면 백트래킹.
<br>X?? » X, once or not at all
<br>X*? » X, zero or more times
<br>X+? » X, one or more times
<br>X{n}? » X, exactly n times
<br>X{n,}? » X, at least n times
<br>X{n,m}? » X, at least n but not more than m times
<br>
<br>
<b>Possessive quantifiers</b>
<br>» Greedy quantifier와 같지만, 백트래킹은 없다.
<br>X?+ » X, once or not at all
<br>X*+ » X, zero or more times
<br>X++ » X, one or more times
<br>X{n}+ » X, exactly n times
<br>X{n,}+ » X, at least n times
<br>X{n,m}+ » X, at least n but not more than m times
<br>
<br>
<b>Logical operations</b>
<br>XY » X followed by Y
<br>X|Y » Either X or Y
<br>(X) » X, as a capturing group
<br>
<br>
<b>Back references</b>
<br>\n » Whatever the n-th capturing group matched
<br>\k&lt;name&gt; » Whatever the named-capturing group "name" matched
<br>
<br>
<b>Quotation</b>
<br>\ » Nothing, but quotes the following character
<br>\Q » Nothing, but quotes all characters until \E
<br>\E » Nothing, but ends quoting started by \Q
<br>
<br>
<b>Special constructs</b>
<br>(?&lt;name&gt;X) » X, as a named-capturing group
<br>(?:X) » X, as a non-capturing group
<br>(?idmsuxU-idmsuxU) » Nothing, but turns match flags i d m s u x U on - off
<br>(?idmsux-idmsux:X) » X, as a non-capturing group with the given flags i d m s u x on - off
<br>(?=X) » X, via zero-width positive lookahead
<br>(?!X) » X, via zero-width negative lookahead
<br>(?&lt;=X) » X, via zero-width positive lookbehind
<br>(?&lt;!X) » X, via zero-width negative lookbehind
<br>(?&gt;X) » X, as an independent, non-capturing group
<br>
<br>
<b>3. Groups and capturing</b>
<br>» 괄호 여는 순서에 따라 capturing group의 숫자가 매겨진다.
<br>» ((A)(B(C)))에 대하여, 0: ((A)(B(C))), 1: (A), 2: (B(C)), 3: (C)의 4가지 그룹이 존재하며, 0번 그룹은 항상 전체 표현을 가리킨다.
<br>
<br>4. 필드
<br>public static final int UNIX_LINES
<br>» 줄끝 '\n'만 ., ^, $에서 동작. (?d) 플래그도 같은 의미.
<br>public static final int CASE_INSENSITIVE
<br>» 대소문자 구분 없음. (?i) 플래그도 같은 의미.
<br>public static final int COMMENTS
<br>» 공백과 주석 허용 » 공백과 #부터 줄 끝까지의 주석이 무시된다. (?x) 플래그도 같은 의미.
<br>public static final int MULTILINE
<br>» ^, $이 각 줄의 끝을 기준으로도 작동; 기본 동작은 입력 시작과 끝에서만 작동. (?m) 플래그도 같은 의미.
<br>public static final int LITERAL Since 1.5
<br>» 표현식 전체를 상수 문자열 취급.
<br>public static final int DOTALL
<br>» .이 줄 끝도 포함하여 매치; 기본 동작은 줄 끝 문자는 미포함. (?s) 플래그도 같은 의미.
<br>public static final int UNICODE_CASE
<br>» CASE_INSENSITIVE 플래그가 유니코드 표준 상에서 동작한다; 기본은 US-ASCII에서만 동작. (?u) 플래그도 같은 의미.
<br>2개 생략
<br>
<br>5. static Pattern compile(String regex) + 1 오버로딩
<br>static boolean matches(String regex, CharSequence input) : 1회용
<br>String pattern()
<br>String toString() Since 1.5
<br>static String quote(String s) Since 1.5
<br>» s를 매칭할 수 있는 정규표현식 리터럴 문자열 표현을 반환.
<br>int flags()
<br>
<br>6. Matcher matcher(CharSequence input)
<br>String[] split(CharSequence input) + 1 오버로딩
<br>
<br>7. Since 1.8
<br>Predicate&lt;String&gt; asPredicate()
<br>Stream&lt;String&gt; splitAsStream(CharSequence nput)