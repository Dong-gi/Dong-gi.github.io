<hr>

<details>
    <summary>interface Collection&lt;E&gt; extends Iterable&lt;E&gt; Since 1.2</summary>
    <ol>
        <li>int size()</li>
        <li>boolean isEmpty()</li>
        <li>boolean contains(Object o)</li>
        <li>Object[] toArray()</li>
        <li>&lt;T&gt; T[] toArray(T[] a)</li>
        <li>default &lt;T&gt; T[] toArray(IntFunction&lt;T[]&gt; generator) Since 11</li>
        <li>boolean add(E e)</li>
        <li>boolean remove(Object o)</li>
        <li>boolean containsAll(Collection&lt;?&gt; c)</li>
        <li>boolean addAll(Collection&lt;? extends E&gt; c)</li>
        <li>boolean removeAll(Collection&lt;?&gt; c)</li>
        <li>boolean removeIf(Predicate&lt;? super E&gt; filter) Since 1.8</li>
        <li>void clear()</li>
        <li>default Stream&lt;E&gt; stream() Since 1.8</li>
        <li>default Stream&lt;E&gt; parallelStream() Since 1.8</li>
    </ol>
</details>

<hr>

<details>
    <summary>@FunctionalInterface interface Comparator&lt;T&gt; Since 1.2</summary>
    <ol>
        <li>int compare(T o1, T o2)</li>
        <li>default Comparator&lt;T&gt; reversed() Since 1.8</li>
        <li>default Comparator&lt;T&gt; thenComparing(Comparator&lt;? super T&gt; other) Since 1.8</li>
        이 비교자가 두 객체를 같다고 판단하면, other가 새로 판단한다.
        <li>default &lt;U&gt; Comparator&lt;T&gt; thenComparing(Function&lt;? super T, ? extends U&gt; keyExtractor, Comparator&lt;? super U&gt; keyComparator) Since 1.8</li>
        thenComparing(comparing(keyExtractor, cmp))와 같이 동작한다. 키를 이용해 비교하는 비교자가 두 객체를 같다고 판단하면, 다른 키를 이용해 비교한다.
        <li>default &lt;U extends Comparable&lt;? super U&gt;&gt; Comparator&lt;T&gt; thenComparing(Function&lt;? super T, ? extends U&gt; keyExtractor) Since 1.8</li>
        thenComparing(comparing(keyExtractor))와 같이 동작한다.
        <li>default Comparator&lt;T&gt; thenComparingInt(ToIntFunction&lt;? super T&gt; KeyExtractor)</li>
        thenComparing(comparingInt(keyExtractor))와 같이 동작한다. 키가 int인 경우. + Long, Double
        <li>static &lt;T extends Comparable&lt;? super T&gt;&gt; Comparator&lt;T&gt; reverseOrder() Since 1.8</li>
        자연스러운 정렬의 역 비교자를 반환.
        <li>static &lt;T extends Comparable&lt;? super T&gt;&gt; Comparator&lt;T&gt; naturalOrder() Since 1.8</li>
        <li>static &lt;T&gt; Comparator&lt;T&gt; nullsFirst(Comparator&lt;? super T&gt; comparator) Since 1.8</li>
        null은 모든 non-null 값보다 작다고 간주한다. null끼리는 서로 같다고 간주한다.
        <li>static &lt;T&gt; comparator&lt;T&gt; nullsLast(Comparator&lt;? super T&gt; comparator) Since 1.8</li>
        null이 모든 non-null 값보다 크다고 간주. null끼리는 서로 같다고 간주.
        <li>static &lt;T, U&gt; Comparator&lt;T&gt; comparing(Function&lt;? super T, ? extends U&gt; keyExtractor, Comparator&lt;? super U&gt; keyComparator) Since 1.8</li>
        정렬에 이용할 키를 생성하는 함수와, 키를 이용해 비교하는 비교자를 넘기면 둘을 포함하는 T타입 비교자를 반환.
        <li>static &lt;T, U extends Comparable&lt;? super U&gt;&gt; Comparator&lt;T&gt; comparing(Function&lt;? super T, ? extends U&gt; keyExtractor) Since 1.8</li>
        <li>static &lt;T&gt; Comparator&lt;T&gt; comparingInt(ToIntFunction&lt;? super T&gt; keyExtractor) Since 1.8 + Long, Double</li>
    </ol>
</details>

<hr>

<details>
    <summary>interface Queue&lt;E&gt; extends Collection&lt;E&gt; Since 1.5</summary>
    <ol>
        <li>boolean add(E e) : 용량이 없으면 예외 발생</li>
        <li>boolean offer(E e) : 용량 제한 있는 큐에서는 예외만 발생하는 add보다 낫다.</li>
        <li>E remove() : 앞쪽 원소 하나 제거. 없으면 예외.</li>
        <li>E poll() : 앞쪽 원소 하나 제거. 없으면 null.</li>
        <li>E element() : 앞쪽 원소 하나 제거하지 않고 가져오기. 없으면 예외.</li>
        <li>E peek() : 앞쪽 원소 하나 제거하지 않고 가져오기. 없으면 null.</li>
    </ol>
</details>

<hr>

<details>
    <summary>interface Deque&lt;E&gt; extends Queue&lt;E&gt; Since 1.6</summary>
    <ol>
        <li>void addFirst(E e) : 자리 없으면 예외</li>
        <li>void addLast(E e)</li>
        <li>boolean offerFirst(E e) : 자리 없으면 false</li>
        <li>boolean offerLast(E e)</li>
        <li>E removeFirst() : 하나 제거하고 반환. 없으면 예외</li>
        <li>E removeLast()</li>
        <li>E pollFirst() : 하나 제거하고 반환. 없으면 null</li>
        <li>E pollLast()</li>
        <li>E getFirst() : 하나 제거하지 않고 반환. 없으면 예외.</li>
        <li>E getLast()</li>
        <li>E peekFirst() : 하나 제거하지 않고 반환. 없으면 null.</li>
        <li>boolean removeFirstOccurrence(Object o)</li>
        <li>boolean removeLastOccurrence(Object o)</li>
        <li>void push(E e) : 이 deque이 표현하는 스택에 push.</li>
        <li>E pop() : 이 deque이 표현하는 스택에서 pop</li>
        <li>Iterator&lt;E&gt; descendingIterator() : iterator()와 역순</li>
    </ol>
</details>

<hr>

<details>
    <summary>interface Enumeration&lt;E&gt; Since 1.0</summary>
    <ol>
        <li>boolean hasMoreElements()</li>
        <li>E nextElement()</li>
        <li>default Iterator&lt;E&gt; asIterator() Since 9</li>
    </ol>
</details>

<hr>

<details>
    <summary>interface EventListener Since 1.1</summary>
    마커 인터페이스
</details>

<hr>

<details>
    <summary>interface Iterator&lt;E&gt; Since 1.2</summary>
    <ol>
            <li>boolean hasNext()</li>
            <li>E next()</li>
            <li>default void remove() : 마지막으로 반환된 원소를 제거. next() 호출 뒤 한 번만 호출 가능.</li>
            <li>default void forEachRemaining(Consumer&lt;? super E&gt; action) Since 1.8</li>
        </ol>
</details>

<hr>

<details>
    <summary>interface List&lt;E&gt; extends Collection&lt;E&gt; Since 1.2</summary>
    <ol>
        <li>List::of, List::copyOf 팩터리 메서드로 변경 불가능한 리스트를 만들 수 있다. 변경 불가능한 리스트는 null 원소를 허용하지 않으며, 모든 원소가 serializable하면 리스트도 그러하다. 또, value-based이므로 identity-sensitive한 연산은 피해야 된다.</li>
        <li>boolean addAll(int index, Collection&lt;? extends E&gt; c)</li>
        <li>default void replaceAll(UnaryOperator&lt;E&gt; operator) Since 1.8</li>
        모든 원소를 연산 결과로 대체
        <li>default void sort(Comparator&lt;? super E&gt; c) Since 1.8</li>
        <li>E get(int index)</li>
        <li>E set(int index, E element) : 이전 값은 반환.</li>
        <li>void add(int index, E element)</li>
        <li>E remove(int index)</li>
        <li>int indexOf(Object o)</li>
        <li>int lastIndexOf(Object o)</li>
        <li>ListIterator&lt;E&gt; listIterator()</li>
        <li>ListIterator&lt;E&gt; listIterator(int index)</li>
        <li>List&lt;E&gt; subList(int fromIndex, int toIndex)</li>
        <li>default Spliterator&lt;E&gt; spliterator() Since 1.8</li>
        <li>static &lt;E&gt; List&lt;E&gt; of() Since 9</li>
        <li>static &lt;E&gt; List&lt;E&gt; of(E e1) Since 9</li>
        <li>static &lt;E&gt; List&lt;E&gt; of(E e1, E e2) Since 9 ...</li>
        <li>@SafeVarargs static &lt;E&gt; List&lt;E&gt; of(E... elements) Since 9 : 단일 배열도 허용</li>
        <li>static &lt;E&gt; List&lt;E&gt; copyOf(Collection&lt;? extends E&gt; coll) Since 10</li>
    </ol>
</details>

<hr>

<details>
    <summary>interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt; Since 1.2</summary>
    <ol>
        <li>양방향으로 이동 가능한 iterator.</li>
        <li>boolean hasPrevious()</li>
        <li>E previous()</li>
        <li>int nextIndex()</li>
        <li>int previousIndex()</li>
        <li>void set(E e) : 마지막으로 반환된 요소를 변경</li>
        <li>void add(E e) : next()로 반환될 요소 바로전에 삽입.</li>
    </ol>
</details>

<hr>

<details>
    <summary>interface Map&lt;K, V&gt; Since 1.2</summary>
    <ol>
        <li>Map::of, Map::ofEntries, Map::copyOf 팩터리 메서드로 변경 불가능한 맵을 만들 수 있다. 변경 불가능한 맵은 키와 값 모두 null을 허용하지 않으며, 모든 키와 값이 serializable하면 맵도 그러하다. 또, value-based므로 identity-sensitive한 연산은 피해야 한다.</li>
        <li>int size()</li>
        <li>boolean isEmpty()</li>
        <li>boolean containsKey(Object key)</li>
        <li>boolean containsValue(Object value)</li>
        <li>V get(Object key)</li>
        <li>V put(K key, V value) : 이전 값은 반환된다.</li>
        <li>V remove(Object key)</li>
        <li>void putAll(Map&lt;? extends K, ? extends V&gt; m)</li>
        <li>void clear()</li>
        <li>Collection&lt;V&gt; values()</li>
        <li>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()</li>
        <li>default V getOrDefault(Object key, V defaultValue) Since 1.8</li>
        <li>default void forEach(BiConsumer&lt;? super K, ? super V&gt; action) Since 1.8</li>
        <li>default void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function) Since 1.8</li>
        모든 값을 연산 결과로 대체한다.
        <li>default V putIfAbsent(K key, V value) Since 1.8</li>
        <li>default boolean remove(Object key, Object value) Since 1.8</li>
        <li>default boolean replace(K key, V oldValue, V newValue) Since 1.8</li>
        <li>default V replace(K key, V value) Since 1.8 : key가 있을 때만 대체</li>
        <li>default V computeIfAbsent(K key, Function&lt;? super K, ? extends V&gt; mappingFunction) Since 1.8</li>
        key가 맵에 없거나, 대응하는 값이 null인 경우 새로운 값을 계산하여 넣는다. 단, 새로운 값이 null이거나 도중 예외가 발생하는 경우, 기록되지 않는다.
        <li>default V computeIfPresent(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) Since 1.8</li>
        <li>default V compute(K key, BiFUnction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) Since 1.8</li>
        <li>default V merge(K key, V value, BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) Since 1.8</li>
        key가 맵에 없거나, 대응하는 값이 null인 경우 null이 아닌 value로 연결. 그 외의 경우 주어진 함수를 통해 새로운 값에 연결하거나, 결과가 null인 경우 맵에서 제거.<br>
        예: map.merge(key, msg, String::concat)
        <li>static &lt;K, V&gt; Map&lt;K, V&gt; of() Since 9</li>
        <li>static &lt;K, V&gt; Map&lt;K, V&gt; of(K k1, V v1) Since 9 ...</li>
        <li>@SafeVarargs static &lt;K, V&gt; Map&lt;K, V&gt; ofEntries(Map.ENtry&lt;? extends K, ? extends V&gt;... entries) Since 9</li>
        Map::entry()와 함께 이용하면 맵 초기화를 편리하게 할 수 있다.
        <li>static &lt;K, V&gt; Map.Entry&lt;K, V&gt; entry(K k, V v) Since 9</li>
        <li>static &lt;K, V&gt; Map&lt;K, V&gt; copyOf(Map&lt;? extends K, ? extends V&gt; map) Since 10</li>
    </ol>
</details>

<hr>

<details>
    <summary>static interface Map.Entry&lt;K, V&gt; Since 1.2</summary>
    <ol>
        <li>K getKey()</li>
        <li>V getValue()</li>
        <li>V setValue(V value)</li>
        <li>static &lt;K extends Comparable&lt;? super K&gt;, V&gt; Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparingByKey() Since 1.8</li>
        키를 자연스러운 순서로 비교하는 비교자 반환.
        <li>static &lt;K, V extends Comparable&lt;? super V&gt;&gt; Comparator&lt;Map.Entry&lt;K, V&gt;&vt; comparingByValue() Since 1.8</li>
        <li>static &lt;K, V&gt; Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparingByKey(Comparator&lt;? super K&gt; cmp) Since 1.8</li>
        <li>static &lt;K, V&gt; Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparingByValue(Comparator&lt;? super V&gt; cmp) Since 1.8</li>
    </ol>
</details>

<hr>

<details>
    <summary>interface Set&lt;E&gt; extends Collection&lt;E&gt; Since 1.2</summary>
    <ol>
        <li>Set::of, Set::copyOf 팩터리 메서드로 변경 불가능한 집합을 만들 수 있다. 변경 불가능한 집합은 null 원소를 허용하지 않으며, 모든 원소가 serializable하면 집합도 그러하다. value-based므로 identity-sensitive한 연산은 피해야 한다.</li>
        <li>static &lt;E&gt; Set&lt;E&gt; of() Since 9</li>
        <li>static &lt;E&gt; Set&lt;E&gt; of(E e1) Since 9 ...</li>
        <li>@SafeVarargs static &lt;E&gt; Set&lt;E&gt; of(E... elements) Since 9 : 단일 배열도 인자로 가능하다.</li>
        <li>static &lt;E&gt; Set&lt;E&gt; copyOf(Collection&lt;? extends E&gt; coll) Since 10</li>
    </ol>
</details>

<hr>

<details>
    <summary>interface SortedMap&lt;K, V&gt; extends Map&lt;K, V&gt; Since 1.2</summary>
    <ol>
        <li>키가 정렬된 Map. 다음 4가지 생성자를 구현할 것을 권장. (void), (Comparator), (Map), (SortedMap)</li>
        <li>Comparator&lt;? super K&gt; comparator()</li>
        <li>SortedMap&lt;K, V&gt; subMap(K fromKey, K toKey) : toKey는 미포함</li>
        <li>SortedMap&lt;K, V&gt; headMap(K toKey)</li>
        <li>SortedMap&lt;K, V&gt; tailMap(K fromKey)</li>
        <li>K firstKey()</li>
        <li>K lastKey()</li>
    </ol>
</details>

<hr>

<details>
    <summary>interface SortedSet&lt;E&gt; extends Set&lt;E&gt; Since 1.2</summary>
    <ol>
        <li>원소가 정렬된 Set. 다음 4가지 생성자를 구현할 것을 권장. (void), (Comparator), (Collection), (SortedSet)</li>
        <li>Comparator&lt;? super E&gt; comparator()</li>
        <li>SortedSet&lt;E&gt; subSet(E fromElement, E toElement) : toElement는 미포함</li>
        <li>SortedSet&lt;E&gt; headSet(E toElement)</li>
        <li>SortedSet&lt;E&gt; tailSet(E fromElement)</li>
        <li>E first()</li>
        <li>E last()</li>
    </ol>
</details>

<hr>

<details>
    <summary>interface NavigableMap&lt;K, V&gt; extends SortedMap&lt;K, V&gt; Since 1.6</summary>
    <ol>
        <li>Map.Entry&lt;K, V&gt; lowerEntry(K key)</li>
        <li>K lowerKey(K key)</li>
        <li>Map.Entry&lt;K, V&gt; floorEntry(K key)</li>
        <li>K floorKey(K key)</li>
        <li>Map.Entry&lt;K, V&gt; ceilingEntry(K key)</li>
        <li>K ceilingKey(K key)</li>
        <li>Map.Entry&lt;K, V&gt; higherEntry(K key)</li>
        <li>K higherKey(K key)</li>
        <li>Map.Entry&lt;K, V&gt; firstEntry()</li>
        <li>Map.Entry&lt;K, V&gt; lastEntry()</li>
        <li>Map.Entry&lt;K, V&gt; pollFirstEntry() : 제거하고 반환</li>
        <li>Map.Entry&lt;K, V&gt; pollLastEntry()</li>
        <li>NavigableMap&lt;K, V&gt; descendingMap()</li>
        <li>NavigableSet&lt;K&gt; navigableKeySet()</li>
        <li>NavigableSet&lt;K&gt; descendingKeySet()</li>
        <li>NavigableMap&lt;K, V&gt; subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)</li>
        <li>NavigableMap&lt;K, V&gt; headMap(K toKey, boolean inclusive)</li>
        <li>NavigableMap&lt;K, V&gt; tailMap(K fromKey, boolean inclusive)</li>
    </ol>
</details>

<hr>

<details>
    <summary>interface NavigableSet&lt;E&gt; extends SortedSet&lt;E&gt; Since 1.6</summary>
    <ol>
        <li>E lower(E e)</li>
        <li>E floor(E e)</li>
        <li>E ceiling(E e)</li>
        <li>E higher(E e)</li>
        <li>E pollFirst() : 제거하고 반환</li>
        <li>E pollLast()</li>
        <li>NavigableSet&lt;E&gt; descendingSet()</li>
        <li>Iterator&lt;E&gt; descendingIterator()</li>
        <li>NavigableSet&lt;E&gt; subSet(E fromElement, boolean fromInclusive, E toElement, bolean toInclusive)</li>
        <li>NavigableSet&lt;E&gt; headSet(E toElement, boolean inclusive)</li>
        <li>NavigableSet&lt;E&gt; tailSet(E fromElement, boolean inclusive)</li>
    </ol>
</details>

<hr>

<details>
    <summary>interface RandomAccess Since 1.4</summary>
    빠른(보통 상수 시간) 임의 접근이 가능한 List를 표현하는 마커 인터페이스
</details>

<hr>

Formattable	
Observer
PrimitiveIterator
Spliterator