<hr>

<details>
    <summary>@FunctionalInterface interface BiConsumer&lt;T, U&gt; Since 1.8</summary>
    1. 인자 두개를 먹고 아무것도 뱉지 않는 소비자.
<br>
<br>2. void accept(T t, U u) : 적당한 동작 수행
<br>
<br>3. default BiConsumer&lt;T, U&gt; andThen(BiConsumer&lt;? super T, ? super U&gt; after) : 현재 소비자가 작업을 마치면 after가 실행되는
새로운 소비자 반환.
</details>

<hr>

<details>
    <summary>@FunctionalInterface interface BiFunction&lt;T, U, R&gt; Since 1.8</summary>
    1. 인자 두개를 먹고 값을 반환하는 함수.
<br>
<br>2. R apply(T t, U u)
<br>
<br>3. default &lt;V&gt; BiFunction&lt;T, U, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) : 함수가 실행되고 난 결과를
after가 처리하는 새로운 함수 반환.
</details>

<hr>

<details>
    <summary>@FunctionalInterface interface BinaryOperator extends BiFunction&lt;T, T, T&gt; Since 1.8</summary>
    1. 같은 타입의 인자 두개를 먹고 같은 타입의 값을 반환하는 함수.
<br>
<br>2. static &lt;T&gt; BinaryOperator&lt;T&gt; minBy(Comparator&lt;? super T&gt; comparator) : 주어진 comparator에 따라 둘 중 작은
것을 반환하는 함수를 생성.
<br>static &lt;T&gt; BinaryOperator&lt;T&gt; maxBy(Comparator&lt;? super T&gt; comparator) : 주어진 comparator에 따라 둘 중 큰 것을
반환하는 함수 생성.
</details>

<hr>

<details>
    <summary>@FunctionalInterface interface BiPredicate&lt;T, U&gt; Since 1.8</summary>
    1. 인자 두개를 먹고 가부를 판단하는 함수.
<br>
<br>2. boolean test(T t, U u)
<br>
<br>3. default BiPredicate&lt;T, U&gt; and(BiPredicate&lt;? super T, ? super U&gt; other) : A short-circuiting logical AND
of this predicate and other.
<br>default BiPredicate&lt;T, U&gt; negate()
<br>default BiPredicate&lt;T, U&gt; or(BiPredicate&lt;? super T, ? super U&gt; other) : A short-circuiting logical OR of
this predicate and other.
</details>

<hr>

<details>
    <summary>@FunctionalInterface interface BooleanSupplier Since 1.8</summary>
    1. boolean 값을 공급하는 생산자.
<br>
<br>2. boolean getAsBoolean()
</details>

<hr>

<details>
    <summary>@FunctionalInterface interface Consumer&lt;T&gt; Since 1.8</summary>
    1. 인자를 하나 먹고 아무것도 반환하지 않는 소비자.
<br>
<br>2. void accept(T t)
<br>
<br>3. default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after) : 이 소비자 다음에 after가 소비하는 병합된 소비자 반환.
</details>

<hr>

<details>
    <summary>@FunctionalInterface interface DoubleBinaryOperator Since 1.8</summary>
    1. double 두개를 먹고 double 하나를 반환하는 함수.
<br>
<br>2. double applyAsDouble(double left, double right)
</details>

<hr>

<details>
    <summary>@FunctionalInterface interface DoubleConsumer Since 1.8</summary>
    1. void accept(double value)
<br>
<br>2. default DoubleConsumer andThen(DoubleConsumer after)
</details>

<hr>

<details>
    <summary>@FunctionalInterface interface DoubleFunction&lt;R&gt; Since 1.8</summary>
    1. R apply(double value)
</details>

<hr>

<details>
    <summary>@FunctionalInterface interface DoublePredicate Since 1.8</summary>
    1. boolean test(double value)
<br>
<br>2. default DoublePredicate and(DoublePredicate other)
<br>default DoublePredicate or(DoublePredicate other)
<br>default DoublePredicate negate()
</details>

<hr>

<details>
    <summary>@FunctionalInterface interface DoubleSupplier Since 1.8</summary>
    1. double getAsDouble()
</details>

<hr>

<details>
    <summary>@FunctionalInterface interface DoubleToIntFunction Since 1.8</summary>
    1. int applyAsInt(double value)
</details>

<hr>

<details>
    <summary>@FunctionalInterface interface DoubleToLongFunction Since 1.8</summary>
    1. long applyAsLong(double value)
</details>

<hr>

<details>
    <summary>@FunctionalInterface interface DoubleUnaryOperator Since 1.8</summary>
    1. double applyAsDouble(double operand)
<br>
<br>2. default DoubleUnaryOperator compose(DoubleUnaryOperator before)
<br>default DoubleUnaryOperator andThen(DoubleUnaryOperator after)
<br>static DoubleUnaryOperator identity() : 항상 입력값 그대로 반환하는 단항 연산자 반환.
</details>

<hr>

<details>
    <summary>@FunctionalInterface interface Function&lt;T, R&gt; Since 1.8</summary>
    1. 인자 하나를 먹고 결과 하나를 뱉는 함수.
<br>
<br>2. R apply(T t)
<br>
<br>3. default &lt;V&gt; Function&V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before)
<br>default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after)
<br>static &lt;T&gt; Function&lt;T, T&gt; identity() : 입력 인자 그대로 반환하는 함수.
</details>

<hr>

<details>
    <summary>@FunctionalInterface interface IntBinaryOperator Since 1.8</summary>
    1. int applyAsInt(int left, int right)
</details>

<hr>

<details>
    <summary>@FunctionalInterface interface IntConsumer Since 1.8</summary>
    1. void accept(int value)
<br>
<br>2. default IntConsumer andThen(IntConsumer after)
</details>

<hr>

<details>
    <summary>@FunctionalInterface interface IntFunction&lt;R&gt; Since 1.8</summary>
    1. R apply(int value)
</details>

<hr>

<details>
    <summary>@FunctionalInterface interface IntPredicate Since 1.8</summary>
    1. boolean test(int value)
<br>
<br>2. default IntPredicate and(IntPredicate other)
<br>default IntPredicate or(IntPredicate other)
<br>default IntPredicate negate()
</details>

<hr>

<details>
    <summary>@FunctionalInterface interface IntSupplier Since 1.8</summary>
    1. int getAsInt()
</details>

<hr>

<details>
    <summary>@FunctionalInterface interface IntToDoubleFunction Since 1.8</summary>
    1. double applyAsDouble(int value)
</details>

<hr>

<details>
    <summary>@FunctionalInterface interface IntToLongFunction Since 1.8</summary>
    1. long applyAsLong(int value)
</details>

<hr>

<details>
    <summary>@FunctionalInterface interface IntUnaryOperator Since 1.8</summary>
    1. int applyAsInt(int operand)
<br>
<br>2. default IntUnaryOperator compose(IntUnaryOperator before)
<br>default IntUnaryOperator andThen(IntUnaryOperator after)
<br>static IntUnaryOperator identity()
</details>

<hr>

<details>
    <summary>@FunctionalInterface interface LongBinaryOperator Since 1.8</summary>
    1. long applyAsLong(long left, long right)
</details>

<hr>

<details>
    <summary>@FunctionalInterface interface LongConsumer Since 1.8</summary>
    1. void accept(long value)
<br>
<br>2. default LongConsumer andThen(LongConsumer after)
</details>

<hr>

<details>
    <summary>@FunctionalInterface interface LongFunction&lt;R&gt; Since 1.8</summary>
    1. R apply(long value)
</details>

<hr>

<details>
    <summary>@FunctionalInterface interface LongPredicate Since 1.8</summary>
    1. boolean test(long value)
<br>
<br>2. default LongPredicate and(LongPredicate other)
<br>default LongPredicate or(LongPredicate other)
<br>default LongPredicate negate()
</details>

<hr>

<details>
    <summary>@FunctionalInterface interface LongSupplier Since 1.8</summary>
    1. long getAsLong()
</details>

<hr>

<details>
    <summary>@FunctionalInterface interface LongToDoubleFunction Since 1.8</summary>
    1. double applyAsDouble(long value)
</details>

<hr>

<details>
    <summary>@FunctionalInterface interface LongToIntFunction Since 1.8</summary>
    1. int applyAsInt(long value)
</details>

<hr>

<details>
    <summary>@FunctionalInterface interface LongUnaryOperator Since 1.8</summary>
    1. long applyAsLong(long operand)
<br>
<br>2. default LongUnaryOperator compose(LongUnaryOperator before)
<br>default LongUnaryOperator andThen(LongUnaryOperator after)
<br>static LongUnaryOperator identity()
</details>

<hr>

<details>
    <summary>@FunctionalInterface interface ObjDoubleConsumer&lt;T&gt; Since 1.8</summary>
    1. void accept(T t, double value)
</details>

<hr>

<details>
    <summary>@FunctionalInterface interface ObjIntConsumer&lt;T&gt; Since 1.8</summary>
    1. void accept(T t, int value)
</details>

<hr>

<details>
    <summary>@FunctionalInterface interface ObjLongConsumer&lt;T&gt; Since 1.8</summary>
    1. void accept(T t, long value)
</details>

<hr>

<details>
    <summary>@FunctionalInterface interface Predicate&lt;T&gt; Since 1.8</summary>
    1. boolean test(T t)
<br>
<br>2. default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other)
<br>default Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other)
<br>static &lt;T&gt; Predicate&lt;T&gt; isEqual(Object targetRef) : Object.equals(Object, Object)를 이용해 비교하는 Predicate 반환
</details>

<hr>

<details>
    <summary>@FunctionalInterface interface Supplier&lt;T&gt; Since 1.8</summary>
    1. T get()
</details>

<hr>

<details>
    <summary>@FunctionalInterface interface ToDoubleBiFunction&lt;T, U&gt; Since 1.8</summary>
    1. double applyAsDouble(T t, U u)
</details>

<hr>

<details>
    <summary>@FunctionalInterface interface ToDoubleFunction&lt;T&gt; Since 1.8</summary>
    1. double applyAsDouble(T value)
</details>

<hr>

<details>
    <summary>@FunctionalInterface interface ToIntBiFunction&lt;T, U&gt; Since 1.8</summary>
    1. int applyAsInt(T t, U u)
</details>

<hr>

<details>
    <summary>@FunctionalInterface interface ToIntFunction&lt;T&gt; Since 1.8</summary>
    1. int applyAsInt(T value)
</details>

<hr>

<details>
    <summary>@FunctionalInterface interface ToLongBiFunction&lt;T, U&gt; Since 1.8</summary>
    1. long applyAsLong(T t, U u)
</details>

<hr>

<details>
    <summary>@FunctionalInterface interface ToLongFunction&lt;T&gt; Since 1.8</summary>
    1. long applyAsLong(T value)
</details>

<hr>

<details>
    <summary>@FunctionalInterface interface UnaryOperator&lt;T&gt; extends Function&lt;T, T&gt; Since 1.8</summary>
    1. static &lt;T&gt; UnaryOperator&lt;T&gt; identity()
</details>

<hr>
