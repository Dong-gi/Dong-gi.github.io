<hr>

<details>
    <summary>Attribute</summary>
    <ol>
        <button type="button" class="btn btn-primary btn-sm btn-code" path="VS/CSharp/Basic/AttributeExample.cs"
            lan="cs">AttributeExample.cs 전체 코드 »</button>
        <li>사용자 정의 특성은 System.Attribute를 상속하여 만든다.</li>
        <button type="button" class="btn btn-primary btn-sm btn-code" path="VS/CSharp/Basic/AttributeExample.cs"
            displayRange="[12, 19]" lan="cs">AttributeExample.cs »</button>
        <li>명명시 Attribute를 접미하고, 실제 사용시에는 "Attribute"는 생략 가능하다.</li>
        <button type="button" class="btn btn-primary btn-sm btn-code" path="VS/CSharp/Basic/AttributeExample.cs"
            displayRange="[21, 24]" lan="cs">AttributeExample.cs »</button>
        <li>특성을 적용할 수 있는 대상 제한</li>
        System.AttributeUsage 생성자에 AttributeTargets 전달. 생략시 기본값은 AttributeTargets.All. 여러 대상에 적용된다면
        AttributeTargets.Field | AttributeTargets.Method처럼 |를 이용.
        <li>적용하는 대상 명시</li>
        어셈블리에 적용하는 경우(AttributeTargets.Assembly), 반환값에 적용하는 경우(AttributeTargets.ReturnValue)와 같이, 특성이 적용될 대상을 자동으로 특정해내지
        못하는 경우엔 이를 명시해줄 수 있다.<br>
        assembly, module, type, method, property, field, event, param, return, typevar
    </ol>
</details>

<hr>

<details>
    <summary>checked/unchecked 블록</summary>
    <ol>
        <li>기본적으로는 프로그램 실행 시 오버플로/언더플로를 무시한다.</li>
        <li>checked/unchecked 블록은 이를 각각 명시적인 예외로 처리/비처리 하도록 한다.</li>
        <button type="button" class="btn btn-primary btn-sm btn-code" path="VS/CSharp/Basic/CheckedExample.cs"
            displayRange="[13, 39]" lan="cs">예시 코드 »</button>
    </ol>
</details>

<hr>

<details>
    <summary>가변 길이 매개변수 params</summary>
    <button type="button" class="btn btn-primary btn-sm btn-code" path="VS/CSharp/Basic/ParamsExample.cs"
        displayRange="[11, 17]" lan="cs">예시 코드 »</button>
</details>

<hr>

<details>
    <summary>extern</summary>
    <ol>
        <li>메서드의 body가 없어도 컴파일 되도록 한다.</li>
        <li>호출할 메서드가 있는 dll을 DllImport 특성으로 지정해주면 해당 메서드를 호출한다</li>
        <li>http://www.pinvoke.net/</li>
    </ol>
</details>

<hr>

<details>
    <summary>unsafe</summary>
    <ol>
        <li>unsafe를 지정한 블록, 클래스에서는 포인터를 사용할 수 있다.</li>
        <li>컴파일 시 /unsafe 옵션을 지정해야 한다. 비주얼 스튜디오는 프로젝트 속성 - 빌드 - 안전하지 않은 코드 허용</li>
        <li>System.Runtime.InteropServices.Marshal</li>
    </ol>
</details>

<hr>

<details>
    <summary>fixed</summary>
    <ol>
        <li>unsafe한 코드에 참조 변수(의 일부)를 보내야 하는 경우, 블록이 끝날 때까지 힙 영역에서 해당 객체의 주소를 고정시킨다.</li>
        <li>참조 변수 자체에 fixed를 적용할 수는 없고, 필드의 일부를 "int* pValue = &obj.field"처럼 지정하여 사용</li>
    </ol>
</details>

<hr>

<details>
    <summary>stackalloc</summary>
    값 형식의 배열을 스택에 할당하도록 한다<br>
    int* pArray = stackalloc int[12];
</details>

<hr>

<details>
    <summary>app.config</summary>
    <ol>
        <li>supportedRuntime</li>
        실행에 필요한 닷넷 버전 지정. 비주얼 스튜디오가 자동으로 추가해주는듯
        <button type="button" class="btn btn-primary btn-sm btn-code" path="VS/CSharp/Basic/App.config"
            lan="xml">App.config »</button>

        <li>appSettings</li>
        <button type="button" class="btn btn-primary btn-sm btn-code" path="VS/CSharp/Basic/App.config"
            lan="xml">App.config »</button>
        <button type="button" class="btn btn-primary btn-sm btn-code" path="VS/CSharp/Basic/Program.cs"
            lan="cs">Program.cs »</button>
    </ol>
</details>

<hr>

<details>
    <summary>디버그 모드에서만 실행되는 코드</summary>
    <ol>
        <li>전처리 상수</li>
        #if DEBUG ... #endif

        <li>Conditional 특성</li>
        [Conditional("DEBUG")] : 적용된 클래스, 메서드는 릴리스 빌드 시 포함되지 않는다

        <li>System.Diagnostics.Debug</li>
        Debug.WriteLine() : 디버그 출력 창에 출력된다
    </ol>
</details>

<hr>

<details>
    <summary>서명</summary>
    <ol>
        <li>Strong-named Assembly</li>
        어셈블리 이름 + 버전 + 문화권 + 공개키 토큰

        <li>서명 절차</li>
        비주얼 스튜디오 프로젝트 속성 - 서명
    </ol>
</details>

<hr>

<details>
    <summary>예외</summary>
    <ol>
        <li>try {} catch {} finally {}</li>
        <li>try {} catch (ExceptionType) {}</li>
        <li>try {} catch (ExceptionType) { throw; }</li>
        <li>try {} catch (ExceptionType e) {}</li>
        <li>try {} finally { iDisposable.Dispose(); } == using(var iDisposable = ~)</li>
        https://docs.microsoft.com/ko-kr/dotnet/api/system.idisposable?view=netframework-4.8
    </ol>
</details>

<hr>




<ol>
    <li>var</li>
    ● 지역변수 초기화시에만 사용 가능한 자동형식

    <li>dynamic</li>
    ● 타입 검사를 런타임에 한다.<br>
    ● COM 컴포넌트와 .NET 사이의 상호 운용을 위해, 동적 언어와의 상호 운용을 위해 추가.


    <li>메서드 매개변수 제어</li>
    ● ref : 참조에 의한 호출.<br>
    ● out : 쓰기 전용 매개변수. 호출 전에 초기화되지 않아도 되며, 종료 전에 할당이 이루어져야 한다.<br>
    ● 매개변수 명시 : Divide(a: 10, b: 3, q: out q, r: out r);<br>
    ● 선택적 매개변수 : Method(int a = 0, int b = 0) {}

    <li>확장 메서드</li>
    ● 기존 클래스에 static method 추가.<button type="button" class="btn btn-primary btn-sm btn-code"
        path="VS/CSharp/Basic/ExtensionExample.cs" lan="cs">ExtensionExample.cs »</button>

    <li>readonly</li>
    ● 읽기 전용 필드 선언<br>
    ● readonly struct : 모든 필드가 readonly인 struct<br>
    ● ref readonly : 메서드에서 반환된 참조를 읽기만 가능

    <li>인덱서</li>
    ● 오버로딩 가능.<br>
    ● 접근제한자 리턴_타입 this[인덱스_타입 인덱스_식별자] { get {} set {} }<br>
    ● 읽기 전용 : 리턴_타입 this[인덱스_타입 인덱스_식별자] => {}<br>
    ● string은 인덱서를 구현함.<button type="button" class="btn btn-primary btn-sm btn-code"
        path="VS/CSharp/Basic/IndexerExample.cs" lan="cs">IndexerExample.cs »</button>

    <li>전처리 지시문</li>
    ● #define, #undef, #if, #elif, #else, #endif...<br>
    ● #region, #endregion...

    <li>nullable</li>
    <button type="button" class="btn btn-primary btn-sm btn-code" path="VS/CSharp/Basic/NullableExample.cs"
        lan="cs">NullableExample.cs
        »</button>

    <li>System.Array</li>
    ● Sort(), BinarySearch&lt;T&gt;(), IndexOf(), TrueForAll&lt;T&gt;(), FindIndex&lt;T&gt;()Resize&lt;T&gt;(),
    Clear(), ForEach&lt;T&gt;(), GetLength(), Length, Rank

    <li>ICollection</li>
    ● ArrayList : Add(), RemoveAt(), Insert()<br>
    ● Queue : Enqueue(), Dequeue()<br>
    ● Stack : Push(), Pop()<br>
    ● Hashtable<br>
    var hash = new Hashtable();<br>
    hash["one"] = 1;<br>
    hash[2] = true;

    <li>무명 형식</li>
    ● 초기화 이후 읽기만 가능한 일회용 객체. LINQ에 유용하게 쓰임.<br>
    var instance = new { Name = "name", Age = 10 };

    <li>LINQ</li>
    ● LINQ; Language INtegrated Query<br>
    ● from // LINQ query는 from으로 시작한다. from의 대상은 IEnumarable&lt;T&gt;<br>
    ● where + bool 판정식<br>
    ● orderby + 정렬 기준 [(ascending) | descending]<br>
    ● select + 결과<br>
    ● let : LINQ 내에서 변수 선언. let x = 10
    ● LINQ query 결과는 IEnumerable&lt;T&gt;<br><br>

    var xElement = XElement.Load(url); // URL로부터 XML 로드<br>
    var xmlQuery =<br>
    　　from item in xElement.Descendants("data") // 태그 추출<br>
    　　select new {<br>
    　　　　Hour = item.Element("hour").Value,<br>
    　　　　Minute = item.Element("minute").Value<br>
    　　};<br>
    // 속성 추출 : item.Attribute("속성명").Value or item.Attribute["속성명"].Value<br><br>

    ● 중첩 질의<br>
    from student in students<br>
    　　from score in student.Scores<br><br>

    ● Grouping<br>
    결과는 IGrouping&lt;T&gt; 형식<br>
    from p in profiles<br>
    group p by p.Height &lt; 160 into lowGroup<br>
    select new { Key = lowGroup.Key, Profiles = lowGroup };<br><br>

    ● Inner Join<br>
    from a in A<br>
    join b in B<br>
    on a.X equals b.Y<br><br>

    ● Outer Join<br>
    inner join 결과를 임시 컬렉션으로 치환하고, 임시 컬렉션의 빈 항목을 기본 값으로<br>
    from profile in profiles<br>
    join product in products<br>
    on profile.Name equals product.Name into result<br>
    from product in result.DefaultIfEmpty( new Product() { Title = "없음” } )<br>
    select new { Name = profile.Name, Work = product.Title };

    <li>Expression Tree</li>
    ● System.Linq.Expressions 네임스페이스의 Expression 클래스 및 파생 클래스들<br><br>

    var const1 = Expression.Constant(1);<br>
    var param1 = Expression.Parameter(typeof(int), "x");<br>
    var exp = Expression.Add(const1, param1);<br>
    var lambda = Expression&lt;Func&lt;int, int&gt;&gt;.Lambda&lt;Func&lt;int, int&gt;&gt;(exp, new
    ParameterExpression[] { (ParameterExpression)param1 });<br>
    var compiledFunc = lambda.Compile();<br>
    Console.WriteLine(compiledFunc(3));

    <li>리플렉션 Reflection</li>
    ● Object.getType() or typeof 연산자<br>
    ● Type :: GetConstructors(), GetEvents(), GetFields(), GetMethods(), ...<br>
    ● 동적 생성 : System.Activator.CreateInstance(Type);<br>
    ● 동적 정의 : System.Reflection.Emit<br>
    1. System.AppDomain.DefineDynamicAssembly()로 AssemblyBuilder 객체 획득<br>
    2. AssemblyBuilder.DefineDynamicModule()로 ModuleBuilder 획득<br>
    3. ModuleBuilder.DefineType()으로 클래스 생성(TypeBuilder)<br>
    4. TypeBuilder.DefineMethod()로 MethodBuilder 획득<br>
    5. MethodBuilder.GetILGenerator()로 ILGenerator 객체 획득<br>
    6. ILGenerator.Emit()으로 메서드 내용 추가<br>
    7. TypeBuilder.CrateType()으로 인스턴스 생성 가능

    <li>Caller Information</li>
    ● 메서드 매개변수 정의시 사용 가능.<br>
    [CallerFilePath] string filePath = "", [CallerLineNumber] int line = 0, [CallerMemberName] string member = ""

    <li>System.IO</li>
    ● File : 클래스 메서드<br>
    FileInfo : 객체 메서드<br>
    Directory : 클래스 메서드<br>
    DirectoryInfo : 객체 메서드<br><br>

    ● System.IO.Stream<br>
    FileStream, NetworkStream, GZipStream, BufferedStream, ...<br><br>

    ● 바이트<br>
    자료를 바이트 배열로 : BitConverter.GetBytes()<br>
    바이트 배열을 long으로 : BitConverter.ToInt64()<br>
    Little Endian인지 Big Endian인지 고려 필요<br><br>

    ● IO<br>
    new BinaryWriter(new FileStream("a.txt", FileMode.Create));<br>
    new BinaryReader(new FileStream("a.txt", FileMode.Open));<br>
    Text : StreamWriter, StreamReader<br><br>

    ● 직렬화<br>
    class MyClass { [NonSerialized] int a; }<br>
    var bf = new BinaryFormatter();<br>
    bf.Serialize(/* stream */, new MyClass());<br>
    // bf.Deserialize(/* stream */);

    <li>System.Threading</li>
    ● var t = new Thread(new ThreadStart(DoSomething));<br>
    t.Start();<br>
    // t.Abort(); 스레드 상태와 관계없이 종료. 지양<br>
    // t.Join();<br>
    // t.Interrupt(); 스레드가 WaitJoinSleep 상태일 때 종료<br><br>

    ● 스레드 간 동기화<br>
    lock (/* object */) { /* 블록이 끝날 때까지 다른 스레드는 접근 불가 */ }<br><br>

    Monitor.Enter(/* ojbect */);<br>
    try {} finally{ Monitor.Exit(/* object */); } // lock 블록과 동일<br>
    - Monitor.Wait() : 스레드를 WaitSleepJoin 상태로 만들고 lock을 해제한 뒤 Waiting Queue에 들어간다.<br>
    - Monitor.Pulse() : Waiting Queue의 첫 요소를 Ready Queue로 입력.<br>
    위 두 메서드는 lock 블록 안에서 호출되어야 한다.<br><br>

    readonly object myLock = new object();<br>
    bool isDone = false;<br>
    lock (myLock)<br>
    {<br>
    　　while(!isDone) { Monitor.Wait(myLock); }<br>
    　　isDone = false;<br>
    　　// ToDo<br>
    　　isDone = true;<br>
    　　Monitor.Pulse(myLock);<br>
    }<br><br>

    ● 비동기 처리 System.Threading.Tasks.Task<br>
    Action action = () => { Thread.Sleep(1000); Console.WriteLine("Async"); };<br>
    Task task = new Task(action);<br>
    task.start();<br>
    Console.WriteLine("Hello");<br>
    task.Wait();<br>
    Console.WriteLine("World");<br><br>

    var task = Task.Run(() => { Thread.Sleep(1000); Console.WriteLine("Async"); });<br>
    Console.WriteLine("Hello");<br>
    task.Wait();<br>
    Console.WriteLine("World");<br><br>

    ● 비동기 실행 결과 취합 Task&lt;TResult&gt:<br>
    var task = Task&lt;List&lt;int&gt;&gt;.Run(() => {<br>
    　　Thread.Sleep(1000);<br>
    　　var list = new List&lt;int&gt;();<br>
    　　list.Add(3);<br>
    　　return list;<br>
    });<br>
    var myList = new List&lt;int&gt;(new int[] { 1 });<br>
    task.Wait();<br>
    myList.AddRange(task.Result);<br><br>

    ● 병렬 처리 System.Threading.Tasks.Parallel<br>
    void DoSomething(int i) =&gt; Console.WriteLine(i);<br>
    Parallel.For(0, 100, DoSomething);<br><br>

    ● asyne 한정자 + await 연산자<br>
    - async로 한정한 void 리턴 메서드는 await없이 비동기 실행<br>
    - async로 한정한 Task 또는 Task&lt;TResult&gt; 반환 메서드/태스크/람다식은 await 연산자를 만나는 곳에서 호출자에게 제어를 넘겨주며, await 연산자가 없으면 동기적으로
    실행된다.<br>
    - await Task.Delay() : 입력시간 후 태스크 반환. 스레드를 블록시키지 않음<br>
    - .NET Framework 4.5에 ~Async() API 추가
</ol>