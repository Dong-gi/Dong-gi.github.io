<ul>
    <li>클래스</li>
    ● 필드 + 메서드<br>
    ● 정적 생성자 : 자바의 정적 초기화 필드와 같은 의미<br>
    static 클래스이름() { /* 문장 */ }<br>
    ● namespace : 자바의 패키지와 비슷<br>
    namespace MyProgram.Model { }<br>
    using System.Collections.Generic;

    <li>접근 제한자</li>
    public, protected(파생 클래스까지), private, internal(같은 어셈블리), protected internal

    <li>상속</li>
    ● SubClass : SuperClass<br>
    ● sealed : 상속/재정의 불가<br>
    ● 부모 클래스 인스턴스를 자식 클래스로 다운캐스팅 불가.<br>
    ● 모든 자료형의 조상은 System.Object, 모든 값 형식의 조상은 System.ValueType, 모든 배열의 조상은 System.Array<br>
    Object : ToString(), GetType() == typeof, Equals(), GetHashCode()<br>
    Array : Rank, Length, Sort(), Copy()<br>
    ● this, base // 자바와 같이 클래스명.this 불가

    <li>다형성</li>
    ● virtual, override 키워드를 사용해 명시한다. virtual 메서드는 body를 정의해야 한다.<br>
    ● abstract class : 인스턴스화 불가. 생성자는 가질 수 있음.<br>
    abstract method : 자식 클래스에서 반드시 override. body를 가질 수 없음.
    ● 연산자 오버로딩<br>
    public static 타입 operator 연산자(타입1 변수1, 타입2 변수2) {}<br>
    오버로딩 가능 연산자 : +, -, !, ~, ++, --, true, false, *, /, %, &amp;, |, ^, &lt;&lt;, &gt;&gt;, ==, !=, &lt;, &gt;, &lt;=, &gt;=<br>
    +, - 등을 오버로딩하면 복합 대입 연산자도 사용 가능.<br>
    ● 형 변환 정의<br>
    public static implicit operator 타입2(타입1 변수1) {};<br>
    public static explicit operator 타입2(타입1 변수1) {};<br>

    <li>델리게이트</li>
    ● 메서드를 참조하는 자료형<br>
    ● 선언 : 접근제한자 delegate 반환타입 식별자(매개변수);<br>
    ● 익명 델리게이트<br>
    식별자 = delegate(타입1 변수1, ...) { /* 문장 */ }<br>
    ● 람다<br>
    (변수1, ...) => { /* 문장 */ }<br><br>
    
    delegate void VoidDelegate();<br>
    var voidDelegate = new VoidDelegate(() => { Console.WriteLine("1"); });<br>
    voidDelegate += obj.Func; // Delegate Chain<br>
    voidDelegate();<br>
    voidDelegate -= obj.Func;<br>

    <ul>
        <li>Func</li>
        ● 결과를 반환하는 메서드를 참조하는, 미리 정의된 델리게이트.<br>
        ● 매개변수 0 ~ 16개, 총 17가지가 있다.

        <li>Action</li>
        ● 결과를 반환하지 않는 메서드를 참조하는, 미리 정의된 델리게이트.<br>
        ● 매개변수 0 ~ 16개, 총 17가지가 있다.

        <li>이벤트</li>
        ● 일반화된 델리게이트. 간단하게 구독/해지 가능. 클래스 밖에서 호출 불가.<br>
        ● 이벤트의 첫 번째 인자는 이벤트 발생 객체. 두 번째 인자는 EventArgs 호환 객체.<br>
        ● 접근제한자 event EventHandler 식별자;<button type="button" class="btn btn-primary btn-sm btn-code" path="VS/CSharp/Basic/EventExample.cs" lan="cs">EventExample.cs »</button>
    </ul>

    <li>인터페이스</li>
    class SubClass : SuperClass, Interface1, Interface2, ...<br>
    interface Interface1 : Interface2<br><br>

    int IComparer.Compare(object x, object y);<br>
    void IDisposable.Dispose();<br>
    IEnumerator IEnumerable.GetEnumerator();<br>
    object IEnumerator.Current { get; }<br>
    bool IEnumerator.MoveNext();<br>
    void IEnumerator.Reset();<br>

    <li>구조체 struct</li>
    사용자 정의 ValueType : ValueType이므로 생성자 호출 없이 선언만으로 초기화가 진행된다. 이때 사용되는 기본 생성자는 컴파일러가 자동으로 추가하며, 재정의할 수 없다.<br>
    모든 타입은 Object의 파생 클래스이므로, 구조체도 new 키워드로 인스턴스를 생성할 수 있다. 인자를 받는 생성자는 모든 필드를 초기화해야 한다.<br>
    ValueType이므로 할당 시 깊은 복사가 이루어진다.

    <li>열거형 enum</li>
    정수형을 상속받아 정의할 수 있는 ValueType. 기본 int<br><br>

    [Flags] // 열거형을 비트필드로 이용하는 애트리뷰트<br>
    enum Days { SUN = 1, MON = 2, TUE = 4, WED = 8, THU = 16, FRI = 32, SAT = 64}<br>
    Days weekends = Days.SUN | Days.SAT;<br>
    Console.WriteLine(weekends.HasFlag(Days.SUN));
</ul>