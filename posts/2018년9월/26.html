<ol>
    <li>Java Platform Module System(JPMS) 도입
        <ol>
            <li>모듈 : 패키지 집합의 응집도가 충분하다면, 모듈로 그룹화될 수 있다.
                <ul>
                    <li>Ordinary compilation unit; 일반 컴파일 단위(일반 .java 파일) : [패키지 정의] {임포트 선언} {타입(클래스, 인터페이스 등) 정의}</li>
                    <li>이름 있는 모듈에 연관되지 않는 ordinary compilation unit들은 모두 하나의 익명 모듈에 연관된다.</li>
                </ul>
            </li>
            <li>모듈 컴파일 단위 : {임포트 선언} 모듈 정의</li>
            <li>모듈 정의 : {Annotation} [open] module ModuleName { {ModuleDirective} }
                <ul>
                    <li>모듈 이름은 패키지처럼 하나 이상의 자바 식별자를 '.'으로 구분하여 나타낸다.</li>
                    <li>open 한정자가 없으면 일반 모듈 : 컴파일타임과 런타임에 명시적으로 export된 패키지들에 대한 권한만 외부에 부여</li>
                    <li>open 한정자가 있는 열린 모듈 : 컴파일타임엔 명시적으로 export된 것만, 런타임엔 모든 패키지에 대한 권한을 외부에 부여</li>
                    <li>Reflection을 통해서도 같은 접근 권한을 얻을 수 있다.</li>
                </ul>
            </li>
            <li>모듈 명세 ModuleDirective
                <ul>
                    <li>requires { RequiresModifier } ModuleName; // 모듈 의존성</li>
                    <li>exports PackageName [to ModuleName {, ModuleName}]; // 외부에서 접근할 수 있는 패키지</li>
                    <li>opens PackageName [to ModuleName {, ModuleName}]; // 외부에서 접근할 수 있는 패키지</li>
                    <li>uses TypeName; // 사용하는 서비스</li>
                    <li>provides TypeName with TypeName {, TypeName}; // 제공하는 서비스</li>
                </ul>
            </li>
            <li>RequiresModifier : transitive | static
                <br>- transitive : 외부에서 의존하는 모듈은 transitive 키워드가 붙은 모듈도 의존한다.
                <br>- static : 컴파일 타임엔 항상 의존성을 갖고, 런타임엔 선택적.</li>
            <li>java.base 모듈은 최상의 모듈로, 아무런 의존성이 없다.</li>
        </ol>
    </li>
    <li>모듈 예시 코드. 참조 : https://wiki.eclipse.org/Java9/Examples
        <ol>
            <li>먼저, 결과물의 디렉터리 구조를 보면 src 루트에 module-info.java가 존재함을 볼 수 있다.
                <br>
                <img class="rounded mx-auto d-block" alt="" src="imgs/20180827_230700.png" />
                <button type="button" class="btn btn-primary btn-sm btn-code" path="Java/TestModule1/src/module-info.java" lan="java">TestModule1/src/module-info.java »</button>
            </li>
            <li>second라는 이름의 모듈이 필요함을 정의했고, second 모듈을 찾기 위해서 TestModule2 프로젝트를 참조하도록 설정해야 한다.
                <br>
                <img class="rounded mx-auto d-block" alt="" src="imgs/20180827_230710.png" />
            </li>
            <li>second 모듈에서는 hello 패키지를 외부에서 사용할 수 있게 정의.
                <button type="button" class="btn btn-primary btn-sm btn-code" path="Java/TestModule2/src/module-info.java" lan="java">TestModule2/src/module-info.java »</button>
            </li>
            <li>
                <button type="button" class="btn btn-primary btn-sm btn-code" path="Java/TestModule2/src/hello/HelloWorld.java" lan="java">hello.HelloWorld »</button>
                <button type="button" class="btn btn-primary btn-sm btn-code" path="Java/TestModule1/src/test/Test.java" lan="java">를 first 모듈에서 사용하는 예 »</button>
            </li>
        </ol>
    </li>
    <li>REPL로 JShell이 추가되었다 : 코드를 한줄씩 실행하면서 검사할 수 있다.
        <br>https://docs.oracle.com/javase/9/jshell/toc.htm</li>
    <li>Collection factory method 추가 : List.of(...) 등</li>
    <li>try-with-resources 구문 변동 : final한(final 변수 or 변수 초기화 후 변경 없음) resource는 별개의 선언 없이 그대로 이용할 수 있다.
        <button type="button" class="btn btn-primary btn-sm btn-code" path="Java/기초/src/io/github/donggi/TryWithResources.java" lan="java">예시 코드 »</button>
    </li>
    <li>타입 추론 강화로 diamond 연산자 &lt;&gt;가 익명 클래스도 지원</li>
    <li>"_"는 더 이상 유효한 식별자가 아니게 되었다.</li>
    <li>private 인터페이스 메서드 지원</li>
</ol>