<html lang="ko"><head><script id="google-analytics" src="https://www.googletagmanager.com/gtag/js?id=UA-143098403-1" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-143098403-1');
</script><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="google-site-verification" content="aH-DyzdytYQ0NPHNQFcs5dVoiu5YNs6CEEHYgqDmAFM"><meta name="author" content="Donggi Kim &lt;hi.donggi@gmail.com&gt;"><meta name="keywords" content="Spring WebFlux, WebClient, WebSocket, RSocket"><meta name="description" content="Spring Reactive 정리"><title>Spring Reactive</title><link id="w3css" rel="stylesheet" href="/source/w3.css"><link id="highlight-style" rel="stylesheet" href="/source/xcode.css"><link id="default-style" rel="stylesheet" href="/source/default.css"><script id="highlight-js" src="/source/highlight.pack.js"></script><script id="default-js" src="/source/default.min.js"></script><script id="dsq-count-scr" src="//donggi.disqus.com/count.js" async></script></head><body><div class="w3-bar-block w3-sidebar w3-animate-left" id="sidebar"><hr><a class="w3-bar-item w3-button" href="javascript:closeSidebar();">Close &times;</a><hr><div id="marker-list"></div><hr><div id="post-list"></div><hr><div id="file-list"></div><hr></div><div id="main"><div class="w3-bar w3-blue w3-large" id="nav" style="position:-webkit-sticky;position:sticky;top:0px;vertical-align:middle"><button class="w3-bar-item w3-button w3-hover-theme" onclick="toggleSidebar()">&#9776;</button><input class="w3-bar-item" id="query" type="text" placeholder="search" style="max-width:35%"><a class="w3-bar-item w3-button w3-hover-theme" href="/">Home</a></div><div class="w3-padding" id="contents"><h1>Web on Reactive Stack</h1><div><h2>개요</h2><ul><li>원본 문서 : <a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html">web-reactive.html</a></li><li>작업 기준 버전 : 5.3.5</li><li>논블로킹 서버(Netty, Undertow, Servlet 3.1+) 위에서 리액티브 스트림 API 기반의 리액티브-스택 웹앱에 관한 사항을 다룬다</li></ul><h2>리액티브 스트림</h2><div><h3>java.util.concurrent.Flow Since 9 <a class="w3-btn w3-round-xxlarge w3-small w3-green goto" href="java.base.html#pos-1912716076" target="_blank">Goto - reactive-stream</a></h3><ul><li>Publisher : 발행자. subscribe​(Subscriber)</li><li>Subscriber : 구독자. onSubscribe(Subscription), onNext(T), onError(Throwable), onComplete(Void)</li><li>Subscription : 구독. request(long), cancel(Void)</li><li>Processor extends Subscriber, Publisher : 발행자 + 구독자</li></ul><h3><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://projectreactor.io/">리액터</a>의 발행자 Processor</h3><ul><li>reactor.core.publisher.Mono : 0..1개의 이벤트 발행</li><li>reactor.core.publisher.Flux : 0..n개의 이벤트 발행</li></ul><h3>예시 코드</h3><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/reactive-webflux/pom.xml" lan="xml">pom.xml</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/reactive-webflux/src/main/java/io/github/donggi/controller/HelloController.java" lan="java">HelloController.java</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/reactive-webflux/src/test/java/io/github/donggi/controller/HelloControllerTest.java" lan="java">HelloControllerTest.java</button><div class="w3-center w3-margin-bottom"><img class="w3-round" src="/imgs/20191008_110029.png"></div></div></div><h1>Spring WebFlux</h1><div><h2>Overview</h2><ul><li>개발 이유 1 : 더 적은 스레드와 하드웨어 리소스로 동시성을 처리하는 논-블로킹 웹 스택이 필요했기 때문</li><p>Servlet 3.1에서 논-블로킹 I/O를 제공했지만, 다른 여타 동기적 또는 블로킹하는 서블릿 API와 같이 사용하기는 어려움이 있다. 이에 여느 논-블로킹 런타임과도 동작할 수 있는 공통 API의 수요가 생겼다</p><li>개발 이유 2 : Java 8에 도입된 람다를 활용할 수 있는 함수형 엔드포인트 개발을 위해</li></ul><div><h3>Define "Reactive"</h3><ul><li>리액티브 ::= 변화에 반응하는 것을 중심으로 한 프로그래밍 모델 - I/O 이벤트, UI 이벤트 등</li><li>스프링 팀은 여기에 "논-블로킹 back pressure"를 주요 매커니즘으로 더했다</li><p>생산자가 소비자를 호출하는 경우, 빠른 생산으로 생산자가 소비자를 압도할 수 있다. WebFlux는 리액티브 스트림을 이용하여, subscriber가 publisher 속도를 제어하도록 한다</p><li>Publisher의 속도를 늦츨 수 없다면?</li><p>리액티브 스트림은 잉여 생산물에 대한 규정은 하지 않는다. 버퍼에 담을 지, 버릴 지, 실패로 처리할 지는 개발자가 결정해야 한다</p></ul><h3>Reactive API</h3><p>리액티브 스트림의 저수준 API를 사용자가 직접 이용하기에는 부적절하다. 이에 WebFlux는 <a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://projectreactor.io/">리액터</a>를 채택하였다</p><h3>Programming Models</h3><p>WebFlux는 HTTP 추상화, 지원 서버(Netty 등)를 위한 <a class="w3-btn w3-round-xxlarge w3-small w3-green goto" href="#pos-1079810686" target="_self">Goto - HttpHandler</a>, Servlet API에 대응하는 <a class="w3-btn w3-round-xxlarge w3-small w3-green goto" href="#pos-1956235184" target="_self">Goto - WebHandler API</a> 등을 포함하며, 이를 기초로 2가지 프로그래밍 모델을 지원한다</p><ul><li><a class="w3-btn w3-round-xxlarge w3-small w3-green goto" href="#pos1285343375" target="_self">Goto - Annotated Controllers</a></li><p>Spring MVC와 같은 애너테이션을 사용한다. Spring MVC와 WebFlux 컨트롤러 모두 리액티브 반환 타입을 지원하므로, 둘을 떼어 놓고 이야기하기는 어렵다. 한 가지 큰 차이점으로, WebFlux는 리액티브 @RequestBody 인자를 지원한다</p><li><a class="w3-btn w3-round-xxlarge w3-small w3-green goto" href="#pos-963276895" target="_self">Goto - Functional Endpoints</a></li><p>람다 기반, 경량, 함수형 프로그래밍 모델. 애너테이트된 컨트롤러와 다르게 앱이 요청의 시작부터 끝까지 제어하며, 요청을 라우팅하는 라이브러리나 유틸리티 집합이라고 생각해도 된다</p></ul><h3>Applicability</h3><p>굳이 잘 동작하는 Spring MVC 앱을 바꿀 필요는 없다</p><div class="w3-center w3-margin-bottom"><img class="w3-round" src="/imgs/spring-mvc-and-webflux-venn.png"></div><h3>Servers</h3><p>WebFlux 자체에 서버를 시작/종료하는 기능은 없지만, Spring Boot WebFlux starter에서는 이 단계를 자동화해준다</p><h3>Concurrency Model</h3><div><h4 class="fake">Invoking a Blocking API</h4><ul><li>리액터의 publishOn, subscribeOn을 이용해 호출을 다른 스레드를 이용해 처리할 수 있다</li><p><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/webflux/src/main/java/tutorial/webflux/action/CallBlockingAction.java" lan="java">CallBlockingAction.java</button></p><li>지원하는 <a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://projectreactor.io/docs/core/release/api/reactor/core/scheduler/Schedulers.html">Schedulers.html</a></li><table class="no-sort"><tr><th>method</th><th>실행 적합</th></tr><tr><td>parallel()</td><td>병렬 non-blocking Runnable</td></tr><tr><td>single()</td><td>저지연 Runnable 단일 실행. 반환 Scheduler는 재사용된다.</td></tr><tr><td>boundedElastic()</td><td>실행 시간이 긴 여러 (블로킹) 작업 실행. 동시 실행 제한(bound) 존재<ul><li>유저 스레드는 idle 60초를 넘으면 동적으로 삭제된다</li><p>기본 유저 스레드지만, 오버라이딩 메서드로 데몬 스레드 지정 가능</p><li>threadCap : 최대 스레드 수. 기본값은 (코어 수) * 10</li><li>queuedTaskCap : 최대 큐잉 작업 수. 초과하면 RejectedExecutionException 발생. Integer.MAX_VALUE으로 무제한 설정 가능</li><li>name : 스레드 이름 prefix</li></ul></td></tr><tr><td>immediate()</td><td>호출자 스레드로 즉시 실행</td></tr><tr><td>fromExecutorService()</td><td>Backing ExecutorService 지정</td></tr></table></ul></div></div><h2>Reactive Core</h2><div><h3>HttpHandler<span id="pos-1079810686" style="padding:0!important;margin:0!important;width:0!important;height:0!important;overflow:hidden!important"></span></h3><div><p>지원하는 HTTP 서버들에 대한 최소한의 추상화</p><p><strong>↓ interface HttpHandler</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">Mono&lt;Void&gt; handle(ServerHttpRequest request, ServerHttpResponse response)</div><p><strong>↓ Reactor Netty</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">HttpHandler handler = ...
ReactorHttpHandlerAdapter adapter = new ReactorHttpHandlerAdapter(handler);
HttpServer.create().host(host).port(port).handle(adapter).bind().block();
</div></div><h3>WebHandler API<span id="pos-1956235184" style="padding:0!important;margin:0!important;width:0!important;height:0!important;overflow:hidden!important"></span></h3><div><p>org.springframework.web.server 패키지는 HttpHandler 규약 위에서, 컴포넌트 체인(N개 WebExceptionHandler, N개 WebFilter, 1개 WebHandler)을 이용해 요청을 처리한다</p><p>WebHttpHandlerBuilder를 이용해 체인을 구성할 수 있는데, 직접 builder에 등록하거나, 컴포넌트를 자동 감지한 ApplicationContext를 지정해주면 된다</p><p>WebHandler API는 웹앱 공통 기능들을 지원한다 : 유저 세션 with 속성, 요청 속성, 요청 Locale/Principal 결정, form data, multipart data 등</p><h4 class="fake">WebHttpHandlerBuilder 자동 감지 빈</h4><table><tr><th>Bean name</th><th>Bean type</th><th>Count</th><th>Description</th></tr><tr><td>&lt;any&gt;</td><td>WebExceptionHandler</td><td>0..N</td><td>예외 처리</td></tr><tr><td>&lt;any&gt;</td><td>WebFilter</td><td>0..N</td><td>전후 처리</td></tr><tr><td>webHandler</td><td>WebHandler</td><td>1</td><td>요청 처리</td></tr><tr><td>webSessionManager</td><td>WebSessionManager</td><td>0..1</td><td>WebSession 인스턴스 관리. ServerWebExchange로 획득 가능. 기본값 DefaultWebSessionManager<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/webflux/src/main/java/tutorial/webflux/action/CookieAndSessionAction.java" lan="java">CookieAndSessionAction.java</button><details><summary>실행 스크린샷</summary><div class="w3-center w3-margin-bottom"><img class="w3-round" src="/imgs/2021-04-04 154616.png" alt="최초 get 헤더"><br><strong>&lt;이미지 - 최초 get 헤더></strong></div><div class="w3-center w3-margin-bottom"><img class="w3-round" src="/imgs/2021-04-04 154628.png" alt="최초 get body"><br><strong>&lt;이미지 - 최초 get body></strong></div><div class="w3-center w3-margin-bottom"><img class="w3-round" src="/imgs/2021-04-04 154648.png" alt="1번째 set"><br><strong>&lt;이미지 - 1번째 set></strong></div><div class="w3-center w3-margin-bottom"><img class="w3-round" src="/imgs/2021-04-04 154709.png" alt="2번째 set"><br><strong>&lt;이미지 - 2번째 set></strong></div><div class="w3-center w3-margin-bottom"><img class="w3-round" src="/imgs/2021-04-04 154726.png" alt="2번째 get 헤더"><br><strong>&lt;이미지 - 2번째 get 헤더></strong></div><div class="w3-center w3-margin-bottom"><img class="w3-round" src="/imgs/2021-04-04 154740.png" alt="2번째 get body"><br><strong>&lt;이미지 - 2번째 get body></strong></div></details><p>Redis를 이용해 세션을 관리하고 싶은 경우 : spring-session-data-redis 사용 고려<a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://docs.spring.io/spring-session/docs/2.4.2/reference/html5/#samples">samples</a><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://www.baeldung.com/spring-session-reactive">spring-session-reactive</a></p></td></tr><tr><td>serverCodecConfigurer</td><td>ServerCodecConfigurer</td><td>0..1</td><td>form, multipart 데이터를 파싱하는 HttpMessageReader 인스턴스에 접근. ServerWebExchange로 획득 가능. 기본값 ServerCodecConfigurer.create()</td></tr><tr><td>localeContextResolver</td><td>LocaleContextResolver</td><td>0..1</td><td>ServerWebExchange로 획득 가능. 기본값 AcceptHeaderLocaleContextResolver</td></tr><tr><td>forwardedHeaderTransformer</td><td>ForwardedHeaderTransformer</td><td>0..1</td><td>프록시가 추가한 forwarded 헤더 조작. 기본적으로 사용되지 않는다.</td></tr></table><h4 class="fake">Form Data(application/x-www-form-urlencoded)</h4><p><strong>↓ ServerWebExchange</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">Mono&lt;MultiValueMap&lt;String,String&gt;&gt; getFormData()</div><p>DefaultServerWebExchange는 설정된 HttpMessageReader 인스턴스를 이용해 form을 MultiValueMap으로 파싱한다. 기본적으로 ServerCodecConfigurer 빈이 FormHttpMessageReader 빈을 사용 설정한다</p><h4 class="fake">Multipart Data(multipart/form-data)</h4><p><strong>↓ ServerWebExchange</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">Mono&lt;MultiValueMap&lt;String,Part&gt;&gt; getMultipartData()</div><p>DefaultServerWebExchange는 설정된 HttpMessageReader&lt;MultiValueMap&lt;String, Part&gt;&gt; 인스턴스를 이용해 multipart를 MultiValueMap으로 파싱한다. 기본적으로 DefaultPartHttpMessageReader 빈이 이용된다</p></div><h3>Filters</h3><ul><li>WebFilter 사이의 실행 순서는 빈 정의에 @Order를 이용하거나, Ordered 인터페이스를 구현함으로써 조절할 수 있다</li><li>Controller 클래스에 애너테이션을 붙여 CORS 설정을 할 수 있지만, Spring Security를 이용하는 경우 CorsFilter를 이용해 Security보다 먼저 실행되도록 설정할 것이 권장된다<a class="w3-btn w3-round-xxlarge w3-small w3-green goto" href="#pos2074541" target="_self">Goto - CORS</a></li></ul><h3>Exceptions</h3><ul><li>ResponseStatusExceptionHandler : Throwable -&gt; int(HttpStatus) 결정</li><li>WebFluxResponseStatusExceptionHandler : @ResponseStatus로부터 HttpStatus 자동 획득</li><li>REST API의 경우, ResponseEntity를 이용함이 권장된다</li><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/webflux/src/main/java/tutorial/webflux/action/SimpleExceptionAction.java" lan="java">SimpleExceptionAction.java</button></ul><h3>Codecs</h3><ul><li>Encoder, Decoder는 HTTP 스펙과 무관하게, 임의 타입과 DataBuffer 사이의 변환을 정의한다</li><li>HttpMessageReader, HttpMessageWriter는 HTTP 메시지의 읽기/쓰기를 담당한다</li><li>Encoder는 EncoderHttpMessageWriter로, Decoder는 DecoderHttpMessageReader로 래핑 가능하다</li><li>DataBuffer는 기존 byte buffer들(Netty의 ByteBuf, java.nio.ByteBuffer, ...)에 대한 추상화다</li></ul><p>spring-core 모듈은 byte[], ByteBuffer, DataBuffer, Resource, String에 대한 encoder/decoder를 제공하고, spring-web 모듈은 Jackson JSON, Jackson Smile(binary JSON), JAXB2 encoder/decoder 및 HTTP(form, multipart, ...) reader/writer를 제공한다</p><p>전형적으로 ClientCodecConfigurer, ServerCodecConfigurer를 이용해 코덱을 커스터마이징한다. <a class="w3-btn w3-round-xxlarge w3-small w3-green goto" href="#pos-1536640018" target="_self">Goto - HTTP message codecs</a></p><div><h4 class="fake">Jackson JSON</h4><ul><li>Jackson 라이브러리가 존재하는 경우, JSON 및 binary JSON(Smile)이 지원된다</li><li>Jackson2Decoder의 동작</li><ol><li>Jackson의 비동기, 논블로킹 파서가 하나의 JSON 객체를 표현하는 TokenBuffer로 바이트 스트림을 모은다</li><li>각 TokenBuffer는 Jackson의 ObjectMapper로 넘겨져 고수준 객체로 변환된다</li><li>single-value publisher(e.g. Mono)의 디코딩의 경우, TokenBuffer가 하나만 필요하다</li><li>multi-value publisher(e.g. Flux)의 디코딩의 경우, 각 TokenBuffer가 객체를 구성할 수 있게 되면 ObjectMapper로 전달된다. 입력 컨텐츠로 JSON 배열, line-delimited JSON(application/stream+json)이 가능하다</li></ol><li>Jackson2Encoder의 동작</li><ol><li>single-value publisher(e.g. Mono)는 바로 ObjectMapper에서 직렬화한다</li><li>multi-value publisher를 application/json로 직렬화하는 경우, Flux#collectToList()의 반환 컬렉션을 직렬화한다</li><li>application/x-ndjson, application/stream+x-jackson-smile 같은 스트리밍 타입으로 multi-value publisher를 직렬화하는 경우, line-delimited JSON 포맷으로 각 값을 따로 write, flush한다</li><li>SSE의 경우, 이벤트가 발생할 때마다 Jackson2Encoder를 1회 호출하고 flush하여 저지연을 보장한다</li></ol><li>커스텀 JsonSerializer 등록</li><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">@JsonComponent
public class EntityResponseSerializer&lt;T&gt; extends JsonSerializer&lt;EntityResponse&lt;T&gt;&gt; {
    @Override
    public void serialize(EntityResponse&lt;T&gt; value, JsonGenerator gen, SerializerProvider serializers) throws IOException {
        var v = value.entity();
        if (v == null)
            gen.writeNull();
        else if (v instanceof String)
            gen.writeString((String) v);
        else
            gen.writeObject(v);
    }
}
</div></ul></div><h3>Logging</h3></div><h2>DispatcherHandler</h2><div><h3>Special Bean Types</h3><h3>WebFlux Config</h3><h3>Processing</h3><h3>Result Handling</h3><h3>Exceptions</h3><h3>View Resolution</h3></div><h2>Annotated Controllers<span id="pos1285343375" style="padding:0!important;margin:0!important;width:0!important;height:0!important;overflow:hidden!important"></span></h2><div><h3>@Controller</h3><h3>Request Mapping</h3><h3>Handler Methods</h3><h3>Model</h3><h3>DataBinder</h3><h3>Managing Exceptions</h3><h3>Controller Advice</h3></div><h2>Functional Endpoints<span id="pos-963276895" style="padding:0!important;margin:0!important;width:0!important;height:0!important;overflow:hidden!important"></span></h2><div><h3>Overview</h3><h3>HandlerFunction</h3><h3>RouterFunction</h3><h3>Running a Server</h3><h3>Filtering Handler Functions</h3></div><h2>URI Links</h2><h2>CORS<a class="w3-btn w3-round-xxlarge w3-small w3-green goto" href="#pos2074541" target="_self">Goto - CORS</a></h2><h2>Web Security</h2><h2>View Technologies</h2><h2>HTTP Caching</h2><h2>WebFlux Config</h2><div><h3>HTTP message codecs<span id="pos-1536640018" style="padding:0!important;margin:0!important;width:0!important;height:0!important;overflow:hidden!important"></span></h3></div></div></div><hr><p>&copy; <a href="mailto:hi.donggi@gmail.com">Donggi Kim</a>@<a class="w3-btn w3-round-xxlarge w3-small w3-green" href="/LICENSE">MIT License</a> / <a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://www.w3schools.com/w3css">w3css</a>@No license / <a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://highlightjs.org/">highlight.js</a>@<a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://github.com/highlightjs/highlight.js/blob/main/LICENSE">BSD-3-Clause License</a> / <a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://github.com/mathjax/MathJax">MathJax</a>@<a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://github.com/mathjax/MathJax/blob/master/LICENSE">Apache License 2.0</a> / <a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://github.com/davidshimjs/qrcodejs">qrcodejs</a>@<a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://github.com/davidshimjs/qrcodejs/blob/master/LICENSE">MIT License</a></p></div></body></html>