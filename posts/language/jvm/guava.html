<html lang="ko"><head><script id="google-analytics" src="https://www.googletagmanager.com/gtag/js?id=UA-143098403-1" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-143098403-1');
</script><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="google-site-verification" content="aH-DyzdytYQ0NPHNQFcs5dVoiu5YNs6CEEHYgqDmAFM"><meta name="author" content="Donggi Kim &lt;hi.donggi@gmail.com&gt;"><meta name="keywords" content="Guava"><meta name="description" content="Guava 정리"><title>Guava 30.1</title><link id="w3css" rel="stylesheet" href="/source/w3.css"><link id="highlight-style" rel="stylesheet" href="/source/xcode.css"><link id="default-style" rel="stylesheet" href="/source/default.css"><script id="highlight-js" src="/source/highlight.pack.js"></script><script id="default-js" src="/source/default.min.js"></script><script id="dsq-count-scr" src="//donggi.disqus.com/count.js" async></script></head><body><div class="w3-bar-block w3-sidebar w3-animate-left" id="sidebar"><hr><a class="w3-bar-item w3-button" href="javascript:closeSidebar();">Close &times;</a><hr><div id="marker-list"></div><hr><div id="post-list"></div><hr><div id="file-list"></div><hr></div><div id="main"><div class="w3-bar w3-blue w3-large" id="nav" style="position:-webkit-sticky;position:sticky;top:0px;vertical-align:middle"><button class="w3-bar-item w3-button w3-hover-theme" onclick="toggleSidebar()">&#9776;</button><input class="w3-bar-item" id="query" type="text" placeholder="search" style="max-width:35%"><a class="w3-bar-item w3-button w3-hover-theme" href="/">Home</a></div><div class="w3-padding" id="contents"><h1>References</h1><ul><li><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://github.com/google/guava/wiki">wiki</a></li><li><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://javadoc.io/doc/com.google.guava/guava/latest/index.html">javadoc</a></li></ul><h1>...base</h1><div><h2>문자(열) 관련</h2><div><h3>Ascii</h3><p>아스키 문자(열)에 대한 상수, 유틸리티 제공</p><h3>CharMatcher</h3><p>char 단위 문자(열)에 대한 매칭 수행. 보충 평면 글자는 지원하지 않음에 주의</p><h3>Joiner</h3><ul><li>각 객체의 toString() 결과를 Appendable 객체에 append</li><li>skipNulls(), useForNull(String) 설정이 없는 경우, null 인자에 대해 NullPointerException 발생</li></ul><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static Joiner on(String separator)
Joiner.MapJoiner withKeyValueSeparator(String keyValueSeparator)

&lt;A extends Appendable&gt; appendTo(A appendable, ...)
String join(...)
</div><h3>Splitter</h3><p>고정된 구분자(패턴)을 이용해 겹치지 않는 부분 문자열 획득</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static Splitter fixedLength(int length)   // 고정 길이로 자르기
static Splitter on(Pattern separatorPattern)

Splitter limit(int maxItems)
Splitter omitEmptyStrings()
Splitter trimResults()                    // 연속되는 공백 문자 제거
Splitter trimResults(CharMatcher trimmer) // trimmer에 해당하는 모든 연속적인 문자 제거

Splitter.MapSplitter withKeyValueSeparator(Splitter keyValueSplitter)

Iterable&lt;String&gt; split(CharSequence sequence)
List&lt;String&gt; splitToList(CharSequence sequence)
Stream&lt;String&gt; splitToStream(CharSequence sequence)
</div><h3>Strings</h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static String nullToEmpty(String string)
static String emptyToNull(String string)
static boolean isNullOrEmpty(String string)

static String repeat(String string, int count)
static String padStart(String string, int minLength, char padChar)
static String commonPrefix(CharSequence a, CharSequence b) // + commonSuffix
</div></div><h2>GC</h2><div><h3>FinalizableReference</h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">void finalizeReferent() // GC 이후 실행할 작업 정의</div><h3>FinalizableSoftReference&lt;T></h3><p>SoftReference + FinalizableReference</p><h3>FinalizableWeakReference&lt;T></h3><p>WeakReference + FinalizableReference</p><h3>FinalizablePhantomReference&lt;T></h3><p>PhantomReference + FinalizableReference</p><h3>FinalizableReferenceQueue</h3><p>백그라운드 스레드로 FinalizableReference::finalizeReferent()를 실행하는 ReferenceQueue</p></div><h2>ETC</h2><div><h3>Converter&lt;A,B&gt;</h3><p>A -&gt; B, B -&gt; A 양방향 변환이 존재할 때, 그 변환</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static &lt;A,B&gt; Converter&lt;A,B&gt; from(Function&lt;? super A,? extends B&gt; forwardFunction, Function&lt;? super B,? extends A&gt; backwordFunction)

B convert(A a) // null은 항상 null로
Iterable&lt;B&gt; convertAll(Iterable&lt;? extends A&gt; fromIterable)
Converter&lt;B,A&gt; reverse()
&lt;C&gt; Converter&lt;A,C&gt; andThen(Converter&lt;B,C&gt; secondConverter)
</div><h3>Defaults</h3><p>자바 언어 명세에 따라 임의 타입에 대한 기본값을 반환</p><h3>Enums</h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static Field getField(Enum&lt;?&gt; enumValue)
static &lt;T extends Enum&lt;T&gt;&gt; Optional&lt;T&gt; getIfPresent(Class&lt;T&gt; enumClass, String value)
static &lt;T extends Enum&lt;T&gt;&gt; Converter&lt;String,T&gt; stringConverter(Class&lt;T&gt; enumClass)
    // Enum.name()을 이용한 Converter 반환
</div><h3>Preconditions</h3><ul><li>사전조건이 충족되지 않은 경우에만 예외 메시지 포매팅을 수행한다</li><p>다만 메서드 인자는 항상 계산 수행된다. 이마저도 피하고 싶다면 try ... catch 구문을 이용하면 된다</p><li>포매팅 문자열은 %s만 지원한다</li></ul><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static void checkArgument(boolean expression, errorMessage(Template)[, errorMessageArgs])
    // 메서드 매개변수 테스트
static void checkState(boolean expression, errorMessage(Template)[, errorMessageArgs])
    // 인스턴스 상태 테스트
static &lt;T extends Object&gt; checkNotNull(T obj, errorMessage(Template)[, errorMessageArgs])
</div><h3>Stopwatch</h3><ul><li>System.nanoTime()을 이용하여 경과 시간 측정</li><p><strong>↓ Android의 경우</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">// 앱이 슬립 상태가 되면 더 이상 실행되지 않으므로,
Stopwatch.createStarted(
    new Ticker() {
        public long read() {
            return android.os.SystemClock.elapsedRealtimeNanos();
        }
    });</div><li>벽시계 System.currentTimeMillis()는 근사값이며, 주기적인 조정을 거치므로 부정확하다</li></ul><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static Stopwatch createStarted()
static Stopwatch createUnstarted()

Stopwatch start() + stop, reset
boolean isRunning()

Duration elapsed()
long elapsed(TimeUnit desiredUnit)
</div><h3>Suppliers</h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static &lt;F,T&gt; Supplier&lt;T&gt; compose(Function&lt;? super F,T&gt;, Supplier&lt;F&gt; supplier)
static &lt;T&gt; Supplier&lt;T&gt; memoize(Supplier&lt;T&gt; delegate)
static &lt;T&gt; Supplier&lt;T&gt; memoizeWithExpiration(Supplier&lt;T&gt; delegate, long duration, TimeUnit unit)
static &lt;T&gt; Supplier&lt;T&gt; ofInstance(T instance)
static &lt;T&gt; Function&lt;Supplier&lt;T&gt;,T&gt; supplierFunction()
static &lt;T&gt; Supplier&lt;T&gt; synchronizedSupplier(Supplier&lt;T&gt; delegate)
</div><h3>Throwables</h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static String getStackTraceAsString(Throwable throwable)</div><h3>Verify</h3><ul><li>사전조건이 충족되지 않은 경우에만 예외 메시지 포매팅을 수행한다</li><p>다만 메서드 인자는 항상 계산 수행된다. 이마저도 피하고 싶다면 try ... catch 구문을 이용하면 된다</p><li>포매팅 문자열은 %s만 지원한다</li></ul><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static void verify(boolean expression, errorMessage(Template)[, errorMessageArgs])
static &lt;T&gt; T verifyNotNull(T reference, errorMessage(Template)[, errorMessageArgs])
</div></div></div><h1>...cache</h1><div><h2>Cache&lt;K,V&gt;</h2><p>스레드-안전한 캐시. 보통 CacheBuilder로 인스턴스 획득</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">V getIfPresent(Object key)
V get(K key, Callable&lt;? extends V> loader)
    // 캐시에 없으면 loader를 통해 새로 저장하고 반환
ImmutableMap&lt;K,V&gt; getAllPresent(Iterable&lt;?&gt; keys)
ConcurrentMap&lt;K,V&gt; asMap()

void put(K key, V value)
void putAll(Map&lt;? extends K,​? extends V> m)

void invalidate(Object key)
void invalidateAll(Ierable&lt;?&gt; keys)

long size()
CacheStats stats()
    // 구현에 따라 기록 여부가 다를 수 있다
    // CacheBuilder의 경우, recordStats()를 호출한 경우에만 기록

void cleanUp()
    // 구현에 따라 필요한 경우, 정리 연산 수행
</div><h2>LoadingCache&lt;K,V&gt;</h2><p>키가 캐시에 없는 경우(벌크 연산 getAll 포함) loader를 통해 새로 저장하고 반환한다</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">V get(K key)        // getUnchecked(K)의 경우 RuntimeException을 던진다
ImmutableMap&lt;K,V&gt; getAll(Iterable&lt;? extends K&gt; keys)
void refresh(K key) // loader를 통해 값을 갱신한다
</div><h2>CacheBuilder&lt;K,V&gt;</h2><ul><li>자동 loading 설정 가능</li><li>LRU 옵션 설정 가능</li><li>마지막 접근/쓰기 후 t 시간 경과하면 자동 삭제 설정 가능</li><li>키/값 자동 WeakReference 래핑 설정 가능</li><p>WeakReference 사용 설정된 경우, equals() 대신 identity(==) 비교를 이용한다</p><li>삭제된 엔트리에 대한 리스너 설정 가능</li><li>캐시 통계 기록 가능</li><li>CacheBuilder를 통해 만든 캐시는 직렬화/역직렬화 가능하다. 다만, 캐시 설정 정보만 저장/복원된다</li><li>refresh 연산은 기본적으로 LoadingCache.refresh(K) -&gt; CacheLoader.reload(K, V)를 통해 수행된다</li></ul><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">&lt;K1 extends K,V1 extends V&gt; CacheBuilder&lt;K1,V1&gt; weigher(Weigher&lt;? super K1,? super V1&gt; weigher)
    // Weigher : (key, value) 쌍으로부터 상대적인 우선순위를 반환. 낮을수록 높다
    // 호출 객체와 다른 객체가 반환되나, 둘 다 이용 가능하다. 다만 반환된 제네릭 객체는 타입-안전이 보장된다
CacheBuilder&lt;K,V&gt; ticker(Ticker ticker)
    // 지정하지 않은 경우 System.nanoTime()을 기본 사용
&lt;K1 extends K,V1 extends V&gt; CacheBuilder&lt;K1,V1&gt; removalListener(RemovalListener&lt;? super K1,? super V1&gt; listener)
    // 이 안에서 발생하는 예외는 전파되지 않고 Logger로만 기록된다
    // GC로 인해 제거된 경우, 키/값은 null일 수 있다

&lt;K1 extends K,V1 extends V&gt; Cache&lt;K1,V1&gt; build()
&lt;K1 extends K,V1 extends V&gt; LoadingCache&lt;K1,V1&gt; build(CacheLoader&lt;? super K1,V1&gt; loader)
</div><h2>CacheBuilderSpec</h2><ul><li>캐시 설정을 외주할 수 있다</li><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">var spec = "maximumSize=10000,expireAfterWrite=10m";
var graphs = CacheBuilder.from(spec)
    .removalListener(MY_LISTENER)
    .build(
        new CacheLoader&lt;Key, Graph>() {
            public Graph load(Key key) throws AnyException {
                return createExpensiveGraph(key);
            }
        });</div><li>Duration은 정수 + [smhd]로 표현</li></ul><table class="no-sort"><tr><td>concurrencyLevel=[integer]</td><td>CacheBuilder.concurrencyLevel</td></tr><tr><td>initialCapacity=[integer]</td><td>CacheBuilder.initialCapacity</td></tr><tr><td>maximumSize=[long]</td><td>CacheBuilder.maximumSize</td></tr><tr><td>maximumWeight=[long]</td><td>CacheBuilder.maximumWeight</td></tr><tr><td>expireAfterAccess=[duration]</td><td>CacheBuilder.expireAfterAccess(Duration)</td></tr><tr><td>expireAfterWrite=[duration]</td><td>CacheBuilder.expireAfterWrite(Duration)</td></tr><tr><td>refreshAfterWrite=[duration]</td><td>CacheBuilder.refreshAfterWrite(Duration)</td></tr><tr><td>weakKeys</td><td>CacheBuilder.weakKeys()</td></tr><tr><td>softValues</td><td>CacheBuilder.softValues()</td></tr><tr><td>weakValues</td><td>CacheBuilder.weakValues()</td></tr><tr><td>recordStats</td><td>CacheBuilder.recordStats()</td></tr></table><h2>CacheLoader&lt;K,V&gt;</h2><ul><li>LoadingCache에 사용되는 값 생성기</li><li>보통 load(K)만 구현하는 것으로 충분하다. 나머지는 선택적</li></ul><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static &lt;K,V&gt; CacheLoader&lt;K,V&gt; from(Function&lt;K,V&gt; function)

static &lt;K,V&gt; CacheLoader&lt;K,V&gt; asyncReloading(CacheLoader&lt;K,V&gt; loader, Executor executor)
    // reload()가 동기적인 경우에만 유용

abstract V load(K key)                           // 최초 값 생성
ListenableFuture&lt;V&gt; reload(K key, V value) // 기존 값을 대체할 값 생성
</div><h2>RemovalListeners</h2><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static &lt;K,V&gt; RemovalListener&lt;K,V&gt; asynchronus(RemovalListener&lt;K,V&gt; listener, Executor executor)</div><h2>Cache 대리자</h2><p>ForwardingCache, ForwadingCache.SimpleForwardingCache, ForwadingLoadingCache, ForwadingLoadingCache.SimpleForwardingLoadingCache</p></div><h1>...collect</h1><div><h2>Collection types</h2><div><h3>ImmutableCollection&lt;E&gt;</h3><ul><li>래핑한 collection을 변경하면 내용이 바뀌는 Collections.unmodifiableCollection()보다 강력</li><li>null 원소를 허용하지 않는다</li><li>스레드-안전하다</li><li>ImmutableList, ImmutableSet, ImmutableSortedSet, ImmutableMap, ImmutableSortedMap, ImmutableBiMap, ImmutableMultiset, ImmutableMultimap, ImmutableListMultimap, ImmutableSetMultimap, ImmutableTable</li><li>ImmutableCollection.Builder&lt;E>, ImmutableList.Builder&lt;E> 등도 제공</li></ul><h3>BiMap&lt;K,V&gt;</h3><ul><li>1:1 대응 관계를 표현한다</li><li>구현체 : HashBiMap(K, V 둘 다 해시 가능), EnumBiMap(두 enum 간 대응), EnumHashBiMap</li></ul><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">V forcePut(K key, V value) // put(K, V) 실행 전에 value와 관계된 모든 엔트리 제거
                           // 반환값 : 기존 key에 대응됐던 값
BiMap&lt;V,K&gt; inverse() // 반대 방향 뷰 반환
</div><h3>Multiset&lt;E&gt;</h3><ul><li>Bag으로도 불리는 자료형. 값의 중복을 허용(최대 Integer.MAX_VALUE)한다</li><li>구현체 : HashMultiset(HashMap을 구현에 이용), LinkedHashMultiset(결정적 iteration), TreeMultiset(iteration 정렬 지정), EnumMultiset(모든 연산이 상수 시간), ConcurrentHashMultiset(동시성 추가, null 비허용)</li></ul><h3>Multimap&lt;K,V&gt;</h3><ul><li>하나의 키에 대해 여러 값을 매핑</li><li>ListMultimap : List를 이용해 값 삽입 순서를 보존. 엔트리 중복 가능</li><p>관련 구현체 : ArrayListMultimap, LinkedListMultimap</p><li>SetMultimap : Set을 이용해 값 중복 제거</li><p>관련 구현체 : HashMultimap, LinkedHashMultimap(삽입 순 iteration)</p><li>SortedSetMultimap : 값집합을 정렬한 SetMultimap</li><p>관련 구현체 : TreeMultimap(키/값 각각 정렬)</p></ul><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">Map&lt;K,Collection&lt;V&gt;&gt; asMap()
Multiset&lt;K&gt; keys()
Collection&lt;V&gt; replaceValues(K key, Iterable&lt;? extends V&gt; values)
// 이하 생략</div><p><strong>↓ Value uniqueness - ListMultimap</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">var m = MultimapBuilder.hashKeys().linkedListValues().&lt;Integer, Integer>build();
m.put(1, 3);
m.put(2, 3);
m.put(1, 1);
m.put(1, 2);
m.put(1, 1);

assertEquals(5, m.size()); // 같은 키에 대한 값 중복 제거 X
assertEquals(5, m.values().size());</div><p><strong>↓ Value uniqueness - SetMultimap</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">var m = MultimapBuilder.hashKeys().hashSetValues().&lt;Integer, Integer>build();
m.put(1, 3);
m.put(2, 3);
m.put(1, 1);
m.put(1, 2);
m.put(1, 1);

assertEquals(4, m.size()); // 같은 키에 대하여는 값 중복 제거
assertEquals(4, m.values().size()); // 같은 키에 대해서만 값 중복 제거
</div><h3>Table&lt;R,C,V&gt;</h3><ul><li>(행 key, 열 key) 쌍에 대한 값을 보존</li><li>Sparse 데이터 표현에 좋다</li><li>행/열 모두로 조회 가능하지만, 일부 구현은 열로 조회하는 경우 성능이 좋지 않을 수 있다</li><li>메서드가 반환한 모든 Collection/Map은 테이블에 대한 writable view다</li><p><strong>구현에 따라 테이블 변경 메서드를 지원하지 않거나, 메서드가 반환한 Collection/Map이 writable하지 않을 수 있다</strong></p><li>구현체 : ArrayTable(고정 크기 2차원 배열 이용), HashBasedTable(linked hash table 이용), TreeBasedTable(행/열 키 각각을 정렬)</li></ul><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">Set&lt;Table.Cell&lt;R,C,V&gt;&gt; cellSet()
Map&lt;C,V&gt; row(R rowKey) + column
Map&lt;R,Map&lt;C,V&gt;&gt; rowMap() + columnMap
</div><h3>ClassToInstanceMap&lt;B&gt;</h3><ul><li>Class -&gt; instance 매핑</li><p>int.class와 Integer.class는 서로 다름에 유의</p><li>제네릭 매핑에는 TypeToInstanceMap을 이용하면 된다</li><li>구현체 : ImmutableClassToInstanceMap, MutableClassToInstanceMap</li></ul><h3> Queue</h3><div><h4>EvictingQueue&lt;E></h4><p>add()시, 최대 개수에 도달했다면 head 요소 삭제. 논리적으로 circular buffer와 동일</p><h4>MinMaxPriorityQueue&lt;E&gt;</h4><ul><li>A double-ended priority queue</li><p>최대 원소에 대해서도 상수 시간 접근이 가능하며, 최대 원소에 대한 연산도 지원</p><li>크기 제한을 설정하는 경우, 크기가 초과될 때마다 최대 원소 제거</li></ul></div></div><h2>Utility</h2><div><h3>Collections2</h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static &lt;E&gt; Collection&lt;List&lt;E&gt;&gt; permutations(Collection&lt;E&gt; elements)
    // + orderedPermutations
</div><h3>Comparators</h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static &lt;T,​S extends T> Comparator&lt;Iterable&lt;S>> lexicographical​(Comparator&lt;T> comparator)
    // Iterable을 사전순으로 정렬해준다
    // e.g. [] &lt; [1] &lt; [1, 1] &lt; [1, 2] &lt; [2]
    // + isInOrder, isInStrictOrder

static &lt;T> Collector&lt;T,​?,​List&lt;T>> least​(int k, Comparator&lt;? super T> comparator)
    // 최소 원소 k개를 고르는 스트림 최종연산
    // + greatest

static &lt;T> T min​(@Nullable T a, @Nullable T b, Comparator&lt;T> comparator) + max
</div><h3>ComparisonChain</h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">ComparisonChain.start()
    .compare(this.aString, that.aString)
    .compare(this.anInt, that.anInt)
    .result()
</div><h3>Iterators + Iterables</h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static &lt;T&gt; Iterator&lt;T&gt; cycle(T... elements)
static &lt;T&gt; PeekingIterator&lt;T&gt; peekingIterator(Iterator&lt;? extends T&gt; iterator)
static &lt;T&gt; T[] toArray(Iterator&lt;? extends T&gt; iterator, Class&lt;T&gt; type)

static int advance(Iterator&lt;?&gt; iterator, int numberToAdvance)
static &lt;T&gt; Iterator&lt;T&gt; concat(...)
static &lt;T&gt; Iterator&lt;T&gt; limit(Iterator&lt;T&gt;, int limitSize)
static &lt;T&gt; Iterator&lt;T&gt; consumingIterator(Iterator&lt;T&gt; iterator)
    // 원소를 소비하면서 삭제. Iterator.remove()를 지원해줘야 다음 next()가 동작한다
static &lt;T&gt; UnmodifiableIterator&lt;T&gt; filter(Iterator&lt;?&gt; unfiltered, Class&lt;T&gt; desiredType)
static &lt;T&gt; UnmodifiableIterator&lt;T&gt; mergeSorted(...)
static &lt;T&gt; UnmodifiableIterator&lt;List&lt;T&gt;&gt; partition(...) + paddedPartition
static &lt;F,T&gt; Iterator&lt;T&gt; transform(Iterator&lt;F&gt; fromIterator, Function&lt;? super F,? extends T&gt; function)

static &lt;T&gt; boolean addAll(Collection&lt;T&gt; addTo, Iterator&lt;? extends T&gt; iterator)
    // + removeAll, retainAll, removeIf
static &lt;T&gt; boolean all(Iterator&lt;T&gt; iterator, Predicate&lt;? super T&gt; predicate)
    // + any, contains, elementsEqual
static &lt;T&gt; T find(Iterator&lt;T&gt; iterator, Predicate&lt;? super T&gt; predicate)
    // + tryFind
static int frequency(Iterator&lt;?&gt; iterator, Object element
    // + indexOf, size
static &lt;T&gt; T get(Iterator&lt;? extends T&gt; iterator, int position, T defaultValue)
    // + getLast, getNext, getOnlyElement
</div><h3>Lists</h3><p>Cartesian product, (Array|Linked|CopyOnWrite)List 생성 등</p><h3>Maps</h3><p>Set과 Function&lt;K,V&gt;를 이용한 Map 생성, 두 Map 사이의 차분, 필터링, 신규 맵 생성 등</p><h3>MapMaker</h3><ul><li>유사 ConcurrentHashMap을 만든다</li><li>weakKeys()를 지정하는 경우 equals() 대신 identity(==) 비교를 이용한다</li></ul><h3>Multimaps</h3><p>Map&lt;K, Collection&lt;V&gt;&gt;로 변환, 필터링, Multimap&lt;V,K&gt;로 변환, 엔트리 일괄 변경 등</p><h3>MultimapBuilder&lt;K0,​V0></h3><ul><li>K0, V0 : 각각 키, 값 upper bound</li><li>hashKkeys() : hash table 사용</li><li>linkedHashKeys() : hash table 사용 + 키 삽입 순서 기록</li><li>treeKeys() : TreeMap 사용</li><li>enumKeys() : EnumMap 사용</li></ul><h3>Multisets</h3><p>Multiset 사이의 포함 관계, difference, sum, union 등</p><h3>ObjectArrays</h3><p>배열 접합, 새 배열 할당</p><h3>Queues</h3><p>(Blocking)Queue, ArrayDeque, PriorityQueue 생성 등</p><h3>Sets</h3><p>Cartesian product, 신규 집합 생성 등</p><h3>Streams</h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static &lt;T> Stream&lt;T> stream​(Iterable&lt;T> iterable)
static &lt;T> Stream&lt;T> concat​(Stream&lt;? extends T>... streams)
static &lt;A,​B,​R> Stream&lt;R> zip​(Stream&lt;A> streamA, Stream&lt;B> streamB, BiFunction&lt;? super A,​? super B,​R> function)
static &lt;A,​B> void forEachPair​(Stream&lt;A> streamA, Stream&lt;B> streamB, BiConsumer&lt;? super A,​? super B> consumer)
static &lt;T,​R> Stream&lt;R> mapWithIndex​(Stream&lt;T> stream, Streams.FunctionWithIndex&lt;? super T,​? extends R> function)
static &lt;T> Optional&lt;T> findLast​(Stream&lt;T> stream)
</div><h3>Tables</h3><p>값 일괄 변경, transpose(행-열 뒤집기) 등</p></div><h2>Ranges</h2><div><h3>DiscreteDomain&lt;C extends Comparable></h3><p>이산 자료형 전체 범위를 표현한다. 예를 들어, 정수 전체 집합은 표현할 수 있지만, 소수 전체 집합은 표현할 수 없다</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static DiscreteDomain&lt;BigInteger&gt; bigIntegers()
    // + integers, longs

C maxValue() + minValue             // 없으면 NoSuchElementException
abstract C next(C value) + previous // 없으면 null
</div><h3>Range&lt;C extends Comparable></h3><ul><li>대소 관계가 있는 자료형에 대해, 임계값을 이용해 범위 1개를 표현한다</li><li>(a..b), [a..b], (a..b], [a..b), (a..inf), [a..inf), (-inf..b), (-inf..b], (-inf..inf)</li></ul><h3>ContiguousSet&lt;C extends Comparable></h3><p>DiscreteDomain 상에서의 Range 하나를 표현한다</p><h3>RangeMap&lt;K extends Comparable></h3><p>Range -&gt; V 매핑을 표현한다</p></div><h2>Forwawrding collections</h2><div><h3>ForwardingObject</h3><ul><li>장식자 패턴 구현을 위한 최상위 추상 클래스</li><li>delegate()는 장식할 인스턴스를 반환하면 된다</li><li>hashCode(), equals(Object)는 backing object로 포워딩하지 않는다</li><li>ForwardingList, ForwardingMap, ... 등 interface-specific 서브클래스를 이용하거나, 직접 정의하면 된다</li></ul></div><h2>Others</h2><div><h3>Interner&lt;E&gt;</h3><p>임의 불변 타입에서 String.intern()과 유사한 기능을 제공함을 표현</p><h3>Interners</h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static &lt;E&gt; Interner&lt;E&gt; newStrongInterner() + weak
static Interners.InternerBuilder newBuilder()
</div><h3>Ordering</h3><ul><li>부가 기능이 있는 Comparattor</li><p>Comparators Since 21.0에도 있는 기능들임</p><li>인스턴스 획득</li><ul><li>compare(T, T) 재정의</li><li>from(Comparator), natural(), explicit(...) 등</li></ul></ul></div></div><h1>...escape</h1><div><p><strong>XML에 유용한 Escaper 제공</strong></p></div><h1>...eventbus</h1><div><h2>@interface Subscribe</h2><p>이벤트 객체 하나만 인자로 받는 구독자 메서드 표시</p><h2>@interface AllowConcurrentEvents</h2><p>구독자 메서드가 스레드-안전함을 표시</p><h2>EventBus</h2><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">void register​(Object object)   // public @Subscribe 메서드를 갖는 구독자 등록
void post​(Object event)        // 이벤트 발행
</div><h2>AsyncEventBus</h2><p>지정 Executor로 처리</p><h2>DeadEvent</h2><p>처리되지 않은 이벤트는 DeadEvent로 감싸여 한 번 더 발행된다</p></div><h1>...graph</h1><div><h2>Graph&lt;N&gt;</h2><ul><li>지원 : 방향/무방향 그래프, self-loop 허용/비허용, 정점/간선에 대한 삽입 순서 보존/정렬/비정렬</li><li>인스턴스 획득은 GraphBuilder 이용</li></ul><h2>ValueGraph&lt;N,​V></h2><ul><li>Graph + 간선 가중치</li><li>인스턴스 획득은 ValueGraphBuilder 이용</li></ul><h2>Network&lt;N,​E></h2><ul><li>Graph + 모든 간선은 unique 객체</li><li>두 정점 사이에 복수의 간선을 허용할 수 있다</li><li>인스턴스 획득은 NetworkBuilder 이용</li></ul></div><h1>...hash</h1><div><h2>Hashing</h2><p>adler32, crc32, crc32c, hmacMd5, hmacSha256, md5, sha512, ...</p></div><h1>...html.HtmlEscapers</h1><p>Escapers for HTML</p><h1>...io</h1><div><h2>Files</h2><p>java.io.File에 대한 확장. java.nio.Files에서 같은 기능을 많이 제공한다</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static CharSource asCharSource​(File file, Charset charset)
static CharSink asCharSink​(File file, Charset charset, FileWriteMode... modes)
static void touch​(File file)
static void createParentDirs​(File file)
static MappedByteBuffer map​(File file)
static String getFileExtension​(String fullName)
static String getNameWithoutExtension​(String file)
static Traverser&lt;File> fileTraverser()
</div><h2>MoreFiles</h2><p>java.nio.Files에 대한 확장</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static CharSource asCharSource​(Path path, Charset charset, OpenOption... options)
static CharSink asCharSink​(Path path, Charset charset, OpenOption... options)
static ImmutableList&lt;Path> listFiles​(Path dir)
static Traverser&lt;Path> fileTraverser()
static Predicate&lt;Path> isDirectory​(LinkOption... options) + isRegularFile
static void touch​(Path path)static void touch​(Path path)
static void createParentDirectories​(Path path, FileAttribute&lt;?>... attrs)
static String getFileExtension​(Path path)
static String getNameWithoutExtension​(Path path)
static void deleteRecursively​(Path path, RecursiveDeleteOption... options)
static void deleteDirectoryContents​(Path path, RecursiveDeleteOption... options)
</div><h2>LineReader</h2><p>\n, \r, \r\n 무관하게 한 줄씩 읽을 수 있게 해준다</p><h2>Resources</h2><p>클래스패스 상의 리소스에 접근하는 유틸리티를 제공한다</p></div><h1>...math</h1><ul><li>IntMath, LongMath, DoubleMath, BigIntegerMath, BigDecimalMath</li><li>Quantiles : 분위수 계산</li></ul><h1>...net</h1><ul><li>HttpHeaders, MediaType : 상수 제공</li><li>PercentEscaper, UrlEscapers : Escaper 제공</li></ul><h1>...primitives</h1><ul><li>Array : ImmutableIntArray, ImmutableLongArray, ImmutableDoubleArray</li><li>Type : UnsignedInteger, UnsignedLong	</li><li>Utility : Booleans, ..., Doubles, Primitives, UnsignedLongs</li></ul><h1>...reflect</h1><div><h2>TypeToInstanceMap&lt;B&gt;</h2><ul><li>TypeToken -&gt; instance 매핑</li><li>ImmutableTypeToInstanceMap&lt;B>, MutableTypeToInstanceMap&lt;B></li></ul><h2>ClassPath</h2><p>ClassLoader로부터 모든 클래스, 리소스 스캔</p><h2>Reflection</h2><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static String getPackageName​(Class&lt;?> clazz)
static String getPackageName​(String classFullName)
    // 클래스 이름만 파싱하여 패키지 이름을 판단한다

static &lt;T> T newProxy​(Class&lt;T> interfaceType, InvocationHandler handler)
    // 단일 인터페이스 프록시 생성에 편리
</div><h2>TypeToken&lt;T></h2><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">// 인스턴스 획득 1
new TypeToken&lt;List&lt;String>>() {}
// 인스턴스 획득 2
abstract class IKnowMyType&lt;T> {
    TypeToken&lt;T> type = new TypeToken&lt;T>(getClass()) {};
}
new IKnowMyType&lt;String>() {}.type => String

final &lt;X> TypeToken&lt;T> where​(TypeParameter&lt;X> typeParam, TypeToken&lt;X> typeArg)
    // 동적으로 제네릭 타입을 치환
    // e.g.
    static &lt;K, V> TypeToken&lt;Map&lt;K, V>> mapOf(TypeToken&lt;K> keyType, TypeToken&lt;V> valueType) {
      return new TypeToken&lt;Map&lt;K, V>>() {}
          .where(new TypeParameter&lt;K>() {}, keyType)
          .where(new TypeParameter&lt;V>() {}, valueType);
    }

final TypeToken&lt;?> resolveType​(Type type)
    // 제네릭 실제 타입 획득
    // e.g.
    new TypeToken&lt;List&lt;String>>() {}.resolveType(List.class.getMethod("get", int.class).getGenericReturnType())
        == String.class

final TypeToken.TypeSet getTypes()
    // 현재 타입 + 선조 타입 + 구현 인터페이스
    // e.g. List&lt;String> =>
    // [java.util.List&lt;java.lang.String>, java.util.Collection&lt;java.lang.String>, java.lang.Iterable&lt;java.lang.String>]

final TypeToken&lt;? super T> getSupertype​(Class&lt;? super T> superclass)
final TypeToken&lt;? extends T> getSubtype​(Class&lt;?> subclass)
    // e.g.
    var type1 = new TypeToken&lt;List&lt;String>>() {};
    var type2 = type1.getSupertype(Iterable.class); == java.lang.Iterable&lt;java.lang.String>
    var type3 = type2.getSubtype(List.class);       == java.util.List&lt;java.lang.String>

final @Nullable TypeToken&lt;?> getComponentType()
    // 배열 원소 타입 반성

final Invokable&lt;T,​Object> method​(Method method)
final Invokable&lt;T,​T> constructor​(Constructor&lt;?> constructor)

// + wrap, unwrap
// + isSupertypeOf, isSubtypeOf, isArray, isPrimitive
</div></div><h1>...util.concurrent</h1><div><h2>ListenableFuture&lt;V></h2><ul><li>연산 완료 리스너(들)을 가질 수 있는 Future</li><p>JavaScript의 promise 체인과 유사한 로직 작성을 돕기 위해 개발됐다</p><li>이미 완료된 경우, 추가되는 리스너는 즉시 실행된다</li><li>리스너를 실행할 Executor 지정 가능</li></ul><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">void addListener​(Runnable listener, Executor executor)</div><h2>FluentFuture&lt;V></h2><p>ListenableFuture에 체인 기능 추가</p><h2>SettableFuture&lt;V></h2><p>결과를 외부에서 설정 가능한 ListenableFuture</p><h2>Futures</h2><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static &lt;V> ListenableFuture&lt;V> immediateFuture​(@Nullable V value)
static ListenableFuture&lt;Void> immediateVoidFuture()
static &lt;V> ListenableFuture&lt;V> immediateFailedFuture​(Throwable throwable)
static &lt;V> ListenableFuture&lt;V> immediateCancelledFuture()

static &lt;O> ListenableFuture&lt;O> submit​(Callable&lt;O> callable, Executor executor)
static ListenableFuture&lt;Void> submit​(Runnable runnable, Executor executor)
static &lt;O> ListenableFuture&lt;O> submitAsync​(AsyncCallable&lt;O> callable, Executor executor)
static &lt;O> ListenableFuture&lt;O> scheduleAsync​(AsyncCallable&lt;O> callable, Duration delay, ScheduledExecutorService executorService)

static &lt;V,​X extends Throwable> ListenableFuture&lt;V> catching​(ListenableFuture&lt;? extends V> input, Class&lt;X> exceptionType, Function&lt;? super X,​? extends V> fallback, Executor executor)
static &lt;V,​X extends Throwable> ListenableFuture&lt;V> catchingAsync​(ListenableFuture&lt;? extends V> input, Class&lt;X> exceptionType, AsyncFunction&lt;? super X,​? extends V> fallback, Executor executor)

static &lt;V> ListenableFuture&lt;V> withTimeout​(ListenableFuture&lt;V> delegate, Duration time, ScheduledExecutorService scheduledExecutor)
static &lt;I,​O> ListenableFuture&lt;O> transform​(ListenableFuture&lt;I> input, Function&lt;? super I,​? extends O> function, Executor executor)
static &lt;I,​O> ListenableFuture&lt;O> transformAsync​(ListenableFuture&lt;I> input, AsyncFunction&lt;? super I,​? extends O> function, Executor executor)
static &lt;I,​O> Future&lt;O> lazyTransform​(Future&lt;I> input, Function&lt;? super I,​? extends O> function)
    // get() 호출이 있을 때 function 호출

static &lt;V> ListenableFuture&lt;List&lt;V>> allAsList​(ListenableFuture&lt;? extends V>... futures)
static &lt;V> ListenableFuture&lt;List&lt;V>> successfulAsList​(ListenableFuture&lt;? extends V>... futures)
static &lt;T> ImmutableList&lt;ListenableFuture&lt;T>> inCompletionOrder​(Iterable&lt;? extends ListenableFuture&lt;? extends T>> futures)

static &lt;V> Futures.FutureCombiner&lt;V> whenAllComplete​(ListenableFuture&lt;? extends V>... futures)
static &lt;V> Futures.FutureCombiner&lt;V> whenAllSucceed​(ListenableFuture&lt;? extends V>... futures)

static &lt;V> ListenableFuture&lt;V> nonCancellationPropagating​(ListenableFuture&lt;V> future)
    // 출력 tufure를 취소해도 입력 future를 취소하지 않음

static &lt;V> void addCallback​(ListenableFuture&lt;V> future, FutureCallback&lt;? super V> callback, Executor executor)
static &lt;V> V getDone​(Future&lt;V> future)
</div><h2>Futures.FutureCombiner&lt;V></h2><p>다른 ListenableFuture들의 결과들을 이용하는 ListenableFuture</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">&lt;C> ListenableFuture&lt;C> callAsync​(AsyncCallable&lt;C> combiner, Executor executor)
&lt;C> ListenableFuture&lt;C> call​(Callable&lt;C> combiner, Executor executor)
ListenableFuture&lt;?> run​(Runnable combiner, Executor executor)

// e.g.
Futures.whenAllSucceed(loginDateFuture, recentCommandsFuture)
    .call(
        () ->
            new UsageHistory(
                username,
                Futures.getDone(loginDateFuture),
                Futures.getDone(recentCommandsFuture)),
        executor);
</div><h2>ListeningExecutorService</h2><p>Future 대신 ListenableFuture를 반환하는 ExecutorService</p><h2>ListeningScheduledExecutorService</h2><p>ScheduledFuture 대신 ListenableScheduledFuture를 반환하는 ScheduledExecutorService</p><h2>Callables</h2><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static &lt;T> AsyncCallable&lt;T> asAsyncCallable​(Callable&lt;T> callable, ListeningExecutorService listeningExecutorService)</div><h2>ClosingFuture&lt;V></h2><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">// 비동기 연산에 사용된 자원을 자동으로 닫게 해준다
ClosingFuture.submit(
        closer -> closer.eventuallyClose(database.newTransaction(), closingExecutor), executor)
    .transformAsync((closer, transaction) -> transaction.queryClosingFuture("..."), executor)
    .transform((closer, result) -> result.get("userName"), directExecutor())
    .catching(DBException.class, e -> "no user", directExecutor())
    .finishToFuture();
</div><h2>CycleDetectingLockFactory</h2><p>lock 요구 시 사이클을 감지하는 ReentrantLock, ReentrantReadWriteLock 인스턴스 생성</p><h2>Service</h2><ul><li>가동 상태(NEW -> STARTING -> RUNNING -> STOPPING -> TERMINATED / FAILED)와 연관 메서드를 갖는 객체</li><li>중간 구현체 : AbstractExecutionThreadService, AbstractIdleService, AbstractScheduledService, AbstractService</li></ul><h2>ServiceManager</h2><p>서비스 집합 관리자</p><h2>TimeLimiter</h2><ul><li>메서드 호출 제한 시간을 둔다</li><li>구현체 : SimpleTimeLimiter</li></ul><h2>RateLimiter</h2><p>초당 permit 사용량을 제한한 세마포어</p><h2>ThreadFactoryBuilder</h2><p>스레드 이름, daemon 여부, 우선순위 등 설정 간소화</p></div><h1>...xml.XmlEscapers</h1><p>Escapers for XML</p></div><hr><p>&copy; <a href="mailto:hi.donggi@gmail.com">Donggi Kim</a>@<a class="w3-btn w3-round-xxlarge w3-small w3-green" href="/LICENSE">MIT License</a> / <a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://www.w3schools.com/w3css">w3css</a>@No license / <a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://highlightjs.org/">highlight.js</a>@<a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://github.com/highlightjs/highlight.js/blob/main/LICENSE">BSD-3-Clause License</a> / <a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://github.com/mathjax/MathJax">MathJax</a>@<a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://github.com/mathjax/MathJax/blob/master/LICENSE">Apache License 2.0</a> / <a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://github.com/davidshimjs/qrcodejs">qrcodejs</a>@<a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://github.com/davidshimjs/qrcodejs/blob/master/LICENSE">MIT License</a></p></div></body></html>