<html lang="ko"><head><script id="google-analytics" src="https://www.googletagmanager.com/gtag/js?id=UA-143098403-1" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-143098403-1');
</script><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="google-site-verification" content="aH-DyzdytYQ0NPHNQFcs5dVoiu5YNs6CEEHYgqDmAFM"><meta name="author" content="Donggi Kim &lt;hi.donggi@gmail.com&gt;"><meta name="keywords" content="C#, .NET"><meta name="description" content="C#.NET 정리"><title>C#.NET</title><link id="w3css" rel="stylesheet" href="/source/w3.css"><link id="highlight-style" rel="stylesheet" href="/source/xcode.css"><link id="default-style" rel="stylesheet" href="/source/default.css"><script id="highlight-js" src="/source/highlight.pack.js"></script><script id="default-js" src="/source/default.min.js"></script></head><body><div class="w3-bar-block w3-sidebar w3-animate-left" id="sidebar"><hr><a class="w3-bar-item w3-button" href="javascript:closeSidebar();">Close &times;</a><hr><div id="marker-list"></div><hr><div id="post-list"></div><hr><details class="w3-small file-list" open="open"><summary>LICENSE</summary><ul><li>&copy; <a href="mailto:hi.donggi@gmail.com">Donggi Kim</a> →<a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://github.com/Dong-gi/Dong-gi.github.io/blob/master/LICENSE">MIT License</a></li><li><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://www.w3schools.com/w3css">w3css</a> → No license</li><li><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://highlightjs.org/">highlight.js</a> →<a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://github.com/highlightjs/highlight.js/blob/main/LICENSE">BSD-3-Clause License</a></li><li><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://github.com/mathjax/MathJax">MathJax</a> →<a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://github.com/mathjax/MathJax/blob/master/LICENSE">Apache License 2.0</a></li><li><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://github.com/davidshimjs/qrcodejs">qrcodejs</a> →<a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://github.com/davidshimjs/qrcodejs/blob/master/LICENSE">MIT License</a></li></ul></details><hr></div><article id="main"><div class="w3-bar w3-blue w3-large" id="nav" style="position:-webkit-sticky;position:sticky;top:0px;vertical-align:middle"><button class="w3-bar-item w3-button w3-hover-theme" onclick="toggleSidebar()">&#9776;</button><input class="w3-bar-item" id="query" type="text" placeholder="search" style="max-width:35%"><a class="w3-bar-item w3-button w3-hover-theme" href="/">Home</a></div><div class="w3-padding" id="contents"><h1>작성 기준</h1><ul><li>2022년 04월</li><li>.NET 6.0</li><li>C# 10</li></ul><h1>.NET</h1><div><h2>.NET 개요</h2><ul><li>.NET은 (거의) 모든 플랫폼에서 구동하는 다양한 종류의 앱을 빌드하기 위한 무료 오픈 소스 개발 플랫폼</li><li>.NET은 다양한 구현체가 존재한다</li><ul><li>이전에 .NET Core로 불렸던 .NET 5 이상은 최신 구현으로, (거의) 모든 플랫폼에서 실행된다</li><li>.NET Framework는 .NET의 이전 구현으로, Windows에서만 실행된다</li><li>Mono는 Android, Mac, iOS, tvOS 및 watchOS에서 Xamarin 애플리케이션의 성능을 향상하는 런타임</li><p>Unity 엔진도 지원한다. iOS를 위한 전체 사전 컴파일(AOT; Ahead-Of-Time) 컴파일) 기능도 제공</p><li>UWP는 최신 Windows 앱을 빌드하는 데 사용</li></ul><li>.NET 앱은 MSBuild를 사용하여 소스 코드로부터 빌드</li><li>MSBuild와 .NET CLI는 GitHub Actions, Azure DevOps 등의 CI/CD 환경에 사용 가능</li><li>NuGet은 .NET을 위해 설계된 오픈 소스 패키지 관리자</li><p>NuGet 패키지는 컴파일된 코드(DLL), 코드와 관련된 다른 파일 및 패키지의 버전 번호와 같은 정보가 포함된 설명이 포함된 확장명 있는 .zip파일</p></ul><div><h3>.NET 실행 모델</h3><p>각 .NET 구현체는 다음을 포함한다</p><ul><li>런타임(e.g. .NET 5 CLR)</li><li>클래스 라이브러리(e.g. .NET 5 기본 클래스 라이브러리)</li><li>필요에 따른 애플리케이션 라이브러리(e.g. WPF, Windows Forms)</li><li>개발 도구</li></ul><div><h4 class="fake">CLR(Common Language Runtime)</h4><ul><li>.NET 앱은 CLR 환경에서 관리 코드를 실행한다</li><li>CLR은 Windows, macOS, Linux 지원을 포함하는 플랫폼 간 런타임으로, 메모리 할당 및 관리(GC)를 처리하는 가상 머신이다</li><li>관리 코드란 CLR이 실행을 관리하는 코드로써, C/C++ 처럼 프로그래머가 모든 작업을 관리하는 비관리 코드와 대조된다</li></ul><h4 class="fake">JIT(Just-In-Time) 컴파일러와 IL(Intermediate Language)</h4><ul><li>중간 언어는 고급 .NET 언어로 작성된 코드가 컴파일된 결과물로, 모든 고급 .NET 언어 및 하드웨어에 독립적이다</li><li>CLR이 중간 언어를 JIT 처리하여 CPU를 위한 기계어 코드를 생성하고 실행한다</li></ul><h4 class="fake">비관리 리소스 작업</h4><ul><li>e.g. FileStream은 관리 객체지만, 관리되지 않는 파일 핸들을 참조한다. 따라서 FileStream 사용을 마쳤다면 파일 핸들을 명시적으로 해제해야 한다</li><li>비관리 리소스를 참조하는 객체는 IDisposable 인터페이스를 구현한다. 이러한 객체를 using 문에서 사용하면 Dispose() 메서드를 자동으로 호출한다</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">var iDisposable = new FileStream("./", FileMode.Open);
try { } finally { iDisposable.Dispose(); }

// 아래와 동일
using (iDisposable = new FileStream("./", FileMode.Open)) { }
</div></ul></div><h3>.NET 배포 모델</h3><ul><li>자체 포함</li><p>.NET 런타임 및 라이브러리 등을 포함한 실행 파일 생성. .NET 런타임이 없는 머신에서도 실행 가능</p><li>프레임워크 종속</li><p>앱과 자체 종속성만 포함하는 .dll 파일과 실행 파일 생성. 사용자가 .NET을 설치해야 실행 가능</p></ul><h3>런타임 라이브러리 확장</h3><p>자주 사용되는 일부 기능은 런타임 라이브러리에 포함되지는 않지만 NuGet 패키지로 제공된다</p><table><tr><th>NuGet 패키지</th><th>설명서</th></tr><tr><td>Microsoft.Extensions.Hosting</td><td>애플리케이션 수명 관리(일반 호스트)</td></tr><tr><td>Microsoft.Extensions.DependencyInjection</td><td>DI(종속성 주입)</td></tr><tr><td>Microsoft.Extensions.Configuration</td><td>Configuration</td></tr><tr><td>Microsoft.Extensions.Logging</td><td>Logging</td></tr><tr><td>Microsoft.Extensions.Options</td><td>옵션 패턴</td></tr><tr><td>Microsoft.Extensions.FileSystemGlobbing</td><td>파일 탐색</td></tr><tr><td>Microsoft.Extensions.Http</td><td>HTTP</td></tr><tr><td>Microsoft.Extensions.Localization</td><td>지역화</td></tr></table></div><h2>.NET의 새로운 기능</h2><div><h3>.NET Core 2.0</h3><ul><li>C# 7.1 지원</li><li>.NET Standard 2.0 구현</li></ul><h3>.NET Core 2.1</h3><ul><li>JIT 컴파일러 개선 : 계층화된 컴파일</li><ol><li>가능한 빨리 코드를 생성하는 계층</li><li>자주 실행되는 메서드에 대한 최적화 코드를 생성하는 계층(병렬 수행)</li></ol><li>보다 메모리 효율적인 자료형 : System.Span&lt;T&gt;, System.Memory&lt;T&gt;</li><p>읽기 전용 System.ReadOnlySpan&lt;T&gt;, System.ReadOnlyMemory&lt;T&gt;도 지원</p></ul><h3>.NET Core 2.2</h3><ul><li>EventListener 클래스를 사용하여 GC, JIT, ThreadPool 등의 런타임 모니터링 가능<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/VisualStudio/ConsoleApp1/SimpleEventListener.cs" lan="cs">SimpleEventListener.cs</button></li><li><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://github.com/dotnet/core-setup/blob/master/Documentation/design-docs/host-startup-hook.md">호스트 시작 후크</a>를 사용하여 Main 메서드 실행 전 코드 삽입 가능</li></ul><h3>.NET Core 3.0</h3><ul><li>C# 8.0 지원</li><li>.NET Standard 2.1 구현</li><li>WPF 및 Windows Forms 지원</li><li>기본 Json 라이브러리 지원 : System.Text.Json</li><li>HTTP/2 지원</li><li>System.Index, System.Range 추가</li><li>IEnumerable&lt;T&gt;의 비동기 버전 IAsyncEnumerable&lt;T&gt; 추가</li></ul><h3>.NET 5</h3><ul><li>.NET Framework 4.x와의 혼동을 피하기 위해 버전 번호 4.x 생략</li><li>.NET 주요 구현임을 강조하기 위해 이름에서 "Core" 삭제</li><li>.NET Standard를 구현하진 않지만, .NET Standard 2.1를 지원</li><ul><li>.NET Standard 2.1 이후 새로운 .NET Standard 버전은 존재하지 않는다</li><li>신규 API가 추가될 때, .NET 5+는 기능의 구현을 공유하므로 모든 .NET 5+ 앱 및 라이브러리에서 즉시 사용 가능하다</li><p>이는 .NET Standard의 사양-구현 분리 문제를 해결한다</p></ul><li>C# 9 지원</li></ul><h3>.NET 6</h3><ul><li>C# 10 지원</li><li>.NET MAUI 2022년 2분기 일반 공개 예정</li><li>Json 라이브러리 강화</li><p>유효성 검사 및 기본값 제공, 멤버 순서 지정, 스트림 직렬화/역직렬화 등</p><li>우선순위 큐 PriorityQueue&lt;TElement,TPriority&gt; 추가</li><li>HTTP/3 Preview 지원</li><li>제네릭 형식에 대한 연산자 지원(Preview)</li></ul></div><h2>배포 모델</h2><div><h3>단일 파일 배포 및 실행 파일</h3><ul><li>배포 설정 시 "Produce single file"을 설정하면 관리형 DLL을 앱과 함께 단일 실행 파일에 제공한다</li><p>실행 시 관리형 DLL이 추출되어 메모리에 로드되며, 폴더로 추출되지는 않음 Since .NET 5</p><li>네이티브 라이브러리를 단일 파일로 묶고 싶다면 IncludeNativeLibrariesForSelfExtract 플래그 이용</li><p><strong>↓project.csproj</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="xml">&lt;IncludeNativeLibrariesForSelfExtract&gt;true&lt;/IncludeNativeLibrariesForSelfExtract&gt;</div><li>모든 파일을 단일 파일로 묶고 싶다면 IncludeAllContentForSelfExtract 플래그 이용</li><p><strong>↓project.csproj</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="xml">&lt;IncludeAllContentForSelfExtract&gt;true&lt;/IncludeAllContentForSelfExtract&gt;</div><p>위 두 옵션은 앱 실행 시 클라이언트 머신의 디렉터리에 파일이 추출된다</p><ul><li>Linux, MacOS : $HOME/.net</li><li>Windows : %TEMP%/.net</li><li>DOTNET_BUNDLE_EXTRACT_BASE_DIR 환경변수로 제어 가능</li></ul><li>PDB 파일을 DLL에 포함</li><p><strong>↓project.csproj</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="xml">&lt;DebugType&gt;embedded&lt;/DebugType&gt;</div><li>단일 파일 배포시 압축 Since .NET 6</li><p><strong>↓project.csproj</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="xml">&lt;EnableCompressionInSingleFile&gt;true&lt;/EnableCompressionInSingleFile&gt;</div></ul></div><h2>기본 코딩 구성 요소</h2><div><h3>Common Type System</h3><p>CLR에서 사용되는 데이터 타입의 선언, 사용, 관리 방법을 정의한다</p><h3>.NET의 데이터 타입</h3><p>.NET의 모든 타입은 아래의 2가지 범주에 해당한다</p><ul><li>Value type : value type의 인스턴스는 값 자체를 표현하며, value type의 인스턴스가 변수에 할당되는 경우 변수는 값의 사본을 갖는다</li><li>Reference type : reference type의 인스턴스는 실제 값에 대한 참조(포인터와 유사)를 표현하며, reference type의 인스턴스가 변수에 할당되는 경우 변수는 동일한 참조를 갖는다</li></ul><h3>클래스</h3><ul><li>클래스는 명시적으로 지정된 다른 클래스 또는 암시적으로 System.Object에서 파생되는 참조 형식</li><li>객체가 수행할 수 있는 작업과 객체에 포함되는 데이터(필드)를 정의한다.</li></ul><h3>구조체</h3><ul><li>구조체는 System.ValueType에서 파생되는 값 형식</li><li>값 형식이므로 생성자 호출 없이 변수 선언만으로 초기화가 진행된다. 이때 사용되는 기본 생성자는 자동으로 추가되며, 재정의할 수 없다</li><p>인자를 받는 생성자를 정의할 수 있으며, 생성자는 모든 필드를 초기화해야 한다</p><li>.NET의 모든 기본 데이터 타입(Boolean, Int32, ...)들도 구조체로 정의된다</li><li>명시적으로 다른 타입을 상속할 수 없으며, 구조체 자체도 다른 타입의 상속의 대상이 되지 않는다</li></ul><h3>열거형</h3><ul><li>열거형은 System.Enum에서 파생되는 값 형식으로, 기본 정수 타입의 값들에 대해 별명을 제공한다</li><li>내부 형식의 값을 형 변환 없이 열거형에 할당할 수 있다. and vice versa</li><li>메서드 정의 불가, 인터페이스 구현 불가, 프로퍼티 및 이벤트 정의 불가</li><li>열거형 자체는 기본 정수 타입에 대한 제네릭이므로, 열거형 정의에 형식 매개 변수를 사용할 수는 없다</li><li>FlagsAttribute를 이용해 비트 필드라는 특수한 형태의 열거형을 정의할 수 있다<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/VisualStudio/ConsoleApp2/Program.cs" lan="cs">Program.cs</button></li></ul><h3>인터페이스</h3><ul><li>인터페이스는 멤버와 시그니쳐만을 정의한다</li><li>인터페이스의 멤버는 모두 추상 멤버이며, 생성자를 가질 수 없다</li><li>필드 정의 불가, 정적 멤버 정의 불가</li><li>프로퍼티 정의는 가질 수 있다. 구현은 구현 클래스에서 제공</li></ul><h3>대리자</h3><ul><li>메서드를 참조할 수 있는 참조 형식</li><p><strong>↓명명 대리자 인스턴스 생성</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">public delegate void DoSomething();

public static void Main(string[] args)
{
    var delegate1 = new DoSomething(() =&gt; Console.WriteLine("delegate1"));
    delegate1.Invoke();
}</div><li>대리자는 System.Delegate → System.MulticastDelegate를 상속한다</li><li>익명 대리자 인스턴스 생성</li><ol><li>delegate 연산자 Since .NET Framework 2.0</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">var arr = new int[] { 1, 2, 3, 4, 5 };
Console.WriteLine(arr.Where(delegate (int n) { return n % 2 == 0; }).Sum());</div><li>람다 Since C# 3.0</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">var arr = new int[] { 1, 2, 3, 4, 5 };
Console.WriteLine(arr.Where(n => n % 2 == 0).Sum());</div></ol><li>미리 정의된 재사용 가능 대리자</li><ul><li>Action : void 리턴 메서드 참조. 매개변수 0 ~ 16개, 총 17가지</li><li>Func : 결과를 반환하는 메서드 참조. 매개변수 0 ~ 16개, 총 17가지</li><li>Predicate : bool을 반환하는 Func</li></ul></ul><h3>멤버</h3><ul><li>필드 : 임의 타입 변수</li><li>프로퍼티 : (히든) 필드에 대한 getter/setter 메서드. 프로퍼티의 타입과 프로퍼티 내에서 참조하는 필드의 타입이 같을 필요가 없다</li><li>메서드</li><ul><li>메서드 오버로딩</li><p>메서드 시그니처는 이름과 매개 변수 목록으로 구성되며, 메서드 시그니처가 다르다면 이름이 같은 2개 이상의 메서드를 정의할 수 있다</p><li>연산자 오버로딩<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/VisualStudio/ConsoleApp3/Program.cs" lan="cs">Program.cs</button></li></ul><li>생성자</li><li>이벤트</li><p>대리자를 이용한 관찰자 패턴. 간단하게 구독/해지 가능<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/VisualStudio/ConsoleApp5/SomeTimer.cs" lan="cs">SomeTimer.cs</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/VisualStudio/ConsoleApp5/Program.cs" lan="cs">Program.cs</button></p><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">public delegate void EventHandler(object? sender, EventArgs e);
public delegate void EventHandler&lt;TEventArgs&gt;(object? sender, TEventArgs e);</div><p>이벤트 핸들러 추가/제거 작업 재정의 가능<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/VisualStudio/ConsoleApp6/SomeTimer.cs" lan="cs">SomeTimer.cs</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/VisualStudio/ConsoleApp6/Program.cs" lan="cs">Program.cs</button></p><li>중첩 타입</li></ul><h3>멤버의 특성</h3><table><tr><th>특성</th><th>적용 대상</th><th>설명</th></tr><tr><td>abstract</td><td>메서드, 프로퍼티, 이벤트</td><td>파생 타입에서 구현 제공</td></tr><tr><td>private, family, assembly, family and assembly, family or assembly, public</td><td>모두</td><td>멤버 액세스 범위 제한</td></tr><tr><td>final</td><td>메서드, 프로퍼티, 이벤트</td><td>파생 타입에서 재정의 불가</td></tr><tr><td>initialize-only</td><td>필드</td><td>초기화 이후 변경 불가</td></tr><tr><td>newslot, override</td><td>모두</td><td>시그니처가 같은 상속된 멤버와의 상호작용. new(숨김, default, 부모 타입으로 형변환하여 숨긴 메서드 호출 가능), override(재정의)</td></tr><tr><td>virtual</td><td>메서드, 프로퍼티, 이벤트</td><td>파생 타입에서 다른 구현을 제공할 수 있다. 메서드의 어떤 구현을 호출할 지 결정하는 것은 런타임에 호출을 수행하는 인스턴스의 타입. 원하는 버전의 메서드를 호출하려면 해당 타입으로 변수를 캐스팅</td></tr></table><h3>.NET의 타입 변환</h3><ul><li>파생 클래스에서 부모 클래스로의 변환은 연산자 없이 자동 지원</li><li>부모 클래스에서 파생 클래스로의 변환은 연산자를 이용해 자동 지원</li><li>클래스에서 구현하는 인터페이스로의 변환은 연산자 없이 자동 지원</li><li>인터페이스에서 구현 클래스로의 변환은 연산자를 이용해 자동 지원</li><li>사용자 정의 암시적/명시적 타입 변환<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/VisualStudio/ConsoleApp4/Program.cs" lan="cs">Program.cs</button></li></ul><h3>제네릭의 공변성(Covariance) 및 반공변성(Contravariance)</h3><ul><li>Covariance : 지정된 것보다 더 많은 파생 타입을 사용 가능</li><p>e.g. IEnumerable&lt;Derived&gt; 인스턴스를 IEnumerable&lt;Base&gt; 변수에 할당 가능</p><li>Contravariance : 지정된 것보다 더 일반적인 타입을 사용 가능</li><p>e.g. Action&lt;Base&gt; 인스턴스를 Action&lt;Derived&gt; 변수에 할당 가능</p><li>Invariance : 지정된 타입만 사용 가능</li><p>e.g. List&lt;Base&gt;는 List&lt;Derived&gt; 변수에 할당 불가능. and vice versa</p></ul><table><tr><th>형식</th><th>공변 형식 매개 변수</th><th>반공변 형식 매개 변수</th></tr><tr><td>Action&lt;T&gt;</td><td></td><td>Y</td></tr><tr><td>Comparison&lt;T&gt;</td><td></td><td>Y</td></tr><tr><td>Converter&lt;TInput,TOutput&gt;</td><td>Y</td><td>Y</td></tr><tr><td>Func&lt;TResult&gt;</td><td>Y</td><td></td></tr><tr><td>Func&lt;T,TResult&gt;</td><td>Y</td><td>Y</td></tr><tr><td>IComparable&lt;T&gt;</td><td></td><td>Y</td></tr><tr><td>Predicate&lt;T&gt;</td><td></td><td>Y</td></tr><tr><td>IComparer&lt;T&gt;</td><td></td><td>Y</td></tr><tr><td>IEnumerable&lt;T&gt;</td><td>Y</td><td></td></tr><tr><td>IEnumerator&lt;T&gt;</td><td>Y</td><td></td></tr><tr><td>IEqualityComparer&lt;T&gt;</td><td></td><td>Y</td></tr><tr><td>IGrouping&lt;TKey,TElement&gt;</td><td>Y</td><td></td></tr><tr><td>IOrderedEnumerable&lt;TElement&gt;</td><td>Y</td><td></td></tr><tr><td>IOrderedQueryable&lt;T&gt;</td><td>Y</td><td></td></tr><tr><td>IQueryable&lt;T&gt;</td><td>Y</td><td></td></tr></table><h3>컬렉션</h3><table><tr><td>수행할 작업</td><td>제네릭 컬렉션 옵션</td><td>제네릭이 아닌 컬렉션 옵션</td><td>스레드-안전 or 불변 컬렉션 옵션</td></tr><tr><td>키-값 쌍 저장 &amp; 키를 통한 조회</td><td>Dictionary&lt;TKey,TValue&gt;</td><td>Hashtable</td><td>ConcurrentDictionary&lt;TKey,TValue&gt;, ReadOnlyDictionary&lt;TKey,TValue&gt;, ImmutableDictionary&lt;TKey,TValue&gt;</td></tr><tr><td>임의 인덱스를 이용한 조회</td><td>List&lt;T&gt;</td><td>Array, ArrayList</td><td>ImmutableList&lt;T&gt;, ImmutableArray</td></tr><tr><td>FIFO</td><td>Queue&lt;T&gt;</td><td>Queue</td><td>ConcurrentQueue&lt;T&gt;, ImmutableQueue&lt;T&gt;</td></tr><tr><td>LIFO</td><td>Stack&lt;T&gt;</td><td>Stack</td><td>ConcurrentStack&lt;T&gt;, ImmutableStack&lt;T&gt;</td></tr><tr><td>삽입 순서에 따른 조회</td><td>LinkedList&lt;T&gt;</td><td>권장 사항 없음</td><td>권장 사항 없음</td></tr><tr><td>컬렉션 변경 감시(INotifyPropertyChanged 및 INotifyCollectionChanged 구현)</td><td>ObservableCollection&lt;T&gt;</td><td>권장 사항 없음</td><td>권장 사항 없음</td></tr><tr><td>정렬된 컬렉션</td><td>SortedList&lt;TKey,TValue&gt;</td><td>SortedList</td><td>ImmutableSortedDictionary&lt;TKey,TValue&gt;, ImmutableSortedSet&lt;T&gt;</td></tr><tr><td>집합</td><td>HashSet&lt;T&gt;, SortedSet&lt;T&gt;</td><td>권장 사항 없음</td><td>ImmutableHashSet&lt;T&gt;, ImmutableSortedSet&lt;T&gt;</td></tr></table><h3>예외</h3><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">// 명시적 예외 발생
throw e; // e는 System.Exception 및 파생 클래스의 인스턴스

// 예외 처리
try { } catch { } finally { }   // 임의 예외 처리
try { } catch (Exception) { }   // 특정 예외 처리
try { } catch { throw; }        // 호출 스택으로 예외 넘기기
try { } catch (Exception e) { } // 특정 예외 처리. 예외 인스턴스 참조

var flag = Random.Shared.Next() % 2 == 0;
try { } // when 필터를 사용하는 경우, 같은 타입을 여러 번 catch 가능
catch (Exception) when (flag) { }
catch (Exception) when (!flag) { }
</div><h3>.NET의 숫자</h3><div><h4 class="fake">정수</h4><table><tr><th>형식</th><th>크기(바이트)</th><th>최소값</th><th>최대값</th></tr><tr><td>System.Int16</td><td>2</td><td>-32,768</td><td>32,767</td></tr><tr><td>System.Int32</td><td>4</td><td>-2,147,483,648</td><td>2,147,483,647</td></tr><tr><td>System.Int64</td><td>8</td><td>-9,223,372,036,854,775,808</td><td>9,223,372,036,854,775,807</td></tr><tr><td>System.SByte</td><td>1</td><td>-128</td><td>127</td></tr><tr><td>System.IntPtr(32비트 프로세스)</td><td>4</td><td>-2,147,483,647</td><td>2,147,483,647</td></tr><tr><td>System.IntPtr(64비트 프로세스)</td><td>8</td><td>-9,223,372,036,854,775,808</td><td>9,223,372,036,854,775,807</td></tr><tr><td>System.Byte</td><td>1</td><td>0</td><td>255</td></tr><tr><td>System.UInt16</td><td>2</td><td>0</td><td>65,535</td></tr><tr><td>System.UInt32</td><td>4</td><td>0</td><td>4,294,967,295</td></tr><tr><td>System.UInt64</td><td>8</td><td>0</td><td>18,446,744,073,709,551,615</td></tr><tr><td>System.UIntPtr(32비트 프로세스)</td><td>4</td><td>0</td><td>4,294,967,295</td></tr><tr><td>System.UIntPtr(64비트 프로세스)</td><td>8</td><td>0</td><td>18,446,744,073,709,551,615</td></tr><tr><td>BigInteger</td><td>무제한</td><td>-∞</td><td>∞</td></tr></table><h4 class="fake">부동소수</h4><p>부동소수는 NaN 및 무한대에 관한 특별한 클래스 멤버를 제공한다</p><table><tr><th>형식</th><th>크기(바이트)</th><th>근사 범위</th><th>참고</th></tr><tr><td>System.Half</td><td>2</td><td>±65504</td><td>Since .NET 5</td></tr><tr><td>System.Single</td><td>4</td><td>±3.4 x 1038</td><td></td></tr><tr><td>System.Double</td><td>8</td><td>±1.7 × 10308</td><td></td></tr><tr><td>System.Decimal</td><td>16</td><td>±7.9228 x 1028</td><td></td></tr></table><h4 class="fake">복소수</h4><p>System.Numerics.Complex</p><h4 class="fake">SIMD(Single Instruction Multiple Data)</h4><ul><li>Vector&lt;T&gt; : 고속 병렬 처리를 위한 T 타입 1차원 벡터</li><li>Vector2, Vector3, Vector4 : Single 값에 대한 2~4차원 벡터</li><li>Matrix3x2, Matrix4x4 : 각각 3x2, 4x4 행렬</li><li>Plane : 평면</li><li>Quaternion : 3차원 물리적 회전</li></ul></div><h3>날짜, 시간 및 표준 시간대</h3><ul><li>DateTime : UTC 기준 시각. 0001-01-01 00:00:00 ~ 9999-12-31 23:59:59</li><p>시간은 틱이라고 하는 100나노초 단위로 측정. 시각은 1년 1월 1일 자정 이후로 경과한 틱 수</p><li>DateTimeOffset : DateTime + UTC로부터의 offset</li><li>TimeZoneInfo : 표준 시간대</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">Console.WriteLine(DateTime.Now);            // 2022-04-20 오후 9:06:11
Console.WriteLine(DateTime.UtcNow);         // 2022-04-20 오후 12:06:11

Console.WriteLine(DateTimeOffset.Now);      // 2022-04-20 오후 9:06:11 +09:00
Console.WriteLine(DateTimeOffset.UtcNow);   // 2022-04-20 오후 12:06:11 +00:00
Console.WriteLine(                          // 2022-04-20 오후 9:06:11 +09:00
    new DateTimeOffset(DateTime.Now, TimeZoneInfo.Local.BaseUtcOffset));
Console.WriteLine(                          // 2022-04-20 오후 12:06:11 +09:00
    new DateTimeOffset(new DateTime(DateTime.UtcNow.Ticks), TimeZoneInfo.Local.BaseUtcOffset));

Console.WriteLine(DateTime.Now.Ticks - DateTime.UtcNow.Ticks);              // 323999999997 = 9시간
Console.WriteLine(DateTimeOffset.Now.Ticks - DateTimeOffset.UtcNow.Ticks);  // 323999999942 = 9시간</div><li>DateOnly Since .NET 6 : 0001-01-01 ~ 9999-12-31</li><li>TimeOnly Since .NET 6 : 00:00:00 ~ 23:59:59</li></ul><h3>Attribute</h3><ol><li>자바의 애너테이션처럼 요소를 장식한다<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/VisualStudio/ConsoleApp7/Program.cs" lan="cs">Program.cs</button></li><li>사용자 정의 특성은 System.Attribute를 상속하여 만든다</li><li>명명시 Attribute를 접미하고, 실제 사용할 땐 생략 가능하다</li><li>특성 적용 대상 제한 : System.AttributeUsage 생성자에 AttributeTargets 전달. 생략시 기본값은 AttributeTargets.All</li><li>적용 대상 명시 : assembly, module, type, method, property, field, event, param, return, typevar</li></ol></div><h2>데이터 액세스</h2><div><h3>LINQ; Language Itegrated Query</h3><ol><li>데이터에 대한 선언적 코드<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/VisualStudio/ConsoleApp8/Program.cs" lan="cs">Program.cs</button></li><li>MoreLinq 패키지에서 추가적인 편의성을 제공한다</li><li>↓ 일반 구문</li><p><strong>↓syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">from        LINQ는 from으로 시작한다
            from의 대상은 IEnumerable&lt;T>
            LINQ 결과도 IEnumerable&lt;T>
where + bool 판정식
orderby + 정렬 기준 [(ascending) | descending]
select + 결과</div><p><strong>↓예시</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">from mQuest in mQuests
where mQuest.quest_group_id.Equals(mQuestGroup.quest_group_id)
orderby mQuest.quest_name
select mQuest</div><li><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://docs.microsoft.com/ko-kr/dotnet/standard/parallel-programming/introduction-to-plinq">PLINQ</a></li><ul><li>AsParallel() : 가능한 경우 나머지 쿼리를 병렬로 실행</li><li>AsSequential() : 나머지 쿼리를 순차적으로 실행</li><li>AsOrdered() : 나머지 쿼리에 대해, 병렬로 실행하더라도 소스 시퀀스의 순서를 유지</li><li>AsUnordered() : 나머지 쿼리에 대해 소스 시퀀스 순서와 무관하게 실행</li><li>ForAll() : 순차 실행하는 foreach와 달리, 병렬로 결과 아이템 소비</li></ul><li>LINQ 내에서의 변수 선언 예 : let x = 10</li><li>중첩 쿼리 가능</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">from student in students
from score in student.Scores</div><li>Grouping 결과는 IGrouping&lt;T> 형식</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">from p in profiles
group p by p.Height &lt; 160 into lowGroup
select new { Key = lowGroup.Key, Profiles = lowGroup };</div><li>Inner Join</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">from a in A
join b in B on a.X equals b.Y</div><li>Outer Join</li><p>inner join 결과를 임시 컬렉션으로 치환하고, 임시 컬렉션의 빈 항목을 기본 값으로 채운다</p><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">from profile in profiles
join product in products on profile.Name equals product.Name into result
from product in result.DefaultIfEmpty( new Product() { Title = "없음” } )
select new { Name = profile.Name, Work = product.Title };</div><li>Expression Tree : System.Linq.Expressions</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">var const1 = Expression.Constant(1);
var param1 = Expression.Parameter(typeof(int), "x");
var exp = Expression.Add(const1, param1);
var lambda = Expression&lt;Func&lt;int, int>>.Lambda&lt;Func&lt;int, int>>(exp, new ParameterExpression[] { (ParameterExpression)param1 });
var compiledFunc = lambda.Compile();
Console.WriteLine(compiledFunc(3));
</div></ol><h3><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://docs.microsoft.com/ko-kr/dotnet/standard/data/xml/">System.Xml</a></h3><h3><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://docs.microsoft.com/ko-kr/dotnet/standard/data/sqlite/?tabs=netcore-cli">Microsoft.Data.Sqlite</a></h3><h3><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://docs.microsoft.com/ko-kr/ef/core/">Entity Framework(ORM)</a></h3></div></div><h1>문법</h1><div><h2>기본 자료형</h2><div><h3>숫자 리터럴</h3><p>16진수 표현 0xFFFF, 2진수 표현 0b1010, 구분 문자 '_' 사용 가능</p><h3>문자형</h3><table class="no-sort"><tr><td>char</td><td>2바이트(유니코드)</td><td>System.Char</td></tr><tr><td>string</td><td>동적 크기. Indexer 구현</td><td>System.String</td></tr></table><h3>문자열 리터럴</h3><ul><li>@"" : \ 이스케이프를 하지 않는다. ""로 일반 문자열의 \"를 대신할 수 있다</li><li>$"" Since C# 6 : 간편한 포맷 문자열을 제공한다. {<i>표현식</i>[,<i>alignment</i>][:<i>formatString</i>]}<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/VisualStudio/csharp_interpolated_string.cs" lan="cs">csharp_interpolated_string.cs</button></li><li>Since C# 8 : @$"", $@"" 모두 유효. 이전에는 $@""만 가능</li></ul><h3>Boolean</h3><p>Boolean 연산 &&, ||는 Short-circuit</p></div><h2>배열</h2><ul><li>배열 초기화시 기본값으로 채워진다</li><li>다차원 배열 [,] : 배열 차원 고정. 메모리 상에서는 일차원 배열처럼 존재</li><li>Jagged Array [][] : 배열의 차원이 가변적</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">int[] arr1 = new int[3];
int[] arr2 = new int[] { 1, 2, 3 };
int[] arr3 = { 1, 2, 3 };
int[,] arr4 = new int[2, 2];
int[,] arr5 = new int[,] { { 1, 2 }, { 3, 4 } };
</div></ul><h2>형변환</h2><p>as 연산자를 이용한 명시적 변환은, null을 허용하는 참조 자료형만 가능하다</p><h2>구문</h2><ul><li>if ~ else if ~ else</li><li>switch</li><p>정수, bool, char, string, enum에 대해 동작. case문 다음이 빈 문장일 때만 break 생략 가능</p><p>Since C# 7.0 : null이 아닌 모든 표현식 가능</p><li>while, do ~ while</li><li>for(초기식; 조건식; 증감식)</li><li>foreach(var obj in IEnumerable)</li><li>점프</li><p>break, continue, goto(관례상 레이블은 대문자로만), return, throw</p><li>checked/unchecked 블록</li><p>기본적으로는 프로그램 실행 시 오버플로/언더플로를 무시한다</p><p>checked/unchecked 블록은 이를 각각 명시적인 예외로 처리/비처리 하도록 한다</p><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/VisualStudio/CSharp/Basic/CheckedExample.cs" displayRange="[13, 39]" lan="cs">CheckedExample.cs</button></ul><h2>네임스페이스</h2><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">namespace MyProgram.Model { }
using System.Collections.Generic;
using static MyProgram.Model.Constants;
</div></div><h1>객체지향</h1><div><h2>클래스</h2><ul><li>프로퍼티 → (히든) 필드에 대한 getter/setter 메서드<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/VisualStudio/csharp_property.cs" lan="cs">ViewModel에서의 사용 예 »</button></li><li>익명 객체 → new { PropertyName = value } : 생성 후 읽기만 가능</li><li>정적 생성자 → static 클래스이름() { }</li><p>첫 번째 인스턴스가 만들어지거나 정적 멤버가 참조되기 전에 자동으로 호출된다</p><li>partial class ClassName {} : 프로젝트 내 여러 파일에 걸쳐 클래스 작성 가능</li><li>접근 제한자 → public, protected(파생 클래스까지), private, internal(같은 어셈블리), protected internal</li></ul><div><h3>상속</h3><ul><li>class SubClass : BaseClass</li><li>interface Interface1 : Interface2</li><li>is 연산자로 호환 여부 확인 가능</li><li>this 키워드 : 클래스의 현재 인스턴스<br>base 키워드 : 부모 클래스 메서드 또는 생성자 호출<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/VisualStudio/csharp_base_keyword.cs" lan="cs">csharp_base_keyword.cs</button></li><li>sealed 키워드 → 상속/재정의 불가</li><li>부모 클래스 인스턴스를 자식 클래스로 다운캐스팅 불가</li><li>모든 자료형의 조상은 System.Object : ToString(), GetType(), Equals(), GetHashCode()<br>모든 값 형식의 조상은 System.ValueType<br>모든 배열의 조상은 System.Array : Sort(), BinarySearch&lt;T>(), IndexOf(), ..., Length, Rank</li></ul></div><h2>제네릭</h2><ul><li>Type Bound</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">class MyGenereic&lt;T, U> where T : struct where U : class { }
// 값 형식         where T : struct
// 참조 형식       where T : class
// 기본 생성자 보유 where T : new()
// 호환 여부 검사   where T : BaseClassName | InterfaceName | U // U는 다른 형식 매개 변수
// where T : A[, B[, C[...]]]</div><li>제네릭 별명</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">using Commands = System.Collections.Generic.Dictionary&lt;string, System.Windows.Input.ICommand>;</div></ul></div><h1>추가 기능 ~ C# 8.0 (2019. 02. 12)</h1><div><h2>타입</h2><ol><li class="marker">BigInteger : 크기 제한없는 정수. 연산자 오버로딩 덕에 편리</li><li class="marker">dynamic : 파이썬처럼 타입 검사를 런타임에 하여 Duck-typing을 가능하게 한다</li><li class="marker">IntPtr : 32/64비트 프로그램에서 각각 4/8바이트. 포인터 외에 운영체제 핸들값을 저장하는 용도로도 사용</li><li class="marker">var : 지역변수 초기화시 사용 가능한 자동형식</li><li class="marker">Nullable&lt;T> : null을 허용하는 래퍼 클래스. int?는 Nullable&lt;int>와 동일하다</li></ol><div><h3>튜플 : System.ValueTuple</h3><ul><li>익명 튜플 : 멤버의 기본 이름은 Item1, Item2, ...</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">var unnamed = ("one", "two");</div><li>명명 튜플 : 컴파일하면 멤버명은 Item*으로 변경된다</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">var named = (first: "one", second: "two");</div><li>튜플 프로젝션 이니셜라이저 : 변수명을 자동으로 요소 이름으로 사용</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">var accumulation = (count, sum);</div><li>Since C# 7.3 ==, != 연산자 지원(short-circuit)</li><ul><li>Nullable인 튜플이나 멤버에 대해 자동으로 변환을 수행한다</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">var left = (a: 5, b: 10);
var right = (a: 5, b: 10);
(int a, int b)? nullableTuple = right;
Console.WriteLine(left == nullableTuple); // true</div><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">var left = (a: 5, b: 10);
(int? a, int? b) nullableMembers = (5, 10);
Console.WriteLine(left == nullableMembers); // true</div><li>튜플 멤버에 대한 암시적 변환을 수행한다</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">(long a, int b) longFirst = (5, 10);
(int a, long b) longSecond = (5, 10);
Console.WriteLine(longFirst == longSecond); // true</div></ul><li>메서드 튜플 반환</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">static (int Count, double Sum, double SumOfSquares) ComputeSumAndSumOfSquares(IEnumerable&lt;double> sequence) { }
static (int, double, double) ComputeSumAndSumOfSquares(IEnumerable&lt;double> sequence) { }
(int count, double sum, double sumOfSquares) = ComputeSumAndSumOfSquares(sequence);
(int count, var sum, var sumOfSquares) = ComputeSumAndSumOfSquares(sequence);
var (count, sum, sumOfSquares) = ComputeSumAndSumOfSquares(sequence);
var result = ComputeSumAndSumOfSquares(sequence);</div><li>메서드 튜플 매개변수</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">public void Print((int Count, double Sum, double SumOfSquares) data) { }
public void Print((int, double, double) data) { }</div><li>out 매개변수 튜플</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">var dict = new Dictionary&lt;int, (int, string)>();
dict.TryGetValue(2, out (int num, string place) pair);</div><li>튜플 분해</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">public class Rectangle
{
    public int X { get; set; }
    public int Y { get; set; }
    public int Width { get; set; }
    public int Height { get; set; }
    public void Deconstruct(out int x, out int y, out int width, out int height)
        => (x, y, width, height) = (X, Y, Width, Height);
}
// 또는 다른 형식에 대한 확장 메서드를 작성하여 분해를 지원할 수 있다
public static void Deconstruct(this Rectangle rect, out int x, out int y, out int width, out int height)
    => (x, y, width, height) = (rect.X, rect.Y, rect.Width, rect.Height);
var rect = new Rectangle(1, 2, 3, 4);
var (_, _, w, h) = rect;
</div></ul></div><h2>연산자</h2><ul><li class="marker">await : 피연산자가 나타내는 비동기 작업이 완료될 때까지 바깥쪽 비동기 메서드의 평가를 일시 중단</li><li class="marker">default(Type) : 타입에 대한 기본값/인스턴스 반환한다</li><p>Since C# 7.1 : default 리터럴로 기본값을 표현할 수 있다</p><li class="marker">nameof(Identifier) : 식별자 문자열 반환</li><li class="marker">Null 조건부 연산자 ?. 및 ?[]<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/VisualStudio/CSharp/Basic/NullableExample.cs" lan="cs">NullableExample.cs</button></li><ul><li>피연산자가 null이 아니면 멤버 액세스 ?. 또는 요소 액세스 ?[] 연산을 적용한다</li><li>null이면 그대로 null 반환</li><li>null 조건부 연산자를 연쇄적으로 이용할 때, 중간에서 null이 반환된 경우, 나머지는 처리되지 않는다</li></ul><li class="marker">stackalloc : 값 형식의 배열을 스택에 할당한다. fixed 문으로 고정하지 않아도 된다. 메서드 반환 시 자동 삭제된다; 임의 해제 불가</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">int* numbers = stackalloc int[100]; // 포인터는 unsafe 컨텍스트를 사용해야 한다
Span&lt;int> numbers = stackalloc int[100]; // Since C# 7.2 : Span, ReadOnlySpan에 할당 가능
var idx = numbers.IndexOfAny(stackalloc[] { 1, 2, 3, 4 }); // Since C# 8.0 : 다른 식 내부에서 stackalloc 사용 가능</div><li class="marker">?? 연산자 : 좌측 피연산자가 null이면 우측 피연산자를 반환</li><li class="marker">??= 연산자 Since C# 8.0 : 왼쪽 피연산자가 null로 평가되는 경우, 오른쪽 피연산자의 값을 대입</li><li class="marker">^ 연산자 Since C# 8.0 : 끝부터 시작하는 인덱스</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">// 시퀀스 길이가 length인 경우, ^1은 마지막 요소, ^length는 첫번째 요소, ^n은 length - n번째 요소
int[] xs = new[] { 0, 10, 20, 30, 40 };
int last = xs[^1];</div><li class="marker">범위 연산자 .. Since C# 8.0 : start..end // [start, end)</li><ul><li>a.. == a..^0</li><li>..b == 0..b</li><li>.. == 0..^0</li></ul><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">Console.WriteLine($"The last word is {words[^1]}");
var lazyDog = words[^2..^0];
var allWords = words[..]; // contains "The" through "dog"
var firstPhrase = words[..4]; // contains "The" through "fox"
var lastPhrase = words[6..]; // contains "the, "lazy" and "dog"
Range phrase = 1..4;
var text = words[phrase];
</div></ul><h2>한정자</h2><ul><li class="marker">async : 메서드, 람다식, 익명 메서드(delegate 연산자)를 비동기로 지정</li><ul><li>void 리턴 : await할 수 없으며, 따라서 예외를 catch할 수 없다</li><li>Task, Task&lt;TResult> : await 가능</li><li>Since C# 7.0 : 액세스 가능한 GetAwaiter() 메서드가 있는 모든 형식 리턴 가능</li><p>System.Threading.Tasks.ValueTask&lt;TResult>은 패키지 System.Threading.Tasks.Extensions가 제공하는 구현</p></ul><li class="marker">private protected : 동일 어셈블리 내의 클래스 및 파생 클래스에서 엑세스 가능</li><li class="marker">ref</li><ul><li>ref 매개변수 : 참조 전달. 호출자 스코프의 변수를 그대로 사용하는 효과. 참조가 존재하기 위해 호출 전에 초기화 필요</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">void Method(ref int refArgument)</div><li>ref 반환 : 참조 반환</li><li>ref 지역 변수 : ref 반환값으로 초기화되는 지역 변수</li><p>Since C# 7.3 : foreach 반복 변수는 ref 또는 ref readonly 지역 변수일 수 있다</p><li>ref readonly 반환 : 반환된 참조에 대한 쓰기는 비허용</li></ul><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">public ref decimal GetCurrentPrice() {
        // ...
        return ref DecimalArray[0];
}
ref decimal estValue = ref GetCurrentPrice();
ref decimal copyValue = ref estValue;</div><li class="marker">in 매개변수 : 참조 전달. 메서드에서 수정 불가</li><li class="marker">out 매개변수 : 참조 전달. 호출 전에 초기화되지 않아도 되지만, 반환 전에 할당돼야 한다</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">// 선언과 동시에 out 매개변수로 사용 가능
int.TryParse("12", out var result);
int.TryParse("21", out var _); // 출력 무시</div><li class="marker">ref struct : 스택에 할당되는 struct. 클래스의 멤버가 될 수 없다. 인터페이스를 구현할 수 없다<br>readonly struct : 모든 필드가 readonly인 struct</li><li class="marker">unsafe : unsafe로 한정한 타입, 메서드, 블록에서는 포인터를 사용할 수 있다</li><p>컴파일 시 -unsafe 옵션을 지정해야 한다 : 비주얼 스튜디오는 "프로젝트 속성 - 빌드 - 안전하지 않은 코드 허용"<br>관련 클래스 : System.Runtime.InteropServices.Marshal</p></ul><h2>메서드</h2><ol><li class="marker">매개변수 명시</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">Divide(a: 10, b: 3, q: out q, r: out r);</div><li class="marker">선택적 매개변수</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">Method(int a = 0, int b = 0) {}</div><li class="marker">가변 길이 매개변수 params<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/VisualStudio/CSharp/Basic/ParamsExample.cs" displayRange="[11, 17]" lan="cs">ParamsExample.cs</button></li><li class="marker">확장 메서드 : 기존 클래스에 static method 추가됨<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/VisualStudio/CSharp/Basic/ExtensionExample.cs" lan="cs">ExtensionExample.cs</button></li><li class="marker">람다 식 사용 확장 : 생성자, 소멸자, 이벤트 add/remove, 프로퍼티 set, 인덱서 set</li><li class="marker">메서드 안에 지역 함수 정의 가능</li><p>static 지역 함수로 선언하면 외부 변수 참조 불가</p><li class="marker">extern 메서드 : 메서드의 body가 없어도 컴파일 되도록 한다</li><p>호출할 메서드가 있는 dll을 [DllImport] Attribute로 지정해주면 해당 메서드를 호출한다. http://www.pinvoke.net/</p><li class="marker">Caller information</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">static void Log(string text,
                [CalleMemberName] string memberName = "",
                [CallerFilePath] string filePath = "",
                [CallerLineNumber] int lineNumber = 0) { }</div><li>Main 메서드에 async 허용</li></ol><h2>구문</h2><ol><li class="marker">인덱서 구문 : 하나 이상의 인수로 참조되는 프로퍼티. string, List&lt;T> 등은 인덱서를 구현함<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/VisualStudio/CSharp/Basic/IndexerExample.cs" lan="cs">IndexerExample.cs</button></li><li class="marker">switch case 필터 Since C# 7.0</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">switch(item) {
    case 100:
    case null:
    case DateTime dt:
    case int i when i > 300:
    case var i when i.어쩌구저쩌구():
}</div><li class="marker">전처리 지시문 #define, #undef, #if, #elif, #else, #endif, ..., #region, #endregion</li><li class="marker">fixed 문 : unsafe 컨텍스트에서, GC가 변수를 재배치하지 않도록 하여 포인터의 유효함을 보장한다</li></ol><div><h3>yield 반복기</h3><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">public static IEnumerable&lt;int> InfiniteSeries(int limit) {
    var num = 0;
    if(num &lt;= limit)
        yield return ++start;
    yield break;
}
public class Galaxies
{
    public IEnumerable&lt;Galaxy> NextGalaxy
    {
        get
        {
            yield return new Galaxy { Name = "Tadpole", MegaLightYears = 400 };
            yield return new Galaxy { Name = "Pinwheel", MegaLightYears = 25 };
            yield return new Galaxy { Name = "Milky Way", MegaLightYears = 0 };
            yield return new Galaxy { Name = "Andromeda", MegaLightYears = 3 };
        }
    }
}
</div></div><h2>App.config</h2><ol><li>supportedRuntime</li><p>실행에 필요한 닷넷 버전 지정. 비주얼 스튜디오가 자동으로 추가해주는듯</p><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/VisualStudio/CSharp/Basic/App.config" lan="xml">App.config »</button><li>appSettings</li><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/VisualStudio/CSharp/Basic/App.config" lan="xml">App.config »</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/VisualStudio/CSharp/Basic/Program.cs" lan="cs">Program.cs »</button></ol><h2>디버그 모드</h2><ol><li>전처리 상수 #if DEBUG ... #endif</li><li>[Conditional("DEBUG")] 적용된 클래스, 메서드는 릴리스 빌드 시 포함되지 않는다</li><li>System.Diagnostics.Debug.WriteLine() : 디버그 출력</li></ol><h2>Reflection 리플렉션</h2><ul><li>AppDomain → Assembly ← Module ← Type</li><p>AppDomain : EXE 프로세스 내에서 CLR에 의해 구현된 격리 공간. 최초 실행 시 기본적으로 1개 생성(AppDomain.CurrentDomain).</p><p>static 멤버들은 AppDomain 안에서 유일하다. 프로세스의 여러 AppDomain에서 동일한 클래스를 로드했다면 static 멤버들은 각 도메인마다 하나씩 존재</p><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">var appDomain = AppDomain.CreateDomain("MyDomain");
ObjectHandle handle = appDomain.CreateInstanceFrom(dllPath, "Namespace.ClassName");
...
AppDomain.Unload(appDomain);</div><li>Object.getType() or typeof 연산자</li><li>Type :: GetConstructors(), GetEvents(), GetFields(), GetMethods(), ...</li><li>동적 생성 : System.Activator.CreateInstance(Type);</li><li>동적 타입 정의 : System.Reflection.Emit</li><ol><li>System.AppDomain.DefineDynamicAssembly()로 AssemblyBuilder 객체 획득</li><li>AssemblyBuilder.DefineDynamicModule()로 ModuleBuilder 획득</li><li>ModuleBuilder.DefineType()으로 클래스 생성(TypeBuilder)</li><li>TypeBuilder.DefineMethod()로 MethodBuilder 획득</li><li>MethodBuilder.GetILGenerator()로 ILGenerator 객체 획득</li><li>ILGenerator.Emit()으로 메서드 내용 추가</li><li>TypeBuilder.CrateType()으로 인스턴스 생성 가능</li></ol></ul><h2>재귀 패턴 매칭 Since C# 8.0</h2><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">int? x = null;
if (x is int n1)
    Console.WriteLine(n1);
else
    Console.WriteLine("Not a int");
x = 3;
if (x is int n2)
    Console.WriteLine(n2);</div><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">var (a, b) = (1, 2);
switch(a, b)
{
    case (0, _):
        Console.WriteLine("a is 0");
        break;
    case (1, _):
        Console.WriteLine("a is 1");
        break;
}</div><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">public static bool IsComplete(int n) =>
    n switch
    {
        6 => true,
        28 => true,
        496 => true,
        8128 => true,
        33550336 => true,
        _ => false
    };</div><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">public static bool IsComplete(int n) =>
    n switch
    {
        int x when new int[] { 6, 28, 496, 8128, 33550336 }.Contains(x) => true,
        _ => false
    };</div><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">var newState = (GetState(), action, hasKey) switch {
    (DoorState.Closed, Action.Open, _) => DoorState.Opened,
    (DoorState.Opened, Action.Close, _) => DoorState.Closed,
    (DoorState.Closed, Action.Lock, true) => DoorState.Locked,
    (DoorState.Locked, Action.Unlock, true) => DoorState.Closed,
    (var state, _, _) => state };</div><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">var msg = "Hello";
if (msg is string { Length: 5 } five)
    Console.WriteLine($"Right. {msg} is a 5 length string");</div><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">public static decimal ComputeSalesTax(Address location, decimal salePrice) =>
    location switch {
        { State: "WA" } => salePrice * 0.06M,
        { State: "MI" } => salePrice * 0.05M,
        _ => 0M
    };</div><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">static Quadrant GetQuadrant(Point point) => point switch {
    (0, 0) => Quadrant.Origin,
        var (x, y) when x > 0 && y > 0 => Quadrant.One,
        var (x, y) when x &lt; 0 && y > 0 => Quadrant.Two,
        var (x, y) when x &lt; 0 && y &lt; 0 => Quadrant.Three,
        var (x, y) when x > 0 && y &lt; 0 => Quadrant.Four,
        var (_, _) => Quadrant.OnBorder,
        _ => Quadrant.Unknown
    };
</div></div><h1><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://devblogs.microsoft.com/dotnet/c-9-0-on-the-record/">C# 9.0</a></h1><div><h2>Init-only properties</h2><p>초기화 이후엔 프로퍼티에 할당 불가</p><p><strong>↓C#</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="C#">public class Person
{
    public string? FirstName { get; init; }
    public string? LastName { get; init; }
}
</div><h2>Init accessors and readonly fields</h2><p><strong>↓C#</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="C#">public class Person
{
    private readonly string name;

    public string Name
    {
        get => name;
        init => name = (value ?? "Anonymous");
    }
}
</div><h2>Records</h2><ul><li>class 키워드 대신 record 키워드로 선언하는 경우, 유사 값-타입이 된다</li><li>Equals 메서드에서 값을 기반으로 비교를 수행한다</li><li>다른 record를 상속할 수 있다</li><li>Positional records</li><p>Init-only properties, 생성자, deconstructor를 자동으로 생성한다</p><p><strong>↓C#</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="C#">public record Person(string FirstName, string LastName);

var person = new Person("Donggi", "Kim");
var (firstName, lastName) = person;

// 상속
public record Student(string FirstName, string LastName, int ID) : Person(FirstName, LastName);
</div></ul><h2>Top-level programs</h2><p>단일 파일 프로그램에 한해, Main() 정의없이 즉시 본문 작성 가능. await 가능</p><p><strong>↓C#</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="C#">using System;

Console.WriteLine("Hello World");
</div><h2>With-expressions</h2><p>변경 불가능한 데이터 인스턴스의 일부만 변경한 복제본 생성에 사용</p><p><strong>↓C#</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="C#">var newPerson = person with { LastName = "AI" };
</div><h2>Target-typed new expressions</h2><p><strong>↓C#</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="C#">Point[] ps = { new (1, 2), new (3, 4) };
</div><h2>Covariant returns</h2><p>메서드 상속 시 리턴 타입을 더욱 좁히는 것이 허용된다</p><p><strong>↓C#</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="C#">class Tiger : Animal
{
    public override Meat GetFood() => ...;
}
</div></div><h1>.NET 정규표현식</h1><ul><p>Java와 동일한 부분은 생략</p><li>\nn 또는 \nnn : 8진수 ASCII</li><li>\w : \p{L} | \p{Mn} | \p{Nd} | \p{Pc}</li><li>\Z : \z | (?=\n)</li><li>(?&lt;name>X) == (?'name'X)</li><ul><li>Named group</li><li>\k'name'역참조 가능. replace에서 ${name}참조 가능, GroupCollection의 인덱서로 참조 가능</li><li>그룹 오버로딩 가능 : (?&lt;1>a)(?&lt;1>\1b) // 스택처럼 정의가 쌓이며 '-name'으로 가장 최근 정의 삭제 가능</li></ul><li class="marker">균형 조정 그룹; Balancing group</li><ul><li>(?&lt;name1-name2>X) == (?'name1-name2'X)</li><p>name1은 현재 그룹(Optional)이고, name2는 이전에 정의된 그룹. 균형 조정 그룹은 마지막(백트래킹) name2 정의를 삭제하고, name1에 name2와 name1 사이 간격을 저장한다</p><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">var html = "&lt;html>&lt;body>Hello&lt;p>World&lt;/p>olleH&lt;/body>&lt;/html>Plain Text&lt;script>console.log('hello world');&lt;/script>Plain Text&lt;yes>Text&lt;/no>";
Console.WriteLine($"All text : {html}");
foreach (Match match in Regex.Matches(html, @"&lt;(?'tag'\w+)>(.(?&lt;!&lt;/\k&lt;tag>>))*(?'-tag'&lt;/\k&lt;tag>>)", RegexOptions.IgnoreCase))
    Console.WriteLine($"HTML part : {match.Groups[0]}");
// All text : &lt;html>&lt;body>Hello&lt;p>World&lt;/p>olleH&lt;/body>&lt;/html>Plain Text&lt;script>console.log('hello world');&lt;/script>Plain Text&lt;yes>Text&lt;/no>
// HTML part : &lt;html>&lt;body>Hello&lt;p>World&lt;/p>olleH&lt;/body>&lt;/html>
// HTML part : &lt;script>console.log('hello world');&lt;/script></div></ul><li>옵션</li><ul><li>(?imnsx-imnsx:X) // X 내에 옵션 적용/비적용. 이 자체는 캡처링 그룹이 아님</li><li>(?imnsx-imnsx) // 이후 식에 옵션 적용/비적용</li><li>System.Text.RegularExpressions.RegexOptions // Regex 생성자 또는 정적 메서드에 전체 옵션 지정</li><table class="no-sort"><tr><td>IgnoreCase</td><td>i</td><td>대소문자 구별X</td></tr><tr><td>Multiline</td><td>m</td><td>^, $이 \n에서도 동작</td></tr><tr><td>ExplicitCapture</td><td>n</td><td>명명된 캡처링 그룹만 유효</td></tr><tr><td>Singleline</td><td>s</td><td>.이 \n포함</td></tr><tr><td>IgnorePatternWhitespace</td><td>x</td><td>이스케이프되지 않은 공백을 패턴에서 제거하고 주석을 #으로 표시 가능</td></tr><tr><td>Compiled</td><td></td><td>어셈블리로 컴파일</td></tr><tr><td>RightToLeft</td><td></td><td>우→좌 검색</td></tr><tr><td>ECMAScript</td><td></td><td></td></tr><tr><td>CultureInvariant</td><td></td><td></td></tr><tr><td>None</td><td></td><td>옵션 없음 명시</td></tr></table></ul><li>(?>X) : Non-backtracking</li><li class="marker">Replace 구문</li><ul><li>$n, ${name} : 캡처링 그룹</li><li>$& : 전체 매칭 문자열</li><li>$` : 매칭 문자열 앞부분</li><li>$' : 매칭 문자열 뒷부분</li><li>$+ : 마지막 캡처링 그룹</li><li>$_ : 전체 입력 문자열</li></ul><li>인라인 주석 : (?#comment)</li></ul><details><summary class="marker">지원 Unicode class : \p{name} ↔ \P{name}</summary><table class="no-sort"><tr><th>Category</th><th>Description</th></tr><tr><td>Lu</td><td>Letter, Uppercase</td></tr><tr><td>Ll</td><td>Letter, Lowercase</td></tr><tr><td>Lt</td><td>Letter, Titlecase</td></tr><tr><td>Lm</td><td>Letter, Modifier</td></tr><tr><td>Lo</td><td>Letter, Other</td></tr><tr><td>L</td><td>Lu + Ll + Lt + Lm + Lo</td></tr><tr><td>Mn</td><td>Mark, Nonspacing</td></tr><tr><td>Mc</td><td>Mark, Spacing Combining</td></tr><tr><td>Me</td><td>Mark, Enclosing</td></tr><tr><td>M</td><td>Mn + Mc + Me</td></tr><tr><td>Nd</td><td>Number, Decimal Digit</td></tr><tr><td>Nl</td><td>Number, Letter</td></tr><tr><td>No</td><td>Number, Other</td></tr><tr><td>N</td><td>Nd + Nl + No</td></tr><tr><td>Pc</td><td>Punctuation, Connector</td></tr><tr><td>Pd</td><td>Punctuation, Dash</td></tr><tr><td>Ps</td><td>Punctuation, Start[Open]</td></tr><tr><td>Pe</td><td>Punctuation, End[Close]</td></tr><tr><td>Pi</td><td>Punctuation, Initial quote</td></tr><tr><td>Pf</td><td>Punctuation, Final quote</td></tr><tr><td>Po</td><td>Punctuation, Other</td></tr><tr><td>P</td><td>Pc + Pd + Ps + Pe + Pi + Pf + Po</td></tr><tr><td>Sm</td><td>Symbol, Math</td></tr><tr><td>Sc</td><td>Symbol, Currency</td></tr><tr><td>Sk</td><td>Symbol, Modifier</td></tr><tr><td>So</td><td>Symbol, Other</td></tr><tr><td>S</td><td>Sm + Sc + Sk + So</td></tr><tr><td>Zs</td><td>Separator, Space</td></tr><tr><td>Zl</td><td>Separator, Line</td></tr><tr><td>Zp</td><td>Separator, Paragraph</td></tr><tr><td>Z</td><td>Zs + Zl + Zp</td></tr><tr><td>Cc</td><td>Other, Control</td></tr><tr><td>Cf</td><td>Other, Format</td></tr><tr><td>Cs</td><td>Other, Surrogate</td></tr><tr><td>Co</td><td>Other, Private Use</td></tr><tr><td>Cn</td><td>Other, Not Assigned</td></tr><tr><td>C</td><td>Cc + Cf + Cs + Co + Cn</td></tr></table><table class="no-sort"><tr><th>Code point range</th><th>Block name</th></tr><tr><td>0000 - 007F</td><td>IsBasicLatin</td></tr><tr><td>0080 - 00FF</td><td>IsLatin-1Supplement</td></tr><tr><td>0100 - 017F</td><td>IsLatinExtended-A</td></tr><tr><td>0180 - 024F</td><td>IsLatinExtended-B</td></tr><tr><td>0250 - 02AF</td><td>IsIPAExtensions</td></tr><tr><td>02B0 - 02FF</td><td>IsSpacingModifierLetters</td></tr><tr><td>0300 - 036F</td><td>IsCombiningDiacriticalMarks</td></tr><tr><td>0370 - 03FF</td><td>IsGreek or IsGreekandCoptic</td></tr><tr><td>0400 - 04FF</td><td>IsCyrillic</td></tr><tr><td>0500 - 052F</td><td>IsCyrillicSupplement</td></tr><tr><td>0530 - 058F</td><td>IsArmenian</td></tr><tr><td>0590 - 05FF</td><td>IsHebrew</td></tr><tr><td>0600 - 06FF</td><td>IsArabic</td></tr><tr><td>0700 - 074F</td><td>IsSyriac</td></tr><tr><td>0780 - 07BF</td><td>IsThaana</td></tr><tr><td>0900 - 097F</td><td>IsDevanagari</td></tr><tr><td>0980 - 09FF</td><td>IsBengali</td></tr><tr><td>0A00 - 0A7F</td><td>IsGurmukhi</td></tr><tr><td>0A80 - 0AFF</td><td>IsGujarati</td></tr><tr><td>0B00 - 0B7F</td><td>IsOriya</td></tr><tr><td>0B80 - 0BFF</td><td>IsTamil</td></tr><tr><td>0C00 - 0C7F</td><td>IsTelugu</td></tr><tr><td>0C80 - 0CFF</td><td>IsKannada</td></tr><tr><td>0D00 - 0D7F</td><td>IsMalayalam</td></tr><tr><td>0D80 - 0DFF</td><td>IsSinhala</td></tr><tr><td>0E00 - 0E7F</td><td>IsThai</td></tr><tr><td>0E80 - 0EFF</td><td>IsLao</td></tr><tr><td>0F00 - 0FFF</td><td>IsTibetan</td></tr><tr><td>1000 - 109F</td><td>IsMyanmar</td></tr><tr><td>10A0 - 10FF</td><td>IsGeorgian</td></tr><tr><td>1100 - 11FF</td><td>IsHangulJamo</td></tr><tr><td>1200 - 137F</td><td>IsEthiopic</td></tr><tr><td>13A0 - 13FF</td><td>IsCherokee</td></tr><tr><td>1400 - 167F</td><td>IsUnifiedCanadianAboriginalSyllabics</td></tr><tr><td>1680 - 169F</td><td>IsOgham</td></tr><tr><td>16A0 - 16FF</td><td>IsRunic</td></tr><tr><td>1700 - 171F</td><td>IsTagalog</td></tr><tr><td>1720 - 173F</td><td>IsHanunoo</td></tr><tr><td>1740 - 175F</td><td>IsBuhid</td></tr><tr><td>1760 - 177F</td><td>IsTagbanwa</td></tr><tr><td>1780 - 17FF</td><td>IsKhmer</td></tr><tr><td>1800 - 18AF</td><td>IsMongolian</td></tr><tr><td>1900 - 194F</td><td>IsLimbu</td></tr><tr><td>1950 - 197F</td><td>IsTaiLe</td></tr><tr><td>19E0 - 19FF</td><td>IsKhmerSymbols</td></tr><tr><td>1D00 - 1D7F</td><td>IsPhoneticExtensions</td></tr><tr><td>1E00 - 1EFF</td><td>IsLatinExtendedAdditional</td></tr><tr><td>1F00 - 1FFF</td><td>IsGreekExtended</td></tr><tr><td>2000 - 206F</td><td>IsGeneralPunctuation</td></tr><tr><td>2070 - 209F</td><td>IsSuperscriptsandSubscripts</td></tr><tr><td>20A0 - 20CF</td><td>IsCurrencySymbols</td></tr><tr><td>20D0 - 20FF</td><td>IsCombiningDiacriticalMarksforSymbols or IsCombiningMarksforSymbols</td></tr><tr><td>2100 - 214F</td><td>IsLetterlikeSymbols</td></tr><tr><td>2150 - 218F</td><td>IsNumberForms</td></tr><tr><td>2190 - 21FF</td><td>IsArrows</td></tr><tr><td>2200 - 22FF</td><td>IsMathematicalOperators</td></tr><tr><td>2300 - 23FF</td><td>IsMiscellaneousTechnical</td></tr><tr><td>2400 - 243F</td><td>IsControlPictures</td></tr><tr><td>2440 - 245F</td><td>IsOpticalCharacterRecognition</td></tr><tr><td>2460 - 24FF</td><td>IsEnclosedAlphanumerics</td></tr><tr><td>2500 - 257F</td><td>IsBoxDrawing</td></tr><tr><td>2580 - 259F</td><td>IsBlockElements</td></tr><tr><td>25A0 - 25FF</td><td>IsGeometricShapes</td></tr><tr><td>2600 - 26FF</td><td>IsMiscellaneousSymbols</td></tr><tr><td>2700 - 27BF</td><td>IsDingbats</td></tr><tr><td>27C0 - 27EF</td><td>IsMiscellaneousMathematicalSymbols-A</td></tr><tr><td>27F0 - 27FF</td><td>IsSupplementalArrows-A</td></tr><tr><td>2800 - 28FF</td><td>IsBraillePatterns</td></tr><tr><td>2900 - 297F</td><td>IsSupplementalArrows-B</td></tr><tr><td>2980 - 29FF</td><td>IsMiscellaneousMathematicalSymbols-B</td></tr><tr><td>2A00 - 2AFF</td><td>IsSupplementalMathematicalOperators</td></tr><tr><td>2B00 - 2BFF</td><td>IsMiscellaneousSymbolsandArrows</td></tr><tr><td>2E80 - 2EFF</td><td>IsCJKRadicalsSupplement</td></tr><tr><td>2F00 - 2FDF</td><td>IsKangxiRadicals</td></tr><tr><td>2FF0 - 2FFF</td><td>IsIdeographicDescriptionCharacters</td></tr><tr><td>3000 - 303F</td><td>IsCJKSymbolsandPunctuation</td></tr><tr><td>3040 - 309F</td><td>IsHiragana</td></tr><tr><td>30A0 - 30FF</td><td>IsKatakana</td></tr><tr><td>3100 - 312F</td><td>IsBopomofo</td></tr><tr><td>3130 - 318F</td><td>IsHangulCompatibilityJamo</td></tr><tr><td>3190 - 319F</td><td>IsKanbun</td></tr><tr><td>31A0 - 31BF</td><td>IsBopomofoExtended</td></tr><tr><td>31F0 - 31FF</td><td>IsKatakanaPhoneticExtensions</td></tr><tr><td>3200 - 32FF</td><td>IsEnclosedCJKLettersandMonths</td></tr><tr><td>3300 - 33FF</td><td>IsCJKCompatibility</td></tr><tr><td>3400 - 4DBF</td><td>IsCJKUnifiedIdeographsExtensionA</td></tr><tr><td>4DC0 - 4DFF</td><td>IsYijingHexagramSymbols</td></tr><tr><td>4E00 - 9FFF</td><td>IsCJKUnifiedIdeographs</td></tr><tr><td>A000 - A48F</td><td>IsYiSyllables</td></tr><tr><td>A490 - A4CF</td><td>IsYiRadicals</td></tr><tr><td>AC00 - D7AF</td><td>IsHangulSyllables</td></tr><tr><td>D800 - DB7F</td><td>IsHighSurrogates</td></tr><tr><td>DB80 - DBFF</td><td>IsHighPrivateUseSurrogates</td></tr><tr><td>DC00 - DFFF</td><td>IsLowSurrogates</td></tr><tr><td>E000 - F8FF</td><td>IsPrivateUse or IsPrivateUseAreaIsPrivateUse or IsPrivateUseArea</td></tr><tr><td>F900 - FAFF</td><td>IsCJKCompatibilityIdeographs</td></tr><tr><td>FB00 - FB4F</td><td>IsAlphabeticPresentationForms</td></tr><tr><td>FB50 - FDFF</td><td>IsArabicPresentationForms-A</td></tr><tr><td>FE00 - FE0F</td><td>IsVariationSelectors</td></tr><tr><td>FE20 - FE2F</td><td>IsCombiningHalfMarks</td></tr><tr><td>FE30 - FE4F</td><td>IsCJKCompatibilityForms</td></tr><tr><td>FE50 - FE6F</td><td>IsSmallFormVariants</td></tr><tr><td>FE70 - FEFF</td><td>IsArabicPresentationForms-B</td></tr><tr><td>FF00 - FFEF</td><td>IsHalfwidthandFullwidthForms</td></tr><tr><td>FFF0 - FFFF</td><td>IsSpecials</td></tr></table></details></div></article><hr></body></html>