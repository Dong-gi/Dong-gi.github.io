<!DOCTYPE html><html lang="ko-KR"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="google-site-verification" content="aH-DyzdytYQ0NPHNQFcs5dVoiu5YNs6CEEHYgqDmAFM"><meta name="author" content="Donggi Kim &lt;hi.donggi@gmail.com&gt;"><meta name="description" content="C#.NET 정리"><title>C#.NET</title><link rel="icon" href="/imgs/favicon.png"><link id="w3css" rel="stylesheet" href="/source/w3.css"><link id="highlight-style" rel="stylesheet" href="/source/xcode.css"><link id="default-style" rel="stylesheet" href="/source/default.css"><script>window.wizFuncQueue = [];</script></head><body><div class="w3-bar-block w3-sidebar w3-animate-left" id="sidebar"><hr><a class="w3-bar-item w3-button" href="javascript:closeSidebar();">Close &times;</a><hr><div id="marker-list"></div><hr><div id="post-list"></div><hr><details class="w3-small file-list" open="open"><summary>LICENSE</summary><ul><li>&copy; <a href="mailto:hi.donggi@gmail.com">Donggi Kim</a> →<a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://github.com/Dong-gi/Dong-gi.github.io/blob/master/LICENSE">MIT License</a></li><li><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://www.w3schools.com/w3css">w3css</a> → No license</li><li><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://highlightjs.org/">highlight.js</a> →<a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://github.com/highlightjs/highlight.js/blob/main/LICENSE">BSD-3-Clause License</a></li><li><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://github.com/mathjax/MathJax">MathJax</a> →<a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://github.com/mathjax/MathJax/blob/master/LICENSE">Apache License 2.0</a></li><li><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://github.com/davidshimjs/qrcodejs">qrcodejs</a> →<a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://github.com/davidshimjs/qrcodejs/blob/master/LICENSE">MIT License</a></li></ul></details><hr></div><article id="main"><div class="w3-bar w3-blue w3-large" id="nav" style="position:-webkit-sticky;position:sticky;top:0px;vertical-align:middle"><button class="w3-bar-item w3-button w3-hover-theme" onclick="toggleSidebar()">&#9776;</button><input class="w3-bar-item" id="query" type="text" placeholder="search" style="max-width:35%"><a class="w3-bar-item w3-button w3-hover-theme" href="/">Home</a></div><div class="w3-padding" id="contents"><h1>작성 기준</h1><ul><li>2022년 04월</li><li>.NET 6.0</li><li>C# 10</li></ul><h1>.NET</h1><div><h2>.NET 개요</h2><ul><li>.NET은 (거의) 모든 플랫폼에서 구동하는 다양한 종류의 앱을 빌드하기 위한 무료 오픈 소스 개발 플랫폼</li><li>.NET은 다양한 구현체가 존재한다</li><ul><li>이전에 .NET Core로 불렸던 .NET 5 이상은 최신 구현으로, (거의) 모든 플랫폼에서 실행된다</li><li>.NET Framework는 .NET의 이전 구현으로, Windows에서만 실행된다</li><li>Mono는 Android, Mac, iOS, tvOS 및 watchOS에서 Xamarin 애플리케이션의 성능을 향상하는 런타임</li><p>Unity 엔진도 지원한다. iOS를 위한 전체 사전 컴파일(AOT; Ahead-Of-Time) 컴파일) 기능도 제공</p><li>UWP는 최신 Windows 앱을 빌드하는 데 사용</li></ul><li>.NET 앱은 MSBuild를 사용하여 소스 코드로부터 빌드</li><li>MSBuild와 .NET CLI는 GitHub Actions, Azure DevOps 등의 CI/CD 환경에 사용 가능</li><li>NuGet은 .NET을 위해 설계된 오픈 소스 패키지 관리자</li><p>NuGet 패키지는 컴파일된 코드(DLL), 코드와 관련된 다른 파일 및 패키지의 버전 번호와 같은 정보가 포함된 설명이 포함된 확장명 있는 .zip파일</p></ul><div><h3>.NET 실행 모델</h3><p>각 .NET 구현체는 다음을 포함한다</p><ul><li>런타임(e.g. .NET 5 CLR)</li><li>클래스 라이브러리(e.g. .NET 5 기본 클래스 라이브러리)</li><li>필요에 따른 애플리케이션 라이브러리(e.g. WPF, Windows Forms)</li><li>개발 도구</li></ul><div><h4 class="fake">CLR(Common Language Runtime)</h4><ul><li>.NET 앱은 CLR 환경에서 관리 코드를 실행한다</li><li>CLR은 Windows, macOS, Linux 지원을 포함하는 플랫폼 간 런타임으로, 메모리 할당 및 관리(GC)를 처리하는 가상 머신이다</li><li>관리 코드란 CLR이 실행을 관리하는 코드로써, C/C++ 처럼 프로그래머가 모든 작업을 관리하는 비관리 코드와 대조된다</li></ul><h4 class="fake">JIT(Just-In-Time) 컴파일러와 IL(Intermediate Language)</h4><ul><li>중간 언어는 고급 .NET 언어로 작성된 코드가 컴파일된 결과물로, 모든 고급 .NET 언어 및 하드웨어에 독립적이다</li><li>CLR이 중간 언어를 JIT 처리하여 CPU를 위한 기계어 코드를 생성하고 실행한다</li></ul><h4 class="fake">비관리 리소스 작업</h4><ul><li>e.g. FileStream은 관리 객체지만, 관리되지 않는 파일 핸들을 참조한다. 따라서 FileStream 사용을 마쳤다면 파일 핸들을 명시적으로 해제해야 한다</li><li>비관리 리소스를 참조하는 객체는 IDisposable 인터페이스를 구현한다. 이러한 객체를 using 문에서 사용하면 Dispose() 메서드를 자동으로 호출한다</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">var iDisposable = new FileStream("./", FileMode.Open);
try { } finally { iDisposable.Dispose(); }

// 아래와 동일
using (iDisposable = new FileStream("./", FileMode.Open)) { }
</div></ul></div><h3>.NET 배포 모델</h3><ul><li>자체 포함</li><p>.NET 런타임 및 라이브러리 등을 포함한 실행 파일 생성. .NET 런타임이 없는 머신에서도 실행 가능</p><li>프레임워크 종속</li><p>앱과 자체 종속성만 포함하는 .dll 파일과 실행 파일 생성. 사용자가 .NET을 설치해야 실행 가능</p></ul><h3>런타임 라이브러리 확장</h3><p>자주 사용되는 일부 기능은 런타임 라이브러리에 포함되지는 않지만 NuGet 패키지로 제공된다</p><table><tr><th>NuGet 패키지</th><th>설명서</th></tr><tr><td>Microsoft.Extensions.Hosting</td><td>애플리케이션 수명 관리(일반 호스트)</td></tr><tr><td>Microsoft.Extensions.DependencyInjection</td><td>DI(종속성 주입)</td></tr><tr><td>Microsoft.Extensions.Configuration</td><td>Configuration</td></tr><tr><td>Microsoft.Extensions.Logging</td><td>Logging</td></tr><tr><td>Microsoft.Extensions.Options</td><td>옵션 패턴</td></tr><tr><td>Microsoft.Extensions.FileSystemGlobbing</td><td>파일 탐색</td></tr><tr><td>Microsoft.Extensions.Http</td><td>HTTP</td></tr><tr><td>Microsoft.Extensions.Localization</td><td>지역화</td></tr></table></div><h2>.NET의 새로운 기능</h2><div><h3>.NET Core 2.0</h3><ul><li>C# 7.1 지원</li><li>.NET Standard 2.0 구현</li></ul><h3>.NET Core 2.1</h3><ul><li>JIT 컴파일러 개선 : 계층화된 컴파일</li><ol><li>가능한 빨리 코드를 생성하는 계층</li><li>자주 실행되는 메서드에 대한 최적화 코드를 생성하는 계층(병렬 수행)</li></ol><li>보다 메모리 효율적인 자료형 : System.Span&lt;T&gt;, System.Memory&lt;T&gt;</li><p>읽기 전용 System.ReadOnlySpan&lt;T&gt;, System.ReadOnlyMemory&lt;T&gt;도 지원</p></ul><h3>.NET Core 2.2</h3><ul><li>EventListener 클래스를 사용하여 GC, JIT, ThreadPool 등의 런타임 모니터링 가능<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/VisualStudio/ConsoleApp1/SimpleEventListener.cs" lan="cs">SimpleEventListener.cs</button></li><li><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://github.com/dotnet/core-setup/blob/master/Documentation/design-docs/host-startup-hook.md">호스트 시작 후크</a>를 사용하여 Main 메서드 실행 전 코드 삽입 가능</li></ul><h3>.NET Core 3.0</h3><ul><li>C# 8.0 지원</li><li>.NET Standard 2.1 구현</li><li>WPF 및 Windows Forms 지원</li><li>기본 Json 라이브러리 지원 : System.Text.Json</li><li>HTTP/2 지원</li><li>System.Index, System.Range 추가</li><li>IEnumerable&lt;T&gt;의 비동기 버전 IAsyncEnumerable&lt;T&gt; 추가</li></ul><h3>.NET 5</h3><ul><li>.NET Framework 4.x와의 혼동을 피하기 위해 버전 번호 4.x 생략</li><li>.NET 주요 구현임을 강조하기 위해 이름에서 "Core" 삭제</li><li>.NET Standard를 구현하진 않지만, .NET Standard 2.1를 지원</li><ul><li>.NET Standard 2.1 이후 새로운 .NET Standard 버전은 존재하지 않는다</li><li>신규 API가 추가될 때, .NET 5+는 기능의 구현을 공유하므로 모든 .NET 5+ 앱 및 라이브러리에서 즉시 사용 가능하다</li><p>이는 .NET Standard의 사양-구현 분리 문제를 해결한다</p></ul><li>C# 9 지원</li></ul><h3>.NET 6</h3><ul><li>C# 10 지원</li><li>.NET MAUI 2022년 2분기 일반 공개 예정</li><li>Json 라이브러리 강화</li><p>유효성 검사 및 기본값 제공, 멤버 순서 지정, 스트림 직렬화/역직렬화 등</p><li>우선순위 큐 PriorityQueue&lt;TElement,TPriority&gt; 추가</li><li>HTTP/3 Preview 지원</li><li>제네릭 타입에 대한 연산자 지원(Preview)</li></ul></div><h2>배포 모델</h2><div><h3>단일 파일 배포 및 실행 파일</h3><ul><li>배포 설정 시 "Produce single file"을 설정하면 관리형 DLL을 앱과 함께 단일 실행 파일에 제공한다</li><p>실행 시 관리형 DLL이 추출되어 메모리에 로드되며, 폴더로 추출되지는 않음 Since .NET 5</p><li>네이티브 라이브러리를 단일 파일로 묶고 싶다면 IncludeNativeLibrariesForSelfExtract 플래그 이용</li><p><strong>↓project.csproj</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="xml">&lt;IncludeNativeLibrariesForSelfExtract&gt;true&lt;/IncludeNativeLibrariesForSelfExtract&gt;</div><li>모든 파일을 단일 파일로 묶고 싶다면 IncludeAllContentForSelfExtract 플래그 이용</li><p><strong>↓project.csproj</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="xml">&lt;IncludeAllContentForSelfExtract&gt;true&lt;/IncludeAllContentForSelfExtract&gt;</div><p>위 두 옵션은 앱 실행 시 클라이언트 머신의 디렉터리에 파일이 추출된다</p><ul><li>Linux, MacOS : $HOME/.net</li><li>Windows : %TEMP%/.net</li><li>DOTNET_BUNDLE_EXTRACT_BASE_DIR 환경변수로 제어 가능</li></ul><li>PDB 파일을 DLL에 포함</li><p><strong>↓project.csproj</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="xml">&lt;DebugType&gt;embedded&lt;/DebugType&gt;</div><li>단일 파일 배포시 압축 Since .NET 6</li><p><strong>↓project.csproj</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="xml">&lt;EnableCompressionInSingleFile&gt;true&lt;/EnableCompressionInSingleFile&gt;</div></ul></div><h2>기본 코딩 구성 요소</h2><div><h3>Common Type System</h3><p>CLR에서 사용되는 데이터 타입의 선언, 사용, 관리 방법을 정의한다</p><h3>.NET의 데이터 타입</h3><p>.NET의 모든 타입은 아래의 2가지 범주에 해당한다</p><ul><li>Value type : value type의 인스턴스는 값 자체를 표현하며, value type의 인스턴스가 변수에 할당되는 경우 변수는 값의 사본을 갖는다</li><li>Reference type : reference type의 인스턴스는 실제 값에 대한 참조(포인터와 유사)를 표현하며, reference type의 인스턴스가 변수에 할당되는 경우 변수는 동일한 참조를 갖는다</li></ul><h3>클래스</h3><ul><li>클래스는 명시적으로 지정된 다른 클래스 또는 암시적으로 System.Object에서 파생되는 참조 타입</li><li>객체가 수행할 수 있는 작업과 객체에 포함되는 데이터(필드)를 정의한다.</li></ul><h3>구조체</h3><ul><li>구조체는 System.ValueType에서 파생되는 값 타입</li><li>값 타입이므로 생성자 호출 없이 변수 선언만으로 초기화가 진행된다. 이때 사용되는 기본 생성자는 자동으로 추가되며, 재정의할 수 없다</li><p>인자를 받는 생성자를 정의할 수 있으며, 생성자는 모든 필드를 초기화해야 한다</p><li>.NET의 모든 기본 데이터 타입(Boolean, Int32, ...)들도 구조체로 정의된다</li><li>명시적으로 다른 타입을 상속할 수 없으며, 구조체 자체도 다른 타입의 상속의 대상이 되지 않는다</li></ul><h3>열거형</h3><ul><li>열거형은 System.Enum에서 파생되는 값 타입으로, 기본 정수 타입의 값들에 대해 별명을 제공한다</li><li>내부 타입의 값을 형 변환 없이 열거형에 할당할 수 있다. and vice versa</li><li>메서드 정의 불가, 인터페이스 구현 불가, 프로퍼티 및 이벤트 정의 불가</li><li>열거형 자체는 기본 정수 타입에 대한 제네릭이므로, 열거형 정의에 타입 매개 변수를 사용할 수는 없다</li><li>FlagsAttribute를 이용해 비트 필드라는 특수한 형태의 열거형을 정의할 수 있다<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/VisualStudio/ConsoleApp2/Program.cs" lan="cs">Program.cs</button></li></ul><h3>인터페이스</h3><ul><li>인터페이스는 멤버와 시그니쳐만을 정의한다</li><li>인터페이스의 멤버는 모두 추상 멤버이며, 생성자를 가질 수 없다</li><li>필드 정의 불가, 정적 멤버 정의 불가</li><li>프로퍼티 정의는 가질 수 있다. 구현은 구현 클래스에서 제공</li></ul><h3>대리자</h3><ul><li>메서드를 참조할 수 있는 참조 타입</li><p><strong>↓명명 대리자 인스턴스 생성</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">public delegate void DoSomething();

public static void Main(string[] args)
{
    var delegate1 = new DoSomething(() =&gt; Console.WriteLine("delegate1"));
    delegate1.Invoke();
}</div><li>대리자는 System.Delegate → System.MulticastDelegate를 상속한다</li><li>익명 대리자 인스턴스 생성</li><ol><li>delegate 연산자 Since .NET Framework 2.0</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">var arr = new int[] { 1, 2, 3, 4, 5 };
Console.WriteLine(arr.Where(delegate (int n) { return n % 2 == 0; }).Sum());</div><li>람다 Since 3.0</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">var arr = new int[] { 1, 2, 3, 4, 5 };
Console.WriteLine(arr.Where(n =&gt; n % 2 == 0).Sum());</div></ol><li>미리 정의된 재사용 가능 대리자</li><ul><li>Action : void 리턴 메서드 참조. 매개변수 0 ~ 16개, 총 17가지</li><li>Func : 결과를 반환하는 메서드 참조. 매개변수 0 ~ 16개, 총 17가지</li><li>Predicate : bool을 반환하는 Func</li></ul></ul><h3>멤버</h3><ul><li>필드 : 임의 타입 변수</li><li>프로퍼티 : (히든) 필드에 대한 get/set 접근자</li><p>프로퍼티의 타입과 프로퍼티 내에서 참조하는 필드의 타입이 같을 필요는 없다</p><li>메서드</li><ul><li>메서드 오버로딩</li><p>메서드 시그니처는 이름과 매개 변수 목록으로 구성되며, 메서드 시그니처가 다르다면 이름이 같은 2개 이상의 메서드를 정의할 수 있다</p><li>연산자 오버로딩<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/VisualStudio/ConsoleApp3/Program.cs" lan="cs">Program.cs</button></li></ul><li>생성자</li><li>이벤트</li><p>대리자를 이용한 관찰자 패턴. 간단하게 구독/해지 가능<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/VisualStudio/ConsoleApp5/SomeTimer.cs" lan="cs">SomeTimer.cs</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/VisualStudio/ConsoleApp5/Program.cs" lan="cs">Program.cs</button></p><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">public delegate void EventHandler(object? sender, EventArgs e);
public delegate void EventHandler&lt;TEventArgs&gt;(object? sender, TEventArgs e);</div><p>이벤트 핸들러 추가/제거 작업 재정의 가능<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/VisualStudio/ConsoleApp6/SomeTimer.cs" lan="cs">SomeTimer.cs</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/VisualStudio/ConsoleApp6/Program.cs" lan="cs">Program.cs</button></p><li>중첩 타입</li></ul><h3>멤버의 특성</h3><table><tr><th>특성</th><th>적용 대상</th><th>설명</th></tr><tr><td>abstract</td><td>메서드, 프로퍼티, 이벤트</td><td>파생 타입에서 구현 제공</td></tr><tr><td>private, family, assembly, family and assembly, family or assembly, public</td><td>모두</td><td>멤버 액세스 범위 제한</td></tr><tr><td>final</td><td>메서드, 프로퍼티, 이벤트</td><td>파생 타입에서 재정의 불가</td></tr><tr><td>initialize-only</td><td>필드</td><td>초기화 이후 변경 불가</td></tr><tr><td>newslot, override</td><td>모두</td><td>시그니처가 같은 상속된 멤버와의 상호작용. new(숨김, default, 부모 타입으로 형변환하여 숨긴 메서드 호출 가능), override(재정의)</td></tr><tr><td>virtual</td><td>메서드, 프로퍼티, 이벤트</td><td>파생 타입에서 다른 구현을 제공할 수 있다. 메서드의 어떤 구현을 호출할 지 결정하는 것은 런타임에 호출을 수행하는 인스턴스의 타입. 원하는 버전의 메서드를 호출하려면 해당 타입으로 변수를 캐스팅</td></tr></table><h3>.NET의 타입 변환</h3><ul><li>파생 클래스에서 부모 클래스로의 변환은 연산자 없이 자동 지원</li><li>부모 클래스에서 파생 클래스로의 변환은 연산자를 이용해 자동 지원</li><li>클래스에서 구현하는 인터페이스로의 변환은 연산자 없이 자동 지원</li><li>인터페이스에서 구현 클래스로의 변환은 연산자를 이용해 자동 지원</li><li>사용자 정의 암시적/명시적 타입 변환<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/VisualStudio/ConsoleApp4/Program.cs" lan="cs">Program.cs</button></li></ul><h3>제네릭의 공변성(Covariance) 및 반공변성(Contravariance)</h3><ul><li>Covariance : 지정된 것보다 더 많은 파생 타입을 사용 가능</li><p>e.g. IEnumerable&lt;Derived&gt; 인스턴스를 IEnumerable&lt;Base&gt; 변수에 할당 가능</p><li>Contravariance : 지정된 것보다 더 일반적인 타입을 사용 가능</li><p>e.g. Action&lt;Base&gt; 인스턴스를 Action&lt;Derived&gt; 변수에 할당 가능</p><li>Invariance : 지정된 타입만 사용 가능</li><p>e.g. List&lt;Base&gt;는 List&lt;Derived&gt; 변수에 할당 불가능. and vice versa</p></ul><table><tr><th>타입</th><th>공변 타입 매개 변수</th><th>반공변 타입 매개 변수</th></tr><tr><td>Action&lt;T&gt;</td><td></td><td>Y</td></tr><tr><td>Comparison&lt;T&gt;</td><td></td><td>Y</td></tr><tr><td>Converter&lt;TInput,TOutput&gt;</td><td>Y</td><td>Y</td></tr><tr><td>Func&lt;TResult&gt;</td><td>Y</td><td></td></tr><tr><td>Func&lt;T,TResult&gt;</td><td>Y</td><td>Y</td></tr><tr><td>IComparable&lt;T&gt;</td><td></td><td>Y</td></tr><tr><td>Predicate&lt;T&gt;</td><td></td><td>Y</td></tr><tr><td>IComparer&lt;T&gt;</td><td></td><td>Y</td></tr><tr><td>IEnumerable&lt;T&gt;</td><td>Y</td><td></td></tr><tr><td>IEnumerator&lt;T&gt;</td><td>Y</td><td></td></tr><tr><td>IEqualityComparer&lt;T&gt;</td><td></td><td>Y</td></tr><tr><td>IGrouping&lt;TKey,TElement&gt;</td><td>Y</td><td></td></tr><tr><td>IOrderedEnumerable&lt;TElement&gt;</td><td>Y</td><td></td></tr><tr><td>IOrderedQueryable&lt;T&gt;</td><td>Y</td><td></td></tr><tr><td>IQueryable&lt;T&gt;</td><td>Y</td><td></td></tr></table><h3>컬렉션</h3><table><tr><td>수행할 작업</td><td>제네릭 컬렉션 옵션</td><td>제네릭이 아닌 컬렉션 옵션</td><td>스레드-안전 or 불변 컬렉션 옵션</td></tr><tr><td>키-값 쌍 저장 &amp; 키를 통한 조회</td><td>Dictionary&lt;TKey,TValue&gt;</td><td>Hashtable</td><td>ConcurrentDictionary&lt;TKey,TValue&gt;, ReadOnlyDictionary&lt;TKey,TValue&gt;, ImmutableDictionary&lt;TKey,TValue&gt;</td></tr><tr><td>임의 인덱스를 이용한 조회</td><td>List&lt;T&gt;</td><td>Array, ArrayList</td><td>ImmutableList&lt;T&gt;, ImmutableArray</td></tr><tr><td>FIFO</td><td>Queue&lt;T&gt;</td><td>Queue</td><td>ConcurrentQueue&lt;T&gt;, ImmutableQueue&lt;T&gt;</td></tr><tr><td>LIFO</td><td>Stack&lt;T&gt;</td><td>Stack</td><td>ConcurrentStack&lt;T&gt;, ImmutableStack&lt;T&gt;</td></tr><tr><td>삽입 순서에 따른 조회</td><td>LinkedList&lt;T&gt;</td><td>권장 사항 없음</td><td>권장 사항 없음</td></tr><tr><td>컬렉션 변경 감시(INotifyPropertyChanged 및 INotifyCollectionChanged 구현)</td><td>ObservableCollection&lt;T&gt;</td><td>권장 사항 없음</td><td>권장 사항 없음</td></tr><tr><td>정렬된 컬렉션</td><td>SortedList&lt;TKey,TValue&gt;</td><td>SortedList</td><td>ImmutableSortedDictionary&lt;TKey,TValue&gt;, ImmutableSortedSet&lt;T&gt;</td></tr><tr><td>집합</td><td>HashSet&lt;T&gt;, SortedSet&lt;T&gt;</td><td>권장 사항 없음</td><td>ImmutableHashSet&lt;T&gt;, ImmutableSortedSet&lt;T&gt;</td></tr></table><h3>예외</h3><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">// 명시적 예외 발생
throw e; // e는 System.Exception 및 파생 클래스의 인스턴스

// 예외 처리
try { } catch { } finally { }   // 임의 예외 처리
try { } catch (Exception) { }   // 특정 예외 처리
try { } catch { throw; }        // 호출 스택으로 예외 넘기기
try { } catch (Exception e) { } // 특정 예외 처리. 예외 인스턴스 참조

var flag = Random.Shared.Next() % 2 == 0;
try { } // when 필터를 사용하는 경우, 같은 타입을 여러 번 catch 가능
catch (Exception) when (flag) { }
catch (Exception) when (!flag) { }
</div><h3>.NET의 숫자</h3><div><h4 class="fake">정수</h4><table><tr><th>타입</th><th>크기(바이트)</th><th>최소값</th><th>최대값</th></tr><tr><td>System.Int16</td><td>2</td><td>-32,768</td><td>32,767</td></tr><tr><td>System.Int32</td><td>4</td><td>-2,147,483,648</td><td>2,147,483,647</td></tr><tr><td>System.Int64</td><td>8</td><td>-9,223,372,036,854,775,808</td><td>9,223,372,036,854,775,807</td></tr><tr><td>System.SByte</td><td>1</td><td>-128</td><td>127</td></tr><tr><td>System.IntPtr(32비트 프로세스)</td><td>4</td><td>-2,147,483,647</td><td>2,147,483,647</td></tr><tr><td>System.IntPtr(64비트 프로세스)</td><td>8</td><td>-9,223,372,036,854,775,808</td><td>9,223,372,036,854,775,807</td></tr><tr><td>System.Byte</td><td>1</td><td>0</td><td>255</td></tr><tr><td>System.UInt16</td><td>2</td><td>0</td><td>65,535</td></tr><tr><td>System.UInt32</td><td>4</td><td>0</td><td>4,294,967,295</td></tr><tr><td>System.UInt64</td><td>8</td><td>0</td><td>18,446,744,073,709,551,615</td></tr><tr><td>System.UIntPtr(32비트 프로세스)</td><td>4</td><td>0</td><td>4,294,967,295</td></tr><tr><td>System.UIntPtr(64비트 프로세스)</td><td>8</td><td>0</td><td>18,446,744,073,709,551,615</td></tr><tr><td>BigInteger</td><td>무제한</td><td>-∞</td><td>∞</td></tr></table><h4 class="fake">부동소수</h4><p>부동소수는 NaN 및 무한대에 관한 특별한 클래스 멤버를 제공한다</p><table><tr><th>타입</th><th>크기(바이트)</th><th>근사 범위</th><th>참고</th></tr><tr><td>System.Half</td><td>2</td><td>±65504</td><td>Since .NET 5</td></tr><tr><td>System.Single</td><td>4</td><td>±3.4 x 1038</td><td></td></tr><tr><td>System.Double</td><td>8</td><td>±1.7 × 10308</td><td></td></tr><tr><td>System.Decimal</td><td>16</td><td>±7.9228 x 1028</td><td></td></tr></table><h4 class="fake">복소수</h4><p>System.Numerics.Complex</p><h4 class="fake">SIMD(Single Instruction Multiple Data)</h4><ul><li>Vector&lt;T&gt; : 고속 병렬 처리를 위한 T 타입 1차원 벡터</li><li>Vector2, Vector3, Vector4 : Single 값에 대한 2~4차원 벡터</li><li>Matrix3x2, Matrix4x4 : 각각 3x2, 4x4 행렬</li><li>Plane : 평면</li><li>Quaternion : 3차원 물리적 회전</li></ul></div><h3>날짜, 시간 및 표준 시간대</h3><ul><li>DateTime : UTC 기준 시각. 0001-01-01 00:00:00 ~ 9999-12-31 23:59:59</li><p>시간은 틱이라고 하는 100나노초 단위로 측정. 시각은 1년 1월 1일 자정 이후로 경과한 틱 수</p><li>DateTimeOffset : DateTime + UTC로부터의 offset</li><li>TimeZoneInfo : 표준 시간대</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">Console.WriteLine(DateTime.Now);            // 2022-04-20 오후 9:06:11
Console.WriteLine(DateTime.UtcNow);         // 2022-04-20 오후 12:06:11

Console.WriteLine(DateTimeOffset.Now);      // 2022-04-20 오후 9:06:11 +09:00
Console.WriteLine(DateTimeOffset.UtcNow);   // 2022-04-20 오후 12:06:11 +00:00
Console.WriteLine(                          // 2022-04-20 오후 9:06:11 +09:00
    new DateTimeOffset(DateTime.Now, TimeZoneInfo.Local.BaseUtcOffset));
Console.WriteLine(                          // 2022-04-20 오후 12:06:11 +09:00
    new DateTimeOffset(new DateTime(DateTime.UtcNow.Ticks), TimeZoneInfo.Local.BaseUtcOffset));

Console.WriteLine(DateTime.Now.Ticks - DateTime.UtcNow.Ticks);              // 323999999997 = 9시간
Console.WriteLine(DateTimeOffset.Now.Ticks - DateTimeOffset.UtcNow.Ticks);  // 323999999942 = 9시간</div><li>DateOnly Since .NET 6 : 0001-01-01 ~ 9999-12-31</li><li>TimeOnly Since .NET 6 : 00:00:00 ~ 23:59:59</li></ul><h3>Attribute</h3><ol><li>자바의 애너테이션처럼 요소를 장식한다<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/VisualStudio/ConsoleApp7/Program.cs" lan="cs">Program.cs</button></li><li>사용자 정의 특성은 System.Attribute를 상속하여 만든다</li><li>명명시 Attribute를 접미하고, 실제 사용할 땐 생략 가능하다</li><li>특성 적용 대상 제한 : System.AttributeUsage 생성자에 AttributeTargets 전달. 생략시 기본값은 AttributeTargets.All</li><li>적용 대상 명시 : assembly, module, type, method, property, field, event, param, return, typevar</li></ol></div><h2>데이터 액세스</h2><div><h3>LINQ; Language Itegrated Query</h3><ol><li>데이터에 대한 선언적 코드<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/VisualStudio/ConsoleApp8/Program.cs" lan="cs">Program.cs</button></li><li>MoreLinq 패키지에서 추가적인 편의성을 제공한다</li><li>↓ 일반 구문</li><p><strong>↓syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">from        LINQ는 from으로 시작한다
            from의 대상은 IEnumerable&lt;T&gt;
            LINQ 결과도 IEnumerable&lt;T&gt;
where + bool 판정식
orderby + 정렬 기준 [(ascending) | descending]
select + 결과</div><p><strong>↓예시</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">from mQuest in mQuests
where mQuest.quest_group_id.Equals(mQuestGroup.quest_group_id)
orderby mQuest.quest_name
select mQuest</div><li><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://docs.microsoft.com/ko-kr/dotnet/standard/parallel-programming/introduction-to-plinq">PLINQ</a></li><ul><li>AsParallel() : 가능한 경우 나머지 쿼리를 병렬로 실행</li><li>AsSequential() : 나머지 쿼리를 순차적으로 실행</li><li>AsOrdered() : 나머지 쿼리에 대해, 병렬로 실행하더라도 소스 시퀀스의 순서를 유지</li><li>AsUnordered() : 나머지 쿼리에 대해 소스 시퀀스 순서와 무관하게 실행</li><li>ForAll() : 순차 실행하는 foreach와 달리, 병렬로 결과 아이템 소비</li></ul><li>LINQ 내에서의 변수 선언 예 : let x = 10</li><li>중첩 쿼리 가능</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">from student in students
from score in student.Scores</div><li>Grouping 결과는 IGrouping&lt;T&gt; 타입</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">from p in profiles
group p by p.Height &lt; 160 into lowGroup
select new { Key = lowGroup.Key, Profiles = lowGroup };</div><li>Inner Join</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">from a in A
join b in B on a.X equals b.Y</div><li>Outer Join</li><p>inner join 결과를 임시 컬렉션으로 치환하고, 임시 컬렉션의 빈 항목을 기본 값으로 채운다</p><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">from profile in profiles
join product in products on profile.Name equals product.Name into result
from product in result.DefaultIfEmpty( new Product() { Title = "없음” } )
select new { Name = profile.Name, Work = product.Title };</div><li>Expression Tree : System.Linq.Expressions</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">var const1 = Expression.Constant(1);
var param1 = Expression.Parameter(typeof(int), "x");
var exp = Expression.Add(const1, param1);
var lambda = Expression&lt;Func&lt;int, int&gt;&gt;.Lambda&lt;Func&lt;int, int&gt;&gt;(exp, new ParameterExpression[] { (ParameterExpression)param1 });
var compiledFunc = lambda.Compile();
Console.WriteLine(compiledFunc(3));
</div></ol><h3><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://docs.microsoft.com/ko-kr/dotnet/standard/data/xml/">System.Xml</a></h3><h3><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://docs.microsoft.com/ko-kr/dotnet/standard/data/sqlite/?tabs=netcore-cli">Microsoft.Data.Sqlite</a></h3><h3><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://docs.microsoft.com/ko-kr/ef/core/">Entity Framework(ORM)</a></h3></div></div><h1>C#</h1><div><h2>프로그램 구조</h2><ul><li>C# 프로그램은 하나 이상의 어셈블리 파일로 구성</li><li>어셈블리 파일은 0개 이상의 네임스페이스를 포함</li><li>네임스페이스는 클래스, 인터페이스 등의 타입이나 다른 네임스페이스를 포함</li><li>프로그램은 단 하나의 진입점(Main 메서드)을 가질 수 있다; 라이브러리와 서비스는 진입점이 필요없다</li></ul><div><h3>Main 메서드</h3><ul><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">class TestClass
{
    static void Main(string[] args) { }
}</div><li>static이어야 한다</li><li>public일 필요는 없다</li><li>Main 메서드를 가진 클래스 또는 구조체가 static일 필요는 없다</li><li>void 또는 int를 반환할 수 있다</li><li>Since 7.1 Task 또는 Task&lt;int&gt;를 반환하는 async 메서드로 선언할 수 있다</li><li>string[] 매개변수를 받지 않아도 된다</li><li>여러 Main 메서드를 선언한 경우, 컴파일 시 진입점을 명시적으로 지정해야 한다</li></ul><h3>최상위 문 Since 9</h3><ul><li>Main 메서드를 선언하는 대신, 최상위 문으로 직접 작성할 수 있다</li><li>컴파일 시 다른 Main 메서드를 진입점으로 지정할 수 없다</li><li>최상위 문은 암시적으로 전역 네임스페이스다</li><li>최상위 문이 포함된 파일에서 네임스페이스, 타입 정의는 최상위 문이 뒤에 위치해야 한다</li><li>최상위 문은 args 배열 변수를 이용해 명령줄 인자에 접근할 수 있다</li><li>await 키워드 사용 가능</li></ul></div><h2>타입 시스템</h2><div><h3>네임스페이스</h3><ul><li>네임스페이스를 이용해 대규모 프로젝트에서 타입 및 메서드 이름의 범위를 제어 가능</li><li>using 지시문을 이용해 네임스페이스 타이핑 생략 가능</li><li>global 네임스페이스는 루트 네임스페이스</li><p>e.g. global::System은 항상 .NET System 네임스페이스를 가리킨다</p></ul><h3>클래스</h3><ul><li>class 키워드로 정의하고, new 키워드로 인스턴스 생성</li><li>익명 객체 : 생성 후 읽기만 가능</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">var o1 = new { X = 1, Y = 2 };
var o2 = o1 with { Y = 3 };
var o3 = new { o2.X, o2.Y, z = 4 };</div><li>정적 생성자 : 첫 번째 인스턴스가 만들어지거나 정적 멤버가 참조되기 전에 1회 호출</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">class ClassName
{
    static ClassName() { }
}</div><li>부분 클래스 : 프로젝트 내 여러 파일에 걸쳐 클래스 작성</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">partial class ClassName { }</div><li>상속</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">class SubClass : BaseClass { }</div><li>sealed 키워드로 상속 방지 가능</li><li>as 연산자를 이용한 명시적 형변환은 null을 허용하는 참조 자료형만 가능</li><li>this 키워드 : 클래스의 현재 인스턴스 참조</li><li>base 키워드 : 부모 클래스 메서드 또는 생성자 호출</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">public class Person
{
    public Person(int pID) { }
    public virtual void Print() =&gt; Console.WriteLine("Default Print() in Person");
}
public class Employee : Person
{
    public Employee(int pID, int eID) : base(pID) { }
    public override void Print()
    {
        Console.WriteLine("Before Print");
        base.Print();
        Console.WriteLine("After Print");
    }
}
</div></ul><h3>튜플 System.ValueTuple Since 8.0</h3><ul><li>익명 튜플 : 멤버의 기본 이름은 Item1, Item2, ...</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">var unnamed = ("one", "two");</div><li>명명 튜플 : 컴파일하면 멤버명은 Item*으로 변경된다</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">var named = (first: "one", second: "two");</div><li>튜플 프로젝션 이니셜라이저 : 변수명을 자동으로 요소 이름으로 사용</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">var accumulation = (count, sum);</div><li>Since 7.3 ==, != 연산자 지원(short-circuit)</li><ul><li>Nullable인 튜플이나 멤버에 대해 자동으로 변환을 수행한다</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">var left = (a: 5, b: 10);
(int a, int b)? nullableTuple = left;
Console.WriteLine(left == nullableTuple);</div><li>튜플 멤버에 대한 암시적 변환을 수행한다</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">(long a, int b) longFirst = (5, 10);
(int a, long b) longSecond = (5, 10);
Console.WriteLine(longFirst == longSecond);</div></ul><li>메서드 튜플 반환</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">static (int, int) Divmod(int a, int b) { }
var (div, mod) = Divmod(123, 12);</div><li>메서드 튜플 매개변수</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">public void Print((int, double, double) data) { }</div><li>out 매개변수 튜플</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">var dict = new Dictionary&lt;int, (int, string)&gt;();
dict.TryGetValue(2, out (int num, string place) pair);
</div></ul><h3>Record Since 9</h3><ul><li>class 키워드 대신 record 키워드로 선언하는 경우, 유사 값-타입이 된다</li><li>Equals 메서드에서 값을 기반으로 비교를 수행한다</li><li>다른 record를 상속할 수 있다</li><li>Positional record</li><p>레코드 정의 시 위치 매개 변수를 사용하면 init-only properties, 생성자, deconstructor 등을 자동으로 생성한다</p><p><strong>↓C#</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="C#">var person1 = new Person("X", "Y");
var (firstName, lastName) = person1;
var person2 = person1 with { LastName = "Z" };

public record Person(string FirstName, string LastName);
public record Student(string FirstName, string LastName, int ID) : Person(FirstName, LastName);</div><li>record struct Since 10</li><p>변경 가능한 record. record struct는 상속을 지원하지 않는다</p></ul><h3>인터페이스</h3><ul><li>구현 클래스는 인터페이스의 프로퍼티 및 인덱서에 접근자를 추가할 수 있다</li><p>e.g. get 접근자만 있는 인터페이스 프로퍼티에 set 접근자 추가 가능</p><li>Since 8.0 멤버 기본 구현 정의 가능</li><li>Since 11 필드가 아닌 인터페이스 멤버는 static abstract 가능</li></ul><h3>제네릭</h3><ul><li>Type Bound</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">class MyGenereic&lt;T, U&gt; where T : struct where U : class { }
// where T : struct                                 값 타입
// where T : class                                  참조 타입
// where T : new()                                  기본 생성자 보유
// where T : BaseClassName | InterfaceName | U      호환 여부 검사. U는 다른 타입 매개 변수
// where T : A[, B[, C[...]]]</div><li>제네릭 별명</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">using Commands = System.Collections.Generic.Dictionary&lt;string, System.Windows.Input.ICommand&gt;;</div></ul><h3>숫자 타입</h3><table><tr><th>C# 타입</th><th>.NET 타입</th></tr><tr><td>sbyte</td><td>System.SByte</td></tr><tr><td>byte</td><td>System.Byte</td></tr><tr><td>short</td><td>System.Int16</td></tr><tr><td>ushort</td><td>System.UInt16</td></tr><tr><td>int</td><td>System.Int32</td></tr><tr><td>uint</td><td>System.UInt32</td></tr><tr><td>long</td><td>System.Int64</td></tr><tr><td>ulong</td><td>System.UInt64</td></tr><tr><td>nint</td><td>System.IntPtr</td></tr><tr><td>nuint</td><td>System.UIntPtr</td></tr><tr><td>float</td><td>System.Single</td></tr><tr><td>double</td><td>System.Double</td></tr><tr><td>decimal</td><td>System.Decimal</td></tr></table><ul><li>정수 리터럴</li><ul><li>16진수 표현 0xFFFF, 2진수 표현 0b1010, 구분 문자 '_' 사용 가능</li><li>접미사가 없는 경우 int, uint, long, ulong 중에서 표현 가능한 첫 번째 것</li><li>접미사가 대소문자 구별 없이 U인 경우 uint, ulong 중 표현 가능한 첫 번째 것</li><li>접미사가 대소문자 구별 없이 L인 경우 long, ulong 중 표현 가능한 첫 번째 것</li><li>접미사가 대소문자 구별 없이 UL, LU인 경우 ulong</li></ul><li>실수 리터럴</li><ul><li>접미사가 없는 경우 double</li><li>접미사가 F, f인 경우 float</li><li>접미사가 M, m인 경우 decimal</li></ul></ul><h3>문자 관련 타입</h3><ul><li>char(System.Char) : 유니코드 1글자</li><li>string(System.String) : 유니코드 문자열. Indexer 구현 제공</li><li>리터럴</li><ul><li>@"" : \ 이스케이프를 하지 않는다. 여러 줄 작성 가능. "를 표현하고 싶으면 ""</li><li>$"" Since 6 : 간편한 포맷 문자열을 제공한다. {<i>표현식</i>[,<i>alignment</i>][:<i>formatString</i>]}</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">// 정렬
Console.WriteLine($"|{"LEFT",-20}|");               // |LEFT                |
Console.WriteLine($"|{"RIGHT",20}|");               // |               RIGHT|

// 숫자 https://docs.microsoft.com/ko-kr/dotnet/standard/base-types/composite-formatting#format-string-component
Console.WriteLine($"{Math.PI}");                    // 3.14159265358979
Console.WriteLine($"{Math.PI:E}");                  // 3.141593E+000
Console.WriteLine($"0x{12345:x}");                  // 0x3039
Console.WriteLine($"{Math.PI * 1000:F3}");          // 3141.593
Console.WriteLine($"{Math.PI * 1000:N3}");          // 3,141.593
Console.WriteLine($"{Math.PI:0000.00%}");           // 0314.16%
Console.WriteLine($"{Math.PI:#0000.000‰}");         // 3141.593‰

// 시각 https://docs.microsoft.com/ko-kr/dotnet/standard/base-types/custom-date-and-time-format-strings
var now = DateTime.Now;
Console.WriteLine($"{now:yyyy-MM-dd HH:mm:ss}");    // 2019-12-16 06:15:56
Console.WriteLine($"{now:yyyy-M-d H:m:s}");         // 2019-12-16 6:15:56
Console.WriteLine($"{now:yy-MMM-ddd}");             // 19-Dec-Mon
Console.WriteLine($"{now:g yy-MMMM-dddd}");         // A.D. 19-December-Monday
Console.WriteLine($"{now:t hh:mm:ss.ffffff zzz}");  // A 06:15:56.627000 +00:00

// enum
var day = DAY.WED;
Console.WriteLine($"'{day}', 'D : {day:D}', 'X : {day:X}'");
// 'WED', 'D : 3', 'X : 00000003'

var mode = MODE.M2 | MODE.M4;
Console.WriteLine($"'{mode}', 'D : {mode:D}', 'X : {mode:X}'");
// 'M2, M4', 'D : 10', 'X : 0000000A'

enum DAY { SUN, MON, THE, WED, THU, FRI, SAT }
[Flags]
enum MODE { M1 = 0b0001, M2 = 0b0010, M3 = 0b0100, M4 = 0b1000 }</div><li>Since 8 : @$"", $@"" 모두 유효. 이전에는 $@""만 가능</li></ul></ul><h3>배열</h3><ul><li>배열 초기화시 기본값으로 채워진다</li><li>다차원 배열 [,] : 배열 차원 고정. 메모리 상에서는 일차원 배열처럼 존재</li><li>Jagged Array [][] : 배열의 차원이 가변적</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">int[] arr1 = new int[3];
int[] arr2 = new int[] { 1, 2, 3 };
int[] arr3 = { 1, 2, 3 };
int[,] arr4 = new int[2, 2];
int[,] arr5 = new int[,] { { 1, 2 }, { 3, 4 } };
</div></ul></div><h2>기능</h2><div><h3>패턴 매칭</h3><ul><li>null 검사</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">int? n = 123;
if (n is int number)
    Console.WriteLine(number);
if (n is not null)
    Console.WriteLine(n);
</div><li>타입 호환 검사</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">public static T Mean&lt;T&gt;(IEnumerable&lt;T&gt; items)
{
    if (items is IList&lt;T&gt; list)
        // List 전용 로직
    // 그 외 로직
}

public static decimal CalculateToll(this Vehicle vehicle) =&gt; vehicle switch
{
    Car =&gt; 2.00m,
    Truck =&gt; 7.50m,
    null =&gt; throw new ArgumentNullException(nameof(vehicle)),
    _ =&gt; throw new ArgumentException("Unknown type of a vehicle", nameof(vehicle)),
};
</div><li>불연속 값 비교</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">public static bool IsComplete(int n) =&gt; n switch
{
    6 or 28 or 496 or 8128 or 33550336 =&gt; true,
    _ =&gt; false
};
</div><li>상수 관계 비교</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">public static bool IsWarm(float celsius) =&gt; celsius switch
{
    &gt; 17 and &lt; 25 =&gt; true,
    _ =&gt; false
};
</div><li>위치 비교</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">static decimal GetGroupTicketPriceDiscount(int groupSize, DateTime visitDate)
    =&gt; (groupSize, visitDate.DayOfWeek) switch
    {
        (&lt;= 0, _) =&gt; throw new ArgumentException("Group size must be positive."),
        (_, DayOfWeek.Saturday or DayOfWeek.Sunday) =&gt; 0.0m,
        (&gt;= 5 and &lt; 10, _) =&gt; 12.0m,
        (&gt;= 10, _) =&gt; 15.0m,
        _ =&gt; 0.0m,
    };

static string PrintIfAllCoordinatesArePositive(object point) =&gt; point switch
{
    Point2D (&gt; 0, &gt; 0) p =&gt; p.ToString(),
    Point3D (&gt; 0, &gt; 0, &gt; 0) p =&gt; p.ToString(),
    _ =&gt; string.Empty,
};
</div><li>프로퍼티 비교</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">var msg = "Hello";
if (msg is string { Length: 5 } five)</div><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">public record Point(int X, int Y);
public record Segment(Point Start, Point End);

static bool IsAnyEndOnXAxis(Segment segment) =&gt;
    segment is { Start: { Y: 0 } } or { End: { Y: 0 } };

// Since 10
static bool IsAnyEndOnXAxis(Segment segment) =&gt;
    segment is { Start.Y: 0 } or { End.Y: 0 };
</div><li>var 키워드로 중간 계산 결과 저장 가능</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">static Point Transform(Point point) =&gt; point switch
{
    var (x, y) when x &lt; y =&gt; new Point(-x, y),
    var (x, y) when x &gt; y =&gt; new Point(x, -y),
    var (x, y) =&gt; new Point(x, y),
};
</div></ul><h3>무시</h3><ul><li>_ 키워드로 변수 무시</li><li>(_, a, _) = Something() : 반환 무시</li><li>Something(a, out _) : 출력 무시</li></ul><h3>분해</h3><ul><li>메서드로 튜플을 반환하고, 이를 분해하여 변수에 할당 가능</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">var (name, address, city, zip) = QueryCityData(...);

static (string, string, string, string) QueryCityData(...) { }</div><li>사용자 정의 타입에 분해자를 정의하면 해당 인스턴스 분해 가능</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">// 순서대로 out 매개 변수에 정의
public void Deconstruct(out string fname, out string mname, out string lname) { }</div><li>확장 메서드를 작성하여 분해 기능 추가 가능</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">public static void Deconstruct(this Rectangle rect, out int x, out int y, out int width, out int height)
    =&gt; (x, y, width, height) = (rect.X, rect.Y, rect.Width, rect.Height);
</div></ul></div><h2>연산자 및 식</h2><div><h3>^ 연산자</h3><p>Since 8.0 : 끝부터 시작하는 인덱스</p><h3>..</h3><ul><li>Since 8.0 : 범위 연산자. start..end는 구간 [start, end)을 의미</li><li>a.. == a..^0</li><li>..b == 0..b</li><li>.. == 0..^0</li></ul><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">var words = new string[] { "The", "quick", "brown", "fox", "jumped", "over", "the", "lazy", "dog" };
Console.WriteLine($"The last word is {words[^1]}");
var lazyDog = words[^2..^0];
var allWords = words[..];
var phrase = 1..4;
var text = words[phrase];
</div><h3>[] (인덱서 연산자)</h3><p>하나 이상의 인수로 참조되는 프로퍼티. string, List&lt;T&gt; 등은 인덱서를 구현함</p><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">public int this[int idx]
{
    get =&gt; idx;
    set =&gt; Console.WriteLine($"{idx} : 0x{value:X}");
}
</div><h3>?. 및 ?[]</h3><ul><li>피연산자가 null이 아니면 액세스 연산 적용</li><li>피연산자가 null이면 null 반환</li><p>null 조건부 연산자를 연쇄적으로 이용할 때, 중간에서 null이 반환된 경우, 나머지는 처리되지 않는다</p></ul><h3>?? 및 ??=</h3><ul><li>?? : 왼쪽 피연산자가 null이면 우측 피연산자 반환</li><li>??= Since 8.0 : 왼쪽 피연산자가 null이면, 오른쪽 피연산자의 값을 대입</li></ul><h3>await 연산자</h3><p>피연산자가 나타내는 비동기 작업이 완료될 때까지 바깥쪽 비동기 메서드의 평가를 일시 중단</p><h3>default 식</h3><ul><li>default(Type) : 타입에 대한 기본값/인스턴스 반환</li><li>Since 7.1 : default 리터럴로 기본값을 표현 가능</li></ul><h3>nameof 식</h3><p>nameof(Identifier) : 식별자 문자열 반환</p><h3>stackalloc 식</h3><p>배열을 스택에 할당한다. fixed 문으로 고정하지 않아도 된다. 메서드 반환 시 자동 삭제된다 -- 임의 해제 불가</p><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">int* numbers = stackalloc int[100]; // 포인터는 unsafe 컨텍스트를 사용해야 한다
Span&lt;int&gt; numbers = stackalloc int[100]; // Since 7.2 : Span, ReadOnlySpan에 할당 가능
var idx = numbers.IndexOfAny(stackalloc[] { 1, 2, 3, 4 }); // Since 8.0 : 다른 식 내부에서 stackalloc 사용 가능
</div></div><h2>키워드</h2><div><h3>async</h3><ul><li>메서드, 람다식, 익명 메서드(delegate 연산자)를 비동기로 지정</li><li>void 리턴 : await할 수 없으며, 따라서 예외를 catch할 수 없다</li><li>Task, Task&lt;TResult&gt; : await 가능</li><li>Since 7.0 : 액세스 가능한 GetAwaiter() 메서드가 있는 모든 타입 리턴 가능</li><p>System.Threading.Tasks.ValueTask&lt;TResult&gt;은 패키지 System.Threading.Tasks.Extensions가 제공하는 구현</p></ul><h3>fixed</h3><p>unsafe 컨텍스트에서, GC가 변수를 재배치하지 않도록 하여 포인터가 유효함을 보장한다</p><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">fixed (int* p = &amp;pt.x) { ... }
</div><h3>in, out</h3><ul><li>in 매개변수 : 참조 전달. 메서드에서 수정 불가</li><li>out 매개변수 : 참조 전달. 호출 전에 초기화되지 않아도 되지만, 반환 전에 할당돼야 한다</li><p>선언과 동시에 out 매개변수로 사용 가능</p><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">int.TryParse("12", out var result);</div></ul><h3>private protected</h3><p>동일 어셈블리 내의 클래스 및 파생 클래스에서 엑세스 가능</p><h3>readonly</h3><ul><li>readonly 필드 : 생성자에서 초기화한 후에는 쓰기 불가</li><li>ref readonly 반환 : 반환된 참조에 대한 쓰기는 비허용</li><li>readonly struct : 모든 필드가 readonly인 struct</li></ul><h3>ref</h3><ul><li>ref 매개변수 : 참조 전달. 호출자 스코프의 변수를 그대로 사용하는 효과. 참조가 존재하기 위해 호출 전에 초기화 필요</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">void Method(ref int refArgument)</div><li>ref 반환 : 참조 반환</li><li>ref 지역 변수 : ref 반환값으로 초기화되는 지역 변수</li><p>Since 7.3 : foreach 반복 변수도 ref 또는 ref readonly 지역 변수일 수 있다</p><li>ref readonly 반환 : 반환된 참조에 대한 쓰기는 비허용</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">public ref decimal GetCurrentPrice() { }
ref decimal estValue = ref GetCurrentPrice();
ref decimal copyValue = ref estValue;</div><li>ref struct : 스택에 할당되는 struct. 클래스의 멤버가 될 수 없다. 인터페이스를 구현할 수 없다</li></ul><h3>unsafe</h3><ul><li>unsafe로 한정한 타입, 메서드, 블록에서는 포인터를 사용할 수 있다</li><li>컴파일 시 -unsafe 옵션을 지정해야 한다</li><p>비주얼 스튜디오에서는 "프로젝트 속성 - 빌드 - 안전하지 않은 코드 허용"</p></ul><h3>var, dynamic</h3><ul><li>var : 암시적 변수 타입. 컴파일러가 타입을 결정한다</li><li>dynamic : 파이썬처럼 타입 검사를 런타임에 하여 Duck-typing을 가능하게 한다</li></ul><h3>yield</h3><p>메서드, 연산자, get 접근자가 반복자임을 선언</p><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">foreach (var n in Series(100))
    Console.WriteLine(n);

IEnumerable&lt;int&gt; Series(int limit)
{
    var num = 0;
    while (num &gt; limit)
        yield return ++num;
    yield break;
}
</div></div><h2>메서드</h2><ul><li>호출 시 매개변수 명시</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">Divide(a: 10, b: 3, q: out q, r: out r);</div><li>선택적 매개변수 선언</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">Method(int a = 0, int b = 0) {}</div><li>가변 길이 매개변수 params</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">public static int Sum(params int[] args) =&gt; args.Sum();</div><li>확장 메서드 : 기존 클래스에 static method 추가</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">public static class ExtensionExample
{
    public static int Double(this int i) =&gt; i * 2;
}</div><li>메서드 안에 지역 함수 정의 가능</li><p>static 지역 함수로 선언하면 외부 변수 참조 불가</p><li>extern 메서드 : 메서드의 body가 없어도 컴파일</li><p>호출할 메서드가 있는 dll을 [DllImport] Attribute로 지정해주면 해당 메서드를 호출한다. http://www.pinvoke.net/</p><li>Caller information</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">using System.Runtime.CompilerServices;

Log("Hello");

static void Log(
    string text,
    [CallerMemberName] string memberName = "",
    [CallerFilePath] string filePath = "",
    [CallerLineNumber] int lineNumber = 0)
{
    Console.WriteLine($"{filePath}@{lineNumber}[{memberName}]: {text}");
}
</div></ul><h2>코딩 스타일</h2><ul><li>인터페이스는 I로 시작</li><li>밑줄 문자를 연속으로 사용하지 않아야 함</li><li>식별자는 기본적으로 PascalCasing</li><li>private 또는 internal 필드는 _camelCasing</li><li>private static 또는 internal static 필드는 s_camelCasing</li><li>ThreadStatic 필드는 t_camelCasing</li><li>메서드 매개 변수는 camelCasing</li></ul><h2>App.config</h2><ol><li>appSettings</li><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/VisualStudio/ConsoleApp9/App.config" lan="xml">App.config »</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/VisualStudio/ConsoleApp9/Program.cs" lan="cs">Program.cs »</button></ol><h2>디버그 모드</h2><ol><li>전처리 상수 #if DEBUG ... #endif</li><li>[Conditional("DEBUG")] 적용된 클래스, 메서드는 릴리스 빌드 시 포함되지 않는다</li><li>System.Diagnostics.Debug.WriteLine() : 디버그 출력</li></ol><h2>Reflection 리플렉션</h2><ul><li>AppDomain → Assembly ← Module ← Type</li><p>AppDomain : EXE 프로세스 내에서 CLR에 의해 구현된 격리 공간. 최초 실행 시 기본적으로 1개 생성(AppDomain.CurrentDomain).</p><li>static 멤버들은 AppDomain 안에서 유일하다. 프로세스의 여러 AppDomain에서 동일한 클래스를 로드했다면 static 멤버들은 각 도메인마다 하나씩 존재</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">var appDomain = AppDomain.CreateDomain("MyDomain");
ObjectHandle handle = appDomain.CreateInstanceFrom(dllPath, "Namespace.ClassName");
...
AppDomain.Unload(appDomain);</div><li>Object.getType() or typeof 연산자</li><li>Type :: GetConstructors(), GetEvents(), GetFields(), GetMethods(), ...</li><li>동적 생성 : System.Activator.CreateInstance(Type);</li><li>동적 타입 정의 : System.Reflection.Emit</li><ol><li>System.AppDomain.DefineDynamicAssembly()로 AssemblyBuilder 객체 획득</li><li>AssemblyBuilder.DefineDynamicModule()로 ModuleBuilder 획득</li><li>ModuleBuilder.DefineType()으로 클래스 생성(TypeBuilder)</li><li>TypeBuilder.DefineMethod()로 MethodBuilder 획득</li><li>MethodBuilder.GetILGenerator()로 ILGenerator 객체 획득</li><li>ILGenerator.Emit()으로 메서드 내용 추가</li><li>TypeBuilder.CrateType()으로 인스턴스 생성 가능</li></ol></ul><h2>C#의 새로운 기능</h2><div><h3>C# 8.0</h3><ul><li>구조체 멤버에 readonly 가능</li><li>인터페이스 멤버의 기본 구현 제공 가능</li><li>패턴 매칭 강화</li><p>switch 식, 속성 패턴, 튜플 패턴, 위치 패턴 등</p><li>using 선언</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">using var file = new System.IO.StreamWriter("WriteLines2.txt");</div><li>정적 로컬 함수 선언 가능</li><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">void Something()
{
    static int LocalSomething() { }
}</div><li>nullable 참조 타입 추가</li><p>Nullable&lt;T&gt;는 null을 허용하는 래퍼 클래스. int?는 Nullable&lt;int&gt;와 동일하다</p><li>비동기 삭제</li><p>System.IAsyncDisposable 인터페이스를 구현하는 인스턴스를 await using으로 사용</p></ul><h3>C# 9.0</h3><ul><li>record 타입 추가</li><li>초기화 전용 set 접근자</li><p><strong>↓C#</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="C#">public class Person
{
    public string? FirstName { get; init; }
    public string? LastName { get; init; }
}</div><li>최상위 문 사용 가능</li><li>공변 반환 : 메서드 상속 시 반환 타입을 더욱 좁히는 것이 허용된다</li></ul><h3>C# 10</h3><ul><li>record class 추가</li><li>임의 using 선언에 global 한정자를 추가하여 모든 소스 파일에 적용 가능</li><li>namespace XXX { } 대신 namespace XXX; 사용 가능</li></ul></div></div><h1>.NET 정규표현식</h1><ul><p>Java와 동일한 부분은 생략</p><li>\nn 또는 \nnn : 8진수 ASCII</li><li>\w : \p{L} | \p{Mn} | \p{Nd} | \p{Pc}</li><li>\Z : \z | (?=\n)</li><li>(?&lt;name&gt;X) == (?'name'X)</li><ul><li>Named group</li><li>\k'name'역참조 가능. replace에서 ${name}참조 가능, GroupCollection의 인덱서로 참조 가능</li><li>그룹 오버로딩 가능 : (?&lt;1&gt;a)(?&lt;1&gt;\1b) // 스택처럼 정의가 쌓이며 '-name'으로 가장 최근 정의 삭제 가능</li></ul><li class="marker">균형 조정 그룹; Balancing group</li><ul><li>(?&lt;name1-name2&gt;X) == (?'name1-name2'X)</li><p>name1은 현재 그룹(Optional)이고, name2는 이전에 정의된 그룹. 균형 조정 그룹은 마지막(백트래킹) name2 정의를 삭제하고, name1에 name2와 name1 사이 간격을 저장한다</p><p><strong>↓cs</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="cs">var html = "&lt;html&gt;&lt;body&gt;Hello&lt;p&gt;World&lt;/p&gt;olleH&lt;/body&gt;&lt;/html&gt;Plain Text&lt;script&gt;console.log('hello world');&lt;/script&gt;Plain Text&lt;yes&gt;Text&lt;/no&gt;";
foreach (Match match in Regex.Matches(html, @"&lt;(?'tag'\w+)&gt;(.(?&lt;!&lt;/\k&lt;tag&gt;&gt;))*(?'-tag'&lt;/\k&lt;tag&gt;&gt;)"))
    Console.WriteLine($"HTML part : {match.Groups[0]}");
// HTML part : &lt;html&gt;&lt;body&gt;Hello&lt;p&gt;World&lt;/p&gt;olleH&lt;/body&gt;&lt;/html&gt;
// HTML part : &lt;script&gt;console.log('hello world');&lt;/script&gt;</div></ul><li>옵션</li><ul><li>(?imnsx-imnsx:X) // X 내에 옵션 적용/비적용. 이 자체는 캡처링 그룹이 아님</li><li>(?imnsx-imnsx) // 이후 식에 옵션 적용/비적용</li><li>System.Text.RegularExpressions.RegexOptions // Regex 생성자 또는 정적 메서드에 전체 옵션 지정</li><table class="no-sort"><tr><td>IgnoreCase</td><td>i</td><td>대소문자 구별X</td></tr><tr><td>Multiline</td><td>m</td><td>^, $이 \n에서도 동작</td></tr><tr><td>ExplicitCapture</td><td>n</td><td>명명된 캡처링 그룹만 유효</td></tr><tr><td>Singleline</td><td>s</td><td>.이 \n포함</td></tr><tr><td>IgnorePatternWhitespace</td><td>x</td><td>이스케이프되지 않은 공백을 패턴에서 제거하고 주석을 #으로 표시 가능</td></tr><tr><td>Compiled</td><td></td><td>어셈블리로 컴파일</td></tr><tr><td>RightToLeft</td><td></td><td>우→좌 검색</td></tr><tr><td>ECMAScript</td><td></td><td></td></tr><tr><td>CultureInvariant</td><td></td><td></td></tr><tr><td>None</td><td></td><td>옵션 없음 명시</td></tr></table></ul><li>(?&gt;X) : Non-backtracking</li><li class="marker">Replace 구문</li><ul><li>$n, ${name} : 캡처링 그룹</li><li>$& : 전체 매칭 문자열</li><li>$` : 매칭 문자열 앞부분</li><li>$' : 매칭 문자열 뒷부분</li><li>$+ : 마지막 캡처링 그룹</li><li>$_ : 전체 입력 문자열</li></ul><li>인라인 주석 : (?#comment)</li></ul><details><summary class="marker">지원 Unicode class : \p{name} ↔ \P{name}</summary><table class="no-sort"><tr><th>Category</th><th>Description</th></tr><tr><td>Lu</td><td>Letter, Uppercase</td></tr><tr><td>Ll</td><td>Letter, Lowercase</td></tr><tr><td>Lt</td><td>Letter, Titlecase</td></tr><tr><td>Lm</td><td>Letter, Modifier</td></tr><tr><td>Lo</td><td>Letter, Other</td></tr><tr><td>L</td><td>Lu + Ll + Lt + Lm + Lo</td></tr><tr><td>Mn</td><td>Mark, Nonspacing</td></tr><tr><td>Mc</td><td>Mark, Spacing Combining</td></tr><tr><td>Me</td><td>Mark, Enclosing</td></tr><tr><td>M</td><td>Mn + Mc + Me</td></tr><tr><td>Nd</td><td>Number, Decimal Digit</td></tr><tr><td>Nl</td><td>Number, Letter</td></tr><tr><td>No</td><td>Number, Other</td></tr><tr><td>N</td><td>Nd + Nl + No</td></tr><tr><td>Pc</td><td>Punctuation, Connector</td></tr><tr><td>Pd</td><td>Punctuation, Dash</td></tr><tr><td>Ps</td><td>Punctuation, Start[Open]</td></tr><tr><td>Pe</td><td>Punctuation, End[Close]</td></tr><tr><td>Pi</td><td>Punctuation, Initial quote</td></tr><tr><td>Pf</td><td>Punctuation, Final quote</td></tr><tr><td>Po</td><td>Punctuation, Other</td></tr><tr><td>P</td><td>Pc + Pd + Ps + Pe + Pi + Pf + Po</td></tr><tr><td>Sm</td><td>Symbol, Math</td></tr><tr><td>Sc</td><td>Symbol, Currency</td></tr><tr><td>Sk</td><td>Symbol, Modifier</td></tr><tr><td>So</td><td>Symbol, Other</td></tr><tr><td>S</td><td>Sm + Sc + Sk + So</td></tr><tr><td>Zs</td><td>Separator, Space</td></tr><tr><td>Zl</td><td>Separator, Line</td></tr><tr><td>Zp</td><td>Separator, Paragraph</td></tr><tr><td>Z</td><td>Zs + Zl + Zp</td></tr><tr><td>Cc</td><td>Other, Control</td></tr><tr><td>Cf</td><td>Other, Format</td></tr><tr><td>Cs</td><td>Other, Surrogate</td></tr><tr><td>Co</td><td>Other, Private Use</td></tr><tr><td>Cn</td><td>Other, Not Assigned</td></tr><tr><td>C</td><td>Cc + Cf + Cs + Co + Cn</td></tr></table><table class="no-sort"><tr><th>Code point range</th><th>Block name</th></tr><tr><td>0000 - 007F</td><td>IsBasicLatin</td></tr><tr><td>0080 - 00FF</td><td>IsLatin-1Supplement</td></tr><tr><td>0100 - 017F</td><td>IsLatinExtended-A</td></tr><tr><td>0180 - 024F</td><td>IsLatinExtended-B</td></tr><tr><td>0250 - 02AF</td><td>IsIPAExtensions</td></tr><tr><td>02B0 - 02FF</td><td>IsSpacingModifierLetters</td></tr><tr><td>0300 - 036F</td><td>IsCombiningDiacriticalMarks</td></tr><tr><td>0370 - 03FF</td><td>IsGreek or IsGreekandCoptic</td></tr><tr><td>0400 - 04FF</td><td>IsCyrillic</td></tr><tr><td>0500 - 052F</td><td>IsCyrillicSupplement</td></tr><tr><td>0530 - 058F</td><td>IsArmenian</td></tr><tr><td>0590 - 05FF</td><td>IsHebrew</td></tr><tr><td>0600 - 06FF</td><td>IsArabic</td></tr><tr><td>0700 - 074F</td><td>IsSyriac</td></tr><tr><td>0780 - 07BF</td><td>IsThaana</td></tr><tr><td>0900 - 097F</td><td>IsDevanagari</td></tr><tr><td>0980 - 09FF</td><td>IsBengali</td></tr><tr><td>0A00 - 0A7F</td><td>IsGurmukhi</td></tr><tr><td>0A80 - 0AFF</td><td>IsGujarati</td></tr><tr><td>0B00 - 0B7F</td><td>IsOriya</td></tr><tr><td>0B80 - 0BFF</td><td>IsTamil</td></tr><tr><td>0C00 - 0C7F</td><td>IsTelugu</td></tr><tr><td>0C80 - 0CFF</td><td>IsKannada</td></tr><tr><td>0D00 - 0D7F</td><td>IsMalayalam</td></tr><tr><td>0D80 - 0DFF</td><td>IsSinhala</td></tr><tr><td>0E00 - 0E7F</td><td>IsThai</td></tr><tr><td>0E80 - 0EFF</td><td>IsLao</td></tr><tr><td>0F00 - 0FFF</td><td>IsTibetan</td></tr><tr><td>1000 - 109F</td><td>IsMyanmar</td></tr><tr><td>10A0 - 10FF</td><td>IsGeorgian</td></tr><tr><td>1100 - 11FF</td><td>IsHangulJamo</td></tr><tr><td>1200 - 137F</td><td>IsEthiopic</td></tr><tr><td>13A0 - 13FF</td><td>IsCherokee</td></tr><tr><td>1400 - 167F</td><td>IsUnifiedCanadianAboriginalSyllabics</td></tr><tr><td>1680 - 169F</td><td>IsOgham</td></tr><tr><td>16A0 - 16FF</td><td>IsRunic</td></tr><tr><td>1700 - 171F</td><td>IsTagalog</td></tr><tr><td>1720 - 173F</td><td>IsHanunoo</td></tr><tr><td>1740 - 175F</td><td>IsBuhid</td></tr><tr><td>1760 - 177F</td><td>IsTagbanwa</td></tr><tr><td>1780 - 17FF</td><td>IsKhmer</td></tr><tr><td>1800 - 18AF</td><td>IsMongolian</td></tr><tr><td>1900 - 194F</td><td>IsLimbu</td></tr><tr><td>1950 - 197F</td><td>IsTaiLe</td></tr><tr><td>19E0 - 19FF</td><td>IsKhmerSymbols</td></tr><tr><td>1D00 - 1D7F</td><td>IsPhoneticExtensions</td></tr><tr><td>1E00 - 1EFF</td><td>IsLatinExtendedAdditional</td></tr><tr><td>1F00 - 1FFF</td><td>IsGreekExtended</td></tr><tr><td>2000 - 206F</td><td>IsGeneralPunctuation</td></tr><tr><td>2070 - 209F</td><td>IsSuperscriptsandSubscripts</td></tr><tr><td>20A0 - 20CF</td><td>IsCurrencySymbols</td></tr><tr><td>20D0 - 20FF</td><td>IsCombiningDiacriticalMarksforSymbols or IsCombiningMarksforSymbols</td></tr><tr><td>2100 - 214F</td><td>IsLetterlikeSymbols</td></tr><tr><td>2150 - 218F</td><td>IsNumberForms</td></tr><tr><td>2190 - 21FF</td><td>IsArrows</td></tr><tr><td>2200 - 22FF</td><td>IsMathematicalOperators</td></tr><tr><td>2300 - 23FF</td><td>IsMiscellaneousTechnical</td></tr><tr><td>2400 - 243F</td><td>IsControlPictures</td></tr><tr><td>2440 - 245F</td><td>IsOpticalCharacterRecognition</td></tr><tr><td>2460 - 24FF</td><td>IsEnclosedAlphanumerics</td></tr><tr><td>2500 - 257F</td><td>IsBoxDrawing</td></tr><tr><td>2580 - 259F</td><td>IsBlockElements</td></tr><tr><td>25A0 - 25FF</td><td>IsGeometricShapes</td></tr><tr><td>2600 - 26FF</td><td>IsMiscellaneousSymbols</td></tr><tr><td>2700 - 27BF</td><td>IsDingbats</td></tr><tr><td>27C0 - 27EF</td><td>IsMiscellaneousMathematicalSymbols-A</td></tr><tr><td>27F0 - 27FF</td><td>IsSupplementalArrows-A</td></tr><tr><td>2800 - 28FF</td><td>IsBraillePatterns</td></tr><tr><td>2900 - 297F</td><td>IsSupplementalArrows-B</td></tr><tr><td>2980 - 29FF</td><td>IsMiscellaneousMathematicalSymbols-B</td></tr><tr><td>2A00 - 2AFF</td><td>IsSupplementalMathematicalOperators</td></tr><tr><td>2B00 - 2BFF</td><td>IsMiscellaneousSymbolsandArrows</td></tr><tr><td>2E80 - 2EFF</td><td>IsCJKRadicalsSupplement</td></tr><tr><td>2F00 - 2FDF</td><td>IsKangxiRadicals</td></tr><tr><td>2FF0 - 2FFF</td><td>IsIdeographicDescriptionCharacters</td></tr><tr><td>3000 - 303F</td><td>IsCJKSymbolsandPunctuation</td></tr><tr><td>3040 - 309F</td><td>IsHiragana</td></tr><tr><td>30A0 - 30FF</td><td>IsKatakana</td></tr><tr><td>3100 - 312F</td><td>IsBopomofo</td></tr><tr><td>3130 - 318F</td><td>IsHangulCompatibilityJamo</td></tr><tr><td>3190 - 319F</td><td>IsKanbun</td></tr><tr><td>31A0 - 31BF</td><td>IsBopomofoExtended</td></tr><tr><td>31F0 - 31FF</td><td>IsKatakanaPhoneticExtensions</td></tr><tr><td>3200 - 32FF</td><td>IsEnclosedCJKLettersandMonths</td></tr><tr><td>3300 - 33FF</td><td>IsCJKCompatibility</td></tr><tr><td>3400 - 4DBF</td><td>IsCJKUnifiedIdeographsExtensionA</td></tr><tr><td>4DC0 - 4DFF</td><td>IsYijingHexagramSymbols</td></tr><tr><td>4E00 - 9FFF</td><td>IsCJKUnifiedIdeographs</td></tr><tr><td>A000 - A48F</td><td>IsYiSyllables</td></tr><tr><td>A490 - A4CF</td><td>IsYiRadicals</td></tr><tr><td>AC00 - D7AF</td><td>IsHangulSyllables</td></tr><tr><td>D800 - DB7F</td><td>IsHighSurrogates</td></tr><tr><td>DB80 - DBFF</td><td>IsHighPrivateUseSurrogates</td></tr><tr><td>DC00 - DFFF</td><td>IsLowSurrogates</td></tr><tr><td>E000 - F8FF</td><td>IsPrivateUse or IsPrivateUseAreaIsPrivateUse or IsPrivateUseArea</td></tr><tr><td>F900 - FAFF</td><td>IsCJKCompatibilityIdeographs</td></tr><tr><td>FB00 - FB4F</td><td>IsAlphabeticPresentationForms</td></tr><tr><td>FB50 - FDFF</td><td>IsArabicPresentationForms-A</td></tr><tr><td>FE00 - FE0F</td><td>IsVariationSelectors</td></tr><tr><td>FE20 - FE2F</td><td>IsCombiningHalfMarks</td></tr><tr><td>FE30 - FE4F</td><td>IsCJKCompatibilityForms</td></tr><tr><td>FE50 - FE6F</td><td>IsSmallFormVariants</td></tr><tr><td>FE70 - FEFF</td><td>IsArabicPresentationForms-B</td></tr><tr><td>FF00 - FFEF</td><td>IsHalfwidthandFullwidthForms</td></tr><tr><td>FFF0 - FFFF</td><td>IsSpecials</td></tr></table></details></div></article><hr><script id="google-analytics" src="https://www.googletagmanager.com/gtag/js?id=UA-143098403-1" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-143098403-1');</script><script id="highlight-js" src="/source/highlight.pack.js" defer></script><script id="default-js" src="/source/default.min.js" defer></script></body></html>