<html lang="ko"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="google-site-verification" content="aH-DyzdytYQ0NPHNQFcs5dVoiu5YNs6CEEHYgqDmAFM"><meta name="author" content="Donggi Kim &lt;hi.donggi@gmail.com&gt;"><meta name="keywords" content="MCS, Mathematics"><meta name="description" content="Mathematics for Computer Science 정리"><title>Mathematics for Computer Science</title><link id="w3css" rel="stylesheet" href="/source/w3.css"><link id="highlight-style" rel="stylesheet" href="/source/xcode.css"><link id="default-style" rel="stylesheet" href="/source/default.css"><script id="highlight-js" src="/source/highlight.pack.js"></script><script id="default-js" src="/source/default.min.js"></script><script id="dsq-count-scr" src="//donggi.disqus.com/count.js" async></script><link id="mjx-style" rel="stylesheet" href="/source/mjx-chtml.css"><script id="MathJax-script" src="/source/tex-chtml.js" async></script><script>MathJax = {
    tex: {
        tags: 'ams',
        inlineMath: [['식[', ']식']]
    }
};</script><script id="kakao-ads" src="//t1.daumcdn.net/kas/static/ba.min.js" async></script><script id="google-ads" data-ad-client="ca-pub-7897366614471210" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><script id="google-analytics" src="https://www.googletagmanager.com/gtag/js?id=UA-143098403-1" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-143098403-1');</script></head><body><div class="w3-bar-block w3-sidebar w3-animate-left" id="sidebar"><hr><a class="w3-bar-item w3-button" href="javascript:closeSidebar();">Close &times;</a><hr><div id="marker-list"></div><hr><div id="post-list"></div><hr><div class="w3-center"><ins class="kakao_ad_area" style="display:none;" data-ad-unit="DAN-1k1r635zxb6g3" data-ad-width="300" data-ad-height="250"></ins></div><hr><div id="file-list"></div><hr></div><div id="main"><div class="w3-bar w3-blue w3-large" id="nav" style="position:-webkit-sticky;position:sticky;top:0px;vertical-align:middle"><button class="w3-bar-item w3-button w3-hover-theme" onclick="toggleSidebar()">&#9776;</button><input class="w3-bar-item" id="query" type="text" placeholder="search" style="max-width:35%"><a class="w3-bar-item w3-button w3-hover-theme" href="/">Home</a></div><div class="w3-padding" id="contents"><h1>도서 정보</h1><div class="w3-row"><div class="w3-col s2 w3-center"><div class="w3-center w3-margin-bottom"><img class="w3-round" src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQew5ZrEOtvLqafGH3aEaTctFKCSV4qjsRoZS4tT7Ci_lJXjSIV" alt="도서 이미지" style="max-height:210px;"><br><strong>&lt;이미지 - 도서 이미지></strong></div></div><div class="w3-col s10"><table class="no-sort"><tr><td>표제/저자사항</td><td>Mathematics for Computer Science / Eric Lehman, F Thomson Leighton, Albert R Meyer</td></tr><tr><td>ISBN 정보</td><td>979-11-88621-12-5 [93000]</td></tr><tr><td>Copyright</td><td>2017, Eric Lehman, F Tom Leighton, <a class="w3-btn w3-round-xxlarge w3-small w3-green" href="http://people.csail.mit.edu/meyer">Albert R Meyer</a>. This work is available under the terms of the <a class="w3-btn w3-round-xxlarge w3-small w3-green" href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-ShareAlike 3.0 license.</a></td></tr></table></div></div><h1>Proofs</h1><div><h2>Introduction</h2><p><strong>정의</strong> 명제(proposition)에 대한 수학적 증명이란, 기본 공리(axiom)들로부터 명제에 도달하는 일련의 논리적 연역(deduction)이다</p><h2>What is a Proof?</h2><div><h3>Propositions</h3><p><strong>정의</strong> 명제(proposition)란 참 또는 거짓인 문장이다</p><p><strong>Conjecture.</strong> [오일러 추측] 방정식 식[a^4+b^4+c^4=d^4]식을 만족하는 양의 정수 식[a, b, c, d]식는 존재하지 않는다<br>이를 아래와 같이 표현할 수 있다
\[\forall a, b, c, d \in \mathbb{Z}^+. a^4+b^4+c^4 \ne d^4.\]</p><h3>Predicates</h3><p><strong>정의</strong> Predicate ::= 변수에 의해 진리값이 결정되는 문제</p><p>예. 식[P(n) ::= \text{"n은 완전제곱수다"}]식</p><h3>The Axiomatic Method</h3><p><strong>정의</strong><ul><li>정리(Theorem) ::= 중요한 참 명제</li><li>보조정리(Lemma) ::= 이후 명제를 증명하는 데 필요한 예비 명제</li><li>따름정리(Corollary) ::= 정리로부터 쉽게 도출되는 명제</li></ul></p><h3>Our Axioms</h3><div><p><strong>정의</strong> Implication ::= 식[\text{"If }P\text{, then }Q\text{"}]식처럼 조건을 갖는 명제
 종종 식[P\text{ IMPLIES }Q]식, 식[P \longrightarrow Q]식로 표현한다</p><p>증명을 간결하게 하기 위해 아래의 공리(Axiom)들을 증명없이 이용한다</p><h4>Logical Deductions</h4><p><strong>Rule.</strong> 식[{P, P \implies Q \over Q}]식<p>↑ 식[{P, P \implies Q}]식 모두 참이면 식[Q]식도 참이라는 의미</p></p><p><strong>Rule.</strong> 식[{P \implies Q, Q \implies R \over P \implies R}]식</p><p><strong>Rule.</strong> 식[{\operatorname{NOT}(Q) \implies \operatorname{NOT}(P) \over P \implies Q}]식</p></div><h3>Proving an Implication</h3><div><h4>Method #1</h4><ol><li>다음과 같이 쓴다. "P가 참이라고 가정한다"</li><li>Q가 논리적으로 도출됨을 보인다</li></ol><h4>Method #2</h4><ol><li>다음과 같이 쓴다. "대우명제를 통해 증명한다"</li><li>식[{\operatorname{NOT}(Q) \implies \operatorname{NOT}(P)}]식을 Method #1으로 증명한다</li></ol></div><h3>Proving an "If and Only If"</h3><div><h4>Method #1</h4><ol><li>다음과 같이 쓴다. "식[P \implies Q]식과 그 역을 증명한다."</li><li>다음과 같이 쓴다. "먼저 식[P \implies Q]식를 증명한다". 이후 증명</li><li>다음과 같이 쓴다. "다음으로 식[Q \implies P]식를 증명한다". 이후 증명</li></ol><h4>Method #2</h4><ol><li>다음과 같이 쓴다. "We construct a chain of if-and-only-if implications."</li><li>어떠한 식(들)이 P와 동치임을 보이고, 다시 Q와도 동치임을 보인다</li></ol></div><h3>Proof by Cases</h3><p>명제가 가능한 모든 경우의 수에 대해 성립함을 보일 수 있다면 참임을, 단 하나의 경우라도 거짓임을 보인다면 거짓임을 증명할 수 있다</p><h3>Proof by Contradiction</h3><ol><li>다음과 같이 쓴다. "모순(Contradiction)을 통해 증명한다."</li><li>다음과 같이 쓴다. "P가 거짓이라고 가정한다"</li><li>논리적으로 모순임을 보인다</li><li>다음과 같이 쓴다. "이는 모순이며, 따라서 P는 참이다"</li></ol><div><h4>Example</h4><p><span id="pos266080820" style="padding:0!important;margin:0!important;width:0!important;height:0!important;overflow:hidden!important"></span><strong>Theorem 1.8.1.</strong> 식[\sqrt{2}]식는 무리수다</p><p><i>Proof.</i> 모순을 통해 증명한다. 식[\sqrt{2}]식가 유리수라면, 이를 표현할 수 있는 기약분수 식[n / d]식이 존재해야 한다<br>두 식을 모두 거듭제곱하면 식[2 = n^2 / d^2]식이 성립하며, 따라서 식[2d^2 = n^2]식이다. 이는 n이 2의 배수여야 함을 의미하며, 또다시 식[2d^2]식는 4의 배수여야 함을 의미한다<br>결국 n과 d모두 2의 배수여야 하지만, 이는 식[n / d]식이 기약분수라는 것에 위배된다. 이는 모순이며, 따라서 식[\sqrt{2}]식는 무리수다</p></div><h3>Good Proofs in Practice</h3><ul><li>증명은 계산이 아니라 에세이다</li></ul><h3>Problems</h3><div><h4>Problem 1.1.</h4><p>Albert announces to his class that he plans to surprise them with a quiz sometime next week.<br>His students first wonder if the quiz could be on Friday of next week. They
 reason that it can’t: if Albert didn’t give the quiz before Friday, then by midnight
 Thursday, they would know the quiz had to be on Friday, and so the quiz wouldn’t
 be a surprise any more.<br>Next the students wonder whether Albert could give the surprise quiz Thursday.
 They observe that if the quiz wasn’t given before Thursday, it would have to be
 given on the Thursday, since they already know it can’t be given on Friday. But
 having figured that out, it wouldn’t be a surprise if the quiz was on Thursday either.<br>Similarly, the students reason that the quiz can’t be on Wednesday, Tuesday, or
 Monday. Namely, it’s impossible for Albert to give a surprise quiz next week. All
 the students now relax, having concluded that Albert must have been bluffing. And
 since no one expects the quiz, that’s why, when Albert gives it on Tuesday next
 week, it really is a surprise!<br>What, if anything, do you think is wrong with the students’ reasoning?</p><p>→ '다음 주 금요일이 시험날이 될 수 없다'는 결론은 '금요일 전까지 시험을 내지 않았다'는 가정이 참일 때만 유효하며, 해당 가정의 진리값은 실제로 다음 주 금요일 자정을 넘기지 않는 이상 알 수 없으므로, 적절한 수학적 명제로 볼 수 없다</p><h4>Problem 1.3.</h4><p>What's going on here?</p><p>\[1=\sqrt{1}=\sqrt{(-1)(-1)}=\sqrt{-1}\sqrt{-1}=\left(\sqrt{-1}\right)^2=-1\]</p><ol><li>Precisely identify and explain the mistake(s) in this <i>bogus</i> proof.</li><p>식[\sqrt{ab} = \sqrt{a}\sqrt{b}]식는 식[a,b\in \mathbb{R}^{0+}]식인 경우만 성립한다. 따라서 식[\sqrt{(-1)(-1)}=\sqrt{-1}\sqrt{-1}]식 이후의 추론은 모두 잘못됐다</p><li>Prove (correctly) that if 1 = -1, then 2 = 1.</li><p>1 = -1 양변에 1을 더하면 2 = 0. 다시 양변에 2로 나누면 1 = 0. 따라서 2 = 0 = 1이 성립한다</p></ol><h4>Problem 1.4.</h4><p>Identify exactly where the bugs are in each of the following bogus proofs.</p><ol><li><i>Bogus proof</i> : 식[1¢ = $0.01 = ($0.1)^2 = (10¢)^2 = 100¢ = $1]식</li><p>식[$0.01 = $(0.1)^2]식, 식[($0.1)^2=$^2(0.1)^2]식 각각은 성립하지만 식[$ \ne 1]식이므로 식[$0.01 = ($0.1)^2]식은 성립하지 않는다</p></ol><h4>Problem 1.5.</h4><p>It's a fact that the Arithmetic Mean is at least as large as the Geometric Mean, namely, 식[{a+b \over 2} \ge \sqrt{ab}]식
 for all nonnegative real numbers a and b. But there’s something objectionable
 about the following proof of this fact. What’s the objection, and how would you fix it?</p><p><i>Bogus proof.</i>\begin{align*}
  {a+b \over 2} \ge & \sqrt{ab}, && so \\
  a+b \ge & 2\sqrt{ab}, && so \\
  a^2+2ab+b^2 \ge & 4ab, && so \\
  a^2-2ab+b^2 \ge & 0, && so \\
  (a-b)^2 \ge & 0 && \text{which we know is true.}
\end{align*}<br>The last statement is true because a - b is a real number, and the square of a real
 number is never negative. This proves the claim.</p><p>→ 증명해야 하는 명제를 가정에서 참으로 이용하고 있으므로 시작부터 잘못된 증명이다. 또, 증명 순서가 반대로 됐다</p><h4>Problem 1.7.</h4><p>Show that 식[\operatorname{log}_{7}n]식 is either an integer or irrational, where n is a positive integer. Use whatever familiar facts about integers and primes you need, but explicitly state such facts.</p><p>→ 모순을 통해 증명한다. 식[\operatorname{log}_{7}n]식이 정수가 아닌 유리수라면, 이를 표현할 수 있는 기약분수 식[{a \over b}]식이 존재해야 한다<br>식[\operatorname{log}_{7}n = {a \over b} \iff n = 7^{a \over b} \iff n^b=7^a]식<br>따라서 n은 7의 배수여야 한다. n을 소인수분해하면 식[n=2^{x_1} \cdot 3^{x_2} \cdot 5^{x_3} \cdot 7^{x_4} \cdots prime_k^{x_k} = 7^a]식<br>이때, 우변의 식[7^a]식은 7외의 소수로 나눌 수 없으므로 식[n=2^{0} \cdot 3^{0} \cdot 5^{0} \cdot 7^{x_4} \cdots prime_k^{0} = 7^{x_4}]식<br>따라서 식[n^b = 7^{x_4 b} = 7^a]식이며, 식[x_4 b = a \iff {a \over b} = x_4]식이다. 하지만 이는 식[a \over b]식가 기약분수라는 가정에 위배된다<br>이는 모순이며, 따라서 식[\operatorname{log}_{7}n]식은 정수거나 무리수이다</p><h4>Problem 1.9.</h4><p>If we raise an irrational number to an irrational power, can the result be rational? Show that it can by considering 식[\sqrt{2}^{\sqrt{2}}]식 and arguing by cases.</p><p>→ 임의 정수 n, 임의 유리수 r, 임의 무리수 i에 대하여 식[r^{{n \over i} \cdot i}=r^n]식이 성립한다</p><h4>Problem 1.16.</h4><p>Give an example of two distinct positive integers m, n such that 식[n^2]식 is a multiple of m, but n is not a multiple of m. How about having m be less than n?</p><p>→ m = 4, n = 6</p></div></div><ins class="adsbygoogle" style="display:block;text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7897366614471210" data-ad-slot="4044599363"></ins><h2>The Well Ordering Principle</h2><div><p><strong>Definition.</strong> The <i>Well Ordering Principle(WOP)</i> ::= Every <i>nonempty</i> set of <i>nonnegative integers</i> has a <i>smallest</i> element.</p><h3>Template for WOP Proofs</h3><p>WOP을 이용해 식[P(n)\text{ is true for all }n \in \mathbb{N}]식을 증명하기</p><ol><li>P(n)의 반례집합 C를 정의한다. 식[C ::= \left\{n \in \mathbb{N} | \operatorname{NOT}(P(n))\text{ is true.}\right\}]식</li><li>"C는 공집합이 아니다"를 모순을 통해 증명한다</li><li>WOP에 의해, C에는 최소 원소 n이 존재해야 한다</li><li>P(n)이 참임을 보이면, 식[n \notin C]식이며 따라서 n이 아닌 다른 최소 원소가 C에 존재해야 한다. 이는 n이 C의 최소 원소라는 것에 모순이므로,</li><li>C는 공집합이다. 따라서 P(n)은 항상 참이다</li></ol><p><span id="pos294531225" style="padding:0!important;margin:0!important;width:0!important;height:0!important;overflow:hidden!important"></span><strong>Theorem 2.2.1.</strong> 식[\forall n \in \mathbb{N}. 1 + 2 + \cdots + n = n(n+1)/2]식</p><p><i>Proof.</i></p><ul><li>n = 0. 0 = 0(0+1)/2</li><li>n = 1. 1 = 1(1+1)/2</li><li>n > 1.</li><p>반례집합 식[C ::= \left\{n \in \mathbb{N}|1+2+\cdots+n\ne n(n+1)/2\right\}]식이 공집합임을 보여 증명한다<br>먼저 C가 원소를 가진다고 가정하자. WOP에 의해 C에는 최소 원소 c > 1이 존재한다
 이때, c-1 > 0이므로 식[1+2+\cdots+(c-1)=(c-1)c/2]식가 성립한다
 양변에 c를 더하면 식[1+2+\cdots+c=(c-1)c/2 + c=c(c+1)/2]식이므로, 식[c \notin C]식이다<br>이는 c가 C의 최소 원소라는 것에 모순이므로, C는 공집합이며, 따라서 명제는 항상 참이다</p></ul><h3>Factoring into Primes</h3><p><span id="pos294561016" style="padding:0!important;margin:0!important;width:0!important;height:0!important;overflow:hidden!important"></span><strong>Theorem 2.3.1.</strong> 1보다 큰 모든 자연수는 소수의 곱으로 표현할 수 있다 ─ 소인수분해 가능하다</p><p><i>Proof.</i> 반례집합 C가 원소를 가진다고 가정하자. WOP에 의해 C에는 최소 원소 n > 1이 존재한다
 이때, n은 소수일 수 없으므로 식[1 &lt; a, b &lt; n]식를 만족하는 두 자연수 a, b의 곱이다<br> n이 C의 최소원소기 때문에 식[a, b \notin C]식며, 따라서 a, b 각각은 소인수분해 가능하다
 따라서 식[n = ab]식 역시 소인수분해 가능하며, 이는 C가 원소를 가질 수 없음을 의미한다</p><h3>Well Ordered Sets</h3><p><strong>Definition.</strong> Well ordered set ::= 어떤 숫자 집합에 대하여, 공집합이 아닌 모든 부분집합이 최소 원소를 갖는 경우</p><p><span id="pos294590807" style="padding:0!important;margin:0!important;width:0!important;height:0!important;overflow:hidden!important"></span><strong>Theorem 2.4.1.</strong> 음이 아닌 임의 정수 n에 대하여, 집합 식[S=\left\{m \in \mathbb{N}|m\ge -n\right\}]식는 well ordered set이다</p><p><i>Proof.</i> S의 모든 원소에 n을 더한 새로운 집합 S+n을 생각해보자. WOP에 의해 S+n은 0 이상의 최소 원소를 가진다. 또, S+n의 공집합이 아닌 부분집합 역시 WOP에 의해 0 이상의 최소 원소를 가진다<br> 다시 S+n 집합의 모든 원소에 n을 뺀 집합 S를 생각해보면, S와 공집합이 아닌 S의 모든 부분집합은 -n 이상의 최소 원소를 가짐을 알 수 있다</p><p><span id="pos294590838" style="padding:0!important;margin:0!important;width:0!important;height:0!important;overflow:hidden!important"></span><strong>Theorem 2.4.2.</strong> 실수 집합 S의 하한(lower bound) ::= 식[\forall s \in S. s \ge b]식를 만족하는 실수 b<br> 실수 집합 S의 상한(upper bound) ::= 식[\forall s \in S. s \le b]식를 만족하는 실수 b</p><p><span id="pos-1295600878" style="padding:0!important;margin:0!important;width:0!important;height:0!important;overflow:hidden!important"></span><strong>Corollary 2.4.3.</strong> Lower bound를 갖는 임의의 정수 집합은 well ordered set이다</p><p><i>Proof.</i> 정수 집합이 lower bound로 식[b \in \mathbb{R}]식를 갖는 경우, 정수 식[n = \lfloor b \rfloor]식 역시 집합의 lower bound다. 따라서 <a class="w3-btn w3-round-xxlarge w3-small w3-green goto" href="#pos294590807" target="_self">Goto - Theorem 2.4.1.</a>에 의하여 집합이 well ordered set임을 알 수 있다</p><p><span id="pos-1295600847" style="padding:0!important;margin:0!important;width:0!important;height:0!important;overflow:hidden!important"></span><strong>Corollary 2.4.4.</strong> Upper bound를 갖는 임의의 정수 집합은 최대 원소가 존재한다</p><p><i>Proof.</i> 정수 집합 S가 upper bound로 식[b \in \mathbb{R}]식를 가질 때, 모든 원소에 -1을 곱한 집합 -S를 생각해보자. <a class="w3-btn w3-round-xxlarge w3-small w3-green goto" href="#pos-1295600878" target="_self">Goto - Corollary 2.4.3.</a> 에 의해 -S가 최소 원소 -m를 가짐을 알 수 있으며, 다시 -S의 모든 원소에 -1을 곱한 집합 S는 최대 원소 m을 가짐을 알 수 있다</p><p><span id="pos2087474023" style="padding:0!important;margin:0!important;width:0!important;height:0!important;overflow:hidden!important"></span><strong>Lemma 2.4.5.</strong> 공집합이 아닌 모든 유한 실수 집합은 well ordered set이다</p><p><i>Proof.</i> 유한집합 크기에 관한 WOP로 증명한다<br>최소 원소를 갖지 않는 유한 실수 집합의 크기 n에 대한 집합 C를 생각하자. WOP에 의해 C는 최소 원소 m을 갖는다. 이때, 원소가 하나인 집합이 최소 원소를 가짐은 자명하므로 식[m\ge 2]식다<br>이제 원소를 m개 갖는 유한 실수 집합 F를 생각하자. F의 임의 원소 식[r_0]식를 F에서 제거한 집합 F'이라고 하자. 이때, F'의 크기는 m보다 작으므로 최소 원소 식[r_1]식을 가진다<br>따라서 식[r_0, r_1]식 중 작은 값이 F의 최소 원소가 되며, C는 공집합이다</p><div><h4>A Different Well Ordered Set</h4><p>n/(n+1) 꼴로 표현되는 집합 식[\mathbb{F}]식는 well ordered set이다\[{0 \over 1},{1 \over 2},{2 \over 3},\cdots,{n \over n+1},\cdots\]
간단하게 분자가 가장 작은 원소가 최소 원소다</p><p><span id="pos2087474054" style="padding:0!important;margin:0!important;width:0!important;height:0!important;overflow:hidden!important"></span><strong>Lemma 2.4.6.</strong> 식[\mathbb{N}+\mathbb{F}]식는 well ordered set이다</p><p><i>Proof.</i> 식[\mathbb{N}+\mathbb{F}]식의 공집합이 아닌 임의 부분집합 S를 생각한다. S의 임의 원소는 식[n+f, n\in\mathbb{N},f\in\mathbb{F}]식로 표현 가능하다
 가능한 모든 n의 집합은 WOP에 의해 최소원소 식[n_s]식를 갖는다<br>이제 S의 원소 중 식[n_s+f, f\in\mathbb{F}]식꼴로 표현 가능한 원소들에 대해, 가능한 모든 f의 집합은 WOP에 의해 최소원소 식[f_s]식를 가짐을 알 수 있다
 이를 통해 식[n_s+f_s]식가 S의 최소원소임을 알 수 있다</p></div><h3>Problems</h3><div><h4>Problem 2.5.</h4><p>Use the Well Ordering Principle to prove that there is no solution over the positive integers to the equation: \[4a^3+2b^3=c^3\]</p><p>→ 가능한 모든 해에 대하여, 식[s = a+b+c]식의 집합 S을 생각해보자. 만약 해가 존재한다면 WOP에 의해 S는 최소 원소 식[s_m=a_m+b_m+c_m]식가 존재한다<br>식[4a^3+2b^3=c^3]식의 양변을 2로 나누면 식[2a^3+b^3=c^3/2]식이며, 이를 통해 c가 2의 배수(식[c=2c']식)임을 알 수 있다. 식[2a^3+b^3=4c'^3]식
 마찬가지로 b, a도 2의 배수임을 알 수 있으며, 이제 식[a_m/2, b_m/2, c_m/2]식도 방정식의 해임을 보여 S가 공집합임을 보이겠다<br>식[4(a_m/2)^3+2(b_m/2)^3=(c_m/2)^3]식의 양변에 8을 곱하면 식[4a_m^3+2b_m^3=c_m^3]식이며, 따라서 식[s_m]식은 S의 최소 원소가 아니다
 이는 S가 공집함임을 보여주며, 따라서 방정식의 해는 존재하지 않는다</p><h4>Problem 2.6.</h4><p>You are given a series of envelopes, respectively containing 1, 2, 4, ..., 식[2^m]식 dollars. Define<ul><strong>Property</strong><i> m</i>: For any nonnegative integer less than 식[2^{m+1}]식, there is a
 selection of envelopes whose contents add up to exactly that number
 of dollars.</ul>Use the Well Ordering Principle (WOP) to prove that Property m holds for all
nonnegative integers m.</p><p>→ 우선, 1, 2, 4, ..., 식[2^m]식 달러는 각각의 봉투에 대응하므로 반례가 될 수 없다 따라서 반례 집합 C의 최소 원소 c를 2진법으로 표현했을 때, 식[{b_{m-1}b_{m-2}\cdots b_2b_1b_0}_{(2)}]식 중 적어도 2개의 자리수가 1이어야 한다
 이 중 자리수가 1인 최소 자리수가 식[b_i]식일 때, 식[c-2^i = {b_{m-1}b_{m-2}\cdots b_{i+1}0b_{i-1}\cdots b_2b_1b_0}_{(2)}]식이며, 봉투들의 합계로 표현 가능하며, 식[2^i]식 봉투는 그 중에 포함되지 않는다<br>이때, 식[c-2^i]식에 사용된 봉투 조합에 식[2^i]식 봉투를 포함하면 c달러가 되며, 이는 c가 반례 집합의 원소라는 것에 모순이다
 따라서 C는 공집합이며, 속성 m은 참이다</p><h4>Problem 2.7.</h4><p>Use the Well Ordering Principle to prove that any integer greater than or equal to 8 can be represented as the sum of nonnegative integer multiples of 3 and 5.</p><ul>8 이상의 임의 정수를 식[8 + 3x + i]식으로 표현할 수 있다. 식[x \in \mathbb{N}, i \in \{0, 1, 2\}]식<li>8 + 3x + 0 = 5 + 3(x + 1)</li><li>8 + 3x + 1 = 3(x + 3)</li><li>8 + 3x + 2 = 5*2 + 3x</li></ul><h4>Problem 2.10.</h4><p>Use the Well Ordering Principle to prove that<span id="pos38476311" style="padding:0!important;margin:0!important;width:0!important;height:0!important;overflow:hidden!important"></span>\begin{align*}n\le 3^{n/3} && (2.6)\end{align*}
for every nonnegative integer n.</p><ul>부등식은 식[n^3 \le 3^n]식과 동치다<li>n = 0. 식[0 \le 1]식</li><li>n = 1. 식[1 \le 3]식</li><li>n = 2. 식[8 \le 9]식</li><li>n = 3. 식[27 \le 27]식</li><li>식[n \ge 4]식</li><p>반례 집합 C의 최소 원소 c가 존재한다고 가정하자. 식[c^3 \gt 3^c]식<br>c-1은 부등식이 성립한다. 식[(c-1)^3 \le 3^{c-1}]식<br>양변에 식[{c \over c-1}^3]식을 곱하면 식[c^3 \le {c \over c-1}^3 3^{c-1}]식<br>따라서 식[{c \over c-1}^3 3^{c-1} \gt 3^c]식이 성립해야 한다<br>\begin{align*}
  \iff & {c \over c-1}^3 = \left(1 + {1 \over c-1}\right)^3 \gt 3 \\
  \iff & {1 + {1 \over c-1}} \gt 1.44\cdots \\
  \iff & {1 \over c-1} \gt 0.44\cdots \\
  \iff & 1 \gt (c-1)\cdot 0.44\cdots
\end{align*}
 이때, 식[c-1 \ge 3]식이므로 부등식은 성립하지 않는다
 따라서 C는 공집합이며, 명제는 참이다</p></ul></div></div><ins class="adsbygoogle" style="display:block;text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7897366614471210" data-ad-slot="4044599363"></ins><h2>Logical Formulas</h2><div><h3>Propositions from Propositions</h3><p>Propositional variables 또는 Boolean variable은 T(true) 또는 F(false) 값만 가질 수 있는 변수다</p><div><h4>IMPLIES</h4><table><caption>truth table</caption><tr><th>P</th><th>Q</th><th>P IMPLIES Q</th></tr><tr><td>T</td><td>T</td><td>T</td></tr><tr><td>T</td><td>F</td><td>F</td></tr><tr><td>F</td><td>T</td><td>T</td></tr><tr><td>F</td><td>F</td><td>T</td></tr></table><h4>If and Only If</h4><table><caption>truth table</caption><tr><th>P</th><th>Q</th><th>P IFF Q</th></tr><tr><td>T</td><td>T</td><td>T</td></tr><tr><td>T</td><td>F</td><td>F</td></tr><tr><td>F</td><td>T</td><td>F</td></tr><tr><td>F</td><td>F</td><td>T</td></tr></table></div><h3>Propositional Logic in Computer Programs</h3><div><h4>Cryptic Notation</h4><table><tr><th>English</th><th>Symbolic Notation</th></tr><tr><td>NOT(P)</td><td>식[\neg{P}, \overline{P}]식</td></tr><tr><td>P AND Q</td><td>식[P \land Q]식</td></tr><tr><td>P OR Q</td><td>식[P \lor Q]식</td></tr><tr><td>P IMPLIES Q, if P then Q</td><td>식[P \longrightarrow Q]식</td></tr><tr><td>P IFF Q</td><td>식[P \iff Q]식</td></tr><tr><td>P XOR Q</td><td>식[P \oplus Q]식</td></tr></table></div><h3>Equivalence and Validity</h3><div><h4>Implications and Contrapositives</h4><ul><li>명제의 역 == Converse</li><li>명제의 대우 == Contrapositive</li></ul><h4>Validity and Satisfiability</h4><ul><li><i>Valid</i> formula : 항상 참인 명제</li><li><i>Satisfiable</i> formula : 변수에 따라 참/거짓이 바뀌는 명제</li></ul></div><h3>The Algebra of Propositions</h3><div><h4>Propositions in Normal Form</h4><p><strong>Theorem 3.4.1.</strong> 모든 명제 식은 그와 동치인 DNF, CNF가 존재한다</p><p>예. A AND (B OR C)<table><tr><th>A</th><th>B</th><th>C</th><th>A AND (B OR C)</th></tr><tr><td>T</td><td>T</td><td>T</td><td>T</td></tr><tr><td>T</td><td>T</td><td>F</td><td>T</td></tr><tr><td>T</td><td>F</td><td>T</td><td>T</td></tr><tr><td>T</td><td>F</td><td>F</td><td>F</td></tr><tr><td>F</td><td>T</td><td>T</td><td>F</td></tr><tr><td>F</td><td>T</td><td>F</td><td>F</td></tr><tr><td>F</td><td>F</td><td>T</td><td>F</td></tr><tr><td>F</td><td>F</td><td>F</td><td>F</td></tr></table><ul><li>DNF(Disjunctive normal form) : 식이 참이 되는 행들을 OR로 연결한다</li>식[(A \land B \land C) \lor (A \land B \land \overline{C}) \lor (A \land \overline{B} \land C)]식<li>CNF(Conjunctive normal form) : 식이 거짓이 되는 행들을 AND로 연결한다</li>식[(\overline{A} \lor B \lor C) \land (A \lor \overline{B} \lor \overline{C}) \land (A \lor \overline{B} \lor C) \land (A \lor B \lor \overline{C}) \land (A \lor B \lor C)]식</ul></p><h4>Proving Equivalences</h4><table class="no-sort"><tr><td>교환법칙 of AND</td><td>식[A \land B = B \land A]식</td></tr><tr><td>결합법칙 of AND</td><td>식[(A \land B) \land C = A \land (B \land C)]식</td></tr><tr><td>항등원 of AND</td><td>식[T \land A = A]식</td></tr><tr><td>zero of AND</td><td>식[F \land A = F]식</td></tr><tr><td>멱등 of AND</td><td>식[A \land A = A]식</td></tr><tr><td>contradiction of AND</td><td>식[A \land \overline{A} = F]식</td></tr><tr><td>double negation</td><td>식[\operatorname{NOT}(\overline{A}) = A]식</td></tr><tr><td>validity of OR</td><td>식[A \lor \overline{A} = T]식</td></tr><tr><td>De Morgan for AND</td><td>식[\operatorname{NOT}(A \land B) = \overline{A} \lor \overline{B}]식</td></tr><tr><td>De Morgan for OR</td><td>식[\operatorname{NOT}(A \lor B) = \overline{A} \land \overline{B}]식</td></tr></table><ul><li>A IMPLIES B = NOT(A) OR B</li><li>식을 정규화할 때, 식[(\overline{A} \lor \overline{B}) \land (\overline{A} \lor \overline{C})]식처럼 변수에만 NOT이 적용되었다면 드모르간의 법칙을 이용해 확장할 필요가 없다</li></ul></div><h3>The SAT Problem</h3><p><strong>SAT</strong> ::= 명제가 참일 수 있는 지(satisfiable)에 대한 일반적인 결정 문제</p><h3>Predicate Formulas</h3><div><h4>Quantifiers</h4><ul><li>for all : 식[\forall]식</li><li>there exists : 식[\exists]식</li><li>Universal quantification : 명제가 항상 참인 한정</li><li>Existential quantification : 명제가 참일 수 있는 한정</li></ul><h4>Mixing Quantifiers</h4><p>예. 식[\forall{n}\in\text{Evens }\exists{p}\in\text{Primes }\exists{q}\in\text{Primes. }n=p+q]식</p><h4>Order of Quantifiers</h4><p>서로 다른 종류의 한정 문구 순서를 변경하면 의미가 바뀔 수 있다</p><h4>Variables Over One Domain</h4><p>모든 변수의 정의역이 동일하다면 표기에서 생략할 수 있다. 예. 식[\forall{x}\exists{y}.P(x, y)]식</p></div><h3>Problems</h3><div><h4>Problem 3.6.</h4><p>Propositional logic comes up in digital circuit design using the convention that T corresponds to 1 and F to 0. A simple example is a 2-bit half-adder circuit. This circuit has 3 binary inputs, a1, a0, b, and 3 binary outputs, c, s1, s0. The 2-bit word 식[a_1a_0]식 gives the binary representation of an integer k between 0 and 3. The 3-bit word 식[cs_1s_0]식 gives the binary representation of k C b. The third output bit c is called the final carry bit.<br>So if k and b were both 1, then the value of 식[a_1a_0]식 would be 01 and the value of the output 식[cs_1s_0]식 would 010, namely, the 3-bit binary representation of 1 + 1.<br>In fact, the final carry bit equals 1 only when all three binary inputs are 1, that is, when k = 3 and b = 1. In that case, the value of 식[cs_1s_0]식 is 100, namely, the binary representation of 3 + 1.<br>This 2-bit half-adder could be described by the following formulas:<br>\begin{align*}
  c_0 =& b \\
  s_0 =& a_0\text{ XOR }c_0 \\
  c_1 =& a_0\text{ AND }c_0 && \text{the carry into column 1} \\
  s_1 =& a_1\text{ XOR }c_1 \\
  c_2 =& a_1\text{ AND }c_1 && \text{the carry into column 2} \\
  c   =& c_2
\end{align*}</p><ul><li>(a) Generalize the above construction of a 2-bit half-adder to an n + 1 bit half-adder with inputs 식[a_n,\cdots,a_1,a_0]식 and b and outputs 식[c,s_n,\cdots,s_1,s_0]식. That is, give simple formulas for 식[s_i]식 and 식[c_i]식 for 식[0 \le i \le n + 1]식, where 식[c_i]식 is the carry into column i + 1, and 식[c = c_{n+1}]식</li><p>\begin{align*}  c_0 =& b \\
  s_i =& a_i\text{ XOR }c_i \\
  c_{i+1} =& a_i\text{ AND }c_i
\end{align*}</p><li>(b) Write similar definitions for the digits and carries in the sum of two n + 1-bit binary numbers 식[a_n,\cdots,a_1,a_0]식 and 식[b_n,\cdots,b_1,b_0]식</li><p>\begin{align*}  c_0 =& 0 \\
  s_i =& a_i\text{ XOR }b_i\text{ XOR }c_i \\
  c_{i+1} =& (a_i\text{ AND }b_i)\text{ OR }(b_i\text{ AND }c_i)\text{ OR }(c_i\text{ AND }a_i)
\end{align*}</p><li>(c) How many of each of the propositional operations does your adder from part (b) use to calculate the sum?</li><p>To add two n bit numbers, (2+5)n times unit operations are needed</p></ul><h4>Problem 3.17.</h4><p>A half dozen different operators may appear in propositional formulas, but just AND, OR, and NOT are enough to do the job. That is because each of the operators
 is equivalent to a simple formula using only these three operators. For example,
 A IMPLIES B is equivalent to NOT(A) OR B. So all occurences of IMPLIES in a
 formula can be replaced using just NOT and OR.</p><ul><li>(a) Write formulas using only AND, OR, NOT that are equivalent to each of A IFF B and A XOR B. Conclude that every propositional formula is equivalent to an AND-OR-NOT formula.</li><ul><li>A iff B = (A and B) or (not(A) and not(B))</li><li>A xor B = (A and not(B)) or (not(A) and B)</li></ul><li>(b) Explain why you don’t even need AND.</li><p>A and B = not(not(A) or not(B))</p><li>(c) Explain how to get by with the single operator NAND where A NAND B is equivalent by definition to NOT(A AND B)</li><ul><li>A and B = (A nand B) nand (A nand B)</li><li>not(A) = A nand A</li><li>A or B = not(not(A) and not(B)) = X nand X<br>where X = (Y nand Z) nand (Y nand Z), Y = A nand A, Z = B nand B</li></ul></ul><h4>Problem 3.18.</h4><p>The propositional connective NOR is defined by the rule<br>P NOR Q ::= NOT(P) AND NOT(Q)<br>Explain why every propositional formula—possibly involving any of the usual operators such as IMPLIES, XOR, . . .—is equivalent to one whose only connective is NOR.</p><ul><li>not(A) = A nor A</li><li>A or B = not(A nor B) = (A nor b) nor (A nor b)</li><li>A and b = not(not(A) or not(B)) = X nor X<br>where X = (Y nor Z) nor (Y nor Z), Y = A nor A, Z = B nor B</li></ul><h4>Problem 3.19.</h4><p>Explain how to read off a conjunctive form for a propositional formula directly from a disjunctive form for its complement.</p><p>→ Any DNF 식[P_1\text{ OR }P_2\text{ OR }\cdots\text{ OR }P_n]식, where 식[P_i=Q_{i1}\text{ AND }Q_{i2}\text{ AND }\cdots\text{ AND }Q_{im_i}]식<br>\begin{align*}
   & \text{ NOT}(P_1\text{ OR }P_2\text{ OR }\cdots\text{ OR }P_n) \\
  =& \text{ NOT}(P_1)\text{ AND }\text{ NOT}(P_2)\text{ AND }\cdots\text{ AND }\text{ NOT}(P_n) \\
  =& (\text{ NOT}(Q_{11})\text{ OR }\text{ NOT}(Q_{12})\text{ OR }\cdots\text{ OR }\text{ NOT}(Q_{1m_1})))\text{ AND } \\
   & (\text{ NOT}(Q_{21})\text{ OR }\text{ NOT}(Q_{22})\text{ OR }\cdots\text{ OR }\text{ NOT}(Q_{2m_1})))\text{ AND } \\
   & \vdots \\
   & (\text{ NOT}(Q_{n1})\text{ OR }\text{ NOT}(Q_{n2})\text{ OR }\cdots\text{ OR }\text{ NOT}(Q_{2n_1})))
\end{align*}</p><h4>Problem 3.32.</h4><p>The goal of this problem is to translate some assertions about binary strings into logic notation. The domain of discourse is the set of all finite-length binary strings:
 λ, 0, 1, 00, 01, 10, 11, 000, 001, . . . . (Here λ denotes the empty string.) In your
 translations, you may use all the ordinary logic symbols (including =), variables,
and the binary symbols 0, 1.<br>A string like 01x0y of binary symbols and variables denotes the concatenation
 of the symbols and the binary strings represented by the variables. For example, if
 the value of x is 011 and the value of y is 1111, then the value of 01x0y is the
 binary string 0101101111.</p><ul><li>(a) x consists of three copies of some string.</li><p>→ 식[\exists{y}. x=yyy]식</p><li>(b) x is an even-length string of 0’s.</li><p>→ let CONCAT(a, b, c, ...) = abc...<br>let REPT(a, n) = CONCAT(a, REPT(a, n-1)) = CONCAT(aa, REPT(a, n-2)) = CONCAT(aa...a, REPT(a, 0)) = CONCAT(aa...a, λ) = aa...a<br>x = REPT(00, n) where n \in N</p><li>(c) x does not contain both a 0 and a 1.</li><p>→ x = λ</p><li>(d) x is the binary representation of 식[2^k + 1]식 for some integer 식[k \ge 0]식</li><p>→ x = 1 or CONCAT(1, REPT(0, n), 1) where 식[n \in \mathbb{N}]식</p></ul></div></div><ins class="adsbygoogle" style="display:block;text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7897366614471210" data-ad-slot="4044599363"></ins><h2>Mathematical Data Types</h2><div><h3>Sets</h3><div><h4>Some Popular Sets</h4><ul><li>식[\emptyset]식 : Empty set</li><li>식[\mathbb{N}]식 : Nonnegative integers</li><li>식[\mathbb{Z}]식 : Integers</li><li>식[\mathbb{Q}]식 : Rational numbers</li><li>식[\mathbb{R}]식 : Real numbers</li><li>식[\mathbb{C}]식 : Complex numbers</li></ul><h4>Comparing and Combining Sets</h4><ul><li>식[S \subseteq T]식 : S is a subset of T</li><li>식[S \subset T]식 : S is a strict subset of T</li><li>Union : 식[x \in A \cup B\text{　　iff　　}x \in A\text{ OR }x \in B]식</li><li>Intersection : 식[x \in A \cap B\text{　　iff　　}x \in A\text{ AND }x \in B]식</li><li>Difference : 식[x \in A - B\text{　　iff　　}x \in A\text{ AND }x \notin B]식</li><li>Complement : 식[\overline{A} ::= D - A]식 where D is domain set</li></ul><h4>Power Set</h4><p>pow(A) ::= The set of all the subsets of a set A</p></div><h3>Sequences</h3><ul><li>A sequence is a list of objects called terms or components. e.g. (a, b, c)</li><li>λ ::= empty sequence</li><li>Cartesian product of sets, 식[S_1\times S_2\times\cdots\times S_n]식, is a new set consisting of all sequences where the first component is drawn from S1, the second from S2, and so forth.</li><li>식[S^n = S\times S\times\cdots\times S]식</li></ul><h3>Functions</h3><div><h4>Domains and Images</h4><ul><li>식[f:A\rightarrow B]식 indicates that f is a function with domain, A, and codomain, B</li><li>Partial function : function is not defined for some elements in the domain</li><li>Total function : function is defined for every element in the domain</li><li>range(f) ::= f(domain(f))</li><li>image of S under f ::= f(S) where 식[S \subseteq A]식</li></ul><h4>Function Composition</h4><p><span id="pos260733567" style="padding:0!important;margin:0!important;width:0!important;height:0!important;overflow:hidden!important"></span><strong>Definition 4.3.1.</strong> For functions 식[f:A\rightarrow B]식 and 식[g:B\rightarrow C]식, the composition, 식[g\circ f]식 is defined by the rule: 식[\forall{x}\in A, (g\circ f)(x) ::= g(f(x))]식</p></div><h3>Binary Relations</h3><p><span id="pos260763358" style="padding:0!important;margin:0!important;width:0!important;height:0!important;overflow:hidden!important"></span><strong>Definition 4.4.1.</strong> A binary relation, R, constists of a set, A, called the domain of R, a set, B, called the codomain of R, and a subset of 식[A\times B]식 called the graph of R</p><ul><li>Also said to be "relation between A and B", "relation from A to B"</li><li>식[R:A\rightarrow B]식</li><li>"a R b" means the pair (a, b) is in the graph of R</li></ul><div><h4>Relation Diagrams</h4><p><span id="pos260763389" style="padding:0!important;margin:0!important;width:0!important;height:0!important;overflow:hidden!important"></span><strong>Definition 4.4.2.</strong> A binary relation, R, is:</p><ul><li>function when it has the [식[\le]식1 arrow out] property</li><li>surjective when it has the [식[\ge]식1 arrows in] property</li><li>total when it has the [식[\ge]식1 arrows out] property</li><li>injective when it has the [식[\le]식1 arrows in] property</li><li>bijective when it has both the [=1 arrows in] and the [=1 arrows out] property</li></ul><h4>Relational Images</h4><p><span id="pos260763482" style="padding:0!important;margin:0!important;width:0!important;height:0!important;overflow:hidden!important"></span><strong>Definition 4.4.5.</strong> The inverse, 식[R^{-1}]식 of a relation 식[R:A\rightarrow B]식 is the relation from B to A defined by the rule: 식[b R^{-1} a\text{　　iff　　}a R b]식</p><p><span id="pos260763513" style="padding:0!important;margin:0!important;width:0!important;height:0!important;overflow:hidden!important"></span><strong>Definition 4.4.6.</strong> The image of a set under the relation,  식[R^{-1}]식, is called the inverse image of the set.</p></div><h3>Finite Cardinality</h3><p><span id="pos260793149" style="padding:0!important;margin:0!important;width:0!important;height:0!important;overflow:hidden!important"></span><strong>Definition 4.5.1.</strong> If A is a finite set, the cardinality(= size) |A| is the number of elements in A</p><p><span id="pos260793180" style="padding:0!important;margin:0!important;width:0!important;height:0!important;overflow:hidden!important"></span><strong>Definition 4.5.2.</strong> Let A, B be sets. Then</p><ul><li>A surj B iff there is a surjective function from A to B</li><li>A inj B iff there is an injective total relation from A to B</li><li>A bij B iff there is a bijection from A to B</li></ul><p><span id="pos351878993" style="padding:0!important;margin:0!important;width:0!important;height:0!important;overflow:hidden!important"></span><strong>Theorem 4.5.4.</strong> [Mapping Rules] For finite sets A, B,</p><ul><li>A surj B iff |A| >= |B|</li><li>A inj B iff |A| &lt;= |B|</li><li>A bij B iff |A| = |B|</li></ul></div><ins class="adsbygoogle" style="display:block;text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7897366614471210" data-ad-slot="4044599363"></ins><h2>Induction</h2>139p<div><h3>Ordinary Induction</h3><h3>Strong Induction</h3><h3>Strong Inductions vs. Induction vs. Well Ordering</h3></div><h2>State Machines</h2><div><h3>States and Transitions</h3><h3>The Invariant Principle</h3><h3>Partial Correctness &amp; Termination</h3><h3>The Stable Marriage Problem</h3></div><h2>Recursive Data Types</h2><div><h3>Recursive Definitions and Structural Induction</h3><h3>Strings of Matched Brackets</h3><h3>Recursive Functions on Nonnegative Integers</h3><h3>Arithmetic Expressions</h3><h3>Games as a Recursive Data Type</h3><h3>Induction in Computer Science</h3></div><h2>Infinite Sets</h2><div><h3>Infinite Cardinality</h3><h3>The Halting Problem</h3><h3>The Logic of Sets</h3><h3>Does All This Really Work?</h3></div></div><h1>Structures</h1><div><h2>Introduction</h2><h2>Number Theory</h2><div><h3>Divisibility</h3><h3>The Greatest Common Divisor</h3><h3>Prime Mysteries</h3><h3>The Fundamental Theorem of Arithmetic</h3><h3>Alan Turing</h3><h3>Modular Arithmetic</h3><h3>Remainder Arithmetic</h3><h3>Turing's Code (Version 2.0)</h3><h3>Multiplicative Inverses and Cancelling</h3><h3>Euler's Theorem</h3><h3>RSA Public Key Encryption</h3><h3>What has SAT got to do with it?</h3><h3>Problems</h3></div><h2>Directed graphs &amp; Partial Orders</h2><div><h3>Vertex Degrees</h3><h3>Walks and Paths</h3><h3>Adjacency Matrices</h3><h3>Walk Relations</h3><h3>Directed Acyclic Graphs &amp; Scheduling</h3><h3>Partial Orders</h3><h3>Representing Partial Orders by Set Containment</h3><h3>Linear Orders</h3><h3>Product Orders</h3><h3>Equivalence Relations</h3><h3>Summary of Relational Properties</h3><h3>Problems</h3></div><h2>Communication Networks</h2><div><h3>Routing</h3><h3>Routing Measures</h3><h3>Network Designs</h3></div><h2>Simple Graphs</h2><div><h3>Vertex Adjacency and Degrees</h3><h3>Sexual Demographics in America</h3><h3>Some Common Graphs</h3><h3>Isomorphism</h3><h3>Bipartite Graphs &amp; Matchings</h3><h3>Coloring</h3><h3>Walks in Simple Graphs</h3><h3>Connectivity</h3><h3>Special Walks and Tours</h3><h3>k-connected Graphs</h3><h3>Forests &amp; Trees</h3><h3>Problems</h3></div><h2>Planar Graphs</h2><div><h3>Drawing Graphs in the Plane</h3><h3>Definitions of Planar Graphs</h3><h3>Euler's Formula</h3><h3>Bounding the Number of Edges in a Plannar Graph</h3><h3>Returning to 식[K_5]식 and 식[K_{3,3}]식</h3><h3>Coloring Planar Graphs</h3><h3>Classifying Polyhedra</h3><h3>Another Characterization for Planar Graphs</h3></div></div><h1>Counting</h1><div><h2>Introduction</h2><h2>Sums and Asymptotics</h2><div><h3>The Value of an Annuity</h3><h3>Sums of Powers</h3><h3>Approximating Sums</h3><h3>Hanging Out Over the Edge</h3><h3>Products</h3><h3>Double Trouble</h3><h3>Asymptotic Notation</h3></div><h2>Cardinality Rules</h2><div><h3>Counting One Thing by Counting Another</h3><h3>Counting Sequences</h3><h3>The Generalized Product Rule</h3><h3>The Division Rule</h3><h3>Counting Subsets</h3><h3>Sequences with Repetitions</h3><h3>Counting Practice: Poker Hands</h3><h3>The Pigeonhole Principle</h3><h3>Inclusion-Exclusion</h3><h3>Combinatorial Proofs</h3><h3>Problems</h3></div><h2>Generating Functions</h2><div><h3>Infinite Series</h3><h3>Counting with Generating Functions</h3><h3>Partial Fractions</h3><h3>Solving Linear Recurrences</h3><h3>Formal Power Series</h3><h3>Problems</h3></div></div><h1>Probability</h1><div><h2>Introduction</h2><h2>Events and Probability Spaces</h2><div><h3>Let's Make a Deal</h3><h3>The Four Step Method</h3><h3>Strange Dice</h3><h3>The Birthday Principle</h3><h3>Set Theory and Probability</h3><h3>Problems</h3></div><h2>Conditional Probability</h2><div><h3>Month Hall Confusion</h3><h3>Definition and Notation</h3><h3>The Four-Step Method for Conditional Probability</h3><h3>Why Tree Diagrams Work</h3><h3>The Law of Total Probability</h3><h3>Simpson's Paradox</h3><h3>Independence</h3><h3>Mutual Independence</h3><h3>Probability versus Confidence</h3></div><h2>Random Variables</h2><div><h3>Random Variable Examples</h3><h3>Independence</h3><h3>Distribution Functions</h3><h3>Great Expectations</h3><h3>Linearity of Expectation</h3></div><h2>Deviation from the Mean</h2><div><h3>Markov's Theorem</h3><h3>Chebyshev's Theorem</h3><h3>Properties of Variance</h3><h3>Estimation by Random Sampling</h3><h3>Confidence in an Estimation</h3><h3>Sums of Random Variables</h3><h3>Really Great Expectations</h3></div><h2>Random Walks</h2><div><h3>Gambler's Ruin</h3><h3>Random Walks on Graphs</h3></div></div><h1>Recurrences<h2>Introduction</h2><h2>Recurrences</h2><div><h3>The Towers of Hanoi</h3><h3>Merge Sort</h3><h3>Linear Recurrences</h3><h3>Divide-and-Conquer Recurrences</h3><h3>A Feel for Recurrences</h3></div></h1><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-7897366614471210" data-ad-slot="6629226643" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({})</script></div><hr>&copy; 2020. <a href="mailto:hi.donggi@gmail.com">Donggi Kim</a> all rights reserved.<a class="w3-btn w3-round-xxlarge w3-small w3-green" href="/LICENSE">LICENSE</a></div></body></html>