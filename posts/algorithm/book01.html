<div class="row">
    <div class="col-2">
        <img src="http://seoji.nl.go.kr/fu/ecip/dbfiles/CIP_FILES_TBL/6534360_3.jpg" alt="책표지">
    </div>

    <div class="col-10">
        <table class="table">
            <tr>
                <th>표제/저자사항</th>
                <td>알고리즘 도감 / 이시다 모리테루,미야자키 쇼이치 지음 ;김완섭 옮김
                </td>
            </tr>
            <tr>
                <th>ISBN 정보</th>
                <td>979-11-88621-12-5 [93000] 
                </td>
            </tr>
            <tr>
            <tr>
                <th>발행사항</th>
                <td>Jpub(제이펍) , 발행일 : 20180209
                </td>
            </tr>
            <tr>
                <th>출판사 홈페이지</th>
                <td>http://www.jpub.kr
                </td>
            </tr>
        </table>
    </div>
</div>

<hr>

<ol>
    <li>문자열 검색; Boyer-Moore</li>
    예. abcxdezcabacabac에서 abac 검색<br>
    처음 검색 인덱스 0. 마지막 위치의 x는 패턴에 없는 문자이므로 다음 검색 인덱스는 1이 아닌 4.

    <li>최단경로 찾기; 다익스트라</li>
    <ol>
        <li>시작점의 가중치는 0, 나머지 모든 정점의 초기 가중치는 무한대</li>
        간선의 가중치에 음수가 있는 경우, 전체 간선의 가중치를 적절히 더해 0 이상으로 만들어 주면 된다.

        <li>정의</li>
        let W(P) := 시작점으로부터 정점 P까지 도달하는 가중치의 현재 최소합.<br>
        let W(P1, P2) := 간선 P1-P2의 가중치<br>
        Working set := 최단경로 알고리즘의 가중치 업데이트 대상이 되는 정점 집합. 최초값은 시작점으로부터 간선 하나만 건너 도달할 수 있는 모든 정점

        <li>Working set에 속한 정점 P중, W(P)가 가장 낮은 P에 대해 다음을 수행한다</li>
        <ol>
            <li>Working set에서 P 제거</li>
            <li>P에서 간선 하나만 건너 도달할 수 있는 모든 정점 P'에 대해, W(P') = min(W(P'), W(P) + W(P, P'))를 수행하고, W(P')값이 변경된 경우 P'을 Working set에 추가한다.</li>
            <li>만약 P'이 목표 지점이라면, 최단 경로를 찾았으므로 추가 작업을 중지한다.</li>
        </ol>
    </ol>

    <li>최단경로 찾기; A*</li>
    추정 도착점의 추정 가중치 0부터 시작하여, 추정 도착점으로부터 먼 정점일수록 높아지는 추정 가중치를 갖고 시작한다.<br>
    다익스트라 알고리즘을 사용하되, Working set에서 작업 대상이 되는 원소를 찾을 때, 추정 가중치를 합하여 구한다는 게 차이점.

    <li>디피-헬만 키 교환법</li>
    두 키 K1, K2를 합성하는, 교환법칙이 성립하는(F(k1, k2) == F(k2, k1)) 함수 F가 있을 때, 두 대화 참여자 A, B의 키 생성 절차는 아래와 같다.
    <ol>
        <li>A가 B에게 공개키 P를 전달</li>
        <li>A, B가 각각 비밀키 SA, SB를 준비.</li>
        <li>A는 B에게 F(P, SA)를, B는 A에게 F(P, SB)를 전달</li>
        <li>A, B는 이제 각각 F(P, SB, SA), F(P, SA, SB)를 이용하여 대화를 암호화할 수 있다.</li>
    </ol>
    중간에 공개된 키들을 모두 가로채더라도, P, F(P, SA), F(P, SB)만으로는 F(P, SA, SB)를 만들어낼 수 없다. 아래는 RSA키 생성 절차
    <ol>
        <li>A가 B에게 (소수 P, 생성자 G) 전달</li>
        <li>A, B가 각각 비밀키 X, Y를 준비. (X, Y &lt; P-2)</li>
        <li>A는 B에게 G^X mod P를, B는 A에게 G^Y mod P를 전달</li>
        <li>A, B는 이제 각각 (G^Y mod P)^X mod P, (G^X mod P)^Y mod P == G^(XY) mod P를 공유한다.</li>
    </ol>

    <li>메시지 인증 코드; MAC(Message Authentication Code)</li>
    암호문과 키를 이용해 만든 MAC를 암호문과 같이 전달하면 수신측은 암호문 또는 키의 변조를 감지해낼 수 있다. 흔히 사용되는 것은 암호문과 키를 해싱하여 MAC을 행성하는 HMAC

    <li>전자 서명</li>
    <ol>
        <li>A는 메시지(평문이든 다른 암호문이든 무관), 비밀키, 공개키를 준비.</li>
        키 생성 알고리즘 G : 서명자의 (비밀키, 공개키)쌍을 생성한다.
        <li>A는 B에게 공개키를 전달.</li>
        <li>A는 비밀키를 사용해 메시지를 암호화. 이것이 전자 서명</li>
        서명 생성 알고리즘 S : 메시지와 비밀키를 입력받으면 서명을 생성한다
        <li>A는 메시지와 전자 서명을 B에게 전달.</li>
        <li>B는 공개키를 이용해 암호문을 복호화하여 전자 서명과 일치하는지 확인.</li>
        서명 검증 알고리즘 V : 메시지, 공개키, 서명을 입력받으면 승인/거부를 출력한다
    </ol>
</ol>