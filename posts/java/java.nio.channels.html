<script src="/source/utility.js?200203_1003"></script>
<script src="/source/redirect.js?200203_0949"></script>
<hr>

<details>
    <summary>채널 인터페이스</summary>
    <details>
        <summary>interface Channel extends Closeable Since 1.4</summary>
        boolean isOpen(); 채널이란 독립적인 IO를 수행할 수 있는 개체에 대한 연결이다.
    </details>
    <details>
        <summary>interface ReadableByteChannel extends Channel Since 1.4</summary>
        int read(ByteBuffer dst) : dst.remaining()만큼 읽어 dst에 저장. 읽은 바이트 개수를 반환. 스트림의 끝이면 -1.
    </details>
    <details>
        <summary>interface WritableByteChannel extends Channel Since 1.4</summary>
        int write(ByteBuffer src) : src.remaining() 부분을 채널에 쓴다.
    </details>
    <details>
        <summary>interface ByteChannel extends ReadableByteChannel, WritableByteChannel Since 1.4</summary>
        바이트 단위 읽기/쓰기 모두 가능한 채널.
    </details>
    <details>
        <summary>interface AsynchronousChannel extends Channel Since 1.7</summary>
        비동기 I/O를 지원하는 채널. close()도 비동기적으로 수행되며, 도중/이후 작업은 AsynchronousCloseException 발생시키면 된다
    </details>
    <details>
        <summary>interface InterruptibleChannel extends Channel Since 1.4</summary>
        "instanceof InterruptibleChannel" IFF "비동기적으로 close() 메서드를 통해 인터럽트되고 닫을 수 있는 채널"
    </details>
    <details>
        <summary>interface AsynchronousByteChannel extends AsynchronousChannel Since 1.7</summary>
        <ol>
            <li>비동기 IO를 지원하는 바이트 채널</li>
            <li>&lt;A&gt; void read(ByteBuffer dst, A attachment, CompletionHandler&lt;Integer, ? super A&gt; handler)</li>
            기본 동작은 ReadableByteChannel#read와 동일. 쓰기가 완료(실패)되면 handler가 호출된다. handler에 전달될 첫 인자는 읽은 바이트 수.
            <li>Future&lt;Integer&gt; read(ByteBuffer dst)</li>
            반환된 Future#get 메서드로 읽은 바이트 수를 얻을 수 있다.
            <li>&lt;A&gt; void write(ByteBuffer src, A attachment, CompletionHandler&lt;Integer, ? super A&gt; handler)</li>
            <li>Future&lt;Integer&gt; write(ByteBuffer src)</li>
        </ol>
    </details>
    <details>
        <summary>interface ScatteringByteChannel extends ReadableByteChannel Since 1.4</summary>
        채널의 바이트들을 여러 버퍼에 순서대로 저장. 네트워크 헤더나 파일 메타데이터처럼 고정 길이의 헤더를 읽는 데 유용.<br>
        long read(ByteBuffer[] dsts, int offset, int length) : dsts[offset]부터 length개의 버퍼가 각각의 remaining()만큼씩 바이트를 읽어 가져간다.
    </details>
    <details>
        <summary>interface GatheringByteChannel extends WritableByteChannel Since 1.4</summary>
        long write(ByteBuffer[] srcs, int offset, int length) : srcs[offset]부터 length개의 버퍼의 remaining() 부분을 채널에 쓴다.
    </details>
    <details>
        <summary>interface SeekableByteChannel extends ByteChannel Since 1.7</summary>
        <ol>
            <li>현재 위치를 기억하는 바이트 채널.</li>
            <li>SeekableByteChannel position(long newPosition) + getter 오버로딩</li>
            position을 변경하고 그대로 반환.
            <li>long size() : 채널에 연결된 개체의 크기 반환</li>
            <li>SeekableByteChannel truncate(long size)</li>
            채널에 연결된 개체의 크기를 size로 조정. size가 현재보다 작은 경우 나머지는 버려진다(position이 size보다 큰 경우 size로 조정된다). size가 현재 이상인 경우 아무 변경 없다.
        </ol>
    </details>
    <details>
        <summary>interface NetworkChannel extends Channel Since 1.7</summary>
        <ol>
            <li>네트워크 소켓에 대한 채널</li>
            <li>NetworkChannel bind(SocketAddress local)</li>
            <li>SocketAddress getLocalAddress()</li>
            <li>&lt;T&gt; NetworkChannel setOption(SocketOption&lt;T&gt; name, T value) + getOption</li>
            <li>Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions()</li>
        </ol>
    </details>
    <details>
        <summary>interface MulticastChannel extends NetworkChannel Since 1.7</summary>
        <ol>
            <li>IP 계층 멀티캐스팅 가능한 채널</li>
            <li>MembershipKey join(InetAddress group, NetworkInterface interf)</li>
            <li>MembershipKey join(InetAddress group, NetworkInterface interf, InetAddress source)</li>
            source에서 온 데이터그램만 받고자 하는 경우 사용. OS에서 소스 필터링을 지원하지 않으면 예외 발생.
        </ol>
    </details>
</details>

<hr>

<details>
    <summary>비동기 채널 관련</summary>
    <details>
        <summary>interface CompletionHandler&lt;V, A&gt; Since 1.7</summary>
        <ol>
            <li>비동기 I/O 작업의 결과를 소비하는 소비자</li>
            <li>void completed(V result, A attachment) : 성공시 호출된다</li>
            <li>void failed(Throwable exc, A attachment) : 실패시 호출된다</li>
        </ol>
    </details>

    <details>
        <summary>abstract class AsynchronousChannelGroup Since 1.7</summary>
        <ol>
            <li>그룹 지정되지 않은 비동기 채널들은 시스템 기본 그룹에 묶인다</li>
            시스템 속성에 따라 생성된 ThreadFactory가 비동기 작업을 실행할 데몬 스레드들을 만든다.
            <li>static AsynchronousChannelGroup withFixedThreadPool(int nThreads, ThreadFactory threadFactory)</li>
            최대 nThreads의 스레드만 동시에 실행된다. 시스템 기본 AsynchronousChannelProvider 객체의 openAsynchronousChannelGroup(int, ThreadFactory) 메서드를 통해 만들어진다
            <li>static AsynchronousChannelGroup withCachedThreadPool(ExecutorService executor, int initialSize) + 오버로딩</li>
            시스템 기본 AsynchronousChannelProvider 객체의 openAsynchronousChannelGroup(ExecutorService, int) 메서드를 통해 만들어진다.<br>
            채널 그룹의 종료(shutdown)는 ExecutorService의 shutdown()으로 이어진다. 따라서 ExecutorService가 외부에서 닫히는 경우엔 무슨 일이 일어날 지 모른다

            <li>abstract boolean isShutdown() + isTerminated</li>
            <li>abstract void shutdown()</li>
            순차적 종료 절차에 진입한다.
            <li>abstract void shutdownNow()</li>
            shutdown() + 모든 열린 채널들을 닫는다. 실행 중인 CompletionHandler들은 끝날 때까지 기다린다. 도중에 다른 스레드에서 이 메서드를 호출하는 경우, 현재 작업이 완료될 때까지 블록된다; 더 불러도 추가 작업은 없다.
            <li>abstract boolean awaitTermination(long timeout, TimeUnit unit)</li>
        </ol>
    </details>

    <details>
        <summary>abstract class AsynchronousFileChannel implements AsynchronousChannel Since 1.7</summary>
        <ol>
            <li>파일에 대한 비동기 채널. I/O의 기준이 되는 현재 위치를 갖고 있지 않으며, 메서드에서 지정한다</li>
            <li>생성된 채널들은 스레드-안전하며, 완료 핸들러들은 별개의 스레드에서 실행됨이 보장된다.</li>
            연산에 사용되는 ByteBuffer 자체는 스레드-안전하지 않음에 유의
            <li>static AsynchronousFileChannel open(Path file, Set&lt;? extends OpenOption&gt; options, ExecutorService executor, FileAttribute&lt;?&gt;... attrs)</li>
            파일을 열거나 생성한 뒤 비동기 채널을 하나 반환한다. options에는 java.nio.file.StandardOpenOption을 이용하면 된다.
            <li>static AsynchronousFileChannel open(Path file, OpenOptions... options)</li>
            open(file, opts, null, new FileAttribute&lt;?&gt;[0])

            <li>abstract long size() : 기저 파일의 크기</li>
            <li>abstract AsynchronousFileChannel truncate(long size)</li>
            size() &gt; size인 경우 파일을 자른다. return this;
            <li>abstract void force(boolean metaData)</li>
            메서드 호출 시점부터 true면 StandardOpenOption.SYNC를, false면 StandardOpenOption.DSYNC를 적용하는 것과 같다. 기저 파일이 로컬에 존재하는 경우에만 유효하다.
            <li>abstract &lt;A&gt; void lock(long position, long size, boolean shared, A attachment, CompletionHandler&lt;FileLock, ? super A&gt; handler)</li>
            기저 파일 일부에 대한 잠금을 얻는다. handler는 잠금을 얻는 데 성공/실패하면 호출된다. 잠금 size는 고정이므로, 파일 크기가 커질 것도 고려하여 필요한 만큼 신청해놔야 한다.
            <li>final &lt;A&gt; void lock(A attachment, CompletionHandler&lt;FileLock, ? super A&gt; handler)</li>
            lock(0L, Long.MAX_VALUE, false, attachment, handler)
            <li>abstract Future&lt;FileLock&gt; lock(long position, long size, boolean shared) + 오버로딩</li>
            <li>abstract FileLock tryLock(long position, long size, boolean shared) + 오버로딩</li>
            스레드를 블록하지 않는다. OverlappingFileLockException에 해당하는 상황에는 null이 반환된다
            <li>abstract &lt;A&gt; void read(ByteBuffer dst, long position, A attachment, CompletionHandler&lt;Integer, ? super A&gt; handler) + 오버로딩</li>
            handler에 전달되는 Integer는 읽은 바이트 길이, 또는 -1(position &gt; size())
            <li>abstract &lt;A&gt; void write(ByteBuffer src, long position, A attachment, CompletionHandler&lt;Integer, ? super A&gt; handler) + 오버로딩</li>
            position &gt; size()인 경우, 그 사이 바이트 값은 쓰레기 값이다.
        </ol>
    </details>

    <details>
        <summary>abstract class AsynchronousServerSocketChannel implements AsynchronousChannel, NetworkChannel Since 1.7</summary>
        <ol>
            <li>스트림 지향 읽기 소켓 채널
                <button class="btn-code" path="Repositories/Eclipse/JavaSE/src/nio/AsynchronousSocketChannelTest.java" lan="java">예시 코드 »</button></li>
            <li>스레드-안전하지만 최대 accept 가능한 스레드는 하나 뿐이며, accept 도중 중복되는 요청은 AcceptPendingException</li>
            <li>지원하는 소켓 옵션 : SO_RCVBUF(수신 버퍼 크기), SO_REUSEADDR(주소 재사용); 구현에 따라 추가될 수도 있다</li>

            <li>static AsynchronousServerSocketChannel open(AsynchronousChannelGroup group) + 오버로딩</li>
            group을 지정하지 않거나 null로 설정하는 경우 시스템 기본 그룹이 이용된다
            <li>final AsynchronousServerSocketChannel bind(SocketAddress local, int backlog) + 오버로딩 + getLocalAddress</li>
            backlog는 소켓에 대한 최대 pending connection 수. 0이나 음수로 설정하면 구현체의 기본값을 이용한다. return this;
            <li>abstract &lt;A&gt; void accept(A attachment, CompletionHandler&lt;AsynchronousSocketChannel, ? super A&gt; handler) + 오버로딩</li>
            신규 연결된 AsynchronousSocketChannel은 현재 채널과 동일한 채널 그룹에 묶인다. 그룹이 닫힌 경우, 신규 연결도 닫히고 ShutdownChannelGroupException
        </ol>
    </details>

    <details>
        <summary>abstract class AsynchronousSocketChannel implements AsynchronousByteChannel, NetworkChannel Since 1.7</summary>
        <ol>
            <li>스트림 지향 소켓 채널. open 팩터리 메서드로 직접 열거나(Unbound), AsynchronousServerSocketChannel#accept로 열 수(Bound) 있다.
                <button class="btn-code" path="Repositories/Eclipse/JavaSE/src/nio/AsynchronousSocketChannelTest.java" lan="java">예시 코드 »</button></li>
            <li>스레드-안전하지만 최대 하나의 읽기/쓰기만 각각 동시에 존재할 수 있다.</li>
            도중에 중복되는 요청은 각각 ReadPendingException, WritePendinException 발생
            <li>지원하는 소켓 옵션 : SO_SNDBUF(전송 버퍼 크기), SO_RCVBUF(수신 버퍼 크기), SO_KEEPALIVE(기본 false, keep-alive 작동은 구현체에 의존적이다), TCP_NODELAY(Nagle 알고리즘 비활성)</li>
            <li>읽기/쓰기 시 양수의 타임아웃을 지정한 경우, 시간 내에 완료되지 못하면 InterruptedByTimeoutException으로 종료되고, 이후 상태는 비결정적이며, 따라서 사용된 채널, 버퍼들은 버리는 게 낫다</li>

            <li>static AsynchronousSocketChannel open(AsynchronousChannelGroup group) + 오버로딩</li>
            group이 지정되지 않거나 null인 경우, 시스템 기본 그룹이 이용된다
            <li>abstract AsynchronousSocketChannel shutdownInput()</li>
            채널을 더 이상 읽을 수 없게 한다. 이후의 읽기는 모두 -1을 반환한다. return this;
            <li>abstract AsynchronousSocketChannel shutdownOutput()</li>
            채널을 더 이상 쓸 수 없게 한다. 이후의 쓰기는 모두 ClosedChannelException ─ 읽기는 가능할 수 있다 ─ 으로 종료된다.
            <li>abstract &lt;A&gt; void connect(SocketAddress remote, A attachment, CompletionHandler&lt;Void, ? super A&gt; handler) + 오버로딩</li>
            <li>abstract &lt;A&gt; void read(ByteBuffer dst, long timeout, TimeUnit unit, A attachment, CompletionHandler&lt;Integer, ? super A&gt; handler) + 오버로딩</li>
            ScatteringByteChannel#read와 유사한 메서드도 지원한다
            <li>abstract &lt;A&gt; void write(ByteBuffer src, long timeout, TimeUnit unit, A attachment, CompletionHandler&lt;Integer, ? super A&gt; handler) + 오버로딩</li>
            GatheringByteChannel#write와 유사한 메서드도 지원한다
            <li>abstract SocketAddress getRemoteAddress() + getLocalAddress</li>
        </ol>
    </details>
</details>

<hr>

<details>
    <summary>채널 클래스</summary>
    <details>
        <summary>final class Channels Since 1.4</summary>
        <ol>
            <li>채널과 스트림에 관한 유틸리티 클래스.</li>
            <li>static InputStream newInputStream(ReadableByteChannel ch)</li>
            채널이 논-블로킹 모드면 읽기 시 예외 발생. 버퍼링, mark/reset 미지원. 스레드-안전. 닫으면 채널도 닫힌다
            <li>static OutputStream newOutputStream(WritableByteChannel ch)</li>
            채널이 논-블로킹 모드면 쓰기 시 예외 발생. 버퍼링 미지원. 스레드-안전. 닫으면 채널도 닫힌다
            <li>static InputStream newInputStream(AsynchronousByteChannel ch) Since 1.7</li>
            버퍼링, mark/reset 미지원. 스레드-안전. 닫으면 채널도 닫힌다
            <li>static OutputStream newOutputStream(AsynchronousByteChannel ch) Since 1.7</li>
            버퍼링 미지원. 스레드-안전. 닫으면 채널도 닫힌다
            <li>static ReadableByteChannel newChannel(InputStream in)</li>
            버퍼링 미지원. 닫으면 스트림도 닫힌다
            <li>static WritableByteChannel newChannel(OutputStream out)</li>
            버퍼링 미지원. 닫으면 스트림도 닫힌다
            <li>static Reader newReader(ReadableByteChannel ch, Charset charset) + 오버로딩</li>
            채널이 논-블로킹 모드면 읽기 시 예외 발생. 버퍼링 지원. mark/reset 미지원. 닫으면 채널도 닫힌다
            <li>static Writer newWriter(WritableByteChannel ch, Charset charset) + 오버로딩</li>
            채널이 논-블로킹 모드면 쓰기 시 예외 발생. 버퍼링 지원. 닫으면 채널도 닫힌다
        </ol>
    </details>

    <details>
        <summary>abstract class FileChannel extends AbstractInterruptibleChannel implements SeekableByteChannel, GatheringByteChannel, ScatteringByteChannel Since 1.4</summary>
        <ol>
            <li>static FileChannel open(Path path, Set&lt;? extends OpenOption&gt; options, FileAttribute&lt;?&gt;... attrs) Since 1.7 + 오버로딩</li>
            <li>abstract void force(boolean metaData)</li>
            메서드 호출 시점부터 true면 StandardOpenOption.SYNC를, false면 StandardOpenOption.DSYNC를 적용하는 것과 같다. 기저 파일이 로컬에 존재하는 경우에만 유효하다.
            <li>abstract long transferTo(long position, long count, WritableByteChannel target) + transferFrom</li>
            <li>abstract int read(ByteBuffer dst, long position) + write</li>
            <li>abstract MappedByteBuffer map(FileChannel.MapMode mode, long position, long size)</li>
            매핑 : 파일의 일부분을 메모리에 올려놓고 작업. 큰 파일은 이쪽이 효율이 좋다<br>
            READ_ONLY : 변경 불가, READ_WHITE : 변경이 기저 파일에 전파, PRIVATE : 변경이 전파되지 않음
            <li>abstract FileLock lock(long position, long size, boolean shared) + 오버로딩 + tryLock</li>
        </ol>
    </details>

    <details>
        <summary>abstract class ServerSocketChannel extends AbstractSelectableChannel implements NetworkChannel Since 1.4</summary>
        <ol>
            <li>스트림-지향 읽기 소켓 채널. AsynchronousServerSocketChannel 참고.</li>
            <li>static ServerSocketChannel open()</li>
            <li>final ServerSocketChannel bind(SocketAddress local) Since 1.7 + 오버로딩 + getLocalAddress</li>
            <li>abstract ServerSocket socket()</li>
            <li>abstract SocketChannel accept()</li>
        </ol>
    </details>

    <details>
        <summary>abstract class SocketChannel extends AbstractSelectableChannel implements ByteChannel, ScatteringByteChannel, GatheringByteChannel, NetworkChannel Since 1.4</summary>
        <ol>
            <li>스트림-지향 소켓 채널. AsynchronousSocketChannel 참고.</li>
            <li>static SocketChannel open() + 오버로딩</li>
            <li>abstract boolean connect(SocketAddress remote) + isConnected, isConnectionPending, getRemoteAddress</li>
            <li.abstract boolean finishConnect()
            <li>abstract SocketChannel shutdownInput() Since 1.7 + shutdownOutput</li>
            <li>abstract Socket socket()</li>
        </ol>
    </details>

    <details>
        <summary>abstract class DatagramChannel extends AbstractSelectableChannel implements ByteChannel, ScatteringByteChannel, GatheringByteChannel, MulticastChannel Since 1.4</summary>
        <ol>
            <li>데이터그램-지향 소켓 채널</li>
            <li>기존 데이터그램 소켓에서 채널을 얻는 방법은 없으며, open 팩터리 메서드로 획득해야 한다</li>
            <li>send/receive 메서드는 연결없이 사용할 수 있지만, read/write 메서드는 connect 메서드를 통해 연결해야 이용할 수 있다</li>
            연결된 경우, 송/수신에 불필요한 보안 체크를 하지 않는다
            <li>지원하는 소켓 옵션 : SO_SNDBUF, SO_RCVBUF, SO_REUSEADDR, SO_BROADCAST, IP_TOS, IP_MULTICAST_IF, IP_MULTICAST_TTL, IP_MULTICAST_LOOP</li>

            <li>static DatagramChannel open() + 오버로딩</li>
            IP 멀티캐스팅에 이용하려는 경우, 멀티캐스트 그룹 타입을 ProtocolFamily에 지정해줘야 한다
            <li>abstract DatagramSocket socket()</li>
            <li>abstract DatagramChannel connect(SocketAddress remote) + isConnected, disconnect, getRemoteAddress</li>
            <li>abstract SocketAddress receive(ByteBuffer dst)</li>
            <li>abstract int send(ByteBuffer src, SocketAddress target)</li>
        </ol>
    </details>

    <details>
        <summary>abstract class SelectableChannel extends AbstractInterruptibleChannel implements Channel Since 1.4</summary>
        <ol>
            <li>스레드-안전. Selector를 통해 멀티플렉싱될 수 있는 채널을 정의한다</li>
            <li>Selector에 등록함으로써 SelectionKey가 발행된다. 나가는 건 마음대로 할 수 없다.</li>
            채널이 닫히면 채널에 대한 모든 SelectionKey들은 cancel된다
            <li>각 Selector에는 최대 한 번씩만 등록할 수 있다. Selector가 닫히면 등록된 모든 채널이 내려가고, 각 키들은 즉시 무효하게 된다</li>
            <li>Non-blocking mode</li>
            새로 생성된 SelectableChannel은 블로킹 모드지만, configureBlocking(boolean) 메서드로 모드를 변경할 수 있다. 이 경우, Selector에 등록하기 전에 논-블로킹으로 설정해야 하며, 한 번 등록되면 등록 취소되기 전까지 논-블로킹 모드로 작동한다<br>
            논-블로킹 모드에서는 I/O 연산이 절대 블로킹되지 않지만, 요청보다 적은 데이터가 보내지거나 아예 전송되지 않을 수 있다.
        </ol>
        <details>
            <summary>Method Detail</summary>
            <ol>
                <li>abstract SelectorProvider provider()</li>
                이 채널을 생성한 provider를 반환한다
                <li>abstract int validOps()</li>
                <li>abstract SelectionKey register(Selector sel, int ops) + 오버로딩 + isRegistered</li>
                <li>abstract SelectionKey keyFor(Selector sel)</li>
                <li>abstract SelectableChannel configureBlocking(boolean block) + isBlocking</li>
                이미 어느 Selector에 등록된 채널이라면 논-블로킹 설정 시 IllegalBlockingModeException 발생
                <li>abstract Object blockingLock()</li>
                configureBlocking, register 메서드에서 동기화에 이용되는 객체를 반환한다
            </ol>
        </details>
    </details>
</details>

<hr>

<details>
    <summary>abstract class Pipe Since 1.4</summary>
    <ol>
        <li>2개 채널로 이루어진 단방향 파이프를 정의한다</li>
        SinkChannel : 쓰기 전용, SourceChannel : 읽기 전용
        <li>static Pipe open()</li>
        <li>abstract Pipe.SourceChannel source() + sink</li>
    </ol>
</details>

<hr>

<details>
    <summary>abstract class FileLock implements AutoCloseable Since 1.4</summary>
    <ol>
        <li>Adivisory Lock : 응용 프로그램이 잠금을 직접 확인하고, 알아서 읽기/쓰기를 수행할 지 결정한다.</li>
        <li>Mandatory Lock : 커널이 잠금을 관리하기 때문에, 관련되지 않은 프로세스는 접근 불가</li>
        모든 잠금을 Adivisory Lock으로 간주하여 관리함이 바람직하다
        <li>On some systems, 잠금의 존재로 인해 매핑(FileChannel#map)이 불가능할 수 있음에 유의</li>
        <li>On some systems, 채널을 닫으면 해당 파일에 대한 모든 잠금이 해제될 수 있음에 유의</li>
        <li>Some network filesystems, 잠금 영역 크기가 하드웨어 페이지 크기의 배수인 경우에만 매핑을 지원함에 유의</li>
        <li>Some network filesystems, 2^30 또는 2^31 이상 크기에 대한 잠금을 지원하지 않음에 유의</li>

        <li>final FileChannel channel()</li>
        <li>final Channel acquiredBy() Since 1.7</li>
        <li>final long position() + size, isShared, isValid</li>
        <li>final boolean overlaps(long position, long size)</li>
        <li>abstract void release() + close</li>
    </ol>
</details>

<hr>

<details>
    <summary>abstract class MembershipKey Since 1.7</summary>
    <ol>
        <li>IP 멀티캐스트 그룹에 대한 멤버십을 표현한다</li>

        <li>abstract boolean isValid()</li>
        <li>abstract void drop()</li>
        <li>abstract InetAddress group()</li>
        <li>abstract MulticastChannel channel()</li>
        이 멤버십 키를 생성한 채널을 반환한다.
        <li>abstract InetAddress sourceAddress()</li>
        특정 소스의 데이터그램만 수신하는 멤버십(Source-specific membership key)인 경우, 유효한 주소를 반환한다
        <li>abstract MembershipKey block(InetAddress source) + unblock</li>
        OS가 소스 필터링을 적용하지만, 적용되지 않은 멤버십에 대하여 이를 호출하면 특정 소스를 차단할 수 있다
        <li>abstract NetworkInterface networkInterface()</li>
    </ol>
</details>

<hr>

<details>
    <summary>abstract class Selector implements Closeable</summary>
    <ol>
        <li>SelectableChannel에 대한 멀티플렉서. 스레드-안전</li>
        <li>SelectableChannel을 등록하면 SelectionKey가 발행되며, 3가지 집합으로 관리된다</li>
        <ul>
            <li>Key set : 현재 등록된 채널들에 관한 키. SelectableChannel#register 메서드로 등록. Selector#keys 메서드로 획득.</li>
            <li>Selected-key set : 선택 연산에 의해, 최소 하나의 연산에 대해 ready 상태로 파악된 키. 자동 등록(수동 삭제만 가능). selectedKeys 메서드로 획득</li>
            <li>Cancelled-key set : 취소되었지만 채널은 아직 등록되어 있는 키</li>
        </ul>
        <li>선택 연산에는 2가지 종류가 있다</li>
        <ul>
            <li>select(), select(long), selectNow() : 지정된 연산에 대해 준비된 상태인지 확인하여 selected-key set 업데이트</li>
            <ol>
                <li>Cancelled-key set의 멤버들에 대해, 키 집합에서 제거하고 채널을 등록 취소한다. 결과적으로 cancelled-key set은 비게 된다.</li>
                아래 작업 중 Cacelled-key set에 추가된 키들에 대해서도 추가로 작업한다
                <li>Selected-key set에 없는 키에 대해, 키의 interest set의 연산 중 하나라도 준비되었다면 selected-key set으로 추가되고, 키의 ready set이 설정된다</li>
                <li>Selected-key set에 있는 키에 대해, 키의 ready set 외의 연산 중 준비된 것들은 ready set으로 추가된다</li>
            </ol>
            <li>select(Consumer), select(Consumer, long), selectNow(Consumer) : 준비된 채널들에 대해 작업 실행. selected-key set을 업데이트하지 않음</li>
            <ol>
                <li>Cancelled-key set의 멤버들에 대한 작업은 전과 같다</li>
                마찬가지로 아래 작업 중 Cacelled-key set에 추가된 키들에 대해서도 추가로 작업한다
                <li>키의 ready set이 최소 하나의 연산에 대해 준비되었다면, ready set은 준비된 연산들로만 설정되고, 주어진 Consumer가 키를 소비한다.</li>
                키의 ready set이 2개 이상의 연산에 대해 준비되었다면, Consumer는 여러 번 호출될 수 있다. Consumer를 호출하기 전에 ready set에서 해당 연산을 빼기 때문에, 한 번의 선택 연산에서 같은 연산에 대해 2번 호출되지 않는다.
            </ol>
        </ul>
        <li>선택 연산에서 사용되는 키의 interest set은 연산의 시작 시점의 것으로, 중간에 변경됐다면 다음 선택 연산에 적용된다</li>
        <li>키와 채널은 언제든 닫힐 수 있으므로, 사용 시 다른 스레드에서 키나 채널을 닫는지 유의해야 한다</li>
    </ol>
    <details>
        <summary>Method Detail</summary>
        <ol>
            <li>static Selector open() + isOpen</li>
            <li>abstract SelectorProvider provider()</li>
            <li>abstract Set&lt;SelectionKey&gt; keys() + selectedKeys</li>
            <li>abstract int selectNow()</li>
            논-블로킹으로 선택한다. 선택 연산으로 ready set이 업데이트된 키의 수를 반환한다. 이전 wakeup()의 영향을 제거한다
            <li>abstract int select(long timeout) + 오버로딩</li>
            블로킹으로 선택한다. timeout이 지정되지 않은 경우엔 무기한. 적어도 하나의 채널이 선택되면 반환한다.
            <li>int selectNow(Consumer&lt;SelectionKey&gt; action) Since 11</li>
            논-블로킹으로 키를 소비한다. 소비된 유니크한 키의 개수를 반환한다. 이전 wakeup()의 영향을 제거한다
            <li>int select(Consumer&lt;SelectionKey&gt; action, long timeout) Since 11 + 오버로딩</li>
            블로킹으로 키를 소비한다. 소비된 유니크한 키의 개수를 반환한다. 시간 초과 되거나, 적어도 하나의 채널이 선택되면 wakeup()으로 깨어난다
            <li>abstract Selector wakeup()</li>
            아직 반환하지 않은 선택 연산이 즉시 반환하도록 한다. 현재 실행 중인 선택 연산이 없다면 다음 선택 연산(selectNow 제외)에 대해 적용된다.
        </ol>
    </details>
</details>

<hr>

<details>
    <summary>abstract class SelectionKey Since 1.4</summary>
    <ol>
        <li>SelectableChannel이 Selector에 등록됨을 나타내는 토큰. 채널이나 Selector가 닫히면서 cancel 메서드로 닫히기 전까지 유효</li>
        <li>각 SelectionKey는 2가지 연산 집합을 갖는다. 각 집합은 int로 표현되고, 설정된 비트는 채널이 해당 연산을 지원함을 의미한다</li>
        <ul>
            <li>Interest set : Selector의 선택 연산에서 ready 상태인지 검사될 연산 집합. 최초 채널 등록 시 제공된 int값이며, interestOps(int)로 변경할 수 있다.</li>
            <li>Ready set : 키의 채널이 ready 상태인 연산들의 집합. 최초 생성 시 0이며, Selector의 선택 연산으로 변경된다. 직접 변경할 수는 없다.</li>
        </ul>
        <li>이 클래스에서 공통적인 지원 연산에 대해 정의하지만, 각 SelectableChannel의 서브 클래스에서 제공하는 validOps()가 정확하다</li>
    </ol>
    <details>
        <summary>Field Detail</summary>
        <ol>
            <li>static final int OP_READ</li>
            Selector의 선택 연산 시 interest set에 포함되어 있을 때. 채널이 읽기 가능하거나, end-of-stream에 도달했거나, 원격지에서 닫았거나, 에러 대기 상태면 ready set에 추가
            <li>static final int OP_WRITE</li>
            Selector의 선택 연산 시 interest set에 포함되어 있을 때. 채널이 쓰기 가능하거나, 원격지에서 닫았거나, 에러 대기 상태만 ready set에 추가
            <li>static final int OP_CONNECT</li>
            Selector의 선택 연산 시 interest set에 포함되어 있을 때, 채널이 연결 완료될 수 있거나, 에러 대기 상태면 ready set에 추가
            <li>static final int OP_ACCEPT</li>
            Selector의 선택 연산 시 interest set에 포함되어 있을 때. 서버 채널이 연결을 허용할 수 있거나, 에러 대기 상태면 ready set에 추가
        </ol>
    </details>
    <details>
        <summary>Method Detail</summary>
        <ol>
            <li>abstract SelectableChannel channel() : 연관 채널 반환</li>
            <li>abstract Selector selector() : 연관 Selector 반환</li>
            <li>abstract boolean isValid()</li>
            <li>abstract void cancel()</li>
            <li>abstract int interestOps() + setter 메서드</li>
            <li>public int interestOpsOr(int ops) Since 11 + interestOpsAnd</li>
            <li>abstract int readyOps()</li>
            <li>final boolean isReadable() + isWritable, isConnectable, isAcceptable</li>
            <li>final Object attach(Object ob) + getter 메서드</li>
        </ol>
    </details>
</details>

<hr>