<hr>

<details>
    <summary>Package Detail</summary>
    <ol>
        <li>자바 SCTP; Stream Control Transport Protocol 구현을 제공한다</li>
        <li>SCTP는 전송 계층 프로토콜로써, TCP처럼 연결-지향적이며, UDP처럼 메시지-지향적이다</li>
        <li>SCTP는 multi-homing을 지원한다 : 연결의 Primary 주소가 비가용 상태가 되더라도 Sub 주소를 통해 연결을 지속할 수 있다</li>
        <li>연결에서 데이터 교환은 논리적인 스트림들로 나뉘며, 각 스트림은 메시지들의 이동 경로가 된다. 스트림 내부적으로 메시지의 순서를 관리한다.</li>
        <li>One-to-one 스타일 구현체 : SctpServerChannel, SctpChannel</li>
        TCP와 유사한 인터페이스를 제공하며, 하나의 SCTP association만 관리한다
        <li>One-to-many 스타일 구현체 : SctpMultiChannel</li>
        UDP와 유사한 인터페이스를 제공하며, 여러 SCTP association을 관리할 수 있다.
    </ol>
</details>

<hr>

<details>
    <summary>class Association Since 1.7</summary>
    <ol>
        <li>Association은 두 SCTP 종단점 사이의 연결을 의미한다.</li>
        각 종단점은 전송 계층 주소의 리스트를 가지며, 따라서 Association은 두 주소의 카티션 곱만큼 존재할 수 있다
        <li>각 Association은 ID를 가지며, association이 유효한 동안 채널 안에서 유일하게 존재한다</li>
        <li>SCTP가 Dynamic Address Reconfiguration(RFC5061)을 구현한 경우, Association의 종단점 주소는 변경될 수 있다</li>
        <li>final int associationId() + maxInboundStreams, maxOutboundStreams</li>
    </ol>
</details>

<hr>

<details>
    <summary>Notification 연관</summary>
    <details>
        <summary>interface Notification Since 1.7</summary>
        Association association() : 관련 Association을 반환한다
    </details>
    <details>
        <summary>interface NotificationHandler&lt;T&gt; Since 1.7</summary>
        HandlerResult handleNotification(Notification notification, T attachment)
    </details>
    <details>
        <summary>enum HandlerResult Since 1.7</summary>
        CONTINUE : 다른 메시지나 알림을 대기, RETURN : 다른 데이터를 기다리지 말고 반환
    </details>
    <details>
        <summary>class AbstractNotificationHandler&lt;T&gt; implements NotificationHandler&lt;T&gt; Since 1.7</summary>
        <ol>
            <li>NotificationHandler 스켈레톤을 제공한다. handleNotification 메서드는 CONTINUE를 반환하도록 구현됐다</li>
            <li>HandlerResult handleNotification(AssociationChangeNotification notification, T attachment)</li>
            + PeerAddressChangeNotification, SendFailedNotification, ShutdownNotification
        </ol>
    </details>
    <details>
        <summary>abstract class AssociationChangeNotification implements Notification Since 1.7</summary>
        <details>
            <summary>static enum AssociationChangeNotification.AssocChangeEvent Since 1.7</summary>
            <ol>
                <li>COMM_UP : 새 association 준비 완료</li>
                <li>COMM_LOST : Association 실패. 이후 송신한 메시지만큼 실패 알림이 도착한다</li>
                <li>RESTART : 피어의 재시작을 감지</li>
                <li>SHUTDOWN : Association 정상 종료</li>
                <li>CANT_START : 새 association 수립 실패</li>
            </ol>
        </details>
        <ol>
            <li>abstract AssociationChangeNotification.AssocChangeEvent event()</li>
        </ol>
    </details>
    <details>
        <summary>abstract class PeerAddressChangeNotification implements Notification Since 1.7</summary>
        <details>
            <summary>static enum PeerAddressChangeNotification.AddressChangeEvent Since 1.7</summary>
            <ol>
                <li>ADDR_AVAILABLE : 주소가 도달 가능해졌음</li>
                <li>ADDR_UNREACHABLE : 주소에 도달 불가능해짐. 도달 가능해질 때까지 대체 주소로 reroute</li>
                <li>ADDR_REMOVED : 이 주소는 이제 association의 일부가 아님</li>
                <li>ADDR_ADDED : 이 주소는 이제 association의 일부임</li>
                <li>ADDR_MADE_PRIMARY : 이 주소는 이제 association의 primary 주소임</li>
                <li>ADDR_CONFIRMED : 이 주소는 유효하다고 확인됨</li>
            </ol>
        </details>
        <ol>
            <li>abstract SocketAddress address() : 피어 주소 반환</li>
            <li>abstract PeerAddressChangeNotification.AddressChangeEvent event()</li>
        </ol>
    </details>
    <details>
        <summary>abstract class SendFailedNotification implements Notification Since 1.7</summary>
        <ol>
            <li>abstract SocketAddress address() : 피어 primary 주소 반환</li>
            <li>abstract ByteBuffer buffer() : 보내려던 버퍼 반환</li>
            <li>abstract int errorCode() : SCTP 에러 코드(RFC2960 section 3.3.10)</li>
            <li>abstract int streamNumber() : 보내려던 스트림 번호</li>
        </ol>
    </details>
    <details>
        <summary>abstract class ShutdownNotification implements Notification Since 1.7</summary>
        피어가 SHUTDOWN한다고 알려왔을 때, 로컬 SCTP 스택으로부터 전달된다
    </details>
</details>

<hr>

<details>
    <summary>SCTP 소켓 옵션</summary>
    <details>
        <summary>interface SocketOption&lt;T&gt; extends SocketOption&lt;T&gt; Since 1.7</summary>
    </details>
    <details>
        <summary>class SctpStandardSocketOptions Since 1.7</summary>
        <details>
            <summary>static class SctpStandardSocketOptions.InitMaxStreams Since 1.7</summary>
            <ol>
                <li>Association 수립 협상에 사용되는 inbound/outbound 스트림 최대 개수를 정의한다</li>
                <li>static SctpStandardSocketOptions.InitMaxStreams create(int maxInStreams, int maxOutStreams)</li>
                <li>int maxInStreams() + maxOutStreams</li>
            </ol>
        </details>
        <ol>
            <li>static final SctpSocketOption&lt;Boolean&gt; SCTP_DISABLE_FRAGMENTS</li>
            메시지 파편화를 사용할 지 여부. 파편화를 사용하지 않으면 PMTU보다 큰 메시지의 송신에는 에러가 발생한다<br>
            PMTU : Path MTU : 경로 중 가장 작은 MTU값
            <li>static final SctpSocketOption&lt;Boolean&gt; SCTP_EXPLICIT_COMPLETE</li>
            메시지 종결을 명시적으로 할 지 여부. 사용하는 경우, 메시지의 마지막 송신은 MessageInfo::isComplete가 true를 반환해야 한다.
            기본값은 false며 이는 각 전송을 완결로 간주된다. 옵션의 지원 여부는 자바 구현체에 달렸다
            <li>static final SctpSocketOption&lt;Integer&gt; SCTP_FRAGMENT_INTERLEAVE</li>
            <ul>
                <li>메시지 파편의 조합 수준을 제어한다. 이 옵션의 지원 여부는 자바 구현체에 달렸다</li>
                <li>Level 0 : 스트림에서 메시지 파편을 받기 시작했다면, 해당 스트림에서는 해당 메시지의 파편만을 허용한다. 모든 파편이 도착할 때까지 블록한다</li>
                <li>Level 1 : Association 당 하나의 메시지 파편화를 허용한다. SctpChannel은 하나의 association만 가능하므로 Level 0와 동일하다.</li>
                <li>Level 2 : Association + 스트림 당 하나의 메시지 파편화를 허용한다. 즉, "association X 스트림 Y", "association X 스트림 Z"를 동시에 수신할 수 있다</li>
            </ul>
            <li>static final SctpSocketOption&lt;SctpStandardSocketOptions.InitMaxStreams&gt; SCTP_INIT_MAXSTREAMS</li>
            실제 협상 결과는 연관된 Association 객체로부터 알아낼 수 있다. Association 객체는 AssociationChangeEvent::COMM_UP 이벤트의 AssociationChangeNotification으로부터 얻을 수 있다.
            <li>static final SctpSocketOption&lt;Boolean&gt; SCTP_NODELAY</li>
            지연없이 송신할 지 여부. 기본적으로 SCTP는 TCP의 Nagle 알고리즘과 유사한 기법을 이용한다.
            <li>static final SctpSocketOption&lt;SocketAddress&gt; SCTP_PRIMARY_ADDR</li>
            로컬 SCTP 스택에서 association primary 피어 주소로 이용할 값을 지정한다.
            <li>static final SctpSocketOption&lt;SocketAddress&gt; </li>
            피어가 association primary 주소로 이용했으면 하는 값을 지정한다.
            <li>static final SctpSocketOption&lt;Integer&gt; SO_SNDBUF</li>
            SctpChannel에서 이 값은 한 번의 send로 보낼 수 있는 최대 크기가 된다. SctpMultiChannel에서도 같은 의미로 모든 association에 적용되고, 각 window size에 영향을 미친다.
            <li>static final SctpSocketOption&lt;Integer&gt; SO_RCVBUF</li>
            SctpChannel에서 이 값은 수신측 window size에 영향을 미친다. SctpMultiChannel에서 이 값은 각 association에 묶인 수신측 버퍼의 크기, 또는 전체 수신 버퍼의 크기에 영향을 미칠 수 있다
            <li>static final SctpSocketOption&lt;Integer&gt; SO_LINGER</li>
            초 단위의 linger interval : 소켓이 닫힐 때, 아직 못 보낸 데이터를 보내거나, 보낼 수 없다고 판단하기까지 대기하는 timeout<br>
            음수면 이 옵션을 사용하지 않으며, 기본값은 음수다. 최댓값은 시스템 종속적이며, 그보다 큰 값을 설정하면 시스템 최댓값이 설정된다.
        </ol>
    </details>
</details>

<hr>

<details>
    <summary>abstract class MessageInfo Since 1.7</summary>
    <ol>
        <li>메시지에 대한 부가 정보를 제공한다. 메시지 전송 시 createOutgoing 메서드를 이용해 부가 정보를 제공함이 바람직하다</li>
        <li>static MessageInfo createOutgoing(SocketAddress address, int streamNumber)</li>
        address : SctpChannel에서는 적절한 피어 주소, 또는 primary 주소를 의미하는 null. SctpMultiChannel에서는 association을 결정하기 위한 피어 주소이며, association이 없으면 하나 수립된다<br>
        streamNumber : 메시지를 보낼 스트림 번호
    </ol>
</details>