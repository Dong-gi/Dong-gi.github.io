<html lnag="ko"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="google-site-verification" content="aH-DyzdytYQ0NPHNQFcs5dVoiu5YNs6CEEHYgqDmAFM"><meta name="author" content="Donggi Kim &lt;hi.donggi@gmail.com&gt;"><meta name="keywords" content="com.sun.nio.sctp"><meta name="description" content="com.sun.nio.sctp 정리"><title>com.sun.nio.sctp</title><link id="w3css" rel="stylesheet" href="/source/w3.css"><link id="highlight-style" rel="stylesheet" href="/source/xcode.css"><link id="default-style" rel="stylesheet" href="/source/default.css"><script id="highlight-js" src="/source/highlight.pack.js"></script><script id="default-js" src="/source/default.min.js"></script><script id="dsq-count-scr" src="//donggi.disqus.com/count.js" async></script><script id="google-analytics" src="https://www.googletagmanager.com/gtag/js?id=UA-143098403-1" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-143098403-1');</script></head><body><div id="sidebar" class="w3-bar-block w3-sidebar w3-animate-left"><hr><a href="javascript:closeSidebar();" class="w3-bar-item w3-button">Close &times;</a><hr><div id="marker-list"></div><hr><div id="post-list"></div><hr><div id="file-list"></div><hr></div><div id="main"><div id="nav" style="position:-webkit-sticky;position:sticky;top:0px;vertical-align:middle" class="w3-bar w3-blue w3-large"><button onclick="toggleSidebar()" class="w3-bar-item w3-button w3-hover-theme">&#9776;</button><input id="query" type="text" placeholder="search" class="w3-bar-item"></div><div id="contents" class="w3-padding"><h1 class="marker">Package Detail</h1><ol><li>자바 SCTP; Stream Control Transport Protocol 구현을 제공한다</li><button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/nio/sctp/SctpChannelTest.java" lan="java">나중에 다시...</button><li>SCTP는 전송 계층 프로토콜로써, TCP처럼 연결-지향적이며, UDP처럼 메시지-지향적이다</li><li>SCTP는 multi-homing을 지원한다 : 연결의 Primary 주소가 비가용 상태가 되더라도 Sub 주소를 통해 연결을 지속할 수 있다</li><li>연결에서 데이터 교환은 논리적인 스트림들로 나뉘며, 각 스트림은 메시지들의 이동 경로가 된다. 스트림 내부적으로 메시지의 순서를 관리한다.</li><li>One-to-one 스타일 구현체 : SctpServerChannel, SctpChannel</li><p>TCP와 유사한 인터페이스를 제공하며, 하나의 SCTP association만 관리한다</p><li>One-to-many 스타일 구현체 : SctpMultiChannel</li><p>UDP와 유사한 인터페이스를 제공하며, 여러 SCTP association을 관리할 수 있다.</p></ol><h1 class="marker">class Association Since 1.7</h1><ol><li>Association은 두 SCTP 종단점 사이의 연결을 의미한다.</li><p>각 종단점은 전송 계층 주소의 리스트를 가지며, 따라서 Association은 두 주소의 카티션 곱만큼 존재할 수 있다</p><li>각 Association은 ID를 가지며, association이 유효한 동안 채널 안에서 유일하게 존재한다</li><li>SCTP가 Dynamic Address Reconfiguration(RFC5061)을 구현한 경우, Association의 종단점 주소는 변경될 수 있다</li><li>final int associationId() + maxInboundStreams, maxOutboundStreams</li></ol><h1 class="marker">Notification 연관</h1><div><h2 class="marker">interface Notification Since 1.7</h2><p><strong>↓ java</strong></p><div lan="java" class="as-code code-div w3-leftbar w3-border-green">Association association() // 관련 Association을 반환한다</div><h2 class="marker">interface NotificationHandler&lt;T> Since 1.7</h2><p><strong>↓ java</strong></p><div lan="java" class="as-code code-div w3-leftbar w3-border-green">HandlerResult handleNotification(Notification notification, T attachment)</div><h2 class="marker">enum HandlerResult Since 1.7</h2><p><strong>↓ java</strong></p><div lan="java" class="as-code code-div w3-leftbar w3-border-green">CONTINUE // 다른 메시지나 알림을 대기
RETURN   // 다른 데이터를 기다리지 말고 반환
</div><h2 class="marker">class AbstractNotificationHandler&lt;T> implements NotificationHandler&lt;T> Since 1.7</h2><p>NotificationHandler 스켈레톤을 제공한다. handleNotification 메서드는 CONTINUE를 반환하도록 구현됐다</p><h2 class="marker">abstract class AssociationChangeNotification implements Notification Since 1.7</h2><div><h3 class="marker">static enum AssociationChangeNotification.AssocChangeEvent Since 1.7</h3><p><strong>↓ java</strong></p><div lan="java" class="as-code code-div w3-leftbar w3-border-green">COMM_UP    // 새 association 준비 완료
COMM_LOST  // Association 실패. 이후 송신한 메시지만큼 실패 알림이 도착한다
RESTART    // 피어의 재시작을 감지
SHUTDOWN   // Association 정상 종료
CANT_START // 새 association 수립 실패
</div></div><h2 class="marker">abstract class PeerAddressChangeNotification implements Notification Since 1.7</h2><div><h3 class="marker">static enum PeerAddressChangeNotification.AddressChangeEvent Since 1.7</h3><p><strong>↓ java</strong></p><div lan="java" class="as-code code-div w3-leftbar w3-border-green">ADDR_AVAILABLE    // 주소가 도달 가능해졌음
ADDR_UNREACHABLE  // 주소에 도달 불가능해짐. 도달 가능해질 때까지 대체 주소로 reroute
ADDR_REMOVED      // 이 주소는 이제 association의 일부가 아님
ADDR_ADDED        // 이 주소는 이제 association의 일부임
ADDR_MADE_PRIMARY // 이 주소는 이제 association의 primary 주소임
ADDR_CONFIRMED    // 이 주소는 유효하다고 확인됨
</div></div><h2 class="marker">abstract class SendFailedNotification implements Notification Since 1.7</h2><p><strong>↓ java</strong></p><div lan="java" class="as-code code-div w3-leftbar w3-border-green">abstract SocketAddress address() // 피어 primary 주소 반환
abstract ByteBuffer buffer()     // 보내려던 버퍼 반환
abstract int errorCode()         // SCTP 에러 코드(RFC2960 section 3.3.10)
abstract int streamNumber()      // 보내려던 스트림 번호
</div><h2 class="marker">abstract class ShutdownNotification implements Notification Since 1.7</h2><p>피어가 SHUTDOWN한다고 알려왔을 때, 로컬 SCTP 스택으로부터 전달된다</p></div><h1 class="marker">SCTP 소켓 옵션</h1><div><h2 class="marker">interface SocketOption&lt;T> extends SocketOption&lt;T> Since 1.7</h2><h2 class="marker">class SctpStandardSocketOptions Since 1.7</h2><ol><li>static final SctpSocketOption&lt;Boolean> SCTP_DISABLE_FRAGMENTS</li><p>메시지 파편화를 사용할 지 여부. 파편화를 사용하지 않으면 PMTU보다 큰 메시지의 송신에는 에러가 발생한다<br>PMTU : Path MTU : 경로 중 가장 작은 MTU값</p><li>static final SctpSocketOption&lt;Boolean> SCTP_EXPLICIT_COMPLETE</li><p>메시지 종결을 명시적으로 할 지 여부. 사용하는 경우, 메시지의 마지막 송신은 MessageInfo#isComplete가 true를 반환해야 한다.
기본값은 false며 이는 각 전송을 완결로 간주된다. 옵션의 지원 여부는 자바 구현체에 달렸다</p><li>static final SctpSocketOption&lt;Integer> SCTP_FRAGMENT_INTERLEAVE</li><ul><li>메시지 파편의 조합 수준을 제어한다. 이 옵션의 지원 여부는 자바 구현체에 달렸다</li><li>Level 0 : 스트림에서 메시지 파편을 받기 시작했다면, 해당 스트림에서는 해당 메시지의 파편만을 허용한다. 모든 파편이 도착할 때까지 블록한다</li><li>Level 1 : Association 당 하나의 메시지 파편화를 허용한다. SctpChannel은 하나의 association만 가능하므로 Level 0와 동일하다.</li><li>Level 2 : Association + 스트림 당 하나의 메시지 파편화를 허용한다. 즉, "association X 스트림 Y", "association X 스트림 Z"를 동시에 수신할 수 있다</li></ul><li>static final SctpSocketOption&lt;SctpStandardSocketOptions.InitMaxStreams> SCTP_INIT_MAXSTREAMS</li><p>실제 협상 결과는 연관된 Association 객체로부터 알아낼 수 있다. Association 객체는 AssociationChangeEvent#COMM_UP 이벤트의 AssociationChangeNotification으로부터 얻을 수 있다.</p><li>static final SctpSocketOption&lt;Boolean> SCTP_NODELAY</li><p>지연없이 송신할 지 여부. 기본적으로 SCTP는 TCP의 Nagle 알고리즘과 유사한 기법을 이용한다.</p><li>static final SctpSocketOption&lt;SocketAddress> SCTP_PRIMARY_ADDR</li><p>로컬 SCTP 스택에서 association primary 피어 주소로 이용할 값을 지정한다.</p><li>static final SctpSocketOption&lt;SocketAddress> SCTP_SET_PEER_PRIMARY_ADDR</li><p>피어가 association primary 주소로 이용했으면 하는 값을 지정한다.</p><li>static final SctpSocketOption&lt;Integer> SO_SNDBUF</li><p>SctpChannel에서 이 값은 한 번의 send로 보낼 수 있는 최대 크기가 된다. SctpMultiChannel에서도 같은 의미로 모든 association에 적용되고, 각 window size에 영향을 미친다.</p><li>static final SctpSocketOption&lt;Integer> SO_RCVBUF</li><p>SctpChannel에서 이 값은 수신측 window size에 영향을 미친다. SctpMultiChannel에서 이 값은 각 association에 묶인 수신측 버퍼의 크기, 또는 전체 수신 버퍼의 크기에 영향을 미칠 수 있다</p><li>static final SctpSocketOption&lt;Integer> SO_LINGER</li><p>초 단위의 linger interval : 소켓이 닫힐 때, 아직 못 보낸 데이터를 보내거나, 보낼 수 없다고 판단하기까지 대기하는 timeout<br>음수면 이 옵션을 사용하지 않으며, 기본값은 음수다. 최댓값은 시스템 종속적이며, 그보다 큰 값을 설정하면 시스템 최댓값이 설정된다.</p></ol><div><h3 class="marker">static class SctpStandardSocketOptions.InitMaxStreams Since 1.7</h3><ol><li>Association 수립 협상에 사용되는 inbound/outbound 스트림 최대 개수를 정의한다</li><li>static SctpStandardSocketOptions.InitMaxStreams create(int maxInStreams, int maxOutStreams)</li><li>int maxInStreams() + maxOutStreams</li></ol></div></div><h1 class="marker">abstract class MessageInfo Since 1.7</h1><ol><li>메시지에 대한 부가 정보를 제공한다. 메시지 전송 시 createOutgoing 메서드를 이용해 부가 정보를 제공함이 바람직하다</li><li>static MessageInfo createOutgoing(SocketAddress address, int streamNumber)</li><p>streamNumber : 메시지를 보낼 스트림 번호<br>address : SctpChannel에서는 적절한 피어 주소, 또는 primary 주소를 의미하는 null. SctpMultiChannel에서는 association을 결정하기 위한 피어 주소이며, association이 없으면 하나 수립된다<br>초기화 : isUnordered() == true, timeToLive() == 0, isComplete() == true, payloadProtocolID() == 0</p><li>static MessageInfo createOutgoing(Association association, SocketAddress address, int streamNumber)</li><p>SctpMultiChannel에서 기존에 수립된 association에 대해 MessageInfo를 만들 때 사용한다</p><li>abstract SocketAddress address()</li><p>메시지를 받은 경우 : 송신 소켓 주소, 그 외의 경우 : 목적지 주소</p><li>abstract Association association()</li><p>메시지를 받은 경우 : 메시지가 전달된 association, 그 외의 경우 : 메시지를 보낼 association</p><li>abstract int bytes()</li><p>메시지를 받은 경우 : 읽은 메시지의 바이트 크기, 그 외의 경우 : 의미없음</p><li>abstract boolean isComplete() + setter 메서드</li><p>메시지의 종결 여부. SCTP_EXPLICIT_COMPLETE 옵션에 따라 작동이 달라진다</p><li>abstract boolean isUnordered() + setter 메서드</li><p>메시지가 순서적인지 여부.</p><li>abstract int payloadProtocolID() + setter 메서드</li><p>패킷 본문을 어떻게 처리할 지 여부. SCTP에서는 사용하지 않으며(= 0), 응용 계층에서 알아서 사용하면 된다</p><li>abstract int streamNumber() + setter 메서드</li><li>abstract long timeToLive() + setter 메서드</li></ol><h1 class="marker">채널 관련</h1><div><h2 class="marker">abstract class SctpServerChannel extends AbstractSelectableChannel Since 1.7</h2><ol><li>스레드-안전, 메시지-지향, 수신 SCTP 소켓 selectable 채널</li><li>지원하는 소켓 옵션 : SCTP_INIT_MAXSTREAMS</li><li>static SctpServerChannel open()</li><li>final SctpServerChannel bind(SocketAddress local, int backlog) + 오버로딩</li><p>backlog는 대기하는 association의 최대 개수로, 지정하지 않으면 0이 사용되고, 이는 기본값을 의미한다</p><li>abstract SctpServerChannel bindAddress(InetAddress address) + unbindAddress</li><p>이 채널의 소켓에 바인드 주소를 추가한다</p><li>abstract Set&lt;SocketAddress> getAllLocalAddresses()</li><p>바인드된 모든 주소를 반환한다</p><li>abstract &lt;T> getOption(SctpSocketOption&lt;T> name) + setOption</li><li>abstract Set&lt;SctpSocketOption&lt;?>> supportedOptions()</li><li>final int validOps() : SelectionKey.OP_ACCEPT</li></ol><h2 class="marker">abstract class SctpChannel extends AbstractSelectableChannel Since 1.7</h2><ol><li>스레드-안전. 메시지-지향 SCTP 소켓 selectable 채널</li><li>채널이 연결됐는지 여부는 getRemoteAddresses()로 확인할 수 있다</li><li>논-블로킹 모드로 동작할 수 있다. 연결하기 전에 AbstractSelectableChannel#configureBlocking으로 설정</li><p>논-블로킹 모드에서 connect 메서드로 연결을 시작하면 즉시 반환되며, 연결 대기 중인지는 isConnectionPending 메서드로, 완료됐는지는 finishConnect 메서드로 확인 가능</p><li>지원하는 소켓 옵션 : SCTP_DISABLE_FRAGMENTS, SCTP_EXPLICIT_COMPLETE, SCTP_FRAGMENT_INTERLEAVE, SCTP_INIT_MAXSTREAMS, SCTP_NODELAY, SCTP_PRIMARY_ADDR, SCTP_SET_PEER_PRIMARY_ADDR, SO_SNDBUF, SO_RCVBUF, SO_LINGER</li></ol><div><h3>Method Detail</h3><ol><li>static SctpChannel open(SocketAddress remote, int maxOutStreams, int maxInStreams) + 오버로딩</li><p>인자 없는 오버로딩 메서드는 단순히 채널을 열기만 하지만, 인자 있는 메서드는 열고 연결까지 진행한다</p><li>abstract SctpChannel bind(SocketAddress local) + bindAddress, unbindAddress, getAllLocalAddresses</li><p>SctpServerChannel의 설명과 동일</p><li>abstract boolean connect(SocketAddress remote, int maxOutStreams, int maxInStreams) + 오버로딩</li><p>maxOutStreams, maxInStreams 매개변수는 65536까지 가능하며, 지정되지 않거나 0이면 기본값을 사용한다. 다음의 긴 옵션 설정을 편리하게 대신해준다.</p><p>setOption(SctpStandardSocketOptions.SCTP_INIT_MAXSTREAMS, SctpStandardSocketOptions.InitMaxStreams.create(maxInStreams, maxOutStreams))</p><li>abstract boolean isConnectionPending()</li><li>abstract boolean finishConnect()</li><p>이미 연결에 실패했다면 예외 발생 + 채널 닫힘, 이미 연결됐다면 즉시 true 반환, 논-블로킹 모드에서 연결되지 않은 경우 즉시 false를 반환, 블로킹 모드에서 연결되지 않은 경우 연결되거나 실패하기까지 블록</p><li>abstract Set&lt;SocketAddress> getRemoteAddresses()</li><p>연결된 원격지의 주소들을 반환한다</p><li>abstract Association association()</li><li>abstract SctpChannel shutdown()</li><p>채널은 닫지 않고, 연결 종료만 한다. 종료 신호를 피어에게 전달하여 추가적인 쓰기를 방지한다</p><li>abstract &lt;T> T getOption(SctpSocketOption&lt;T> name) + setOption, supportedOptions</li><li>final int validOps() : SelectionKey.OP_CONNECT | SelectionKey.OP_READ | SelectionKey.OP_WRITE</li><li>abstract &lt;T> MessageInfo receive(ByteBuffer dst, T attachment, NotificationHandler&lt;T7gt; handler)</li><p>논-블로킹 모드에서는 메시지나 알림이 아직 가용상태가 아니라면 즉시 null이 반환된다<br>dst에 공간이 부족하거나, 기저 input 버퍼가 완결된 메시지를 갖고 있지 않다면 반환된 MessageInfo의 isComplete 메서드는 false를 반환한다. 이 상태에서 이 메서드를 한 번 더 호출하면 메시지를 완전히 소비한다.<br>임의 스트림에서 단 하나의 메시지만 파편화되어 전달될 수 있다. 이를 변경하려면 SCTP_FRAGMENT_INTERLEAVE를 변경해야 한다<br>알림을 받고 적절한 핸들러 메서드가 존재하면 호출된다. 해당 메서드가 CONTINUE를 반환하면 이 메서드에서 계속하여 다른 메시지나 알림을 받는다. 핸들러 메서드가 RETURN을 반환하면 이 메서드는 null을 반환한다. 핸들러의 처리되지 않은 예외는 계속하여 전달된다.<br>이 메서드는 임의 시점에 호출될 수 있다. 다른 스레드가 이미 받기를 시작했다면 해당 연산이 종료되기까지 블록된다</p><li>abstract int send(ByteBuffer src, MessageInfo messageInfo)</li><p>기저 output 버퍼에 충분한 공간이 있다면 src는 하나의 메시지로 전송된다. SCTP_EXPLICIT_COMPLETE 옵션이 켜 있지 않다면, 메시지의 전송은 원자적이다.<br>메시지는 messageInfo.streamNumber()로 정의된 스트림 번호로 전송된다. 이 메서드는 임의 시점에 호출될 수 있다. 다른 스레드가 이미 전송을 시작했다면 해당 연산이 종료되기까지 블록된다<br>논-블로킹 모드면서 기저 output 버퍼에 충분한 공간이 없다면 0이 반환된다.</p></ol></div><h2 class="marker">abstract class SctpMultiChannel extends AbstractSelectableChannel Since 1.7</h2><ol><li>스레드-안전, 메시지-지향 SCTP 소켓 Selectable 채널</li><li>바인드되지 않은 채널에 대해 send 메서드를 호출하면 먼저 bind 메서드가 호출된다. 이때 묶이는 주소는 getAllLocalAddresses()의 반환값 중 하나다</li><li>피어에 대해 association을 명시하지 않아도 send, receive가 작동한다. 없으면 알아서 구축한다</li><li>새로운 association이 구축될 때마다 AssociationChangeEvent.COMM_UP AssociationChangeNotification을 받는다</li><li>지원하는 소켓 옵션 : SCTP_DISABLE_FRAGMENTS, SCTP_EXPLICIT_COMPLETE, SCTP_FRAGMENT_INTERLEAVE, SCTP_INIT_MAXSTREAMS, SCTP_NODELAY, SCTP_PRIMARY_ADDR, SCTP_SET_PEER_PRIMARY_ADDR, SO_SNDBUF, SO_RCVBUF, SO_LINGER</li></ol><div><h3>Method Detail</h3><ol><li>static SctpMultiChannel open()</li><li>abstract Set&lt;Association> associations()</li><li>abstract SctpMultiChannel bind(SocketAddress local, int backlog) + 오버로딩 + bindAddress, unbindAddress, getAllLocalAddresses</li><p>SctpServerChannel 설명과 동일</p><li>abstract Set&lt;SocketAddress> getRemoteAddresses(Association association)</li><p>연결된 소켓의 바인드된 주소들을 반환한다. 소켓은 주어진 association으로 식별된다</p><li>abstract SctpMultiChannel shutdown(Association association)</li><p>채널은 닫지 않고 association을 종료한다</p><li>abstract &lt;T> T getOption(SctpSocketOption&lt;T> name, Association association) + setOption, supportedOptions</li><p>채널 레벨 설정은 association 매개변수를 무시한다</p><li>final int validOps() : SelectionKey.OP_READ | SelectionKey.OP_WRITE</li><li>abstract &lt;T> MessageInfo receive(ByteBuffer buffer, T attachment, NotificationHandler&lt;T> handler)</li><p>SctpChannel 설명과 동일</p><li>abstract int send(ByteBuffer buffer, MessageInfo messageInfo)</li><p>채널이 바인드되지 않았다면 먼저 bind(null, 0)을 호출. 피어와 수립된 association이 없으면 자동으로 하나 수립. 새로운 association이 수립되면 AssociationChangeEvent.COMM_UP AssociationChangeNotification 알림이 도착한다<br>기저 output 버퍼에 충분한 공간이 있다면 하나의 메시지로 전송된다. SCTP_EXPLICIT_COMPLETE 옵션이 없다면 전송은 원자적이다<br>논-블로킹 모드에서 어떤 이유로든 메시지 전송에 실패했다면 AssociationChangeEvent.CANT_START AssociationChangeNotification을 받는다</p><li>abstract SctpChannel branch(Association association)</li><p>특정 association을 전담하는 SctpChannel을 반환한다. 이 association은 더 이상 SctpMultiChannel에서 관리하지 않는다.</p></ol></div></div></div><hr>&copy; 2020. <a href="mailto:hi.donggi@gmail.com">Donggi Kim</a> all rights reserved.<a class="w3-btn w3-round w3-round-xxlarge w3-small w3-green" href="/LICENSE" target="_blank">LICENSE</a></div></body></html>