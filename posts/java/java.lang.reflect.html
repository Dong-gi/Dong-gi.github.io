<hr>

<details>
    <summary>자바 제네릭의 제약사항</summary>
    자바의 제네릭은 컴파일 과정에서 모두 Object 또는 바운드된 클래스로 교체된다.<br>
    → 따라서 List&lt;T&gt;에 대하여 실제로 런타임에서 T가 어떤 타입인지 직접 알아내는 방법은 없다.<br>
    → 따라서 제네릭 타입에 대한 직접적인 연산은 모두 무효하다.
</details>

<hr>

<details>
    <summary>interface Type Since 1.5</summary>
    1. 모든 타입의 공통 superinterface.<br>
    2. default String getTypeName() Since 1.8    
</details>

<hr>

<details>
    <summary>interface GenericArrayType extends Type Since 1.5</summary>
    1. 원소 타입이 parameterized type 또는 type 변수인 배열 타입을 표현.<br>
    2. Type getGenericComponentType() : 이 배열의 원소 타입을 Type 객체로 반환.
</details>

<hr>

<details>
    <summary>interface ParameterizedType extends Type Since 1.5</summary>
    <ol>
        <li>Collection&lt;String&gt;처럼 파라미터화된 타입을 표현.</li>
        <li>Type[] getActualTypeArguments() Since 1.5</li>
        <li>Type getRawType() Since 1.5</li>
        <li>Type getOwnerType() Since 1.5 : 예를 들어 이 타입이 O&lt;T&gt;.I&lt;S&gt;면, O&lt;T&gt;를 반환한다.</li>
    </ol>
</details>

<hr>

<details>
    <summary>interface WildcardType extends Type Since 1.5</summary>
    <ol>
        <li>?, ? extends Number, ? super Integer와 같은 와일드카드 타입을 표현.</li>
        <li>Type[] getUpperBounds()</li>
        <li>Type[] getLowerBounds()</li>
    </ol>
</details>

<hr>

<details>
    <summary>interface AnnotatedElement Since 1.5</summary>
    <ol>
        <li>default boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) Since 1.5</li>
        <li>&lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass) Since 1.5</li>
        <li>Annotation[] getAnnotations() Since 1.5</li>
        <li>default &lt;T extends Annotation&gt; T[] getAnnotationsByType(Class&lt;T&gt; annotationClass) Since 1.8</li>
        <li>default &lt;T extends Annotation&gt; T getDeclaredAnnotation(Class&lt;T&gt; annotationClass) Since 1.8</li>
        <li>default &lt;T extends Annotatino&gt; T[] getDeclaredAnnotationsByType(Class&lt;T&gt; annotationClass) Since 1.8</li>
        <li>Annotation[] getDeclaredAnnotations() Since 1.5</li>
    </ol>
</details>

<hr>

<details>
    <summary>interface AnnotatedType extends AnnotatedElement Since 1.8</summary>
    <ol>
        <li>default AnnotatedType getAnnotatedOwnerType() Since 9</li>
        이 타입이 멤버로 속해있는, 어노테이트된 타입 반환. 예를 들어 이 타입이 @TA O&lt;T&gt;.I&lt;S&gt;라면, @TA O&lt;T&gt;를 반환.<br>
        null : 이 타입이 top-level이거나 local 클래스, 익명 클래스, 기본 자료형, void인 경우. 이 타입이 AnnotatedArrayType, AnnotatedTypeVariable, AnnotatedWildcardType의 인스턴스인 경우.
        <li>Type getType() : 이 어노테이트된 타입의 기저 타입</li>
    </ol>
</details>

<hr>

<details>
    <summary>interface AnnotatedArrayType extends AnnotatedType Since 1.8</summary>
    1. 원소가 애너테이트된 배열을 표현.<br>
    2. AnnotatedType getAnnotatedGenericComponentType() : 이 배열의 애너테이트된 제네릭 타입 반환
</details>

<hr>

<details>
    <summary>interface AnnotatedParameterizedType extends AnnotatedType Since 1.8</summary>
    1. 타입 인자들이 애너테이트된 parameterized type을 표현.<br>
    2. AnnotatedType[] getAnnotatedActualTypeArguments()
</details>

<hr>

<details>
    <summary>interface TypeVariable&lt;D extends GenericDeclaration&gt; extends Type, AnnotatedElement Since 1.5</summary>
    <ol>
        <li>타입 변수에 관한 공통 superinterface.</li>
        <li>Type[] getBounds()</li>
        <li>D getGenericDeclaration() Since 1.5</li>
        <li>String getName()</li>
        <li>AnnotatedType[] getAnnotatedBounds() Since 1.8</li>
    </ol>
</details>

<hr>

<details>
    <summary>interface GenericDeclaration extends AnnotatedElement Since 1.5</summary>
    1. 모든 타입 변수 정의들에 대한 공통 인터페이스.<br>
    https://www.programcreek.com/java-api-examples/?api=java.lang.reflect.GenericDeclaration<br>
    2. TypeVariable&lt;?&gt;[] getTypeParameters()
</details>

<hr>

<details>
    <summary>interface AnnotatedTypeVariable extends AnnotatedType Since 1.8</summary>
    1. 애너테이트된 바운드를 가진 타입 변수를 표현.<br>
    2. AnnotatedType[] getAnnotatedBounds()
</details>

<hr>

<details>
    <summary>interface AnnotatedWildcardType extends AnnotatedType Since 1.8</summary>
    <ol>
        <li>애너테이트된 upper 또는 lower 바운드들에 대한 와일드카드 타입을 표현</li>
        <li>AnnotatedType[] getAnnotatedLowerBounds()</li>
        <li>AnnotatedType[] getAnnotatedUpperBounds()</li>
    </ol>
</details>

<hr>

<details>
    <summary>interface Member Since 1.1</summary>
    <ol>
        <li>하나의 멤버(필드나 메서드) 또는 생성자를 가리킨다.</li>
        <li>static final int PUBLIC</li>
        <li>static final int DECLARED : 상속 받은 것 미포함</li>
        <li>Class&lt;?&gt; getDeclaringClass()</li>
        <li>String getName()</li>
        <li>int getModifiers()</li>
        <li>boolean isSynthetic() Since 1.5 : 컴파일러에 의해 만들어진 멤버인지 여부</li>
    </ol>
</details>

<hr>

<details>
    <summary>interface InvocationHandler Since 1.3</summary>
    1. Proxy 인스턴스의 invocation handler에서 구현하는 인터페이스.<br>
    2. Object invoke(Object proxy, Method method, Object[] args)
</details>

<hr>

<details>
    <summary>class AccessibleObject implements AnnotatedElement Since 1.2</summary>
    <ol>
        <li>Field, Method, Constructor의 base 클래스. 리플렉트된 객체를 사용하기 전에 suppressing check 표시한다.</li>
        <li>static void setAccessible(AccessibleObject[] array, boolean flag)</li>
        배열의 각 원소들을 setAccessible(boolean)으로 설정할 수 있을 때, 한번에 하기 위한 메서드
        <li>void setAccessible(boolean flag)</li>
        <li>final boolean trySetAccessible() Since 9</li>
        아마도 변경되었을 accessible flag 값을 반환한다. 실패할 경우 예외를 발생하지 않고 false를 반환.
        <li>final boolean canAccess(Object obj) Since 9</li>
    </ol>
</details>

<hr>

<details>
    <summary>final class Field extends AccessibleObject implements Member Since 1.1</summary>
    <ol>
        <li>boolean isEnumConstant() Since 1.5</li>
        <li>boolean isSynthetic() Since 1.5</li>
        <li>Class&lt;?&gt; getType()</li>
        <li>Type getGenericType() Since 1.5</li>
        <li>String toGenericString() Since 1.5</li>
        <li>Object get(Object obj)</li>
        <li>boolean getBoolean(Object obj)</li>
        <li>byte getByte(Object obj)</li>
        <li>char getChar(Object obj)</li>
        <li>short getShort(Object obj)</li>
        <li>int getInt(Object obj)</li>
        <li>long getLong(Object obj)</li>
        <li>float getFloat(Object obj)</li>
        <li>double getDouble(Object obj)</li>
        <li>void set(Object obj, Object value)</li>
        <li>void setBoolean(Object obj, boolean z)</li>
        <li>void setByte(Object obj, byte b)</li>
        <li>void setChar(Object obj, char c)</li>
        <li>void setShort(Object obj, short s)</li>
        <li>void setInt(Object obj, int i)</li>
        <li>void setLong(Object obj, long l)</li>
        <li>void setFloat(Object obj, float f)</li>
        <li>void setDouble(Object obj, double d)</li>
        <li>AnnotatedType getAnnotatedType() Since 1.8</li>
    </ol>
</details>

<hr>

<details>
    <summary>abstract class Executable extends AccessibleObject implements Member, GenericDeclaration Since 1.8</summary>
    <ol>
        <li>Method, Constructor의 공통 기능</li>
        <li>abstract Class&lt;?&gt;[] getParameterTypes()</li>
        <li>int getParameterCount()</li>
        <li>Type[] getGenericParameterTypes()</li>
        <li>Parameter[] getParameters()</li>
        <li>abstract Class&lt;?&gt;[] getExceptionTypes()</li>
        <li>Type[] getGenericExceptionTypes()</li>
        <li>abstract Annotation[][] getParameterAnnotations()</li>
        <li>abstract AnnotatedType getAnnotatedReturnType()</li>
        <li>AnnotatedType getAnnotatedReceiverType()</li>
        <li>AnnotatedType[] getAnnotatedParameterTypes()</li>
        <li>AnnotatedType[] getAnnotatedExceptionTypes()</li>
        <li>abstract String toGenericString()</li>
        <li>boolean isVarArgs()</li>
        <li>boolean isSynthetic()</li>
    </ol>
</details>

<hr>

<details>
    <summary>final class Method extends Executable Since 1.1</summary>
    <ol>
        <li>Class&lt;&?&gt; getReturnType()</li>
        <li>Type getGenericReturnType() Since 1.5</li>
        <li>Object getDefaultValue() Since 1.5</li>
        <li>Object invoke(Object obj, Object... args)</li>
        <li>boolean isBridge()</li>
        <li>boolean isDefault() Since 1.8</li>
    </ol>
</details>

<hr>

<details>
    <summary>final class Constructor&lt;T&gt; extends Executable Since 1.1</summary>
    T newInstance(Object... initargs)
</details>

<hr>

<details>
    <summary>final class Parameter implements AnnotatedElement</summary>
    <ol>
        <li>메서드 인자에 관한 정보.</li>
        <li>boolean isNamePresent()</li>
        <li>boolean isImplicit()</li>
        <li>boolean isSynthetic()</li>
        <li>boolean isVarArgs()</li>
        <li>Executable getDeclaringExecutable()</li>
        <li>int getModifiers()</li>
        <li>String getName()</li>
        <li>Type getParameterizedType()</li>
        <li>Class&lt;?&gt; getType()</li>
        <li>AnnotatedType getAnnotatedType()</li>
    </ol>
</details>

<hr>

<details>
    <summary>final class Array Since 1.1</summary>
    <ol>
        <li>동적으로 자바 배열을 생성하고 접근하는 static 메서드들을 제공.</li>
        <li>static Object newInstance(Class&lt;?&gt; componentType, int length)</li>
        <li>static Object newInstance(Class&lt;?&gt; componentType, int... dimensions)</li>
        <li>static int getLength(Object array)</li>
        <li>static Object get(Object array, int index)</li>
        <li>static boolean getBoolean(Object array, int index)</li>
        <li>static byte getByte(Object array, int index)<br>
            ... static double getDouble(Object array, int index)</li>
        <li>static void set(Object array, int index, Object value)</li>
        <li>static void setBoolean(Object array, int index, boolean z)<br>
            ... static void setDouble(Object array, int index, double d)</li>
    </ol>
</details>

<hr>

<details>
    <summary>class Modifier Since 1.1</summary>
    <ol>
        <li>public static final int PUBLIC, PRIVATE, PROTECTED, STATIC, FINAL, SYNCHRONIZED, VOLATILE, TRANSIENT, NATIVE, INTERFACE, ABSTRACT, STRICT</li>
        <li>public Modifier()</li>
        <li>static boolean isPublic(int mod)<br>
            ... static boolean isStrict(int mod)</li>
        <li>static String toString(int mod)</li>
        <li>사용할 수 있는 제한자들을 OR하여 반환</li>
        <ul>
            <li>static int classModifiers() Since 1.7</li>
            <li>static int interfaceModifiers() Since 1.7</li>
            <li>static int constructorModifiers() Since 1.7</li>
            <li>static int methodModifiers() Since 1.7</li>
            <li>static int fieldModifiers() Since 1.7</li>
            <li>static int parameterModifiers() Since 1.8</li>
        </ul>
    </ol>
</details>

<hr>

<details>
    <summary>class Proxy implements Serializable Since 1.3</summary>
    <ol>
        <li>Proxy는 인터페이스 익명 객체처럼 행동하면서 사용자 정의 메서드를 호출할 수 있는 객체를 생성하는 static 메서드를 제공한다.</li>
        예. 인터페이스 Foo의 프록시 인스턴스 생성 : proxy instanceof Foo == true, (Foo) proxy : ok<br>
        InvocationHandler handler = new MyInvocationHandler(...);<br>
        Foo f = (Foo) Proxy.newProxyInstance(Foo.class.getClassLoader(), new Class&lt;?&gt;[] { Foo.class }, handler);
        <li>프록시 클래스 속성</li>
        "$Proxy"로 이름이 시작. final and non-abstract. java.lang.reflect.Proxy를 상속. 생성시 주어진 인터페이스들을 차례대로 구체화. ProtectionDomain은 bootstrap 클래스 로더가 로드한 시스템 클래스들과 동일.
        <li>protected InvocationHandler h</li>
        <li>protedtec Proxy(InvocationHandler h)</li>
        <li>static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</li>
        <li>static boolean isProxyClass(Class&lt;?&gt; cl)</li>
        <li>static InvocationHandler getInvocationHandler(Object proxy)</li>
    </ol>
</details>

<hr>