<div class="row">
    <div class="col-2">
        <img src="http://image.yes24.com/Goods/65551284/800x0" alt="책표지">
    </div>

    <div class="col-10">
        <table class="table">
            <tr>
                <th>표제/저자사항</th>
                <td>이펙티브 자바 / 조슈아 블로크
                </td>
            </tr>
            <tr>
                <th>ISBN 정보</th>
                <td>978-89-6626-116-1 [13000] 
                </td>
            </tr>
            <tr>
                <th>ISBN-A</th>
                <td>https://doi.org/10.978.896626/1161
                </td>
            </tr>
            <tr>
                <th>발행사항</th>
                <td>인사이트 , 발행일 : 20140828
                </td>
            </tr>
            <tr>
                <th>출판사 홈페이지</th>
                <td>http://blog.insightbook.co.kr/
                </td>
            </tr>
        </table>
    </div>
</div>

<hr>

<ol>
    <li>비트 필드 대신 EnumSet을 이용하자</li>
    
    <li>ordinal을 배열 인덱스로 이용하는 대신 enum을 키로 사용하는 EnumMap을 이용하자</li>
    
    <li>계산할 때는 래퍼 클래스 대신 기본 자료형을 이용하자</li>

    <li>객체를 참조할 때는 인터페이스를 사용하자</li>
    
    <li>호출자가 복구할 것으로 여겨지는 상황에서는 checked exception</li>

    <li>추상화 수준에 맞는 예외를 던져라</li>
    하위 계층에서 발생한 예외를 호출자에게 다시 보내야하는 경우, 해당 계층에 맞는 예외로 바꿔서 던져야 한다.

    <li>wait, notify, Thread 등을 이용하는 대신 java.util.concurrent 패키지 이용</li>
    컬렉션 외부에서 병행성을 처리하는 것은 불가능하다. 락을 걸어봐야 아무 효과가 없을 뿐 아니라 프로그램만 느려진다. java.util.concurrent 패키지에서 제공하는 컬렉션 이용

    <li>스레드 안전성 수준</li>
    <ol>
        <li>immutable : 이 클래스 인스턴스들은 상수기 때문에, 동기화 메커니즘이 필요없다</li>
        <li>unconditionally thread-safe : 적절한 내부 동기화 메커니즘을 갖추고 있어 외부에서 안전하게 사용할 수 있다.</li>
        <li>conditionally thread-safe : unconditionally thread-safe와 같지만 몇몇 스레드는 외부적인 동기화가 필요하다</li>
        <li>non thread-safe : 이 클래스 인스턴스들은 가변적이며, 외부적인 동기화가 필요하다</li>
        <li>thread-hostile : static 멤버를 변경시키며, 외부적인 동기화를 거쳐도 안전하지 않다.</li>
    </ol>

    <li>정적 필드 초기화 지연</li>
    static FieldType getField() { return FieldHolder.field; }<br>
    private static class FieldHolder {<br>
    　　static final FieldType field = computeFieldValue();<br>
    }

    <li>객체 필드 초기화 지연</li>
    private volatile FieldType field;<br>
    FieldType getField() {<br>
    　　FieldType result = field;<br>
    　　if (result == null) {<br>
    　　　　synchronized(this) {<br>
    　　　　　　result = field;<br>
    　　　　　　if (result == null)<br>
    　　　　　　　　field = result = computeFieldValue();<br>
    　　　　}<br>
    　　}<br>
    　　return result;<br>
    }

    <li>스레드는 필요한 일을 하고 있지 않을 때는 실행 중이어서는 안 된다</li>

    <li>ThreadGroup은 피하라. 대신 Thead pool executor를 이용하자</li>

    <li>Serializable 인터페이스 구현은 신중하게</li>
    릴리스하고 나면 구현을 바꾸기 어려워진다. 또, 직렬화된 바이트 스트림은 공격에 취약하므로 readObject 메서드를 방어적으로 구현해야 한다
</ol>