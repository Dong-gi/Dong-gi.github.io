<hr>

<details>
    <summary>interface Appendable Since 1.5</summary>
    <ol>
        <li>유니코드 CharSequence 또는 char 값을 덧붙일 수 있는 객체를 표현한다.</li>
        <li>Appendable append(CharSequence csq) + 2 오버로딩</li>
    </ol>
</details>

<hr>

<details>
    <summary>interface AutoCloseable Since 1.7</summary>
    자동으로 자원을 해제하는 객체를 표현한다. try-with-resources 블록에 사용되면 close()가 자동으로 호출된다. IO 작업이 없는 것들을 try-with-resources 블록에 이용하는 것은 불필요한 일이다.
    <button class="btn-code" path="Repositories/Eclipse/Basic/src/io/github/donggi/TryWithResources.java" lan="java">예시 코드 »</button>
</details>

<hr>

<details>
    <summary>interface Cloneable Since 1.0</summary>
    Object#clone()을 재정의했음을 나타내는 마커 인터페이스.
</details>

<hr>

<details>
    <summary>interface Comparable&lt;T&gt; Since 1.2</summary>
    <ol>
        <li>자연스러운 순서로 클래스의 모든 객체를 정렬할 수 있음을 표현.</li>
        <li>이를 구현한 클래스 객체들의 List, array는 Collections.sort, Arrays.sort로 각각 정렬할 수 있다.</li>
        <li>이를 구현한 클래스 객체들은 Comparator 정의 없이 SortedMap, SortedSet의 키로 이용할 수 있다.</li>
        <li>null은 객체가 아니므로 equals(null)이 false를 리턴하는 것과 달리 compareTo(null)은 NullPointerException을 내보내는 것이 바람직하다.</li>
        <li>다음 성질을 만족하도록 구현함이 권장된다. (e1.compareTo(e2) == 0) == e1.equals(e2)</li>
        <li>int compareTo(T o)</li>
        return this - o; // o보다 앞서면(작으면) 음수, 같으면 0, 뒤면(크면) 양수 반환.
    </ol>
</details>

<hr>

<details>
    <summary>interface Iterable&lt;T&gt; Since 1.5</summary>
    <ol>
        <li>이를 구현한 클래스 객체는 enhanced for statement의 순회 대상이 될 수 있다.
            <button class="btn-code" path="Repositories/Eclipse/JavaSE/src/lang/IterableExample.java" lan="java">예시 코드 »</button></li>

        <li>Iterator&lt;T&gt; iterator()</li>
        구현한 클래스 인스턴스를 반환하면 된다.

        <li>default void forEach(Consumer&lt;? super T&gt; action) Since 1.8</li>
        순회하면서 action을 적용한다. 기본 구현 : for(T t : this) action.accept(t);

        <li>default Spliterator&lt;T&gt; spliterator() Since 1.8</li>
        기본 구현은 Sliterator의 모든 사항을 구현하지 않으므로 재정의하는 것이 더 좋은 성능을 보인다.
    </ol>
</details>

<hr>

<details>
    <summary>interface ProcessHandle extends Comparable<ProcessHandle> Since 9</summary>
    <ol>
        <li>native process들에 대한 제어 제공. 프로세스 생애 모니터링, 자식 프로세스 나열, 프로세스 정보 얻기, 프로세스 종료 등.
            <button class="btn-code" path="Repositories/Eclipse/JavaSE/src/lang/ProcessHandleExample.java" lan="java">예시 코드 »</button></li>
        <li>프로세스 ID는 OS가 할당한 것으로, 값의 범위는 OS에 의존적이다.</li>
        <li>ProcessHandle 객체는 다음 팩터리 메서드로 반환된다.</li>
        current(), of(long), children(), descendants(), parent(), allProcesses()<br>
        parent() » zombie 상태의 프로세스는 보통 parent가 없다.
        <li>SecurityManager의 RuntimePermission("manageProcess")만큼의 제어 권한을 갖는다.</li>
        <li>ProcessHandle 객체들을 비교할 때는 equals, compareTo 메서드를 이용해야 한다.</li>
    </ol>
    <details>
        <summary>static interface ProcessHandle.Info Since 9</summary>
        <ul>
            <li>Optional&lt;String&gt; command()</li>
            실행가능한 경로 반환

            <li>Optional&lt;String&gt; commandLine()</li>
            command()와 arguments()의 결과를 공백으로 구분한 결과 반환

            <li>Optional&lt;String[]&gt; arguments()</li>
            프로세스의 인자 반환

            <li>Optional&lt;Instant&gt; startInstant()</li>
            프로세스의 시작 시각 반환

            <li>Optional&lt;Duration&gt; totalCpuDuration()</li>
            CPU 사용 시간 반환

            <li>Optional&lt;String&gt; user()</li>
            프로세스 유저 반환
        </ul>
    </details>
    <details>
        <summary>Method Detail</summary>
        <ol>
            <li>ProcessHandle.Info info()</li>
            <li>boolean supportsNormalTermination()</li>
            destroy() 메서드가 정상적으로 프로세스를 종료하는지 여부. false면 프로세스를 강제로 즉시 종료함을 의미.
            <li>CompletableFuture&lt;ProcessHandle&gt; onExit()</li>
            onExit().get()을 호출하면 프로세스가 종료되는 것을 기다린다. supportsNormalTermination()이 false일 경우 onExit()에 등록한 후처리들이 진행되지 않을 수 있음.
            <li>boolean destroy()</li>
            프로세스 종료에 시간이 걸릴 수 있으므로, isAlive()가 얼마간 true를 반환할 수 있다. 성공적으로 프로세스를 종료하면 true, 아니면 false를 반환한다.
            <li>boolean destroyForcibly() : 강제 종료</li>
            <li>long pid()</li>
            <li>boolean isAlive()</li>
            PID가 유효하면 alive로 간주
        </ol>
    </details>
</details>

<hr>

<details>
    <summary>interface Readable Since 1.5</summary>
    <ol>
        <li>Readable은 문자들에 대한 소스다.
            <button class="btn-code" path="Repositories/Eclipse/JavaSE/src/lang/ReadableExample.java" lan="java">예시 코드 »</button></li>

        <li>int read(CharBuffer cb)</li>
        문자들을 그대로 cb에 put()을 통해 저장한다. cb에 대한 어떠한 사전처리도 없다. 저장한 char 개수를 반환하며, 소스의 끝이면 -1을 반환한다.
    </ol>
</details>

<hr>

<details>
    <summary>@FunctionalInterface interface Runnable Since 1.0</summary>
    Runnable은 한 스레드로서 실행되도록 구현돼야 한다. Thread의 run()만을 재정의할 때 사용한다.<button class="btn-code" path="Repositories/Eclipse/JavaSE/src/lang/RunnableExample.java" lan="java">예시 코드 »</button>
</details>

<hr>

<details>
    <summary>class SecurityManager Since 1.0</summary>
    <ol>
        <li>보안 정책을 구현할 수 있는 클래스. 전형적인 확인 절차는 아래와 같다.</li>
        SecurityManager security = System.getSecurityManager();<br>
        if (security != null) {<br>
        　　security.checkXXX(argument, . . . );<br>
        }
        <li>Object getSecurityContext() : 현재 실행 환경을 캡슐화한 객체 반환.</li>
        <li>ThreadGroup getThreadGroup() Since 1.1 : 새로운 스레드를 생성할 수 있는 스레드그룹 반환</li>
        <li>void checkPermission(Permission perm) Since 1.2 + checkXXX()</li>
        <li>void checkPermission(Permission perm, Object context) Since 1.2</li>
    </ol>
</details>

<hr>

<details>
    <summary>final class Math Since 1.0, StrictMath Since 1.3</summary>
    <details open>
        <summary>Field Detail</summary>
        <ol>
            <li>static double E, PI</li>
        </ol>
    </details>
    <details open>
        <summary>Method Detail</summary>
        <ol>
            <li>삼각함수, 쌍곡선 함수, 라디안-육십분법 변환, 지수-로그, 제곱/3제곱/제곱근/3제곱근/pow</li>
            <li>static double IEEEremainder(double f1, double f2)</li>
            <li>ceil, floor, rint, round</li>
            rint : round to even이 이용된다.
            <li>static double random()</li>
            <li>abs, max, min, signum</li>
        </ol>
        <details>
            <summary>사칙연산</summary>
            <ul>
                <li>오버플로우되면 예외 : addExact, substractExact, multiplyExact, incrementExact, decrementExact, negateExact, toIntExact</li>
                <li>static long multiplyFull(int x, int y) Since 9<br>
                    static long multiplyHigh(long x, long y) Since 9 : 상위 64개 비트를 반환</li>
                <li>floorDiv(x, y)</li>
                floor(x/y)를 반환한다. Integer/Long.MIN_VALUE를 -1로 나누는 경우는 오버플로우가 발생하고 Integer/Long.MIN_VALUE를 반환한다.
                <li>floorMod(x, y)</li>
                x - (floorDiv(x, y) * y)를 반환한다. 부호는 y와 같다.
                <li>static double fma(double a, double b, double c) Since 9 // + float : a * b + c</li>
            </ul>
        </details>
    </details>
</details>

<hr>

<details>
    <summary>공유 변수 관련</summary>
    <details>
        <summary>abstract class ClassValue&lt;T&gt; Since 1.7</summary>
        <ol>
            <li>임의의 타입에 대하여, 필요할 때에 연산된 값을 가져오도록 지원. 해당 값은 해당 타입에 대해 일관성을 갖는다.</li>
            <li>protected abstract T computeValue(Class&lt;?&gt; type)</li>
            해당 type에 대하여, 최초 get 메서드 호출 시 한 번만 호출되며, 이후 remove 메서드 호출이 없으면 더 이상 불리지 않는다.
            <li>T get(Class&lt;?&gt; type)</li>
            값이 계산되지 않은 상태에서 여러 스레드들이 경합을 벌일 경우, 임의 스레드의 결과값을 모두에 반환한다.
            <li>void remove(Class&lt;?&gt; type)</li>
        </ol>
    </details>

    <details>
        <summary>class ThreadLocal&lt;T&gt; Since 1.2</summary>
        <ol>
            <li>스레드 단위의 지역 변수를 제공한다. 호출 지점과 관계없이 한 스레드 내부에서 변수를 공유한다.</li>
            <li>protected T initialValue()</li>
            초기값이 설정되지 않은 상태에서 최초 get() 호출에 의해 불린다. remove() 호출 후의 get() 요청으로 다시 불린다.
            <li>static &lt;S&gt; ThreadLocal&lt;S&gt; withInitial(Supplier&lt;? extends S&gt; supplier) Since 1.8</li>
            supplier로 초기값이 설정되는 ThreadLocal 반환.
            <li>T get()</li>
            <li>void set(T value)</li>
            <li>void remove() Since 1.5</li>
        </ol>
    </details>

    <details>
        <summary>class InheritableThreadLocal&lt;T&gt; extends ThreadLocal&lt;T&gt; Since 1.2</summary>
        <ol>
            <li>ThreadLocal에 상속성을 부여. 자식 스레드는 부모의 thread-local 변수들을 모두 상속받고 시작한다. childValue 메서드를 재정의함으로써 부모의 값과 다르게 설정할 수도 있다.</li>
            <li>protected T childValue(T parentValue)</li>
        </ol>
    </details>
</details>

<hr>

<details>
    <summary>타입 관련</summary>
    <details>
        <summary>interface CharSequence Since 1.4</summary>
        <ol>
            <li>일련의 char 값들을 표현한다. equals(), hashCode()에 대한 규약이 없어서 두 CharSequence 객체를 비교하는 결과는 정의되어 있지 않으며, 따라서 set이나 map의 키로 이용하기에 부적절하다.
                <button class="btn-code" path="Repositories/Eclipse/JavaSE/src/lang/CharSequenceExample.java" lan="java">예시 코드 »</button></li>
            <li>static int compare(CharSequence cs1, CharSequence cs2) Since 11</li>
            두 CharSequence를 사전순으로 비교한다.
            <li>int length()</li>
            길이. 16비트 char의 개수.
            <li>char charAt(int index)</li>
            <li>CharSequence subSequence(int start, end)</li>
            start부터 end-1까지. start == end일 경우 빈 CharSequence 객체가 반환된다.
            <li>String toString()</li>
            <li>default IntStream chars() Since 1.8</li>
            char들을 int로 0패딩하여 스트림 생성. 두 char로 쪼개진 유니코드 보충 평면의 문자를 하나로 합치진 않는다.
            <li>default IntStream codePoints() Since 1.8</li>
            유니코드 값들을 스트림으로 생성. 보충 평면의 문자는 Character.toCodePoint 메서드를 통해 하나의 int 값으로 형성.
        </ol>
    </details>

    <details>
        <summary>final class Boolean implements Serializable, Comparable&lt;Boolean&gt; Since 1.0</summary>
        <ol>
            <li>원시 타입 boolean의 wrapper 클래스</li>
            <li>static final Boolean FALSE</li>
            <li>static final Boolean TRUE</li>
            <li>static Class&lt;Boolean&gt; TYPE Since 1.1</li>
        </ol>
        <details>
            <summary>Method Detail</summary>
            <ol>
                <li>static boolean parseBoolean(String s) Since 1.5</li>
                s가 null이 아니고 대소문자 구분없이 "true"와 일치하면 true 반환.
                <li>boolean booleanValue()</li>
                <li>static Boolean valueOf(String s) : valueOf(parseBoolean(s))와 동일 + 1 오버로딩</li>
                <li>static String toString(boolean b) Since 1.4 : "true" or "false"</li>
                <li>int hashCode() : true면 1231, false면 1237</li>
                <li>static int hashCode(boolean value) Since 1.8</li>
                <li>static boolean getBoolean(String name)</li>
                name에 해당하는 system property가 존재하고, 대소문자 구분없이 "true"와 일치하면 true 반환
                <li>int compareTo(Boolean b) Since 1.5</li>
                TRUE.compareTo(FALSE) &gt; 0, FALSE.compareTo(TRUE) &lt; 0
                <li>static int compare(boolean x, boolean y) Since 1.7</li>
                <li>static boolean logicalAnd(boolean a, boolean b) Since 1.8 + or, xor</li>
            </ol>
        </details>
    </details>

    <details>
        <summary>abstract class Number implements Serializable Since 1.0</summary>
        <ol>
            <li>수에 관한 최상위 추상 wrapper 클래스</li>
            <li>abstract int intValue() + long, float, double</li>
            <li>byte byteValue() Since 1.1 : intValue()를 byte로 변환하여 반환</li>
            <li>short shortValue() Since 1.1 : intValue()를 short로 변환하여 반환</li>
        </ol>
    </details>

    <details>
        <summary>final class Byte extends Number implements Comparable&lt;Byte&gt; Since 1.1</summary>
        <ol>
            <li>기본 타입 byte에 대한 wrapper 클래스</li>
            <li>static final int BYTES Since 1.8 : 2의 보수 형태로 byte 값을 표현하기 위해 필요한 바이트 수</li>
            <li>static final byte MAX_VALUE : 2^7-1</li>
            <li>static final byte MIN_VALUE : -2^7</li>
            <li>static final int SIZE Since 1.5: 2의 보수 형태로 byte 값을 표현하기 위해 필요한 비트 수</li>
            <li>static final Class&lt;Byte&gt; TYPE</li>
        </ol>
        <details>
            <summary>Method Detail</summary>
            <ol>
                <li>static String toString(byte b) : 10진수 표현으로 반환</li>
                <li>static Byte valueOf(byte b) Since 1.5</li>
                <li>static byte parseByte(String s, int radix) + 1 오버로딩</li>
                예외 : s가 null이거나 길이가 0일 때. s에 radix진수가 아닌 문자가 포함될 때(단, s가 2글자 이상일 때 첫 '-', '+'는 가능). radix가 [Character.MIN_RADIX, Character.MAX_RADIX] 범위를 벗어날 때, 값이 byte를 벗어날 때.
                <li>static Byte valueOf(String s, int radix) + 1 오버로딩</li>
                <li>static Byte decode(String nm)</li>
                다음 문법으로 표현된 10진수, 16진수, 8진수를 parseByte()를 이용해 디코딩한다. 공백을 허용하지 않는다.
                <ul>
                    <li>(Sign?)(10진수)</li>
                    <li>(Sign?)(0x | 0X | #)(16진수)</li>
                    <li>(Sign?)0(8진수)</li>
                    <li>Sign: '-', '+'</li>
                </ul>
                <li>static int hashCode(byte value) Since 1.8</li>
                <li>int compareTo(Byte anotherByte) Since 1.2 : this - anotherByte</li>
                <li>static int compare(byte x, byte y) Since 1.7</li>
                <li>static int compareUnsigned(byte x, byte y) Since 9</li>
                <li>static int toUnsignedInt(byte x) Since 1.8</li>
                <li>static long toUnsignedLong(byte x) Since 1.8</li>
            </ol>
        </details>
    </details>

    <details>
        <summary>final class Character implements Serializable, Comparable&lt;Character&gt; Since 1.0</summary>
        <ol>
            <li>기본타입 char에 대한 wrapper 클래스. 추가적으로 문자 집합(소문자, 숫자 등) 정의, 변환 기능을 갖는다.</li>
            <li>유니코드 표준 8.0.0을 따른다.(JDK 9 기준)</li>
            <ul>
                <li>16비트 고정폭으로 값을 표현하며, 유효한 범위는 U+0000 부터 U+10FFFF까지(= Unicode scalar value).</li>
                <li>[U+0000, U+FFFF] == Basic Multilingual Plane(BMP), (U+FFFF, ~) == supplementary characters</li>
                <li>자바 플랫폼은 보충 평면의 문자들은 2개의 char의 쌍으로 표현한다.</li>
                <li>하위 21개 비트를 이용하여 int 하나로 모든 유니코드 code point를 표현할 수 있다.</li>
            </ul>
            <li>int를 받는 메서드는 모든 유니코드를 처리할 수 있지만, char만을 받는 메서드는 보충 평면 문자를 처리하지 못한다.</li>
            <button class="btn-code" path="Repositories/Eclipse/JavaSE/src/lang/CharacterExample.java" lan="java">예시 코드 »</button>
        </ol>
        <details>
            <summary>static class Character.Subset Since 1.2</summary>
            <ul>
                <li>이 클래스의 객체는 유니코드 문자 집합을 표현한다. Character 클래스 내부에서 정의한 문자 집합은 Character.UnicodeBlock뿐이다.</li>
                <li>final boolean equals(Object obj) : 오직 같은 객체일 때만 true를 반환함으로써 모든 부분집합들이 동일함을 보장한다.</li>
                <li>final int hashCode() : 기본 정의된 Object.hashCode()를 이용한다. final로 정의하여 equals()와 일관성을 유지한다.</li>
                <li>final String toString() : name 반환</li>
            </ul>
        </details>
        <details>
            <summary>static final class Character.UnicodeBlock extends Character.Subset Since 1.2</summary>
            <ul>
                <li>유니코드 문자 블록. 각 문자들은 최대 하나의 유니코드 블록에 포함된다.</li>
                <li>static Character.UnicodeBlock ARABIC, GREEK, HANGUL 등</li>
                <li>static Character.UnicodeBlock of(char c) : c가 속한 유니코드 블록 반환</li>
                <li>static Character.UnicodeBlock of(int codePoint) Since 1.5</li>
                <li>static final Character.UnicodeBlock forName(String blockName) Since 1.5</li>
                블록 이름이 변경될 경우, 변경 전/후 이름 둘 다 사용할 수 있다.
            </ul>
        </details>
        <details>
            <summary>static enum Character.UnicodeScript Since 1.7</summary>
            <ul>
                <li>유니코드 표준 스크립트 이름 정의를 표현. 모든 문자는 하나의 스크립트(각 언어|INHERITED|COMMON|UNKNOWN)에 할당된다.</li>
                <li>ARABIC, GREEK, HANGUL 등</li>
                <li>static Character.UnicodeScript valueOf(String name)</li>
                <li>static Character.UnicodeScript of(int codePoint)</li>
                <li>static final Character.UnicodeScript forName(String scriptName)</li>
            </ul>
        </details>
        <details>
            <summary>Field Detail</summary>
            <ol>
                <li>static final int MIN_RADIX : 문자열-숫자 간 변환을 지원하는 최소 radix</li>
                <li>static final int MAX_RADIX : 문자열-숫자 간 변환을 지원하는 최대 radix</li>
                <li>static final char MIN_VALUE Since 1.0.2 : '\u0000'</li>
                <li>static final char MAX_VALUE Since 1.0.2 : '\uFFFF'</li>
                <li>static final Class&lt;Character&gt; TYPE Since 1.1</li>
                <li>static final byte MODIFIER_LETTER, SPACE_SEPARATOR, MATH_SYMBOL 등</li>
                <li>static final char MIN_HIGH_SURROGATE Since 1.5 : '\uD800'</li>
                <li>static final char MAX_HIGH_SURROGATE Since 1.5 : '\uDBFF'</li>
                <li>static final char MIN_LOW_SURROGATE Since 1.5 : '\uDC00'</li>
                <li>static final char MAX_LOW_SURROGATE Since 1.5 : '\uDFFF'</li>
                <li>static final int MIN_SUPPLEMENTARY_CODE_POINT Since 1.5 : U+10000</li>
                <li>static final int MIN_CODE_POINT Since 1.5 : U+0000</li>
                <li>static final int MAX_CODE_POINT Since 1.5 : U+10FFFF</li>
                <li>static final int SIZE Since 1.5 : 표현에 필요한 비트 수, 16</li>
                <li>static final int BYTES Since 1.8 : 표현에 필요한 바이트 수</li>
            </ol>
        </details>
        <details>
            <summary>Method Detail</summary>
            <ol>
                <li>static Character valueOf(char c) Since 1.5</li>
                <li>char charValue()</li>
                <li>static int hashCode(char value) Since 1.8 == (int)value</li>
                <li>static String toString(int codePoint) Since 11 + 1 오버로딩</li>
                <li>static boolean isValidCodePoint(int codePoint) Since 1.5</li>
                + isBmpCodePoint, isSupplementaryCodePoint, isHighSurrogate, isLowSurrogate, isSurrogate, isSurrogatePair, isLowerCase, isUpperCase, isTitleCase
                <li>static boolean isDigit(char ch) + 1 오버로딩 : getType(ch) == DECIMAL_DIGIT_NUMBER</li>
                <ul>
                    <li>'\u0030' through '\u0039', ISO-LATIN-1 digits ('0' through '9')</li>
                    <li>'\u0660' through '\u0669', Arabic-Indic digits</li>
                    <li>'\u06F0' through '\u06F9', Extended Arabic-Indic digits</li>
                    <li>'\u0966' through '\u096F', Devanagari digits</li>
                    <li>'\uFF10' through '\uFF19', Fullwidth digits 등</li>
                </ul>
                <li>static boolean isDefined(int codePoint) Since 1.5 + 1 오버로딩 : 유니코드에 정의되었는지 여부</li>
                + isLetter(char ch) : getType(ch) == *_LETTER, isLetterOrDigit

                <li>static boolean isAlphabetic(int codePoint) Since 1.7</li>
                UPPERCASE_LETTER, LOWERCASE_LETTER, TITLECASE_LETTER, MODIFIER_LETTER, OTHER_LETTER, LETTER_NUMBER, 및 기타 알파벳 문자인지 여부
                <li>static boolean isIdeographic(int codePoint) Since 1.7 : CJKV(중국어, 일본어, 한국어, 베트남어) 여부</li>
                <li>static boolean isJavaIdentifierStart(char ch) Since 1.1 + 1 오버로딩 : 자바 식별자 선두문자</li>
                + isJavaIdentifierPart, isUnicodeIdentifierStart, isUnicodeIdentifierPart, isIdentifierIgnorable

                <li>static boolean isSpaceChar(char ch) Since 1.1 + 1 오버로딩 : getType(ch) == *_SEPARATOR</li>
                <li>static boolean isWhitespace(char ch) Since 1.1 + 1 오버로딩</li>
                공백 문자(단, non-breaking space('\u00A0', '\u2007', '\u202F') 제외), '\t', '\n', 'u000B', '\f', '\r', '\u001C', '\u001D', '\u001E', '\u001F'
                <li>static boolean isISOControl(char ch) Since 1.1 + 1 오버로딩</li>
                '\u0000' ~ '\u001F', '\u007F' ~ '\u009F'
                <li>static int charCount(int codePoint) Since 1.5 : 표현에 필요한 char 수(1 or 2)</li>
                <li>static int toCodePoint(char high, char low) Since 1.5</li>
                <li>static int codePointAt(CharSequence seq, int index) Since 1.5 + 2 오버로딩</li>
                + codePointBefore, highSurrogate, lowSurrogate
                <li>static char[] toChars(int codePoint) Since 1.5 + 1 오버로딩</li>
                <li>static int codePointCount(CharSequence seq, int beginIndex, int endIndex) Since 1.5 + 1 오버로딩</li>
                [beginIndex, endIndex) 사이의 유니코드 문자 수 반환
                <li>static int offsetByCodePoints(CharSequence seq, int index, int codePointOffset) Since 1.5 + 1 오버로딩</li>
                지정된 index로부터 offset 개수만큼 유니코드를 건너뛴 위치. +일 경우 index 포함, -인 경우 index 미포함(예시 코드 참고)
                <li>static int toLowerCase(int codePoint) Since 1.5 + 1 오버로딩 + toUpperCase, toTitleCase</li>
                isLowerCase(toLowerCase(x))가 항상 true는 아니다. String.toLowerCase()가 사용 언어에 따른 효과적인 변환을 수행한다.
                <li>static int digit(int codePoint, int radix) + 1 오버로딩: 예제 참조</li>
                <li>static int getNumericValue(char ch) Since 1.1</li>
                로마 숫자, a~z 등을 10진법 수로 반환한다. 음수일 경우 -2, 숫자가 아닐 경우 -1 반환.
                <li>static char forDigit(int digit, int radix)</li>
                <li>static int getNumericValue(int codePoint) Since 1.5</li>
                <li>static int getType(int codePoint) Since 1.5 + 1 오버로딩</li>
                <li>static byte getDirectionality(char ch) Since 1.4</li>
                문자 표시 순서를 반환한다. DIRECTIONALITY_UNDEFINED, DIRECTIONALITY_LEFT_TO_RIGHT 등
                <li>static byte getDirectionality(int codePoint) Since 1.5</li>
                <li>static boolean isMirrored(char ch) Since 1.4 + 1 오버로딩 : 좌우 대칭되는 문자가 존재하는지 여부</li>
                <li>static int compare(char x, char y) Since 1.7 : x - y</li>
                <li>static char reverseBytes(char ch) Since 1.5</li>
                <li>static String getName(int codePoint) Since 1.7</li>
                이름 반환 : Character.UnicodeBlock.of(codePoint).toString().replace('_', ' ') + " " + Integer.toHexString(codePoint).toUpperCase(Locale.ROOT);<br>
                정의되어 있지 않으면 null 반환
                <li>static int codePointOf(String name) Since 9 : 정의되어 있지 않으면 예외</li>
            </ol>
        </details>
    </details>

    <details>
        <summary>final class Double extends Number implements Comparable&lt;Double&gt;, Constable, ConstantDesc Since 1.0</summary>
        <details>
            <summary>Field Detail</summary>
            <ol>
                <li>public static final double POSITIVE_INFINITY : == Double.longBitsToDouble(0x7ff0000000000000L)</li>
                <li>public static final double NEGATIVE_INFINITY : == Double.longBitsToDouble(0xfff0000000000000L)</li>
                <li>public static final double NaN : == Double.longBitsToDouble(0x7ff8000000000000L)</li>
                <li>public static final double MAX_VALUE : == 0x1.fffffffffffffP+1023 == Double.longBitsToDouble(0x7fefffffffffffffL)</li>
                <li>public static final double MIN_NORMAL Since 1.6</li>
                진수가 1 이상인 가장 작은 양수 표현. == 0x1.0p-1022 == Double.longBitsToDouble(0x0010000000000000L)
                <li>public static final double MIN_VALUE</li>
                가장 작은 양수 표현 == 0x0.0000000000001P-1022 == Double.longBitsToDouble(0x1L)
                <li>public static final int MAX_EXPONENT Since 1.6 : == Math.getExponent(Double.MAX_VALUE)</li>
                <li>public static final int MIN_EXPONENT Since 1.6 : == Math.getExponent(Double.MIN_NORMAL)</li>
                <li>public static final int SIZE Since 1.5 : 표현에 필요한 비트 수</li>
                <li>public static final int BYTES Since 1.8 : 표현에 필요한 바이트 수</li>
                <li>public static final Class&lt;Double&gt; TYPE Since 1.1</li>
            </ol>
        </details>
        <details>
            <summary>Method Detail</summary>
            <ol>
                <li>static String toString(double d)</li>
                <li>static String toHexString(double d) Since 1.5</li>
                <li>static Double valueOf(String s) + 1 오버로딩 + parseDouble</li>
                <li>static boolean isNaN(double v) + isInfinite, isFinite + non-static methods</li>
                <li>static int hashCode(double value) Since 1.8 + non-static method</li>
                (int)(v^(v&gt;&gt;&gt;32)), v = Double.doubleToLongBits(this.doubleValue())
                <li>static long doubleToLongBits(double value)</li>
                double 표현 그대로 long으로 전환. 63번 비트는 부호, 62-52번 비트는 지수, 51-0번 비트는 진수
                <li>static long doubleToRawLongBits(double value) Since 1.3</li>
                NaN의 경우 각각의 NaN에 대응하는 값으로 반환.
                <li>static double longBitsToDouble(long bits)</li>
                range 0x7ff0000000000001L through 0x7fffffffffffffffL or in the range 0xfff0000000000001L through 0xffffffffffffffffL, the result is a NaN
                <li>int compareTo(Double anotherDouble) Since 1.2</li>
                Double.NaN은 Double.POSITIVE_INFINITY보다 크다고 간주, 0.0d는 -0.0d보다 크다고 간주
                <li>static int compare(double d1, double d2) Since 1.4</li>
                <li>static double sum(double a, double b) Since 1.8 + max, min</li>
            </ol>
        </details>
    </details>

    <details>
        <summary>final class Integer extends Number implements Comparable&lt;Integer&gt; Since 1.0</summary>
        <details>
            <summary>Field Detail</summary>
            <ol>
                <li>@Native public static final int MIN_VALUE : -2^31</li>
                <li>@Native public static final int MAX_VALUE : 2^31-1</li>
                <li>public static final Class&lt;Integer&gt; TYPE Since 1.1</li>
                <li>@Native public static final int SIZE Since 1.5 : 표현하는데 필요한 비트 수</li>
                <li>public static final int BYTES Since 1.8 : 표현하는데 필요한 바이트 수</li>
            </ol>
        </details>
        <details>
            <summary>Method Detail</summary>
            <ol>
                <li>static String toString(int i, int radix) + toUnsignedString, toBinaryString, toOctalString, toHexString</li>
                radix in [Character.MIN_RADIX, Character.MAX_RADIX]

                <li>static int parseInt(CharSequence s, int beginIndex, int endIndex, int radix) Since 9 + 2 오버로딩 + parseUnsignedInt, valueOf</li>
                [beginIndex, endIndex - 1]. 파싱 중 CharSequence 변경에 대한 조치를 하지 않음

                <li>static Integer decode(String nm)</li>
                문자열을 정수로 파싱하는 것은 parseInt와 같으나, nm의 포맷(접두 0x, 0X, 0, #...)에 따라 radix를 자동 조정한다.

                <li>static int sum(int a, int b) Since 1.8 + max, min</li>
            </ol>
            <details>
                <summary>System Property 관련</summary>
                <ol>
                    <li>static Integer getInteger(String nm, int val) + 2 오버로딩</li>
                    nm : property name, val : 기본값<br>
                    속성 값은 decode 메서드를 통해 변환된다
                </ol>
            </details>
            <details>
                <summary>unsigned 연산</summary>
                <ol>
                    <li>static int compareUnsigned(int x, int y) Since 1.8</li>
                    <li>static long toUnsignedLong(int x) Since 1.8</li>
                    <li>static int divideUnsigned(int dividend, int divisor) Since 1.8</li>
                    <li>static int remainderUnsigned(int dividend, int divisor) Since 1.8</li>
                </ol>
            </details>
            <details>
                <summary>bit 관련</summary>
                <ol>
                    <li>static int highestOneBit(int i) Since 1.5</li>
                    <li>static int lowestOneBit(int i) Since 1.5</li>
                    <li>static int numberOfLeadingZeros(int i) Since 1.5</li>
                    <li>static int numberOfTrailingZeros(int i) Since 1.5</li>
                    <li>static int bitCount(int i) Since 1.5</li>
                    <li>static int rotateLeft(int i, int distance) Since 1.5</li>
                    <li>static int rotateRight(int i, int distance) Since 1.5</li>
                    <li>static int reverse(int i) Since 1.5</li>
                    <li>static int reverseBytes(int i) Since 1.5 : 바이트 단위로 뒤집기</li>
                    <li>static int signum(int i) Since 1.5 : -1, 0, 1</li>
                </ol>
            </details>
        </details>
    </details>

    <details>
        <summary>final class String implements Serializable, Comparable&lt;String&gt;, CharSequence, Constable, ConstantDesc Since 1.0</summary>
        <ol>
            <li>유니코드 보충 평면 문자는 surrogate pairs로써 2자리를 차지한다.</li>
            <li>로캐일을 고려한 문자열 비교는 Collator 클래스를 이용.</li>
            <li>static final Comparator&lt;String&gt; CASE_INSENSITIVE_ORDER Since 1.2</li>
            대소문자 구분없는 비교자. 직렬화 가능.
        </ol>
        <details>
            <summary>Constructor Detail</summary>
            <ol>
                <li>public String()</li>
                <li>public String(String original)</li>
                <li>public String(char[] value) + 1 오버로딩</li>
                <li>public String(int[] codePoints, int offset, int count) Since 1.5</li>
                <li>public String(byte[] bytes, int offset, int length, Charset charset) Since 1.6 + 5 오버로딩</li>
                <li>public String(StringBuffer buffer)</li>
                <li>public String(StringBuilder builder) Since 1.5</li>
            </ol>
        </details>
        <details>
            <summary>Method Detail</summary>
            <ol>
                <li>boolean isEmpty() Since 1.6</li>
                <li>int codePointAt(int index) Since 1.5 + codePointBefore</li>
                <li>int codePointCount(int beginIndex, int endIndex)</li>
                <li>void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)</li>
                <li>byte[] getBytes(Charset charset) Since 1.6 + 2 오버로딩</li>
                지정되지 않은 경우, 플랫폼 기본 문자셋을 이용한다. 기본 문자셋을 변경하려면 JVM 옵션을 조정하면 된다.
                <li>boolean contentEquals(StringBuffer sb) Since 1.4 + 1 오버로딩</li>
                <li>boolean equalsIgnoreCase(String anotherString)</li>
                <li>int compareToIgnoreCase(String str) Since 1.2</li>
                <li>boolean regionMatches(int tooffset, String other, int ooffset, int len) + 1 오버로딩</li>
                부분 문자열이 일치하는지 여부 반환. t(his's)offset, o(ther's)offset</li>
                <li>boolean startsWith(String prefix, int toffset) + 1 오버로딩</li>
                <li>boolean endsWith(String suffix)</li>
                <li>int indexOf(int ch, int fromIndex) + 3 오버로딩 + lastIndexOf</li>
                <li>String substring(int beginIndex, int endIndex) + 1 오버로딩</li>
                <li>String concat(String str)</li>
                <li>String replace(char oldChar, char newChar)</li>
                <li>boolean matches(String regex) Since 1.4 == Pattern.matches(regex, str)</li>
                <li>boolean contains(CharSequence s) Since 1.5</li>
                <li>String replaceAll(String regex, String replacement) Since 1.4 + replaceFirst</li>
                <li>String replace(CharSequence target, CharSequence replacement) Since 1.5</li>
                <li>String[] split(String regex, int limit) Since 1.4</li>
                limit이 음수인 경우, 제한 없이 분리. 0인 경우 빈 문자열로 끝나지 않음.
                <li>String[] split(String regex) Since 1.4 : split(regex, 0)</li>
                <li>static String join(CharSequence delimiter, CharSequence... elements) Since 1.8 + 1 오버로딩</li>
                <li>String toLowerCase(Locale locale) Since 1.1 + 1 오버로딩 + toUpperCase</li>
                <li>String trim() : 시작과 끝의 공백(&lt;= U+0020) 제거</li>
                <li>String strip() Since 11 + stripLeading, stripTrailing : 공백 제거</li>
                <li>boolean isBlank() Since 11 : 비거나 공백 문자로만 이루어졌는지 여부</li>
                <li>Stream&lt;String&gt; lines() Since 11 : 줄 끝(\n, \r, \r\n) 기준으로 분리</li>
                <li>String indent(int n) Since 12</li>
                각 줄이 n개의 공백으로 시작하도록 조정하고, 줄 끝을 \n로 정규화한다. n이 음수인 경우, 최대 n개의 앞선 공백을 제거한다.
                <li>&lt;R&gt; R transform(Function&lt;? super String, ? extends R&gt; f) Since 12</li>
                <li>IntStream codePoints() Since 9 + chars</li>
                <li>char[] toCharArray()</li>
                <li>static String format(String format, Object... args) Since 1.5 + 1 오버로딩</li>
                <li>static String valueOf(Object obj) : obj.toString() + 8 오버로딩</li>
                <li>String intern() : 문자열 객체에 대한 내부 표현 반환</li>
                <li>String repeat(int count) Since 11</li>
            </ol>
        </details>
    </details>

    <details>
        <summary>final class StringBuffer implements Serializable, Comparable&lt;StringBuffer&gt;, CharSequence Since 1.0</summary>
        <ol>
            <li>스레드-안전한 변경 가능한 문자열.</li>
        </ol>
        <details>
            <summary>Constructor Detail</summary>
            <ol>
                <li>public StringBuffer()</li>
                <li>public StringBuffer(int capacity)</li>
                <li>public StringBuffer(String str)</li>
                <li>public StringBuffer(CharSequence seq) Since 1.5</li>
            </ol>
        </details>
        <details>
            <summary>Method Detail</summary>
            <ol>
                <li>void trimToSize() Since 1.5</li>
                버퍼 크기를 줄여 문자열 크기에 맞춘다
                <li>void setLength(int newLength)</li>
                새로운 크기의 문자열에 기존 문자열을 복사. 남는 부분은 '\u0000'(null)로 채워진다.
                <li>void ensureCapacity(int minimumCapacity)</li>
                <li>StringBuffer reverse() Since 1.0.2</li>

                <li>추가 / 삽입 » append, insert</li>
                <li>삭제 / 변경 » delete, set~, replace</li>
                <li>기타 String과 유사한 메서드 생략</li>
            </ol>
        </details>
    </details>

    <details>
        <summary>final class StringBuilder implements Serializable, Comparable&lt;StringBuilder&gt;, CharSequence Since 1.5</summary>
        StringBuffer의 비동기화 버전.
    </details>

    <details>
        <summary>abstract class Enum&lt;E extends Enum&lt;E&gt;&gt; implements Constable, Comparable&lt;E&gt;, Serializable Since 1.5</summary>
        <ol>
            <li>모든 공용체의 베이스. Enum을 집합이나 맵의 키로 이용하면 효율적인 구현을 얻을 수 있다.</li>
        </ol>
        <details>
            <summary>static final class Enum.EnumDesc&lt;E extends Enum&lt;E&gt;&gt; extends DynamicConstantDesc&lt;E&gt; Since 12</summary>
            static &lt;E extends Enum&lt;E&gt;&gt; Enum.EnumDesc&lt;E&gt; of(ClassDesc enumClass, String constantName) Since 12
        </details>
        <details>
            <summary>Method Detail</summary>
            <ol>
                <li>final String name()</li>
                <li>final int ordinal()</li>
                <li>final Class&lt;E&gt; getDeclaringClass()</li>
                <li>static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt; enumType, String name) Since 1.5</li>
            </ol>
        </details>
    </details>

    <details>
        <summary>class Throwable implements Serializable Since 1.0</summary>
        <ol>
            <li>모든 에러와 예외의 조상.</li>
        </ol>
        <details>
            <summary>Constructor Detail</summary>
            <ol>
                <li>public Throwable()</li>
                <li>public Throwable(String message)</li>
                <li>public Throwable(String message, Throwable cause) Since 1.4</li>
                <li>public Throwable(Throwable cause) Since 1.4</li>
                <li>protected Throwable(String message, THrowable cause, boolean enableSuppression, boolean writableStackTrace) Since 1.7</li>
            </ol>
        </details>
        <details>
            <summary>Method Detail</summary>
            <ol>
                <li>String getMessage() + getLocalizedMessage</li>
                <li>Throwable getCause() Since 1.4</li>
                <li>Throwable initCause(Throwable cause) Since 1.4</li>
                <li>void printStackTrace(PrintStream s) Since 1.1 + 1 오버로딩</li>
                <li>StackTraceElement[] getStackTrace() Since 1.4</li>
                <li>void setStackTrace(StackTraceElement[] stackTrace) Since 1.4</li>
                <li>final void addSuppressed(Throwable exception) Since 1.7</li>
                <li>final Throwable[] getSuppressed() Since 1.7</li>
            </ol>
        </details>
    </details>
</details>

<hr>

<details>
    <summary>클래스 관련</summary>
    <details>
        <summary>final class Class&lt;T&gt; implements Serializable, GenericDeclaration, Type, AnnotatedElement, TypeDescriptor.OfField&lt;Class&lt;?&gt;&gt;, Constable Since 1.0</summary>
        <details>
            <summary>Method Detail</summary>
            <ol>
                <li>ClassLoader getClassLoader()</li>
                <li>InputStream getResourceAsStream(String name) Since 1.1 // ClassLoader 관련</li>
                <li>URL getResource(String name) Since 1.1</li>
                <li>T cast(Object obj) Since 1.5 » obj를 호출한 Class 객체와 같은 타입으로 변환</li>
                <li>&lt;U&gt; Class&lt;? extends U&gt; asSubclass(Class&lt;U&gt; clazz) Since 1.5</li>
                호출한 Class 객체의 타입을 변환한다. 반환되는 변수는 현재 객체를 참조한다.<br>
                U : 변환하고자 하는 타입, clazz : 변환하고자 하는 타입 Class 객체
            </ol>
            <details>
                <summary>Nest</summary>
                <ol>
                    <li>Nest는 같은 런타임 패키지 안의, private member에 접근 가능한 클래스와 인터페이스의 집합.</li>
                    Nest에 속한 클래스, 인터페이스를 nestmate라 부르고, 하나의 nest에서 하나의 nestmate는 host 역할을 하고 나머지 nestmate 목록을 갖는다.
                    <li>Class&lt;?&gt; getNestHost() Since 11</li>
                    <li>Class&lt;?&gt;[] getNestMembers() Since 11</li>
                </ol>
            </details>
            <details>
                <summary>클래스 이름 관련</summary>
                <ol>
                    <li>String toString()
                        <button class="btn-code" path="Repositories/Eclipse/JavaSE/src/lang/ClassExample.java" lan="java">예시 코드 »</button></li>
                    <li>String toGenericString() Since 1.8 : 접근한정자 및 타입 포함하여 반환</li>
                    <li>String getName()</li>
                    배열의 경우 차원마다 '['를 붙이며, 배열 원소 타입을 아래와 같이 인코딩한다.<br>
                    boolean : Z, byte : B, char : C, class or interface : L<i>className</i>;, double : D, float : F, int : I, long : J, short : S
                    <li>String getSimpleName() Since 1.5</li>
                    익명 클래스면 빈 문자열 반환
                    <li>String getCanonicalName() Since 1.5</li>
                    Local class, 익명 클래스, 또는 이들의 배열은 canonical name이 없어 null을 반환한다.
                    <li>static Class&lt;?&gt; forName(String className) » 로드된 클래스는 초기화가 진행된다.</li>
                    <li>static Class&lt;?&gt; forName(String name, boolean initialize, ClassLoader loader) Since 1.2</li>
                    <li>static Class&lt;?&gt; forName(Module module, String name) Since 9</li>
                    주어진 모듈에서 <a role="button" target="_blank" class="btn btn-info btn-sm" href="https://docs.oracle.com/javase/9/docs/api/java/lang/ClassLoader.html#name">binary name</a>을 가진 클래스를 반환한다.<br>
                    클래스를 초기화하지 않으며, 클래스를 찾을 수 없으면 null을 반환한다.
                </ol>
            </details>
            <details>
                <summary>is~ Methods</summary>
                <ol>
                    <li>boolean isInstance(Object obj) Since 1.1</li>
                    instanceof 연산자의 동적인 형태라고 보면 된다. 원시타입 클래스 객체는 false만을 반환한다.
                    <li>boolean isAssignableFrom(Class&lt;?&gt; cls) Since 1.1</li>
                    cls 타입 객체를 현재 클래스의 참조 변수로 참조할 수 있는지 여부 반환.
                    <li>boolean isInterface() + isArray, isPrimitive, isAnnotation, isEnum, isAnonymousClass, isLocalClass, isMemberClass</li>
                    wrapper 클래스는 원시타입이 아님에 유의 : Integer.class != Integer.TYPE, Integer.TYPE == int.class
                    <li>boolean isSynthetic() Since 1.5</li>
                    Synthetic class : 명시적/암시적으로 생성자가 정의되지 않은 채 생성된 클래스</li>
                    <li>boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) Since 1.5</li>
                    <li>boolean isNestmateOf(Class&lt;?&gt; c) Since 11</li>
                </ol>
            </details>
            <details>
                <summary>리플렉션 관련</summary>
                <ol>
                    <li>Module getModule() Since 9</li>
                    <li>Package getPackage()</li>
                    <li>String getPackageName() Since 9</li>
                    익명 패키지면 빈 문자열 반환. 배열 클래스의 경우 원소 타입이 속한 패키지 이름 반환. 원시 타입 또는 void의 경우 "java.lang" 반환.                    
                    <li>TypeVariable&lt;Class&lt;T&gt;&gt;[] getTypeParameters() Since 1.5</li>
                    <li>Class&lt;? super T&gt; getSuperclass() + getGenericSuperclass</li>
                    <li>Class&lt;?&gt;[] getInterfaces() : 구현한/상속한 인터페이스 Class 객체 배열 반환</li>
                    <li>Type[] getGenericInterfaces() Since 1.5</li>
                    <li>Class&lt;?&gt; getComponentType() Since 1.1</li>
                    배열 원소 타입 클래스 객체 반환. 배열이 아닌 경우 null 반환</li>
                    <li>int getModifiers() Since 1.1 : java.lang.reflect.Modifier</li>
                    <li>Object[] getSigners() Since 1.1 : 없으면 null 반환</li>
                    <li>Method getEnclosingMethod() Since 1.5 + getEnclosingConstructor, getDeclaringClass, getEnclosingClass</li>
                    이 클래스가 메서드 내부에서 정의된 경우, 해당 메서드를 반환한다.
                    <li>Class&lt;?&gt;[] getClasses() Since 1.1</li>
                    public 멤버로 정의된 클래스, 인터페이스 Class 객체 배열 반환.
                    <li>Field[] getFields() Since 1.1 + getMethods, getConstructors</li>
                    <li>Field getField(String name) Since 1.1 + getMethod, getConstructor</li>
                    <li>Class&lt;?&gt;[] getDeclaredClasses() Since 1.1 + getDeclaredFields, getDeclaredMethods, getDeclaredConstructors</li>
                    상속된 것을 제외한, 호출하는 클래스 내부에 정의된 public, protected, default, private 클래스와 인터페이스들을 반환한다.
                    <li>Field getDeclaredField(String name) Since 1.1 + getDeclaredMethod, getDeclaredConstructor</li>
                    <li>T[] getEnumConstants() Since 1.5</li>
                    <li>AnnotatedType getAnnotatedSuperclass() Since 1.8</li>
                    <li>AnnotatedType[] getAnnotatedInterfaces() Since 1.8</li>    
                </ol>
            </details>
        </details>
    </details>

    <details>
        <summary>abstract class ClassLoader extends Object Since 1.0</summary>
        <ol>
            <li>전형적으로, 로드할 클래스 이름을 파일명으로 변환하여 ".class"파일을 읽어온다.</li>
            <li>모든 Class 객체들은 ClassLoader에 대한 참조를 갖고 있다.</li>
            <li>배열의 경우 런타임에 Class 객체가 생성되며, 이때 Class.getClassLoader()는 원소의 것과 동일하다.</li>
            <li>클래스를 로드하는 것 외에, 자원(.class 파일, 구성 파일, 이미지 등)을 배치하는 책임도 진다.</li>
            <li>Delegation model : ClassLoader 객체들은 각기 parent class loader를 갖는다. 클래스나 자원을 찾기 전에 parent를 먼저 조사하게 된다.</li>
            <li>동시 로딩을 지원하는 parallel capable class loader들은 클래스 초기화 시 registerAsParallelCapable()를 통해 등록해야 한다. ClassLoader 클래스는 기본적으로 등록되나, 서브클래스들도 자신을 등록해야 한다.</li>
            <li>계층구조가 약한 delegation model의 경우 클래스 로더들이 parallel capable하지 않으면 deadlock 발생 가능성이 있다.</li>
            <li>Run-time Built-in Class Loaders</li>
            <ul>
                <li>Bootstrap class loader : JVM 내장 클래스 로더. 보통 null이며, parent가 없다.</li>
                <li>Platform class loader : Java SE APIs, JDK-specific run-time classes</li>
                <li>System class loader, a.k.a Application class loader : Used to define classes on the application class path, module path, and JDK-specific tools</li>
            </ul>

            <li>파일이 아닌 네트워크 같은 다른 소스로부터 클래스를 로드할 경우, defineClass()를 통해 Class 객체를 얻고 Constructor.newInstance()를 통해 클래스 객체를 생성하면 된다.</li>
            <li>네트워크 클래스 로더는 findClass(), loadClassData() 메서드를 반드시 작성해야 한다.</li>
            public Class findClass(String name) {<br>
            　　byte[] b = loadClassData(name);<br>
            　　return defineClass(name, b, 0, b.length);<br>
            }<br>
            private byte[] loadClassData(String name) { /**/ }
            <li>Binary names</li>
            ClassLoader 메서드에 전달하는 String 타입 클래스 이름은 아래와 같은 형식을 따라야 한다.<br>
            "java.lang.String", "javax.swing.JSpinner$DefaultEditor", "java.security.KeyStore$Builder$FileBuilder$1", "java.net.URLClassLoader$3$1"
        </ol>
        <details>
            <summary>Constructor Detail</summary>
            <ol>
                <li>protected ClassLoader(String name, ClassLoader parent) Since 9</li>
                parent가 null일 경우, 해당 클래스 로더가 모든 플랫폼 클래스를 볼 수 있다는 보장은 없다. name : class loader's name; or null if not named</li>
                <li>protected ClassLoader(ClassLoader parent) Since 1.2</li>
                <li>protected ClassLoader() == ClassLoader(getSystemClassLoader())</li>
            </ol>
        </details>
        <details>
            <summary>Method Detail</summary>
            <ol>
                <li>String getName() Since 9 : 클래스 로더 이름 반환. 없으면 null</li>
                <li>Class&lt;?&gt; loadClass(String name) : loadClass(name, false)</li>
                <li>protected Class&lt;?&gt; loadClass(String name, boolean resolve)</li>
                <ol>
                    <li>findLoadedClass(String)로 이미 로드됐나 확인</li>
                    <li>없으면 : parent 혹은 VM의 클래스 로더의 loadClass를 호출</li>
                    <li>없으면 : findClass(String) 호출</li>
                    <li>위를 통해 클래스를 찾았고, resolve가 true면 resolveClass(Class) 호출.</li>
                    <li>ClassLoader의 서브클래스들은 이 메서드가 아닌 findClass(String)을 재정의하면 된다.</li>
                    <li>재정의되지 않은 이상, getClassLoadingLock()을 통해 메서드는 동기화된다.</li>
                </ol>

                <li>protected Object getClassLoadingLock(String className) Since 1.7</li>
                <li>protected Class&lt;?&gt; findClass(String name) Since 1.2 + 1 오버로딩</li>
                <li>protected final Class&lt;?&gt; findSystemClass(String name) : 시스템 클래스 로더에 의해 호출</li>
                <li>protected final Class&lt;?&gt; findLoadedClass(String name) Since 1.1 : 없으면 null</li>
                <li>protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len) Since 1.1 + 2 오버로딩</li>
                지정되지 않은 경우, 기본 ProtectionDomain을 새 클래스에 할당한다. 기본 ProtectionDomain은 Policy.getPolicy().getPermissions(new CodeSource(null, null))과 같은 권한을 부여받는다. 기본 ProtectionDomain은 첫 호출시 생성되고 재사용된다.
                <li>protected final void resolveClass(Class&lt;?&gt; c) : 클래스를 링크한다.</li>
                <li>protected final void setSigners(Class&lt;?&gt; c, Object[] signers) Since 1.1</li>
                상기한 메서드들을 통한 클래스 정의시 SecurityException이 발생하는 경우와 관계 있다.
                한 패키지 내부의 클래스들은 동일한 certificate 집합을 가져야 한다.
                정의하는 클래스가 어떤 패키지에 추가될 때, 패키지의 certificate 집합과 비교하여 서로 다른 경우 예외가 발생한다.
                Certificate 집합은 ProtectionDomain의 CodeSource로부터 얻을 수 있다.

                <li>protected static boolean registerAsParallelCapable() Since 1.7</li>
                호출자의 인스턴스가 만들어지지 않았고, 호출자의 모든 수퍼클래스들이 parallel capable로 등록된 경우
                <li>final boolean isRegisteredAsParallelCapable() Since 9</li>
                <li>final ClassLoader getParent() Since 1.2</li>
                Bootstrap class loader를 표현하는 데 null을 사용하는 구현도 있다.</li>
                <li>final Module getUnnamedModule() Since 9 : 이 클래스 로더를 위한 익명 모듈을 반환한다.</li>
                <li>static ClassLoader getPlatformClassLoader() Since 9</li>
                <li>static ClassLoader getSystemClassLoader()</li>
                시스템 클래스 로더를 반환하며, 이는 새롭게 정의되는 클래스 로더들의 default delegation parent다.
                <li>final Package getDefinedPackage(String name) Since 9</li>
                <li>final Package[] getDefinedPackages() Since 9</li>
                <li>protected Package[] getPackages() Since 1.2 : 현재 및 조상 클래스 로더들이 정의한 패키지들을 반환.</li>
                <li>protected Package definePackage(String name, String specTitle, String specVersion, String specVendor, String implTitle, String implVersion, String implVendor, URL sealBase) Since 1.2</li>
                필요한 경우, defineClass 메서드 전에 호출되어야 한다.
                <li>void setDefaultAssertionStatus(boolean enabled) Since 1.4</li>
                <li>void setPackageAssertionStatus(String packageName, boolean enabled) Since 1.4</li>
                <li>void setClassAssertionStatus(String className, boolean enabled) Since 1.4</li>
                <li>void clearAssertionStatus() Since 1.4</li>
            </ol>
            <details>
                <summary>리소스 관련</summary>
                <ol>
                    <li>protected URL findResource(String moduleName, String name) Since 9</li>
                    <li>URL getResource(String name) Since 1.1</li>
                    <li>Enumeration&lt;URL&gt; getResources(String name) Since 1.2</li>
                    <li>Stream&lt;URL&gt; resources(String name) Since 9</li>
                    <li>protected URL findResource(String name) Since 1.2</li>
                    <li>protected Enumeration&lt;URL&gt; findResources(String name) Since 1.2</li>
                    <li>static URL getSystemResource(String name) Since 1.1</li>
                    <li>static Enumeration&lt;URL&gt; getSystemResources(String name) Since 1.2</li>
                    <li>InputStream getResourceAsStream(String name) Since 1.1</li>
                    <li>static InputStream getSystemResourceAsStream(String name) Since 1.1</li>
                </ol>
            </details>
        </details>
    </details>

    <details>
        <summary>class Package implements AnnotatedElement Since 1.2</summary>
        <details>
            <summary>Method Detail</summary>
            <ol>
                <li>String getName()</li>
                <li>String getSpecificationTitle()</li>
                <li>String getSpecificationVersion()</li>
                <li>String getSpecificationVendor()</li>
                <li>String getImplementationVersion()</li>
                <li>String getImplementationVendor()</li>
                <li>boolean isSealed()</li>
                <li>boolean isSealed(URL url) : 해당 url로 봉인했는지 여부</li>
                <li>boolean isCompatibleWith(String desired) » 현재 사양 버전이 desired 이상이면 true</li>
                <li>static Package[] getPackages() : 호출자의 클래스 로더와 그 조상들이 정의한 모든 패키지</li>
            </ol>
        </details>
    </details>

    <details>
        <summary>final class Module implements AnnotatedElement Since 9</summary>
        <ol>
            <li>이름 있는 모듈에 속하지 않은 모든 타입은 각 클래스 로더의 익명 모듈에 속한다.</li>
        </ol>
        <details>
            <summary>Method Detail</summary>
            <ol>
                <li>boolena isNamed()</li>
                <li>String getName() : 없으면 null</li>
                <li>ClassLoader getClassLoader()</li>
                <li>ModuleDescriptor getDescriptor()</li>
                <li>ModuleLayer getLayer()</li>
                <li>boolean canRead(Module other)</li>
                <li>Module addReads(Module other)</li>
                <li>boolean isExported(String pn, Module other)</li>
                <li>boolean isOpen(String pn, Module other)</li>
                <li>boolean isExported(String pn)</li>
                <li>boolean isOpen(String pn)</li>
                <li>Module addExports(String pn, Module other)</li>
                <li>Module addOpens(String pn, Module other)</li>
                <li>Module addUses(Class&lt;?&gt; service)</li>
                <li>boolean canUse(Class&lt;?&gt; service)</li>
                <li>Set&lt;String&gt; getPackages()</li>
                <li>InputStream getResourceAsStream(String name)</li>
                해당 모듈의 리소스를 스트림으로 반환. name은 '/'으로 구분된 경로
            </ol>
        </details>
    </details>
</details>

<hr>

<details>
    <summary>프로그램 실행 단위</summary>
    <details>
        <summary>class Thread implements Runnable Since 1.0</summary>
        <ol>
            <li>스레드는 실행 우선순위를 가지며, 그 초깃값은 스레드를 생성한 스레드의 것과 같다. 데몬 스레드로부터 생성된 스레드도 데몬 스레드다.</li>
            <li>JVM이 시작되면 하나의 non-daemon 스레드가 존재하며, 전형적으로 main 메서드를 호출한다. JVM은 다음의 상황 중 하나라도 일어나기 전까지 실행을 계속한다.</li>
            <ul>
                <li>Runtime 클래스의 exit 메서드 호출, 또는 SecurityManager의 exit 허용</li>
                <li>모든 데몬 스레드가 아닌 스레드들의 종료 : run 메서드의 반환이든 예외 발생이든 관계없이</li>
            </ul>
        </ol>
        <details>
            <summary>static enum Thread.State Since 1.5</summary>
            NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED
        </details>
        <details>
            <summary>@FunctionalInterface static interface Thread.UncaughtExceptionHandler Since 1.5</summary>
            <ol>
                <li>처리되지 않은 예외로 인해 스레드가 종료되는 상황을 대비한 핸들러. 그러한 상황에서, 먼저 Thread.getUncaughtExceptionHandler()를 통해 얻은 핸들러에 해당 스레드와 예외 객체를 전달한다.</li>
                <li>만일 스레드에 핸드러가 설정되지 않은 경우, ThreadGroup의 핸들러를 이용하며, ThreadGroup에도 없는 경우 default 핸들러를 이용할 수 있다.</li>
                <li>void uncaughtException(Thread t, Throwable e)</li>
            </ol>
        </details>
        <details>
            <summary>Field Detail</summary>
            <ol>
                <li>public static final int MIN_PRIORITY</li>
                <li>public static final int NORM_PRIORITY</li>
                <li>public static final int MAX_PRIORITY</li>
            </ol>
        </details>
        <details>
            <summary>Constructor Detail</summary>
            <ol>
                <li>public Thread()</li>
                <li>public Thread(Runnable target)</li>
                <li>public Thread(ThreadGroup group, Runnable target)</li>
                <li>public Thread(String name)</li>
                <li>public Thread(ThreadGroup group, String name)</li>
                <li>public Thread(Runnable target, String name)</li>
                <li>public Thread(ThreadGroup group, Runnable target, String name)</li>
                <li>public Thread(ThreadGroup group, Runnable target, String name, long stackSize) Since 1.4</li>
                stackSize는 스레드에 할당하는 바이트 크기를 가리키나, 플랫폼에 따라 그 효과는 다르다.
                <li>public Thread(ThreadGroup group, Runnable target, String name, long stackSize, boolean inheritThreadLocals) Since 9</li>
            </ol>
        </details>
        <details>
            <summary>Method Detail</summary>
            <ol>
                <li>static Thread currentThread()</li>
                <li>static void yield()</li>
                <li>static void sleep(long millis) + 1 오버로딩</li>
                <li>static void onSpinWait() Since 9</li>
                <details>
                    <summary>Spin-wait 루프에서 조건이 충족되어 루프를 벗어나기를 기다린다.</summary>
                    class EventHandler {<br>
                    　　volatile boolean eventNotificationNotReceived;<br>
                    　　void waitForEventAndHandleIt() {<br>
                    　　　　while ( eventNotificationNotReceived ) {<br>
                    　　　　　　java.lang.Thread.onSpinWait();<br>
                    　　　　}<br>
                    　　　　readAndProcessEvent();<br>
                    　　}<br>
                    　　<br>
                    　　void readAndProcessEvent() {<br>
                    　　　　// Read event from some source and process it<br>
                    　　　　 . . .<br>
                    　　}<br>
                    }
                </details>

                <li>void start() : JVM이 run()을 호출. 스레드를 재시작하는 것은 허용되지 않는다.</li>
                <li>void run() : 관련된 Runnable의 run() 호출</li>
                <li>void interrupt()</li>
                <ul>
                    <li>checkAccess()가 호출된다. wait, join, sleep으로 블록된 경우 인터럽트 상태가 초기화되고, InterruptedException 발생.</li>
                    <li>InterruptibleChannel로 I/O 작업 중 블록된 경우, 인터럽트 상태가 설정되고 채널은 닫힌다. ClosedByInterruptException 발생.</li>
                    <li>Selector에서 블록된 경우, 인터럽트 상태가 설정되고 selection 연산에서 즉시 반환된다. 그 외의 경우 인터럽트 상태가 설정된다.</li>
                </ul>

                <li>static boolean interrupted() : 현재 스레드가 인터럽드됐는지 여부. 스레드의 인터럽트 상태는 이 메서드로 인해 초기화된다.</li>
                <li>boolean isInterrupted() : 스레드의 인터럽트 상태를 변경하지 않고 반환한다.</li>
                <li>final boolean isAlive()</li>
                <li>final void setPriority(int newPriority) + getPriority</li>
                <li>final void setName(String name) + getName</li>
                <li>final ThreadGroup getThreadGroup()</li>
                <li>static int activeCount() : 현재 스레드 그룹 하위의, 활동중인 스레드 추정치 반환.</li>
                <li>static int enumerate(Thread[] tarray) : 현재 스레드 그룹 하위의 모든 활동 스레드를 배열에 복사하고 그 갯수를 반환한다.</li>
                <li>final void join(long millis) + 2 오버로딩</li>
                이 스레드가 중지되기까지 일시 대기. 0이면 무기한 대기. 지정 되지 않은 경우 0
                <li>static void dumpStack() : 현재 스레드의 스택 추적을 표준 에러 출력</li>
                <li>final void setDaemon(boolean on) + 1 오버로딩 + isDaemon</li>
                스레드를 daemon 또는 user 스레드로 변경. user 스레드가 하나도 없으면 프로그램은 종료된다. 스레드가 시작되기 전에 호출돼야한다.
                <li>final void checkAccess() : 현재 스레드가 이 스레드를 변경할 수 없으면 SecurityException 발생</li>
                <li>ClassLoader getContextClassLoader() Since 1.2</li>
                <li>static boolean holdsLock(Object obj) Since 1.4</li>
                특정 객체를 lock으로 갖는지 확인하기 위해 만들어짐.
                <li>StackTraceElement[] getStackTrace() Since 1.5 : 현재 스레드의 스택 추적 반환</li>
                <li>static Map&lt;Thread, StackTraceElement[]&gt; getAllstackTraces() Since 1.5 : 전체 스레드에 대해 스택 추적 반환</li>
                <li>long getId() Since 1.5</li>
                <li>Thread.State getState() Since 1.5</li>
                <li>static void setDefaultUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh) Since 1.5 + getDefaultUncaughtExceptionHandler</li>
                <li>void setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh) Since 1.5 + getUncaughtExceptionHandler</li>
            </ol>
        </details>
    </details>

    <details>
        <summary>class ThreadGroup implements Thread.UncaughtExceptionHandler Since 1.0</summary>
        <details>
            <summary>Constructor Detail</summary>
            <ol>
                <li>public ThreadGroup(String name) Since 1.0</li>
                <li>public ThreadGroup(ThreadGroup parent, String name) Since 1.0</li>
            </ol>
        </details>
        <details>
            <summary>Method Detail</summary>
            <ol>
                <li>final String getName() Since 1.0</li>
                <li>final ThreadGroup getParent() Since 1.0</li>
                <li>boolean isDestroyed() Since 1.1</li>
                <li>final void setDaemon(boolean daemon) Since 1.0 + isDaemon</li>
                데몬 스레드 그룹은 마지막 스레드나 스레드 그룹이 파괴되면 자동으로 파괴된다.
                <li>final void setMaxPriority(int pri) Since 1.0 + getMaxpriority</li>
                <li>final boolean parentOf(ThreadGroup g) Since 1.0</li>
                <li>final void checkAccess() Since 1.0</li>
                <li>int activeCount()</li>
                <li>int enumerate(Thread[] list) : Thread 클래스의 설명과 동일</li>
                <li>int enumerate(Thread[] list, boolean recurse) Since 1.0</li>
                <li>int activeGroupCount() Since 1.0</li>
                <li>int enumerate(ThreadGroup[] list) Since 1.0</li>
                <li>int enumerate(ThreadGroup[] list, boolean recurse) Since 1.0</li>
                <li>final void interrupt() Since 1.2 : 그룹의 모든 스레드에 인터럽트</li>
                <li>final void destroy() Since 1.0 : 그룹과 하위 모든 그룹을 파괴</li>
                <li>void list() : 표준 출력으로 설명 출력</li>
                <li>void uncaughtException(Thread t, THrowable e) Since 1.0 : 처리되지 않은 예외에 대하여 JVM이 호출한다</li>
            </ol>
        </details>
    </details>

    <details>
        <summary>abstract class Process Since 1.0</summary>
        <ol>
            <li>ProcessBuilder.start, Runtime.exec으로 시작된 native process들에 대한 제어 제공.</li>
        </ol>
        <details>
            <summary>Method Detail</summary>
            <ol>
                <li>abstract OutputStream getOutputStream() + getInputStream, getErrorStream</li>
                <li>abstract int waitFor()</li>
                현재 스레드가 이 프로세스의 종료를 기다린다. 프로세스의 종료 값을 반환.
                <li>boolean waitFor(long timeout, TimeUnit unit) Since 1.8</li>
                timeout : maximum time to wait. 시간 내에 프로세스가 종료되었다면 true 반환
                <li>abstract int exitValue()</li>
                <li>abstract void destroy() : 정상 종료.</li>
                <li>Process destroyForcibly() Since 1.8 : 강제, 즉시 종료.</li>
                <li>boolean supportsNormalTermination() Since 9</li>
                <li>boolean isAlive() Since 1.8</li>
                <li>long pid() Since 9</li>
                <li>CompletableFuture&lt;Process&gt; onExit() Since 9</li>
                <li>ProcessHandle toHandle() Since 9</li>
                <li>ProcessHandle.Info info() Since 9</li>
                <li>Stream&lt;ProcessHandle&gt; children() Since 9</li>
                <li>Stream&lt;ProcessHandle&gt; descendants() Since 9</li>
            </ol>
        </details>
    </details>

    <details>
        <summary>final class ProcessBuilder Since 1.5</summary>
        <ol>
            <li>이 클래스는 스레드-안전하지 않다.</li>
        </ol>
        <details>
            <summary>abstract static class ProcessBuilder.Redirect Since 1.7</summary>
            <ol>
                <li>서브프로세스의 입력 소스 또는 출력 방향을 표현한다.</li>
            </ol>
            <details>
                <summary>static enum ProcessBuilder.Redirect.Type</summary>
                APPEND : Redirect.appendTo(File), INHERIT, PIPE, READ : Redirect.from(File), WRITE : Redirect.to(File)
            </details>
            <details>
                <summary>Field Detail</summary>
                <ol>
                    <li>public static final ProcessBuilder.Redirect PIPE : 현재 프로세스와 파이프로 연결</li>
                    <li>public static final ProcessBuilder.Redirect INHERIT : 현재 프로세스의 것과 동일</li>
                    <li>public static final ProcessBuilder.Redirect DISCARD Since 9: 출력 버림</li>
                </ol>
            </details>
            <details>
                <summary>Method Detail</summary>
                <ol>
                    <li>abstract ProcessBuilder.Redirect.Type type()</li>
                    <li>File file() : 입력 소스 또는 출력지와 관계된 File 반환. 없으면 null.</li>
                    <li>static ProcessBuilder.Redirect from(File file)</li>
                    <li>static ProcessBuilder.Redirect to(File file) : file의 이전 내용은 새로운 쓰기 작업에 의해 버려진다.</li>
                    <li>static ProcessBuilder.Redirect appendTo(File file)</li>
                </ol>
            </details>
        </details>
        <details>
            <summary>Constructor Detail</summary>
            <ol>
                <li>public ProcessBuilder(List&lt;String&gt; command)</li>
                <li>public ProcessBuilder(String... command)</li>
            </ol>
        </details>
        <details>
            <summary>Method Detail</summary>
            <details open>
                <summary>Setter</summary>
                <ol>
                    <li>ProcessBuilder command(String... command) + 1 오버로딩</li>
                    <li>ProcessBuilder directory(File directory)</li>
                    <li>ProcessBuilder redirectInput(ProcessBuilder.Redirect source) Since 1.7 + 1 오버로딩 + redirectOutput, redirectError</li>
                    <li>ProcessBuilder inheritIO() Since 1.7</li>
                    <li>ProcessBuilder redirectErrorStream(boolean redirectErrorStream)</li>
                    true면 서브프로세스들의 에러 출력이 표준 출력과 함께 나온다.
                </ol>
            </details>
            <details open>
                <summary>Getter</summary>
                <ol>
                    <li>List&lt;String&gt; command()</li>
                    <li>Map&lt;String, String&gt; environment()</li>
                    <li>File directory()</li>
                    <li>ProcessBuilder.Redirect redirectInput() Since 1.7 + redirectOutput, redirectError</li>
                    <li>boolean redirectErrorStream()</li>
                </ol>
            </details>
            <ol>
                <li>Process start()</li>
                <li>static List&lt;Process&gt; startPipeline(List&lt;ProcessBuilder&gt; builders) Since 9</li>
                프로세스들의 표준 출력을 다음 프로세스의 표준 입력으로 연결한다.
            </ol>
        </details>
    </details>

    <details>
        <summary>class Runtime Since 1.0</summary>
        <ol>
            <li>모든 Java 애플리케이션은 하나의 Runtime 인스턴스를 가진다.</li>
        </ol>
        <details>
            <summary>static final class Runtime.Version implements Comparable&lt;Runtime.Version&gt; Since 9</summary>
            <ul>
                <li>$VNUM : $FEATURE.$INTERIM.$UPDATE.$PATCH == [1-9][0-9]*((\.0)*\.[1-9][0-9]*)*</li>
                $FEATURE : Feature-release counter<br>
                $INTERIM : Interim-release counter<br>
                $UPDATE : Update-release counter<br>
                $PATCH : Emergency patch-release counter

                <li>Version String : $VNUM(-$PRE)?\+$BUILD(-$OPT)? or $VNUM-$PRE(-$OPT)? or $VNUM(+-$OPT)?</li>
                $PRE : [a-zA-Z0-9]+ : Pre-release identifier<br>
                $BUILD : 0|[1-9][0-9]* : Build number<br>
                $OPT : [-a-zA-Z0-9.]+ : Additional build information
            </ul>
        </details>
        <details>
            <summary>Method Detail</summary>
            <ol>
                <li>static Runtime getRuntime()</li>
                <li>void exit(int status) : 현재 실행중인 JVM을 종료</li>
                <li>void addShutdownHook(Thread hook) Since 1.3 + removeShutdownHook</li>
                JVM이 종료 절차에 진입하면 등록된 모든 hook를 실행
                <li>void halt(int status) Since 1.3 : 강제종료</li>
                <li>Process exec(String[] cmdarray, String[] envp, File dir) Since 1.3 + 5 오버로딩</li>
                <li>int availableProcessors() Since 1.4</li>
                <li>long freeMemory() + totalMemory, maxMemory</li>
                <li>void gc() : Garbage collector 작동.</li>
                <li>void runFinalization() : 소멸 대기중인 모든 객체 소멸</li>
                <li>void load(String filename) : Native library 로드. JNI에서 사용.</li>
                <li>void loadLibrary(String libname)</li>
                <li>static Runtime.Version version() Since 9 : JVM 버전 반환.</li>
            </ol>
        </details>
    </details>

    <details>
        <summary>final class System Since 1.0</summary>
        <details>
            <summary>static interface System.Logger Since 9</summary>
            <details>
                <summary>static enum System.Logger.Level Since 9</summary>
                <ol>
                    <li>ALL(Integer.MIN_VALUE), TRACE(400), DEBUG(500), INFO(800), WARNING(900), ERROR(1000), OFF(Integer.MAX_VALUE)</li>
                    <li>final String getName()</li>
                    <li>final int getSeverity()</li>
                </ol>
            </details>
            <details>
                <summary>Method Detail</summary>
                <ol>
                    <li>String getName() : 로거 이름 반환.</li>
                    <li>boolean isLoggable(System.Logger.Level level)</li>
                    <li>default void log(System.Logger.Level level, String msg) + 오버로딩</li>
                </ol>
            </details>
        </details>
        <details>
            <summary>abstract static class System.LoggerFinder Since 9</summary>
            <ul>
                <li>로거의 생성, 관리, 구성에 관한 서비스 제공.</li>
                <li>기본 구현 : java.logging 모듈이 있는 경우 java.util.logging이용. 없으면 INFO 수준으로 표준 에러 출력</li>
            </ul>
            <details>
                <summary>Method Detail</summary>
                <ol>
                    <li>static System.LoggerFinder getLoggerFinder()</li>
                    <li>abstract getLogger(String name, Module module)</li>
                    <li>System.Logger getLocalizedLogger(String name, ResourceBundle bundle, Module module)</li>        
                </ol>
            </details>
        </details>
        <details>
            <summary>Field Detail</summary>
            <ol>
                <li>public static final InputStream in</li>
                <li>public static final PrintStream out</li>
                <li>public static final PrintStream err</li>
            </ol>
        </details>
        <details>
            <summary>Method Detail</summary>
            <ol>
                <li>static void setIn(InputStream in) Since 1.1 + setOut, setErr</li>
                <li>static Console console() Since 1.6</li>
                <li>static Channel inheritedChannel() Since 1.5</li>
                <li>static void setSecurityManager(SecurityManager s) + getSecurityManager</li>
                <li>static long currentTimeMillis() + nanoTime</li>
                <li>static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</li>
                <li>static int identityHashCode(Object x) Since 1.1</li>
                <li>static String lineSeparator() Since 1.7</li>
                <li>static void setProperties(Properties props) + getProperties</li>
                <li>static String setProperty(String key, String value) Since 1.2 + 2 오버로딩</li>
                <li>static String clearProperty(String key) Since 1.5</li>
                <li>static String getenv(String name) + 1 오버로딩 : 환경변수</li>
                <li>static System.Logger getLogger(String name) Since 9 + 1 오버로딩</li>
                <li>static void exit(int status)</li>
                <li>static void gc() : Runtime의 것을 호출</li>
                <li>static void runFinalization() : Runtime의 것을 호출</li>
                <li>static void load(String filename) : Runtime의 것을 호출</li>
                <li>static void loadLibrary(String libname) : Runtime의 것을 호출</li>
            </ol>
        </details>
    </details>

    <details>
        <summary>final class StackWalker Since 9</summary>
        <ol>
            <li>현재 스레드의 StackFrame에 대한 스트림을 열고 특정 작업을 수행한다. 스트림은 실행 지점인 맨 위 frame부터 아래로 내려가면서 작업한다.</li>
            예. 현재 스레드의 상위 10개 스택 프레임 가져오기. StackWalker.getInstance().walk(s -&gt; s.limit(10).collect(Collectors.toList()));
        </ol>
        <details>
            <summary>static enum StackWalker.Option Since 9</summary>
            <ul>
                <li>RETAIN_CLASS_REFERENCE : StackWalker가 작업하는 StackFrame들에 클래스 정보 유지</li>
                <li>SHOW_HIDDEN_FRAMES : 모든 숨겨진 프레임 표시.</li>
                <li>SHOW_REFLECT_FRAMES : 모든 reflection 프레임 표시</li>
            </ul>
        </details>
        <details>
            <summary>static interface StackWalker.StackFrame Since 9</summary>
            <ul>
                <li>각 StackFrame 객체는 StackWalker로부터 반환된, 메서드 호출을 표현한다.</li>
            </ul>
            <details>
                <summary>Method Detail</summary>
                <ol>
                    <li>String getClassName() : 이 프레임이 나타내는 메서드가 정의된 클래스를 binary name으로 반환</li>
                    <li>String getMethodName() : 이 프레임이 나타내는 메서드의 이름 반환.</li>
                    <li>Class&lt;?&gt; getDeclaringClass() : 이 프레임이 나타내는 메서드가 정의된 클래스의 객체 반환. Option.RETAIN_CLASS_REFERENCE가 설정되어야 지원된다</li>
                    <li>default MethodType getMethodType() Since 10</li>
                    <li>default String getDescriptor() Since 10</li>
                    <li>int getByteCodeIndex() : 실행 지점을 포함하는 Code 속성에서의 인덱스 반환.</li>
                    <li>String getFileName() : 이 프레임이 가리키는 실행 지점이 포함된 소스 파일 이름 반환.</li>
                    <li>int getLineNumber()</li>
                    <li>boolean isNativeMethod()</li>
                    <li>StackStraceElement toStackTraceElement() : 이 프레임에 관한 StackTraceElement 반환.</li>
                </ol>
            </details>
        </details>
        <details>
            <summary>Method Detail</summary>
            <ol>
                <li>static StackWalker getInstance() : 숨겨진 프레임을 모두 생략. 클래스 정보 미포함.</li>
                <li>static StackWalker getInstance(StackWalker.Option option)</li>
                <li>static StackWalker getInstance(Set&lt;StackWalker.Option&gt; options)</li>
                <li>static StackWalker getInstance(Set&lt;StackWalker.Option&gt; options, int estimateDepth)</li>
                <li>&lt;T&gt; T walk(Function&lt;? super Stream&lt;StackWalker.StackFrame&gt;, ? extends T&gt; function)</li>
                <li>void forEach(Consumer&lt; super StackWalker.StackFrame&gt; action)</li>
                <li>Class&lt;&?&gt; getCallerClass()</li>
                이 메서드의 호출자의 클래스 객체를 반환. 예를 들어, Util#getResourceBundle 메서드는 이 메서드를 통해 얻은 호출자의 클래스로부터 클래스 로더를 얻고, 클래스 로더를 통해 리소스를 로드한다.
            </ol>
        </details>
    </details>

    <details>
        <summary>final class StackTraceElement implements Serializable Since 1.4</summary>
        <details>
            <summary>Constructor Detail</summary>
            <ol>
                <li>public StackTraceElement(String declaringClass, String methodName, String fileName, int lineNumber) Since 1.5</li>
                <li>public StackTraceElement(String classLoaderName, String moduleName, String moduleVersion, String declaringClass, String methodName, String fileName, int lineNumber) Since 9</li>    
            </ol>
        </details>
        <details>
            <summary>Method Detail</summary>
            <ol>
                <li>String getFileName()</li>
                <li>int getLineNumber()</li>
                <li>String getModuleName() Since 9</li>
                <li>String getModuleVersion() Since 9</li>
                <li>String getClassLoaderName() Since 9</li>
                <li>String getClassName()</li>
                <li>String getMethodName()</li>
                <li>boolean isNativeMethod()</li>
            </ol>
        </details>
    </details>
</details>

<hr>