<hr>

<details open>
    <summary>Package Summary</summary>
    <ol>
        <li>변수 하나에 대한 잠금 없는 스레드-안전성을 제공한다</li>
        <li>VarHandle을 통해 변수를 원자적으로 접근한다</li>
        <li>AtomicBoolean, AtomicInteger 등은 일반적인 Boolean, Integer 등을 대신할 수 없다</li>
        <li>메모리 장벽을 만나면 CPU 코어의 캐시값이 RAM으로 반영된다</li>
    </ol>
</details>

<hr>

<details>
    <summary>abstract class VarHandle implements Constable Since 9</summary>
    <ol>
        <li>java.lang.invoke 패키지 멤버임</li>
        <li>하나의 변수, 매개변수, 필드 등에 대한 동적인 타입 참조. plain 읽기/쓰기, volatile 읽기/쓰기, compare-and-set 접근을 지원한다</li>
    </ol>
    <details>
        <summary>static enum VarHandle.AccessMode</summary>
        <table>
            <tbody>
                <tr><th>GET</th><td>VarHandle.get</td></tr>
                <tr><th>SET</th><td>VarHandle.set</td></tr>
                <tr><th>GET_VOLATILE</th><td>VarHandle.getVolatile</td></tr>
                <tr><th>SET_VOLATILE</th><td>VarHandle.setVolatile</td></tr>
                <tr><th>GET_ACQUIRE</th><td>VarHandle.getAcquire</td></tr>
                <tr><th>SET_RELEASE</th><td>VarHandle.setRelease</td></tr>
                <tr><th>GET_OPAQUE</th><td>VarHandle.getOpaque</td></tr>
                <tr><th>SET_OPAQUE</th><td>VarHandle.setOpaque</td></tr>
                <tr><th>COMPARE_AND_SET</th><td>VarHandle.compareAndSet</td></tr>
                <tr><th>COMPARE_AND_EXCHANGE</th><td>VarHandle.compareAndExchange</td></tr>
                <tr><th>COMPARE_AND_EXCHANGE_ACQUIRE</th><td>VarHandle.compareAndExchangeAcquire</td></tr>
                <tr><th>COMPARE_AND_EXCHANGE_RELEASE</th><td>VarHandle.compareAndExchangeRelease</td></tr>
                <tr><th>WEAK_COMPARE_AND_SET_PLAIN</th><td>VarHandle.weakCompareAndSetPlain</td></tr>
                <tr><th>WEAK_COMPARE_AND_SET</th><td>VarHandle.weakCompareAndSet</td></tr>
                <tr><th>WEAK_COMPARE_AND_SET_ACQUIRE</th><td>VarHandle.weakCompareAndSetAcquire</td></tr>
                <tr><th>WEAK_COMPARE_AND_SET_RELEASE</th><td>VarHandle.weakCompareAndSetRelease</td></tr>
                <tr><th>GET_AND_SET</th><td>VarHandle.getAndSet</td></tr>
                <tr><th>GET_AND_SET_ACQUIRE</th><td>VarHandle.getAndSetAcquire</td></tr>
                <tr><th>GET_AND_SET_RELEASE</th><td>VarHandle.getAndSetRelease</td></tr>
                <tr><th>GET_AND_ADD</th><td>VarHandle.getAndAdd</td></tr>
                <tr><th>GET_AND_ADD_ACQUIRE</th><td>VarHandle.getAndAddAcquire</td></tr>
                <tr><th>GET_AND_ADD_RELEASE</th><td>VarHandle.getAndAddRelease</td></tr>
                <tr><th>GET_AND_BITWISE_OR</th><td>VarHandle.getAndBitwiseOr</td></tr>
                <tr><th>GET_AND_BITWISE_OR_RELEASE</th><td>VarHandle.getAndBitwiseOrRelease</td></tr>
                <tr><th>GET_AND_BITWISE_OR_ACQUIRE</th><td>VarHandle.getAndBitwiseOrAcquire</td></tr>
                <tr><th>GET_AND_BITWISE_AND</th><td>VarHandle.getAndBitwiseAnd</td></tr>
                <tr><th>GET_AND_BITWISE_AND_RELEASE</th><td>VarHandle.getAndBitwiseAndRelease</td></tr>
                <tr><th>GET_AND_BITWISE_AND_ACQUIRE</th><td>VarHandle.getAndBitwiseAndAcquire</td></tr>
                <tr><th>GET_AND_BITWISE_XOR</th><td>VarHandle.getAndBitwiseXor</td></tr>
                <tr><th>GET_AND_BITWISE_XOR_RELEASE</th><td>VarHandle.getAndBitwiseXorRelease</td></tr>
                <tr><th>GET_AND_BITWISE_XOR_ACQUIRE</th><td>VarHandle.getAndBitwiseXorAcquire</td></tr>
            </tbody>
        </table>
    </details>
    <details>
        <summary>Method Detail</summary>
        <ol>
            <li>final Object get(Object... args)</li>
            변수가 non-volatile인 것처럼 읽는다(= plain read). 모든 VarHandle 인스턴스에서 지원된다
            <li>final void set(Object... args)</li>
            변수가 non-volatile, non-final인 것처럼 쓴다(= plain write). 메서드 시그니처는 (CT1 ct1, ..., CTn ctn, T newValue)void.
            <li>final Object getVolatile(Object... args)</li>
            변수가 volatile인 것처럼 읽는다. 
            <li>final void setVolatile(Object... args)</li>
            변수가 volatile인 것처럼 쓴다. 메서드 시그니처는 (CT1 ct1, ..., CTn ctn, T newValue)void.
            <li>final Object getOpaque(Object... args) + setOpaque</li>
            Opaque : Program order 순서대로 접근한다. 다른 스레드와의 조율은 없다
            <li>final Object getAcquire(Object... args)</li>
            같은 변수에 대해 이어지는 load/store 연산이 이 접근보다 먼저 발생하지 않는다
            <li>final void setRelease(Object... args)</li>
            같은 변수에 대한 이전의 load/store 연산이 이 접근보다 나중에 발생하지 않는다
            <li>final boolean compareAndSet(Object... args)</li>
            원자적으로 다음이 실행된다. getVolatile과 동일한 문맥으로 가져온 값(witness value)이 expectedValue와 동일(==)하면 setVolatile과 동일한 문맥으로 newValue 설정 후 true 반환, 그 외엔 false 반환<br>
            메서드 시그니처는 (CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)boolean
            <li>final Object compareAndExchange(Object... args)</li>
            원자적으로 다음이 실행된다. getVolatile과 동일한 문맥으로 가져온 값(witness value)이 expectedValue와 동일(==)하면 setVolatile과 동일한 문맥으로 newValue 설정. 반환값은 witness value
            <li>final Object compareAndExchangeAcquire(Object... args)</li>
            원자적으로 다음이 실행된다. getAcquire와 동일한 문맥으로 가져온 값(witness value)이 expectedValue와 동일(==)하면 set와 동일한 문맥으로 newValue 설정. 반환값은 witness value
            <li>final Object compareAndExchangeRelease(Object... args)</li>
            원자적으로 다음이 실행된다. get와 동일한 문맥으로 가져온 값(witness value)이 expectedValue와 동일(==)하면 setRelease와 동일한 문맥으로 newValue 설정. 반환값은 witness value
            <li>final boolean weakCompareAndSetPlain(Object... args)</li>
            다음이 실행된다. get과 동일한 문맥으로 가져온 값(witness value)이 expectedValue와 동일(==)하면 set과 동일한 문맥으로 newValue 설정 후 true 반환. 그 외엔 false
            <li>final boolean weakCompareAndSet(Object... args) + ~Acquire, ~Release</li>
            다음이 실행된다. getVolatile과 동일한 문맥으로 가져온 값(witness value)이 expectedValue와 동일(==)하면 setVolatile과 동일한 문맥으로 newValue 설정 후 true 반환. 그 외엔 false
            <li>final Object getAndSet(Object... args) + ~Acquire, ~Release</li>
            원자적으로 다음이 실행된다. getVolatile과 동일한 문맥으로 값(witness value)을 가져오고, setVolatile과 동일한 문맥으로 newValue 설정 후 witness value 반환
            <li>final Object getAndAdd(Object... args) + ~Acquire, ~Release</li>
            원자적으로 값을 더한 후 이전 값 반환. 메서드 시그니처는 (CT1 ct1, ..., CTn ctn, T value)T
            <li>final Object getAndBitwiseOr(Object... args)</li>
            원자적으로 OR 연산 수행 후 이전 값 반환. 메서드 시그니처는 (CT1 ct1, ..., CTn ctn, T mask)T<br>
            + ~Acquire, ~Release, getAndBitwiseAnd~, getAndBitwiseXor~
            <li>final Class&lt;?&gt; varType() + coordinateTypes</li>
            <li>final MethodType accessModeType(VarHandle.AccessMode accessMode) + isAccessModeSupported</li>
            접근 모드 획득
            <li>static void acquireFence()</li>
            장벽 이전의 load 연산이 장벽 이후의 load/store 뒤로 재배치되지 않음
            <li>static void fullFence()</li>
            장벽 이전의 load/store 연산이 장벽 이후의 load/store 뒤로 재배치되지 않음
            <li>static void releaseFence()</li>
            장벽 이전의 load/store 연산이 장벽 이후의 store 뒤로 재배치되지 않음
            <li>static void loadLoadFence()</li>
            장벽 이전의 load 연산이 장벽 이후의 load 뒤로 재배치되지 않음
            <li>static void storeStoreFence()</li>
            장벽 이전의 store 연산이 장벽 이후의 store 뒤로 재배치되지 않음
        </ol>
    </details>
</details>

<hr>

<details>
    <summary>class AtomicBoolean implements Serializable Since 1.5</summary>
    <ol>
        <li>public AtomicBoolean(boolean initialValue) + 오버로딩</li>
        지정하지 않으면 false
        
        <li>final boolean get() : VarHandle::getVolatile</li>
        <li>final boolean compareAndSet(boolean expectedValue, boolean newValue) : VarHandle::compareAndSet</li>
        <li>boolean weakCompareAndSetPlain(boolean expectedValue, boolean newValue) Since 9 + VarHandle::weakCompareAndSetPlain</li>
        <li>final void set(boolean newValue) : VarHandle::setVolatile</li>
        <li>final void lazySet(boolean newValue) Since 1.6 : VarHandle::setRelease</li>
        <li>final boolean getAndSet(boolean newValue) : VarHandle::getAndSet</li>
        <li>final boolean getPlain() Since 9 : VarHandle::get</li>
        <li>final void setPlain(boolean newValue) Since 9 : VarHandle::set</li>
        <li>final boolean getOpaque() Since 9 : VarHandle::getOpaque</li>
        <li>final void setOpaque(boolean newValue) Since 9 : VarHandle::setOpaque</li>
        <li>final boolean getAcquire() Since 9 : VarHandle::getAcquire</li>
        <li>final void setRelease(boolean newValue) Since 9 : VarHandle::setRelease</li>
        <li>final boolean compareAndExchange(boolean expectedValue, boolean newValue) Since 9 + ~Acquire, ~Release</li>
        메모리 영향은 VarHandle::compareAndExchange와 같다.
        <li>final boolean weakCompareAndSetVolatile(boolean expectedValue, boolean newValue) Since 9 + ~Acquire, ~Release</li>
        메모리 영향은 VarHandle::weakCompareAndSet와 같다
    </ol>
</details>

<hr>

<details>
    <summary>class AtomicInteger extends Number implements Serializable Since 1.5 + AtomicLong, AtomicReference</summary>
    <ol>
        <li>public AtomicInteger(int initialValue) + 오버로딩</li>
        지정하지 않은 경우 0
        
        <li>final int get() : VarHandle::getVolatile</li>
        <li>final void set(int newValue) : VarHandle::setVolatile</li>
        <li>final void lazySet(int newValue) Since 1.6 : VarHandle::setRelease</li>
        <li>final int getAndSet(int newValue) : VarHandle::getAndSet</li>
        <li>final boolean weakCompareAndSetPlain(int expectedValue) Since 9 : VarHandle::weakCompareAndSetPlain</li>        
        <li>VarHandle::getAndAdd</li>
        final int getAndIncrement() + getAndDecrement, getAndAdd, incrementAndGet, decrementAndGet, addAndGet
        <li>VarHandle::compareAndSet</li>
        final boolean compareAndSet(int expectedValue, int newValue) + getAndUpdate, updateAndGet, getAndAccumulate, accumulateAndGet
        <li>getPlain ~ weakCompareAndSetRelease​ : AtomicBoolean과 동일</li>
    </ol>
</details>

<hr>

<details>
    <summary>class AtomicIntegerArray implements Serializable Since 1.5 + AtomicLongArray, AtomicReferenceArray</summary>
    <ol>
        <li>인덱스를 추가로 받는 것 외에, 지원하는 메서드들은 AtomicInteger와 같다.</li>
        <li>public AtomicIntegerArray(int length) : 각 원소는 0으로 초기화.</li>
        <li>public AtomicIntegerArray(int[] array)</li>
        <li>final int length()</li>
    </ol>
</details>

<hr>

<details>
    <summary>abstract class AtomicIntegerFieldUpdater&lt;T&gt; Since 1.5 + AtomicLongFieldUpdater, AtomicReferenceFieldUpdater</summary>
    <ol>
        <li>지정된 volatile int 필드를 atomic 연산으로 갱신.</li>
        해당 필드를 단일 업데이터로만 접근한다면, compareAndSet 메서드들이 원자적으로 작동됨이 보장된다
        <li>지원하는 메서드는 AtomicInteger와 유사하다.</li>
        <li>static &lt;U&gt; AtomicIntegerFieldUpdater&lt;U&gt; newUpdater(Class&lt;U&gt; tclass, String fieldName)</li>        
    </ol>
</details>

<hr>

<details>
    <summary>class AtomicMarkableReference&lt;V&gt; Since 1.5</summary>
    <ol>
        <li>원자적으로 갱신되는 마커 bit와 객체 참조 쌍</li>
        <li>public AtomicMarkableReference(V initialRef, boolean initialMark)</li>
        <li>V getReference() + isMarked</li>
        <li>V get(boolean[] markHolder)</li>
        markHolder[0]에 해당하는 참조 반환
        <li>boolean compareAndSet(V expectedReference, V newReference, boolean expectedMark, boolean newMark) + weakCompareAndSet</li>
        기존 참조와 마커 bit가 모두 예상과 동일(==)하다면 원자적으로 갱신하고 true 반환. 그 외엔 false
        <li>void set(V newReference, boolean newMark)</li>
        <li>boolean attemptMark(V expectedReference, boolean newMark)</li>
        기존 참조가 예상과 동일(==)하다면, 마커 bit를 원자적으로 갱신하고 true 반환. 그 외엔 false
    </ol>
</details>

<hr>

<details>
    <summary>class AtomicStampedReference&lt;V&gt; Since 1.5</summary>
    <ol>
        <li>원자적으로 갱신되는 index와 참조 쌍</li>
        <li>public AtomicStampedReference(V initialRef, int initialStamp)</li>
        <li>V getReference() + getStamp</li>
        <li>V get(int[] stampHolder)</li>
        stampHolder[0]에 해당하는 참조 반환
        <li>boolean compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp) + weakCompareAndSet</li>
        기존 참조와 인덱스가 예상과 동일(==)하다면 원자적으로 갱신하고 true 반환. 그 외엔 false
        <li>void set(V newReference, int newStamp)</li>
        <li>boolean attempStamp(V expectedReference, int newStamp)</li>
        기존 참조가 예상과 동일(==)하다면, 인덱스를 원자적으로 갱신하고 true 반환. 그 외엔 false
    </ol>
</details>

<hr>

<details>
    <summary>class LongAdder extends Number implements Serializable Since 1.8 + DoubleAdder</summary>
    <ol>
        <li>초깃값 0으로 시작하는 스레드-안전한 합계.</li>
        합의 순서는 정의되지 않으므로 순서에 상관 없는 경우에 이용해야 한다.
        
        <li>public LongAdder()</li>
        
        <li>void add(long x)</li>
        <li>void increment()</li>
        <li>void decrement()</li>
        <li>long sum() : 현재 합계 반환</li>
        <li>void reset()</li>
        <li>long sumThenReset()</li>
    </ol>
</details>

<hr>

<details>
    <summary>class LongAccumulator extends Number implements Serializable Since 1.8 + DoubleAccumulator</summary>
    <ol>
        <li>특정 값과 특정 함수로 갱신되는 long 값 유지.</li>
        주어진 accumulatorFunction은 부작용이 없어야 한다.

        <li>public LongAccumulator(LongBinaryOperator accumulatorFunction, long identity)</li>
        
        <li>void accumulate(long x)</li>
        <li>long get()</li>
        <li>void reset()</li>
        <li>long getThenReset()</li>
    </ol>
</details>

<hr>