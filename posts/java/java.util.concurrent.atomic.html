<hr>

<details>
    <summary>class AtomicBoolean implements Serializable Since 1.5</summary>
    <ol>
        <li>Boolean을 대신할 순 없다.</li>
        
        <li>public AtomicBoolean(boolean initialValue)</li>
        <li>public AtomicBoolean() : this(false)</li>
        
        <li>final boolean get()</li>
        현재 값을 반환한다. 메모리 영향은 VarHandle.getVolatile(Object...)와 같다 » 변수가 volatile인 것처럼 읽어 반환.
        
        <li>final void set(boolean newValue)</li>
        newValue로 값 설정. 메모리 영향은 VarHandle.setVolatile(Object...)와 같다 » 변수가 volatile인 것처럼 값을 새로 설정한다.

        <li>final boolean compareAndSet(boolean expectedValue, boolean newValue)</li>
        현재 값이 expectedValue와 같다면, atomic 연산으로 newValue로 변경하고 true를 반환한다. 메모리 영향은 VarHandle.compareAndSet(Object...)와 같다 » setVolatile(Object...)로 값 설정, 현재 값은 getVolatile(Object...)로 가져온다.

        <li>boolean weakCompareAndSetPlain(boolean expectedValue, boolean newValue) Since 9</li>
        현재 값이 expectedValue와 같다면, 아마도 atomic 연산으로 newValue로 변경하고 true를 반환한다. 메모리 영향은 VarHandle.weakCompareAndSetPlain(Object...)와 같다 » 변수가 non-volatile, non-final하다고 간주하는 set(Object...), get(Object...)이용.

        <li>final void lazySet(boolean newValue) Since 1.6</li>
        newValue로 값 설정. 메모리 영향은 VarHandle.setRelease(Object...)와 같다 » 값을 새로 설정하며, 이전의 읽기/쓰기들이 재배치되지 않도록 보장한다.

        <li>final boolean getAndSet(boolean newValue)</li>
        atomic 연산으로 newValue로 설정하고, 이전 값을 반환한다. 메모리 영향은 VarHandle.getAndSet(Object...)와 같다 » 이전 값은 getVolatile(Object...)로 가져오고, setVolatile(Object...)로 값 설정.

        <li>final boolean getPlain() Since 9</li>
        변수가 non-volatile인 것처럼 가져온다.

        <li>final void setPlain(boolean newValue) Since 9</li>
        변수가 non-volatile, non-final인 것처럼 쓴다.

        <li>final boolean getOpaque() Since 9</li>
        현재 값을 반환한다. 메모리 영향은 VarHandle.getOpaque(Object...)와 같다 » 프로그램 순서에 따라 접근하여 반환. 다른 스레드들 사이의 접근 순서는 정해지지 않는다.

        <li>final void setOpaque(boolean newValue) Since 9</li>
        newValue로 쓴다. 메모리 영향은 VarHandle.setOpaque(Object...)와 같다 » 프로그램 순서에 따라 접근하여 쓰기. 다른 스레드들 사이의 접근 순서는 정해지지 않는다.

        <li>final boolean getAcquire() Since 9</li>
        현재 값을 반환한다. 메모리 영향은 VarHandle.getAcquire(Object...)와 같다 » 변수의 값을 반환한다. 이후의 읽기/쓰기는 이전에 실행되지 않는다.

        <li>final void setRelease(boolean newValue) Since 9</li>
        newValue로 설정. 메모리 영향은 VarHandle.setRelease(Object...)와 같다. » 변수의 값을 설정한다. 이전의 읽기/쓰기는 이후에 실행되지 않는다.

        <li>final boolean compareAndExchange(boolean expectedValue, boolean newValue) Since 9</li>
        현재 값이 expectedValue와 같다면 atomic 연산으로 newValue로 설정하고 이전 값 반환. 메모리 영향은 VarHandle.compareAndExchange(Object...)와 같다 » expectedValue와 같다면 atomic 연산으로 newValue로 설정. 이전 값은 getVolatile(Object...)로 접근.

        <li>final boolean compareAndExchangeAcquire(boolean expectedValue, boolean newValue) Since 9</li>
        현재 값이 expectedValue와 같다면 atomic 연산으로 newValue로 설정하고 이전 값 반환. 메모리 영향은 VarHandle.compareAndExchangeAcquire(Object...)와 같다 » expectedValue와 같다면 set(Object...)로 newValue 설정. 이전 값은 getAcquire(Object...)로 접근.

        <li>final boolean compareAndExchangeRelease(boolean expectedValue, boolean newValue) Since 9</li>
        현재 값이 expectedValue와 같다면 atomic 연산으로 newValue로 설정하고 이전 값 반환. 메모리 영향은 VarHandle.compareAndExchangeRelease(Object...)와 같다 » expectedValue와 같다면 setRelease(Object...)로 newValue 설정. 이전 값은 get(Object...)로 접근.

        <li>final boolean weakCompareAndSetVolatile(boolean expectedValue, boolean newValue) Since 9</li>
        현재 값이 expectedValue와 같다면, 아마도 atomic 연산으로 newvalue 설정하고 true 반환. 메모리 영향은 VarHandle.weakCompareAndSet(Object...)와 같다 » expectedValue와 같다면 setVolatile(Object...)로 newValue 설정. 이전 값은 getVolatile(Object...)로 접근.

        <li>final boolean weakCompareAndSetAcquire(boolean expectedValue, boolean newValue) Since 9</li>
        현재 값이 expectedValue와 같다면, 아마도 atomic 연산으로 newValue 설정하고 true 반환. 메모리 영향은 VarHandle.weakCompareAndSetAcquire(Object...)와 같다 » expectedValue와 같다면 set(Object...)로 newValue 설정. 이전 값은 getAcquire(Object...)로 접근

        <li>final boolean weakCompareAndSetRelease(boolean expectedValue, boolean newValue) Since 9</li>
        현재 값이 expectedValue와 같다면, 아마도 atomic 연산으로 newValue 설정하고 true 반환. 메모리 영향은 VarHandle.weakCompareAndSetRelease(Object...)와 같다 » expectedValue와 같다면 setRelease(Object...)로 newValue 설정. 이전 값은 get(Object...)로 접근.
    </ol>
</details>

<hr>

<details>
    <summary>class AtomicInteger extends Number implements Serializable Since 1.5</summary>
    <ol>
        <li>public AtomicInteger(int initialValue)</li>
        <li>public AtomicInteger() : this(0)</li>
        
        <li>final int get()</li>
        <li>final void set(int newValue)</li>
        <li>final void lazySet(int newValue) Since 1.6</li>
        <li>final int getAndSet(int newValue)</li>
        <li>final boolean compareAndSet(int expectedValue, int newValue)</li>
        <li>final boolean weakCompareAndSetPlain(int expectedValue) Since 9</li>
        
        <li>final int getAndIncrement()</li>
        atomic 연산으로 1 증가한다. 이전 값을 반환하며, 메모리 영향은 VarHandle.getAndAdd(Object...)와 같다 » getVolatile(Object...)로 값을 가져오고, setVolatile(Object...)로 값을 설정
        <li>final int getAndDecrement()</li>
        <li>final int getAndAdd(int delta)</li>
        <li>final int incrementAndGet()</li>
        atomic 연산으로 1 증가한다. 이후 값을 반환하며, 메모리 영향은 VarHandle.getAndAdd(Object...)와 같다.
        <li>final int decrementAndGet()</li>
        <li>final int addAndGet(int delta)</li>
        <li>final int getPlain() Since 9</li>
        <li>final void setPlain(int newValue) Since 9</li>
        <li>final int getOpaque() Since 9</li>
        <li>final void setOpaque(int newValue) Since 9</li>
        <li>final int getAcquire() Since 9</li>
        <li>final void setRelease(int newValue) Since 9</li>
        <li>final int compareAndExchange(int expectedValue, int newValue) Since 9</li>
        <li>final int compareAndExchangeAcquire(int expectedValue, int newValue) Since 9</li>
        <li>final int compareAndExchangeRelease(int expectedValue, int newValue) Since 9</li>
        <li>final boolean weakCompareAndSetVolatile​(int expectedValue, int newValue) Since 9</li>
        <li>final boolean weakCompareAndSetAcquire​(int expectedValue, int newValue) Since 9</li>
        <li>final boolean weakCompareAndSetRelease​(int expectedValue, int newValue) Since 9</li>
        
        <li>final int getAndUpdate(IntUnaryOperator updateFunction) Since 1.8</li>
        atomic 연산으로 값을 갱신한다. 이전 값을 반환하며, 메모리 영향은 VarHandle.compareAndSet(Object...)와 같다. 이용되는 함수는 재실행될 수 있으므로, 부작용이 없어야 한다.
        <li>final int updateAndGet(IntUnaryOperator updateFunction) Since 1.8</li>
        갱신 이후 값을 반환.
        <li>final int getAndAccumulate(int x, IntBinaryOperator accumulatorFunction) Since 1.8</li>
        atomic 연산으로 값을 갱신한다. 이전 값을 반환하며, 메모리 영향은 VarHandle.compareAndSet(Object...)와 같다. 이용되는 함수는 재실행될 수 있으므로, 부작용이 없어야 한다.
        <li>final int accumulateAndGet(int x, IntBinaryOperator accumulatorFunction) Since 1.8</li>
        갱신 이후 값을 반환.
    </ol>
</details>

<hr>

<details>
    <summary>class AtomicIntegerArray implements Serializable Since 1.5</summary>
    <ol>
        <li>public AtomicIntegerArray(int length) : 각 원소는 0으로 초기화.</li>
        <li>public AtomicIntegerArray(int[] array)</li>
        
        <li>final int get(int i)</li>
        <li>final void set(int i, int newValue) ...</li>
        지원하는 함수들의 설명은 AtomicInteger와 같다.
        <li>final int length()</li>
    </ol>
</details>

<hr>

<details>
    <summary>abstract class AtomicIntegerFieldUpdater&lt;T&gt; Since 1.5</summary>
    <ol>
        <li>지정된 volatile int 필드를 atomic 연산으로 갱신.</li>
        <li>static &lt;U&gt; AtomicIntegerFieldUpdater&lt;U&gt; newUpdater(Class&lt;U&gt; tclass, String fieldName)</li>
        <li>abstract boolean compareAndSet(T obj, int expect, int update)</li>
        <li>abstract boolean weakCompareAndSet(T obj, int expect, int update) ...</li>
        지원하는 함수들의 종류는 AtomicInteger와 유사하다.
    </ol>
</details>

<hr>

<details>
    <summary>class AtomicReference&lt;V&gt; implements Serializable Since 1.5</summary>
    아마도 atomic 연산으로 변경되는 객체 참조를 정의. 지원하는 함수들의 종류는 AtomicInteger와 유사하다.
</details>

<hr>

<details>
    <summary>class AtomicReferenceArray&lt;E&gt; implements Serializable Since 1.5</summary>
    아마도 atomic 연산으로 변경되는 객체 참조들의 배열을 정의. 지원하는 함수들의 종류는 AtomicIntegerArray와 유사하다.
</details>

<hr>

<details>
    <summary>abstract class AtomicReferenceFieldUpdater&lt;T, V&gt; Since 1.5</summary>
    지정된 클래스의 지정된 volatile 참조 필드를 atomic 연산으로 변경. 지원하는 함수들의 종류는 AtomicIntegerFieldUpdater와 유사하다.
</details>

<hr>

<details>
    <summary>class LongAdder extends Number implements Serializable Since 1.8 + DoubleAdder</summary>
    <ol>
        <li>초깃값 0으로 시작하는 스레드-안전한 합계. 단, 합의 순서는 정의되지 않으므로 순서에 상관 없는 경우에 이용해야 한다. 또, 주어진 accumulatorFunction은 부작용이 없어야 한다.</li>
        
        <li>public LongAdder()</li>
        
        <li>void add(long x)</li>
        <li>void increment()</li>
        <li>void decrement()</li>
        <li>long sum() : 현재 합계 반환</li>
        <li>void reset()</li>
        <li>long sumThenReset()</li>
    </ol>
</details>

<hr>

<details>
    <summary>class LongAccumulator extends Number implements Serializable Since 1.8 + DoubleAccumulator</summary>
    <ol>
        <li>특정 값과 특정 함수로 갱신되는 long 값 유지.</li>
        
        <li>public LongAccumulator(LongBinaryOperator accumulatorFunction, long identity)</li>
        
        <li>void accumulate(long x)</li>
        <li>long get()</li>
        <li>void reset()</li>
        <li>long getThenReset()</li>
    </ol>
</details>

<hr>