<hr>

<details>
    <summary>interface Closeable extends AutoCloseable Since 1.5</summary>
    <ol>
        <li>데이터의 출발지나 목적지를 닫을 수 있으면 Closeable하다.</li>
        <li>try-with-resource 구문에 이용될 수 있다. <button type="button" class="btn btn-primary btn-sm btn-code" path="Java/Basic/src/io/github/donggi/TryWithResources.java" lan="java">예시 코드 »</button></li>
    </ol>
    <details>
        <summary>Method Detail</summary>
        <ol>
            <li>void close()</li>
            스트림 및 이와 관련된 시스템 자원을 해제한다. 이미 호출되었다면 아무 일도 하지 않는다.<br>
            close() 실패했을 때, 예외를 던지는 대신 사용하던 자원을 모두 포기하고 Closeable 객체 내부적으로 '닫혔다(closed)'고 마크하길 권장한다.
        </ol>
    </details>
</details>

<hr>

<details>
    <summary>interface Flushable Since 1.5</summary>
    <ol>
        <li>Flush할 수 있는 데이터 목적지는 Flushable하다.</li>
    </ol>
    <details>
        <summary>Method Detail</summary>
        <ol>
            <li>void flush()</li>
            버퍼에 저장된 데이터를 스트림에 모두 써 보낸다.
        </ol>
    </details>
</details>

<hr>

<details>
    <summary>바이트 단위 IO 관련</summary>
    <details>
        <summary>interface DataInput Since 1.0</summary>
        <ol>
            <li>binary stream으로부터 바이트들을 읽고, 또 이를 자바 기본 타입 또는 String으로 만들어 반환하는 기능을 제공한다.</li>
            <li>읽기는 1바이트 단위로 이루어진다.</li>
            <li>Modified UTF-8 : DataInput과 DataOutput 인터페이스는 수정된 UTF-8을 이용한다.</li>
            <ul>
                <li>'\u0001' ~ '\u007F'는 1바이트(0???????)로 표현한다.</li>
                <li>null('\u0000'), '\u0080' ~ '\u07FF'는 2바이트(110????? 10??????)로 표현한다.</li>
                <li>'\u0800' ~ '\uFFFF'는 3바이트(1110??? 10?????? 10??????)로 표현한다.</li>
            </ul>
        </ol>
        <details>
            <summary>Method Detail</summary>
            <ol>
                <li>void readFully(byte[] b) == readFully(b, 0, b.length)<br>
                    void readFully(byte[] b, int off, int len)</li>
                len만큼의 바이트를 읽어와 b의 off번째 바이트부터 저장한다.

                <li>int skipBytes(int n)</li>
                입력 스트림의 n바이트를 무시한다. 실제로 무시한 바이트 길이가 반환된다.

                <details>
                    <summary>기본 자료형 읽기</summary>
                    <ol>
                        <li>boolean readBoolean()</li>
                        readByte() != 0 // 1바이트를 읽어 0이면 false, 그 외엔 true 반환
        
                        <li>byte readByte()</li>
                        1바이트를 읽어 그대로 반환
        
                        <li>int readUnsignedByte()</li>
                        1바이트를 읽어 int로 반환
        
                        <li>short readShort()</li>
                        1바이트씩 순서대로 읽은 a, b에 대하여 (short)((a &lt;&lt; 8) | (b &amp; 0xff)) 반환
        
                        <li>int readUnsignedShort()</li>
                        ((a & 0xff) &lt;&lt; 8) | (b &amp; 0xff)
                        
                        <li>생략</li>

                        <li>float readFloat()</li>
                        readInt()한 비트 순서 그대로 float으로 변환하여 반환

                        <li>double readDouble()</li>
                        readLong()한 비트 순서 그대로 double로 변환하여 반환
                    </ol>
                </details>
                
                <li>String readLine()</li>
                <ul>
                    <li>줄의 끝이나 파일 끝을 만나기까지의 문자열을 반환한다.</li>
                    <li>각 바이트들을 0 패딩하여 char로 변환하므로, 유니코드를 읽기는 부적합하다.</li>
                    <li>아무것도 읽지 못한 경우, 빈 문자열이 아닌 null이 반환된다.</li>
                </ul>

                <li>String readUTF()</li>
                <ul>
                    <li>먼저 readUnsignedShort()와 같은 방법으로 2개 바이트를 읽어와 UTF 길이를 구한다.</li>
                    <li>구한 길이만큼의 바이트를 읽으면서 상기한 Modified UTF-8에 맞춰 String을 만든다.</li>
                    <li>길이만큼의 바이트를 다 읽기 전에 EOF를 만나면 예외를 던진다.</li>
                </ul>
            </ol>
        </details>
    </details>

    <details>
        <summary>interface DataOutput Since 1.0</summary>
        <ol>
            <li>DataInput과 대칭</li>
        </ol>
        <details>
            <summary>Method Detail</summary>
            <ol>
                <li>void write(int b)</li>
                하위 8개 비트만 스트림에 쓴다. 나머지는 무시한다.

                <li>void writeBoolean(boolean v)</li>
                true면 write(1), false면 write(0)

                <li>void writeShort(int v)</li>
                다음 순으로 2개 바이트를 쓴다. (byte)(0xff &amp; (v &gt;&gt; 8)), (byte)(0xff &amp; v)

                <li>void writeBytes(String s)</li>
                s의 각 글자의 하위 8개 비트만 쓴다.

                <li>void writeChars(String s)</li>
                s의 각 글자를 저장.

                <li>void writeUTF(String s)</li>
                Modified UTF-8을 이용하여 저장한다. 총 길이 정보를 2바이트로 먼저 기록한다.
            </ol>
        </details>
    </details>

    <details>
        <summary>abstract class InputStream implements Closeable Since 1.0</summary>
        <ol>
            <li>바이트 단위 읽기에 대한 최상위 추상 클래스</li>
            <li>작업이 끝날 때까지 스레드가 블록되며, 스트림이 비동기적으로 닫히거나, 인터럽트가 발생하는 경우에 대해 대처하지 않는다.</li>
        </ol>
        <details>
            <summary>Method Detail</summary>
            <ol>
                <li>static InputStream nullInputStream() Since 11</li>
                아무것도 읽지 않는 InputStream을 반환한다. 반환된 스트림은 처음부터 열려 있고, 마치 스트림의 끝에 도달한 것처럼 작동한다. 일반 InputSteram과 마찬가지로 close()를 통해 닫는다.

                <li>long transferTo(OutputStream out) Since 9</li>
                입력 스트림의 모든 바이트를 읽어들여 out에 쓴다. 총 전송 바이트 수를 반환하며, 스트림을 닫는 작업을 하진 않는다.

                <li>abstract int read()</li>
                다음 바이트를 읽고 int로 반환한다. 스트림 끝인 경우 -1을 반환한다. 스트림이 끝나거나, 예외가 발생하거나, 읽을 데이터가 준비될 때까지 쓰레드를 블록한다.

                <li>int read(byte[] b) == read(b, 0, b.length)<br>
                    int read(byte[] b, int off, int len)</li>
                실제로 읽은 바이트 수를 반환한다. 스트림 끝인 경우 -1을 반환한다. 쓰레드를 블록한다.

                <li>byte[] readAllBytes() Since 9</li>
                
                <li>byte[] readNBytes(int len) Since 11</li>
                
                <li>long skip(long n)</li>
                실제로 건너뛴 바이트 수를 반환. 음수 매개변수에 대해 0을 반환한다. 서브클래스들의 구현은 이와 다를 수 있다.

                <li>int available()</li>
                막힘 없이 한 번에 읽어올 수 있는 바이트 수 예상값을 반환. InputStream 구현에 따라 전체 바이트 수를 반환하기도, 그렇지 않기도 하다. InputStream 자체는 항상 0을 반환하며, 서브클래스에서 재정의해야 한다.

                <details>
                    <summary>마킹 관련</summary>
                    <ol>
                        <li>boolean markSupported()</li>
                        mark, reset 메서드를 지원하는지 여부 반환. 기본 false

                        <li>void mark(int readlimit)</li>
                        현재 위치 마킹

                        <li>void reset()</li>
                        마지막 마킹 위치로 이동
                    </ol>
                </details>
            </ol>
        </details>
    </details>
    
    <details>
        <summary>abstract class OutputStream implements Closeable, Flushable Since 1.0</summary>
        <ol>
            <li>바이트 단위 쓰기에 대한 최상위 추상 클래스</li>
        </ol>
        <details>
            <summary>Method Detail</summary>
            <ol>
                <li>static OutputStream nullOutputStream() Since 11</li>
                실제로 데이터를 쓰지는 않는 OutputStream 객체를 반환한다.
                <li>abstract void write(int b)</li>
                하위 8개 비트만 쓰고 나머지는 무시한다.
                <li>void write(byte[] b)<br>
                    void write(byte[] b, int off, int len)</li>
            </ol>
        </details>
    </details>

    <details>
        <summary>class FilterInputStream extends InputStream Since 1.0</summary>
        다른 InputStream에 대한 필터 장식자 정의 클래스로, 추가적인 메서드는 없다.
    </details>
    
    <details>
        <summary>class FilterOutputStream extends OutputStream Since 1.0</summary>
        다른 OutputStream에 대한 필터 장식자 정의 클래스로, 추가적인 메서드는 없다.
    </details>

    <details>
        <summary>class ByteArrayInputStream extends InputStream Since 1.0</summary>
        <ol>
            <li>내부 버퍼 byte[] buf에 대한 읽기 연산을 지원하는 InputStream</li>
        </ol>
        <details>
            <summary>Constructor Detail</summary>
            <ol>
                <li>public ByteArrayInputStream(byte[] buf)</li>
                <li>public ByteArrayInputStream(byte[] buf, int offset, int length)</li>
            </ol>
        </details>
    </details>
    
    <details>
        <summary>class ByteArrayOutputStream extends OutputStream Since 1.0</summary>
        <ol>
            <li>내부 버퍼 byte[] buf에 대해 쓰기 연산을 지원하는 OutputStream. 버퍼 크기는 자동으로 확장된다.</li>                
        </ol>
        <details>
            <summary>Constructor Detail</summary>
            <ol>
                <li>public ByteArrayOutputStream()</li>
                <li>public ByteArrayOutputStream(int size)</li>
            </ol>
        </details>
        <details>
            <summary>Method Detail</summary>
            <ol>
                <li>void writeBytes(byte[] b) since 11 == write(b, 0, b.length)</li>
                <li>void writeTo(OutputStream out)</li>
                버퍼를 out에 모두 쓴다. == out.write(buf, 0, count)
                <li>byte[] toByteArray()</li>
                buf 복사본 반환.
                <li>void reset()</li>
                지금까지 쓴 것을 무시하고 처음부터 재활용.
                <li>int size()</li>
                <li>String toString(String charsetName) Since 1.1<br>
                    String toString(Charset charset) Since 10</li>
            </ol>
        </details>
    </details>

    <details>
        <summary>class BufferedInputStream extends FilterInputStream Since 1.0</summary>
        <ol>
            <li>다른 입력 스트림에 대해 버퍼를 제공함으로써 mark와 reset이 가능하게 해준다. 추가적인 특별한 메서드는 없다.</li>
        </ol>            
        <details>
            <summary>Field Detail</summary>
            <ol>
                <li>protected byte[] buf</li>
                <li>protected int count</li>
                마지막 유효 바이트 인덱스 + 1
                <li>protected int marklimit, markpos, pos</li>
                |pos - markpos| &lt; marklimit면 markpos는 -1(기본값)이 된다.
            </ol>
        </details>
            <details>
            <summary>Constructor Detail</summary>
            <ol>
                <li>public BuferedInputStream(InputStream in)</li>
                <li>public BufferedInputStream(InputStream in, int size) : size는 버퍼 크기.</li>
            </ol>
        </details>
    </details>
    
    <details>
        <summary>class BufferedOutputStream extends FilterOutputStream Since 1.0</summary>
        <ol>
            <li>다른 출력 스트림에 대해 버퍼를 제공하여, 시스템 쓰기 작업이 빈번하게 일어나지 않게 해준다. 추가적인 특별한 메서드는 없다.</li>
        </ol>
        <details>
            <summary>Field Detail</summary>
            <ol>
                <li>protected byte[] buf</li>
                <li>protected int count : buf 내부의 유효한 바이트 수</li>
            </ol>
        </details>
            <details>
                <summary>Constructor Detail</summary>
                <ol>
                    <li>public BufferedOutputStream(OutputStream out)</li>
                    <li>public BufferedOutputStream(OutputStream out, int size)</li>
                </ol>
            </details>
    </details>
        
    <details>
        <summary>class DataInputStream extends FilterInputStream implements DataInput Since 1.0</summary>
        <ol>
            <li>플랫폼 독립적인 자바 기본 타입 읽기를 정의한 DataInput을 구체화한 장식자 클래스(FilterInputStream).</li>
        </ol>
        <details>
            <summary>Constructor Detail</summary>
            <ol>
                <li>public DataInputStream(InputStream in)</li>
            </ol>
        </details>
        <details>
            <summary>Method Detail</summary>
            <ol>
                <li>static final String readUTF(DataInput in)</li>
                Modified UTF-8을 이용하여 in 스트림으로부터 String을 해석해 반환한다.
            </ol>
        </details>
    </details>
        
    <details>
        <summary>class DataOutputStream extends FilterOutputStream implements DataOutput Since 1.0</summary>
        <ol>
            <li>플랫폼 독립적인 자바 기본 타입 쓰기를 정의한 DataOutput을 구체화한 장식자 클래스(FilterOutputStream)</li>
        </ol>
        <details>
            <summary>Field Detail</summary>
            <ol>
                <li>protected int written</li>
                현재까지 쓴 바이트 수. 오버플로될 경우 Integer.MAX_VALUE로 설정된다.
            </ol>
        </details>
        <details>
            <summary>Constructor Detail</summary>
            <ol>
                <li>public DataOutputStream(OutputStream out)</li>
            </ol>
        </details>
        <details>
            <summary>Method Detail</summary>
            <ol>
                <li>final int size() == return written;</li>
            </ol>
        </details>
    </details>
        
        
</details>

<hr>

<details>
    <summary>객체 IO(직렬화) 관련</summary>
    <details>
        <summary>interface ObjectInput extends DataInput, AutoCloseable Since 1.1</summary>
        <ol>
            <li>DataInput을 통해 기본 자료형을 읽어오고, 추가적으로 객체를 읽어오는 작업을 지원한다.</li>
        </ol>
        <details>
            <summary>Method Detail</summary>
            <ol>
                <li>Object readObject()</li>
            </ol>
        </details>
    </details>
    
    <details>
        <summary>interface ObjectOutput extends DataOutput, AutoCloseable Since 1.1</summary>
        <ol>
            <li>DataOutput에 추가로 객체 쓰기 작업을 지원한다.</li>
        </ol>
        <details>
            <summary>Method Detail</summary>
            <ol>
                <li>void writeObject(Object obj)</li>
            </ol>
        </details>
    </details>
    
    <details>
        <summary>interface Serializable Since 1.1</summary>
        <ol>
            <li>직렬화와 역질렬화를 지원하는 마커 인터페이스. ObjectInputStream, ObjectOutputStream의 메서드들을 이용해 알아서 저장/복구한다.
                <button type="button" class="btn btn-primary btn-sm btn-code" path="Java/JavaSE/src/io/SerializableExample.java" lan="java">예시 코드 »</button></li>
            <li>직렬화하지 않을 멤버는 transient 키워드로 표시한다.</li>
            <li>직접 구현하고 싶다면 Externalizable 인터페이스를 구체화하거나, 다음의 메서드들을 작성한다.</li>
            <ul>
                <li>private void writeObject(java.io.ObjectOutputStream out)</li>
                out에 알아서 객체 표현 바이트들을 쓰면 된다.

                <li>private void readObject(java.io.ObjectInputStream in)</li>
                in에서 바이트들을 읽어와 알아서 객체를 생성하면 된다.

                <li>private void readObjectNoData()</li>
                객체들의 버전이 다르거나, 기타 이유로 객체를 초기화할 필요가 있는 경우 사용.
            </ul>

            <li>대체 객체를 이용해 저장 : ANY-ACCESS-MODIFIER Object writeReplace()</li>
            <li>대체 객체를 이용해 복구 : ANY-ACCESS-MODIFIER Object readResolve()</li>
            
            <li>클래스 버전</li>
            정의되지 않은 경우 기본값을 사용하지만, 명시할 것을 권장하고 있다.<br>
            ANY-ACCESS-MODIFIER static final long serialVersionUID = (version number)L;
        </ol>
    </details>
        
    <details>
        <summary>interface Externalizable extends Serializable Since 1.1</summary>
        <ol>
            <li>객체 직렬화를 직접 구현하고자 할 때 이를 구체화한다. 객체 직렬화는 빈 객체를 만든 뒤 각 속성의 값을 쓰므로 기본 생성자가 필요하다.
                <button type="button" class="btn btn-primary btn-sm btn-code" path="Java/JavaSE/src/io/ExternalizableExample.java" lan="java">예시 코드 »</button></li>
        </ol>
        <details>
            <summary>Method Detail</summary>
            <ol>
                <li>void writeExternal(ObjectOutput out)</li>
                객체를 out에 쓴다.

                <li>void readExternal(ObjectInput in)</li>
                in으로 객체를 생성한다.
            </ol>
        </details>
    </details>
        
        
</details>

<hr>

<details>
    <summary>문자 단위 IO 관련</summary>
    <details>
        <summary>abstract class Reader implements Readable, Closeable Since 1.1</summary>
        <ol>
            <li>char 단위 읽기에 대한 최상위 추상 클래스</li>
            <li>서브클래스들은 read(char[], int, int)와 close()만 구현해도 된다.</li>
        </ol>
        <details>
            <summary>Field Detail</summary>
            <ol>
                <li>protected Object lock</li>
                내부적으로 동기화에 이용하는 객체
            </ol>
        </details>
        <details>
            <summary>Method Detail</summary>
            <ol>
                <li>static Reader nullReader() Since 11</li>
                아무 것도 읽지 않는 Reader 객체를 반환한다.

                <li>int read()</li>
                char 하나를 읽고 int로 반환. 스트림의 끝이라면 -1을 반환한다.
                
                <li>int read(char[] cbuf)<br>
                    abstract int read(char[] cbuf, int off, int len)</li>
                실제로 읽은 글자 수를 반환.
                
                <li>long skip(long n)</li>
                실제로 건너 뛴 글자 수(바이트 수x) 반환
                
                <li>boolean ready()</li>
                다음 read()가 블록되지 않음을 보장하면 true, 보장하지 못하면 false
                
                <li>마킹 관련 : InputStream과 유사</li>
                
                <li>long transterTo(Writer out) Since 10</li>
                모든 글자를 읽어 out에 쓴다. 전송한 글자 수를 반환한다.
            </ol>
        </details>
    </details>
        
    <details>
        <summary>abstract class Writer implements Appendable, Closeable, Flushable Since 1.1</summary>
        <ol>
            <li>char 단위 쓰기에 대한 취상위 추상 클래스</li>
            <li>Appendable하므로 편리함이 크다.</li>
        </ol>
        <details>
            <summary>Field Detail</summary>
            <ol>
                <li>protected Object lock</li>
                내부적으로 동기화에 이용되는 객체.
            </ol>
        </details>
        <details>
            <summary>Method Detail</summary>
            <ol>
                <li>static Writer nullWriter() Since 11</li>
                아무것도 쓰지 않는 Writer 객체를 반환한다.

                <li>void write(int c)</li>
                하위 16비트만 쓴고 나머지는 무시한다.
                
                <li>void write(char[] cbuf)<br>
                    abstract void write(char[] cbuf, int off, int len)<br>
                    void write(String str)<br>
                    void write(String str, int off, int len)</li>
            </ol>
        </details>
    </details>

    <details>
        <summary>class InputStreamReader extends Reader Since 1.1</summary>
        <ol>
            <li>InputStream에 대해 Reader 작업을 지원해주는 bridge 클래스.
                <button type="button" class="btn btn-primary btn-sm btn-code" path="Java/JavaSE/src/io/BufferedReaderExample.java" lan="java">예시 코드 »</button></li>
        </ol>
        <details>
            <summary>Constructor Detail</summary>
            <ol>
                <li>public InputStreamReader(InputStream in)</li>
                <li>public InputStreamReader(InputStream in, String charsetName)</li>
                <li>public InputStreamReader(InputStream in, Charset cs) Since 1.4</li>
                <li>public InputStreamReader(InputStream in, CharsetDecoder dec) Since 1.4</li>
            </ol>
        </details>
        <details>
            <summary>Method Detail</summary>
            <ol>
                <li>String getEncoding()</li>
            </ol>
        </details>
    </details>
    
    <details>
        <summary>class OutputStreamWriter extends Writer Since 1.1</summary>
        <ol>
            <li>OutputStream에 Writer 작업을 지원해주는 bridge 클래스.</li>
        </ol>
        <details>
            <summary>Constructor Detail</summary>
            <ol>
                <li>public OutputStreamWriter(OutputStream out, String charsetName)</li>
                <li>public OutputStreamWriter9OutputStream out)</li>
                <li>public OutputStreamWriter9OutputStream out, Charset cs) Since 1.4</li>
                <li>public OutputStreamWriter9OutputStream out, CharsetEncoder enc) Since 1.4</li>
            </ol>
        </details>
        <details>
            <summary>Method Detail</summary>
            <ol>
                <li>String getEncoding()</li>
            </ol>
        </details>
    </details>
    
    <details>
        <summary>abstract class FilterReader extends Reader Since 1.1</summary>
        다른 Reader에 대한 필터 장식자 정의 클래스로, 추가적인 메서드는 없다.
    </details>
    
    <details>
        <summary>abstract class FilterWriter extends Writer Since 1.1</summary>
        다른 Writer에 대한 필터 장식자 정의 클래스로, 추가적인 메서드는 없다.
    </details>
    
    <details>
        <summary>class CharArrayReader extends Reader Since 1.1</summary>
        <ol>
            <li>내부 버퍼 char[] buf에 대한 읽기 연산을 지원하는 Reader</li>
        </ol>
        <details>
            <summary>Constructor Detail</summary>
            <ol>
                <li>public CharArrayReader(char[] buf)</li>
                <li>public CharArrayReader(char[] buf, int offset, int length)</li>
            </ol>
        </details>
    </details>
    
    <details>
        <summary>class CharArrayWriter extends Writer Since 1.1</summary>
        <ol>
            <li>내부 버퍼 char[] buf에 대해 쓰기 연산을 지원하는 Writer. 버퍼 크기는 자동으로 확장된다.</li>
        </ol>
        <details>
            <summary>Constructor Detail</summary>
            <ol>
                <li>public CharArrayWriter()</li>
                <li>public CharArrayWriter(int initialSize)</li>
            </ol>
        </details>
        <details>
            <summary>Method Detail</summary>
            <ol>
                <li>void writeTo(Writer out)</li>
                out에 버퍼의 모든 내용을 쓴다.
                <li>void reset()</li>
                버퍼를 비우고 재활용한다.
                <li>char[] toCharArray()</li>
                <li>int size()</li>
            </ol>
        </details>
    </details>
        
    <details>
        <summary>class StringReader extends Reader Since 1.1</summary>
        <ol>
            <li>String에 대해 읽기 연산을 수행하는 Reader.</li>
        </ol>
        <details>
            <summary>Constructor Detail</summary>
            <ol>
                <li>public StringReader(String s)</li>
            </ol>
        </details>
    </details>
    
    <details>
        <summary>class StringWriter extends Writer Since 1.1</summary>
        <ol>
            <li>내부 StringBuffer에 쓰기 연산을 지원하는 Writer.</li>
        </ol>
        <details>
            <summary>Constructor Detail</summary>
            <ol>
                <li>public StringWriter()</li>
                <li>public StringWriter(int initialSize)</li>
            </ol>
        </details>
        <details>
            <summary>Method Detail</summary>
            <ol>
                <li>StringBuffer getBuffer()</li>
            </ol>
        </details>
    </details>
        
    <details>
        <summary>class BufferedReader extends Reader Since 1.1</summary>
        <ol>
            <li>다른 Reader에 대한 버퍼를 제공하여, 시스템 읽기 작업이 빈번하게 일어나지 않게 해준다.
                <button type="button" class="btn btn-primary btn-sm btn-code" path="Java/JavaSE/src/io/BufferedReaderExample.java" lan="java">예시 코드 »</button></li>
        </ol>
        <details>
            <summary>Constructor Detail</summary>
            <ol>
                <li>public BufferedReader(Reader in, int sz)</li>
                <li>public BufferedReader(Reader in)</li>
            </ol>
        </details>
            <details>
            <summary>Method Detail</summary>
            <ol>
                <li>String readLine() : EOF도 줄의 끝으로 간주</li>
                <li>Stream&lt;String&gt; lines() Since 1.8</li>
            </ol>
        </details>
    </details>
    
    <details>
        <summary>class BufferedWriter extends Writer Since 1.1</summary>
        <ol>
            <li>Writer에 버퍼를 제공하여 시스템 쓰기 작업이 빈번하게 일어나지 않도록 한다.</li>
        </ol>
        <details>
            <summary>Constructor Detail</summary>
            <ol>
                <li>public BufferedWriter(Writer out)</li>
                <li>public BufferedWriter(Writer out, int sz)</li>
            </ol>
        </details>
            <details>
            <summary>Method Detail</summary>
            <ol>
                <li>void newLine() : 줄 바꿈 문자열은 시스템 속성 line.separator로 결정된다.</li>
            </ol>
        </details>
    </details>
        
    <details>
        <summary>class LineNumberReader extends BufferedReader Since 1.1</summary>
        <ol>
            <li>Reader가 줄 끝을 만날때마다 라인을 카운트하는 클래스. 처음 시작은 0.</li>
        </ol>
        <details>
            <summary>Method Detail</summary>
            <ol>
                <li>void setLineNumber(int lineNumber)</li>
                읽기 위치가 이동하는 건 아니다

                <li>int getLineNumber()</li>
            </ol>
        </details>
    </details>
        
    <details>
        <summary>class PrintWriter extends Writer Since 1.1</summary>
        PrintStream의 Writer 버전. 텍스트 출력 스트림에 객체들을 정형화된 텍스트로 쓰는 기능을 제공한다.
    </details>
            
            
</details>

<hr>

<details>
    <summary>파일 관련</summary>
    <details>
        <summary>@FunctionalInterface interface FileFilter Since 1.2</summary>
        <ol>
            <li>파일 패스 필터링에 사용되며 File::listFiles의 매개변수로 객체가 넘겨진다.
                <button type="button" class="btn btn-primary btn-sm btn-code" path="Java/JavaSE/src/io/FileFilterExample.java" lan="java">예시 코드 »</button></li>
        </ol>
        <details>
            <summary>Method Detail</summary>
            <ol>
                <li>boolean accept(File pathname)</li>
            </ol>
        </details>
    </details>
    
    <details>
        <summary>@FunctionalInterface interface FilenameFilter Since 1.0</summary>
        <ol>
            <li>특정 디렉터리에서의 파일명 필터링에 사용되며 FileDialog::setFilenameFilter, File::list, File::listFiles의 매개변수로 객체가 넘겨진다.
                <button type="button" class="btn btn-primary btn-sm btn-code" path="Java/JavaSE/src/io/FilenameFilterExample.java" lan="java">예시 코드 »</button></li>
        </ol>
        <details>
            <summary>Method Detail</summary>
            <ol>
                <li>boolean accept(File dir, String name)</li>
            </ol>
        </details>
    </details>


</details>

<hr>

<details>
    <summary>class PrintStream extends FilterOutputStream implements Appendable, Closeable Since 1.0</summary>
    <ol>
        <li>OutputStream에 기본 타입 및 각종 문자열을 쓰는 기능을 제공한다.</li>
        <li>public PrintStream(OutputStream out)</li>
        <li>public PrintStream(OutputStream out, boolean autoFlush)</li>
        바이트 배열을 다 쓰거나, 새 줄 문자, '\n'을 쓰면 자동으로 flush()
        <li>public PrintStream(OutputStream out, boolean autoFlush, String encoding) Since 1.4</li>
        <li>public PrintStream(OutputStream out, boolean autoFlush, Charset charset) Since 10</li>
        <li>public PrintStream(String fileName) Since 1.5</li>
        <li>public PrintStream(String fileName, String csn) Since 1.5 » csn = charset 이름</li>
        <li>public PrintStream(String fileName, Charset charset) Since 10</li>
        <li>public PrintStream(File file) Since 1.5</li>
        <li>public PrintStream(File file, String csn) Since 1.5</li>
        <li>public PrintStream(File file, Charset charset) Since 10</li>
        <li>boolean checkError()</li>
        flush()한 다음 오류 상태를 검사한다. 예외를 던지지 않으므로 이 메서드로 확인해야 한다. 스트림에 InterruptedIOException이 발생하면 Thread.currentThread().interrupt()를 실행한다.
        <li>protected void setError Since 1.1</li>
        에러 상태를 true로 한다.
        <li>protected void clearError Since 1.6</li>
        에러 상태를 초기화한다.
        <li>각종 print(), println(), append()</li>
        void print(Object obj) == print(String.valueOf(Object))
        <li>PrintStream printf(String format, Object... args) Since 1.5</li>
        <li>PrintStream printf(Locale l, String format, Object... args) Since 1.5</li>
        <li>PrintStream format(String format, Object... args) Since 1.5</li>
        <li>PrintStream format(Locale l, String format, Object... args) Since 1.5</li>
    </ol>
</details>

<hr>

<details>
    <summary>class PipedInputStream extends InputStream Since 1.0</summary>
    <ol>
        <li>PipedOutputStream과 연결되어 바이트들을 받는 InputStream. PipedOutputStream과 별개의 스레드에서 동작해야 한다.
            <button type="button" class="btn btn-primary btn-sm btn-code" path="Java/JavaSE/src/io/PipedStreamExample.java" lan="java">예시 코드 »</button></li>
        <li>public PipedInputStream(PipedOutputStream src)</li>
        <li>public PipedInputStream(PipedOutputStream src, int pipeSize) Since 1.6</li>
        <li>public PipedInputStream()</li>
        <li>public PipedInputStream(int pipeSize) Since 1.6</li>
        <li>void connect(PipedOutputStream src)</li>
    </ol>
</details>

<hr>

<details>
    <summary>class PipedOutputStream extends OutputStream Since 1.0</summary>
    <ol>
        <li>연결된 PipedInputStream으로 바이트들을 보내는 OutputStream. PipedInputStream과 별개의 스레드에서 동작해야 한다.
            <button type="button" class="btn btn-primary btn-sm btn-code" path="Java/JavaSE/src/io/PipedStreamExample.java" lan="java">예시 코드 »</button></li>
        <li>public PipedOutputStream(PipedInpuStream snk)</li>
        <li>public PipedOutputStream()</li>
        <li>void connect(PipedInputStream snk)</li>
    </ol>
</details>

<hr>

<details>
    <summary>class PipedReader extends Reader Since 1.1</summary>
    PipedInputStream과 유사. <button type="button" class="btn btn-primary btn-sm btn-code" path="Java/JavaSE/src/io/PipedReaderExample.java" lan="java">예시 코드 »</button>
</details>

<hr>

<details>
    <summary>class PipedWriter extends Writer Since 1.1</summary>
    PipedOutputStream과 유사. <button type="button" class="btn btn-primary btn-sm btn-code" path="Java/JavaSE/src/io/PipedReaderExample.java" lan="java">예시 코드 »</button>
</details>

<hr>

<details>
    <summary>class SequenceInputStream extends InputStream Since 1.0</summary>
    <ol>
        <li>여러 InputStream을 이어붙인듯이 활용하는 InputStream.</li>
        <li>public SequenceInputStream(Enumeration&lt;? extends InputStream&gt; e)</li>
        <li>public SequenceInputStream(InputStream s1, InputStream s2)</li>
    </ol>
</details>

<hr>

<details>
    <summary>class PushbackInputStream extends FilterInputStream Since 1.0</summary>
    <ol>
        <li>이미 읽은 것을 취소하고 다시 읽을 수 있는 기능을 지원한다. 이전에 읽은 내용을 저장하지는 않으므로, 덮어쓰기처럼 이용할 수 있다.
            <button type="button" class="btn btn-primary btn-sm btn-code" path="Java/JavaSE/src/io/PushBackExample.java" lan="java">예시 코드 »</button></li>
        <li>public PushbackInputStream(InputStream in, int size) Since 1.1</li>
        <li>public PushbackInputStream(InputStream in) Since 1.1 : 1바이트짜리 버퍼를 이용한다.</li>
        <li>void unread(int b) : 하위 8비트만 버퍼에 쓴다.</li>
        <li>void unread(byte[] b), unread(byte[] b, int off, int len) Since 1.1</li>
    </ol>
</details>

<hr>

<details>
    <summary>class PushbackReader extends FilterReader Since 1.1</summary>
    PushbackInputStream과 비슷.<button type="button" class="btn btn-primary btn-sm btn-code" path="Java/JavaSE/src/io/PushBackExample.java" lan="java">예시 코드 »</button>
</details>

<hr>

<details>
    <summary>class ObjectInputStream extends InputStream implements ObjectInput, ObjectStreamConstants Since 1.1</summary>
    객체 읽기에 관한 InputStream. <button type="button" class="btn btn-primary btn-sm btn-code" path="Java/JavaSE/src/io/SerializableExample.java" lan="java">예시 코드 »</button>
</details>

<hr>

<details>
    <summary>class ObjectOutputStream extends OutputStream implements OjbectOutput, ObjectStreamConstants Since 1.1</summary>
    객체 쓰기에 관한 OutputStream. <button type="button" class="btn btn-primary btn-sm btn-code" path="Java/JavaSE/src/io/SerializableExample.java" lan="java">예시 코드 »</button>
</details>

<hr>

<details>
    <summary>final class Console implements Flushable Since 1.6</summary>
    <ol>
        <li>JVM이 컨트롤할 수 있는 문자 기반 콘솔에 대한 접근 제공. 콘솔 존재 여부는 하위 플랫폼에 의존적이며, 싱글톤으로 System.console()을 통해 얻을 수 있다. 만일 가용한 콘솔이 없다면 null이 넘겨진다.</li>
        <li>콘솔에 대한 읽기/쓰기 작업은 모두 원자 단위로 이루어지며, 따라서 다른 스레드가 대기할 가능성이 있다.</li>
        <li>콘솔에 대한 close()는 실제로 아무런 영향을 미치지 않는다.</li>
        <li>유닉스의 Ctrl+D, 윈도우의 Ctrl+Z와 같은 종료 문자를 만나면 읽기 메서드는 null을 반환한다.</li>
        <li>보안 유의 : 패스워드와 같은 중요한 데이터를 읽어들일 때, readPassword(), readPassword(String, Object...) 메서드를 이용하고, 반환된 char[]를 수동으로 0 초기화한다.</li>
        <button type="button" class="btn btn-primary btn-sm btn-code" path="Java/JavaSE/src/io/ConsoleExample.java" lan="java">예시 코드 »</button>
        <li>PrintWriter writer() : 유니크한 PrintWriter 객체 반환</li>
        <li>Reader reader() : 유니크한 Reader 객체 반환</li>
        <li>Console format(String fmt, Object... args)</li>
        <li>Console printf(String format, Object... args)</li>
        <li>String readLine(String fmt, Object... args)</li>
        <li>String readLine()</li>
        <li>char[] readPassword(String fmt, Object... args)</li>
        <li>char[] readPassword()</li>
    </ol>
</details>

<hr>

<details>
    <summary>class File implements Serializable, Comparable<File> Since 1.0</summary>
    <ol>
        <li>추상화된 파일 및 디렉터리 경로에 대한 추상화된 표현 제공.(물리적 저장 장치 » 경로 문자열 » File 객체)</li>
        <li>경로 문자열은 절대 경로, 상대 경로 둘 다 허용된다. 상대 경로의 기준 위치는 System속성 "user.dir"로 얻을 수 있다.</li>
        <li>보다 많은 기능을 제공하는 java.nio.file 패키지가 존재한다.</li>
        <li>public static final char separatorChar, String separator</li>
        시스템 속성 "file.separator", UNIX : '/', Windows : '\\'
        <li>public static final char pathSeparatorChar, String pathSeparator</li>
        시스템 속성 "path.separator", UNIX : ':', Windows : ';'
        <li>public File(URI uri) Since 1.4 // 기타 생성자 생략</li>
        file 스킴으로 시작하는 uri를 통해 객체를 초기화한다. uri 형식은 시스템에 따라 다를 수 있다.
        <li>String getParent(), File getParentFile() Since 1.2</li>
        <li>String getPath(), String getAbsolutePath(), File getAbsoluteFile() Since 1.2</li>
        <li>String getCanonicalPath() Since 1.1, File getCanonicalFile() Since 1.2</li>
        <li>boolean isAbsolute(), canRead(), exists(), isDirectory(), isHidden(), canExecute() 등</li>
        <li>long lastModified(), long length()</li>
        <li>boolean createNewFile(), mkdir(), delete(), renameTo(File dest), setLastModified(long time)</li>
        <li>boolean mkdirs() : 경로상 필요한 모든 디렉터리들 생성</li>
        <li>boolean setReadOnly(), setWritable(~), setReadable(~), setExecutable(~) Since 1.6</li>
        <li>String[] list(), list(FilenameFilter filter)</li>
        <li>File[] listFiles(), listFiles(FilenameFilter filter), listFiles(FileFilter filter) Since 1.2</li>
        <button type="button" class="btn btn-primary btn-sm btn-code" path="Java/JavaSE/src/io/FileFilterExample.java" lan="java">FileFilter 예시 코드 »</button>
        <button type="button" class="btn btn-primary btn-sm btn-code" path="Java/JavaSE/src/io/FilenameFilterExample.java" lan="java">FilenameFilter 예시 코드 »</button>
        <li>static File[] listRoots() Since 1.2</li>
        <li>long getTotalSpace(), getFreeSpace(), getUsableSpace() Since 1.6</li>
        <li>static File createTempFile(String prefix, String suffix, File directory) Since 1.2</li>
        <li>static File createTempFile(String prefix, String suffix) Since 1.2</li>
        특정 디렉터리에 새로운 빈 파일을 만들어 반환한다. 이 메서드는 오직 임시 파일 작업을 위해 만들어졌으며, deleteOnExit()을 통해 자동으로 정리되어야 한다.<br>
        prefix : 의미 있는 접두어, suffix : null이면 ".tmp"
        <li>void deleteOnExit() Since 1.2</li>
        <li>int hashCode() : 추상 경로이름과 1234321 사이의 xor 연산</li>
        <li>URI toURI() Since 1.4, java.nio.file.Path toPath() Since 1.7</li>
        <button type="button" class="btn btn-primary btn-sm btn-code" path="Java/JavaSE/src/io/FileExample.java" lan="java">File 예시 코드 »</button>
    </ol>
</details>

<hr>

<details>
    <summary>class FileInputStream extends InputStream Since 1.0</summary>
    <ol>
        <li>FileInputStream(String name)<br>
            FileInputStream(File file)<br>
            FileInputStream(FileDescriptor fdObj)</li>
        <li>FileChannel getChannel() Since 1.4</li>
        유니크한 FileChannel을 반환하며, 채널에서의 위치는 스트림에서 읽어들인 만큼과 같다.
        <li>final FileDescriptor getFD()</li>
</details>

<hr>

<details>
    <summary>class FileOutputStream extends OutputStream Since 1.0</summary>
    <ol>
        <li>FileOutputStream(String name)<br>
            FileOutputStream(String name, boolean append)<br>
            FileOutputStream(File file)<br>
            FileOutputStream(File file, boolean append)<br>
            FileOutputStream(FileDescriptor fdObj)</li>
        파일에 대한 새로운 OutputStream을 생성한다. 파일과의 연결에 대한 새 FileDescriptor 객체가 생성되고, 파일의 처음부터 쓰기 시작한다.<br>
        Security manager가 있으면 checkWrite 메서드로 권한을 검사한다.</li>
        <li>final FileDescriptor getFD()</li>
        <li>FileChannel getChannel() Since 1.4</li>
        유니크한 FileChannel을 반환하며, 채널에서의 위치는 스트림에서 쓴 바이트 수와 같다(append 모드가 아닐 경우). append 모드에서는 파일의 크기와 채널의 위치가 동일하다.
    </ol>
</details>

<hr>

<details>
    <summary>class FileReader extends InputStreamReader Since 1.1</summary>
    FileReader(String fileName)<br>
    FileReader(File file)<br>
    FileReader(FileDescriptor fd)<br>
    FileReader(String fileName, Charset charset) Since 11<br>
    FileReader(File file, Charset charset) Since 11
</details>

<hr>

<details>
    <summary>class FileWriter extends OutputStreamWriter Since 1.1</summary>
    FileWriter(String fileName)<br>
    FileWriter(String fileName, boolean append)<br>
    FileWriter(File file)<br>
    FileWriter(File file, boolean append) Since 1.4<br>
    FileWriter(FileDescriptor fd)<br>
    FileWriter(String fileName, Charset charset) Since 11<br>
    FileWriter(String fileName, Charset charset, boolean appedn) Since 11<br>
    FileWirter(File file, Charset charset) Since 11<br>
    FileWriter(File file, Charset charset, boolean append) Since 11
</details>

<hr>

<details>
    <summary>final class FilePermission extends Permission implements Serializable Since 1.2</summary>
    <ol>
        <li>파일 및 디렉터리에 관한 권한을 표현하는 클래스.
            <button type="button" class="btn btn-primary btn-sm btn-code" path="Java/JavaSE/src/io/FilePermissionExample.java" lan="java">예시 코드 »</button></li>
        <ul>
            <li>"/*"로 끝나는 경로는 해당 디렉터리 내부 모든 파일 및 디렉터리를 가리킨다. "*"는 현재 디렉터리 내부.</li>
            <li>"/-"로 끝나는 경로는 해당 디렉터리 내부 모든 파일 및 모든 서브디렉터리를 가리킨다. "-"는 현재 디렉터리 내부.</li>
            <li>"&lt;&lt;ALL FILES&gt;&gt;"로 표현된 경로는 임의 파일과 대응한다.</li>
            <li>권한 리스트는 콤마로 구분한 문자열로 표현한다.</li>
            가능한 키워드는 "read", "write", "execute"(Runtime.exec 메서드 호출 관련), "delete"(File.delete 메서드 호출 관련), "readlink"(java.nio.file.Files.readSymbolicLink 메서드와 관련)
            <li>주의 : 임의 파일에 대한 권한은 보안상 위험하다. 기본적으로 코드가 포함된 디렉터리는 읽기가 가능하므로 굳이 권한을 부여할 필요 없다.</li>
        </ul>
        <li>FilePermission(String path, String actions)</li>
        시스템 속성 "jdk.io.permissionsUseCanonicalPath"가 매개변수 path의 처리에 대해 기술한다.
        <a role="button" target="_blank" class="btn btn-info btn-sm" href="https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/io/FilePermission.html#%3Cinit%3E(java.lang.String,java.lang.String)">자세히</a>
        <li>boolean implies(Permission p) : 객체의 권한이 인자의 권한을 내포하는지 여부 반환</li>
        <li>String getActions()</li>
        <li>PermissionCollection newPermissionCollection()</li>
        예. 컬렉션에 다음 두 가지 권한─("/tmp/-", "read"), ("/tmp/scratch/foo", "write")─들이 있을 때, 이에 대한 implies메서드에 권한 ("/tmp/scratch/foo", "read,write")을 넘겨준 결과는 true를 반환해야 한다.
    </ol>
</details>

<hr>

<details>
    <summary>class RandomAccessFile implements DataOutput, DataInput, Closeable Since 1.0</summary>
    <ol>
        <li>읽기/쓰기 가능한 임의 접근 파일. 읽기/쓰기의 기준 위치 file pointer가 존재.</li>
        읽기로 예정된 바이트들을 모두 읽기 전에 EOF를 만나면 EOFException 발생.</li>
        <li>RandomAccessFile(String name, String mode)<br>
            RandomAccessFile(File file, String mode)</li>
        mode » "r", "rw", "rws"(파일 내용 및 메타데이터 변경을 곧바로 반영), "rwd"(파일 내용 변경을 곧바로 반영)
        <li>final FileDescriptor getFD()</li>
        <li>final FileChannel getChannel() Since 1.4</li>
        <li>int read() : InputStream.read()와 동일<br>
            int read(byte[] b)<br>
            int read(byte[] b, int off, int len)<br>
            final void readFully(byte[] b)<br>
            readFully(byte[] b, int off, int len)</li>
        <li>long getFilePointer()</li>
        <li>void seek(long pos) : file pointer 설정</li>
        <li>long length()</li>
        <li>void setLength(long newLength) Since 1.2</li>
        기존 크기 &gt; newLength and getFilePointer() &gt; newLength → 자르고, file pointer = newLength<br>
        기존 크기 &lt; newLength → 확장. 확장한 영역의 데이터는 초기화되지 않는다.
    </ol>
</details>

<hr>