<hr>

<details>
    <summary>org.apache.commons.lang3 Since 1.0</summary>
    <details>
        <summary>class AnotationUtils Since 3.0</summary>
        <ol>
            <li>스레드-안전. 애너테이션 (프록시) 인스턴스에 관한 유틸리티를 제공한다</li>
            <li>static boolean equals(Annotation a1, Annotation a2) : Annotation.equals(Object)의 문서대로 처리해준다</li>
            <li>static int hashCode(Annotation a) : Annotation.hashCode()의 문서대로 처리해준다</li>
            <li>static String toString(Annotation a) : Annotation.toString()의 문서대로 처리해준다</li>
            <li>static boolean isValidAnnotationMemberType(Class&lt;?&gt; type)</li>
        </ol>
    </details>
    <details>
        <summary>class ArchUtils Since 3.6</summary>
        <ol>
            <li>java.lang.System "os.arch" 프로퍼티에 관한 유틸리티를 제공한다</li>
            <li>static Processor getProcessor() : 현재 JVM의 프로세서 정보를 반환</li>
            <li>static Processor getProcessor(String value) : value는 "os.arch" 프로퍼티의 반환값과 유사해야 한다</li>
        </ol>
    </details>
    <details>
        <summary>class ArrayUtils Since 2.0</summary>
        <ol>
            <li>스레드-안전. null에 관대한 배열 유틸리티를 제공한다.</li>
            <li>public static final Object[] EMPTY_OBJECT_ARRAY</li>
            <li>public static final Class&lt;?&gt;[] EMPTY_CLASS_ARRAY</li>
            <li>public static final long[] EMPTY_LONG_ARRAY</li>
            <li>public static final Long[] EMPTY_LONG_OBJECT_ARRAY + 이하 생략</li>
        </ol>
        <details>
            <summary>Method Detail</summary>
            <ol>
                <li>static &lt;T&gt; boolean isArrayIndexValid(T[] array, int index) Since 3.8</li>
                <li>static String toString(Object array, String stringIfNull) + 1 오버로딩 + toStringArray</li>
                <li>static int hashCode(Object array)</li>
                <li>static Map&lt;Object, Object&gt; toMap(Object[] array)</li>
                각 원소는 Map.Entry거나 배열이여야 하며, 배열인 경우 원소가 2개 이상 있어야 한다(1번째는 키, 2번째는 값)
                <li>static &lt;T&gt; T[] toArray(T... items) Since 3.0</li>
                <li>static &lt;T&gt; T[] clone(T[] array) : 얕은 복사 수행 + 8 오버로딩</li>
                <li>static &lt;T&gt; T[] nullToEmpty(T[] array, Class&lt;T[]&gt; type) Since 3.5 + 19 오버로딩</li>
                방어적 프로그래밍 기법 : array가 null이면 같은 타입의 빈 배열을 반환한다. null이 아니면 그대로 반환.
                <li>static &lt;T&gt; T[] subarray(T[] array, int startIndexInclusive, int endIndexExclusive) Since 2.1 + 8 오버로딩</li>
                <li>static boolean isSameLength(Object[] array1, Object[] array2) : null은 카운트 제외 + 8 오버로딩</li>
                <li>static int getLength(Object array) Since 2.1 : null이면 0</li>
                <li>static boolean isSameType(Object array1, Object array2)</li>
                배열이 같은 타입인지 반환한다. 다차원 배열 타입도 처리된다
                <li>static void shuffle(Object[] array) Since 3.6 + 오버로딩</li>
                <li>static void reverse(Object[] array, int startIndexInclusive, int endIndexExclusive) + 17 오버로딩</li>
                <li>static void swap(Object[] array, int offset1, int offset2, int len) Since 3.5 + 17 오버로딩</li>
                array가 null이거나, 인덱스가 오버플로된 경우 작업을 하지 않는다. 음수 인덱스는 0으로 간주한다
                <li>static void shift(Object[] array, int startIndexInclusive, int endIndexExclusive, int offset) Since 3.5 + 17 오버로딩</li>
                <li>static int indexOf(Object[] array, Object objectToFind, int startIndex) + 19 오버로딩 + lastIndexOf, contains</li>
                null에 대하여 INDEX_NOT_FOUND(-1)를 반환한다
                <li>static char[] toPrimitive(Character[] array, char valueForNull) + 오버로딩</li>
                <li>static Character[] toObject(char[] array) + 오버로딩</li>
                <li>static boolean isEmpty(Object[] array) Since 2.1 : null이면 true + 오버로딩 + isNotEmpty</li>
                <li>static &lt;T&gt; T[] addAll(T[] array1, T... array2) Since 2.1 + 오버로딩</li>
                + add, remove, removeElement, removeAll, removeElements, removeAllOccurences, insert
                <li>static &lt;T&gt; boolean isSorted(T[] array, Comparator&lt;T&gt; comparator) Since 3.4 + 오버로딩</li>
            </ol>
        </details>
    </details>
    <details>
        <summary>class BitField Since 2.0</summary>
        <ol>
            <li>클래스 인스턴스 내부에 비트값들을 저장하지 않고, 외부 int, short, byte에 대한 마스킹 연산을 지원한다</li>
            <li>public BitField(int mask)
                <button class="btn-code" path="Repositories/Eclipse/apache-commons-lang-example/src/test/java/BitFieldTest.java" lan="java">예시 코드 »</button></li>
        </ol>
        <details>
            <summary>Method Detail</summary>
            <ol>
                <li>int getValue(int holder)</li>
                마스크 비트에 해당하는 비트들을 우측으로 시프트하여 값 반환
                <li>int getRawValue(int holder)</li>
                마스크 비트에 해당하는 비트들의 위치 그대로 값 반환
                <li>int set(int holder) + clear</li>
                <li>int setValue(int holder, int value)</li>
                마스크 비트에 value를 설정한 후의 값을 반환
                <li>boolean isSet(int holder) + isAllSet</li>
                마스크 비트에 해당하는 비트들 중 하나라도 설정되었다면 true
            </ol>
        </details>
    </details>
    <details>
        <summary>class BooleanUtils Since 2.0</summary>
        <ol>
            <li>스레드-안전. boolean, Boolean에 관한 유틸리티 제공</li>
            <li>static Boolean negate(Boolean bool) + isTrue, isNotTrue, isFalse, isNotFalse</li>
            <li>static boolean toBoolean(Boolean bool, boolean valueIfNull)</li>
            <li>static boolean toBoolean(int value) + toBooleanObject, toInteger</li>
            <li>static boolean toBoolean(String str) + 오버로딩</li>
            대소문자 무관. true : "true", "on", "y", "t", "yes". toBooleanObject(String)에서는 키워드 외의 문자열에 대해서 null 반환
            <li>static String toStringTrueFalse(boolean bool) + toStringOnOff, toStringYesNo</li>

            <li>static boolean and(boolean... array) Since 3.0.1 + or, xor</li>
        </ol>
    </details>
    <details>
        <summary>class ClassPathUtils Since 3.3</summary>
        <ol>
            <li>static String toFullyQualifiedName(Class&lt;?&gt; context, String resourceName) + 오버로딩</li>
            ClassPathUtils.toFullyQualifiedName(StringUtils.class, "StringUtils.properties") == "org.apache.commons.lang3.StringUtils.properties"
            <li>static String toFullyQualifiedPath(Class&lt;?&gt; context, resourceName) + 오버로딩</li>
            ClassPathUtils.toFullyQualifiedPath(StringUtils.class, "StringUtils.properties") == "org/apache/commons/lang3/StringUtils.properties"
        </ol>
    </details>
    <details>
        <summary>class Functions</summary>
        <ol>
            <li>예외를 허용하는 함수 유틸리티. 내부에서 발생한 예외는 RuntimeException으로 감싸여 전달된다</li>
            <li>@FunctionalInterface static interface Functions.FailableConsumer&lt;O, T extends Throwable&gt;</li>
            <li>@FunctionalInterface static interface Functions.FailableFunction&lt;I, O, T extends Throwable&gt;</li>
            <li>@FunctionalInterface static interface Functions.FailablePredicate&lt;O, T extends Throwable&gt;</li>
            <li>@FunctionalInterface static interface Functions.FailableRunnable&lt;T extends Throwable&gt;</li>
            <li>@FunctionalInterface static interface Functions.FailableCallable&lt;O, T extends Throwable&gt;</li>
            <li>@FunctionalInterface static interface Functions.FailableBiConsumer&lt;O1, O2, T extends Throwable&gt;</li>
            <li>@FunctionalInterface static interface Functions.FailableBiFunction&lt;I1, I2, O, T extends Throwable&gt;</li>
            <li>@FunctionalInterface static interface Functions.FailableBiPredicate&lt;O1, O2, T extends Throwable&gt;</li>
        </ol>
        <details>
            <summary>Method Detail</summary>
            <ol>
                <li>static &lt;T extends Throwable&gt; void run(Functions.FailableRunnable&lt;T&gt; pRunnable)</li>
                + call(Callable), accept(Consumer), apply(Function), test(Predicate)

                <li>@SafeVarargs static void tryWithResources(Functions.FailableRunnable&lt;? extends THrowable&gt; pAction, Functions.FailableRunnable&lt;? extends Throwable&gt;... pResources) + 1 오버로딩</li>
                AutoCloseable하지 않은 객체들에 대해, pAction 실행 후 성공/실패 여부와 무관하게 pResources가 제공된 순서대로 실행됨을 보장한다.

                <li>static RuntimeException rethrow(Throwable pThrowable)</li>
                사용 예시 : throw rethrow(e);
            </ol>
        </details>
    </details>
    <details>
        <summary>class ObjectUtils Since 1.0</summary>
        <ol>
            <li>스레드-안전. 객체 관련 유틸리티를 제공한다</li>
            <li>static boolean isEmpty(Object object) Since 3.9 + isNotEmpty</li>
            <ul>
                <li>CharSequence : length() == 0</li>
                <li>Array : length == 0</li>
                <li>Collection : size() == 0</li>
                <li>Map : size() == 0</li>
            </ul>
            <li>static &lt;T&gt; T defaultIfNull(T object, T defaultValue)</li>
            <li>@SafeVarargs static &lt;T&gt; T firstNonNull(T... values) Since 3.0</li>
            <li>static boolean anyNotNull(Object... values) Since 3.5 + allNotNull</li>
            <li>@SafeVarargs static &lt;T extends Comparable&lt;? super T&gt;&gt; T min (T... values)</li>
            + max, compare, median(중앙값), mode(최빈값)
        </ol>
    </details>
    <details>
        <summary>class RandomUtils Since 3.3</summary>
        <ol>
            <li>java.util.Random 인스턴스를 생성하는 귀찮음을 해소해줄 수 있다. 성능/정확성을 위해 <a role="button" target="_blank" class="btn btn-info btn-sm" href="https://commons.apache.org/proper/commons-rng/commons-rng-core/javadocs/api-1.2/overview-summary.html">Commons RNG</a>를 고려해봄이 좋다</li>
            <li>static boolean nextBoolean() Since 3.5</li>
            <li>static byte[] nextBytes(int count)</li>
            <li>static int nextInt(int startInclusive, int endExclusive) + 오버로딩 + long, double, float</li>
        </ol>
    </details>
    <details>
        <summary>class RandomStringUtils Since 1.0</summary>
        <ol>
            <li>스레드-안전. 간단한 랜덤 문자열 생성. 정교한 작업이 필요하다면 <a role="button" target="_blank" class="btn btn-info btn-sm" href="https://commons.apache.org/proper/commons-text/javadocs/api-release/">commons-text</a> RandomStringGenerator 이용</li>
            <li>static String random(int count) : 특정 길이 랜덤 문자열 반환</li>
            <li>static String randomAscii(int minLengthInclusive, int maxLengthExclusive) Since 3.5 + 오버로딩</li>
            <li>static String randomAlphabetic(int minLengthInclusive, int maxLengthExclusive) Since 3.5 + 오버로딩</li>
            <li>static String randomNumeric(int minLengthInclusive, int maxLengthExclusive) Since 3.5 + 오버로딩</li>
            <li>static String randomAlphanumeric(int minLengthInclusive, int maxLengthExclusive) Since 3.5 + 오버로딩</li>
            <li>static String randomGraph(int minLengthInclusive, int maxLengthExclusive) Since 3.5 + 오버로딩 + randomPrint</li>
            공백 문자를 제외한, 눈에 보이는 문자들(POSIX [:graph:] )로만 구성
            <li>static String random(int count, String chars) + 오버로딩</li>
            <li>이하 생략</li>
        </ol>
    </details>
    <details>
        <summary>final class Range&lt;T&gt; implements Serializable Since 3.0</summary>
        <ol>
            <li>스레드-안전. 비교 가능한 객체의 구간을 정의한다.</li>
            <li>static &lt;T&gt; Range&lt;T&gt; is(T element, Comparator&lt;T&gt; comparator) + 오버로딩</li>
            구간의 최소/최댓값 모두 element로 설정한 구간을 반환한다
            <li>static &lt;T&gt; Range&lt;T&gt; between(T fromInclusive, T toInclusive, Comparator&lt;T&gt; comparator) + 오버로딩</li>
            <li>T getMinimum() + getMaximum, getComparator</li>
            <li>boolean contains(T element)</li>
            + isBefore, isAfter, isStartedBy, isEndedBy, containsRange, isOverlappedBy, isBeforeRange, isAfterRange
            <li>int elementCompareTo(T element)</li>
            isBefore면 -1, contains면 0, isAfter면 1
            <li>Range&lt;T&gt; intersectionWith(Range&lt;T&gt; other) SInce 3.0.1</li>
        </ol>
    </details>
    <details>
        <summary>class RegExUtils Since 3.8</summary>
        <ol>
            <li>static String removeAll(String text, String regex) + 오버로딩</li>
            + removeFirst, removePattern(removeAll + Pattern.DOTALL 옵션), replaceAll, replaceFirst, replacePattern(replaceAll + Pattern.DOTALL 옵션)
        </ol>
    </details>
    <details>
        <summary>class SerializationUtils Since 1.0</summary>
        <ol>
            <li>스레드-안전. 직렬화/역직렬화 유틸리티 제공</li>
            <li>static &lt;T extends Serializable&gt; T clone(T object) : 직렬화를 이용한 depp clone</li>
            <li>static &lt;T extends Serializable&gt; T roundtrip(T msg) : 직렬화 후 역직렬화하여 반환</li>
            <li>static byte[] serialize(Serializable obj) + 오버로딩</li>
            <li>static &lt;T&gt; T deserialize(byte[] objectData) + 오버로딩</li>
        </ol>
    </details>
    <details>
        <summary>class StringUtils Since 1.0</summary>
        <ol>
            <li>스레드-안전. null 안전한 String 유틸리티 제공</li>

            <li>static String normalizeSpace(String str) Since 3.0</li>
            <li>static String repeat(String str, String separator, int repeat) Since 2.5 + 오버로딩</li>
            <li>static String rightPad(String str, int size) + leftPad</li>
            
            <li>static boolean isEmpty(CharSequence cs) Since 3.0 + 오버로딩</li>
            + isNotEmpty, isAnyEmpty, isNoneEmpty, isAllEmpty, isBlank(isEmpty 포함), isNotBlank, isAnyBlank, isNoneBlank, isAllBlank
            
            <li>static String trim(String str) : heading, trailing 제어 문자(ASCII &lt;= 32) 제거</li>
            + trimToNull(결과가 isBlank면 null), trimToEmpty, strip(공백 문자; Character::isWhitespace 또는 사용자 지정 문자 제거), stripToNull, stripToEmpty, stripStart, stripEnd, stripAll, stripAccents
            
            <li>static String truncate(String str, int maxWidth) Since 3.5 + 오버로딩</li>

            <li>static int compare(String str1, String str2, boolean nullIsLess) Since 3.5 + 오버로딩</li>
            <li>static boolean contains(CharSequence seq, CharSequence searchSeq) Since 3.0 + 오버로딩</li>
            + containsAny, containsOnly(검색 대상 문자들로만 구성됐는지 여부), containsNone, startWithAny, endsWithAny

            <li>static int indexOf(CharSequence seq, CharSequence searchSeq, int startPos) Since 3.0 + 오버로딩</li>
            + lastIndexOf, indexOfAny, indexOfAnyBut(검색 대상 문자에 해당하지 않는 최초의 인덱스)
            <li>static int ordinalIndexOf(CharSequence str, CharSequence searchStr, int ordinal) Since 3.0 + lastOrdinalIndexOf</li>
            ordinal번째로 검색된 위치를 반환

            <li>static String left(String str, int len) + right, mid, center, abbreviate</li>
            <li>static String substringBefore(String str, String separator) Since 2.0</li>
            + substringAfter, substringBeforeLast, substringAfterLast, substringBetween, substringsBetween

            <li>static String[] splitByWholeSeparator(String str, String separator, int max) + 오버로딩</li>
            + splitPreserveAllTokens, splitByWholeSeparatorPreserveAllTokens, splitByCharacterType

            <li>@SafeVarargs static &lt;T&gt; String join(T... elements) + 오버로딩</li>

            <li>static String deleteWhitespace(String str)</li>
            + removeStart, removeEnd, remove, replaceOnce, replaceEach, replaceEachRepeatedly(문자열이 containsNone을 만족할 때까지 반복), replaceChars

            <li>static String overlay(String str, String overlay, int start, int end) Since 2.0</li>
            str의 부분 문자열[start, end)을 overlay로 교체한다. start &gt; end인 경우 스왑된다.

            <li>static String rotate(String str, int shift) Since 3.5</li>
            + reverse, reverseDelimited

            <li>static String getCommonPrefix(String... strs) Since 2.4</li>
            <li>static String appendIfMissing(String str, CharSequence suffix, CharSequence... suffixes) Since 3.2 + prependIfMissing</li>
            <li>static String wrap(String str, String wrapWith) Since 3.4 + 오버로딩 + wrapIfMissing, unwrap</li>
        </ol>
    </details>
    <details>
        <summary>class SystemUtils Since 1.0</summary>
        <ol>
            <li>스레드-안전. java.lang.System에 관한 헬퍼 제공</li>
            <li>public static final String JAVA_HOME Since Java 1.1</li>
            <li>public static final String JAVA_IO_TMPDIR Since Java 1.2</li>
            <li>public static final String OS_ARCH Since Java 1.1</li>
            <li>public static final String USER_DIR Since Java 1.1</li>
            <li>public static final boolean IS_OS_WINDOWS Since 2.0 등</li>
        </ol>
    </details>
    <details>
        <summary>class ThreadUtils Since 3.5</summary>
        <ol>
            <li>스레드-안전. Thread, ThreadGroup에 관한 헬퍼 제공</li>
            <li>@FunctionalInterface static interface ThreadUtils.ThreadPredicate</li>
            boolean test(Thread thread)
            <li>@FunctionalInterface static interface ThreadUtils.ThreadGroupPredicate</li>
            boolean test(ThreadGroup threadGroup)
            <li>static class ThreadUtils.ThreadIdPredicate implements ThreadUtils.ThreadPredicate</li>
            <li>static class ThreadUtils.NamePredicate implements ThreadUtils.ThreadPredicate, ThreadUtils.ThreadGroupPredicate</li>
        </ol>
        <details>
            <summary>Method Detail</summary>
            <ol>
                <li>static Thread findThreadById(long threadId, ThreadGroup threadGroup) + 오버로딩</li>
                <li>static Collection&lt;Thread&gt; findThreadsByName(String threadName, ThreadGroup threadGroup) + 오버로딩</li>
                <li>static Collection&lt;ThreadGroup&gt; findThreadGroupsByName(String threadGroupName)</li>
                <li>static Collection&lt;ThreadGroup&gt; getAllThreadGroups()</li>
                <li>static ThreadGroup getSystemThreadGroup()</li>
                <li>static Collection&lt;Thread&gt; getAllThreads()</li>
                <li>static Collection&lt;Thread&gt; findThreads(ThreadGroup group, boolean recurse, ThreadUtils.ThreadPredicate predicate) + 오버로딩</li>
            </ol>
        </details>
    </details>
    <details>
        <summary>class Validate Since 2.0</summary>
        <ol>
            <li>스레드-안전. 인자 평가에 관한 유틸리티를 제공한다</li>
            <li>static void isTrue(boolean expression, String format, Object... values) + 오버로딩</li>
            <li>static &lt;T&gt; T notNull(T object, String format, Object... values) + 오버로딩</li>
            <li>static &lt;T&gt; T[] notEmpty(T[] array, String format, Object... values) + 오버로딩</li>
            <li>static &lt;T&gt; T[] noNullElements(T[] array, String format, Object... values) + 오버로딩</li>
            <li>static &lt;T&gt; T[] validIndex(T[] array, int index, String format, Object... values) Since 3.0 + 오버로딩</li>
            <li>static void matchesPattern(CharSequence input, String pattern) Since 3.0 + 오버로딩</li>
            <li>static &lt;T&gt; void inclusiveBetween(T start, T end, Comparable&lt;T&gt; value) Since 3.0 + 오버로딩 + exclusiveBetween</li>
            <li>static void isInstanceOf(Class&lt;?&gt; type, Object obj) Since 3.0 + 오버로딩</li>
            <li>static void isAssignableFrom(Class&lt;?&gt; superType, Class&lt;?&gt; type) Since 3.0 + 오버로딩</li>
        </ol>
    </details>
</details>

<hr>

<details>
    <summary>org.apache.commons.lang3.arch Since 3.6</summary>
    <details open>
        <summary>class Processor Since 3.6</summary>
        <ol>
            <li>static enum Processor.Arch : BIT_32, BIT_64, UNKNOWN</li>
            <li>static enum Processor.Type : IA_64, PPC, UNKNOWN, X86</li>
            <li>Processor.Arch getArch + getType</li>
            <li>boolean is32Bit() + is64Bit, isX86, ...</li>
        </ol>
    </details>
</details>

<hr>

<details>
    <summary>org.apache.commons.lang3.concurrent</summary>
    <details>
        <summary>CircuitBreaker</summary>
        <details>
            <summary>interface CircuitBreaker&lt;T&gt; Since 3.5</summary>
            <ol>
                <li><a role="button" target="_blank" class="btn btn-info btn-sm" href="https://martinfowler.com/bliki/CircuitBreaker.html">CircuitBreaker</a>는 외부 리소스의 가용 여부를 알려주는 역할을 한다.</li>
                리소스를 신뢰할 수 없는 상태로 변이되면 당분간 리소스에 대한 모든 요청을 즉시 거부하도록 고안된 개념이지만, 적절하게 알아서 구현하면 된다
                <li>회로에서 가져온 개념이므로 close가 가용, open이 불가를 의미한다</li>
                <li>boolean isOpen() + isClosed</li>
                <li>void close() + open</li>
                <li>boolean checkState()</li>
                가용 상태를 재확인하여 필요하다면 상태를 변경한다.
                <li>boolean incrementAndCheckState(T increment)</li>
                checkState()에 인자가 필요한 경우 이용한다
            </ol>
        </details>
        <details>
            <summary>abstract class AbstractCircuitBreaker&lt;T&gt; implements CircuitBreaker&lt;T&gt; Since 3.5</summary>
            <ol>
                <li>protected static enum AbstractCircuitBreaker.Stage : CLOSED, OPEN</li>
                <li>void addChangeListener(PropertyChangeListener listener)</li>
                <li>void removeChangeListener(PropertyChangeListener listener)</li>
            </ol>
        </details>
        <details>
            <summary>class EventCountCircuitBreaker extends AbstractCircuitBreaker&lt;Integer&gt; Since 3.5</summary>
            <ol>
                <li>카운트와 인터벌을 가지고 아래와 같은 서비스를 제공할 수 있다. 카운팅은 외부에서 직접해야함에 유의</li>
                <ul>
                    <li>n개 이상의 실패가 발생하면 상태를 OPEN으로 천이</li>
                    <li>n분 동안 m개 이상의 실패가 발생하면 l분간 상태를 OPEN으로 천이.</li>
                    <li>분당 요청이 n개 이하로 떨어지면 상태를 CLOSED로 천이</li>
                </ul>
                <li>public EventCountCircuitBreaker(int threshold, long checkInterval, TimeUnit checkUnit)</li>
                기준 이벤트 카운트/인터벌 모두 공유. 초당 최대 5개의 처리를 하는
                <button class="btn-code" path="Repositories/Eclipse/apache-commons-lang-example/src/test/java/EventCountCircuitBreakerTest.java" displayRange="[11,32]" lan="java">예시 »</button>
                <li>public EventCountCircuitBreaker(int openingThreshold, long checkInterval, TimeUnit checkUnit, int closingThreshold)</li>
                기준 인터벌을 공유. 초당 5개 이상의 요청이 발생하면 OPEN, 초당 2개 이하로 떨어지면(부정확) CLOSE하는
                <button class="btn-code" path="Repositories/Eclipse/apache-commons-lang-example/src/test/java/EventCountCircuitBreakerTest.java" displayRange="[34,61]" lan="java">예시 »</button>
                <li>public EventCountCircuitBreaker(int openingThreshold, long openingInterval, TimeUnit openingUnit, int closingThreshold, long closingInterval, TimeUnit closingUnit)</li>
                초당 5번 이상 실패하면 2초간 OPEN하는
                <button class="btn-code" path="Repositories/Eclipse/apache-commons-lang-example/src/test/java/EventCountCircuitBreakerTest.java" displayRange="[63,90]" lan="java">예시 »</button>
            </ol>
        </details>
    </details>

    <details>
        <summary>Initializer</summary>
        <details>
            <summary>interface ConcurrentInitializer&lt;T&gt; Since 3.0</summary>
            <ol>
                <li>스레드-안전한 초기화 로직을 의미한다</li>
                <li>T get() throws ConcurrentException</li>
            </ol>
        </details>
        <details>
            <summary>abstract class AtomicInitializer&lt;T&gt; implements ConcurrentInitializer&lt;T&gt; Since 3.0</summary>
            <ol>
                <li>『Effective Java』에서 소개하는 <button class="btn-code" path="posts/java/effective_java.html" lan="nohighlight">객체 필드 초기화 지연</button>과 유사한 형태의 로직으로, AtomicReference를 이용해 단 한 번만 객체가 초기화됨을 보장한다</li>
                <li>protected abstrct T initialize() throws ConcurrentException</li>
            </ol>
        </details>
        <details>
            <summary>abstract class AtomicSafeInitializer&lt;T&gt; implements ConcurrentInitializer&lt;T&gt; Since 3.0</summary>
            AtomicInitializer와 다르가 initialize()가 단 한 번만 호출됨이 보장된다
        </details>
        <details>
            <summary>abstract class BackgroundInitializer&lt;T&gt; implements ConcurrentInitializer&lt;T&gt; Since 3.0</summary>
            <ol>
                <li>내부적으로 ExecutorService와 Future를 이용해 백그라운드 초기화 작업을 지원한다.</li>
                start()로 초기화를 다른 스레드에서 시작시키고, get()을 통해 블로킹할 수 있다.
                <li>final ExecutorService getExternalExecutor() + setExternalExecutor</li>
                <li>boolean start()</li>
                단 한 번만 실행됨이 보장된다. 최초에만 true, 나머지는 false 반환.
                <li>boolean isStarted() == (future != null)</li>
                <li>Future&lt;T&gt; getFuture()</li>
                <li>protected 메서드 생략</li>
            </ol>
        </details>
        <details>
            <summary>class CallableBackgroundInitializer&lt;T&gt; extends BackgroundInitializer&lt;T&gt; Since 3.0</summary>
            Callable을 이용한 BackgroundInitializer 콘크리트 클래스
        </details>
        <details>
            <summary>class ConstantInitializer&lt;T&gt; implements ConcurrentInitializer&lt;T&gt; Since 3.0</summary>
            항상 같은 객체/값을 반환하는 ConcurrentInitializer 콘크리트 클래스
        </details>
    </details>

    <details>
        <summary>ThreadFactory</summary>
        <details>
            <summary>class BasicThreadFactory implements ThreadFactory Since 3.0</summary>
            <ol>
                <li>내부 ThreadFactory가 생성한 스레드에 특정 속성들을 설정하여 관리하기 편하게 해준다.</li>
                <li>namingPattern에는 포맷 문자열을 이용하면 된다. %d에는 스레드 번호가 할당된다.</li>
                스레드 번호는 내부적으로 관리되는 총 생성 스레드 수와 관계가 있다
                <li>long getThreadCount() + 이하 생략</li>
            </ol>
            <details>
                <summary>static class BasicThreadFactory.Builder implements Builder&lt;BasicThreadFactory&gt;</summary>
                <ol>
                    <li>BasicThreadFactory.Builder wrappedFactory(ThreadFactory factory)</li>
                    <li>BasicThreadFactory.Builder namingPattern(String pattern)</li>
                    <li>BasicThreadFactory.Builder daemon(boolean daemon)</li>
                    <li>BasicThreadFactory.Builder uncaughtExceptionHandler(Thread.UncaughtExceptionHandler handler)</li>
                    <li>void reset() : build() 호출 시 빌드 후 자동으로 호출된다</li>
                </ol>
            </details>
        </details>
    </details>

    <details>
        <summary>interface Computable&lt;I, O&gt; Since 3.6</summary>
        O compute(I arg) throws InterruptedException
    </details>

    <details>
        <summary>class ConcurrentUtils Since 3.0</summary>
    </details>
</details>