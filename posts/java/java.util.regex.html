<hr>

<details>
    <summary>interface MatchResult Since 1.5</summary>
    <ol>
        <li>정규표현식 매칭 결과. group의 의미에 대해선 Pattern 참고.</li>
        <li>int start() : 매치된 결과의 시작 인덱스 반환</li>
        <li>int start(int group) : group번째 매치된 결과의 시작 인덱스 반환</li>
        <li>int end() : 매치된 결과의 마지막 글자 다음 인덱스 반환</li>
        <li>int end(int group) : group번째 매치된 결과의 마지막 글자 다음 인덱스 반환</li>
        <li>String group() : 이전 매치된 결과 반환</li>
        <li>String group(int group) : group번째 매치된 결과 반환</li>
        <li>int groupCount() : 매치된 group 개수 반환<button type="button" class="btn btn-primary btn-sm btn-code" path="Java/JavaSE/src/regex/MatchResultExample.java" lan="java">예시 코드 »</button></li>
    </ol>
</details>

<hr>

<details>
    <summary>final class Pattern implements Serializable Since 1.4</summary>
    <ol>
        <li>정규표현식의 컴파일된 표현</li>
        <li>Groups and capturing</li>
        괄호 여는 순서에 따라 capturing group의 숫자가 매겨진다. ((A)(B(C)))에 대하여, 0: ((A)(B(C))), 1: (A), 2: (B(C)), 3: (C)의 4가지 그룹이 존재하며, 0번 그룹은 항상 전체 표현을 가리킨다.
    </ol>

    <details>
        <summary>정규표현식 문자 표현</summary>
        <ol>
            <li>x » 문자 x 자체</li>
            <li>\\ » 백슬래시 문자</li>
            <li>\0n 또는 \0nn 또는 \0mnn» » 8진수 표현 문자(m &lt;= 3)</li>
            <li>\xhh 또는 \uhhhh 또는 \u{h...h} » 16진수 표현 문자</li>
            <li>\N{name} » 유니코드 이름으로 표현된 문자</li>
            <li>\t » 탭 \u0009</li>
            <li>\n » newline \u000A</li>
            <li>\r » carriage-return \u000D</li>
            <li>\f » form-feed \u000C</li>
            <li>\a » alert \u0007</li>
            <li>\e » escape \u001B</li>
            <li>\cx » x에 관한 제어 문자</li>
        </ol>
    </details>

    <details>
        <summary>정규표현식 문자 집합 표현</summary>
        <ol>
            <li>[abc] » a, b, or c(단순 집합)</li>
            <li>[^abc] » a, b, c를 제외한 임의 문자(여집합)</li>
            <li>[a-zA-Z] » a ~ z or A ~ Z, inclusive(범위)</li>
            <li>[a-d[m-p]] » a ~ d or m ~ p : [a-dm-p](합집합)</li>
            <li>[a-z&amp;&amp;[def]] » d, e, or f(교집합)</li>
            <li>[a-z&amp;&amp;[^bc]] » a ~ z &amp;&amp; b와 c는 제외(차집합)</li>
            <li>[a-z&amp;&amp;[^m-p]] » a ~ z &amp;&amp; m ~ p는 제외 : [a-lq-z](차집합)</li>
        </ol>
    </details>
        
    <details>
        <summary>정규표현식 문자 집합 상수</summary>
        <ol>
            <li>. » 임의 문자(줄 끝은 매치되지 않을수도 있음)</li>
            <li>\d » [0-9]</li>
            <li>\D » [^0-9]</li>
            <li>\h » 수평 공백 문자: [ \t\xA0\u1680\u180e\u2000-\u200a\u202f\u205f\u3000]</li>
            <li>\H » [^\h]</li>
            <li>\s » 공백 문자: [ \t\n\x0B\f\r]</li>
            <li>\S » [^\s]</li>
            <li>\v » 수직 공백 문자: [\n\x0B\f\r\x85\u2028\u2029]</li>
            <li>\V » [^\v]</li>
            <li>\w » [a-zA-Z_0-9]</li>
            <li>\W » [^w]</li>
        </ol>
    </details>

    <details>
        <summary>POSIX 문자 집합(US-ASCII에서만)</summary>
        <ol>
            <li>\p{Lower} » [a-z]</li>
            <li>\p{Upper} » [A-Z]</li>
            <li>\p{ASCII} » All ASCII:[\x00-\x7F]</li>
            <li>\p{Alpha} » [\p{Lower}\p{Upper}]</li>
            <li>\p{Digit} » [0-9]</li>
            <li>\p{Alnum} » [\p{Alpha}\p{Digit}]</li>
            <li>\p{Punct} » Punctuation: One of !"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\]^_`{|}~</li>
            <li>\p{Graph} » A visible character: [\p{Alnum}\p{Punct}]</li>
            <li>\p{Print} » A printable character: [\p{Graph}\x20]</li>
            <li>\p{Blank} » A space or a tab: [ \t]</li>
            <li>\p{Cntrl} » A control character: [\x00-\x1F\x7F]</li>
            <li>\p{XDigit} » A hexadecimal digit: [0-9a-fA-F]</li>
            <li>\p{Space} » A whitespace character: [ \t\n\x0B\f\r]</li>
        </ol>
    </details>

    <details>
        <summary>java.lang.Character 집합</summary>
        <ol>
            <li>\p{javaLowerCase} » Equivalent to java.lang.Character.isLowerCase()</li>
            <li>\p{javaUpperCase} » Equivalent to java.lang.Character.isUpperCase()</li>
            <li>\p{javaWhitespace} » Equivalent to java.lang.Character.isWhitespace()</li>
            <li>\p{javaMirrored} » Equivalent to java.lang.Character.isMirrored()</li>
        </ol>
    </details>

    <details>
        <summary>유니코드 문자 집합</summary>
        <ol>
            <li>\p{IsLatin} » A Latin script character (script)</li>
            <li>\p{InGreek} » A character in the Greek block (block)</li>
            <li>\p{Lu} » An uppercase letter (category)</li>
            <li>\p{IsAlphabetic} » An alphabetic character (binary property)</li>
            <li>\p{Sc} » A currency symbol</li>
            <li>\P{InGreek} » Any character except one in the Greek block (negation)</li>
            <li>[\p{L}&amp;&amp;[^\p{Lu}]] » Any letter except an uppercase letter (subtraction)</li>
        </ol>
    </details>

    <details>
        <summary>경계 매칭 표현식</summary>
        <ol>
            <li>^ » The beginning of a line</li>
            <li>$ » The end of a line</li>
            <li>\b » A word boundary</li>
            <li>\b{g} » A Unicode extended grapheme cluster boundary</li>
            <li>\B » A non-word boundary</li>
            <li>\A » The beginning of the input</li>
            <li>\G » The end of the previous match</li>
            <li>\Z » The end of the input but for the final terminator, if any</li>
            <li>\z » The end of the input</li>
            <li>\R » Any Unicode linebreak sequence, is equivalent to \u000D\u000A|[\u000A\u000B\u000C\u000D\u0085\u2028\u2029]</li>
        </ol>
    </details>

    <details>
        <summary>Greedy Quantifiers</summary>
        <ol>
            <a role="button" target="_blank" class="btn btn-info btn-sm" href="https://stackoverflow.com/questions/5319840/greedy-vs-reluctant-vs-possessive-quantifiers">참고자료</a> : 처음에 매치할 수 있는 만큼 최대한 매치. 그 다음 요소의 매칭이 없으면 백트래킹.
            <li>X? » X, once or not at all</li>
            <li>X* » X, zero or more times</li>
            <li>X+ » X, one or more times</li>
            <li>X{n} » X, exactly n times</li>
            <li>X{n,} » X, at least n times</li>
            <li>X{n,m} » X, at least n but not more than m times</li>
        </ol>
    </details>

    <details>
        <summary>Reluctant Quantifiers</summary>
        <ol>
            Non-greedy. 처음에 최소한만 매치. 그 다음 요소의 매칭이 없으면 백트래킹.
            <li>X?? » X, once or not at all</li>
            <li>X*? » X, zero or more times</li>
            <li>X+? » X, one or more times</li>
            <li>X{n}? » X, exactly n times</li>
            <li>X{n,}? » X, at least n times</li>
            <li>X{n,m}? » X, at least n but not more than m times</li>
        </ol>
    </details>

    <details>
        <summary>Possessive Quantifiers</summary>
        <ol>
            Greedy quantifier와 같지만, 백트래킹은 없다.
            <li>X?+ » X, once or not at all</li>
            <li>X*+ » X, zero or more times</li>
            <li>X++ » X, one or more times</li>
            <li>X{n}+ » X, exactly n times</li>
            <li>X{n,}+ » X, at least n times</li>
            <li>X{n,m}+ » X, at least n but not more than m times</li>
        </ol>
    </details>

    <details>
        <summary>Logical operations</summary>
        <ol>
            <li>XY » X followed by Y</li>
            <li>X|Y » Either X or Y</li>
            <li>(X) » X, as a capturing group</li>
        </ol>
    </details>

    <details>
        <summary>Back references</summary>
        <ol>
            <li>\n » Whatever the n-th capturing group matched</li>
            <li>\k&lt;name&gt; » Whatever the named-capturing group "name" matched</li>
        </ol>
    </details>

    <details>
        <summary>Quotation</summary>
        <ol>
            <li>\ » Nothing, but quotes the following character</li>
            <li>\Q » Nothing, but quotes all characters until \E</li>
            <li>\E » Nothing, but ends quoting started by \Q</li>
        </ol>
    </details>

    <details>
        <summary>Special constructs</summary>
        <ol>
            <li>(?&lt;name&gt;X) » X, as a named-capturing group</li>
            <li>(?:X) » X, as a non-capturing group</li>
            <li>(?idmsuxU-idmsuxU) » Nothing, but turns match flags i d m s u x U on - off</li>
            <li>(?idmsux-idmsux:X) » X, as a non-capturing group with the given flags i d m s u x on - off</li>
            <li>(?=X) » X, via zero-width positive lookahead</li>
            <li>(?!X) » X, via zero-width negative lookahead</li>
            예. 금칙어가 포함되지 않은 문장 == 금칙어로 시작하지 않는 문자가 처음부터 끝까지 이어진다. » ^((?!badword).)*$
            <li>(?&lt;=X) » X, via zero-width positive lookbehind</li>
            <li>(?&lt;!X) » X, via zero-width negative lookbehind</li>
            <li>(?&gt;X) » X, as an independent, non-capturing group</li>
        </ol>
    </details>

    <details>
        <summary>Field Detail</summary>
        <ol>
            <li>public static final int UNIX_LINES</li>
            줄끝 '\n'만 ., ^, $에서 동작. (?d) 플래그도 같은 의미.
            
            <li>public static final int CASE_INSENSITIVE</li>
            대소문자 구분 없음. (?i) 플래그도 같은 의미.
            
            <li>public static final int COMMENTS</li>
            공백과 주석 허용 » 공백과 #부터 줄 끝까지의 주석이 무시된다. (?x) 플래그도 같은 의미.
            
            <li>public static final int MULTILINE</li>
            ^, $이 각 줄의 끝을 기준으로도 작동; 기본 동작은 입력 시작과 끝에서만 작동. (?m) 플래그도 같은 의미.
            
            <li>public static final int LITERAL Since 1.5</li>
            표현식 전체를 상수 문자열 취급.
            
            <li>public static final int DOTALL</li>
            .이 줄 끝도 포함하여 매치; 기본 동작은 줄 끝 문자는 미포함. (?s) 플래그도 같은 의미.
            
            <li>public static final int UNICODE_CASE</li>
            CASE_INSENSITIVE 플래그가 유니코드 표준 상에서 동작한다; 기본은 US-ASCII에서만 동작. (?u) 플래그도 같은 의미.        
        </ol>
    </details>

    <details>
        <summary>Method Detail</summary>
        <ol>
            <li>static Pattern compile(String regex) + 1 오버로딩</li>
        
            <li>static boolean matches(String regex, CharSequence input) : 1회용</li>
            <li>String pattern()</li>
            <li>String toString() Since 1.5</li>
            <li>static String quote(String s) Since 1.5</li>
            s를 매칭할 수 있는 정규표현식 리터럴 문자열 표현을 반환.
            
            <li>int flags()</li>
            <li>Matcher matcher(CharSequence input)</li>
            <li>String[] split(CharSequence input) + 1 오버로딩</li>
            <li>Predicate&lt;String&gt; asPredicate() Since 1.8</li>
            <li>Stream&lt;String&gt; splitAsStream(CharSequence nput) Since 1.8</li>
        </ol>
    </details>
</details>

<hr>

<details>
    <summary>final class Matcher implements MatchResult Since 1.4</summary>
    <ol>
        Pattern으로부터 만들어지는 매칭 엔진으로, 아래 세 가지 작업을 수행한다.
        <li>matches() : 전체 입력에 대해 패턴 매칭</li>
        <li>lookingAt() : 입력 시작부분 패턴 매칭</li>
        <li>find() : 입력의 다음 부분 패턴 매칭</li>
    </ol>

    <details>
        <summary>Method Detail</summary>
        <ol>
            <li>Pattern pattern()</li>
            <li>MatchResult toMatchResult() Since 1.5</li>
            <li>Matcher usePattern(Pattern newPattern) Since 1.5</li>
            <li>Matcher reset() + 1오버로딩</li>
            
            <li>int start(String name) Since 1.8</li>
            주어진 식별자에 해당하는 그룹의 시작 인덱스 반환
            <li>int end(String name) Since 1.8</li>
            <li>String group(String name) Since 1.7</li>
            
            <li>boolean mathes()</li>
            <li>boolean find() + 1 오버로딩</li>
            <li>boolean lookingAt()</li>
            
            <li>static String quoteReplacement(String s) Since 1.5</li>
            appendReplacement 메서드의 replacement로 사용될 s의 리터럴 표기를 반환.
            <li>Matcher appendReplacement(StringBuffer sb, String replacement) + 1 오버로딩</li>
            입력 소스의 append position부터 start() 전까지 sb에 추가. → replacement를 sb에 추가. 현재 matcher의 append position을 end()로 설정.
            <li>StringBuffer appendTail(StringBuffer sb) + 1 오버로딩</li>
            입력 소스의 append position부터를 sb에 추가.
            appendReplacement 메서드를 호출한 뒤에 이를 호출하여 남머지 부분을 복사할 목적으로 만들어짐.
            <li>String replaceAll(String replacement)</li>
            입력 소스의 모든 매칭되는 부분을 replacement로 변경.
            <li>String replaceAll(Function&lt;MatchResult, String&gt; replacer) Since 9</li>
            <li>String replaceFirst(String replacement) + 1 오버로딩</li>
            <li>Stream&lt;MatchResult&gt; results() Since 9</li>
            
            <li>Matcher region(int start, int end) Since 1.5</li>
            입력 소스의 특정 구간을 매칭 대상으로 하도록 초기화한다. transparency, anchoring 속성에 따라 동작이 다르다.
            <li>int regionStart(), regionEnd() Since 1.5</li>
            <li>boolean hasTransparentBounds() Since 1.5</li>
            <li>Matcher useTransparentBounds(boolean b) Since 1.5</li>
            region의 경계 너머를 패턴 매칭에 보이도록 할지 여부
            <li>boolean hasAnchoringBounds() Since 1.5</li>
            <li>Matcher useAnchoringBounds(boolean b) Since 1.5</li>
            region의 경계에서 ^, $를 작동하게 할지 여부
        </ol>
    </details>
</details>

<hr>
