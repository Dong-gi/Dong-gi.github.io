<script src="/source/redirect.js?200226_1657"></script><hr><details><summary>interface MatchResult Since 1.5</summary><ol><li>정규표현식 매칭 결과. group의 의미에 대해선 Pattern 참고.<li>int start() : 매치된 결과의 시작 인덱스 반환<li>int start(int group) : group번째 매치된 결과의 시작 인덱스 반환<li>int end() : 매치된 결과의 마지막 글자 다음 인덱스 반환<li>int end(int group) : group번째 매치된 결과의 마지막 글자 다음 인덱스 반환<li>String group() : 이전 매치된 결과 반환<li>String group(int group) : group번째 매치된 결과 반환<li>int groupCount() : 매치된 group 개수 반환<button class="btn-code"path="Repositories/Eclipse/JavaSE/src/regex/MatchResultExample.java"lan="java">예시 코드 »</button></ol></details><hr><details><summary>final class Pattern implements Serializable Since 1.4</summary><ul><li>Line terminator</li>"\n", "\r\n", "\r", "\u0085", "\u2028", "\u2029" // UNIX_LINES 모드에서는 "\n"만 줄 끝으로 인식<li>Groups and capturing</li><ul><li>Group : 괄호로 감싸인 정규표현식 (X)<li>Capturing group : 괄호 순서에 따라 그룹에 ID가 매겨지며, 이는 나중에 참조(backreference)될 수 있다</li>0번 그룹은 항상 전체 표현을 가리킨다. <button class="btn-code"path="Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java"displayrange="[16,26]"lan="java">예를 들어</button> (A)(B(C))에 대하여,<table><tr><th>Group ID<th>Pattern<tr><td>0<td>(A)(B(C))<tr><td>1<td>(A)<tr><td>2<td>(B(C))<tr><td>3<td>(C)</table><li>Non-capturing group : (?:X)는 후참조할 수 없다 <button class="btn-code"path="Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java"displayrange="[28,37]"lan="java">예 »</button></ul><li>Character expression</li><ul><li>x, \\ : 각각 x, \에 대응 <button class="btn-code"path="Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java"displayrange="[39,39]"lan="java">예 »</button><li>\0n, \0nn, \0nnn : 8진수 아스키 코드[0,255] == [00, 0377] <button class="btn-code"path="Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java"displayrange="[40,40]"lan="java">예 »</button><li>\xhh : 16진수 아스키 코드[0,255] <button class="btn-code"path="Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java"displayrange="[41,41]"lan="java">예 »</button><li>\uhhhh, \u{h...h} : 16진수 유니코드[Character.MIN_CODE_POINT, Character.MAX_CODE_POINT] <button class="btn-code"path="Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java"displayrange="[42,42]"lan="java">예 »</button><li>\N{name} : 유니코드 이름 <button class="btn-code"path="Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java"displayrange="[43,43]"lan="java">예 »</button><li>\t(tab \u0009), \n(newline \u000A), \r(carriage-return \u000D), \f(form-feed \u000C), \a(alert \u0007), \e(escape \u001B), \cx(x에 관한 제어 문자)</ul><li>Character class</li><ul><li>[abc] : 단순 집합 <button class="btn-code"path="Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java"displayrange="[44,44]"lan="java">예 »</button><li>[^abc] : 여집합 <button class="btn-code"path="Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java"displayrange="[45,45]"lan="java">예 »</button><li>[a-z] : 유니코드 Range(inclusive) <button class="btn-code"path="Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java"displayrange="[46,46]"lan="java">예 »</button><li>[a-d[m-p]] == [a-dm-p] : 합집합 <button class="btn-code"path="Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java"displayrange="[47,47]"lan="java">예 »</button><li>[a-z&amp;&amp;[def]] : 교집합 <button class="btn-code"path="Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java"displayrange="[48,48]"lan="java">예 »</button><li>[a-z&amp;&amp;[^bc]] : 차집합(A and not(B) == A - B) <button class="btn-code"path="Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java"displayrange="[49,49]"lan="java">예 »</button></ul><li>Predefined character classe</li><ul><li>. : 임의 문자. DOTALL 플래그가 있으면 line terminator도 매칭<li>\d : [0-9], \D : [^\d]<li>\s : 공백 문자 [ \t\n\x0B\f\r], \S : [^\s]<li>\h : 수평 공백 [ \t\xA0\u1680\u180e\u2000-\u200a\u202f\u205f\u3000], \H : [^\h]<li>\v : 수직 공백 [\n\x0B\f\r\x85\u2028\u2029], \V : [^\v]<li>\w : Word character, \W : [^w]</ul><li>java.lang.Character class</li><ul><li>\p{javaLowerCase} : Character.isLowerCase()<li>\p{javaUpperCase} : Character.isUpperCase()<li>\p{javaWhitespace} : Character.isWhitespace()<li>\p{javaMirrored} : Character.isMirrored()</ul><li>Unicode class</li><ul><li>\R : 임의 줄바꿈 문자열 \u000D\u000A|[\u000A\u000B\u000C\u000D\u0085\u2028\u2029]<li>\X : Any Unicode extended grapheme cluster<li>\b{g} : A Unicode extended grapheme cluster boundary<li>\P{expr} == [^\p{expr}]</li>\p{IsLatin} : Latin <strong>script</strong>, \p{InGreek} : Greek <strong>block</strong>, \p{Lu} : Uppercase letter(<strong>category</strong>), \p{IsAlphabetic} : <strong>binary property</strong>, \p{Sc} : Currency symbol</ul><li>Boundary matcher</li><ul><li>^ : 줄 시작, $ : 줄 끝<li>\b : 단어 경계, \B : 비단어 경계<li>\A : The beginning of the input<li>\G : The end of the previous match<li>\z » The end of the input</ul><li>Greedy quantifier</li><ul>처음에 매치할 수 있는 만큼 최대한 매치. 그 다음 요소의 매칭이 없으면 백트래킹. <a class="w3-btn w3-round w3-round-xxlarge w3-small w3-green"target="_blank"href="https://stackoverflow.com/questions/5319840/greedy-vs-reluctant-vs-possessive-quantifiers">참고자료</a><li>X? : X, once or not at all<li>X* : X, zero or more times<li>X+ : X, one or more times<li>X{n} : X, exactly n times<li>X{n,} : X, at least n times<li>X{n,m} : X, at least n but not more than m times</ul><li>Reluctant quantifier</li>처음에 최소한만 매치. 그 다음 요소의 매칭이 없으면 백트래킹. X??, X*?, X+?, X{n}?, X{n,}?, X{n,m}?<li>Possessive quantifier</li>Greedy quantifier와 같지만, 백트래킹은 없다. X?+, X*+, X++, X{n}+, X{n,}+, X{n,m}+<li>Logical operation</li><ul><li>XY : X followed by Y<li>X|Y : Either X or Y<li>(X) : X, as a capturing group</ul><li>Backreference</li><ul><li>\n : The n-th capturing group matched<li>\k&lt;name&gt; : Tthe named-capturing group "name" matched</li>↑ 정규표현식 내에서는 위 두 가지 backreference가 가능하며, replace()에서는 $0, $1, $2, ...로 표기한다 <button class="btn-code"path="Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java"displayrange="[51,57,59,71,73,85]"lan="java">예 »</button></ul><li>Quotation</li><ul><li>\ : Nothing, but quotes the following character<li>\Q : Nothing, but quotes all characters until \E<li>\E : Nothing, but ends quoting started by \Q</ul><li>Special construct</li><ul><li>(?&lt;name&gt;X) : X, as a named-capturing group <button class="btn-code"path="Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java"displayrange="[59,71]"lan="java">예 »</button><li>(?:X) : X, as a non-capturing group<li>(?idmsuxU-idmsuxU) : 각 플래그를 켜거나 끈다<li>(?idmsux-idmsux:X) : 주어진 플래그로 non-capturing group X를 매칭한다<li>(?=X) : Positive lookahead, (?!X) : Negative lookahead</li><button class="btn-code"path="Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java"displayrange="[51,57]"lan="java">예1 »</button> <button class="btn-code"path="Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java"displayrange="[87,102]"lan="java">금칙어 판별 예 »</button><li>(?&lt;=X) : Positive lookbehind, (?&lt;!X) : Negative lookbehind<li>(?&gt;X) : Non-capturing group + Possessive</ul></ul><details><summary>Field Detail</summary><ol><li>public static final int UNIX_LINES</li>줄끝 '\n'만 ., ^, $에서 동작. (?d) 플래그도 같은 의미.<li>public static final int CASE_INSENSITIVE</li>대소문자 구분 없음. (?i) 플래그도 같은 의미.<li>public static final int COMMENTS</li>공백과 주석 허용. 공백과 #부터 줄 끝까지의 주석이 무시된다. (?x) 플래그도 같은 의미.<li>public static final int MULTILINE</li>^, $이 각 줄의 끝을 기준으로도 작동; 기본 동작은 입력 시작과 끝에서만 작동. (?m) 플래그도 같은 의미.<li>public static final int LITERAL Since 1.5</li>표현식 전체를 상수 문자열 취급.<li>public static final int DOTALL</li>.이 줄 끝도 포함하여 매치; 기본 동작은 줄 끝 문자는 미포함. (?s) 플래그도 같은 의미.<li>public static final int UNICODE_CASE</li>CASE_INSENSITIVE 플래그가 유니코드 표준 상에서 동작한다; 기본은 US-ASCII에서만 동작. (?u) 플래그도 같은 의미.</ol></details><details><summary>Method Detail</summary><ol><li>static Pattern compile(String regex) + 1 오버로딩<li>static boolean matches(String regex, CharSequence input) : 1회용<li>String pattern()<li>String toString() Since 1.5<li>static String quote(String s) Since 1.5</li>s를 매칭할 수 있는 정규표현식 리터럴 문자열 표현을 반환.<li>int flags()<li>Matcher matcher(CharSequence input)<li>String[] split(CharSequence input) + 1 오버로딩<li>Predicate&lt;String&gt; asPredicate() Since 1.8<li>Stream&lt;String&gt; splitAsStream(CharSequence nput) Since 1.8</ol></details></details><hr><details><summary>final class Matcher implements MatchResult Since 1.4</summary><ol>Pattern으로부터 만들어지는 매칭 엔진으로, 아래 세 가지 작업을 수행한다.<li>matches() : 전체 입력에 대해 패턴 매칭<li>lookingAt() : 입력 시작부분 패턴 매칭<li>find() : 입력의 다음 부분 패턴 매칭</ol><details><summary>Method Detail</summary><ol><li>Pattern pattern()<li>MatchResult toMatchResult() Since 1.5<li>Matcher usePattern(Pattern newPattern) Since 1.5<li>Matcher reset() + 1오버로딩<li>int start(String name) Since 1.8</li>주어진 식별자에 해당하는 그룹의 시작 인덱스 반환<li>int end(String name) Since 1.8<li>String group(String name) Since 1.7<li>boolean mathes()<li>boolean find() + 1 오버로딩<li>boolean lookingAt()<li>static String quoteReplacement(String s) Since 1.5</li>appendReplacement 메서드의 replacement로 사용될 s의 리터럴 표기를 반환.<li>Matcher appendReplacement(StringBuffer sb, String replacement) + 1 오버로딩</li>입력 소스의 append position부터 start() 전까지 sb에 추가. → replacement를 sb에 추가. 현재 matcher의 append position을 end()로 설정.<li>StringBuffer appendTail(StringBuffer sb) + 1 오버로딩</li>입력 소스의 append position부터를 sb에 추가. appendReplacement 메서드를 호출한 뒤에 이를 호출하여 남머지 부분을 복사할 목적으로 만들어짐.<li>String replaceAll(String replacement)</li>입력 소스의 모든 매칭되는 부분을 replacement로 변경.<li>String replaceAll(Function&lt;MatchResult, String&gt; replacer) Since 9<li>String replaceFirst(String replacement) + 1 오버로딩<li>Stream&lt;MatchResult&gt; results() Since 9<li>Matcher region(int start, int end) Since 1.5</li>입력 소스의 특정 구간을 매칭 대상으로 하도록 초기화한다. transparency, anchoring 속성에 따라 동작이 다르다.<li>int regionStart(), regionEnd() Since 1.5<li>boolean hasTransparentBounds() Since 1.5<li>Matcher useTransparentBounds(boolean b) Since 1.5</li>region의 경계 너머를 패턴 매칭에 보이도록 할지 여부<li>boolean hasAnchoringBounds() Since 1.5<li>Matcher useAnchoringBounds(boolean b) Since 1.5</li>region의 경계에서 ^, $를 작동하게 할지 여부</ol></details></details><hr>