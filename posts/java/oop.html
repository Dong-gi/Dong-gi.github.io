<html lnag="ko"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="google-site-verification" content="aH-DyzdytYQ0NPHNQFcs5dVoiu5YNs6CEEHYgqDmAFM"><meta name="author" content="Donggi Kim &lt;hi.donggi@gmail.com&gt;"><meta name="keywords" content="Java, OOP"><meta name="description" content="Java 객체지향 정리"><title>Java 객체지향</title><link id="w3css" rel="stylesheet" href="/source/w3.css"><link id="highlight-style" rel="stylesheet" href="/source/xcode.css"><link id="default-style" rel="stylesheet" href="/source/default.css"><script id="highlight-js" src="/source/highlight.pack.js"></script><script id="default-js" src="/source/default.min.js"></script><script id="dsq-count-scr" src="//donggi.disqus.com/count.js" async></script><script id="kakao-ads" src="//t1.daumcdn.net/kas/static/ba.min.js" async></script><script id="google-ads" data-ad-client="ca-pub-7897366614471210" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><script id="google-analytics" src="https://www.googletagmanager.com/gtag/js?id=UA-143098403-1" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-143098403-1');</script></head><body><div id="sidebar" class="w3-bar-block w3-sidebar w3-animate-left"><hr><a href="javascript:closeSidebar();" class="w3-bar-item w3-button">Close &times;</a><hr><div id="marker-list"></div><hr><div id="post-list"></div><hr><div class="w3-center"><ins style="display:none;" data-ad-unit="DAN-1k1r635zxb6g3" data-ad-width="300" data-ad-height="250" class="kakao_ad_area"></ins></div><hr><div id="file-list"></div><hr></div><div id="main"><div id="nav" style="position:-webkit-sticky;position:sticky;top:0px;vertical-align:middle" class="w3-bar w3-blue w3-large"><button onclick="toggleSidebar()" class="w3-bar-item w3-button w3-hover-theme">&#9776;</button><input id="query" type="text" placeholder="search" class="w3-bar-item"></div><div id="contents" class="w3-padding"><h1 class="marker">클래스</h1><ul><li>자바 코드의 기본 단위는 클래스이며, 파일 이름과 클래스 이름이 일치해야 한다. 이 일치하는 클래스만이 파일 내부에서 public으로 정의될 수 있다.</li><li>객체 지향 3원리</li><ol><li>캡슐화 : 코드와 데이터를 함께 묶고 외부의 접근/오용을 제한</li><li>상속 : 상위 클래스의 속성들을 하위 클래스에서 그대로 이용</li><li>다형성(Polymorphism) : 상위 타입 참조 변수로 하위 타입 객체를 참조할 수 있고, 이를 통해 호출하는 메서드는 실제로 참조하는 객체의 타입에 따라 나중에 결정된다.</li></ol><li>초기화 블록</li><ul><li>class initializer : 클래스 내의 static {} 블록으로, 클래스 로드시 한 번 호출된다.</li><li>instance initializer : 클래스 내의 {} 블록으로, 객체 생성시 한 번 호출된다.<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/Basic/src/io/github/donggi/ClassExample.java" lan="java">초기화 블록, 상속, 다형성 예시 »</button></li></ul><li>this : 객체 자신을 가리키는 키워드. this()를 통해 다른 생성자 호출, this.methodName()을 통해 다른 메서드 호출, ClassName.this를 통해 가려진 영역의 객체 참조.</li><li>super : 부모 클래스를 가리키는 키워드. super()를 통해 부모 메서드 호출, super.methodName()을 통해 다른 메서드 호출</li><li>자바는 오버라이드를 명시하지 않아도 재정의한 메서드를 호출해준다.(= Dynamic method dispatch)</li><li>instanceof 연산자로 호환 여부 확인 가능</li><li>{}를 이용해 간단하게 익명클래스를 작성할 수 있다.<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/Basic/src/io/github/donggi/AnonymousClass.java" lan="java">익명클래스 객체 예시 »</button></li></ul><h1 class="marker">인터페이스</h1><ul><li>인터페이스 내부의 모든 요소는 기본적으로 public이다. JDK 9에서 private 메서드 지원 추가.</li><li>인터페이스는 final 멤버 변수를 가질 수 있다.</li><li>인터페이스의 메서드는 기본적으로 body가 없지만, default method는 가질 수 있다.</li><li>인터페이스 구현 : implements</li><li>추상클래스는 인터페이스를 부분적으로 구현해도 된다.</li><button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/Basic/src/io/github/donggi/Interface.java" lan="java">View Code »</button></ul><h1 class="marker">중첩 클래스</h1><ul><li>Static Nested Class : 외부 클래스 이름으로 접근</li><li>Non-Static Nested Class : 외부 클래스 객체로 접근</li><li>Inner Interface : 외부 클래스 이름으로 접근</li><li>Anonymous Class : 외부 클래스 final 멤버 접근 가능</li><li>Local Class : 외부 클래스 final 멤버 접근 가능</li><button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/Basic/src/io/github/donggi/Nested.java" lan="java">View Code »</button></ul><h1 class="marker">람다</h1><ul><li>@FunctionalInterface</li><ul><li>구현되지 않은 메서드가 1개만 있는 인터페이스.</li><li>java.util.function 패키지에 유용한 FunctionalInterface들이 정의되어 있다.</li><li>기존의 인터페이스에 static 메서드가 추가되었다. 예) Comparator.comparing</li></ul><li>익명 메서드 Lambda : FunctionalInterface의 메서드만을 명시함으로써 익명 객체를 생성한다.</li><p>시그니처를 간소화하는 것은 어디까지나 정의가 분명할 때뿐이다.<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/Basic/src/io/github/donggi/Lambda2.java" lan="java">View Code »</button></p><li>메서드 참조를 이용해 기정의된 메서드를 람다로 이용할 수 있다. '::' 연산자를 이용한다.</li><li>생성자 참조 » "::new". 배열 생성자 int[]::new도 가능.<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/Basic/src/io/github/donggi/Lambda.java" lan="java">View Code »</button></li></ul><h1 class="marker">Object 클래스</h1><ol><li>Object는 모든 참조 자료형의 부모로, 가장 기본적인 클래스다.</li><li>protected Object clone()</li><ol><li>객체의 복사본을 생성하여 반환한다.(얕은 복사)</li><li>Object.clone()의 접근제한자는 protected이다. 이는 얕은 복사본의 이용으로 원본 객체까지 변경되는 것을 막기 위함이다.</li><li>clone()을 재정의할 때, Cloneable 마커 인터페이스를 구현하는데, 마커 인터페이스는 추상 메소드 없이, 클래스가 단순히 해당 기능을 가짐을 나타낸다.</li></ol><li>boolean equals(Object obj)</li><p>Object 클래스의 equals 구현 : return this == obj;<br>equals()를 오버라이드할 경우 non-null 참조 변수들에 대해 아래의 원칙을 만족해야 한다.</p><ol><li>x.equals(null) == false</li><li>Reflexive : x.equals(x) == true</li><li>Symmetric : x.equals(y) == y.equals(x)</li><li>Transitive : x.equals(y) == true AND y.equals(z) == ture IMPLIES x.equals(z) == true</li><li>Consistence : 객체의 참조가 변하지 않는 한 equals()는 항상 같은 값을 반환해야 한다.</li></ol><li>String toString() : 객체의 문자열 표현 반환</li><li>Class&lt;?> getClass() : 객체의 Class를 반환</li><li>int hashCode() : 객체의 hash code 반환 // HashSet, HashMap 등에서 이용</li><li>void notify() : 해당 객체에 대해 대기하는 스레드를 깨운다.</li><li>void notifyAll() : 해당 객체에 대해 대기하는 모든 스레드를 깨운다.</li><li>void wait() : 해당 객체에 대해 스레드를 대기.</li><li>void wait(long timeout) : 깨워질 때까지 최대 timeout ms동안 대기.</li><li>void wait(long timeout, int nanos) : timeout ms + nanos ns</li><button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/Basic/src/io/github/donggi/ObjectExample.java" lan="java">예시 : clone, equals, hashCode, toString, compareTo »</button><button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/Basic/src/io/github/donggi/Notify.java" lan="java">예시 : notify, wait »</button><li>@Deprecated(since="9") protected void finalize()</li><p>객체 폐기 메서드였던 것.<br>대안 : Non-heap 리소스를 갖는 객체들에 대하여 명시적인 자원 해제 메서드를 지원해야 하며, 가능하면 AutoCloseable을 구현한다.
java.lang.ref.Cleaner, java.lang.ref.PhantomReference는 참조되지 않는 객체를 해제하는 데 유연한 방법을 <a class="w3-btn w3-round w3-round-xxlarge w3-small w3-green" href="https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/lang/ref/Cleaner.html" target="_blank">제공한다</a></p></ol><h1 class="marker">패키지</h1><ul><li>패키지는 네임스페이스와 비슷한 역할을 하며, 클래스들을 구분해준다. 파일시스템 상에서 디렉터리(폴더)로 표현된다.</li><li>일반적으로 패키지 이름은 도메인의 역순으로 구성하고, 소문자만을 이용한다.</li><li>패키지 내부에 패키지를 가질 수 있다. package package1.sub1;</li><li>import 패키지.(이름 or *); 이름 충돌이 발생할 때는 패키지 이름을 명시한다.</li><li>정적 멤버 임포트 : import static package . className . ( staticMemberName | * );</li></ul><h1 class="marker">Enum</h1><ul><li>모든 enum은 Enum&lt;E>를 상속하므로, 추가로 다른 클래스를 상속할 수 없다.</li><li>enum은 여타 클래스와 같이 멤버 변수, 메서드를 가질 수 있으며, private 생성자와 abstract method도 가질 수 있다.</li><li>enum은 로드시 한번만 생성되므로 싱글톤을 간단하게 구현할 수 있다.</li><li>Enum&lt;E> :: name, toString, ordinal, compareTo, valueOf</li><button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/Basic/src/io/github/donggi/EnumExample.java" lan="java">View Code »</button></ul><h1 class="marker">예외</h1><ul><li>Throwable « Exception(Checked Exception) « RuntimeException(Unchecked Exception)</li><li>Error : 프로그램 내부에서 해결할 수 없어 종료됨.</li><li>Unchecked Exception은 따로 처리하지 않아도 프로그램이 계속 실행된다.</li><li>Chained Exceptions : 하나의 예외로 인해 다른 예외들이 발생할 수 있다. JDK 1.4부터 근원적인 예외를 알아올 수 있는 방법이 추가되었다.</li><ol><li>Throwable(Throwable causeExc), Throwable(String msg, Throwable causeExc) : 보다 근본적인 원인을 인자로 하여 새로운 예외 생성</li><li>Throwable initCause(Throwable causeExc) : 예외의 근원을 설정하며, 생성자를 통해 호출되거나 이미 호출된 경우 다시 호출 불가</li><li>Throwable getCause() : 현재 예외의 근원을 얻는다. 없으면 null</li></ol><button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/Basic/src/io/github/donggi/ExceptionExample.java" lan="java">View Code »</button><li>부모보다 많은 종류의 예외를 공표할 수 없다.</li></ul><h1 class="marker">옵션 타입</h1><p>Optional&lt;T> : T 타입의 존재 여부를 포함하는 T타입 컨테이너<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/Basic/src/io/github/donggi/OptionalExample.java" lan="java">View Code »</button></p><h1 class="marker">제네릭</h1><ul><li>여러 타입을 기본 요소로 할 수 있는 범용 클래스/인터페이스 작성을 위한 문법.</li><li>A가 B의 서브타입일 때, A[]는 B[]의 서브타입이지만, G&lt;A>는 G&lt;B>의 서브타입이 아니다.</li><p>Erasure : 컴파일 시 제네릭 타입을 모두 지우고 바운드 타입으로(명시되지 않았다면 Object) 변경한다. javap를 통해 이를 확인할 수 있다.<br>자식 메서드의 Erasure가 부모와 다를 때 부모 메서드는 bridge 메서드가 되어 자식의 Erasure를 이용하는 메서드를 호출한다. 이 과정에서 리턴 타입만 다른 메서드들이 생성될 수 있지만, 바이트 코드 단계기 때문에 에러가 발생되지 않고 잘 처리된다.</p><li>메서드에서는 와일드카드 '?'를 이용하여 제네릭 타입을 매개변수로 받을 수 있다.</li><li>제네릭을 통한 객체 생성 불가. 제네릭을 static 요소에서 이용하는 데 제한.</li><li>제네릭 타입의 선언, 제네릭 리스트 일부 구현, 바운드된 타입 매개변수 선언<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/Basic/src/io/github/donggi/Generic.java" lan="java">View Code »</button></li><li>비제네릭 클래스의 제네릭 생성자 선언, 비제네릭 클래스 - 제네릭 클래스 상속<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/Basic/src/io/github/donggi/Generic2.java" lan="java">View Code »</button></li></ul></div><hr>&copy; 2020. <a href="mailto:hi.donggi@gmail.com">Donggi Kim</a> all rights reserved.<a class="w3-btn w3-round w3-round-xxlarge w3-small w3-green" href="/LICENSE" target="_blank">LICENSE</a></div></body></html>