<hr>

<details>
    <summary>Consumer</summary>
    <details>
        <summary>@FunctionalInterface interface Consumer&lt;T&gt; Since 1.8</summary>
        <ol>
            <li>인자를 하나 먹고 아무것도 반환하지 않는 소비자.</li>
            <li>void accept(T t)</li>
            <li>default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after) : 이 소비자 다음에 after가 소비하는 병합된 소비자 반환.</li>
        </ol>
    </details>
    
    <details>
        <summary>@FunctionalInterface interface DoubleConsumer Since 1.8 + int, long</summary>
        <ol>
            <li>void accept(double value)</li>
            <li>default DoubleConsumer andThen(DoubleConsumer after)</li>
        </ol>
    </details>
    
    <details>
        <summary>@FunctionalInterface interface BiConsumer&lt;T, U&gt; Since 1.8</summary>
        <ol>
            <li>인자 두개를 먹고 아무것도 뱉지 않는 소비자.</li>
            <li>void accept(T t, U u) : 적당한 동작 수행</li>
            <li>default BiConsumer&lt;T, U&gt; andThen(BiConsumer&lt;? super T, ? super U&gt; after) : 현재 소비자가 작업을 마치면 after가 실행되는 새로운 소비자 반환.</li>
        </ol>
    </details>
    
    <details>
        <summary>@FunctionalInterface interface ObjDoubleConsumer&lt;T&gt; Since 1.8</summary>
        void accept(T t, double value) + int, long
    </details>
</details>

<hr>

<details>
    <summary>Supplier</summary>
    <details>
        <summary>@FunctionalInterface interface Supplier&lt;T&gt; Since 1.8</summary>
        T get()
    </details>
    
    <details>
        <summary>@FunctionalInterface interface BooleanSupplier Since 1.8</summary>
        boolean getAsBoolean() : boolean 값을 공급하는 생산자. + int, double, long
    </details>
</details>

<hr>

<details>
    <summary>Function, Operator</summary>
    <details>
        <summary>@FunctionalInterface interface Function&lt;T, R&gt; Since 1.8</summary>
        <ol>
            <li>인자 하나를 먹고 결과 하나를 뱉는 함수.</li>
            <li>R apply(T t)</li>
            <li>default &lt;V&gt; Function&V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before)</li>
            <li>default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after)</li>
            <li>static &lt;T&gt; Function&lt;T, T&gt; identity() : 입력 인자 그대로 반환하는 함수.</li>
        </ol>
    </details>
    
    <details>
        <summary>@FunctionalInterface interface IntFunction&lt;R&gt; Since 1.8</summary>
        R apply(int value) + double, long
    </details>
    
    <details>
        <summary>@FunctionalInterface interface DoubleToIntFunction Since 1.8</summary>
        int applyAsInt(double value) + double, int, long 간의 상호 변환 함수들이 모두 정의됨
    </details>
    
    <details>
        <summary>@FunctionalInterface interface UnaryOperator&lt;T&gt; extends Function&lt;T, T&gt; Since 1.8</summary>
        static &lt;T&gt; UnaryOperator&lt;T&gt; identity()
    </details>
    
    <details>
        <summary>@FunctionalInterface interface DoubleUnaryOperator Since 1.8 + int, long</summary>
        <ol>
            <li>double applyAsDouble(double operand)</li>
            <li>default DoubleUnaryOperator compose(DoubleUnaryOperator before)</li>
            <li>default DoubleUnaryOperator andThen(DoubleUnaryOperator after)</li>
            <li>static DoubleUnaryOperator identity() : 항상 입력값 그대로 반환하는 단항 연산자 반환.</li>
        </ol>
    </details>
    
    <details>
        <summary>@FunctionalInterface interface ToDoubleFunction&lt;T&gt; Since 1.8</summary>
        double applyAsDouble(T value) + int, long
    </details>
    
    <details>
        <summary>@FunctionalInterface interface BiFunction&lt;T, U, R&gt; Since 1.8</summary>
        <ol>
            <li>인자 두개를 먹고 값을 반환하는 함수.</li>
            <li>R apply(T t, U u)</li>
            <li>default &lt;V&gt; BiFunction&lt;T, U, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) : 함수가 실행되고 난 결과를 after가 처리하는 새로운 함수 반환.</li>
        </ol>
    </details>
    
    <details>
        <summary>@FunctionalInterface interface ToDoubleBiFunction&lt;T, U&gt; Since 1.8</summary>
        double applyAsDouble(T t, U u) + int, long
    </details>
    
    <details>
        <summary>@FunctionalInterface interface BinaryOperator extends BiFunction&lt;T, T, T&gt; Since 1.8</summary>
        <ol>
            <li>같은 타입의 인자 두개를 먹고 같은 타입의 값을 반환하는 함수.</li>
            <li>static &lt;T&gt; BinaryOperator&lt;T&gt; minBy(Comparator&lt;? super T&gt; comparator) : 주어진 comparator에 따라 둘 중 작은 것을 반환하는 함수를 생성.</li>
            <li>static &lt;T&gt; BinaryOperator&lt;T&gt; maxBy(Comparator&lt;? super T&gt; comparator) : 주어진 comparator에 따라 둘 중 큰 것을 반환하는 함수 생성.</li>
        </ol>
    </details>
    
    <details>
        <summary>@FunctionalInterface interface DoubleBinaryOperator Since 1.8</summary>
        double applyAsDouble(double left, double right) : double 두개를 먹고 double 하나를 반환하는 함수. + int, long
    </details>
</details>

<hr>

<details>
    <summary>Predicate</summary>
    <details>
        <summary>@FunctionalInterface interface Predicate&lt;T&gt; Since 1.8</summary>
        <ol>
            <li>boolean test(T t)</li>
            <li>default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other)</li>
            <li>default Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other)</li>
            <li>static &lt;T&gt; Predicate&lt;T&gt; isEqual(Object targetRef) : Object.equals(Object, Object)를 이용해 비교하는 Predicate 반환</li>
        </ol>
    </details>
    
    <details>
        <summary>@FunctionalInterface interface DoublePredicate Since 1.8 + int, long</summary>
        <ol>
            <li>boolean test(double value)</li>
            <li>default DoublePredicate and(DoublePredicate other)</li>
            <li>default DoublePredicate or(DoublePredicate other)</li>
            <li>default DoublePredicate negate()</li>
        </ol>
    </details>
    
    <details>
        <summary>@FunctionalInterface interface BiPredicate&lt;T, U&gt; Since 1.8</summary>
        <ol>
            <li>인자 두개를 먹고 가부를 판단하는 함수.</li>
            <li>boolean test(T t, U u)</li>
            <li>default BiPredicate&lt;T, U&gt; and(BiPredicate&lt;? super T, ? super U&gt; other) : A short-circuiting logical AND of this predicate and other.</li>
            <li>default BiPredicate&lt;T, U&gt; negate()</li>
            <li>default BiPredicate&lt;T, U&gt; or(BiPredicate&lt;? super T, ? super U&gt; other) : A short-circuiting logical OR of this predicate and other.</li>
        </ol>
    </details>
</details>

<hr>