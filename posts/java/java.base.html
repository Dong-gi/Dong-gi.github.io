<html lnag="ko"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="google-site-verification" content="aH-DyzdytYQ0NPHNQFcs5dVoiu5YNs6CEEHYgqDmAFM"><meta name="author" content="Donggi Kim &lt;hi.donggi@gmail.com&gt;"><meta name="keywords" content="Java, Base, JDK12"><meta name="description" content="JDK12 java.base 모듈 정리"><title>java.base 모듈 12</title><link id="w3css" rel="stylesheet" href="/source/w3.css"><link id="highlight-style" rel="stylesheet" href="/source/xcode.css"><link id="default-style" rel="stylesheet" href="/source/default.css"><script id="highlight-js" src="/source/highlight.pack.js"></script><script id="default-js" src="/source/default.min.js"></script><script id="dsq-count-scr" src="//donggi.disqus.com/count.js" async></script><script id="kakao-ads" src="//t1.daumcdn.net/kas/static/ba.min.js" async></script><script id="google-ads" data-ad-client="ca-pub-7897366614471210" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><script id="google-analytics" src="https://www.googletagmanager.com/gtag/js?id=UA-143098403-1" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-143098403-1');</script></head><body><div id="sidebar" class="w3-bar-block w3-sidebar w3-animate-left"><hr><a href="javascript:closeSidebar();" class="w3-bar-item w3-button">Close &times;</a><hr><div id="marker-list"></div><hr><div id="post-list"></div><hr><div class="w3-center"><ins style="display:none;" data-ad-unit="DAN-1k1r635zxb6g3" data-ad-width="300" data-ad-height="250" class="kakao_ad_area"></ins></div><hr><div id="file-list"></div><hr></div><div id="main"><div id="nav" style="position:-webkit-sticky;position:sticky;top:0px;vertical-align:middle" class="w3-bar w3-blue w3-large"><button onclick="toggleSidebar()" class="w3-bar-item w3-button w3-hover-theme">&#9776;</button><input id="query" type="text" placeholder="search" class="w3-bar-item"></div><div id="contents" class="w3-padding"><h1 class="marker">java.io</h1><div><h2 class="marker">interface Closeable extends AutoCloseable</h2><ol><li>데이터의 출발지나 목적지를 닫을 수 있으면 Closeable하다.</li><li>void close()</li><p>스트림 및 이와 관련된 시스템 자원을 해제한다. 이미 호출되었다면 아무 일도 하지 않는다.<br>close() 실패했을 때, 예외를 던지는 대신 사용하던 자원을 모두 포기하고 Closeable 객체 내부적으로 '닫혔다(closed)'고 마크하길 권장한다.</p></ol><h2 class="marker">interface Flushable</h2><ol><li>Flush할 수 있는 데이터 목적지는 Flushable하다.</li><li>void flush()</li><p>버퍼에 저장된 데이터를 스트림에 모두 써 보낸다.</p></ol><h2 class="marker">final class Console implements Flushable</h2><ol><li>JVM이 컨트롤할 수 있는 문자 기반 콘솔에 대한 접근 제공. 콘솔 존재 여부는 하위 플랫폼에 의존적이며, 싱글톤으로 System.console()을 통해 얻을 수 있다. 만일 가용한 콘솔이 없다면 null이 넘겨진다.<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/io/ConsoleExample.java" lan="java">View Code »</button></li><li>콘솔에 대한 읽기/쓰기 작업은 모두 원자적으로 이루어지며, 따라서 다른 스레드가 대기할 가능성이 있다.</li><li>콘솔에 대한 close()는 실제로 아무런 영향을 미치지 않는다.</li><li>유닉스의 Ctrl+D, 윈도우의 Ctrl+Z와 같은 종료 문자를 만나면 읽기 메서드는 null을 반환한다.</li><li>보안 유의 : 패스워드와 같은 중요한 데이터를 읽어들일 때, readPassword(), readPassword(String, Object...) 메서드를 이용하고, 반환된 char[]를 수동으로 0 초기화한다.</li></ol><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">PrintWriter writer() // 유니크한 PrintWriter 객체 반환
Reader reader()      // 유니크한 Reader 객체 반환
char[] readPassword(String fmt, Object... args)
char[] readPassword()</div><h2 class="marker">바이트 단위 IO 관련</h2><div><h3 class="marker">interface DataInput</h3><ol><li>binary stream으로부터 바이트들을 읽고, 또 이를 자바 기본 타입 또는 String으로 만들어 반환하는 기능을 제공한다.</li><li>읽기는 1바이트 단위로 이루어진다.</li><li>Modified UTF-8 : DataInput과 DataOutput 인터페이스는 수정된 UTF-8을 이용한다.</li><ul><li>'\u0001' ~ '\u007F'는 1바이트(0???????)로 표현한다.</li><li>null('\u0000'), '\u0080' ~ '\u07FF'는 2바이트(110????? 10??????)로 표현한다.</li><li>'\u0800' ~ '\uFFFF'는 3바이트(1110??? 10?????? 10??????)로 표현한다.</li></ul></ol><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">int skipBytes(int n)
    // 입력 스트림의 n바이트를 무시한다. 실제로 무시한 바이트 길이가 반환된다.

String readLine()
    // 줄의 끝이나 파일 끝을 만나기까지의 문자열을 반환한다.
    // 각 바이트들을 0 패딩하여 char로 변환하므로, 유니코드를 읽기는 부적합하다.
    // 아무것도 읽지 못한 경우, 빈 문자열이 아닌 null이 반환된다.

String readUTF()
    // 먼저 readUnsignedShort()와 같은 방법으로 2개 바이트를 읽어와 UTF 길이를 구한다.
    // 구한 길이만큼의 바이트를 읽으면서 상기한 Modified UTF-8에 맞춰 String을 만든다.
    // 길이만큼의 바이트를 다 읽기 전에 EOF를 만나면 예외를 던진다.
</div><h3 class="marker">interface DataOutput</h3><p>DataInput과 대칭</p><h3 class="marker">abstract class InputStream implements Closeable</h3><ol><li>바이트 단위 읽기에 대한 최상위 추상 클래스</li><li>작업이 끝날 때까지 스레드가 블록되며, 스트림이 비동기적으로 닫히거나, 인터럽트가 발생하는 경우에 대해 대처하지 않는다.</li></ol><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static InputStream nullInputStream() Since 11
    // 아무것도 읽지 않는 InputStream을 반환한다. 반환된 스트림은 처음부터 열려 있고, 마치 스트림의 끝에 도달한 것처럼 작동한다. 일반 InputSteram과 마찬가지로 close()를 통해 닫는다.

long transferTo(OutputStream out) Since 9
    // 입력 스트림의 모든 바이트를 읽어들여 out에 쓴다. 총 전송 바이트 수를 반환하며, 스트림을 닫는 작업을 하진 않는다.
byte[] readAllBytes() Since 9
byte[] readNBytes(int len) Since 11

long skip(long n)
    // 실제로 건너뛴 바이트 수를 반환. 음수 매개변수에 대해 0을 반환한다. 서브클래스들의 구현은 이와 다를 수 있다.
int available()
    // 막힘 없이 한 번에 읽어올 수 있는 바이트 수 예상값을 반환. InputStream 구현에 따라 전체 바이트 수를 반환하기도, 그렇지 않기도 하다. InputStream 자체는 항상 0을 반환하며, 서브클래스에서 재정의해야 한다.

// 마킹 관련
boolean markSupported()    // mark, reset 메서드를 지원하는지 여부 반환. 기본 false
void mark(int readlimit)   // 현재 위치 마킹
void reset()               // 마지막 마킹 위치로 이동
</div><h3 class="marker">abstract class OutputStream implements Closeable, Flushable</h3><ol><li>바이트 단위 쓰기에 대한 최상위 추상 클래스</li></ol><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static OutputStream nullOutputStream() Since 11
    // 실제로 데이터를 쓰지는 않는 OutputStream 객체를 반환한다.
</div><h3 class="marker">class FilterInputStream extends InputStream</h3><p>다른 InputStream에 대한 필터 장식자 정의 클래스로, 추가적인 메서드는 없다.</p><h3 class="marker">class FilterOutputStream extends OutputStream</h3><p>다른 OutputStream에 대한 필터 장식자 정의 클래스로, 추가적인 메서드는 없다.</p><h3 class="marker">class ByteArrayInputStream extends InputStream</h3><p>내부 버퍼 byte[] buf에 대한 읽기 연산을 지원하는 InputStream</p><h3 class="marker">class ByteArrayOutputStream extends OutputStream</h3><p>내부 버퍼 byte[] buf에 대해 쓰기 연산을 지원하는 OutputStream. 버퍼 크기는 자동으로 확장된다.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">void writeTo(OutputStream out)
    // 버퍼를 out에 모두 쓴다. == out.write(buf, 0, count)

byte[] toByteArray() // buf 복사본 반환.
void reset() // 지금까지 쓴 것을 무시하고 처음부터 재활용.
int size()
String toString(String charsetName)
</div><h3 class="marker">class BufferedInputStream extends FilterInputStream</h3><p>다른 입력 스트림에 버퍼를 제공하여 mark와 reset이 가능하게 해준다.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">protected byte[] buf
protected int count // 마지막 유효 바이트 인덱스 + 1
protected int marklimit, markpos, pos
    // |pos - markpos| &lt; marklimit면 markpos는 -1(기본값)이 된다.
</div><h3 class="marker">class BufferedOutputStream extends FilterOutputStream</h3><p>다른 출력 스트림에 버퍼를 제공하여, 시스템 쓰기 작업이 빈번하게 일어나지 않게 해준다.</p><h3 class="marker">class DataInputStream extends FilterInputStream implements DataInput</h3><p>플랫폼 독립적인 자바 기본 타입 읽기를 정의한 DataInput을 구현한 장식자 클래스(FilterInputStream).</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static final String readUTF(DataInput in)
    // Modified UTF-8을 이용하여 in 스트림으로부터 String을 해석해 반환한다.</div><h3 class="marker">class DataOutputStream extends FilterOutputStream implements DataOutput</h3><p>플랫폼 독립적인 자바 기본 타입 쓰기를 정의한 DataOutput을 구현한 장식자 클래스(FilterOutputStream)</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">protected int written
    // 현재까지 쓴 바이트 수. 오버플로될 경우 Integer.MAX_VALUE로 설정된다.
final int size() == return written;</div><h3 class="marker">class PrintStream extends FilterOutputStream implements Appendable, Closeable</h3><p>OutputStream, File에 기본 타입 및 각종 문자열을 쓰는 기능을 제공한다.</p><p>autoFlush : 바이트 배열을 다 쓰거나, 새 줄 문자, '\n'을 쓰면 자동으로 flush()</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">boolean checkError()
    // flush()한 다음 오류 상태를 검사한다. 예외를 던지지 않으므로 이 메서드로 확인해야 한다. 스트림에 InterruptedIOException이 발생하면 Thread.currentThread().interrupt()를 실행한다.</div><h3 class="marker">class PipedInputStream extends InputStream</h3><p>PipedOutputStream과 연결되어 바이트들을 받는 InputStream. PipedOutputStream과 별개의 스레드에서 동작해야 한다.<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/io/PipedStreamExample.java" lan="java">View Code »</button></p><h3 class="marker">class PipedOutputStream extends OutputStream</h3><p>연결된 PipedInputStream으로 바이트들을 보내는 OutputStream. PipedInputStream과 별개의 스레드에서 동작해야 한다.<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/io/PipedStreamExample.java" lan="java">View Code »</button></p><h3 class="marker">class SequenceInputStream extends InputStream</h3><p>여러 InputStream을 이어붙인듯이 활용하는 InputStream.</p><h3 class="marker">class PushbackInputStream extends FilterInputStream</h3><p>이미 읽은 것을 취소하고 다시 읽을 수 있는 기능을 지원한다. 이전에 읽은 내용을 저장하지는 않으므로, 덮어쓰기처럼 이용할 수 있다.<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/io/PushBackExample.java" lan="java">View Code »</button></p><h3 class="marker">class FileInputStream extends InputStream</h3><p><button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/io/SerializableExample.java" lan="java">View Code »</button></p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">FileChannel getChannel()
    // 유니크한 FileChannel을 반환하며, 채널에서의 위치는 스트림에서 읽어들인 만큼과 같다.</div><h3 class="marker">class FileOutputStream extends OutputStream</h3><p><button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/io/SerializableExample.java" lan="java">View Code »</button></p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">FileChannel getChannel()
    // 유니크한 FileChannel을 반환하며, 채널에서의 위치는 스트림에서 쓴 바이트 수와 같다(append 모드가 아닐 경우). append 모드에서는 파일의 크기와 채널의 위치가 동일하다.</div></div><h2 class="marker">객체 IO(직렬화) 관련</h2><div><h3 class="marker">interface ObjectInput extends DataInput, AutoCloseable</h3><p>DataInput을 통해 기본 자료형을 읽어오고, 추가적으로 객체를 읽어오는 작업을 지원한다.</p><h3 class="marker">interface ObjectOutput extends DataOutput, AutoCloseable</h3><p>DataOutput에 추가로 객체 쓰기 작업을 지원한다.</p><h3 class="marker">interface Serializable</h3><ol><li>직렬화와 역질렬화를 지원하는 마커 인터페이스. ObjectInputStream, ObjectOutputStream의 메서드들을 이용해 알아서 저장/복구한다.<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/io/SerializableExample.java" lan="java">View Code »</button></li><li>직렬화하지 않을 멤버는 transient 키워드로 표시한다.</li><li>직접 구현하고 싶다면 Externalizable 인터페이스를 구현하거나, 다음의 메서드들을 작성한다.</li><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">private void writeObject(java.io.ObjectOutputStream out) # out에 알아서 객체 표현 바이트들을 쓰면 된다.
private void readObject(java.io.ObjectInputStream in)    # in에서 바이트들을 읽어와 알아서 객체를 생성하면 된다.
private void readObjectNoData()                          # 객체들의 버전이 다르거나, 기타 이유로 객체를 초기화할 필요가 있는 경우 사용.</div><li>대체 객체를 이용해 저장 : ANY-ACCESS-MODIFIER Object writeReplace()</li><li>대체 객체를 이용해 복구 : ANY-ACCESS-MODIFIER Object readResolve()</li><li>클래스 버전</li><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">// 정의되지 않은 경우 기본값을 사용하지만, 명시할 것을 권장하고 있다.
ANY-ACCESS-MODIFIER static final long serialVersionUID = (version number)L;</div></ol><h3 class="marker">interface Externalizable extends Serializable</h3><ol><li>객체 직렬화를 직접 구현하고자 할 때 이를 구현한다. 객체 직렬화는 빈 객체를 만든 뒤 각 속성의 값을 쓰므로 기본 생성자가 필요하다.<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/io/ExternalizableExample.java" lan="java">View Code »</button></li></ol><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">void writeExternal(ObjectOutput out) # 객체를 out에 쓴다.
void readExternal(ObjectInput in)    # in으로 객체를 생성한다.</div><h3 class="marker">class ObjectInputStream extends InputStream implements ObjectInput, ObjectStreamConstants</h3><p>객체 읽기에 관한 InputStream.<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/io/SerializableExample.java" lan="java">View Code »</button></p><h3 class="marker">class ObjectOutputStream extends OutputStream implements OjbectOutput, ObjectStreamConstants</h3><p>객체 쓰기에 관한 OutputStream.<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/io/SerializableExample.java" lan="java">View Code »</button></p></div><h2 class="marker">문자 단위 IO 관련</h2><div><h3 class="marker">abstract class Reader implements Readable, Closeable</h3><ol><li>char 단위 읽기에 대한 최상위 추상 클래스</li><li>서브클래스들은 read(char[], int, int)와 close()만 구현해도 된다.</li></ol><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static Reader nullReader() Since 11
    // 아무 것도 읽지 않는 Reader 객체를 반환한다.

int read()
    // char 하나를 읽고 int로 반환. 스트림의 끝이라면 -1을 반환한다.
int read(char[] cbuf)
abstract int read(char[] cbuf, int off, int len)
    // 실제로 읽은 글자 수를 반환.

long skip(long n)
    // 실제로 건너 뛴 글자 수(바이트 수x) 반환

boolean ready()
    // 다음 read()가 블록되지 않음을 보장하면 true, 보장하지 못하면 false

// 마킹 관련 : InputStream과 유사

long transterTo(Writer out) Since 10
    // 모든 글자를 읽어 out에 쓴다. 전송한 글자 수를 반환한다.</div><h3 class="marker">abstract class Writer implements Appendable, Closeable, Flushable</h3><ol><li>char 단위 쓰기에 대한 취상위 추상 클래스</li><li>Appendable하므로 편리함이 크다.</li></ol><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static Writer nullWriter() Since 11
    // 아무것도 쓰지 않는 Writer 객체를 반환한다.

void write(int c)
    // 하위 16비트만 쓴고 나머지는 무시한다.</div><h3 class="marker">class InputStreamReader extends Reader</h3><p>InputStream에 대해 Reader 작업을 지원해주는 bridge 클래스.<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/io/BufferedReaderExample.java" lan="java">View Code »</button></p><h3 class="marker">class OutputStreamWriter extends Writer</h3><p>OutputStream에 Writer 작업을 지원해주는 bridge 클래스.</p><h3 class="marker">abstract class FilterReader extends Reader</h3><p>다른 Reader에 대한 필터 장식자 정의 클래스로, 추가적인 메서드는 없다.</p><h3 class="marker">abstract class FilterWriter extends Writer</h3><p>다른 Writer에 대한 필터 장식자 정의 클래스로, 추가적인 메서드는 없다.</p><h3 class="marker">class CharArrayReader extends Reader</h3><p>내부 버퍼 char[] buf에 대한 읽기 연산을 지원하는 Reader</p><h3 class="marker">class CharArrayWriter extends Writer</h3><p>내부 버퍼 char[] buf에 대해 쓰기 연산을 지원하는 Writer. 버퍼 크기는 자동으로 확장된다.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">void writeTo(Writer out)
    // out에 버퍼의 모든 내용을 쓴다.
void reset()
    // 버퍼를 비우고 재활용한다.
char[] toCharArray()</div><h3 class="marker">class StringReader extends Reader</h3><p>String에 대해 읽기 연산을 수행하는 Reader.</p><h3 class="marker">class StringWriter extends Writer</h3><p>내부 StringBuffer에 쓰기 연산을 지원하는 Writer.</p><h3 class="marker">class BufferedReader extends Reader</h3><p>다른 Reader에 대한 버퍼를 제공하여, 시스템 읽기 작업이 빈번하게 일어나지 않게 해준다.<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/io/BufferedReaderExample.java" lan="java">View Code »</button></p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">String readLine()         // EOF도 줄의 끝으로 간주
Stream&lt;String> lines()</div><h3 class="marker">class BufferedWriter extends Writer</h3><p>Writer에 버퍼를 제공하여 시스템 쓰기 작업이 빈번하게 일어나지 않도록 한다.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">void newLine() // 줄 바꿈 문자열은 시스템 속성 line.separator로 결정된다.</div><h3 class="marker">class LineNumberReader extends BufferedReader</h3><p>Reader가 줄 끝을 만날때마다 라인을 카운트하는 클래스. 처음 시작은 0.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">void setLineNumber(int lineNumber) // 읽기 위치가 이동하는 건 아니다
int getLineNumber()</div><h3 class="marker">class PrintWriter extends Writer</h3><p>PrintStream의 Writer 버전. 텍스트 출력 스트림에 객체들을 정형화된 텍스트로 쓰는 기능을 제공한다.</p><h3 class="marker">class PipedReader extends Reader</h3><p>PipedInputStream과 유사.<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/io/PipedReaderExample.java" lan="java">View Code »</button></p><h3 class="marker">class PipedWriter extends Writer</h3><p>PipedOutputStream과 유사.<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/io/PipedReaderExample.java" lan="java">View Code »</button></p><h3 class="marker">class PushbackReader extends FilterReader</h3><p>PushbackInputStream과 비슷.<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/io/PushBackExample.java" lan="java">View Code »</button></p><h3 class="marker">class FileReader extends InputStreamReader</h3>특별한 내용 없음<h3 class="marker">class FileWriter extends OutputStreamWriter</h3>특별한 내용 없음</div><h2 class="marker">파일 관련</h2><div><h3 class="marker">@FunctionalInterface interface FileFilter</h3><p>파일 패스 필터링에 사용되며 File#listFiles의 매개변수로 객체가 넘겨진다.<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/io/FileFilterExample.java" lan="java">View Code »</button></p><h3 class="marker">@FunctionalInterface interface FilenameFilter</h3><p>특정 디렉터리에서의 파일명 필터링에 사용되며 FileDialog#setFilenameFilter, File#list, File#listFiles의 매개변수로 객체가 넘겨진다.<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/io/FilenameFilterExample.java" lan="java">View Code »</button></p><h3 class="marker">class File implements Serializable, Comparable&lt;file&gt;</h3><ol><li>추상화된 파일 및 디렉터리 경로에 대한 추상화된 표현 제공.(물리적 저장 장치 » 경로 문자열 » File 객체)</li><li>경로 문자열은 절대 경로, 상대 경로 둘 다 허용된다. 상대 경로의 기준 위치는 System속성 "user.dir"로 얻을 수 있다.</li><li>보다 많은 기능을 제공하는 java.nio.file 패키지가 존재한다.</li></ol><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">public static final char separatorChar, String separator
    // 시스템 속성 "file.separator", UNIX : '/', Windows : '\\'
public static final char pathSeparatorChar, String pathSeparator
    // 시스템 속성 "path.separator", UNIX : ':', Windows : ';'

URI toURI(), java.nio.file.Path toPath()
String getPath(), getAbsolutePath(), getParent() // ...
File getAbsoluteFile(), getParentFile()          // ...

boolean canRead(), exists(), isDirectory()          // ...
boolean setReadOnly(), setWritable(), setReadable() // ...

long lastModified(), length() // ...
long getTotalSpace(), getFreeSpace(), getUsableSpace()

boolean createNewFile(), delete(), renameTo() // ...
boolean mkdirs() // 경로상 필요한 모든 디렉터리들 생성

String[] list()
File[] listFiles()

int hashCode() : 추상 경로이름과 1234321 사이의 xor 연산

static File[] listRoots()
static File createTempFile(String prefix, String suffix)
    // (특정) 디렉터리에 새로운 빈 파일을 만들어 반환한다. 이 메서드는 오직 임시 파일 작업을 위해 만들어졌으며, deleteOnExit()을 통해 자동으로 정리되어야 한다.
    // prefix : 의미 있는 접두어, suffix : null이면 ".tmp"</div><p><button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/io/FileFilterExample.java" lan="java">FileFilter 예</button><button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/io/FilenameFilterExample.java" lan="java">FilenameFilter 예</button><button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/io/FileExample.java" lan="java">File 예</button></p><h3 class="marker">final class FilePermission extends Permission implements Serializable</h3><p>파일 및 디렉터리에 관한 권한을 표현하는 클래스.<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/io/FilePermissionExample.java" lan="java">View Code »</button></p><ul><li>"/*"로 끝나는 경로는 해당 디렉터리 내부 모든 파일 및 디렉터리를 가리킨다. "*"는 현재 디렉터리 내부.</li><li>"/-"로 끝나는 경로는 해당 디렉터리 내부 모든 파일 및 모든 서브디렉터리를 가리킨다. "-"는 현재 디렉터리 내부.</li><li>"&lt;&lt;ALL FILES>>"로 표현된 경로는 임의 파일과 대응한다.</li><li>권한 리스트는 콤마로 구분한 문자열로 표현한다.</li><p>가능한 키워드는 "read", "write", "execute"(Runtime.exec 메서드 호출 관련), "delete"(File.delete 메서드 호출 관련), "readlink"(java.nio.file.Files.readSymbolicLink 메서드와 관련)</p><li>주의 : 임의 파일에 대한 권한은 보안상 위험하다. 기본적으로 코드가 포함된 디렉터리는 읽기가 가능하므로 굳이 권한을 부여할 필요 없다.</li></ul><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">boolean implies(Permission p)
    // 객체의 권한이 인자의 권한을 내포하는지 여부 반환
PermissionCollection newPermissionCollection()
    // 예. 컬렉션에 다음 두 가지 권한─("/tmp/-", "read"), ("/tmp/scratch/foo", "write")─들이 있을 때, 이에 대한 implies메서드에 권한 ("/tmp/scratch/foo", "read,write")을 넘겨준 결과는 true를 반환해야 한다.</div><h3 class="marker">class RandomAccessFile implements DataOutput, DataInput, Closeable</h3><p>읽기/쓰기 가능한 임의 접근 파일. 읽기/쓰기의 기준 위치 file pointer가 존재.<br>읽기로 예정된 바이트들을 모두 읽기 전에 EOF를 만나면 EOFException 발생.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">RandomAccessFile(String name, String mode)
    // mode : "r", "rw", "rws"(파일 내용 및 메타데이터 변경을 곧바로 반영), "rwd"(파일 내용 변경을 곧바로 반영)

int read() // InputStream.read()와 동일

long getFilePointer()
void seek(long pos) // file pointer 설정

long length()
void setLength(long newLength)
    // 기존 크기 > newLength && getFilePointer() > newLength
    //     → 자르고, file pointer = newLength
    // 기존 크기 &lt; newLength
    //     → 확장. 확장한 영역의 데이터는 초기화되지 않는다.
</div></div></div><h1 class="marker">java.lang</h1><div><h2 class="marker">interface Appendable</h2><p>유니코드 CharSequence 또는 char 값을 덧붙일 수 있는 객체를 표현한다.</p><h2 class="marker">interface AutoCloseable</h2><p>자동으로 자원을 해제하는 객체를 표현한다. try-with-resources 블록에 사용되면 close()가 자동으로 호출된다. IO 작업이 없는 것들을 try-with-resources 블록에 이용하는 것은 불필요한 일이다.<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/Basic/src/io/github/donggi/TryWithResources.java" lan="java">View Code »</button></p><h2 class="marker">interface Cloneable</h2><p>Object#clone()을 재정의했음을 나타내는 마커 인터페이스.</p><h2 class="marker">interface Comparable&lt;T></h2><ol><li>자연스러운 순서로 클래스의 모든 객체를 정렬할 수 있음을 표현.</li><li>이를 구현한 클래스 객체들의 List, array는 Collections.sort, Arrays.sort로 각각 정렬할 수 있다.</li><li>이를 구현한 클래스 객체들은 Comparator 정의 없이 SortedMap, SortedSet의 키로 이용할 수 있다.</li><li>null은 객체가 아니므로 equals(null)이 false를 리턴하는 것과 달리 compareTo(null)은 NullPointerException을 내보내는 것이 바람직하다.</li><li>다음 성질을 만족하도록 구현함이 권장된다.</li><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">(e1.compareTo(e2) == 0) == e1.equals(e2)</div></ol><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">int compareTo(T o) {
    return this - o;
    // o보다 앞서면(작으면) 음수, 같으면 0, 뒤면(크면) 양수 반환.
}</div><h2 class="marker">interface Iterable&lt;T></h2><p>이를 구현한 클래스 객체는 enhanced for statement의 순회 대상이 될 수 있다.<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/lang/IterableExample.java" lan="java">View Code »</button></p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">Iterator&lt;T> iterator()
    // 구현한 클래스 인스턴스를 반환하면 된다.
default void forEach(Consumer&lt;? super T> action)
    // 순회하면서 action을 적용한다.
    // 기본 구현 : for(T t : this) action.accept(t);
default Spliterator&lt;T> spliterator()
    // 기본 구현은 Sliterator의 모든 사항을 구현하지 않으므로 재정의하는 것이 더 좋은 성능을 보인다.</div><h2 class="marker">interface ProcessHandle extends Comparable&lt;processhandle&gt; Since 9</h2><ol><li>native process들에 대한 제어 제공. 프로세스 생애 모니터링, 자식 프로세스 나열, 프로세스 정보 얻기, 프로세스 종료 등.<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/lang/ProcessHandleExample.java" lan="java">View Code »</button></li><li>프로세스 ID는 OS가 할당한 것으로, 값의 범위는 OS에 의존적이다.</li><li>ProcessHandle 객체는 다음 팩터리 메서드로 반환된다.</li><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">current(), of(long), children(), descendants(), parent(), allProcesses()
parent() // zombie 상태의 프로세스는 보통 parent가 없다.</div><li>SecurityManager의 RuntimePermission("manageProcess")만큼의 제어 권한을 갖는다.</li><li>ProcessHandle 객체들을 비교할 때는 equals, compareTo 메서드를 이용해야 한다.</li></ol><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">ProcessHandle.Info info()

boolean supportsNormalTermination()
    // destroy() 메서드가 정상적으로 프로세스를 종료하는지 여부. false면 프로세스를 강제로 즉시 종료함을 의미.
CompletableFuture&lt;ProcessHandle> onExit()
    // onExit().get()을 호출하면 프로세스가 종료되는 것을 기다린다.
    // supportsNormalTermination()이 false일 경우 onExit()에 등록한 후처리들이 진행되지 않을 수 있음.

boolean destroy()
    // 프로세스 종료에 시간이 걸릴 수 있으므로, isAlive()가 얼마간 true를 반환할 수 있다.
    // 성공적으로 프로세스를 종료하면 true, 아니면 false를 반환한다.
boolean destroyForcibly() // 강제 종료

long pid()
boolean isAlive() // PID가 유효하면 alive로 간주</div><div><h3 class="marker">static interface ProcessHandle.Info Since 9</h3><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">Optional&lt;String> command()            // 실행가능한 경로 반환
Optional&lt;String> commandLine()        // command()와 arguments()의 결과를 공백으로 구분한 결과 반환
Optional&lt;String[]> arguments()        // 프로세스의 인자 반환
Optional&lt;Instant> startInstant()      // 프로세스의 시작 시각 반환
Optional&lt;Duration> totalCpuDuration() // CPU 사용 시간 반환
Optional&lt;String> user()               // 프로세스 유저 반환</div></div><h2 class="marker">interface Readable</h2><p>Readable은 문자들에 대한 소스다.<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/lang/ReadableExample.java" lan="java">View Code »</button></p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">int read(CharBuffer cb)
    // 문자들을 그대로 cb에 put()을 통해 저장한다. cb에 대한 어떠한 사전처리도 없다. 저장한 char 개수를 반환하며, 소스의 끝이면 -1을 반환한다.</div><h2 class="marker">@FunctionalInterface interface Runnable</h2><p>Runnable은 한 스레드로서 실행되도록 구현돼야 한다. Thread의 run()만을 재정의할 때 사용한다.<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/lang/RunnableExample.java" lan="java">View Code »</button></p><h2 class="marker">class SecurityManager</h2><ol><li>보안 정책을 구현할 수 있는 클래스. 전형적인 확인 절차는 아래와 같다.</li><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">SecurityManager security = System.getSecurityManager();
if (security != null) {
    security.checkXXX(argument, . . . );
}</div></ol><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">Object getSecurityContext()           // 현재 실행 환경을 캡슐화한 객체 반환.
ThreadGroup getThreadGroup()          // 새로운 스레드를 생성할 수 있는 스레드그룹 반환
void checkPermission(Permission perm) // checkXXX()</div><h2 class="marker">final class Math, StrictMath</h2><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static double IEEEremainder(double f1, double f2)

static double rint(double d) // rount to even

// 오버플로우되면 예외
addExact, substractExact, multiplyExact, incrementExact, decrementExact, negateExact, toIntExact

static long multiplyFull(int x, int y)   // Since 9
static long multiplyHigh(long x, long y) // Since 9, 상위 64개 비트를 반환

floorDiv(x, y)
    // x/y에 가장 가까운 최대 정수를 반환
    // Integer.MIN_VALUE, Long.MIN_VALUE를 -1로 나누는 경우는 오버플로우가 발생하고, 각각 Integer.MIN_VALUE, Long.MIN_VALUE를 반환한다.
floorMod(x, y)
    // x - (floorDiv(x, y) * y)를 반환한다. 부호는 y와 같다.
fma(a, b, c)
    // Since 9, a * b + c에 가장 가까운 float, double을 반환</div><h2 class="marker">공유 변수 관련</h2><div><h3 class="marker">abstract class ClassValue&lt;T></h3><p>임의 타입에 대하여, 필요할 때에 연산된 값을 가져오도록 지원. 해당 값은 해당 타입에 대해 일관성을 갖는다.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">protected abstract T computeValue(Class&lt;?> type)
    // type에 대하여, 최초 get 메서드 호출 시 한 번만 호출되며, 이후 remove 메서드 호출이 없으면 더 이상 불리지 않는다.
T get(Class&lt;?> type)
    // 값이 계산되지 않은 상태에서 여러 스레드들이 경합을 벌일 경우, 임의 스레드의 결과값을 모두에 반환한다.
void remove(Class&lt;?> type)
    // 다음 get 호출 시 값을 새로 계산하도록 한다</div><h3 class="marker">class ThreadLocal&lt;T></h3><p>스레드 단위의 지역 변수를 제공한다. 호출 지점과 관계없이 한 스레드 내부에서 변수를 공유한다.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">protected T initialValue()
    // 초기값이 설정되지 않은 상태에서 최초 get() 호출에 의해 불린다. remove() 호출 후의 get() 요청으로 다시 불린다.
static &lt;S> ThreadLocal&lt;S> withInitial(Supplier&lt;? extends S> supplier)
    // supplier로 초기값이 설정되는 ThreadLocal 반환.</div><h3 class="marker">class InheritableThreadLocal&lt;T> extends ThreadLocal&lt;T></h3><p>ThreadLocal에 상속성을 부여. 자식 스레드는 부모의 thread-local 변수들을 모두 상속받고 시작한다. childValue 메서드를 재정의함으로써 부모의 값과 다르게 설정할 수도 있다.</p></div><h2 class="marker">타입 관련</h2><div><h3 class="marker">interface CharSequence</h3><p>일련의 char 값들을 표현한다. equals(), hashCode()에 대한 규약이 없어, 두 CharSequence 객체를 비교하는 결과는 정의되어 있지 않으며, 따라서 set이나 map의 키로 이용하기에 부적절하다.<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/lang/CharSequenceExample.java" lan="java">View Code »</button></p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static int compare(CharSequence cs1, CharSequence cs2) Since 11
    // 두 CharSequence를 사전순으로 비교한다.

default IntStream chars()
    // char들을 int로 0패딩하여 스트림 생성. 두 char로 쪼개진 유니코드 보충 평면의 문자를 하나로 합치진 않는다.
default IntStream codePoints()
    // 유니코드 값들을 스트림으로 생성. 보충 평면의 문자는 Character.toCodePoint 메서드를 통해 하나의 int 값으로 형성.</div><h3 class="marker">final class Boolean implements Serializable, Comparable&lt;Boolean></h3><p>원시 타입 boolean의 wrapper 클래스. 람다 활용을 위한 static 메서드들을 제공한다.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static boolean parseBoolean(String s)
    // s가 null이 아니고 대소문자 구분없이 "true"와 일치하면 true 반환.
static Boolean valueOf(String s)
    // == valueOf(parseBoolean(s))

static boolean getBoolean(String name)
    // name에 해당하는 system property가 존재하고, 대소문자 구분없이 "true"와 일치하면 true 반환

int compareTo(Boolean b)
    // TRUE.compareTo(FALSE) > 0, FALSE.compareTo(TRUE) &lt; 0</div><h3 class="marker">abstract class Number implements Serializable</h3><p>수에 관한 최상위 추상 wrapper 클래스</p><h3 class="marker">final class Byte extends Number implements Comparable&lt;Byte></h3><p>기본 타입 byte에 대한 wrapper 클래스. 람다 활용을 위한 static 메서드들을 제공한다.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static byte parseByte(String s, int radix)
    // 예외 : s가 null이거나 길이가 0일 때. s에 radix진수가 아닌 문자가 포함될 때(단, s가 2글자 이상일 때 첫 '-', '+'는 가능). radix가 [Character.MIN_RADIX, Character.MAX_RADIX] 범위를 벗어날 때, 값이 byte를 벗어날 때.
static Byte valueOf(String s, int radix)
static Byte decode(String nm)
    // 다음 문법으로 표현된 10진수, 16진수, 8진수를 parseByte()를 이용해 디코딩한다. 공백을 허용하지 않는다.
    //     (Sign?)(10진수)
    //     (Sign?)(0x | 0X | #)(16진수)
    //     (Sign?)0(8진수)
    //     Sign: '-', '+'

static int compare(byte x, byte y)
static int compareUnsigned(byte x, byte y) Since 9
static int toUnsignedInt(byte x)
static long toUnsignedLong(byte x)</div><h3 class="marker">final class Character implements Serializable, Comparable&lt;Character></h3><ol><li>기본타입 char에 대한 wrapper 클래스. 추가적으로 문자 집합(소문자, 숫자 등) 정의, 변환 기능을 갖는다.</li><li>유니코드 표준 8.0.0을 따른다.(JDK 9 기준)</li><ul><li>16비트 고정폭으로 값을 표현하며, 유효한 범위는 U+0000 부터 U+10FFFF까지(= Unicode scalar value).</li><ol><li>[U+0000, U+FFFF] == 기본 문자 평면(BMP; Basic Multilingual Plane)</li><li>(U+FFFF, ~) == 보충 문자 평면(supplementary characters)</li></ol><li>자바 플랫폼은 보충 평면의 문자들은 2개의 char의 쌍으로 표현한다.</li><li>하위 21개 비트를 이용하여 int 하나로 모든 유니코드 code point를 표현할 수 있다.</li></ul><li>int를 받는 메서드는 모든 유니코드를 처리할 수 있지만, char만을 받는 메서드는 보충 평면 문자를 처리하지 못한다.</li><button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/lang/CharacterExample.java" lan="java">View Code »</button></ol><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static final char MIN_HIGH_SURROGATE          // \uD800
static final char MAX_HIGH_SURROGATE          // \uDBFF
static final char MIN_LOW_SURROGATE           // \uDC00
static final char MAX_LOW_SURROGATE           // \uDFFF
static final int MIN_SUPPLEMENTARY_CODE_POINT // U+10000
static final int MIN_CODE_POINT               // U+0000
static final int MAX_CODE_POINT               // U+10FFFF

static String getName(int codePoint)
    // 이름 반환 : Character.UnicodeBlock.of(codePoint).toString().replace('_', ' ') + " " + Integer.toHexString(codePoint).toUpperCase(Locale.ROOT);
    // 정의되어 있지 않으면 null 반환
static int codePointOf(String name)
    // Since 9, 정의되어 있지 않으면 예외

static boolean isValidCodePoint(int codePoint)
static int getType(int codePoint)
static byte getDirectionality(char ch)
    // 문자 표시 순서를 반환한다. DIRECTIONALITY_UNDEFINED, DIRECTIONALITY_LEFT_TO_RIGHT 등
static boolean isMirrored(char ch)
    // 좌우 대칭되는 문자가 존재하는지 여부

static boolean isDigit(char ch)
    // getType(ch) == DECIMAL_DIGIT_NUMBER
static boolean isLetter(char ch)
    // getType(ch) == *_LETTER, isLetterOrDigit
static boolean isAlphabetic(int codePoint)
    // UPPERCASE_LETTER, LOWERCASE_LETTER, TITLECASE_LETTER, MODIFIER_LETTER, OTHER_LETTER, LETTER_NUMBER, 및 기타 알파벳 문자인지 여부
static boolean isSpaceChar(char ch)
    // getType(ch) == *_SEPARATOR
static boolean isWhitespace(char ch)
    // 공백 문자 '\t', '\n', 'u000B', '\f', '\r', '\u001C', '\u001D', '\u001E', '\u001F'
    // 단, non-breaking space('\u00A0', '\u2007', '\u202F') 제외

static int charCount(int codePoint)
    // 표현에 필요한 char 수(1 or 2)
static char[] toChars(int codePoint)
static String toString(int codePoint) Since 11

static char reverseBytes(char ch)
static int toCodePoint(char high, char low)
static int codePointAt(CharSequence seq, int index)
    // + codePointBefore, highSurrogate, lowSurrogate
static int codePointCount(CharSequence seq, int beginIndex, int endIndex)
    // [beginIndex, endIndex) 사이의 유니코드 문자 수 반환
static int offsetByCodePoints(CharSequence seq, int index, int codePointOffset)
    // 지정된 index로부터 offset 개수만큼 유니코드를 건너뛴 위치. +일 경우 index 포함, -인 경우 index 미포함(예시 코드 참고)

static int toLowerCase(int codePoint)
    // + toUpperCase, toTitleCase
    // isLowerCase(toLowerCase(x))가 항상 true는 아니다.

static int digit(int codePoint, int radix)
static char forDigit(int digit, int radix)
static int getNumericValue(int codePoint)</div><div><h4 class="marker">static class Character.Subset</h4><p>이 클래스의 객체는 유니코드 문자 집합을 표현한다. Character 클래스 내부에서 정의한 문자 집합은 Character.UnicodeBlock뿐이다.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">final String toString() // name 반환</div><h4 class="marker">static final class Character.UnicodeBlock extends Character.Subset</h4><p>유니코드 문자 블록. 각 문자들은 최대 하나의 유니코드 블록에 포함된다.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static Character.UnicodeBlock ARABIC, GREEK, HANGUL // 등

static Character.UnicodeBlock of(char c)            // c가 속한 유니코드 블록 반환
static final Character.UnicodeBlock forName(String blockName)
    // 블록 이름이 변경된 경우, 변경 전/후 이름 둘 다 사용할 수 있다.</div><h4 class="marker">static enum Character.UnicodeScript</h4><p>유니코드 표준 스크립트 이름 정의를 표현. 모든 문자는 하나의 스크립트(각 언어|INHERITED|COMMON|UNKNOWN)에 할당된다.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">ARABIC, GREEK, HANGUL // 등

static Character.UnicodeScript of(int codePoint)</div></div><h3 class="marker">final class Double extends Number implements Comparable&lt;Double>, Constable, ConstantDesc</h3><p>기본 타입 double에 대한 wrapper 클래스. 람다 활용을 위한 static 메서드들을 제공한다.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">public static final double POSITIVE_INFINITY // Double.longBitsToDouble(0x7ff0000000000000L)
public static final double NEGATIVE_INFINITY // Double.longBitsToDouble(0xfff0000000000000L)
public static final double NaN               // Double.longBitsToDouble(0x7ff8000000000000L)
public static final double MAX_VALUE         // Double.longBitsToDouble(0x7fefffffffffffffL), 0x1.fffffffffffffP+1023
public static final double MIN_NORMAL        // Double.longBitsToDouble(0x0010000000000000L), 0x1.0p-1022
    // 진수가 1 이상인 가장 작은 양수 표현.
public static final double MIN_VALUE         // Double.longBitsToDouble(0x1L), 0x0.0000000000001P-1022
    // 가장 작은 양수 표현

static Double valueOf(String s) // + parseDouble
static String toHexString(double d)

static long doubleToLongBits(double value)
    // double 표현 그대로 long으로 전환. 63번 비트는 부호, 62-52번 비트는 지수, 51-0번 비트는 진수
static long doubleToRawLongBits(double value)
    // NaN의 경우 각각의 NaN에 대응하는 값으로 반환.
static double longBitsToDouble(long bits)
    // NaN : [0x7ff0000000000001L, 0x7fffffffffffffffL] or [0xfff0000000000001L, 0xffffffffffffffffL]

int compareTo(Double anotherDouble)
    // Double.NaN > Double.POSITIVE_INFINITY
    // 0.0d > -0.0d</div><h3 class="marker">final class Integer extends Number implements Comparable&lt;Integer></h3><p>기본 타입 int에 대한 wrapper 클래스. 람다 활용을 위한 static 메서드들을 제공한다.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static String toString(int i, int radix)
    // + toUnsignedString, toBinaryString, toOctalString, toHexString
    // radix in [Character.MIN_RADIX, Character.MAX_RADIX]
static int parseInt(CharSequence s, int beginIndex, int endIndex, int radix)
    // Since 9, [beginIndex, endIndex)
    // + parseUnsignedInt, valueOf
    // 파싱 중 CharSequence 변경에 대한 조치를 하지 않음
static Integer decode(String nm) // Byte#decode 참고

static Integer getInteger(String nm, int val)
    // 시스템 속성값을 decode 메서드로 변환하여 반환.
    // nm : property name, val : 기본값

// unsigned 연산
static int compareUnsigned(int x, int y)
static long toUnsignedLong(int x)
static int divideUnsigned(int dividend, int divisor)
static int remainderUnsigned(int dividend, int divisor)

// bit 연산
static int highestOneBit(int i)            // + lowestOneBit
static int numberOfLeadingZeros(int i)     // + numberOfTrailingZeros
static int bitCount(int i)
static int rotateLeft(int i, int distance) // + rotateRight
static int reverse(int i)
static int reverseBytes(int i)             // 바이트 단위로 뒤집기</div><h3 class="marker">final class String implements Serializable, Comparable&lt;String>, CharSequence, Constable, ConstantDesc</h3><ol><li>유니코드 보충 평면 문자는 surrogate pairs로써 2자리를 차지한다.</li><li>로캐일을 고려한 문자열 비교는 Collator 클래스를 이용.</li><li>람다 활용을 위한 static 메서드들을 제공한다</li></ol><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static final Comparator&lt;String> CASE_INSENSITIVE_ORDER
    // 대소문자 구분없는 비교자. 직렬화 가능.

static String format(String format, Object... args)
static String valueOf(Object obj) : obj.toString()

boolean isEmpty() // 길이가 0인지 여부
boolean isBlank() // Since 11, 비거나 공백 문자로만 이루어졌는지 여부

byte[] getBytes(Charset charset)
    // 문자셋이 지정되지 않은 경우, 플랫폼 기본 문자셋을 이용한다. 기본 문자셋을 변경하려면 JVM 옵션을 조정하면 된다.

// 비교
boolean contentEquals(StringBuffer sb)
boolean equalsIgnoreCase(String anotherString)
int compareToIgnoreCase(String str)
boolean regionMatches(int tooffset, String other, int ooffset, int len)
    // 부분 문자열이 일치하는지 여부 반환. t(his's)offset, o(ther's)offset
boolean startsWith(String prefix, int toffset)
boolean endsWith(String suffix)

// 검색
int indexOf(String str, int fromIndex) // + lastIndexOf
boolean matches(String regex)          // == Pattern.matches(regex, str)
boolean contains(CharSequence s)
String replaceAll(String regex, String replacement) // + replaceFirst
String replace(CharSequence target, CharSequence replacement)

String[] split(String regex, int limit)
    // limit이 음수인 경우, 제한 없이 분리. 0인 경우 빈 문자열로 끝나지 않음.
static String join(CharSequence delimiter, CharSequence... elements)

String trim()             // 시작과 끝의 공백(&lt;= U+0020) 제거
String strip()            // Since 11, + stripLeading, stripTrailing. 공백 제거
Stream&lt;String> lines() // Since 11, 줄 끝(\n, \r, \r\n) 기준으로 분리
String indent(int n)      // Since 12, 각 줄이 n개의 공백으로 시작하도록 조정하고, 줄 끝을 \n로 정규화한다. n이 음수인 경우, 최대 n개의 앞선 공백을 제거한다.

&lt;R> R transform(Function&lt;? super String, ? extends R> f) // Since 12
String repeat(int count) // Since 11</div><h3 class="marker">final class StringBuffer implements Serializable, Comparable&lt;StringBuffer>, CharSequence</h3><p>스레드-안전한 변경 가능한 문자열.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">void trimToSize()
    // 버퍼 크기를 줄여 문자열 크기에 맞춘다
void setLength(int newLength)
    // 새로운 크기의 문자열에 기존 문자열을 복사. 남는 부분은 '\u0000'(null)로 채워진다.
void ensureCapacity(int minimumCapacity)
StringBuffer reverse()</div><h3 class="marker">final class StringBuilder implements Serializable, Comparable&lt;StringBuilder>, CharSequence</h3><p>StringBuffer의 비동기화 버전.</p><h3 class="marker">abstract class Enum&lt;E extends Enum&lt;E>> implements Constable, Comparable&lt;E>, Serializable</h3><p>모든 enum의 베이스. Enum을 집합이나 맵의 키로 이용하면 효율적인 구현을 얻을 수 있다.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">final String name()
final int ordinal()
final Class&lt;E> getDeclaringClass()
static &lt;T extends Enum&lt;T>> T valueOf(Class&lt;T> enumType, String name)</div><div><h4 class="marker">static final class Enum.EnumDesc&lt;E extends Enum&lt;E>> extends DynamicConstantDesc&lt;E> Since 12</h4><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static &lt;E extends Enum&lt;E>> Enum.EnumDesc&lt;E> of(ClassDesc enumClass, String constantName) Since 12</div></div><h3 class="marker">class Throwable implements Serializable</h3><p>모든 에러와 예외의 조상.</p></div><h2 class="marker">클래스 관련</h2><button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/lang/ClassExample.java" lan="java">View Code »</button><div><h3 class="marker">final class Class&lt;T> implements Serializable, GenericDeclaration, Type, AnnotatedElement, TypeDescriptor.OfField&lt;Class&lt;?>>, Constable</h3><div><h4 class="marker">Nest</h4><p>Nest는 같은 런타임 패키지 안의, private member에 접근 가능한 클래스와 인터페이스의 집합.
Nest에 속한 클래스, 인터페이스를 nestmate라 부르고, 하나의 nest에서 하나의 nestmate는 host 역할을 하고 나머지 nestmate 목록을 갖는다.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">Class&lt;?> getNestHost() Since 11
Class&lt;?>[] getNestMembers() Since 11</div></div><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">// ClassLoader 관련
ClassLoader getClassLoader()
InputStream getResourceAsStream(String name)
URL getResource(String name)
static Class&lt;?> forName(String className)
    // 로드된 클래스는 초기화가 진행된다.
static Class&lt;?> forName(String name, boolean initialize, ClassLoader loader)
static Class&lt;?> forName(Module module, String name)
    // Since 9, 주어진 모듈에서 binary name을 가진 클래스를 반환한다.
    // 클래스를 초기화하지 않으며, 클래스를 찾을 수 없으면 null을 반환한다.
    // 참고 : https://docs.oracle.com/javase/9/docs/api/java/lang/ClassLoader.html#name

// 타입 관련
T cast(Object obj)
    // obj를 호출한 Class 객체와 같은 타입으로 변환
&lt;U> Class&lt;? extends U> asSubclass(Class&lt;U> clazz)
    // 호출한 Class 객체의 타입을 변환한다. 반환되는 변수는 현재 객체를 참조한다.
    // U : 변환하고자 하는 타입, clazz : 변환하고자 하는 타입 Class 객체
boolean isInstance(Object obj)
    // instanceof 연산자의 동적인 형태. 원시타입 클래스 객체는 false만 반환한다.
boolean isAssignableFrom(Class&lt;?> cls)
    // cls 타입 객체를 현재 클래스의 참조 변수로 참조할 수 있는지 여부 반환.
boolean isInterface()
    // + isArray, isPrimitive, isAnnotation, isEnum, isAnonymousClass, isLocalClass, isMemberClass
    // wrapper 클래스는 원시타입이 아님에 유의 : Integer.class != Integer.TYPE, Integer.TYPE == int.class
boolean isSynthetic()
    // Synthetic class : 명시적/암시적으로 생성자가 정의되지 않은 채 생성된 클래스
boolean isNestmateOf(Class&lt;?> c) // Since 11

// 클래스 이름 관련
String toGenericString()
    // 접근한정자 및 타입 포함하여 반환
String getName()
    // 배열의 경우 차원마다 '['를 붙이며, 배열 원소 타입을 아래와 같이 인코딩한다.
    // boolean : Z, byte : B, char : C, class or interface : L{className};, double : D, float : F, int : I, long : J, short : S
String getSimpleName()
    // 익명 클래스면 빈 문자열 반환
String getCanonicalName()
    // Local class, 익명 클래스, 또는 이들의 배열은 canonical name이 없어 null을 반환한다.

// 리플렉션 관련
Module getModule() // Since 9
Package getPackage()
String getPackageName()
    // Since 9, 익명 패키지면 빈 문자열 반환. 배열 클래스의 경우 원소 타입이 속한 패키지 이름 반환. 원시 타입 또는 void의 경우 "java.lang" 반환.
Class&lt;?>[] getClasses()
    // public 멤버로 정의된 클래스, 인터페이스 Class 객체 배열 반환.
    // + getFields, getMethods, getConstructors
    // + getField(String name), getMethod, getConstructor
Class&lt;?>[] getDeclaredClasses() + getDeclaredFields, getDeclaredMethods, getDeclaredConstructors
    // 상속된 것을 제외하고, 호출하는 클래스 내부에 정의된 public, protected, default, private 클래스와 인터페이스들을 반환한다.
    // + getDeclaredField, getDeclaredMethod, getDeclaredConstructor
T[] getEnumConstants()

Class&lt;?> getComponentType()
    // 배열 원소 타입 클래스 객체 반환. 배열이 아닌 경우 null 반환
Method getEnclosingMethod()
    // 이 클래스가 메서드 내부에서 정의된 경우, 해당 메서드를 반환한다.
    // + getEnclosingConstructor, getDeclaringClass, getEnclosingClass
int getModifiers()
    // java.lang.reflect.Modifier
boolean isAnnotationPresent(Class&lt;? extends Annotation> annotationClass)</div><h3 class="marker">abstract class ClassLoader extends Object</h3><ol><li>전형적으로, 로드할 클래스 이름을 파일명으로 변환하여 ".class"파일을 읽어온다.</li><li>모든 Class 객체들은 ClassLoader에 대한 참조를 갖고 있다.</li><li>배열의 경우 런타임에 Class 객체가 생성되며, 이때 Class.getClassLoader()는 원소의 것과 동일하다.</li><li>클래스를 로드하는 것 외에, 자원(.class 파일, 구성 파일, 이미지 등)을 배치하는 책임도 진다.</li><li>Delegation model : ClassLoader 객체들은 각기 parent class loader를 갖는다. 클래스나 자원을 찾기 전에 parent를 먼저 조사하게 된다.</li><li>동시 로딩을 지원하는 parallel capable class loader들은 클래스 초기화 시 registerAsParallelCapable()를 통해 등록해야 한다. ClassLoader 클래스는 기본적으로 등록되나, 서브클래스들도 자신을 등록해야 한다.</li><li>계층구조가 약한 delegation model의 경우 클래스 로더들이 parallel capable하지 않으면 deadlock 발생 가능성이 있다.</li><li>Run-time Built-in Class Loaders</li><ul><li>Bootstrap class loader : JVM 내장 클래스 로더. 보통 null이며, parent가 없다.</li><li>Platform class loader : Java SE APIs, JDK-specific run-time classes</li><li>System class loader, a.k.a Application class loader : Used to define classes on the application class path, module path, and JDK-specific tools</li></ul><li>파일이 아닌 네트워크 같은 다른 소스로부터 클래스를 로드할 경우, defineClass()를 통해 Class 객체를 얻고 Constructor.newInstance()를 통해 클래스 객체를 생성하면 된다.</li><li>네트워크 클래스 로더는 findClass(), loadClassData() 메서드를 반드시 작성해야 한다.</li><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">public Class findClass(String name) {
    byte[] b = loadClassData(name);
    return defineClass(name, b, 0, b.length);
}
private byte[] loadClassData(String name) { /**/ }</div><li>Binary names</li><p>ClassLoader 메서드에 전달하는 String 타입 클래스 이름은 아래와 같은 형식을 따라야 한다.<br>"java.lang.String", "javax.swing.JSpinner$DefaultEditor", "java.security.KeyStore$Builder$FileBuilder$1", "java.net.URLClassLoader$3$1"</p></ol><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">protected ClassLoader(String name, ClassLoader parent) Since 9
    // parent가 null일 경우, 해당 클래스 로더가 모든 플랫폼 클래스를 볼 수 있다는 보장은 없다.
    // name : class loader's name; or null if not named
String getName()
    // Since 9, 클래스 로더 이름 반환. 없으면 null

Class&lt;?> loadClass(String name) // == loadClass(name, false)
protected Class&lt;?> loadClass(String name, boolean resolve)
     // 1. findLoadedClass(String)로 이미 로드됐나 확인
     // 없으면 : parent 혹은 VM의 클래스 로더의 loadClass를 호출
     // 없으면 : findClass(String) 호출
     // 2. 위를 통해 클래스를 찾았고, resolve가 true면 resolveClass(Class) 호출.
     // 3. ClassLoader의 서브클래스들은 이 메서드가 아닌 findClass(String)을 재정의하면 된다.
     // 4. 재정의되지 않은 이상, getClassLoadingLock()을 통해 메서드는 동기화된다.
protected final void resolveClass(Class&lt;?> c) : 클래스를 링크한다.

static ClassLoader getPlatformClassLoader() // Since 9
static ClassLoader getSystemClassLoader()
    // 시스템 클래스 로더를 반환하며, 이는 새롭게 정의되는 클래스 로더들의 default delegation parent다.

// 리소스 관련
URL getResource(String name)
Enumeration&lt;URL> getResources(String name)
Stream&lt;URL> resources(String name) // Since 9
static URL getSystemResource(String name)
static Enumeration&lt;URL> getSystemResources(String name)
InputStream getResourceAsStream(String name)
static InputStream getSystemResourceAsStream(String name)</div><h3 class="marker">final class Module implements AnnotatedElement Since 9</h3><p>이름 있는 모듈에 속하지 않은 모든 타입은 각 클래스 로더의 익명 모듈에 속한다.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">InputStream getResourceAsStream(String name)
    // 해당 모듈의 리소스를 스트림으로 반환. name은 '/'으로 구분된 경로
</div></div><h2 class="marker">프로그램 실행 단위</h2><div><h3 class="marker">class Thread implements Runnable</h3><ol><li>스레드는 실행 우선순위를 가지며, 그 초깃값은 스레드를 생성한 스레드의 것과 같다. 데몬 스레드로부터 생성된 스레드도 데몬 스레드다.</li><li>JVM이 시작되면 하나의 non-daemon 스레드가 존재하며, 전형적으로 main 메서드를 호출한다. JVM은 다음의 상황 중 하나라도 일어나기 전까지 실행을 계속한다.</li><ul><li>Runtime 클래스의 exit 메서드 호출, 또는 SecurityManager의 exit 허용</li><li>모든 데몬 스레드가 아닌 스레드들의 종료 : run 메서드의 반환이든 예외 발생이든 관계없이</li></ul></ol><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">public static final int MIN_PRIORITY
public static final int NORM_PRIORITY
public static final int MAX_PRIORITY

final void setDaemon(boolean on)
    // 스레드를 daemon 또는 user 스레드로 변경. 스레드가 시작되기 전에 호출돼야한다.
    // user 스레드가 하나도 없으면 프로그램은 종료된다.

void start() // JVM이 run() 호출. 스레드를 재시작하는 것은 허용되지 않는다.
void run()   // 관련된 Runnable의 run() 호출
void interrupt()
    // 1. checkAccess()가 호출된다. wait, join, sleep으로 블록된 경우 인터럽트 상태가 초기화되고, InterruptedException 발생.
    // 2. InterruptibleChannel로 I/O 작업 중 블록된 경우, 인터럽트 상태가 설정되고 채널은 닫힌다. ClosedByInterruptException 발생.
    // 3. Selector에서 블록된 경우, 인터럽트 상태가 설정되고 selection 연산에서 즉시 반환된다. 그 외의 경우 인터럽트 상태가 설정된다.

static Thread currentThread()
ClassLoader getContextClassLoader()

long             getId()
Thread.State     getState()
static boolean   interrupted()     // 현재 스레드가 인터럽드됐는지 여부. 스레드의 인터럽트 상태는 이 메서드로 인해 초기화된다.
boolean          isInterrupted()   // 스레드의 인터럽트 상태를 변경하지 않고 반환한다.
final boolean    isAlive()
final void       join(long millis) // 이 스레드가 중지되기까지 일시 대기. 0이면 무기한 대기. 지정 되지 않은 경우 0

static void dumpStack()
    // 현재 스레드의 스택 추적을 표준 에러 출력
final void checkAccess()
    // 현재 스레드가 이 스레드를 변경할 수 없으면 SecurityException 발생
static boolean holdsLock(Object obj)
    // 특정 객체를 lock으로 갖는지 확인

static void setDefaultUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)
void        setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)</div><div><h4 class="marker">static void onSpinWait() Since 9</h4><p>Spin-wait 루프에서 조건이 충족되어 루프를 벗어나기를 기다린다.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">class EventHandler {
    volatile boolean eventNotificationNotReceived;
    void waitForEventAndHandleIt() {
        while ( eventNotificationNotReceived ) {
            java.lang.Thread.onSpinWait();
        }
        readAndProcessEvent();
    }

    void readAndProcessEvent() {
        // Read event from some source and process it
         . . .
    }
}</div><h4 class="marker">static enum Thread.State</h4><p>NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED</p><h4 class="marker">@FunctionalInterface static interface Thread.UncaughtExceptionHandler</h4><ol><li>처리되지 않은 예외로 인해 스레드가 종료되는 상황을 대비한 핸들러. 그러한 상황에서, 먼저 Thread.getUncaughtExceptionHandler()를 통해 얻은 핸들러에 해당 스레드와 예외 객체를 전달한다.</li><li>만일 스레드에 핸드러가 설정되지 않은 경우, ThreadGroup의 핸들러를 이용하며, ThreadGroup에도 없는 경우 default 핸들러를 이용할 수 있다.</li></ol></div><h3 class="marker">class ThreadGroup implements Thread.UncaughtExceptionHandler</h3><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">final void setDaemon(boolean daemon)
    // 데몬 스레드 그룹은 마지막 스레드나 스레드 그룹이 파괴되면 자동으로 파괴된다.

int activeCount()
int enumerate(...)

final void interrupt() // 그룹의 모든 스레드에 인터럽트
final void destroy()   // 그룹과 하위 모든 그룹을 파괴
</div><h3 class="marker">abstract class Process</h3><p>ProcessBuilder.start, Runtime.exec으로 시작된 native process들에 대한 제어 제공.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">abstract OutputStream getOutputStream()
    // + getInputStream, getErrorStream

abstract int waitFor()
    // 현재 스레드가 이 프로세스의 종료를 기다린다. 프로세스의 종료 값을 반환.
boolean waitFor(long timeout, TimeUnit unit)
    // 시간 내에 프로세스가 종료되었다면 true 반환

abstract int exitValue()
abstract void destroy()   // 정상 종료.
Process destroyForcibly() // 강제, 즉시 종료.
boolean isAlive()

// Since 9
long pid()
boolean supportsNormalTermination()
CompletableFuture&lt;Process> onExit()
ProcessHandle toHandle()
ProcessHandle.Info info()
Stream&lt;ProcessHandle> children()
Stream&lt;ProcessHandle> descendants()
</div><h3 class="marker">final class ProcessBuilder</h3><p>이 클래스는 스레드-안전하지 않다.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">ProcessBuilder command(String... command)
ProcessBuilder directory(File directory)
ProcessBuilder redirectInput(ProcessBuilder.Redirect source)
    // + redirectOutput, redirectError
ProcessBuilder inheritIO()
ProcessBuilder redirectErrorStream(boolean redirectErrorStream)
    // true면 서브프로세스들의 에러 출력이 표준 출력으로 나온다.

Process start()

static List&lt;Process> startPipeline(List&lt;ProcessBuilder> builders)
    // Since 9, 프로세스들의 표준 출력을 다음 프로세스의 표준 입력으로 연결한다.</div><div><h4 class="marker">abstract static class ProcessBuilder.Redirect</h4><p>서브프로세스의 입력 소스 또는 출력 방향을 표현한다.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">public static final ProcessBuilder.Redirect PIPE    // 현재 프로세스와 파이프로 연결
public static final ProcessBuilder.Redirect INHERIT // 현재 프로세스의 것과 동일
public static final ProcessBuilder.Redirect DISCARD // Since 9, 출력 버림

static ProcessBuilder.Redirect from(File file)
static ProcessBuilder.Redirect to(File file) // file의 이전 내용은 새로운 쓰기 작업에 의해 버려진다.
static ProcessBuilder.Redirect appendTo(File file)</div><div><h5 class="marker">static enum ProcessBuilder.Redirect.Type</h5><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">APPEND, // Redirect.appendTo(File)
INHERIT,
PIPE,
READ, // Redirect.from(File)
WRITE // Redirect.to(File)
</div></div></div><h3 class="marker">class Runtime</h3><p>모든 Java 애플리케이션은 하나의 Runtime 인스턴스를 가진다.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static Runtime getRuntime()

void exit(int status)
    // 현재 실행중인 JVM을 종료
void addShutdownHook(Thread hook)
    // + removeShutdownHook
    // JVM이 종료 절차에 진입하면 등록된 모든 hook를 실행
void halt(int status)
    // 강제종료
Process exec(String[] cmdarray, String[] envp, File dir)

int availableProcessors()
long freeMemory()
    // + totalMemory, maxMemory
void gc()
void runFinalization()
    // 소멸 대기중인 모든 객체 소멸
</div><h3 class="marker">final class System</h3><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">public static final InputStream in // + out, err
static void setIn(InputStream in)  // + setOut, setErr

static long currentTimeMillis() // + nanoTime
static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)
static int identityHashCode(Object x)

static String lineSeparator()
static void setProperties(Properties props) // getProperties
static String setProperty(String key, String value)
static String clearProperty(String key)
static String getenv(String name) // 환경변수
static System.Logger getLogger(String name) // Since 9
static void exit(int status)</div><div><h4 class="marker">static interface System.Logger Since 9</h4><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">String getName()
boolean isLoggable(System.Logger.Level level)
default void log(System.Logger.Level level, String msg)</div><div><h5 class="marker">static enum System.Logger.Level Since 9</h5><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">ALL(Integer.MIN_VALUE), TRACE(400), DEBUG(500), INFO(800), WARNING(900), ERROR(1000), OFF(Integer.MAX_VALUE)</div></div><h4 class="marker">abstract static class System.LoggerFinder Since 9</h4><ul><li>로거의 생성, 관리, 구성에 관한 서비스 제공.</li><li>기본 구현 : java.logging 모듈이 있는 경우 java.util.logging이용. 없으면 INFO 수준으로 표준 에러 출력</li></ul></div><h3 class="marker">final class StackWalker Since 9</h3><p>현재 스레드의 StackFrame에 대한 스트림을 열고 특정 작업을 수행한다. 스트림은 실행 지점인 맨 위 frame부터 아래로 내려가면서 작업한다.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static StackWalker getInstance(...)
    // 기본 설정 : 숨겨진 프레임 생략. 클래스 정보 미포함.

&lt;T> T walk(Function&lt;? super Stream&lt;StackWalker.StackFrame>, ? extends T> function)
    // 예. 현재 스레드의 상위 10개 스택 프레임 가져오기.
    StackWalker.getInstance().walk(s -> s.limit(10).collect(Collectors.toList()));
void forEach(Consumer&lt; super StackWalker.StackFrame> action)

Class&lt;&?> getCallerClass()
    // 이 메서드를 호출하는 호출자의 클래스 객체를 반환.
    // Util#getResourceBundle 메서드는 이 메서드를 통해 얻은 호출자의 클래스로부터 클래스 로더를 얻고, 클래스 로더를 통해 리소스를 로드한다.</div><div><h4 class="marker">static enum StackWalker.Option Since 9</h4><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">RETAIN_CLASS_REFERENCE // StackFrame에 클래스 정보 유지
SHOW_HIDDEN_FRAMES     // 숨겨진 프레임 표시.
SHOW_REFLECT_FRAMES    // reflection 프레임 표시
</div><h4 class="marker">static interface StackWalker.StackFrame Since 9</h4><p>각 StackFrame 객체는 StackWalker로부터 반환된, 메서드 호출을 표현한다.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">String            getMethodName()       // 메서드 이름 반환.
String            getClassName()        // 메서드가 정의된 클래스의 binary name 반환
Class&lt;?>       getDeclaringClass()   // 메서드가 정의된 클래스 객체 반환. Option.RETAIN_CLASS_REFERENCE 설정 필요
StackTraceElement toStackTraceElement() // 프레임에 관한 StackTraceElement 반환.
</div></div><h3 class="marker">final class StackTraceElement implements Serializable</h3><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">String  getFileName()
int     getLineNumber()
String  getMethodName()
String  getClassName()
String  getClassLoaderName() // Since 9
String  getModuleName() // Since 9
</div></div></div><h1 class="marker">java.lang.annotation</h1><div><h2 class="marker">interface Annotation</h2><p>이 인터페이스를 구현하는 것으로 새로운 애너테이션을 정의할 순 없다.</p><h2 class="marker">enum ElementType</h2><p>애너테이션이 적용되는 요소를 표현한다.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VALIABLE, ANNOTATION_TYPE, PACKAGE, TYPE_PARAMETER, MODULE // Since 9</div><h2 class="marker">enum RetentionPolicy</h2><p>애너테이션 유지 정책.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">SOURCE  // 컴파일러가 제거
CLASS   // 컴파일러가 클래스 파일에 기록(default)
RUNTIME // 클래스 파일에 기록하고 JVM 런타임에도 유지. 따라서 리플렉션 가능.
</div><h2 class="marker">@Documented @Retention(RUNTIME) @Target(ANNOTATION_TYPE) @interface Documented</h2><p>@Documented가 다른 애너테이션 타입 A에 존재하면, @A로 꾸며진 요소의 공개적인 서명으로 인식하여 JavaDoc에 포함된다.</p><h2 class="marker">@Documented @Retention(RUNTIME) @Target(ANNOTATION_TYPE) @interface Inherited</h2><p>Superclass의 애너테이션을 상속함을 표시. 클래스에만 유효한 애너테이션이다.</p><h2 class="marker">@Documented @Retention(RUNTIME) @Target(ANNOTATION_TYPE) @interface Repeatable</h2><p>애너테이션을 반복적으로 정의할 수 있음을 표현.<a class="w3-btn w3-round w3-round-xxlarge w3-small w3-green" href="https://docs.oracle.com/javase/tutorial/java/annotations/repeating.html" target="_blank">참고자료</a></p><h2 class="marker">@Documented @Retention(RUNTIME) @Target(ANNOTATION_TYPE) @interface Retention</h2><p>애너테이션을 얼마나 유지할 지 표현. value ← RetentionPolicy</p><h2 class="marker">@Documented @Retention(RUNTIME) @Target(ANNOTATION_TYPE) @interface Target</h2><p>애너테이션을 적용할 요소들을 표현한다. 여러 개(또는 0개)일 경우 배열 리터럴 표기 {}를 이용한다. value ← ElementType[]</p></div><h1 class="marker">java.lang.module Since 9</h1><div><h2 class="marker">interface ModuleFinder Since 9</h2><ol><li>Module Resolution : 모듈들의 연관 관계를 계산하는 작업. 각 모듈의 필요(requires) 모듈들을 반복적으로 찾아내고 관계 그래프를 구한다.</li><li>ModuleFinder는 module resolution과 service binding(Configuration#resolveAndBind)에서 모듈을 찾는 데 이용된다.</li></ol><h2 class="marker">interface ModuleReader Extends Closeable Since 9</h2><p>모듈 내용에 대한 접근 제공.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">Optional&lt;URI> find(String name)
default Optional&lt;InputStream> open(String name)
default Optional&lt;ByteBuffer> read(String name)
Stream&lt;String> list()
</div></div><h1 class="marker">java.lang.ref</h1><div><h2 class="marker">Package Summary</h2><ol><li>참조 객체에 관한 클래스를 제공한다</li><li>3단계의 참조 레벨을 제공한다 : Soft > Weak > Phantom</li><li>객체 참조 레벨</li><ul><li>Strongly reachable</li><p>참조 객체의 조회없이 객체에 직접 접근 가능한 스레드가 존재. 객체를 생성한 스레드가 이 레벨에 해당</p><li>Softly reachable</li><p>Not strongly reachable && Soft 참조 객체의 조회로 객체에 접근 가능</p><li>Weakly reachable</li><p>Not strongly reachable && Not softly reachable && Weak 참조 객체의 조회로 객체에 접근 가능.
약한 참조가 해제되면 대상 객체는 소멸(finilization) 대상이 된다.</p><li>Phantom reachable</li><p>Not strongly reachable && Not softly reachable && Not weakly reachable && 객체는 소멸됐지만 Phantom 참조 객체가 참조하는 중</p><li>Unreachable</li><p>참조 불가능하며, 따라서 메모리 해제 대상이 된다.</p></ul></ol><h2 class="marker">final class Cleaner Since 9</h2><ol><li>객체 참조와 관련 정리 작업을 관리한다.</li><p>객체가 phantom reachable 상태로 변했음을 통지받으면 정리 작업이 실행된다. 참조 레벨의 변경을 통지받기 위해 PhantomReference와 ReferenceQueue를 이용한다.</p><li>객체 참조와 정리 작업을 등록하면 Cleanable 인스턴스가 반환된다</li><p>가장 효과적인 사용법은 객체의 close() 메서드나, 객체가 필요없는 시점에 명시적으로 clean()을 호출하는 것.</p><li>등록하는 객체를 객체 정리 작업이 참조하면 안 된다</li><p>참조하는 경우, 객체는 Phantom reachable 레벨에 도달할 수 없고, 따라서 자동으로 정리 작업이 호출될 수 없다.</p><li>정리 작업은 Runnable이며, 실행 중 발생하는 모든 예외는 무시된다. 발생한 예외는 Cleaner와 다른 정리 작업에 영향을 미치지 않는다.
Cleaner 인스턴스와 관계된 스레드가 정리 작업을 실행하며, 모든 정리 작업이 실행된 후엔 Cleaner 인스턴스가 GC에 의해 정리된다</li><li>System.exit 도중의 정리 작업의 실행은 정의되지 않는다</li></ol><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static Cleaner create()
Cleaner.Cleanable register(Object obj, Runnable action)</div><div><h3 class="marker">static interface Cleaner.Cleanable Since 9</h3><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">void clean()
    // cleanable을 등록 취소하고 정리 작업을 실행한다. 반복 호출되도 정리 작업은 최대 1번만 실행된다.
</div></div><h2 class="marker">class ReferenceQueue&lt;T></h2><p>참조 큐. 참조 레벨 변화를 감지하면 GC가 참조 객체를 큐에 추가한다</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">Reference&lt;? extends T> poll()
    // 참조 객체가 즉시 사용 가능하면 큐에서 제거하고 반환한다. 그 외의 경우 즉시 null을 반환한다.
Reference&lt;? extends T> remove(long timeout)
    // 다음 참조 객체를 규에서 제거하고 반환한다. 그 다음 참조 객체가 사용 가능해질 때까지 최대 timeout 만큼 대기한다
</div><h2 class="marker">abstract class Reference&lt;T></h2><p>GC와 상호작용하기 위한 메서드들을 정의한다. 이 클래스를 직접 상속하지 않아야 한다</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">T get()
    // 참조하는 객체를 반환한다
void clear()
boolean enqueue()
    // 참조 객체를 정리하고 등록된 큐에 넣는다
    // + isEnqueued</div><div><h3 class="marker">Sub Classes<strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">class SoftReference&lt;T> extends Reference&lt;T>
class WeakReference&lt;T> extends Reference&lt;T>
class PhantomReference&lt;T> extends Reference&lt;T>
</div></h3></div></div><h1 class="marker">java.lang.reflect</h1><div><h2 class="marker">자바 제네릭 제약사항</h2><ol><li>자바의 제네릭은 컴파일 과정에서 모두 Object 또는 바운드된 클래스로 교체된다.</li><li>따라서 List&lt;T> 참조 변수만 가지고 T가 어떤 타입인지 런타임에 알아내는 방법은 없다.</li><p>다만, 원소가 존재한다면 instanceof, Class#isInstanse, Class#isAssignableFrom을 이용한 판별은 가능하다.</p><li>따라서 제네릭 타입에 대한 직접적인 연산은 모두 무효하다.</li></ol><h2 class="marker">final class Array</h2><p>동적으로 자바 배열을 생성하고 접근하는 static 메서드들을 제공.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static Object newInstance(Class&lt;?> componentType, int length)
static Object get(Object array, int index)
    // + getBoolean, getByte, ..., + set...
</div><h2 class="marker">class Modifier</h2><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">public static final int PUBLIC, PRIVATE, PROTECTED, STATIC, FINAL, SYNCHRONIZED, VOLATILE, TRANSIENT, NATIVE, INTERFACE, ABSTRACT, STRICT
static int classModifiers()
    // 사용할 수 있는 제한자들을 OR하여 반환
    // + interfaceModifiers, constructorModifiers, ...
</div><h2 class="marker">지원 타입 종류</h2><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">interface Type                           // 모든 타입의 공통 super interface.
interface ParameterizedType extends Type // Collection&lt;String>처럼 파라미터화된 타입을 표현.
interface GenericArrayType extends Type  // 원소 타입이 parameterized type 또는 type 변수인 배열 타입을 표현.
interface WildcardType extends Type      // ?, ? extends Number, ? super Integer와 같은 와일드카드 타입을 표현.
interface AnnotatedElement               // 애너테이트된 요소를 표현
interface AnnotatedType extends AnnotatedElement {
    default AnnotatedType getAnnotatedOwnerType();
        // Since 9, 이 타입이 멤버로 속해있는, 애너테이트된 타입 반환. 예를 들어 이 타입이 @TA O&lt;T>.I&lt;S>라면, @TA O&lt;T>를 반환.
        // null이 반환되는 경우 ↓
        //     타입이 top-level이거나 local 클래스, 익명 클래스, 기본 자료형, void인 경우.
        //     타입이 AnnotatedArrayType, AnnotatedTypeVariable, AnnotatedWildcardType의 인스턴스인 경우.
    Type getType();
        // 이 애너테이트된 타입의 기저 타입
}
interface AnnotatedArrayType extends AnnotatedType         // 원소가 애너테이트된 배열을 표현.
interface AnnotatedParameterizedType extends AnnotatedType // 타입 인자들이 애너테이트된 parameterized type을 표현.
interface TypeVariable&lt;D extends GenericDeclaration> extends Type, AnnotatedElement // 타입 변수에 관한 공통 superinterface.
interface GenericDeclaration extends AnnotatedElement      // 모든 타입 변수 정의들에 대한 공통 인터페이스.
interface AnnotatedTypeVariable extends AnnotatedType      // 애너테이트된 바운드를 가진 타입 변수를 표현.
interface AnnotatedWildcardType extends AnnotatedType      // 애너테이트된 upper 또는 lower 바운드들에 대한 와일드카드 타입을 표현
</div><h2 class="marker">클래스 멤버 관련</h2><div><h3 class="marker">interface Member</h3><p>하나의 멤버(필드나 메서드) 또는 생성자를 가리킨다.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">boolean isSynthetic() // 컴파일러에 의해 만들어진 멤버인지 여부</div><h3 class="marker">class AccessibleObject implements AnnotatedElement</h3><p>Field, Method, Constructor의 base 클래스. 리플렉트된 객체를 사용하기 전에 suppressing check 표시한다.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">void setAccessible(boolean flag)
static void setAccessible(AccessibleObject[] array, boolean flag)
    // 배열의 각 원소들을 setAccessible(boolean)으로 설정할 수 있을 때, 한번에 하기 위한 메서드

// Since 9
final boolean canAccess(Object obj)
final boolean trySetAccessible()
    // accessible flag 값을 반환한다. 실패할 경우 예외를 발생하지 않고 false를 반환.
</div><h3 class="marker">final class Field extends AccessibleObject implements Member</h3><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">boolean isEnumConstant()
void set(Object obj, Object value)
    // + get, setBoolean, getBoolean, ...
</div><h3 class="marker">abstract class Executable extends AccessibleObject implements Member, GenericDeclaration</h3><p>Method, Constructor의 공통 기능</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">abstract Class&lt;?>[] getParameterTypes()
Parameter[] getParameters()
</div><h3 class="marker">final class Method extends Executable</h3><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">Class&lt;&?> getReturnType()
Object invoke(Object obj, Object... args)
</div><h3 class="marker">final class Constructor&lt;T> extends Executable</h3><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">T newInstance(Object... initargs)</div><h3 class="marker">final class Parameter implements AnnotatedElement</h3><p>메서드 인자에 관한 정보.</p><h3 class="marker">interface InvocationHandler</h3><p>Proxy 인스턴스의 invocation handler에서 구현하는 인터페이스.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">Object invoke(Object proxy, Method method, Object[] args)</div><h3 class="marker">class Proxy implements Serializable</h3><ul><li>Proxy는 인터페이스 익명 객체처럼 행동하면서 사용자 정의 메서드를 호출할 수 있는 객체를 생성하는 static 메서드를 제공한다.</li><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">// 예. 인터페이스 Foo의 프록시 인스턴스 생성
InvocationHandler handler = new MyInvocationHandler(...);
var f = (Foo) Proxy.newProxyInstance(Foo.class.getClassLoader(), new Class&lt;?>[] { Foo.class }, handler);</div><li>프록시 클래스 속성</li><p>"$Proxy"로 이름이 시작. final and non-abstract. java.lang.reflect.Proxy를 상속. 생성시 주어진 인터페이스들을 차례대로 구현. ProtectionDomain은 bootstrap 클래스 로더가 로드한 시스템 클래스들과 동일.</p></ul><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static Object newProxyInstance(ClassLoader loader, Class&lt;?>[] interfaces, InvocationHandler h)
static boolean isProxyClass(Class&lt;?> cl)
static InvocationHandler getInvocationHandler(Object proxy)
</div></div></div><h1 class="marker">java.math</h1><div><h2 class="marker">class BigDecimal extends Number implements Comparable&lt;BigDecimal></h2><p>임의 정밀도의 변경할 수 없는 10진 정수와 32비트 정수인 지수로 십진수를 표현한다.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">public static final BigDecimal ZERO, ONE, TEN

public BigDecimal(String val)
    // val   ::= (부호)?(진수부)(지수부)?
    // 진수부 ::= 정수부.(소수부) or .소수부 or 정수부
    // 지수부 ::= (e|E)정수

BigDecimal add(BigDecimal augend) // + subtract, multiply, divide
BigDecimal divideToIntegralValue(BigDecimal divisor) // 몫
BigDecimal remainder(BigDecimal divisor)             // 나머지
BigDecimal[] divideAndRemainder(BigDecimal divisor)
// + sqrt, pow, abs, negate, scale, precision, unscaledValue, round, movePointRight, scaleByPowerOfTen, ...
</div><h2 class="marker">class BigInteger extends Number implements Comparable&lt;BigInteger></h2><p>변경할 수 없는 임의 길이의 정수. -2^(Integer.MAX_VALUE) ~ 2^(Integer.MAX_VALUE)</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">public static final BigInteger ZERO, ONE, TWO /* Since 9 */, TEN

public BigInteger(int signum, byte[] magnitude, int off, int len) Since 9
public BigInteger(String val, int radix)
public BigInteger(int numBits, Random rnd) : [0 ~ 2^numBits) 사이 난수
public BigInteger(int bitLength, int certainty, Random rnd)
    // rnd를 통해 난수를 생성하고, 특정 비트 길이의 양의 정수(아마도 소수) 반환. 소수일 확률은 (1 - 0.5^certainty) 초과.

static BigInteger probablePrime(int bitLength, Random rnd)
    // 합성수일 가능성은 2^(-100)을 넘지 않는다.
BigInteger nextProbablePrime()
    // 이 BigInteger보다 큰 첫 소수(아마도)를 반환한다. 합성수일 가능성은 2^(-100)을 넘지 않는다.

// BigDecimal에는 없는 메서드
sqrtAndRemainder() Since 9, gcd(BigInteger), modPow(BigInteger, BigInteger), shiftLeft(int), and(BigInteger), testBit(int), setBit(n), flipBit(int)
</div><h2 class="marker">final class MathContext implements Serializable</h2><p>정밀도, 반올림 모드를 캡슐화한 변경 불가능한 객체.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">public static final MathContext UNLIMITED
    // precision=0 && roundingMode=HALF_UP
public static final MathContext DECIMAL32, DECIMAL64, DECIMAL128
    // 각각 7/16/34digits && roundingMode=HALF_EVEN

int getPrecision()
RoundingMode getRoundingMode()
</div><h2 class="marker">enum RoundingMode</h2><ul><li>CEILING, FLOOR, UP : 0에서 멀어지도록 선택</li><li>DOWN : 0에 가까워지도록 선택</li><li>HALF_UP, HALF_DOWN, HALF_EVEN : 가장 인접한 두 이웃들이 같은 거리에 있는 경우(*5인 경우), 각각 큰/작은/짝수 이웃을 선택.</li><li>UNNECESSARY : 올림이나 내림이 필요없는 상태. 그 외엔 ArithmeticException 발생.</li></ul></div><h1 class="marker">java.net</h1><div><h2 class="marker">Address</h2><div><h3 class="marker">class InetAddress implements Serializable</h3><p>IP 주소를 표현하며, IPv4, IPv6 각각에 대응하는 서브 클래스가 있다. 서브 클래스를 직접 이용하는 일은 별로 없을 거라고 한다.<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/net/InetAddressTest.java" lan="java">View Code »</button></p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static InetAddress getLoopbackAddress() // 127.0.0.1(127.*.*.*) or ::1
static InetAddress getByAddress(byte[] addr)
static InetAddress getByName(String host)
static InetAddress[] getAllByName(String host)
byte[] getAddress()
</div><h3 class="marker">abstract class SocketAddress implements Serializable</h3><p>프로토콜과 무관한 소켓 주소를 의미.</p><h3 class="marker">class InetSocketAddress extends SocketAddress</h3><p>IP 소켓 주소[(IP 주소 or 호스트 이름) + 포트]를 표현.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">public InetSocketAddress(int port)                   // port가 0이면 바인드시 자동 할당.
public InetSocketAddress(InetAddress addr, int port) // addr이 null이면 와일드카드 할당
public InetSocketAddress(String hostname, int port)
</div><h3 class="marker">class InterfaceAddress</h3><ol><li>IPv4 : IP 주소 + 서브넷 마스크 + 브로드캐스트 주소</li><li>IPv6 : IP 주소 + network prefix length</li></ol></div><h2 class="marker">Connection</h2><div><h3 class="marker">abstract class URLConnection</h3><ol><p>URL이 지정하는 원격지와의 연결을 정의하며, 일반적으로 아래 단계에 따라 사용된다</p><li>openConnection 메서드를 통해 연결 객체 획득</li><li>구성 인자 및 요청 속성 설정</li><p>setAllowUserInteraction, setDoInput, setDoOutput, setIfModifiedSince, setUseCaches</p><li>connect 메서드로 연결 시도</li><li>연결 성공하면 헤더와 컨텐츠에 접근할 수 있다</li><p>getContent, getHeaderField, getInputStream, getOutputStream<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/net/HttpURLConnectionTest.java" lan="java">View Code »</button><br>자주 사용되는 헤더 필드 접근 메서드 : getContentEncoding, getContentLength, getContentType, getDate, getExpiration, getLastModified</p></ol><h3 class="marker">abstract class HttpURLConnection extends URLConnection</h3><ol><li>HttpURLConnection은 요청을 1회만 하지만, 기저 네트워크 연결은 다른 인스턴스가 공유할 수 있다</li><li>public static final int HTTP_OK, HTTP_BAD_REQUEST, HTTP_NOT_FOUND, ...</li><li>int getResponseCode()<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/net/HttpURLConnectionTest.java" lan="java">View Code »</button></li></ol><h3 class="marker">abstract class JarURLConnection extends URLConnection</h3><ol><li>원격지 jar에 대한 연결을 제공한다</li><li>JarEntry 표기 : jar:http://www.foo.com/bar/baz.jar!/COM/foo/Quux.class</li><li>JarFile 표기 : jar:http://www.foo.com/bar/baz.jar!/</li><li>Jar directory 표기 : jar:http://www.foo.com/bar/baz.jar!/COM/foo/</li></ol></div><h2 class="marker">Socket</h2><div><h3 class="marker">interface SocketOptions</h3><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">@Native static final int SO_REUSEPORT
    // Since 9, 여러 소켓이 같은 주소와 포트를 listen할 수 있는지 여부.
@Native static final int SO_LINGER
    // TCP 소켓 linger-on-close timeout 설정. 0이면 즉시 강제 종료. 양수면 최대 65,535까지 종료 대기. 그 외엔 일반적인 종료 절차.
@Native static final int SO_TIMEOUT
    // ServerSocket#accept, SocketInputStream#read, DatagramSocket#receive에 대한 timeout 설정. 사용하기 전에 미리 설정돼야 한다.
@Native static final int SO_SNDBUF
    // 전송 버퍼 크기에 대한 힌트 + SO_RCVBUF
@Native static final int SO_KEEPALIVE
    // TCP 연결에서 2시간(실제와 다를 수 있음) 동안 아무 교환이 없으면 keepalive probe를 보낸다. 응답이 ACK면 정상, RST면 상대가 리셋(리부트)되었으므로 연결 종료, 응답 없는 경우에도 연결 종료.
@Native static final int SO_OOBINLINE
    // TCP 소켓에 설정되면 input stream을 통해 긴급 데이터(1바이트)를 받을 수 있다. 설정되지 않으면(기본) 버려진다.
void setOption(int optID, Object value)
    // + getOption, ...
</div><h3 class="marker">class Socket implements Closeable</h3><p>TCP 클라이언트 소켓<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/net/SocketTest.java" lan="java">View Code »</button></p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">void connect(SocketAddress endpoint, int timeout)
void bind(SocketAddress bindpoint)

SocketChannel getChannel()
    // SocketChannel#open 또는 ServerSocketChannel#accept로 생성된 경우에만 존재.
InputStream getInputStream() + getOutputStream

// Since 9
&lt;T> Socket setOption(SocketOption&lt;T> name, T value)
&lt;T> T getOption(SocketOption&lt;T> name)
Set&lt;SocketOption&lt;?>> supportedOptions()
</div><h3 class="marker">class ServerSocket implements Closeable</h3><p>TCP 서버 소켓<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/net/SocketTest.java" lan="java">View Code »</button></p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">public ServerSocket(int port)
    // port 0은 자동 할당. 들어오는 연결 큐의 크기(backlog)는 50.

void bind(SocketAddress endpoint)
Socket accept()
ServerSocketChannel getChannel()
    // ServerSocketChannel#open으로 생성된 경우에만 존재.

static void setSocketFactory(SocketImplFactory fac)
void setPerformancePreferences(int connectionTime, int latency, int bandwidth)

// Since 9
&lt;T> ServerSocket setOption(SocketOption&lt;T> name, T value)
&lt;T> T getOption(SocketOption&lt;T> name)
Set&lt;SocketOption&lt;?>> supportedOptions()
</div><h3 class="marker">class DatagramSocket implements Closeable</h3><p>UDP 소켓을 정의한다</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">void bind(SocketAddress addr)
void connect(InetAddress address, int port)
    // 기본적으로 UDP 데이터그램 소켓은 연결이 없다. 이 메서드로 원격지에 연결하는순간, 소켓은 해당 원격지와만 통신할 수 있다.
    // 원격지와 연결하면 다음 메서드들이 동작한다. getInetAddress(), getPort(), getRemoteSocketAddress()

void send(DatagramPacket p)
void receive(DatagramPacket p)

void setTrafficClass(int tc) + getTrafficClass
    // 0&lt;=tc&lt;=255. IPv4에서, 하위 8개 비트를 IP 패킷의 TOS에 쓴다.
    // IPv6에서, IP 헤더의 sin6_flowinfo 필드에 들어간다.
    // RRC 1349의 TOS 값 정의
    //     IPTOS_LOWCOST(0x02), IPTOS_RELIABILITY(0x04), IPTOS_THROUGHPUT(0x08), IPTOS_LOWDELAY(0x10)

DatagramChannel getChannel()
    // DatagramChannel#open으로 생성된 경우에만 존재.

static void setDatagramSocketImplFactory(DatagramSocketImplFactory fac)

// Since 9
&lt;T> DatagramSocket setOption(SocketOption&lt;T> name, T value)
    // + getOption, 각종 옵션 setter/getter
Set&lt;SocketOption&lt;?>> supportedOptions()
</div><h3 class="marker">class MulticastSocket extends DatagramSocket</h3><ol><li>멀티캐스트 데이터그램 소켓을 제공한다.</li><li>멀티캐스트 그룹 ::= Class D IP 주소 + UDP 포트</li><p>Class D ::= (224.0.0.0, 239.255.255.255]</p><li>멀티캐스트 그룹에 데이터그램을 보내면 모든 구독자들이 받게 된다</li><p>멀티캐스트 그룹의 멤버가 아니라도 멀티캐스트 데이터그램을 보내는 것은 가능하다</p></ol><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">// JavaDoc 예시
var group = InetAddress.getByName("228.5.6.7");
var s = new MulticastSocket(6789);
s.joinGroup(group);
var msg = "hello".getBytes();
s.send(new DatagramPacket(msg, msg.length, group, 6789));
var buf = new byte[1000];
s.receive(new DatagramPacket(buf, buf.length));
s.leaveGroup(group);
</div><h3 class="marker">final class DatagramPacket</h3><ol><li>UDP 패킷을 정의한다. 송신용 생성자는 byte[]와 길이 정보가 필요하고, 수신용 생성자는 주소 정보가 추가로 필요하다.</li><li>패킷 데이터, 길이, 주소 각각에 대한 getter/setter 제공</li></ol></div><h2 class="marker">URI</h2><div><h3 class="marker">final class URI implements Comparable&lt;URI>, Serializable</h3><div><h4 class="marker">URI syntax and components</h4><ol><li>syntax : [scheme:]scheme-specific-part[#fragment]</li><li>Absolute URI : 스킴을 명시한 URI</li><li>Relative URI : Not absolute URI</li><li>Opaque URI : scheme-specific-part가 '/'로 시작하지 않는 absolute URI</li><p>예: "mailto:java-net@java.sun.com", "urn:isbn:096139210x"</p><li>Hierarchical URI : scheme-specific-part가 '/'로 시작하는 absolute or relative URI</li><p>[scheme:][//authority][path][?query][#fragment]<br>예: "http://example.com/languages/java", "sample/a/index.html#28", "../../demo/b/index.html"</p><li>Server-based authority : [user-info@]host[:port]</li><li>Registry-based authority : not server-based authority</li></ol><h4 class="marker">Operations on URI instances</h4><ol><li>Normalization : "."과 ".."을 제거</li><li>Resolution : 상대 URI와 base URI를 이용해 단일 URI를 찾는 작업</li><li>Relativization : Resolution의 역.</li><p>임의의 정규화된 두 URI u, v에 대하여, u.relativize(u.resolve(v)).equals(v)와 u.resolve(u.relativize(v)).equals(v)는 항상 성립한다.</p></ol></div><h3 class="marker">final class URL implements Serializable</h3><p>인스턴스 생성 시, URI와 다르게 정의된 scheme에 대한 핸들러를 찾기 때문에, 핸들러를 찾지 못하면 예외가 발생한다<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/net/HttpURLConnectionTest.java" lan="java">View Code »</button></p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">boolean sameFile(URL other) : fragment(#) 제외하고 같은 파일인지 여부
URI toURI()

URLConnection openConnection()
final InputStream openStream() // == openConnection().getInputStream()
final Object getContent()      // == openConnection().getContent()
</div><h3 class="marker">class URLDecoder</h3><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static String decode(String s, Charset charset) // Since 10</div><h3 class="marker">class URLEncoder</h3><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static String encode(String s, Charset charset) // Since 10</div><h3 class="marker">class URLClassLoader extends SecureClassLoader implements Closeable</h3><p>URL을 이용한 클래스 로더를 제공한다</p></div><h2 class="marker">final class NetworkInterface</h2><p>이름과 할당된 IP 주소들로 구성된 Network Interface 표현.<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/net/NetworkInterfaceTest.java" lan="java">View Code »</button></p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static Stream&lt;NetworkInterface> networkInterfaces()
    // Since 9, + getNetworkInterfaces

Stream&lt;InetAdress> inetAddresses()
    // Since 9, + getInetAddresses
byte[] getHardwareAddress()
    // 보통 MAC 주소
</div></div><h1 class="marker">java.nio</h1><div><h2 class="marker">버퍼 관련</h2><div><h3 class="marker">abstract class Buffer</h3><ol><li>버퍼는 일련의 유한한 기본 자료형 원소들의 나열.</li><ul><li>Capacity : 저장하고 있는 원소들의 개수</li><li>Limit : 읽거나 쓸 수 없는 최초의 인덱스. 0보다 작거나 capacity보다 클 수 없다.</li><li>Position : 다음에 읽거나 쓸 대상의 인덱스. 0보다 작거나 limit보다 클 수 없다.</li><li>0&lt;=mark&lt;=position&lt;=limit&lt;=capacity // 마킹은 지원되지 않을수도 있다.</li></ul><li>get/put 연산의 Relative/Absolute 구분</li><ul><li>Relative : 버퍼의 현재 Position에 대한 연산</li><li>Absolute : 버퍼의 특정 위치를 지정한 연산</li></ul><li>Additional operations</li><ul><li>clear() : 새로운 채널-읽기 또는 relative put 연산을 준비; limit을 capacity로, position을 0으로.</li><li>flip() : 새로운 채널-쓰기 또는 relative get 연산을 준비; limit을 position으로, position을 0으로.</li><li>rewind() : 이미 읽은 것을 다시 읽도록; limit은 그대로, position을 0으로.</li><li>slice() : 기존 버퍼의 부분 시퀀스 생성.</li><li>duplicate() : 기존 버퍼의 얕은 복사본 생성.</li></ul></ol><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">abstract boolean hasArray()
    // 기저 배열의 존재 유무. true면 array()와 arrayOffset() 사용가능
abstract boolean isDirect()
    // Direct 버퍼(즉시 읽기/쓰기)인지 여부

// Since 9
abstract Buffer slice()
    // 현재 버퍼의 현재 위치부터 시작하는 부분 버퍼 생성(내용 공유). direct, read-only 속성을 공유.
abstract Buffer duplicate()
    // 복사본(내용 공유) 반환.
</div><h3 class="marker">abstract class ByteBuffer extends Buffer implements Comparable&lt;ByteBuffer></h3><ol><li>다음 연산을 정의.</li><ul><li>바이트 하나에 대한 absolute/relative get/put</li><li>바이트 시퀀스에 대한 bulk get/put</li><li>다른 원시 타입에 대한 absolute/relative get/put</li><li>다른 원시 타입으로 읽기 가능한 view 버퍼 생성</li><li>compact : 인덱스 [0, position) 사이의 데이터가 버려진다(Optional operation)</li></ul><li>Direct 버퍼</li><p>읽기/쓰기 연산이 직접적으로 이루어지며, 별개의 복사본을 이용하는 non-direct 버퍼에 비해 할당/제거 비용이 크다. Direct 버퍼는 allocateDirect 팩토리 메서드로 생성된다.</p><li>Access to binary data</li><p>버퍼의 byte order는 해당 버퍼에 대한 연산의 기준이 된다. 기본값은 ByteOrder.BIG_ENDIAN.</p><li>인덱싱</li><p>ByteBuffer인덱스를 지정하는 absolute get/put의 인덱스는 바이트 단위다. 뷰 버퍼의 인덱스는 해당 타입 크기 단위다.</p><button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/nio/ByteBufferExample.java" lan="java">View Code »</button></ol><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">abstract byte get(int index)
ByteBuffer get(byte[] dst, int offset, int length)
ByteBuffer put(ByteBuffer src)

abstract CharBuffer asCharBuffer() // + short, int, long, float, double

final int alignmentOffset(int index, int unitSize)
    // Since 9, index % unitSize를 반환한다. 0이 아니면 unitSize 단위로 자르기 부적합하다는 의미. unitSize는 2의 거듭제곱이어야 한다.
final ByteBuffer alignedSlice(int unitSize)
    // Since 9, 현재 버퍼를 unitSize 크기씩 잘라 view 버퍼를 생성(BIG_ENDIAN)한다.
    // 현재 위치가 unitSize의 배수가 아니라면 바로 다음 배수 위치부터 포함하며, limit도 unitSize 배수에 맞춰 끊는다.

int mismatch(ByteBuffer that) Since 11
    // 두 바이트 버퍼의 현재 읽기 위치들을 시작 위치로 하여, 바이트 값이 다른 최초 index를 반환한다.
</div><h3 class="marker">abstract class MappedByteBuffer extends ByteBuffer</h3><p>FileChannel#map 메서드로 생성되는 direct 바이트 버퍼. 기저 파일이 (외부에서) 변경되면 버퍼 내용도 변경된다. 역도 성립</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">final BappedByteBuffer load()  // 파일 내용을 메모리에 적재한다
final MappedByteBuffer force() //강제로 버퍼 변경 내용을 파일에 쓴다.
</div><h3 class="marker">abstract class CharBuffer extends Buffer implements Comparable&lt;CharBuffer>, Appendable, CharSequence, Readable</h3><ol><li>+ ShortBuffer, DoubleBuffer</li><li>다음 연산을 정의</li><ul><li>단일 char에 대한 absolute/relative get/put</li><li>char 시퀀스에 대한 bulk get/set</li><li>compact : ByteBuffer의 설명과 동일</li></ul></ol></div><h2 class="marker">final class ByteOrder</h2><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">public static final ByteOrder BIG_ENDIAN, LITTLE_ENDIAN
static ByteOrder nativeOrder()
</div></div><h1 class="marker">java.nio.channels</h1><div><h2 class="marker">채널 인터페이스</h2><div><h3 class="marker">interface Channel extends Closeable</h3><p>채널이란 독립적인 IO를 수행할 수 있는 개체에 대한 연결이다.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">boolean isOpen()</div><h3 class="marker">interface ReadableByteChannel extends Channel</h3><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">int read(ByteBuffer dst)
    // dst.remaining()만큼 읽어 dst에 저장. 읽은 바이트 개수를 반환. 스트림의 끝이면 -1.
</div><h3 class="marker">interface WritableByteChannel extends Channel</h3><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">int write(ByteBuffer src)
    // src.remaining() 부분을 채널에 쓴다.
</div><h3 class="marker">interface ByteChannel extends ReadableByteChannel, WritableByteChannel</h3><p>바이트 단위 읽기/쓰기 모두 가능한 채널.</p><h3 class="marker">interface AsynchronousChannel extends Channel</h3><p>비동기 I/O를 지원하는 채널. close()도 비동기적으로 수행되며, 도중/이후 작업은 AsynchronousCloseException 발생시키면 된다</p><h3 class="marker">interface InterruptibleChannel extends Channel</h3><p>"instanceof InterruptibleChannel" IFF "비동기적으로 close() 메서드를 통해 인터럽트되고 닫을 수 있는 채널"</p><h3 class="marker">interface AsynchronousByteChannel extends AsynchronousChannel</h3><p>비동기 IO를 지원하는 바이트 채널</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">&lt;A> void read(ByteBuffer dst, A attachment, CompletionHandler&lt;Integer, ? super A> handler)
    // 기본 동작은 ReadableByteChannel#read와 동일. 쓰기가 완료(실패)되면 handler가 호출된다. handler에 전달될 첫 인자는 읽은 바이트 수.
Future&lt;Integer> read(ByteBuffer dst)
    // 반환된 Future#get 메서드로 읽은 바이트 수를 얻을 수 있다.
</div><h3 class="marker">interface ScatteringByteChannel extends ReadableByteChannel</h3><p>채널의 바이트들을 여러 버퍼에 순서대로 저장. 네트워크 헤더나 파일 메타데이터처럼 고정 길이의 헤더를 읽는 데 유용.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">long read(ByteBuffer[] dsts, int offset, int length)
    // dsts[offset]부터 length개의 버퍼가 각각의 remaining()만큼씩 바이트를 읽어 가져간다.
</div><h3 class="marker">interface GatheringByteChannel extends WritableByteChannel</h3><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">long write(ByteBuffer[] srcs, int offset, int length)
    // srcs[offset]부터 length개의 버퍼의 remaining() 부분을 채널에 쓴다.
</div><h3 class="marker">interface SeekableByteChannel extends ByteChannel</h3><p>현재 위치를 기억하는 바이트 채널.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">SeekableByteChannel truncate(long size)
    // 채널에 연결된 개체의 크기를 size로 조정. size가 현재보다 작은 경우 나머지는 버려진다(position이 size보다 큰 경우 size로 조정된다). size가 현재 이상인 경우 아무 변경 없다.
</div><h3 class="marker">interface NetworkChannel extends Channel</h3><p>네트워크 소켓에 대한 채널</p><h3 class="marker">interface MulticastChannel extends NetworkChannel</h3><p>IP 계층 멀티캐스팅 가능한 채널</p></div><h2 class="marker">비동기 채널 관련</h2><div><h3 class="marker">interface CompletionHandler&lt;V, A></h3><p>비동기 I/O 작업의 결과를 소비하는 소비자</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">void completed(V result, A attachment)   // 성공시 호출
void failed(Throwable exc, A attachment) // 실패시 호출
</div><h3 class="marker">abstract class AsynchronousChannelGroup</h3><p>그룹 지정되지 않은 비동기 채널들은 시스템 기본 그룹에 묶인다.</p><p>시스템 속성에 따라 생성된 ThreadFactory가 비동기 작업을 실행할 데몬 스레드들을 만든다.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static AsynchronousChannelGroup withFixedThreadPool(int nThreads, ThreadFactory threadFactory)
    // 최대 nThreads의 스레드만 동시에 실행된다. 시스템 기본 AsynchronousChannelProvider 객체의 openAsynchronousChannelGroup(int, ThreadFactory) 메서드를 통해 만들어진다
static AsynchronousChannelGroup withCachedThreadPool(ExecutorService executor, int initialSize)
    // 시스템 기본 AsynchronousChannelProvider 객체의 openAsynchronousChannelGroup(ExecutorService, int) 메서드를 통해 만들어진다.
    // 채널 그룹의 종료(shutdown)는 ExecutorService의 shutdown()으로 이어진다. 따라서 ExecutorService가 외부에서 닫히는 경우엔 무슨 일이 일어날 지 모른다

abstract void shutdown()
    // 순차적 종료 절차에 진입한다.
abstract void shutdownNow()
    // shutdown() + 모든 열린 채널들을 닫는다. 실행 중인 CompletionHandler들은 끝날 때까지 기다린다. 도중에 다른 스레드에서 이 메서드를 호출하는 경우, 현재 작업이 완료될 때까지 블록된다; 더 불러도 추가 작업은 없다.
abstract boolean awaitTermination(long timeout, TimeUnit unit)
</div><h3 class="marker">abstract class AsynchronousFileChannel implements AsynchronousChannel</h3><ol><li>파일에 대한 비동기 채널. I/O의 기준이 되는 현재 위치를 갖고 있지 않으며, 메서드에서 지정한다</li><li>생성된 채널들은 스레드-안전하며, 완료 핸들러들은 별개의 스레드에서 실행됨이 보장된다.</li><p>연산에 사용되는 ByteBuffer 자체는 스레드-안전하지 않음에 유의</p></ol><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static AsynchronousFileChannel open(Path file, Set&lt;? extends OpenOption> options, ExecutorService executor, FileAttribute&lt;?>... attrs)
    // 파일을 열거나 생성한 뒤 비동기 채널을 하나 반환한다. options에는 java.nio.file.StandardOpenOption을 이용하면 된다.

abstract AsynchronousFileChannel truncate(long size)
    // size() > size인 경우 파일을 자른다. return this;

abstract void force(boolean metaData)
    // 메서드 호출 시점부터 true면 StandardOpenOption.SYNC를, false면 StandardOpenOption.DSYNC를 적용하는 것과 같다. 기저 파일이 로컬에 존재하는 경우에만 유효하다.

abstract &lt;A> void lock(long position, long size, boolean shared, A attachment, CompletionHandler&lt;FileLock, ? super A> handler)
    // 기저 파일 일부에 대한 잠금을 얻는다. handler는 잠금을 얻는 데 성공/실패하면 호출된다. 잠금 size는 고정이므로, 파일 크기가 커질 것도 고려하여 필요한 만큼 신청해놔야 한다.
abstract FileLock tryLock(long position, long size, boolean shared)
    // 스레드를 블록하지 않는다. OverlappingFileLockException에 해당하는 상황에는 null이 반환된다

abstract &lt;A> void read(ByteBuffer dst, long position, A attachment, CompletionHandler&lt;Integer, ? super A> handler)
    // handler에 전달되는 Integer는 읽은 바이트 길이, 또는 -1(position > size())
abstract &lt;A> void write(ByteBuffer src, long position, A attachment, CompletionHandler&lt;Integer, ? super A> handler)
    // position > size()인 경우, 그 사이 바이트 값은 쓰레기 값이다.
</div><h3 class="marker">abstract class AsynchronousServerSocketChannel implements AsynchronousChannel, NetworkChannel</h3><ol><li>스트림 지향 읽기 소켓 채널<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/nio/AsynchronousSocketChannelTest.java" lan="java">View Code »</button></li><li>스레드-안전하지만 최대 accept 가능한 스레드는 하나 뿐이며, accept 도중 중복되는 요청은 AcceptPendingException</li><li>지원하는 소켓 옵션 : SO_RCVBUF(수신 버퍼 크기), SO_REUSEADDR(주소 재사용); 구현에 따라 추가될 수도 있다</li></ol><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static AsynchronousServerSocketChannel open(AsynchronousChannelGroup group)
    // group을 지정하지 않거나 null로 설정하는 경우 시스템 기본 그룹이 이용된다

final AsynchronousServerSocketChannel bind(SocketAddress local, int backlog)
    // backlog는 소켓에 대한 최대 pending connection 수. 0이나 음수로 설정하면 구현체의 기본값을 이용한다. return this;

abstract &lt;A> void accept(A attachment, CompletionHandler&lt;AsynchronousSocketChannel, ? super A> handler)
    // 신규 연결된 AsynchronousSocketChannel은 현재 채널과 동일한 채널 그룹에 묶인다. 그룹이 닫힌 경우, 신규 연결도 닫히고 ShutdownChannelGroupException
</div><h3 class="marker">abstract class AsynchronousSocketChannel implements AsynchronousByteChannel, NetworkChannel</h3><ol><li>스트림 지향 소켓 채널. open 팩터리 메서드로 직접 열거나(Unbound), AsynchronousServerSocketChannel#accept로 열 수(Bound) 있다.<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/nio/AsynchronousSocketChannelTest.java" lan="java">View Code »</button></li><li>스레드-안전하지만 최대 하나의 읽기/쓰기만 각각 동시에 존재할 수 있다.</li><p>도중에 중복되는 요청은 각각 ReadPendingException, WritePendinException 발생</p><li>지원하는 소켓 옵션 : SO_SNDBUF(전송 버퍼 크기), SO_RCVBUF(수신 버퍼 크기), SO_KEEPALIVE(기본 false, keep-alive 작동은 구현체에 의존적이다), TCP_NODELAY(Nagle 알고리즘 비활성)</li><li>읽기/쓰기 시 양수의 타임아웃을 지정한 경우, 시간 내에 완료되지 못하면 InterruptedByTimeoutException으로 종료되고, 이후 상태는 비결정적이며, 따라서 사용된 채널, 버퍼들은 버리는 게 낫다</li></ol><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static AsynchronousSocketChannel open(AsynchronousChannelGroup group)
    // group이 지정되지 않거나 null인 경우, 시스템 기본 그룹이 이용된다

abstract AsynchronousSocketChannel shutdownInput()
    // 채널을 더 이상 읽을 수 없게 한다. 이후의 읽기는 모두 -1을 반환한다. return this;
abstract AsynchronousSocketChannel shutdownOutput()
    // 채널을 더 이상 쓸 수 없게 한다. 이후의 쓰기는 모두 ClosedChannelException ─ 읽기는 가능할 수 있다 ─ 으로 종료된다.

abstract &lt;A> void connect(SocketAddress remote, A attachment, CompletionHandler&lt;Void, ? super A> handler)

abstract &lt;A> void read(ByteBuffer dst, long timeout, TimeUnit unit, A attachment, CompletionHandler&lt;Integer, ? super A> handler)
    // ScatteringByteChannel#read와 유사한 메서드도 지원한다
abstract &lt;A> void write(ByteBuffer src, long timeout, TimeUnit unit, A attachment, CompletionHandler&lt;Integer, ? super A> handler)
    // GatheringByteChannel#write와 유사한 메서드도 지원한다
</div></div><h2 class="marker">채널 클래스</h2><div><h3 class="marker">final class Channels</h3><p>채널과 스트림에 관한 유틸리티 클래스.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static InputStream newInputStream(ReadableByteChannel ch)
    // 채널이 논-블로킹 모드면 읽기 시 예외 발생. 버퍼링, mark/reset 미지원. 스레드-안전. 닫으면 채널도 닫힌다
static OutputStream newOutputStream(WritableByteChannel ch)
    // 채널이 논-블로킹 모드면 쓰기 시 예외 발생. 버퍼링 미지원. 스레드-안전. 닫으면 채널도 닫힌다
static InputStream newInputStream(AsynchronousByteChannel ch)
    // 버퍼링, mark/reset 미지원. 스레드-안전. 닫으면 채널도 닫힌다
static OutputStream newOutputStream(AsynchronousByteChannel ch)
    // 버퍼링 미지원. 스레드-안전. 닫으면 채널도 닫힌다

static ReadableByteChannel newChannel(InputStream in)
    // 버퍼링 미지원. 닫으면 스트림도 닫힌다
static WritableByteChannel newChannel(OutputStream out)
    // 버퍼링 미지원. 닫으면 스트림도 닫힌다
static Reader newReader(ReadableByteChannel ch, Charset charset)
    // 채널이 논-블로킹 모드면 읽기 시 예외 발생. 버퍼링 지원. mark/reset 미지원. 닫으면 채널도 닫힌다
static Writer newWriter(WritableByteChannel ch, Charset charset)
    // 채널이 논-블로킹 모드면 쓰기 시 예외 발생. 버퍼링 지원. 닫으면 채널도 닫힌다
</div><h3 class="marker">abstract class FileChannel extends AbstractInterruptibleChannel implements SeekableByteChannel, GatheringByteChannel, ScatteringByteChannel</h3><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">abstract MappedByteBuffer map(FileChannel.MapMode mode, long position, long size)
    // 매핑 : 파일의 일부분을 메모리에 올려놓고 작업. 큰 파일은 이쪽이 효율이 좋다
    // READ_ONLY : 변경 불가, READ_WHITE : 변경이 기저 파일에 전파, PRIVATE : 변경이 전파되지 않음
</div><h3 class="marker">abstract class ServerSocketChannel extends AbstractSelectableChannel implements NetworkChannel</h3><p>스트림-지향 읽기 소켓 채널. AsynchronousServerSocketChannel 참고.</p><h3 class="marker">abstract class SocketChannel extends AbstractSelectableChannel implements ByteChannel, ScatteringByteChannel, GatheringByteChannel, NetworkChannel</h3><p>스트림-지향 소켓 채널. AsynchronousSocketChannel 참고.</p><h3 class="marker">abstract class DatagramChannel extends AbstractSelectableChannel implements ByteChannel, ScatteringByteChannel, GatheringByteChannel, MulticastChannel</h3><ol><li>데이터그램-지향 소켓 채널</li><li>기존 데이터그램 소켓에서 채널을 얻는 방법은 없으며, open 팩터리 메서드로 획득해야 한다</li><li>send/receive 메서드는 연결없이 사용할 수 있지만, read/write 메서드는 connect 메서드를 통해 연결해야 이용할 수 있다</li><p>연결된 경우, 송/수신에 불필요한 보안 체크를 하지 않는다</p><li>지원하는 소켓 옵션 : SO_SNDBUF, SO_RCVBUF, SO_REUSEADDR, SO_BROADCAST, IP_TOS, IP_MULTICAST_IF, IP_MULTICAST_TTL, IP_MULTICAST_LOOP</li></ol><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static DatagramChannel open()
    // IP 멀티캐스팅에 이용하려는 경우, 멀티캐스트 그룹 타입을 ProtocolFamily에 지정해줘야 한다
</div><h3 class="marker">abstract class SelectableChannel extends AbstractInterruptibleChannel implements Channel</h3><ol><li>스레드-안전. Selector를 통해 멀티플렉싱될 수 있는 채널을 정의한다</li><li>Selector에 등록함으로써 SelectionKey가 발행된다. 나가는 건 마음대로 할 수 없다.</li><p>채널이 닫히면 채널에 대한 모든 SelectionKey들은 cancel된다</p><li>각 Selector에는 최대 한 번씩만 등록할 수 있다. Selector가 닫히면 등록된 모든 채널이 내려가고, 각 키들은 즉시 무효하게 된다</li><li>Non-blocking mode</li><p>새로 생성된 SelectableChannel은 블로킹 모드지만, configureBlocking(boolean) 메서드로 모드를 변경할 수 있다. 이 경우, Selector에 등록하기 전에 논-블로킹으로 설정해야 하며, 한 번 등록되면 등록 취소되기 전까지 논-블로킹 모드로 작동한다<br>논-블로킹 모드에서는 I/O 연산이 절대 블로킹되지 않지만, 요청보다 적은 데이터가 보내지거나 아예 전송되지 않을 수 있다.</p></ol><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">abstract SelectorProvider provider()
    // 이 채널을 생성한 provider를 반환한다

abstract SelectableChannel configureBlocking(boolean block)
    // 이미 어느 Selector에 등록된 채널이라면 논-블로킹 설정 시 IllegalBlockingModeException 발생

abstract Object blockingLock()
    // configureBlocking, register 메서드에서 동기화에 이용되는 객체를 반환한다
</div></div><h2 class="marker">abstract class Pipe</h2><ol><li>2개 채널로 이루어진 단방향 파이프를 정의한다</li><p>SinkChannel : 쓰기 전용, SourceChannel : 읽기 전용</p></ol><h2 class="marker">abstract class FileLock implements AutoCloseable</h2><ol><li>Adivisory Lock : 응용 프로그램이 잠금을 직접 확인하고, 알아서 읽기/쓰기를 수행할 지 결정한다.</li><li>Mandatory Lock : 커널이 잠금을 관리하기 때문에, 관련되지 않은 프로세스는 접근 불가</li><p>모든 잠금을 Adivisory Lock으로 간주하여 관리함이 바람직하다</p><li>On some systems, 잠금의 존재로 인해 매핑(FileChannel#map)이 불가능할 수 있음에 유의</li><li>On some systems, 채널을 닫으면 해당 파일에 대한 모든 잠금이 해제될 수 있음에 유의</li><li>Some network filesystems, 잠금 영역 크기가 하드웨어 페이지 크기의 배수인 경우에만 매핑을 지원함에 유의</li><li>Some network filesystems, 2^30 또는 2^31 이상 크기에 대한 잠금을 지원하지 않음에 유의</li></ol><h2 class="marker">abstract class MembershipKey</h2><p>IP 멀티캐스트 그룹에 대한 멤버십을 표현한다</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">abstract boolean isValid()
abstract void drop()
abstract InetAddress group()
abstract MulticastChannel channel()
    // 이 멤버십 키를 생성한 채널을 반환한다.
abstract InetAddress sourceAddress()
    // 특정 소스의 데이터그램만 수신하는 멤버십(Source-specific membership key)인 경우, 유효한 주소를 반환한다
abstract MembershipKey block(InetAddress source) + unblock
    // OS가 소스 필터링을 적용하지만, 적용되지 않은 멤버십에 대하여 이를 호출하면 특정 소스를 차단할 수 있다
abstract NetworkInterface networkInterface()
</div><h2 class="marker">abstract class Selector implements Closeable</h2><ol><li>SelectableChannel에 대한 멀티플렉서. 스레드-안전</li><li>SelectableChannel을 등록하면 SelectionKey가 발행되며, 3가지 집합으로 관리된다</li><ul><li>Key set : 현재 등록된 채널들에 관한 키. SelectableChannel#register 메서드로 등록. Selector#keys 메서드로 획득.</li><li>Selected-key set : 선택 연산에 의해, 최소 하나의 연산에 대해 ready 상태로 파악된 키. 자동 등록(수동 삭제만 가능). selectedKeys 메서드로 획득</li><li>Cancelled-key set : 취소되었지만 채널은 아직 등록되어 있는 키</li></ul><li>선택 연산에는 2가지 종류가 있다</li><ul><li>select(), select(long), selectNow() : 지정된 연산에 대해 준비된 상태인지 확인하여 selected-key set 업데이트</li><ol><li>Cancelled-key set의 멤버들에 대해, 키 집합에서 제거하고 채널을 등록 취소한다. 결과적으로 cancelled-key set은 비게 된다.</li><p>아래 작업 중 Cacelled-key set에 추가된 키들에 대해서도 추가로 작업한다</p><li>Selected-key set에 없는 키에 대해, 키의 interest set의 연산 중 하나라도 준비되었다면 selected-key set으로 추가되고, 키의 ready set이 설정된다</li><li>Selected-key set에 있는 키에 대해, 키의 ready set 외의 연산 중 준비된 것들은 ready set으로 추가된다</li></ol><li>select(Consumer), select(Consumer, long), selectNow(Consumer) : 준비된 채널들에 대해 작업 실행. selected-key set을 업데이트하지 않음</li><ol><li>Cancelled-key set의 멤버들에 대한 작업은 전과 같다</li><p>마찬가지로 아래 작업 중 Cacelled-key set에 추가된 키들에 대해서도 추가로 작업한다</p><li>키의 ready set이 최소 하나의 연산에 대해 준비되었다면, ready set은 준비된 연산들로만 설정되고, 주어진 Consumer가 키를 소비한다.</li><p>키의 ready set이 2개 이상의 연산에 대해 준비되었다면, Consumer는 여러 번 호출될 수 있다. Consumer를 호출하기 전에 ready set에서 해당 연산을 빼기 때문에, 한 번의 선택 연산에서 같은 연산에 대해 2번 호출되지 않는다.</p></ol></ul><li>선택 연산에서 사용되는 키의 interest set은 연산의 시작 시점의 것으로, 중간에 변경됐다면 다음 선택 연산에 적용된다</li><li>키와 채널은 언제든 닫힐 수 있으므로, 사용 시 다른 스레드에서 키나 채널을 닫는지 유의해야 한다</li></ol><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">abstract int selectNow()
    // 논-블로킹으로 선택한다. 선택 연산으로 ready set이 업데이트된 키의 수를 반환한다. 이전 wakeup()의 영향을 제거한다
abstract int select(long timeout)
    // 블로킹으로 선택한다. timeout이 지정되지 않은 경우엔 무기한. 적어도 하나의 채널이 선택되면 반환한다.
int selectNow(Consumer&lt;SelectionKey> action) Since 11
    // 논-블로킹으로 키를 소비한다. 소비된 유니크한 키의 개수를 반환한다. 이전 wakeup()의 영향을 제거한다
int select(Consumer&lt;SelectionKey> action, long timeout) Since 11
    // 블로킹으로 키를 소비한다. 소비된 유니크한 키의 개수를 반환한다. 시간 초과 되거나, 적어도 하나의 채널이 선택되면 wakeup()으로 깨어난다
abstract Selector wakeup()
    // 아직 반환하지 않은 선택 연산이 즉시 반환하도록 한다. 현재 실행 중인 선택 연산이 없다면 다음 선택 연산(selectNow 제외)에 대해 적용된다.
</div><h2 class="marker">abstract class SelectionKey</h2><ol><li>SelectableChannel이 Selector에 등록됨을 나타내는 토큰. 채널이나 Selector가 닫히면서 cancel 메서드로 닫히기 전까지 유효</li><li>각 SelectionKey는 2가지 연산 집합을 갖는다. 각 집합은 int로 표현되고, 설정된 비트는 채널이 해당 연산을 지원함을 의미한다</li><ul><li>Interest set : Selector의 선택 연산에서 ready 상태인지 검사될 연산 집합. 최초 채널 등록 시 제공된 int값이며, interestOps(int)로 변경할 수 있다.</li><li>Ready set : 키의 채널이 ready 상태인 연산들의 집합. 최초 생성 시 0이며, Selector의 선택 연산으로 변경된다. 직접 변경할 수는 없다.</li></ul><li>이 클래스에서 공통적인 지원 연산에 대해 정의하지만, 각 SelectableChannel의 서브 클래스에서 제공하는 validOps()가 정확하다</li></ol><div><h3 class="marker">Field Detail</h3><ol><li>static final int OP_READ</li><p>Selector의 선택 연산 시 interest set에 포함되어 있을 때. 채널이 읽기 가능하거나, end-of-stream에 도달했거나, 원격지에서 닫았거나, 에러 대기 상태면 ready set에 추가</p><li>static final int OP_WRITE</li><p>Selector의 선택 연산 시 interest set에 포함되어 있을 때. 채널이 쓰기 가능하거나, 원격지에서 닫았거나, 에러 대기 상태만 ready set에 추가</p><li>static final int OP_CONNECT</li><p>Selector의 선택 연산 시 interest set에 포함되어 있을 때, 채널이 연결 완료될 수 있거나, 에러 대기 상태면 ready set에 추가</p><li>static final int OP_ACCEPT</li><p>Selector의 선택 연산 시 interest set에 포함되어 있을 때. 서버 채널이 연결을 허용할 수 있거나, 에러 대기 상태면 ready set에 추가</p></ol></div></div><h1 class="marker">java.nio.charset</h1><div><h2 class="marker">abstract class Charset implements Comparable&lt;Charset></h2><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static SortedMap&lt;String, Charset> availableCharsets()
static boolean isSupported(String charsetName)
static Charset forName(String charsetName)
static Charset defaultCharset()

boolean canEncode()
abstract CharsetDecoder newDecoder()   // + newEncoder
final CharBuffer decode(ByteBuffer bb) // + encode
</div><h2 class="marker">abstract class CharsetDecoder</h2><p>바이트열을 문자열로 변환.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">final CharBuffer decode(ByteBuffer in)
final CoderResult decode(ByteBuffer in, CharBuffer out, boolean endOfInput)

final float averageCharsPerByte() // + maxCharsPerByte
</div><h2 class="marker">abstract class CharsetEncoder</h2><p>문자열을 바이트열로 변환.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">final ByteBuffer encode(CharBuffer in)
final CoderResult encode(CharBuffer in, ByteBuffer out, boolean endOfInput)

final float averageBytesPerChar() // + maxBytesPerChar
</div><h3 class="marker">final class StandardCharsets</h3><p>표준 문자집합 : US-ASCII(= ISO646-US), ISO-8859-1(= ISO-LATIN-1), UTF-8, UTF-16BE, UTF-16LE, UTF-16</p></div><h1 class="marker">java.nio.file</h1><div><h2 class="marker">파일 감시 관련</h2><div><h3 class="marker">interface Watchable</h3><p>WatchService에 등록되어 그 변화나 이벤트가 감시될 수 있는 객체. 정의된 register 메서드는 등록되었음을 WatchKey 객체로 반환한다.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">WatchKey register(WatchService watcher, WatchEvent.Kind&lt;?>... events)</div><h3 class="marker">interface WatchEvent&lt;T></h3><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">WatchEvent.Kind&lt;T> kind()
int count() // 1보다 크면 반복 이벤트
T context()</div><div><h4 class="marker">static interface WatchEvent.Kind&lt;T></h4><p>식별을 위한 이벤트 종류</p><h4 class="marker">static interface WatchEvent.Modifier</h4><p>Watchable 객체가 어떻게 등록되었는지</p></div><h3 class="marker">final class StandardWatchEventKinds</h3><ol><li>public static final WatchEvent.Kind&lt;Object> OVERFLOW : 자리가 없어 이벤트가 버려짐.</li><li>public static final WatchEvent.Kind&lt;Path> ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY : 디렉터리 생성/삭제/변경</li></ol><h3 class="marker">interface WatchKey</h3><ol><li>WatchService에 Watchable 객체가 등록되었음을 표현하는 토큰.</li><li>처음 생성되면 ready 상태. 이벤트를 감지하면 reset()되기 전까지 signalled 상태가 되고, WatchService 큐에 진입하여 처리된다. reset()되면 다시 ready.</li></ol><h3 class="marker">interface WatchService extends Closeable</h3><p>스레드-안전. FileSystem#newWatchService 메서드로 획득한다</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">WatchKey poll()
    // 다음 WatchKey를 제거. 없으면 null.
WatchKey poll(long timeout, TimeUnit unit)
    // 다음 WatchKey를 제거. 없으면 대기. timeout 후에도 없으면 null.
WatchKey take()
    // 다음 WatchKey를 제거. 없으면 대기.
</div></div><h2 class="marker">파일 순회 관련</h2><div><h3 class="marker">interface DirectoryStream&lt;T> extends Closeable, Iterable&lt;T></h3><ol><li>Files#newDirectoryStream 메서드로 획득</li><li>일회용 이터러블이다. 2번째 호출부터는 IllegalStateException 발생</li></ol><h3 class="marker">interface SecureDirectoryStream&lt;T> extends DirectoryStream&lt;T></h3><ol><li>열린 디렉터리에 대한 상대 경로를 이용한 연산들을 추가로 지원한다</li><li>OS에서 이를 지원한다면, Files#newDirectoryStream 메서드로 획득한 DirectoryStream은 SecureDirectoryStream이다</li></ol><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">SecureDirectoryStream&lt;T> newDirectoryStream(T path, LinkOption... options)
    // path가 절대 경로면 Files#newDirectoryStream과 동일.
SeekableByteChannel newByteChannel(T path, Set&lt;? extends OpenOption> options, FileAttribute&lt;?>... attrs)
    // path가 절대 경로면 Files#newByteChannel과 동일. path에 해당하는 파일을 열거나 만든 뒤, 파일에 대한 채널을 반환한다

void deleteFile(T path)
    // Files#delete와 다르게 path가 디렉터리인지 확인하지 않는다. 이로써 디렉터리가 실제로 지워지는 지는 시스템에 의존적이다. 심볼릭 링크의 경우 링크 자체만 지운다.
void deleteDirectory(T path)
    // Files#delete와 다르게 path가 디렉터리인지 확인하지 않는다. 이로써 일반 파일이 지워지는 지는 시스템에 의존적이다.
void move(T srcpath, SecureDirectoryStream&lt;T> targetdir, T targetpath)
    // ATOMIC_MOVE 옵션이 적용된 Files#move와 비슷하게 작업한다. 현재 디렉터리를 기준으로, 파일 하나를 다른 디렉터리에 대한 상대경로가 지정하는 위치에 원자적으로 옮긴다
</div><h3 class="marker">interface FileVisitor&lt;T></h3><p>Files#walkFileTree 메서드에 사용</p><h3 class="marker">class SimpleFileVisitor&lt;T> implements FileVisitor&lt;T></h3><ol><li>preVisitDirectory : CONTINUE 반환</li><li>visitFile : CONTINUE 반환</li><li>visitFileFailed : rethrow</li><li>postVisitDirectory : 예외없으면 CONTINUE, 있으면 rethrows</li></ol><h3 class="marker">enum FileVisitResult</h3><ol><li>CONTINUE : 순회 계속.</li><li>TERMINATE : 순회 종료</li><li>SKIP_SUBTREE : FileVIsitor#preVisitDirectory에서 반환된 경우, 하위 레벨 트리는 순회하지 않는다</li><li>SKIP_SIBLINGS : 현재 요소가 포함된 디렉터리 내부에서, 현재 요소와 동일한 레벨의 요소들은 더 이상 순회하지 않는다.</li><p>FileVIsitor#preVisitDirectory에서 반환된 경우, 현재 디렉터리의 내부 요소들과 postVisitDirectory 모두 건너뛴다</p></ol></div><h2 class="marker">옵션 관련</h2><div><h3 class="marker">interface CopyCption</h3><h3 class="marker">enum StandardCopyOption implements CopyOption</h3><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">REPLACE_EXISTING, COPY_ATTRIBUTES, ATOMIC_MOVE</div><h3 class="marker">interface OpenOption</h3><h3 class="marker">enum StandardOpenOption implements OpenOption</h3><ol><li>READ : 읽기</li><li>WRITE : 쓰기</li><li>APPEND : TRUNCATE_EXISTING 옵션이 있거나 읽기 전용일 때는 적용되지 않는다</li><li>TRUNCATE_EXISTING : 파일을 열 때 크기를 0바이트로 줄인다. 읽기 전용으로 열 때는 적용되지 않는다.</li><li>CREATE : 기존 파일이 존재하면 열고, 없으면 새로 생성한다.</li><li>CREATE_NEW : 신규 파일을 생성한다. 기존 파일이 존재하면 실패한다.</li><li>DELETE_ON_CLOSE : close() 호출 시 파일을 지운다(best effort)</li><li>SPARSE : 파일이 sparse임을 OS에 알려준다. 신규 파일을 생성하는 경우에만 유효하다.</li><li>SYNC : 파일 내용 및 메타데이터의 변경을 동기적으로 물리 장치에 기록한다</li><li>DSYNC : 파일 내용 변경을 동기적으로 물리 장치에 기록한다</li></ol><h3 class="marker">enum FileVisitOption</h3><p>FOLLOW_LINKS : 심볼릭 링크를 따라 들어가는 경우</p><h3 class="marker">enum LinkOption implements OpenOption, CopyOption</h3><p>NOFOLLOW_LINKS : 심볼릭 링크를 따라 들어가지 않는 경우</p></div><h2 class="marker">파일 시스템 관련</h2><div><h3 class="marker">interface Path extends Comparable&lt;Path>, Iterable&lt;Path>, Watchable</h3><p>파일 경로를 가리킨다. 사용자 정의 파일 시스템을 개발하기 위해 만들어짐.<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/nio/PathTest.java" lan="java">View Code »</button></p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static Path of(String first, String... more)
    // Since 11
    // 예. FileSystem#getSeparator == "/"일때, of("/foo", "bar", "gus") → "/foo/bar/gus"

static Path of(URI uri)
    // Since 11 ↔ toUri

FileSystem getFileSystem()
    // 이 Path를 만든 FileSystem 반환
Path getRoot()
    // + getFileName, getParent, getNameCount, getName, subpath, toAbsolutePath, toRealPath

Path normalize()
    // 불필요한 ".", ".." 제거
Path resolve(Path other)
    // 호출한 path를 기준 디렉터리로 하여, other가 가리키는 지점을 단일 Path로 반환한다.
default Path resolveSibling(Path other)
    // (getParent() == null) ? other : getParent().resolve(other);
Path relativize(Path other)
    // 호출한 path를 기준으로, other에 도달하는 상대경로를 반환한다
</div><h3 class="marker">final class Files</h3><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static InputStream newInputStream(Path path, OpenOption... options)
    // + newOutputStream, newByteChannel, newBufferedReader, newBufferedWriter

static DirectoryStream&lt;Path> newDirectoryStream(Path dir, String glob)
    // 예. Files.newDirectoryStream(dir, "*.java"));
    // 예. Files.newDirectoryStream(dir, "*.{c,h,cpp,hpp,java}"));

static Path createFile(Path path, FileAttribute&lt;?>... attrs)
    // + createDirectory, createDirectories(경로 상의 모든 디렉터리 생성), createTempFile, createTempDirectory, createSymbolicLink, createLink(하드 링크)

static void delete(Path path)
    // + deleteIfExists, copy, move

static bolean isSameFile(Path path, Path path2)
static long mismatch(Path path, Path path2)
    // Since 12, 두 파일이 불일치하는 최초의 바이트 위치를 반환한다. 같으면 -1L.

static byte[] readAllBytes(Path path)
    // + readString Since 11, lines, readAllLines
static Path write(Path path, Iterable&lt;? extends CharSequence> lines, OpenOption... options)
static Path writeString(Path path, CharSequence csq, Charset cs, OpenOption... options) // Since 11

static boolean isHidden(Path path)
    // + isDirectory, isSymbolicLink, isRegularFile, exists, notExists, isReadable, isWritable, isExecutable
static String probeContentType(Path path)
    // + getFileAttributeView, readAttributes, getAttribute, setAttribute, getLastModifiedTime, setLastModifiedTime, size

static Stream&lt;Path> list(Path dir)
static Stream&lt;Path> walk(Path start, int maxDepth, FIleVisitOption... options)
    // + walkFileTree
static Stream&lt;Path> find(Path start, int maxDepth, BiPredicate&lt;Path, BasicFileAttributes> matcher, FIleVisitOption... options)
</div><h3 class="marker">final class FileSystems</h3><p>FileSystem 팩터리</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static FileSystem getDefault()
static FileSystem getFileSystem(URI uri)
static FileSystem newFileSystem(Path path, ClassLoader loader)
</div></div></div><h1 class="marker">java.security</h1><div><h2 class="marker">암호적으로 안전한 난수 생성기</h2><div><h3 class="marker">interface SecureRandomParameters Since 9</h3><p>SecureRandom 메서드 인자임을 나타내는 마커 인터페이스</p><h3 class="marker">class SecureRandom extends Random</h3><ol><li>비결정적인 출력을 위해, 전달되는 시드 역시 예측할 수 없어야 한다</li><p>시드를 제공하지 않은 경우, 최초 nextBytes 호출 시 구현체에서 정의하는 엔트로피 소스로부터 시드를 선택한다</p><li>SecureRandom 인스턴스는 스레드-안전하다</li><button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/security/SecureRandomTest.java" lan="java">View Code »</button></ol><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static SecureRandom getInstance(String algorithm)
    // https://docs.oracle.com/en/java/javase/12/docs/specs/security/standard-names.html#securerandom-number-generation-algorithms
static SecureRandom getInstance(String algorithm, SecureRandomParameters params)
    // Since 9
    // SecureRandom.getInstance("DRBG", DrbgParameters.instantiation(128, RESEED_ONLY, null));
static SecureRandomParameters getInstanceStrong()

void reseed()
    // Since 9, 엔트로피 소스로부터 시드 재선택
void nextBytes(byte[] bytes)
    // + generateSeed
</div><h3 class="marker">class DrbgParameters Since 9</h3><ol><li>DRBG; Deterministic Random Bit Generator 이용을 위한 파라미터</li><p>기본 파라미터 외에 직접 지정하고 싶은 경우, 메서드의 SecureRandomParameters 파라미터로 넘기면 된다</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">var drbg = SecureRandom.getInstance("DRBG", DrbgParameters.instantiation(112, NONE, null));
    // Weak DRBG 인스턴스. 112비트 보안 강도
drbg.nextBytes(buffer, DrbgParameters.nextBytes(256, false, "more".getBytes()));
    // 보안 강도 112비트를 초과하여 실패
drbg.nextBytes(buffer, DrbgParameters.nextBytes(112, true, "more".getBytes()));
    // 예측 저항(PR_AND_RESEED) 없으므로 실패</div><li>시스템 속성</li><p>securerandom.drbg.config → 기본값 : Hash_DRBG with SHA-256</p></ol><div><h4 class="marker">Nested Classes</h4><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">// Since 9
static final class DrbgParameters.Instantiation implements SecureRandomParameters
    // DRBG 인스턴스 생성 시 사용.
static enum DrbgParameters.Capability {
    NONE(예측 저항 x, reseed x), PR_AND_RESEED(예측 저항 o, reseed o), RESEED_ONLY(예측 저항 x, reseed o)
}
static final class DrbgParameters.Reseed implements SecureRandomParameters
    // DRBG 인스턴스 reseed에 이용
static final class DrbgParameters.NextBytes implements SecureRandomParameters
    // DRBG 인스턴스의 랜덤 비트열 생성에 이용
</div></div></div></div><h1 class="marker">java.text</h1><div><h2 class="marker">abstract class Format implements Serializable, Cloneable</h2><ol><li>자바에서 제공하는 주요 Format 서브 클래스는 DateFormat, MessageFormat, NumberFormat</li><li>콘크리트 서브 클래스는 아래 3개 메서드를 반드시 구현해야 한다</li><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">format(Object, StringBuffer, FieldPosition)
formatToCharacterIterator(Object)
parseObject(String, ParsePosition)
</div></ol><h2 class="marker">final class Normalizer</h2><ol><li>유니코드<a class="w3-btn w3-round w3-round-xxlarge w3-small w3-green" href="https://ko.wikipedia.org/wiki/유니코드_정규화" target="_blank">정규화/역정규화</a> 관련 기능을 제공한다.</li></ol><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static enum Normalizer.Form {
    NFC, NFD, NFKC, NFKD
}

static String normalize(CharSequence src, Normalizer.Form form)
    // + isNormalized
</div><h2 class="marker">abstract class NumberFormat extends Format</h2><p><button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/text/NumberFormatTest.java" lan="java">View Code »</button></p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static enum NumberFormat.Style { // Since 12
    SHORT, LONG
}
static class NumberFormat.Field extends Format.Field {
    INTEGER(정수부), FRACTION(분수), EXPONENT(지수부), DECIMAL_SEPARATOR(소수 구분 기호), SIGN(부호), GROUPING_SEPARATOR(단위 구분 문자), EXPONENT_SYMBOL, PERCENT, PERMILLE, CURRENCY, EXPONENT_SIGN, PREFIX Since 12, SUFFIX Since 12
}

static final NumberFormat getInstance(Locale inLocale)
    // + getNumberInstance : 범용
    // + getIntegerInstance : 포맷에 HALF_EVEN을 이용하고, 파싱은 정수부만
</div><h2 class="marker">class SimpleDateFormat extends DateFormat</h2><table><tr><th>문자</th><th>표현요소</th><th>예</th></tr><tr><th>G</th><td>기원 전/후</td><td>AD<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/text/SimpleDateFormatTest.java" displayRange="[18,23]" lan="java">예</button></td></tr><tr><th>y</th><td>년</td><td>1996; 96<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/text/SimpleDateFormatTest.java" displayRange="[26,31]" lan="java">예</button></td></tr><tr><th>Y</th><td>Week year</td><td>2009; 09<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/text/SimpleDateFormatTest.java" displayRange="[34,43]" lan="java">예</button></td></tr><tr><th>M</th><td>월(context sensitive)</td><td>July; Jul; 07<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/text/SimpleDateFormatTest.java" displayRange="[26,31]" lan="java">예</button></td></tr><tr><th>L</th><td>월 (standalone form)</td><td>July; Jul; 07</td></tr><tr><th>w</th><td>Week in year</td><td>27<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/text/SimpleDateFormatTest.java" displayRange="[34,43]" lan="java">예</button></td></tr><tr><th>W</th><td>Week in month</td><td>2</td></tr><tr><th>D</th><td>Day in year</td><td>189</td></tr><tr><th>d</th><td>Day in month</td><td>10<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/text/SimpleDateFormatTest.java" displayRange="[26,31]" lan="java">예</button></td></tr><tr><th>F</th><td>Day of week in month</td><td>2</td></tr><tr><th>E</th><td>Day name in week</td><td>Tuesday; Tue<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/text/SimpleDateFormatTest.java" displayRange="[34,43]" lan="java">예</button></td></tr><tr><th>u</th><td>Day number of week</td><td>1 = Monday, ..., 7 = Sunday<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/text/SimpleDateFormatTest.java" displayRange="[34,43]" lan="java">예</button></td></tr><tr><th>a</th><td>Am/pm</td><td>PM<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/text/SimpleDateFormatTest.java" displayRange="[46,51]" lan="java">예</button></td></tr><tr><th>H</th><td>Hour in day (0-23)</td><td>0<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/text/SimpleDateFormatTest.java" displayRange="[26,31]" lan="java">예</button></td></tr><tr><th>k</th><td>Hour in day (1-24)</td><td>24</td></tr><tr><th>K</th><td>Hour in am/pm (0-11)</td><td>0</td></tr><tr><th>h</th><td>Hour in am/pm (1-12)</td><td>12<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/text/SimpleDateFormatTest.java" displayRange="[46,51]" lan="java">예</button></td></tr><tr><th>m</th><td>Minute in hour</td><td>30<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/text/SimpleDateFormatTest.java" displayRange="[26,31]" lan="java">예</button></td></tr><tr><th>s</th><td>Second in minute</td><td>55<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/text/SimpleDateFormatTest.java" displayRange="[26,31]" lan="java">예</button></td></tr><tr><th>S</th><td>Millisecond</td><td>978<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/text/SimpleDateFormatTest.java" displayRange="[46,51]" lan="java">예</button></td></tr><tr><th>z</th><td>General time zone</td><td>Pacific Standard Time; PST; GMT-08:00</td></tr><tr><th>Z</th><td>RFC 822 time zone</td><td>-0800<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/text/SimpleDateFormatTest.java" displayRange="[46,51]" lan="java">예</button></td></tr><tr><th>X</th><td>ISO 8601 time zone</td><td>-08; -0800; -08:00</td></tr></table><h2 class="marker">class MessageFormat extends Format</h2><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">MessageFormatPattern ::= String | MessageFormatPattern FormatElement String
FormatElement        ::= { ArgumentIndex[, FormatType[, FormatStyle]] }
FormatType           ::= number | date | time | choice
FormatStyle          ::= short | medium | long | full | integer | currency | percent | SubformatPattern</div><ol><li>'' 안의 포맷 문자열은 이스케이프된다</li><li>동일 요소에 대한 반복적인 파싱은 마지막 파싱 결과만 유효하다<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/text/MessageFormatTest.java" lan="java">View Code »</button></li></ol><table><tr><th>FormatType</th><th>FormatStyle</th><th>Subformat Created</th></tr><tr><th>(none)</th><th>(none)</th><td>null</td></tr><tr><th rowspan="5">number</th><th>(none)</th><td>NumberFormat.getInstance(getLocale())</td></tr><tr><th>integer</th><td>NumberFormat.getIntegerInstance(getLocale())</td></tr><tr><th>currency</th><td>NumberFormat.getCurrencyInstance(getLocale())</td></tr><tr><th>percent</th><td>NumberFormat.getPercentInstance(getLocale())</td></tr><tr><th>SubformatPattern</th><td>new DecimalFormat(subformatPattern, DecimalFormatSymbols.getInstance(getLocale()))</td></tr><tr><th rowspan="6">date</th><th>(none)</th><td>DateFormat.getDateInstance(DateFormat.DEFAULT, getLocale())</td></tr><tr><th>short</th><td>DateFormat.getDateInstance(DateFormat.SHORT, getLocale())</td></tr><tr><th>medium</th><td>DateFormat.getDateInstance(DateFormat.DEFAULT, getLocale())</td></tr><tr><th>long</th><td>DateFormat.getDateInstance(DateFormat.LONG, getLocale())</td></tr><tr><th>full</th><td>DateFormat.getDateInstance(DateFormat.FULL, getLocale())</td></tr><tr><th>SubformatPattern</th><td>new SimpleDateFormat(subformatPattern, getLocale())</td></tr><tr><th rowspan="6">time</th><th>(none)</th><td>DateFormat.getTimeInstance(DateFormat.DEFAULT, getLocale())</td></tr><tr><th>short</th><td>DateFormat.getTimeInstance(DateFormat.SHORT, getLocale())</td></tr><tr><th>medium</th><td>DateFormat.getTimeInstance(DateFormat.DEFAULT, getLocale())</td></tr><tr><th>long</th><td>DateFormat.getTimeInstance(DateFormat.LONG, getLocale())</td></tr><tr><th>full</th><td>DateFormat.getTimeInstance(DateFormat.FULL, getLocale())</td></tr><tr><th>SubformatPattern</th><td>new SimpleDateFormat(subformatPattern, getLocale())</td></tr><tr><th>choice</th><th>SubformatPattern</th><td>new ChoiceFormat(subformatPattern)</td></tr></table></div><h1 class="marker">java.time</h1><div><h2 class="marker">abstract class Clock</h2><p>시간대(time-zone)을 이용한 현재의 date와 time 제공. 지정하지 않는 이상, 시계 내부의 시각은 계속 변한다.<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/time/ClockTest.java" lan="java">View Code »</button></p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static Clock system(ZoneId zone)
    // 특정 시간대의 시계 반환
    // systemUTC() == system(ZoneOffset.UTC)
    // systemDefaultZone() == system(ZoneId.systemDefault())

static Clock tick(Clock baseClock, Duration tickDuration)
    // 지정된 시계의 tick 단위를 조정. 예를 들어 1분이 지정된 경우, 1분 미만의 값은 버려진다.
    // tickMillis(ZoneId zone) Since 9 == tick(system(zone), Duration.ofMillis(1))

static Clock fixed(Instant fixedInstant, ZoneId zone)
    // 현재 시각으로 멈춘 시계 반환
static Clock offset(Clock baseClock, Duration offsetDuration)
    // 시각을 조정한 새로운 시계 반환
abstract Clock withZone(ZoneId zone)
    // 지정된 시간대에 현재 시계의 복사본을 생성하여 반환한다. 따라서 시각 자체는 조정하지 않는다.
</div><h2 class="marker">final class Duration implements TemporalAmount, Comparable&lt;Duration>, Serializable</h2><p><button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/time/DurationTest.java" lan="java">View Code »</button></p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static Duration of(long amount, TemporalUnit unit)
static Duration from(TemporalAmount amount)
    // amount 그대로 Duration으로 변환
static Duration parse(CharSequence text)
    // ISO-8601 duration format PnDTnHnMn.nS
    // 추가로 접두 부호 가능
static Duration between(Temporal startInclusive, Temporal endExclusive)

Duration withSeconds(long seconds)
    // 나노초 단위만 남기고 seconds로 변경
Duration withNanos(int nanoOfSecond)
    // 나노초 단위만 nanoOfSecond로 변경
</div><h2 class="marker">final class Instant implements Temporal, TemporalAdjuster, Comparable&lt;Instant>, Serializable</h2><p>Epoch(1970-01-01 00:00:00)를 기준으로 한 초(long)와 나노초(int)로 시각을 표현한다. 음수면 epoch 이전</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">public static final Instant EPOCH, MIN(아주 먼 옛날), MAX(아주 먼 미래)

static Instant now()
static Instant parse(CharSequence text)
    // DateTimeFormatter.ISO_INSTANT
    // 예. 2007-12-03T10:15:30.00Z)
</div><h2 class="marker">enum DayOfWeek implements TemporalAccessor, TemporalAdjuster</h2><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">public static final DayOfWeek MONDAY ~ SUNDAY
int getValue() // ISO-8601. 1(MONDAY) ~ 7(SUNDAY)
</div><h2 class="marker">enum Month implements TemporalAccessor, TemporalAdjuster</h2><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">public static final Month JANUARY ~ DECEMBER
int getValue() // ISO-8601. 1(JANUARY) ~ 12(DECEMBER)
</div></div><h1 class="marker">java.time.format</h1><div><h2 class="marker">final class DateTimeFormatter</h2><p><a class="w3-btn w3-round w3-round-xxlarge w3-small w3-green" href="https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/time/format/DateTimeFormatter.html#predefined" target="_blank">DateTimeFormatter.html#predefined</a></p><table><tr><th>Formatter</th><th>Description</th><th>Example</th></tr><tr><th>ofLocalizedDate(dateStyle)</th><td>Formatter with date style from the locale</td><td>'2011-12-03'</td></tr><tr><th>ofLocalizedTime(timeStyle)</th><td>Formatter with time style from the locale</td><td>'10:15:30'</td></tr><tr><th>ofLocalizedDateTime(dateTimeStyle)</th><td>Formatter with a style for date and time from the locale</td><td>'3 Jun 2008 11:05:30'</td></tr><tr><th>ofLocalizedDateTime(dateStyle,timeStyle)</th><td>Formatter with date and time styles from the locale</td><td>'3 Jun 2008 11:05'</td></tr><tr><th>BASIC_ISO_DATE</th><td>Basic ISO date</td><td>'20111203'</td></tr><tr><th>ISO_LOCAL_DATE</th><td>ISO Local Date</td><td>'2011-12-03'</td></tr><tr><th>ISO_OFFSET_DATE</th><td>ISO Date with offset</td><td>'2011-12-03+01:00'</td></tr><tr><th>ISO_DATE</th><td>ISO Date with or without offset</td><td>'2011-12-03+01:00'; '2011-12-03'</td></tr><tr><th>ISO_LOCAL_TIME</th><td>Time without offset</td><td>'10:15:30'</td></tr><tr><th>ISO_OFFSET_TIME</th><td>Time with offset</td><td>'10:15:30+01:00'</td></tr><tr><th>ISO_TIME</th><td>Time with or without offset</td><td>'10:15:30+01:00'; '10:15:30'</td></tr><tr><th>ISO_LOCAL_DATE_TIME</th><td>ISO Local Date and Time</td><td>'2011-12-03T10:15:30'</td></tr><tr><th>ISO_OFFSET_DATE_TIME</th><td>Date Time with Offset</td><td>'2011-12-03T10:15:30+01:00'</td></tr><tr><th>ISO_ZONED_DATE_TIME</th><td>Zoned Date Time</td><td>'2011-12-03T10:15:30+01:00[Europe/Paris]'</td></tr><tr><th>ISO_DATE_TIME</th><td>Date and time with ZoneId</td><td>'2011-12-03T10:15:30+01:00[Europe/Paris]'</td></tr><tr><th>ISO_ORDINAL_DATE</th><td>Year and day of year</td><td>'2012-337'</td></tr><tr><th>ISO_WEEK_DATE</th><td>Year and Week</td><td>'2012-W48-6'</td></tr><tr><th>ISO_INSTANT</th><td>Date and Time of an Instant</td><td>'2011-12-03T10:15:30Z'</td></tr><tr><th>RFC_1123_DATE_TIME</th><td>RFC 1123 / RFC 822</td><td>'Tue, 3 Jun 2008 11:05:30 GMT'</td></tr></table></div><h1 class="marker">java.util</h1><div><h2 class="marker">Collection API</h2><div><h3 class="marker">컬렉션 자료형 인터페이스</h3><div><h4 class="marker">interface Collection&lt;E> extends Iterable&lt;E></h4><ol><li>컬렉션 최소 연산을 정의.</li><li>서브 컬렉션을 작성할 때, 인자없는 생성자와 Collection 인자 하나만 받는 생성자를 각각 작성하도록 권장한다</li><li>정의하지 않아도 되는 선택적 메서드들에 대하여, 구현하지 않는 경우 UnsupportedOperationException을 던져야 한다</li><li>컬렉션이 자기 자신을 요소로 갖는 경우 일부 메서드 실행 중 예외가 발생할 수 있다.</li><p><button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/util/CollectionExample.java" lan="java">View Code »</button></p></ol><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">int size()
boolean isEmpty()

boolean add(E e)
boolean addAll(Collection&lt;? extends E> c)

boolean contains(Object o)
boolean containsAll(Collection&lt;?> c)

boolean retainAll(Collection&lt;?> c)
    // c에 속한 원소만 남기고 모두 제거한다. 이 연산으로 컬렉션이 변경됐다면 true 반환.
boolean remove(Object o)
boolean removeAll(Collection&lt;?> c)
default boolean removeIf(Predicate&lt;? super E> filter)
void clear()

Object[] toArray()
&lt;T> T[] toArray(T[] a)
    // 사용 : toArray(new Clazz[0])
default &lt;T> T[] toArray(IntFunction&lt;T[]> generator)
    // Since 11, 사용 : toArray(Clazz[]::new)

default Stream&lt;E> stream()
default Stream&lt;E> parallelStream()
</div><h4 class="marker">interface Queue&lt;E> extends Collection&lt;E></h4><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">boolean add(E e)   // 추가할 수 없으면 예외 발생. 따라서 반환이 있다면 그 값은 항상 true
boolean offer(E e) // 예외 발생하지 않는 add

E remove()         // 앞쪽 원소 하나 제거. 없으면 예외.
E poll()           // 앞쪽 원소 하나 제거. 없으면 null.

E element()        // 앞쪽 원소 하나 제거하지 않고 가져오기. 없으면 예외.
E peek()           // 앞쪽 원소 하나 제거하지 않고 가져오기. 없으면 null.
</div><h4 class="marker">interface Deque&lt;E> extends Queue&lt;E></h4><p>양방향 삽입/삭제 가능한 Queue</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">boolean removeFirstOccurrence(Object o)
    // + removeLastOccurrence
Iterator&lt;E> descendingIterator()
    // iterator()의 역순
</div><h4 class="marker">interface List&lt;E> extends Collection&lt;E></h4><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">default void replaceAll(UnaryOperator&lt;E> operator)
    // 모든 원소를 연산 결과로 대체

default void sort(Comparator&lt;? super E> c)

int hashCode()
    // hashCode = 31*hashCode + (e==null ? 0 : e.hashCode());

E set(int index, E element) // 이전 값은 반환.

int indexOf(Object o)
    // + lastIndexOf

ListIterator&lt;E> listIterator()
List&lt;E> subList(int fromIndex, int toIndex)</div><p>Unmodifiable List</p><ul><li>List#of, List#copyOf는 null 허용하지 않는 변경 불가능한 리스트를 반환한다.</li><li>모든 원소가 serializable하면 반환된 리스트도 그러하다.</li></ul><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static &lt;E> List&lt;E> of() // Since 9
static &lt;E> List&lt;E> copyOf(Collection&lt;? extends E> coll) // Since 10
</div><h4 class="marker">interface Set&lt;E> extends Collection&lt;E></h4><p>Unmodifiable Set</p><ul><li>Set#of, Set#copyOf는 null 허용하지 않는 변경 불가능한 집합을 반환한다.</li><li>모든 원소가 serializable하면 반환된 집합도 그러하다.</li></ul><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static &lt;E> Set&lt;E> of() // Since 9
static &lt;E> Set&lt;E> copyOf(Collection&lt;? extends E> coll) // Since 10
</div><h4 class="marker">interface SortedSet&lt;E> extends Set&lt;E></h4><p>원소가 정렬된 Set. 다음 4가지 생성자를 구현할 것을 권장. (void), (Comparator), (Collection), (SortedSet)</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">SortedSet&lt;E> subSet(E fromElement, E toElement)
    // 부분집합 반환. toElement는 미포함
    // + headSet, tailSet
E first() // + last
</div><h4 class="marker">interface NavigableSet&lt;E> extends SortedSet&lt;E></h4><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">E lower(E e)
    // e보다 작은 원소들 중 최댓값을 반환. 없으면 null
    // + floor: &lt;=e, ceiling: >=e, higher: >e

NavigableSet&lt;E> descendingSet()
Iterator&lt;E> descendingIterator()
</div><h4 class="marker">interface Map&lt;K, V></h4><ul><li>default V getOrDefault(Object key, V defaultValue)<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/util/MapExample.java" displayRange="[12,16]" lan="java">View Code »</button></li><li>V put(K key, V value) : 이전 값은 반환된다.</li><li>default V putIfAbsent(K key, V value)<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/util/MapExample.java" displayRange="[18,24]" lan="java">View Code »</button></li><li>default V compute(K key, BiFunction&lt;? super K, ? super V, ? extends V> remappingFunction)</li><p>값을 다시 계산하여 덮어쓴다.<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/util/MapExample.java" displayRange="[26,32]" lan="java">View Code »</button></p><li>default V computeIfAbsent(K key, Function&lt;? super K, ? extends V> mappingFunction) + computeIfPresent</li><p>computeIfAbsent : key가 맵에 없거나, 대응하는 값이 null인 경우 새로운 값을 계산하여 넣는다. 계산된 값이 null이면 null 반환. 그 외의 경우 현재값 반환<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/util/MapExample.java" displayRange="[34,56]" lan="java">View Code »</button></p><p>computeIfPresent : key가 존재하고, 대응하는 값이 null이 아닌 경우 새로운 값을 계산하여 넣는다. 키가 존재하면 현재값 반환. 그 외의 경우 null 반환</p><li>default V replace(K key, V value) + replaceAll</li><p>key가 있을 때만 대체. 없으면 null 반환<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/util/MapExample.java" displayRange="[58,70]" lan="java">View Code »</button></p><li>default V merge(K key, V value, BiFunction&lt;? super V, ? super V, ? extends V> remappingFunction)<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/util/MapExample.java" displayRange="[72,89]" lan="java">View Code »</button></li><ul><li>key가 맵에 없거나, 대응하는 값이 null인 경우 : null이 아닌 value로 연결.</li><li>주어진 함수를 통해 새로운 값에 연결</li><li>결과가 null인 경우 맵에서 제거.</li></ul><li>Unmodifiable Instance</li><ul><li>Map#of, Map#ofEntries, Map#copyOf 메서드는 변경 불가능한 맵을 반환한다.</li><p>변경 불가능한 맵은 키와 값 모두 null을 허용하지 않으며, 모든 키와 값이 serializable하면 맵도 그러하다.</p><li>Map.Entry#entry 메서드는 변경 불가능한 엔트리를 반환한다.</li></ul></ul><div><h5 class="marker">static interface Map.Entry&lt;K, V></h5><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static &lt;K extends Comparable&lt;? super K>, V> Comparator&lt;Map.Entry&lt;K, V>> comparingByKey()
    // 키를 자연스러운 순서로 비교하는 비교자 반환. 인자 있는 함수의 경우 해당 비교자를 이용.
    // + comparingByValue
</div></div><h4 class="marker">interface SortedMap&lt;K, V> extends Map&lt;K, V></h4><p>키가 정렬된 Map. 다음 4가지 생성자를 구현할 것을 권장. (void), (Comparator), (Map), (SortedMap)</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">SortedMap&lt;K, V> subMap(K fromKey, K toKey)
    // 지정된 범위의 키만으로 구성된 서브 맵 반환. toKey는 미포함
    // + headMap, tailMap
</div><h4 class="marker">interface NavigableMap&lt;K, V> extends SortedMap&lt;K, V></h4><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">Map.Entry&lt;K, V> lowerEntry(K key)
    // key보다 작은 키들 중 최댓값에 대한 entry 반환. 없으면 null
    // + floorEntry: &lt;=key, ceilingEntry: >=key, higherEntry: >key
K lowerKey(K key)
    // key보다 작은 키들 중 최댓값 반환. 없으면 null
    // + floorKey: &lt;=key, ceilingKey: >=key, higherKey: >key

NavigableMap&lt;K, V> descendingMap()
NavigableMap&lt;K, V> subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)
    // + headMap, tailMap
</div></div><h3 class="marker">컬렉션 연산 인터페이스</h3><div><h4 class="marker">interface Enumeration&lt;E></h4><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">boolean hasMoreElements()
E nextElement()
default Iterator&lt;E> asIterator() // Since 9
</div><h4 class="marker">interface Iterator&lt;E></h4><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">boolean hasNext()
E next()
default void remove()
    // 마지막으로 반환된 원소를 제거. next() 호출 뒤 한 번만 호출 가능.
default void forEachRemaining(Consumer&lt;? super E> action)
</div><h4 class="marker">interface ListIterator&lt;E> extends Iterator&lt;E></h4><p>양방향으로 이동 가능한 iterator.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">boolean hasPrevious()
E previous()
int nextIndex() // + previousIndex
void set(E e)   // 마지막으로 반환된 요소를 변경
void add(E e)   // next()로 반환될 요소 바로전에 삽입.
</div><h4 class="marker">interface PrimitiveIterator&lt;T, T_CONS> extends Iterator&lt;T></h4><ol><li>기본 타입의 박싱을 회피하기 위한 이터레이터를 제공한다</li><li>OfInt, OfLong, OfDouble이 제공된다</li></ol><div><h5 class="marker">static interface PrimitiveIterator.OfInt extends PrimitiveIterator&lt;Integer, IntConsumer></h5><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">int nextInt()
default void forEachRemaining(IntConsumer action)
</div></div><h4 class="marker">interface Spliterator&lt;T></h4><ol><li>Iterator와 마찬가지로 순회를 위한 기능을 제공한다. Iterator와 달리 병렬 순회가 가능하며, 순회 메서드가 hasNext(), next()로 이분화되지 않는다.</li><li>병렬 순회하려는 경우, 동일 Spliterator 객체를 이용하지 말고, 다른 스레드는 trySplit()을 통해 얻은 객체로 순회해야 한다.</li><li>박싱을 피하기 위한 Spliterator를 제공한다. OfInt, OfLong, OfDouble.</li></ol><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static int CONCURRENT, DISTINCT, IMMUTABLE, NONNULL, ORDERED, SIZED, SORTED, SUBSIZED

boolean tryAdvance(Consumer&lt;? super T> action)
    // 남은 원소가 존재하면 하나를 소비하고 true 반환. 그 외엔 false
default void forEachRemaining(Consumer&lt;? super T> action)

Spliterator&lt;T> trySplit()
    // 이 spliterator를 분리할 수 있다면, 일부분을 분리하여 반환하고, 이 spliterator는 나머지 원소들을 순회한다. 그 외엔 null

long estimateSize()
    // forEachRemaining() 메서드에서 순회할 원소의 수를 예측하여 반환한다. 무한하거나, 알 수 없거나, 계산하는 연산이 비싼 경우 Long.MAX_VALUE를 반환하면 된다.
default long getExactSizeIfKnown()
    // 이 spliterator가 SIZED인 경우 estimateSize()를 반환한다. 그 외엔 -1

default Comparator&lt;? super T> getComparator()
    // 이 spliterator의 소스가 Comparator를 이용해 정렬된(SORTED) 경우, 해당 Comparator를 반환한다. 그 외엔 null, 또는 IllegalStateException</div><div><h5 class="marker">static interface Spliterator.OfInt extends Spliterator.OfPrimitive&lt;Integer, IntConsumer, Spliterator.OfInt></h5><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">default boolean tryAdvance(Consumer&lt;? super Integer> action)
    // action이 IntConsumer 인스턴스면 형변환되어 사용된다.
    // + forEachRemaining
</div></div><h4 class="marker">interface RandomAccess</h4><p>빠른(보통 상수 시간) 임의 접근이 가능한 List를 나타내는 마커 인터페이스</p></div><h3 class="marker">컬렉션 자료형 콘크리트 클래스</h3><div><h4 class="marker">static class AbstractMap.SimpleEntry&lt;K, V> implements Map.Entry&lt;K, V>, Serializable</h4><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">public SimpleEntry(K key, V value)</div><h4 class="marker">static class AbstractMap.SimpleImmutableEntry&lt;K, V> implements Map.Entry&lt;K, V>, Serializable</h4><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">public SimpleImmutableEntry(K key, V value)</div><h4 class="marker">class ArrayDeque&lt;E> extends AbstractCollection&lt;E> implements Deque&lt;E>, Cloneable, Serializable</h4><p>가변 길이 배열로 구현한 Deque. 스레드-안전하지 않음.</p><h4 class="marker">class ArrayList&lt;E> extends AbstractList&lt;E> implements List&lt;E>, RandomAccess, Cloneable, Serializable</h4><p>가변 길이 배열로 구현한 List. 스레드-안전하지 않음.</p><h4 class="marker">class Vector&lt;E> extends AbstractList&lt;E> implements List&lt;E>, RandomAccess, Cloneable, Serializable</h4><p>ArrayList와 달리 스레드-안전하다.</p><h4 class="marker">class BitSet implements Cloneable, Serializable</h4><p>각 비트의 기본값은 false. 스레드-안전하지 않음.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">void andNot(BitSet set)
    // set에 true로 설정된 모든 index에 대해 false 설정

boolean intersects(BitSet set)
    // 하나라도 true로 일치하는 경우

int size()        // 총 비트 수
int cardinality() // true 비트 수
int length()      // the index of the highest set bit
</div><h4 class="marker">class EnumMap&lt;K extends Enum&lt;K>, V> extends AbstractMap&lt;K, V> implements Serializable, Cloneable</h4><p>Enum을 키로 이용.</p><h4 class="marker">abstract class EnumSet&lt;E extends Enum&lt;E>> extends AbstractSet&lt;E> implements Cloneable, Serializable</h4><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static &lt;E extends Enum&lt;E>> EnumSet&lt;E> of(E e)
static &lt;E extends Enum&lt;E>> EnumSet&lt;E> range(E from, E to)
static &lt;E extends Enum&lt;E>> EnumSet&lt;E> noneOf(Class&lt;E> elementType) // 공집합 반환
static &lt;E extends Enum&lt;E>> EnumSet&lt;E> allOf(Class&lt;E> elementType)  // 전체 집합 반환
static &lt;E extends Enum&lt;E>> EnumSet&lt;E> complementOf(EnumSet&lt;E> s)   // 여집합 반환
static &lt;E extends Enum&lt;E>> EnumSet&lt;E> copyOf(Collection&lt;E> c)
</div><h4 class="marker">class HashMap&lt;K, V> extends AbstractMap&lt;K, V> implements Map&lt;K, V>, Cloneable, Serializable</h4><p>스레드-안전하지 않음.</p><h4 class="marker">class HashSet&lt;E> extends AbstractSet&lt;E> implements Set&lt;E>, Cloneable, Serializable</h4><p>스레드-안전하지 않음.</p><h4 class="marker">class IdentityHashMap&lt;K, V> extends AbstractMap&lt;K, V> implements Map&lt;K, V>, Serializable, Cloneable</h4><p>스레드-안전하지 않다. 일반적으로 (k1==null ? k2==null : k1.equals(k2))로 키를 비교하는 것과 달리 (k1==k2)로 비교한다.</p><p>keySet()으로 반환되는 Set&lt;K>, values()로 반환되는 Collection&lt;V>, entrySet()으로 반환되는 Set&lt;Map.Entry&lt;K, V>> 모두 원소의 비교를 == 연산으로 한다.</p><h4 class="marker">class LinkedList&lt;E> entends AbstractSequentialList&lt;E> implements List&lt;E>, Deque&lt;E>, Cloneable, Serializable</h4><p>List와 Deque을 모두 구현. 스레드-안전하지 않음.</p><h4 class="marker">class LinkedHashMap&lt;K, V> extends HashMap&lt;K, V> implements Map&lt;K, V></h4><p>키가 삽입된 순서대로 원소를 유지하는 이중 연결 리스트를 가진다. 키가 존재하는 상황에서 put() 호출로 순서가 변경되지 않는다. 스레드-안전하지 않다.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder)
    // accessOrder == true ? 접근 빈도로 정렬 : 삽입 순서로 정렬
</div><h4 class="marker">class LinkedHashSet extends HashSet&lt;E> implements Set&lt;E>, Cloneable, Serializable</h4><p>삽입된 순서대로 원소를 유지하는 이중 연결 리스트를 가진다. 원소가 존재하는 상황에서 add() 호출로 순서가 변경되지 않는다. 스레드-안전하지 않다.</p><h4 class="marker">class PriorityQueue&lt;E> extends AbstractQueue&lt;E> implements Serializable</h4><p>우선순위 힙에 기반한 unbounded 우선순위 큐. head가 가장 우선순위가 작은 원소.</p><h4 class="marker">class Stack&lt;E> extends Vector&lt;E></h4><p>LIFO 스택.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">int search(Object o) // top으로부터 거리 반환</div><h4 class="marker">class TreeMap&lt;K, V> extends AbstractMap&lt;K, V> implements NavigableMap&lt;K, V>, Cloneable, Serializable</h4><p>Red-Black tree(이진 탐색 트리의 일종) 기반의 NavigableMap 구현. log(n) 시간의 작업을 보장한다. 스레드-안전하지 않다.</p><h4 class="marker">class TreeSet&lt;E> extends AbstractSet&lt;E> implements NavigableSet&lt;E>, Cloneable, Serializable</h4><p>TreeMap 기반의 NavigableSet 구현. 스레드-안전하지 않다.</p><h4 class="marker">class WeakHashMap&lt;K, V> extends AbstractMap&lt;K, V> implements Map&lt;K, V></h4><p>key의 존재 여부는 key가 GC 대상이 되는 것에 영향이 없다. key 객체가 유효하지 않게 되면 자동으로 맵에서 삭제한다. key, value 모두에 null을 허용한다. 단, value가 key의 참조를 가지지 않도록 유의해야 한다. 스레드-안전하지 않다.</p></div><h3 class="marker">유틸리티 클래스</h3><div><h4 class="marker">class Collections</h4><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">public static final Set EMPTY_SET   // 변경 불가
public static final List EMPTY_LIST // 변경 불가
public static final Map EMPTY_MAP   // 변경 불가

// 리스트 연산
static &lt;T extends Comparable&lt;? super T>> void sort(List&lt;T> list)
    // T 자체가 Comparable하거나, T에 대한 Comparator를 넘기거나
static &lt;T> int binarySearch(List&lt;? extends Comparable&lt;? super T>> list, T key)
static void reverse(List&lt;?> list)
    // + shuffle, swap, fill, rotate
static &lt;T> void copy(List&lt;? super T> dest, List&lt;? extends T> src)
static &lt;T> boolean replaceAll(List&lt;T> list, T oldVal, T newVal)
static int indexOfSubList(List&lt;?> source, List&lt;?> target)
    // + lastIndexOfSubList
static &lt;T> ArrayList&lt;T> list(Enumeration&lt;T> e)

// Collection 연산
static &lt;T extends Object & Comparable&lt;? super T>> T min(Collection&lt;? extends T> coll)
static int frequency(Collection&lt;?> c, Object o)
static boolean disjoint(Collection&lt;?> c1, Collection&lt;?> c2)
    // 공통 원소가 없는지 여부.

// 변경 불가능한 Collection Factory
static &lt;T> Collection&lt;T> unmodifiableCollection(Collection&lt;? extends T> c)
    // + ...

// Synchronization
//     비결정 상태에 빠지는 것을 방지하기 위해, 반환된 컬렉션에 대해 synchronized 제약을 걸고 이용하는 것이 좋다.
static &lt;T> Collection&lt;T> synchronizedCollection(Collection&lt;T> c)
    // + ...

// 타입 체킹 추가
static &lt;E> Collection&lt;E> checkedCollection(Collection&lt;E> c, Class&lt;E> type)
    // + ...

// Empty Collection(변경 불가)
static &lt;T> Iterator&lt;T> emptyIterator()
    // + ...

// Singleton Collection(변경 불가)
static &lt;T> Set&lt;T> singleton(T o)
static &lt;T> List&lt;T> nCopies(int n, T o)
static &lt;T> List&lt;T> singletonList(T o)
static &lt;K, V> Map&lt;K, V> singletonMap(K key, V value)

// 기타
static &lt;T> Comparator&lt;T> reverseOrder()
    // 자연스러운 비교자의 역 반환.
static &lt;T> Comparator&lt;T> reverseOrder(Comparator&lt;T> cmp)
static &lt;T> Queue&lt;T> asLifoQueue(Deque&lt;T> deque)
    // deque에 대한 LIFO view를 Queue로 반환한다.
</div><h4 class="marker">final class Spliterators</h4><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static &lt;T> Spliterator&lt;T> emptySpliterator()
    // + emptyIntSpliterator, emptyLongSpliterator, emptyDoubleSpliterator
static &lt;T> Spliterator&lt;T> spliterator(Object[] array, int additionalCharacteristics)
    // Arrays.spliterator()가 제공하는 것에 특성을 추가하고 싶을 때 사용. 전형적으로 IMMUTABLE, ORDERED

static &lt;T> Spliterator&lt;T> spliteratorUnknownSize(Iterator&lt;? extends T> iterator, int characteristics)
    // Spliterator로 래핑한 후에 iterator를 사용하면 안 된다.
static &lt;T> Iterator&lt;T> iterator(Spliterator&lt;? extends T> spliterator)
    // Iterator로 래핑한 후에 spliterator를 사용하면 안 된다.        </div><div><h5 class="marker">abstract static class Spliterators.AbstractSpliterator&lt;T> implements Spliterator&lt;T></h5><p>estimateSize(), characteristics(), trySplit()을 구현한 추상 클래스</p></div></div></div><h2 class="marker">객체, 배열 관련</h2><div><h3 class="marker">@FunctionalInterface interface Comparator&lt;T></h3><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">default Comparator&lt;T> reversed()

default Comparator&lt;T> thenComparing(Comparator&lt;? super T> other)
    // 이 비교자가 두 객체를 같다고 판단하면, other가 새로 판단한다.
    // + thenComparingInt, Long, Double

static &lt;T extends Comparable&lt;? super T>> Comparator&lt;T> naturalOrder()
    // 자연스러운 비교자를 반환한다.
    // + reverseOrder

static &lt;T> Comparator&lt;T> nullsFirst(Comparator&lt;? super T> comparator)
    // null은 모든 non-null 값보다 작다고 간주한다. null끼리는 서로 같다고 간주한다.
    // + nullsLast

static &lt;T, U> Comparator&lt;T> comparing(Function&lt;? super T, ? extends U> keyExtractor, Comparator&lt;? super U> keyComparator)
    // 정렬에 이용할 키를 생성하는 함수와, 키를 이용해 비교하는 비교자를 넘기면 둘을 포함하는 T타입 비교자를 반환.
    // + comparingInt, Long, Double
</div><h3 class="marker">class Arrays</h3><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">// 정렬, 검색
static void sort(int[] a)
static void parallelSort(byte[] a)
    // 병합 정렬을 병렬로 수행한다. 모든 병렬 작업은 ForkJoin common pool을 이용해 이루어진다.
static int binarySearch(long[] a, long key)

// 변경, 변환
static void fill(long[] a, long val)
static &lt;T> void setAll(T[] array, IntFunction&lt;? extends T> generator)
static &lt;T> void parallelSetAll(T[] array, IntFunction&lt;? extends T> generator)
static &lt;T> void parallelPrefix(T[] array, BinaryOperator&lt;T> op)
    // 전체 원소에 순차적으로 연산 적용하여 값 변경. 큰 배열은 루프보다 이게 더 빠르다.

static String toString(long[] a)
static String deepToString(Object[] a)
    // toString(Object[])이 o.toString()을 이용하는 반면 여기서는 String.valueOf(Object)가 이용되고, 원소가 배열인 경우 "[]"를 추가하고 해당 배열의 원소들에 대해 같은 작업을 한다.

static &lt;T> List&lt;T> asList(T... a)
static &lt;T> Spliterator&lt;T> spliterator(T[] array)
    // characteristics()에서 SIZED | SUBSIZED | ORDERED | IMMUTABLE를 반환하는 Spliterator 인스턴스를 반환한다.
static &lt;T> Stream&lt;T> stream(T[] array)

// 복사
static &lt;T, U> T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]> newType)
static &lt;T> T[] copyOf(T[] original, int newLength)
static &lt;T, U> T[] copyOfRange(U[] original, int from, int to, Class&lt;? extends T[]> newType)
static &lt;T> T[] copyOfRange(T[] original, int from, int to)

// 비교
static int mismatch(boolean[] a, boolean[] b)  // Since 9
    // 처음으로 일치하지 않는 인덱스 반환.
static boolean equals(long[] a, int aFromIndex, int aToIndex, long[] b, int bFromIndex, int bToIndex) // Since 9
    // Object의 경우, Objects.equals(e1, e2)일 때 같다고 간주한다.
static boolean deepEquals(Object[] a1, Object[] a2)
    // null일 수 있는 각 배열의 두 원소 e1, e2에 대하여, 다음 4가지 경우에 대해 둘이 같다고 판단한다.
    //     1. e1 == e2
    //     2. 둘 모두 참조변수에 대한 배열이고, Arrays.deepEquals(e1, e2)가 true
    //     3. 둘 모두 원시타입에 대한 배열이고, Arrays.equals(e1, e2)가 true
    //     4. e1.equals(e2)가 true

// 해싱
static int hashCode(long[] a)
    // 동일 원소를 가진 List의 해시코드와 동일. null이면 0 반환
static int deepHashCode(Object[] a)
    // 원소가 배열인 경우, 해당 원소의 해시를 deepHashCode로 구한다. 자기 자신을 포함하는 배열 등은 적합하지 않다.
</div><h3 class="marker">final class Objects</h3><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">// 비교
static boolean deepEquals(Object a, Object b)
    // 둘 다 null이면 true. 둘 다 배열이면 Arrays.deepEquals(), 나머진 a.equals(b)
static &lt;T> int compare(T a, T b, Comparator&lt;? super T> c)

// hashCode
static int hash(Object... values)
    // values가 하나의 배열에 든 것처럼 Arrays.hashCode(Object[])를 이용한다. Object.hashCode()의 간편한 구현으로 이용할 수 있다.
    // 주의. hashCode(o) != hash(o)

// toString
static String toString(Object o, String nullDefault)

// null
static boolean isNull(Object obj)
    // Predicate, filter(Objects::isNull)에 이용
static &lt;T> T requireNonNull(T obj)
    // 메서드나 생성자에서 null검사를 하도록 설계되었다.
static &lt;T> T requireNonNullElse(T obj, T defaultObj) // Since 9
static &lt;T> T requireNonNullElseGet(T obj, Supplier&lt;? extends T> supplier) // Since 9

// index Since 9
static int checkIndex(int index, int length)
    // index가 [0, length)에 존재하면 그대로 반환. 아니면 예외 발생.
static int checkFromToIndex(int fromIndex, int toIndex, int length)
    // subrange [fromIndex, toIndex)가 [0, length)에 포함되면 fromIndex 반환. 아니면 예외 발생.
static int checkFromIndexSize(int fromIndex, int size, int length)
    // subrange [fromIndex, fromIndex + size)가 [0, length)에 포함되면 fromIndex 반환. 아니면 예외 발생.
</div><h3 class="marker">final class Optional&lt;T> + OptionalInt, OptionalDouble, OptionalLong</h3><p>null을 허용하지 않는 객체에 대한 컨테이너. value-based므로 identity-sensitive한 연산은 피해야 한다.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static &lt;T> Optional&lt;T> empty()
static &lt;T> Optional&lt;T> of(T value)
static &lt;T> Optional&lt;T> ofNullable(T value)
    // null이면 empty(), 아니면 of(value)

T get()
T orElse(T other)
T orElseGet(Supplier&lt;? extends T> supplier)
Optional&lt;T> or(Supplier&lt;? extends Optional&lt;? extends T>> supplier)
    // Since 9, 값이 존재하면 그대로 반환. 없으면 제공되는 값 반환.
T orELseThrow()
    // Since 10, 값이 없으면 NoSuchElementException

boolean isPresent()
    // + isEmpty Since 11
void ifPresent(Consumer&lt;? super T> action)
void ifPresentOrElse(Consumer&lt;? super T> action, Runnable emptyAction) // Since 9

Optional&lt;T> filter(Predicate&lt;? super T> predicate)
    // 값이 존재하고 필터를 통과하면 그대로 반환. 아니면 빈 컨테이너 반환
Stream&lt;T> stream()
    // Since 9, 값이 존재하면 해당 값 하나만 포함하는 스트림 반환. 없으면 빈 스트림 반환.

&lt;U> Optional&lt;U> map(Function&lt;? super T, ? extends U> mapper)
&lt;U> Optional&lt;U> flatMap(Function&lt;? super T, ? extends Optional&lt;? extends U>> mapper)
    // mapper가 반환하는 값 자체가 Optional이므로 map()과 달리 추가적인 Optional로 감싸지 않는다.
</div></div><h2 class="marker">시간 관련</h2><div><h3 class="marker">class Date implements Serializable, Cloneable, Comparable&lt;Date></h3><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">long getTime()
boolean before(Date when)
static Date from(Instant instant)
</div><h3 class="marker">abstract class Calendar implements Serializable, Cloneable, Comparable&lt;Calendar></h3><ol><li>관대함(Leniency) : 범위를 벗어나는 값도 받아들이며, 나중에 정규화한다. 예를 들어 1월 32일은 2월 1일이 된다.</li><li>add와 roll : add는 오버플로되면 다음 단위가 변하지만, roll은 modulo연산처럼 해당 단위만 변한다.</li></ol><div><h4 class="marker">Field Detail</h4><ol><li>시간 단위</li><p>public static final int ERA, YEAR, MONTH, WEEK_OF_YEAR, WEEK_OF_MONTH_, DATE, ...</p><li>단위 상수</li><p>public static final int SUNDAY, ..., JANUARY, ...AM, PM</p><li>스타일</li><p>public static final int ALL_STYLES, SHORT, LONG, NARROW_FORMAT, ...</p></ol></div><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static Calendar getInstance()
static Locale[] getAvailableLocales()
static Set&lt;String> getAvailableCalendarTypes()

// 달력의 현재 시점을 저장하고 있으므로, 시각 비교, 설정 등의 연산 제공
final Date getTime()
int get(int field)
abstract void add(int field, int amount)
void roll(int field, int amount)
abstract void roll(int field, boolean up) // 1 기본단위만큼 up/down

boolean isLenient()
int getFirstDayOfWeek()
int getMinimalDaysInFirstWeek()
    // 첫 주의 시작이 1월 1일인 경우 1, 그 외의 경우 7
boolean isWeekDateSupported()
    // default false
    // getWeekYear(), setWeekDate(int,int,int), getWeeksInWeekYear() 등을 지원하는지 여부.</div><div><h4 class="marker">static class Calendar.Builder</h4><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">Calendar.Builder setInstant(long instant) // 밀리초
Calendar.Builder set(int field, int value)
Calendar.Builder setFields(int... fieldValuePairs)
    // 예: setFields(Calendar.YEAR, 2013, Calendar.MONTH, Calendar.DECEMBER, Calendar.DAY_OF_MONTH, 23)
Calendar.Builder setTimeZone(TimeZone zone)
Calendar.Builder setLenient(boolean lenient) : build()에서 사용된다
</div></div><h3 class="marker">class GregorianCalendar extends Calendar</h3><p>GregorianCalendar는 아래 메서드를 지원한다.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">int getWeekYear()
void setWeekDate(int weekYear, int weekOfYear, int dayOfWeek)
int getWeeksInWeekYear()
final Instant toInstant()
int getActualMaximum(int field)
int getActualMinimum(int field)
</div><h3 class="marker">class Timer</h3><ol><li>백그라운드 스레드에서 미래에 실행될 작업들을 스케쥴링하는 기능을 제공한다. 작업은 일회용일수도, 일정한 주기를 가지고 반복될 수도 있다. 한 타이머의 모든 작업들은 하나의 백그라운드 스레드를 공유하기 때문에, 작업의 실행은 직렬적이며, 따라서 각 작업들은 가능한 한 빠르게 종료되어야 한다. 그렇지 않은 경우, 뒤에 대기하는 모든 작업이 밀려 제대로 실행되지 않을 수 있다.</li><li>스레드-안전하다. 정시성을 보장하지 않는다. 스케쥴은 Object.wait(long) 메서드를 통해 이루어진다. java.util.concurrent 패키지의 ScheduledThreadPoolExecutor가 더 나은 대안으로 이용될 수 있다.</li><li>기본적으로 타이머의 백그라운드 스레드는 데몬 스레드가 아니다. 따라서 타이머의 작업이 전체 프로그램의 종료를 지연시킬 수 있다. 백그라운드 스레드는 타이머 임의의 생성자에 의해 시작된다.</li></ol><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">void schedule(TimerTask task, long delay)
    // delay밀리초 이후 task가 실행되도록 스케쥴.
void schedule(TimerTask task, Date time)
    // time에 task가 실행되도록 스케쥴. time이 과거라면 즉시 실행
void schedule(TimerTask task, long delay, long period)
    // delay밀리초 이후 period 주기를 갖고 task가 실행되도록 스케쥴.
void schedule(TimerTask task, Date firstTime, long period)
    // firstTime 이후 period 주기를 갖고 task가 실행되도록 스케쥴.
void scheduleAtFixedRate(TimerTask task, long delay, long period)
    // period가 이전 task 종료가 아닌 최초 실행 시점을 기준으로 작동한다. 따라서 어떤 이유로 이전 작업이 지연된 경우, 시간당 작업률을 맞추기 위해 이후 작업이 연속적으로 실행될 수 있다.
void cancel()
    // 타이머를 종료한다. 스케쥴된 모든 작업을 버리고, 현재 실행중인 작업에는 간섭하지 않는다. 타이머 종료 후 백그라운드 스레드도 우아하게 종료되어 GC 대상이 된다. 이후 더 이상의 스케쥴은 불가능하다.
int purge()
    // 호출할 일이 거의 없는 메서드. 많은 작업을 한번에 취소한 경우, 취소한 작업들을 제거하여 참조가 없는 경우 GC 대상이 되도록 한다.
</div><h3 class="marker">abstract class TimerTask implements Runnable</h3><p>Timer 작업으로 사용하기 위한 Runnable</p><ol><li>boolean cancel()</li><ul><li>작업을 취소한다.</li><li>작업이 1회용으로 스케쥴되었지만 아직 실행되지 않은 경우, 또는 아직 스케쥴되지 않은 경우 작업은 결코 실행되지 않는다.</li><li>반복 작업으로 스케쥴된 경우, 작업은 결코 반복되지 않는다.</li><li>작업 도중에 호출된 경우, 작업은 마무리까지 실행된다.</li><li>반복 호출 가능하며 2회째 호출부터는 아무런 영향이 없다.</li><li>true 반환 : 1회용으로 스케쥴되었지만 아직 실행되지 않은 경우, 반복 작업으로 스케쥴된 경우</li><li>false 반환 : 1회용으로 스케쥴되어 이미 실행된 경우, 아직 스케쥴되지 않은 경우, 이미 취소된 경우</li></ul><li>long scheduledExecutionTime()</li><p>가장 최근에 스케쥴된 ─ 또한 실제로 실행된 ─ 시점을 반환한다. 전형적으로 run 메서드에서, 작업이 너무 길어지는 것을 방지하기 위해 사용된다.</p></ol></div><h2 class="marker">숫자 관련</h2><div><h3 class="marker">class DoubleSummaryStatistics implements DoubleConsumer + IntSummaryStatistics, LongSummaryStatistics</h3><ol><li>double에 관한 통계를 모은 상태 객체. 스트림과 함께 사용되도록 설계되었다.</li><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">var stats = doubleStream.collect(DoubleSummaryStatistics::new, DoubleSummaryStatistics::accept, DoubleSummaryStatistics::combine);
var stats = people.stream().collect(Collectors.summarizingDouble(Person::getWeight));</div></ol><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">public DoubleSummaryStatistics()
    // 개수 0, 합계 0, 최솟값 Double.POSITIVE_INFINITY, 최댓값 Double.NEGATIVE_INFINITY, 평균 0인 객체 생성.
    // + (long count, double min, double max, double sum) Since 10
void accept(double value)
    // 요약 정보에 value를 추가
</div><h3 class="marker">class Random implements Serializable</h3><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">public Random()
    // 의사난수 생성기. 스레드-안전하지만 성능 저하 가능성이 있으므로 ThreadLocalRandom을 고려할 것.

void nextBytes(byte[] bytes)
double nextGaussian()
    // 평균 0, 표준분산 1인 정규분포 난수 반환

// 난수 스트림 : + Long, Double 버전 존재
IntStream ints(long streamSize)
IntStream ints() // == ints(Long.MAX_VALUE)
IntStream ints(long streamSize, int randomNumberOrigin, int randomNumberBound) // [origin, bound)
</div><h3 class="marker">final class SplittableRandom</h3><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">public SplittableRandom()
    // 분열하는 의사난수 생성기. 스레드-안전하지 않으며, 분열하여 스레드들이 각자 하나씩 갖도록 설계되었다.

SplittableRandom split()
    // 분열. 상태를 공유하진 않지만, 생성한 난수는 통계적으로 유사한 속성을 갖는다.
</div></div><h2 class="marker">문자열 및 국제화 관련</h2><div><h3 class="marker">class Base64</h3><p>Base64 인코더와 디코더를 반환하는 유틸리티. RFC 2045, 4648</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static Base64.Encoder getEncoder()
static Base64.Encoder getUrlEncoder()
static Base64.Encoder getMimeEncoder()
static Base64.Encoder getMimeEncoder(int lineLength, byte[] lineSeparator)
static Base64.Decoder getDecoder()
static Base64.Decoder getUrlDecoder()
static Base64.Decoder getMimeDecoder()</div><div><h4 class="marker">static class Base64.Encoder</h4><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">byte[] encode(byte[] src)
String encodeToString(byte[] src)
    // new String(encode(src), StandardCharsets.ISO_8859_1)
OutputStream wrap(OutputStream os)
Base64.Encoder withoutPadding()
</div><h4 class="marker">static class Base64.Decoder</h4><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">byte[] decode(byte[] src)
InputStream wrap(InputStream is)
</div></div><h3 class="marker">final class Locale implements Cloneable, Serializable</h3><p>public static final Locale US, ENGLISH, KOREA, KOREAN, ...</p><h3 class="marker">final class Scanner implements Iterator&lt;String>, Closeable</h3><ol><li>정규 표현식을 통해 원시 타입과 String을 분리해내는 간단한 text scanner.</li><li>지정되지 않은 경우, 기본 구분자 패턴은 공백 문자(Character::isWhitespace)</li><li>기저 스트림으로부터 입력을 대기하는 동안 스레드가 블록될 수 있다.</li><li>기저 Readable의 read()에서 IOException이 발생한 경우 소스의 끝에 도달했다고 판단하며, 가장 최근의 예외는 ioException()을 통해 얻을 수 있다</li><li>기저 스트림이 Closeable인 경우, Scanner에 대해 close()가 호출되면 기저 스트림도 닫힌다</li></ol><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">public Scanner(Readable source)
public Scanner(InputStream source)
public Scanner(File source)
public Scanner(Path source)
public Scanner(String source)
public Scanner(ReadableByteChannel source)

Pattern delimiter() // + useDelimiter
Locale locale()     // + useLocale
int radix()         // + useRadix

String findInLine(Pattern pattern)
    // 구분자를 무시하고 pattern을 검색한다. 줄 바꿈 문자 전에 문자열을 찾으면 해당 문자열을 반환하고 다음 라인으로 넘어간다. 줄 바꿈 문자를 만날 때까지 매칭이 없으면 읽기 위치는 변경없이 null을 반환한다.
String findWithinHorizon(Pattern pattern, int horizon)
    // 구분자를 무시하고 pattern을 검색한다. 현재 위치로부터 최대 horizon개의 code point만을 검색에 이용한다. horizon == 0인 경우, 제한없이 검색을 수행한다. 매칭된 문자열이 없으면 읽기 위치 변경없이 null을 반환한다.
Scanner skip(Pattern pattern)
    // 구분자를 무시하고 pattern을 검색한다. 매칭된 문자열이 있으면 건너뛰고, 없으면 읽기 위치 변경 없이 NoSuchElementException 발생.
MatchResult match()
    // 가장 최근의 매칭 결과를 반환한다. MatchResult는 각종 next, findInLine, findWithinHorizon, skip 메서드의 성공적인 실행으로 설정된다.
Stream&lt;MatchResult> findAll(Pattern pattern)
    // Since 9, 스트림의 MatchResult 순서는 findWithinHorizon(pattern, 0), match()를 반복적으로 호출한 것과 동일하다.

Stream&lt;String> tokens()
    // Since 9, 구분자로 자른 문자열들의 스트림을 반환한다
Scanner reset()
    // scanner.useDelimiter("\\p{javaWhitespace}+").useLocale(Locale.getDefault(Locale.Category.FORMAT)).useRadix(10);
</div></div><h2 class="marker">class Properties extends Hashtable&lt;Object, Object></h2><p>stream을 통해 로드/저장되는 영구적인 속성값들을 표현. 기본값으로 이용하기 위해 다른 Properties를 포함할 수 있다. 스레드-안전하다.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">Object setProperty(String key, String value)
String getProperty(String key, String defaultValue)

void list(PrintStream out) // 디버깅에 유용

void load(Reader reader)
void store(Writer writer, String comments)
void loadFromXML(InputStream in)
void storeToXML(OutputStream os, String comment)
</div><h2 class="marker">final class UUID implements Serializable, Comparable&lt;UUID></h2><p>+ com.fasterxml.uuid, com.datastax.cassandra</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">public UUID(long mostSigBits, long leastSigBits)
    // 2개 long을 이용해 128비트 UUID 생성
static UUID randomUUID()
    // version 4 UUID 생성
static UUID nameUUIDFromBytes(byte[] name)
    // version 3 UUID 생성
static UUID fromString(String name)

int version()
    // 1 Time-based UUID
    // 2 DCE security UUID
    // 3 Name-based UUID
    // 4 Randomly generated UUID

int variant()
    // 0 Reserved for NCS
    // 2 RFC 4122(이 클래스에서 사용)
    // 6 Reserved for Microsoft
    // 7 Reserved for future

long timestamp()
    // 60비트로 구성된 Time-based UUID의 시각을 반환한다. 1582-10-15 00:00:00 UTC로부터 몇 100ns가 흘렀는지를 의미한다
long node()
    //Time-based UUID의 48비트 Mac address를 반환한다.
</div></div><h1 class="marker">java.util.concurrent</h1><div><h2 class="marker">@FunctionalInterface interface Callable&lt;V></h2><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">V call() // 매개변수 없는, 결과를 반환하는 작업을 정의. Runnable과 달리 checked 예외를 던져도 된다.</div><h2 class="marker">interface ThreadFactory</h2><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">Thread newThread(Runnable r)</div><h2 class="marker">비동기 자료형 관련</h2><div><h3 class="marker">interface Future&lt;V></h3><p>비동기적 계산의 결과를 표현. 결과는 오직 get 메서드로만 얻을 수 있으며, 필요하다면 결과가 준비될 때까지 블록시킨다.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">boolean cancel(boolean mayInterruptIfRunning)
    // 작업이 완료됐거나 이미 취소된 경우 false를 반환한다. 이 메서드가 종료된 후의 isDone()은 항상 true.
boolean isDone()
V get()
    // 결과가 준비될 때까지 대기
V get(long timeout, TimeUnit unit)
    // 결과가 준비될 때까지 최대 timeout만큼 대기
</div><h3 class="marker">interface RunnableFuture&lt;V> extends Runnable, Future&lt;V></h3><p>Runnable한 Future. 즉 비동기 연산과 그 결과를 표현한다.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">void run() // Future로 하여금 결과를 설정하도록 한다.</div><h3 class="marker">class FutureTask&lt;V> implements RunnableFuture&lt;V></h3><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">public FutureTask(Callable&lt;V> callable)
public FutureTask(Runnable runnable, V result)

protected void done()           // 완료 상태로 천이되면 호출된다
protected void set(V v)         // 결과 설정
protected boolean runAndReset() // 반복 실행 목적
</div><h3 class="marker">interface Delayed extends Comparable&lt;Delayed></h3><p>객체가 일정 지연 뒤 작동함을 마킹하는 인터페이스. 이를 구현할 땐 compareTo를 반드시 같이 구현해야 한다.</p><h3 class="marker">interface ScheduledFuture&lt;V> extends Delayed, Future&lt;V></h3><p>ScheduledExecutorService의 스케쥴링 결과.</p><h3 class="marker">interface RunnableScheduledFuture&lt;V> extends RunnableFuture&lt;V>, ScheduledFuture&lt;V></h3><p>Runnable한 ScheduledFuture</p><h3 class="marker">interface CompletionStage&lt;T></h3><ol><li>비동기적일 수 있는 계산 단계. 다른 CompletionStage가 완료된 뒤 어떠한 동작을 수행하거나 값을 계산한다.</li><p>Stage에서 수행되는 연산은 Function, Consumer, Runnable로 표현되어야 한다. 각각은 apply, accept, run 메서드로 stage에 제공된다.<br>연산에 넘겨지는 인자는 트리거 stage의 결과이며, 이를 통해 연산의 pipeline을 만들 수 있다.<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/concurrent/CompletionStageTest.java" lan="java">View Code »</button></p><li>아래 각 메서드들은 async 버전이 존재한다</li></ol><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">// 이전 연산이 완료되면 그 결과로 fn, action 호출
&lt;U> CompletionStage&lt;U> thenApply(Function&lt;? super T, ? extends U> fn)
CompletionStage&lt;Void> thenAccept(Consumer&lt;? super T> action)
CompletionStage&lt;Void> thenRun(Runnable action)

// this와 other 모두가 종료되면 그 결과로 fn, action 호출
&lt;U, V> CompletionStage&lt;V> thenCombine(CompletionStage&lt;? extends U> other, BiFunction&lt;? super T, ? super U, ? extends V> fn)
&lt;U> CompletionStage&lt;Void> thenAcceptBoth(CompletionStage&lt;? extends U> other, BiConsumer&lt;? super T, ? super U> action)
CompletionStage&lt;Void> runAfterBoth(CompletionStage&lt;?> other, Runnable action)

// this나 other 둘 중 하나라도 종료되면 그 결과로 fn, action 호출
&lt;U> CompletionStage&lt;U> applyToEither(CompletionStage&lt;? extends T> other, Function&lt;? super T, U> fn)
CompletionStage&lt;Void> acceptEither(CompletionStage&lt;? extends T> other, Consumer&lt;? super T> action)
CompletionStage&lt;Void> runAfterEither(CompletionStage&lt;?> other, Runnable action)

// this의 결과를 인자로 fn이 반환하는 CompletionStage가 실행되고, 실행된 결과와 같은 값으로 종료되는 CompletionStage를 반환한다
&lt;U> CompletionStage&lt;U> thenCompose(Function&lt;? super T, ? extends CompletionStage&lt;U>> fn)

// this가 종료되면 결과와 예외를 인자로 fn을 실행하고, fn의 결과로 반환된 stage를 종료한다.
&lt;U> CompletionStage&lt;U> handle(BiFunction&lt;? super T, Throwable, ? extends U> fn)

// this가 종료되면 결과와 예외를 인자로 action을 실행하고, action이 종료되면 반환된 stage도 종료된다.
CompletionStage&lt;T> whenComplete(BiConsumer&lt;? super T, ? super Throwable> action)

// this가 예외를 발생하면 그것을 인자로 fn 실행하는 CompletionStage 반환. 예외 발생이 없는 경우, this의 결과와 같은 값으로 반환된 stage가 종료된다.
CompletionStage&lt;T> exceptionally(Function&lt;Throwable, ? extends T> fn) // Since 12

// this가 예외를 발생하면 fn이 반환하는 CompletionStage로 구성된다.
default CompletionStage&lt;T> exceptionallyCompose(Function&lt;Throwable, ? extends CompletionStage&lt;T>> fn) // Since 12

CompletableFuture&lt;T> toCompletableFuture()
</div><h3 class="marker">class CompletableFuture&lt;T> impliments Future&lt;T>, CompletionStage&lt;T></h3><ol><li>CompletionStage로 이용될 수 있는, 명시적으로 종료(값과 상태를 설정)되는 Future.</li><li>둘 이상의 스레드가 complete, completeExceptionally, cancel을 호출할 경우, 하나만 성공한다.</li><li>non-async 메서드로 등록된 작업은 현재 CompletableFuture가 완료된 스레드 또는 호출자에서 실행된다.</li><li>명시적인 Executor 없이 async 메서드로 등록된 작업은 ForkJoinPool#commonPool에서 수행.</li><li>CompletionStage 메서드들을 독립적으로 구현했기 때문에, 하나를 재정의해도 다른 메서드에 영향이 없다.</li><li>CompletionStage 메서드들만 이용하도록 하려면 minimalCompletionStage()를, future를 변경하지 못하도록 하려면 copy()를 이용.</li><li>전반적인 계산에 대한 직접적인 제어를 할 수 없어서 cancel()의 호출은 completeExceptionally(new CancellationException()) 호출과 동일하다</li><li>서브클래스들은 각자의 클래스 인스턴스를 반환하도록 newIncompletableFuture 메서드를 재정의해야 한다</li></ol><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static &lt;U> CompletableFuture&lt;U> supplyAsync(Supplier&lt;U> supplier)
    // supplier의 결과를 가지고 비동기 종료되는 CompletableFuture 반환
static CompletableFuture&lt;Void> runAsync(Runnable runnable)
    // runnable을 실행하고 비동기 종료되는 CompletableFuture 반환
static &lt;U> CompletableFuture&lt;U> completedFuture(U value)
    // 이미 특정 값으로 종료된 CompletableFuture 반환
static CompletableFuture&lt;Void> allOf(CompletableFuture&lt;?>... cfs)
    // 모든 cfs가 종료되면 완료되는 새로운 CompletableFuture 객체 반환. 하나라도 예외 종료되면 반환된 CompletableFuture도 그러하다. cfs가 빈 경우, null로 종료된다
static CompletableFuture&lt;Object> anyOf(CompletableFuture&lt;?>... cfs)
    // 하나라도 종료되면, 그 결과와 같은 값으로 종료되는 CompletableFuture 객체 반환. cfs가 빈 경우, 완료되지 않는다

T join()
    // 종료되면 결과 값 반환, 또는 발생한 예외 던지기. 예외는 CompletionException이고, 기저 예외를 cause로 설정한다
T getNow(T valueIfAbsent)
    // 종료되었다면 결과 값 반환, 또는 발생한 예외 던지기. 아니면 valueIfAbsent 반환.
boolean complete(T value)
    // 종료되지 않았다면 get()과 연관 메서드들의 반환값을 value로 설정. 이 호출로 CompletableFuture가 완료 상태로 천이되었다면 true 반환.
boolean completeExceptionally(Throwable ex)
    // 종료되지 않았다면 get()과 연관 메서드들이 주어진 예외를 던지도록 한다. 이 호출로 CompletableFuture가 완료 상태로 천이되었다면 true 반환.

boolean isCompletedExeptionally()
void obtrudeValue(T value)
    // 강제로 get()과 연관 메서드들의 반환값 설정. 에러 복구를 위해 설계됨.
    // + obtrudeException
int getNumberOfDependents()
    // 종료 대기중인 CompletableFuture의 개수 추정. 동기화가 아닌 시스템 모니터링을 위해 설계됨.

// Since 9
static Executor delayedExecutor(long delay, TimeUnit unit)
    // 주어진 딜레이 이후에 executor로 작업을 제출하는 새로운 Executor 반환.
static &lt;U> CompletionStage&lt;U> completedStage(U value)
    // 주어진 value로 이미 종료된 새로운 CompletionStage 반환.
static &lt;U> CompletableFuture&lt;U> failedFuture(Throwable ex)
    // 주어진 예외로 이미 종료된 새로운 CompletableFuture 객체 반환.
static &lt;U> CompletionStage&lt;U> failedStage(Throwable ex)
    // 주어진 예외로 이미 종료된 새로운 CompletionStage 반환.
&lt;U> CompletableFuture&lt;U> newIncompletableFuture()
    // 완료되지 않은 새로운 CompletableFuture 객체를 반환한다. 서브클래스들은 각자의 클래스 인스턴스를 반환하도록 newIncompletableFuture 메서드를 재정의해야 한다
Executor defaultExecutor()

CompletableFuture&lt;T> copy()
    // 정상적으로 종료되었다면, 같은 값을 갖는 종료된 CompletableFuture 반환.
    // 예외 종료되었다면, 해당 예외를 원인으로 한 CompletionException으로 예외 종료된 CompletableFuture 반환. 동작은 thenApply(x -> x)와 같다.
CompletionStage&lt;T> minimalCompletionStage()
    // CompletionStage에 정의된 메서드만 이용 가능. 재정의되지 않았다면 toCompletableFuture() 메서드를 통해 그 외의 메서드에 접근 가능하다.

CompletableFuture&lt;T> completeAsync(Supplier&lt;? extends T> supplier)
    // 이 CompletableFuture를 supplier의 결과값으로 종료한다.
CompletableFuture&lt;T> orTimeout(long timeout, TimeUnit unit)
    // 이 CompletableFuture가 주어진 시간 내에 종료되지 않은 경우, TimeoutException으로 예외 종료한다.
CompletableFuture&lt;T> completeOnTimeout(T value, long timeout, TimeUnit unit)
    // 이 CompletableFuture가 주어진 시간 내에 종료되지 않은 경우, value로 종료한다.</div><div><h4 class="marker">static interface CompletableFuture.AsynchronousCompletionTask</h4><p>비동기 메서드에서 생성된 비동기 작업을 나타내는 마커 인터페이스</p></div><h3 class="marker">abstract class ForkJoinTask&lt;V> implements Future&lt;V>, Serializable</h3><ol><li>ForkJoinPool의 실행 단위. 일반적인 스레드보다 훨씬 가벼운 유사-스레드</li><li>메인 ForkJoinTask가 존재하여 다른 subtask들을 실행한다</li><li>전형적으로는 fork, join 메서드 쌍만 이용하며, a.fork(); b.fork(); b.join(); a.join();처럼 join 순서에 유의</li><li>RecursiveAction : 반환이 필요없는 경우<br>RecursiveTask : 반환이 필요한 경우<br>CountedCompleter : 작업의 완료가 다른 작업의 트리거가 되는 경우</li></ol><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">final ForkJoinTask&lt;V> fork()
    // 작업 시작
final V join()
    // 종료 대기 후 결과 반환. 비정상 종료 시 RuntimeException 또는 Error 발생
final V invoke()
    // fork + join

static ForkJoinTask&lt;?> adapt(Runnable runnable)
static void invokeAll(ForkJoinTask&lt;?>... tasks)
    // 모든 작업을 시작. 모두 완료되면 반환. 하나라도 예외가 발생하면 rethrow. 예외 종료된 경우 각 작업의 상태는 직접 획득해야 한다.

final boolean isCompleteNormally()
    // + isCompletedAbnormally
final Throwable getException()
</div><h3 class="marker">abstract class RecursiveAction extends ForkJoinTask&lt;Void></h3><p>재귀적이며 결과없는 ForkJoinTask<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/concurrent/RecursiveActionTest.java" lan="java">View Code »</button><br>코드 출처 : https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/concurrent/RecursiveAction.html</p><h3 class="marker">abstract class RecursiveTask&lt;V> extends ForkJoinTask&lt;V></h3><p>재귀적이며 결과가 있는 ForkJoinTask<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/concurrent/RecursiveTaskTest.java" lan="java">View Code »</button><br>코드 출처 : https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/concurrent/RecursiveTask.html</p><h3 class="marker">abstract class CountedCompleter&lt;T> extends ForkJoinTask&lt;T></h3><ol><li>다른 작업들을 기다린 뒤 트리거로 작업을 시작하는 ForkJoinTask</li><li>Concrete 서브클래스들은 compute() 메서드를 반드시 재정의해야 하며, 되도록이면 반환하기 전에 tryComplete()을 호출해야 한다</li><li>일반적으로 CountedCompleter는 결과를 갖지 않겠지만, 결과가 필요한 경우 getRawResult() 메서드를 재정의하면 된다</li><li><button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/concurrent/CountedCompleterTest.java" displayRange="[14,34,75,85]" lan="java">예시 : setPendingCount + tryComplete</button><button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/concurrent/CountedCompleterTest.java" displayRange="[36,54,75,85]" lan="java">예시 : addToPendingCount + propagateCompletion</button><button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/concurrent/CountedCompleterTest.java" displayRange="[56,73,75,85]" lan="java">예시 : 생성자에서 pendingCount 설정</button><button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/concurrent/CountedCompleterTest.java" displayRange="[87,130]" lan="java">예시 : quietlyCompleteRoot</button><button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/concurrent/CountedCompleterTest.java" displayRange="[132,168]" lan="java">예시 : compute 사용없이 트리거로만 이용</button><br>출처 ; https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/concurrent/CountedCompleter.html</li></ol><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">abstract void compute()
    // 메인 작업

void onCompletion(CountedCompleter&lt;?> caller)
    // tryComplete()이 호출되고, 남은 pendingCount가 0이면 호출된다. 또는 complete(T)가 호출된 경우에도 실행된다
boolean onExceptionalCompletion(Throwable ex, CountedCompleter&lt;?> caller)
    // compute()에서 예외가 발생했거나, ForkJoinTask#completeExceptionally가 호출된 경우 실행된다. 기본 구현은 return true;
    // true를 반환하였고, caller가 아직 완료되지 않은 경우, caller도 같은 예외로 종료된다

final CountedCompleter&lt;?> getCompleter()
    // 생성자에서 지정한 부모 completer 반환 + getRoot
final void tryComplete()
    // pendingCount가 0이 아니면 1 감소시킨다. 0인 경우 onCompletion 메서드를 호출하고, parent completer에 대해서도 tryComplete()을 호출한다
final void propagateCompletion()
    // tryComplete()와 같지만, onCompletion 메서드는 호출하지 않는다

final CountedCompleter&lt;?> firstComplete()
    // pendingCount가 0이면 return this; 그 외엔 pendingCount를 감소시키고 return null;
final CountedCompleter&lt;?> nextComplete()
    // parent completer가 없는 경우, ForkJoinTask#quietlyComplete 호출하고 return null; pendingCount가 0이 아니면 감소시키고 return null;
    // 그 외엔 parent completer 반환
for(var c = firstComplete(); c != null; c = c.nextComplete()) { ... }

final void helpComplete(int maxTasks)
    // 이 작업이 완료되지 않았다면, completion path 상의 최대 maxTasks개 만큼의 시작되지 않은 작업을 진행시킨다
</div></div><h2 class="marker">Executor 관련</h2><div><h3 class="marker">interface Executor</h3><ol><li>전달받은 Runnable을 실행하는 객체. Executor 자체가 스레드의 병행성을 부여하진 않으며, 구현에서 호출자와 다른 스레드 공간을 마련해주어야 한다.</li><li>void execute(Runnable command)</li></ol><h3 class="marker">interface ExecutorService extends Executor</h3><ol><li>java.util.concurrent 패키지의 기본적인 Executor 구현.<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/concurrent/ExecutorServiceTest.java" lan="java">View Code »</button></li></ol><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">void shutdown()
    // 추가적인 Runnable을 받지 않는다. 이전에 추가된 것은 마저 실행한다.
List&lt;&Runnable> shutdownNow()
    // 실행중인 모든 작업을 중지. 실행 대기중이었던 작업들은 반환.

boolean isTerminated()
    // shutdown, shutdownNow 호출 이후 모든 작업이 끝났는지 여부
boolean awaitTermination(long timeout, TimeUnit unit)
    // shutdown 요청 후 모든 작업이 종료되기를 기다리며 블록한다. timeout 발생한 경우 false 반환.

&lt;T> Future&lt;T> submit(Callable&lt;T> task)
    // 결과를 반환하는 작업을 등록한다. 작업이 성공적으로 종료되면 Future#get으로 결과를 확인할 수 있다.
&lt;T> Future&lt;T> submit(Runnable atask, T result)
    // 작업을 등록한다. 작업이 성공적으로 종료되면 Future#get으로 result를 얻을 수 있다.
Futur&lt;?> submit(Runnable task)
    // 작업을 등록한다. 작업이 성공적으로 종료되면 Future#get은 null을 반환한다.

&lt;T> List&lt;Future&lt;T>> invokeAll(Collection&lt;? extends Callable&lt;T>> tasks)
    // 모든 작업이 종료되면 Future 리스트를 반환한다. 따라서 리스트 안의 각 Future#isDone은 true다.
&lt;T> List&lt;Future&lt;T>> invokeAll(Collection&lt;? extends Callable&lt;T>> tasks, long timout, TimeUnit unit)
    // 모든 작업이 종료되거나 timeout이 발생하면 반환. 리스트 안의 각 Future#isDone은 true. timeout 발생 시 완료되지 않은 작업들은 취소된다.
&lt;T> T invokeAny(Collection&lt;? extends Callable&lt;T>> tasks)
    // 성공적으로 완료된 첫 작업의 결과를 반환한다. 완료되지 않은 작업들은 취소된다.
&lt;T> T invokeAny(Collection&lt;? extends Callable&lt;>> tasks, long timeout, TimeUnit unit)
    // timeout되면 TimeoutException 발생
</div><h3 class="marker">interface ScheduledExecutorService extends ExecutorService</h3><p>실행 전에 딜레이를 두거나, 주기적으로 실행을 반복할 수 있는 ExecutorService</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">ScheduledFuture&lt;?> schedule(Runnable command, long delay, TimeUnit unit)
    // 주어진 delay 이후 command가 1회 실행되도록 한다
ScheduledFuture&lt;?> scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)
    // 반복되는 작업은 반환된 Future를 통해 취소할 수 있다.
ScheduledFuture&lt;?> scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)
    // scheduleAtFixedRate와 달리, 이전 작업이 완료된 후 다음 작업이 시작된다.
</div><h3 class="marker">abstract class AbstractExecutorService implements ExecutorService</h3><p>submit, invokeAny, invokeAll 메서드 구현. 반환하는 RunnableFuture에는 FutureTask 이용.</p><h3 class="marker">class ThreadPoolExecutor extends AbstractExecutorService</h3><ol><li>각 작업들은 스레드풀의 별개 스레드에서 실행된다</li><li>Core and maximum pool sizes</li><p>corePoolSize에 도달할 때까지 신규 작업에 대해 신규 스레드를 할당한다. 대기 중인 스레드가 없으면 maxPoolSize에 도달할 때까지 신규 작업에 대해 신규 스레드를 할당한다</p><li>On-demand construction</li><p>처음부터 corePoolSize만큼의 스레드를 만들어놓을 지를 설정할 수 있다</p><li>Creating new threads</li><p>지정되지 않으면 Executors#defaultThreadFactory로부터 신규 스레드를 생성한다. 동일 스레드그룹 + NORM_PRIORITY + non-daemon</p><li>Keep-alive times</li><p>corePoolSize를 초과한 스레드들은 대기 상태가 keepAliveTime을 초과하면 종료된다. allowCoreThreadTimeOut 메서드로 코어 스레드에도 적용할 지 설정 가능</p><li>Queuing</li><ul><li>처리를 기다리는 작업들은 BlockingQueue에서 대기한다.</li><li>corePoolSize 이상의 스레드가 활성 상태라면 작업은 우선 큐에 진입된다. 큐에 자리가 없으면 신규 스레드가 생성되어 작업을 처리한다.</li><li>큐에 자리도 없고 활성 스레드 수가 maximumPoolSize와 같다면 추가 작업은 거부된다</li><li>큐잉 전략 1. Direct handoff</li><p>SynchronousQueue. 작업 가능한 스레드가 없으면 신규로 생성한다. 제한없는 maximumPoolSize 필요</p><li>큐잉 전략 2. Unbounded queue</li><p>무제한으로 큐에 작업을 추가하므로, 활성 스레드의 수는 항상 corePoolSize 이하다</p><li>큐잉 전략 3. Bounded queue</li><p>큐의 크기와 maxPoolSize의 적절한 trade off 필요</p></ul><li>Rejected tasks</li><ul><li>거부된 작업에 대하여 RejectedExecutionHandler#rejectedExecution 메서드가 실행된다</li><li>기본 정책. ThreadPoolExecutor.AbortPolicy : 핸들러가 RejectedExecutionException 발생</li><li>ThreadPoolExecutor.CallerRunsPolicy : 작업을 제출한 스레드가 직접 작업을 실행한다</li><li>ThreadPoolExecutor.DiscardPolicy : 거부된 작업은 버려진다</li><li>ThreadPoolExecutor.DiscardOldestPolicy : 신규 작업이 아닌, 큐에서 가장 오래된 작업이 버려진다. 신규 작업은 다시 시도된다</li></ul><li>Hook methods</li><p>beforeExecute, afterExecute, terminated 메서드를 재정의하여 작업 전후에 필요한 부분을 실행할 수 있다</p></ol><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">void execute(Runnable command)
    // command를 언젠가 실행한다. 작업 스레드가 실행하지 못하면, RejectedExecutionHandler가 처리한다
    // ↔ remove

void shutdown()
    // 순차적 종료 절차에 진입한다. 추가 작업은 받지 않고, 이미 제출된 작업들은 마저 처리한다
List&lt;Runnable> shutdownNow()
    // 대기 중인 작업에 더해 실행 중인 작업들도 모두 중지한다. 대기중이었던 작업들은 리스트로 반환한다. 실행 중인 작업들에 유예 시간을 주고 싶다면 ExecutorService#awaitTermination 이용
boolean isTerminating()
    // shutdown 또는 shutdownNow 메서드가 호출되었지만, 아직 중지가 완료되지는 않았다면 true

void setThreadFactory(ThreadFactory threadFactory)
    // + set/getRejectedExecutionHandler, set/getCorePoolSize, set/getMaximumPoolSize, set/getKeepAliveTime
void allowCoreThreadTimeOut(boolean value)
    // 코어 스레드에도 keep-alive를 적용할 지 여부

boolean prestartCoreThread()
    // 신규 스레드를 하나 생성한다. 이미 corePoolSize 만큼 스레드가 존재한다면 false 반환.
int prestartAllCoreThreads()
    // 생성된 스레드의 수가 corePoolSize가 될 때까지 신규 스레드를 생성한다. 신규로 생성된 스레드의 수를 반환한다
BlockingQueue&lt;Runnable> getQueue()
               직접 조작하진 말고, 모니터링/디버깅 용도로 이용함이 바람직하다

int getPoolSize()            // 현재 풀 안의 스레드 수 반환
int getActiveCount()         // 현재 실행 중인 스레드 수 추정치 반환
int getLargestPoolSize()     // 풀에 동시에 존재했던 스레드의 최대 개수 반환
long getTaskCount()          // 실행 스케쥴된 작업의 총 개수의 근사치 반환
long getCompletedTaskCount() // 실행 완료된 작업의 총 개수의 근사치 반환</div><div><h4 class="marker">interface RejectedExecutionHandler</h4><p>ThreadPoolExecutor에서 실행되지 않은 작업에 대한 처리를 위해 사용.</p></div><h3 class="marker">class ScheduledThreadPoolExecutor extends ThreadPoolExecutor implements ScheduledExecutorService</h3><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">void setContinueExistingPeriodicTasksAfterShutdownPolicy(boolean value)
    // 기본값 false. true면 shutdownNow가 호출되거나 이 정책이 false가 될 때까지 주기 작업을 계속 실행한다

void setExecuteExistingDelayedTasksAfterShutdownPolicy(boolean value)
    // 기본값 true. true면 shutdownNow가 호출되거나 종료 후 이 정책이 false가 되기 전까지는 지연 작업을 실행한다

void setRemoveOnCancelPolicy(boolean value)
    // 기본값 false. 취소된 작업을 즉시 큐에서 제거할 것인지, 또는 해당하는 딜레이 후 제거할 것인지 설정.
</div><h3 class="marker">interface CompletionService&lt;V></h3><p>생산자가 작업들을 추가하면, 소비자는 그것이 완료된 순서대로 이용할 수 있다.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">Future&lt;V> submit(Callable&lt;V> task)
Future&lt;V> submit(Runnable task, V result)
Future&lt;V> take()
    // 완료된 작업을 가져온다. 없으면 대기한다.
Future&lt;V> poll()
    // 완료된 작업을 가져온다. 없으면 null.
Futur&lt;V> poll(long timeout, TimeUnit unit)
</div><h3 class="marker">class ExecutorCompletionService&lt;V> impliments CompletionService&lt;V&gt</h3><p>CompletionService 구현. 주어진 Executor를 실행에 이용한다. 완료되는 순서대로 작업을 take 메서드로 접근할 수 있는 큐에 배치한다.</p><h3 class="marker">class ForkJoinWorkerThread extends Thread</h3><p>ForkJoinPool에서 ForkJoinTask를 실행하는 스레드</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">int getPoolIndex()
    // 풀 안에서 이 스레드의 번호(Unique)
</div><h3 class="marker">class ForkJoinPool extends AbstractExecutorService</h3><ol><li>ForkJoinTask에 관한 ExecutorService. Non-ForkJoinTask 호출자도 이용할 수 있는 메서드를 제공한다</li><p>execute(ForkJoinTask), invoke(ForkJoinTask), submit(ForkJoinTask)</p><li>모든 ForkJoinWorkerThread는 데몬 스레드로 초기화된다</li><li>Common pool 튜닝에 관한 시스템 속성</li><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">java.util.concurrent.ForkJoinPool.common.parallelism
    // parallelism level. 기본값은 프로세서 수
java.util.concurrent.ForkJoinPool.common.threadFactory
    // class name of a ForkJoinPool.ForkJoinWorkerThreadFactory
java.util.concurrent.ForkJoinPool.common.exceptionHandler
    // class name of a Thread.UncaughtExceptionHandler
java.util.concurrent.ForkJoinPool.common.maximumSpares
    // maximum number of allowed extra threads to maintain target parallelism (default 256).</div></ol><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static ForkJoinPool commonPool()

&lt;T> T invoke(ForkJoinTask&lt;T> task)
void execute(ForkJoinTask&lt;?> task)
&lt;T> ForkJoinTask&lt;T> submit(ForkJoinTask&lt;T> task)</div><div><h4 class="marker">static interface ForkJoinPool.ForkJoinWorkerThreadFactory</h4><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">ForkJoinWorkerThread newThread(ForkJoinPool pool)</div><h4 class="marker">static interface ForkJoinPool.ManagedBlocker</h4><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">boolean block()
    // 필요한 만큼 현재 스레드를 블록시킨다. 추가적인 블로킹이 필요하지 않으면 true 반환
boolean isReleasable
    // 블로킹이 필요없으면 true 반환
</div></div><h3 class="marker">class Executors</h3><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">// ExecutorService 관련
static ExecutorService newFixedThreadPool(int nThreads)
    // 최대 동시 실행 가능한 스레드 수 제한. 나머지 스레드는 큐에서 대기. 스레드들은 명시적으로 shutdown되기 전까지 풀에 존재한다.
static ExecutorService newWorkStealingPool()
    // 사용 가능한 프로세서 수를 parallelism level로 이용. 반환되는 객체는 ForkJoinPool 인스턴스
static ExecutorService newSingleThreadExecutor()
    // 하나의 워커 스레드만 사용한다. 예기지 않게 워커가 종료되면 새로운 스레드가 나머지 작업을 위해 그 자리를 대신할 수 있다.
    // 같은 특징을 갖는 newFixedThreadPool(1)과 다르게, 반환된 ExecutorService가 추가적인 워커 스레드를 이용하도록 설정할 수 없다.
static ExecutorService newCachedThreadPool()
    // 이전에 종료된 스레드를 재사용. 60초 동안 이용되지 않으면 풀에서 삭제된다.
static ExecutorService unconfigurableExecutorService(ExecutorService executor)
    // ExecutorService에 정의된 메서드들은 executor에 연결하고, 그 외 캐스트를 통해 이용할 수 있는 메서드들은 호출하지 못하도록 한다.

// ScheduledExecutorService 관련
static ScheduledExecutorService newSingleThreadScheduledExecutor()
static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)
static ScheduledExecutorService unconfigurableScheduledExecutorService(ScheduledExecutorService executor)
    // ScheduledExecutorService에 정의된 메서드들은 executor에 연결하고, 그 외 캐스트를 통해 이용할 수 있는 메서드들은 호출하지 못하도록 한다.

// ThreadFactory 관련
static ThreadFactory defaultThreadFactory()
    // 모든 스레드들을 같은 ThreadGroup으로 생성한다. 스레드의 우선순위는 Threa.NORM_PRIORITY와 그룹의 최대 허용치 중 작은 것으로 설정된다.
    // 각 스레드들은 non-daemon으로 생성되며, Thread.getName()을 통해 얻을 수 있는 "pool-N-thread-M" 꼴의 이름으로 접근할 수 있다.
static ThreadFactory privilegedThreadFactory()
    // 호출하는 스레드와 같은 권한으로 새로운 스레드를 생성하는 ThreadFactory 반환.

// Callable 관련
static &lt;T> Callable&lt;T> callable(Runnable task, T result)
static Callable&lt;Object> callable(Runnable task)
    // 작업이 완료되면 null을 반환하는 Callable 반환
static Callable&lt;Object> callable(PrivilegedAction&lt;?> action)
    // 호출되면 action#run을 실행하고 그 결과를 반환하는 Callable 반환
static Callable&lt;Object> callable(PrivilegedExceptionAction&lt;?> action)
static &lt;T> Callable&lt;T> privilegedCallable(Callable&lt;T> callable)
    // 호출되면 callable을 현재 access control context에서 실행. AccessController.doPrivileged에서 호출되어야 한다.
static &lt;T> Callable&lt;T> privilegedCallableUsingCurrentClassLoader(Callable&lt;T> callable)
</div></div><h2 class="marker">리액티브 스트림</h2><p>https://github.com/reactive-streams/reactive-streams-jvm</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">final class Flow { // Since 9
    static int defaultBufferSize() // 256
}
@FunctionalInterface static interface Flow.Publisher&lt;T> {
    void subscribe(Flow.Subscriber&lt;? super T> subscriber)
}</div><div><h3 class="marker">Publisher 규칙</h3><ol><li>Publisher가 Subscriber에 onNext로 신호를 보낸 횟수 &lt;= Subscriber가 Subscription으로 보낸 request의 횟수</li><p>이 규칙은 onNext의 호출에 대하여, 선행되는 request가 항상 존재함을 함의한다</p><li>Publisher가 onNext로 신호를 보낸 횟수가 request보다 적은 경우, Subscription을 onComplete 또는 onError로 종결한다</li><p>이 규칙은 request에 대한 onNext가 항상 존재하지는 않음을 명시한다</p><li>onSubscribe, onNext, onError, onComplete 신호는 직렬적이어야 한다</li><p>결코 다른 신호와 중첩되는 시점이 있어서는 안 된다</p><li>Publisher의 실패는 반드시 onError로 보내야 한다</li><li>스트림이 정상적으로 종결된 경우 Publisher는 반드시 onComplete 신호를 보내야 한다</li><li>Publisher가 onError, onComplete 신호를 보낸 경우, Subscription은 반드시 취소된 것으로 간주되야 한다</li><li>종료 상태(onError, onCompletion)에서 추가적인 신호의 발생은 절대 없다</li><li>Subscription이 취소된 경우, 추가적인 신호 전달은 절대 없다</li><li>Publisher.subscribe 안에서 onSubscribe를 반드시 호출해야 하며, 반드시 다른 신호를 보내기 전에 선행되어야 한다. 또, 이 경우 메서드는 반드시 정상 종결되어야 한다</li><p>Subscriber.onSubscribe 호출 시 null 검사는 필요없다. NullPointerException이 발생하게 내버려두면 된다.</p><li>Publisher.subscribe는 여러 번 호출될 수 있지만, 하나의 Subscriber로부터는 최대 한 번만 호출되어야 한다</li><li>Publisher는 여러 Subscriber들에 대한 멀티캐스트를 지원할 수 있다</li></ol></div><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static interface Flow.Subsbriber&lt;T> {
    void onSubscribe(Flow.Subscription)
    onNext(T)
    onError(Throwable)
    onComplete(Void)
}</div><div><h3 class="marker">Subscriber 규칙</h3><ol><li>Subscriber는 onNext 신호를 받고 싶다면 반드시 먼저 request 신호를 보내야 한다</li><li>신호를 보낼 때, Publisher의 완료를 기다리지 말고 비동기적으로 전달함이 권장된다</li><li>onComplete, onError 메서드는 절대 Subscription, Publisher 어느쪽의 메서드도 호출해선 안 된다</li><li>onComplete, onError 신호를 받은 이후부터, Subscription은 반드시 취소로 간주되어야 한다</li><li>유효한 Subscription이 존재한다면, 추가적인 onSubscribe 신호에 대해 반드시 cancel을 호출해야 한다</li><p>하나의 Subscriber는 둘 이상의 Publisher를 동시에 구독하지 않아야 한다</p><li>더 이상 필요없다면 반드시 Subscription.cancel을 호출해야 한다</li><li>Subscription으로 보내는 신호들은 반드시 직렬적이어야 한다</li><p>결코 동시에 두 신호를 보내는 순간은 없어야 한다</p><li>cancel의 호출은 대기 중인 작업의 취소를 보장하지 않는다. cancel 이후 추가적인 onNext 신호에 대해 준비되어야 한다</li><li>아무런 request를 보내지 않았더라도, onComplete, onError 신호에 대해 준비되어야 한다</li><li>onSubscribe, onNext, onError, onComplete는 인자가 null이 아닌 이상 반드시 정상 종료되어야 한다</li><p>Subscriber의 실패는 Subscription.cancel로만 통지할 수 있다. 이 규칙이 지켜지지 않은 경우, Subscription은 반드시 취소로 간주되어야 한다</p></ol></div><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static interface Flow.Subscription {
    void request(long)
    cancel(Void)
}</div><div><h3 class="marker">Subscription 규칙</h3><ol><li>request, cancel은 반드시 Subscriber가 호출해야 한다</li><li>onNext, onSubscribe 안에서 동기적으로 request를 호출하는 것은 허용된다</li><li>cancel의 호출은 멱등이어야 하고, 그 실행은 스레드-안전해야 한다</li><li>Subscription이 취소됐다면, 이후의 request, cancel의 호출은 아무 작업도 하지 않아야 한다</li><li>0이하에 대한 request 호출은 onError로 IllegalArgumentException을 보내야 한다</li><li>Subscription이 취소됐다면, Publisher는 Subscriber에 대한 모든 참조를 제거해야 한다</li><li>request, cancel은 항상 정상 종료되어야 한다</li><li>Subscription은 반드시 무제한적인 request 호출을 허용해야 한다. n == Long.MAX_VALUE</li></ol></div><div><h3 class="marker">class SubmissionPublisher&lt;T> implements Flow.Publisher&lt;T>, AutoCloseable Since 9</h3><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">public SubmissionPublisher(Executor executor, int maxBufferCapacity, BiConsumer&lt;? super Flow.Subscriber&lt;? super T>, ? super Throwable> handler)
    // executor : 비동기적으로 구독자에게 전달하는 데 쓰일 Executor
    // maxBufferCapacity : 각 구독자에 대한 버퍼의 한도. 실제 한도는 getMaxBufferCapacity()로 확인
    // handler : null이 아니면 onNext에서 발생한 예외를 처리
public SubmissionPublisher()
    // executor = ForkJoinPool.commonPool()
    // maxBufferCapacity = Flow.defaultBufferSize()
    // handler = null

int submit(T item)
    // 각 구독자에게 비동기적으로 item을 보낸다(onNext). lag(배포된 item 중에 아직 소비되지 않은 개수) 추정치를 반환한다.
int offer(T item, BiPredicate&lt;Flow.Subscriber&lt;? super T>, ? super T> onDrop)
    // 가능하다면 각 구독자에게 비동기적으로 item을 보낸다(onNext). 리소스 초과(버퍼가 가득 찼다던지)로 실패한 경우 onDrop이 실행된다. onDrop이 true를 반환하면 onNext를 다시 시도한다.
    // 반환값이 음수인 경우 drop된 구독자 수를 의미하고, 그 외의 경우 lag(배포된 item 중에 아직 소비되지 않은 개수) 추정치를 의미한다

long estimateMinimumDemand()
    // 각 구독자들이 요청한 아이템 수 중, 아직 공급되지 않은 수의 최소값(추정치) 반환
int estimateMaximumLag()
    // 각 구독자들에 보낸 아이템 중 아직 소비되지 않은 수의 최대값(추정치) 반환
CompletableFuture&lt;Void> consume(Consumer&lt;? super T> consumer)
    // 배포된 모든 아이템에 대해 consumer 실행. 정상적으로 모두 실행되면 onComplete가 호출되고, CompletableFuture도 정상 종료된다
</div></div><h2 class="marker">Blocking 컬렉션</h2><div><h3 class="marker">interface BlockingQueue&lt;E> extends Queue&lt;E></h3><ol><li>기본적으로 스레드-안전하지만, addAll 따위의 bulk 연산은 특별히 표시되지 않는 한 그렇지 않다.</li><li>요소를 획득할 때, 큐가 비어있는 경우 블로킹. 요소를 추가할 때, 큐에 빈 자리가 있을 때까지 블로킹</li></ol><table><tr><th></th><th>예외 발생</th><th>특별값 반환</th><th>블로킹</th><th>시간 제한</th></tr><tr><th>Insert</th><td>add(E)</td><td>offer(E)</td><td>put(E)</td><td>offer(E,long,TimeUnit)</td></tr><tr><th>Remove</th><td>remove()</td><td>poll()</td><td>take()</td><td>poll(long,TimeUnit)</td></tr><tr><th>Examine</th><td>element()</td><td>peek()</td><td>-</td><td>-</td></tr></table><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">int remainingCapacity()
    // 블로킹없이 삽입 가능한 요소의 수. 오차가 있을 수 있다
int drainTo(Collection&lt;? super E> c)
    // 모든 원소를 c로 옮긴다
</div><h3 class="marker">class ArrayBlockingQueue&lt;E> extends AbstractQueue&lt;E> implements BlockingQueue&lt;E>, Serializable</h3><ol><li>크기가 고정된 기저 배열을 이용한 BlockingQueue</li><li>기본적으로 삽입을 기다리는 스레드들 사이의 처리 순서는 보장되지 않지만, fairness를 설정하면 FIFO 순으로 처리된다</li><li>Collection, Iterator의 모든 선택적 연산을 구현했다.</li></ol><h3 class="marker">class LinkedBlockingQueue&lt;E> extends AbstractQueue&lt;E> implements BlockingQueue&lt;E>, Serializable</h3><ol><li>크기를 고정할 수 있는 연결된 BlockingQueue</li><li>Collection, Iterator의 모든 선택적 연산을 구현했다</li></ol><h3 class="marker">class PriorityBlockingQueue&lt;E> extends AbstractQueue&lt;E> implements BlockingQueue&lt;E>, Serializable</h3><ol><li>크기 제한 없고, PriorityQueue와 비슷한 정렬을 이용한 BlockingQueue</li><li>Collection, Iterator의 모든 선택적 연산을 구현했다</li><p>다만 iterator(), spliterator()로 제공되는 인스턴스들은 순회하는 순서를 보장하지 않는다. 순차적인 순회를 원한다면 Arrays.sort(queue.toArray())를 고려할 것</p><li>같은 우선순위의 원소 사이의 정렬은 정의되지 않았다</li></ol><h3 class="marker">class SynchronousQueue&lt;E> extends AbstractQueue&lt;E> implements BlockingQueue&lt;E>, Serializable</h3><ol><li>서로 연관된 삽입 연산과 삭제 연산 한 쌍이 동시에 존재할 때까지 연산을 블로킹한다</li><li>Collection, Iterator의 모든 선택적 연산을 구현했지만, 빈 컬렉션처럼 동작한다</li></ol><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">public SynchronousQueue(boolean fair)
    // fair : 대기하는 스레드들이 순서대로 처리된다. 지정되지 않으면 false
</div><h3 class="marker">class DelayQueue&lt;E extends Delayed> extends AbstractQueue&lt;E> implements BlockingQueue&lt;E></h3><ol><li>Delayed 요소들로 구성된, 크기 제한없는 BlockingQueue. 요소의 지연 시간이 만료되어야 큐로부터 획득 가능하다</li><p>요소가 만료됐음은 getDelay(TimeUnit.NANOSECONDS) 리턴값이 0 이하일 때로 판정</p><li>Collection, Iterator의 모든 선택적 연산을 구현했다</li></ol><h3 class="marker">interface BlockingDeque&lt;E> extends BlockingQueue&lt;E>, Deque&lt;E></h3><p>요소를 획득할 때, 덱이 비어있는 경우 블로킹. 요소를 추가할 때, 덱에 빈 자리가 있을 때까지 블로킹</p><table><tr><th></th><th>예외 발생</th><th>특별값 반환</th><th>블로킹</th><th>시간 제한</th></tr><tr><th>Insert</th><td>addFirst(E)<br>addLast(E)</td><td>offerFirst(E)<br>offerLast(E)</td><td>putFirst(E)<br>putLast(E)</td><td>offerFirst(E,long,TimeUnit)<br>offerLast(E,long,TimeUnit)</td></tr><tr><th>Remove</th><td>removeFirst()<br>removeLast()</td><td>pollFirst()<br>pollLast()</td><td>takeFirst()<br>takeLast()</td><td>pollFirst(long,TimeUnit)<br>pollLast(long,TimeUnit)</td></tr><tr><th>Examine</th><td>getFirst()<br>getLast()</td><td>peekFirst()<br>peekLast()</td><td>-</td><td>-</td></tr></table><h3 class="marker">class LinkedBlockingDeque&lt;E> extends AbstractQueue&lt;E> implements BlockingDeque&lt;E>, Serializable</h3><ol><li>크기를 제한할 수 있는 BlockingDeque.</li><li>Collection, Iterator의 모든 선택적 연산을 구현했다</li></ol><h3 class="marker">interface TransferQueue&lt;E> extends BlockingQueue&lt;E></h3><ol><li>생산자가 소비자가 소비할 때까지 대기할 수 있는 BlockingQueue.</li><li>기존의 BlockingQueue와 SynchronousQueue 기능 모두를 선택적으로 이용할 수 있다</li></ol><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">void transfer(E e)
    // 소비자에게 e를 전달한다. 소비자가 소비할 때까지 대기한다
boolean tryTransfer(E e)
    // 대기 중인 소비자에게 e를 전달한다. 대기 중인 소비자가 없다면 즉시 false를 반환한다
boolean tryTransfer(E e, long timeout, TimeUnit unit)
    // timeout이 지나도록 대기 중인 소비자가 없다면 false를 반환한다
</div><h3 class="marker">class LinkedTransferQueue&lt;E> extends AbstractQueue&lt;E> implements TransferQueue&lt;E>, Serializable</h3><ol><li>크기 제한없고 연결된 TransferQueue.</li><li>size 계산에 순회가 필요하므로 정확하지 않을 수 있다</li><li>addAll 따위의 bulk 연산은 원자적으로 실행되지 않을 수 있다</li><li>Collection, Iterator의 모든 선택적 연산을 구현했다</li></ol></div><h2 class="marker">Non-Blocking 컬렉션</h2><div><h3 class="marker">class CopyOnWriteArrayList&lt;E> implements List&lt;E>, RandomAccess, Cloneable, Serializable</h3><ol><li>스레드-안전한 ArrayList</li><li>add, set 등의 연산마다 새로운 배열을 만든다. 따라서 일반적인 용도로는 매우 나쁘다</li><li>iterator는 생성된 시점의 snapshot을 순회함이 보장되지만, iterator를 통한 요소의 변경은 불가하다</li></ol><h3 class="marker">class CopyOnWriteArraySet&lt;E> extends AbstractSet&lt;E> implements Serializable</h3><p>모든 연산에 CopyOnWriteArrayList를 사용하는 Set</p><h3 class="marker">class ConcurrentLinkedQueue&lt;E> extends AbstractQueue&lt;E> implements Queue&lt;E>, Serializable</h3><ol><li>크기 제한 없고, 스레드-안전한 연결된 Queue</li><li>size 계산에 순회가 필요하므로, 오차가 있을 수 있다</li><li>addAll 따위의 bulk 연산은 원자적으로 실행되지 않을 수 있다</li><li>Collection, Iterator의 모든 선택적 연산을 구현했다.</li></ol><h3 class="marker">class ConcurrentlinkedDeque&lt;E> extends AbstractCollection&lt;E> implements Deque&lt;E>, Serializable</h3><ol><li>크기 제한 없고, 스레드-안전한 연결된 Deque</li><li>size 계산에 순회가 필요하므로, 오차가 있을 수 있다</li><li>addAll 따위의 bulk 연산은 원자적으로 실행되지 않을 수 있다</li><li>Collection, Iterator의 모든 선택적 연산을 구현했다.</li></ol><h3 class="marker">interface ConcurrentMap&lt;K, V> extends Map&lt;K, V></h3><ol><li>스레드-안전, 작업의 원자성 보장</li><p>Map의 각 연산, Map이 반환하는 컬렉션들의 연산 모두 재정의해야 한다</p></ol><h3 class="marker">interface ConcurrentNavigableMap&lt;K, V> extends ConcurrentMap&lt;K, V>, NavigableMap&lt;K, V></h3><p>NavigableMap 연산을 지원하는 ConcurrentMap</p><h3 class="marker">class ConcurrentHashMap&lt;K, V> extends AbstractMap&lt;K, V> implements ConcurrentMap&lt;K, V>, Serializable</h3><ol><li>읽기 연산에 대해서는 완전한 동시성을, 갱신 연산에 대해서는 높은 수준의 동시성을 제공</li><p>Hashtable의 모든 연산을 구현했다. 읽기 연산에 대해 원소를 잠그지는 않으며, 테이블 전체를 잠기는 기능 또한 없다. 가져간 원소를 사용하려고 하는 시점에는 맵에서 제거됐을 수도 있다.</p><li>카운터로 사용할 수 있다. 예. map.computeIfAbsent(key, x -> new LongAdder()).increment();</li><li>Map, Iterator의 모든 선택적 연산을 구현했다</li><li>3가지 Bulk 연산을 지원한다 : forEach, search, reduce</li><p>인자로 받은 parallelismThreshold보다 맵이 작다고 판단되면 순차적으로 원소를 소비, 그 외엔 병렬로 소비. 1이면 최대 병렬성, Long.MAX_VALUE면 병렬 X</p><li>모든 작업 메서드의 매개변수는 non-null이어야 한다</li></ol><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">long mappingCount()
    // 크기가 매우 큰 경우, Map.size() 대신 이용

void forEach(long parallelismThreshold, BiConsumer&lt;? super K, ? super V> action)
    // + forEachKey, forEachValue, forEachEntry
&lt;U> U search(long parallelismThreshold, BiFunction&lt;? super K, ? super V, ? extends U> searchFunction)
    // 찾는 원소에 대해서는 non-null 반환
    // + searchKeys, searchValues, searchEntries
&lt;U> U reduce(long parallelismThreshold, BiFunction&lt;? super K, ? super V, ? extends U> transformer, BiFunction&lt;? super U, ? super U, ? extends U> reducer)
    // + reduceToDouble ~ Int, reduceKeys, reduceKeysToDouble ~ Int, reduceValues, reduceValuesToDouble ~ Int, reduceEntries, reduceEntriesToDouble ~ Int
</div><h3 class="marker">class ConcurrentSkipListMap&lt;K,V> extends AbstractMap&lt;K,V> implements ConcurrentNavigableMap&lt;K,V>, Cloneable, Serializable</h3><ol><li>ConcurrentNavigableMap 구현체. 평균 log(n) 시간이 소요되는, 스레드-안전한<a class="w3-btn w3-round w3-round-xxlarge w3-small w3-green" href="http://en.wikipedia.org/wiki/Skip_list" target="_blank">SkipList</a> 구현을 이용</li><li>오름차순 정렬된 뷰와 이터레이터가 내림차순보다 빠르다</li><li>putAll과 같은 bulk 연산은 원자적으로 종료되지 않을 수 있다</li><li>Map, Iterator의 모든 선택적 연산을 구현했다</li></ol><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">public ConcurrentSkipListMap(Comparator&lt;? super K> comparator)
    // 지정하지 않은 경우, 자연스러운 정렬을 이용한다
</div><h3 class="marker">class ConcurrentSkipListSet&lt;E> extends AbstractSet&lt;E> implements NavigableSet&lt;E>, Cloneable, Serializable</h3><p>ConcurrentSkipListMap을 이용한 NavigableSet</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">public ConcurrentSkipListSet(Comparator&lt;? super E> comparator)
    // 지정하지 않은 경우, 자연스러운 정렬을 이용한다
</div></div><h2 class="marker">실행 기법</h2><div><h3 class="marker">class Semaphore implements Serializable</h3><ol><li>제한된 수의 접근 권한을 acquire()로 획득, release()로 반환.</li><p>fairness : acquire()호출 순서대로 권한 획득.</p><li>public Semaphore(int permits, boolean fair)</li><p>fair : 지정하지 않은 경우 false</p></ol><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">void acquire()
    // 권한을 하나 요구한다. 권한을 얻을 때까지 대기하며, 대기 중인 스레드는 인터럽트될 수 있다.
void acquireUninterruptibly()
    // 대기 중일 때 인터럽트되더라도 계속 대기한다. 인터럽트되지 않았을 경우와 권한을 얻는 시기가 달라질 수 있다
boolean tryAcquire()
void release()
int availablePermits()
int drainPermits()
    // 가용한 모든 권한을 얻는다. 만약 음수라면 release하여 0으로 맞춘다.
boolean isFair()

final boolean hasQueuedThreads()
final int getQueueLength()
</div><h3 class="marker">class CountDownLatch</h3><p>count가 0일 될때까지(원하는 작업들이 완료될 때까지), 1개 이상의 스레드가 대기하는 동기화 제공.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">public CountDownLatch(int count)

void await()
    // count가 0이 될때까지 대기한다. 대기 중에 인터럽트될 수 있다
boolean await(long timeout, TimeUnit unit)
    // 대기 중에 timeout을 넘으면 즉시 false 반환
void countDown()
    // --count, count가 0이면 대기하는 모든 스레드를 깨운다
</div><h3 class="marker">class CyclicBarrier</h3><p>스레드들이 공통의 목적이 달성되기까지 함께 대기. 그 목적을 barrier라고 하며, barrier를 재사용할 수 있어 cyclic하다.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">public CyclicBarrier(int parties, Runnable barrierAction)
    // barrierAction : barrier를 넘을 때 실행. 지정하지 않은 경우, 대기하던 스레드를 깨우기만 한다

int getParties()
int await()
    // 마지막 스레드가 await을 호출할 때까지 대기한다. 대기 중에 인터럽트될 수 있다. 현재 스레드의 대기 순번 반환. getParties() - 1이 첫 번째, 0이 마지막 스레드.
int await(long timeout, TimeUnit unit)
    // timeout을 초과하여 대기하면 barrier는 부서진다
boolean isBroken()
void reset()
    // barrier를 초기 상태로 재설정한다. 이미 대기 중인 스레드가 있다면 BrokenBarrierException 발생. 부서진 barrier를 재사용하려면 별도의 동기화가 필요하므로, 차라리 새로 하나 만들자
int getNumberWaiting()
</div><h3 class="marker">class Exchanger&lt;V></h3><p>두 스레드가 같은 시점에 값을 서로 교환하도록 해준다.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">V exchange(V x) throws InterruptedException
    // 다른 스레드가 같은 지점에 도달하기까지 기다렸다가, 서로 값을 교환한다.
V exchange(V x, long timeout, TimeUnit unit) throws InterruptedException, TimeoutException
    // timeout 초과 시 TimeoutException 발생
</div><h3 class="marker">class Phaser</h3><ol><li>재사용 가능한 동기화 barrier. CyclicBarrier, CountDownLatch 기능에 더해 보다 유연한 메서드 제공</li><li>CyclicBarrier와 다르게 각 회전마다 총 대기하는 스레드 수가 다를 수 있다</li><p>현재 phase가 완료되기 전에 미리 이후의 phase(들)을 등록할 수 있다. 각 phase는 0부터 시작하는 번호를 가진다(Integer.MAX_VALUE에 도달하면 다음은 다시 0)</p><li>계층 구조를 구성할 수 있다. 자식 Phaser의 parties가 0이 아니게 되는 순간 parent에 등록되고, 0이 되는 순간 parent에서 제거된다</li></ol><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">public Phaser(int parties)
    // parties : 다음 phase로 넘어가기 위해 필요한 수
public Phaser(Phaser parent, int parties)
    // parties : 다음 phase로 넘어가기 위해 필요한 수. 지정하지 않으면 0

int register()
    // 새로운 phase를 등록한다
    // + bulkRegister

int arrive()
    // 현재 phaser에 도착한다. 다른 스레드의 도착을 기다리지는 않는다. 현재 phase 번호를 반환한다(종료됐다면 음수)
int arriveAndDeregister()
    // 현재 phaser에 도착하고, 이후 phase에서는 자신이 빠짐을 알린다
int arriveAndAwaitAdvance()
    // 현재 phaser에 도착하고, 현재 phase의 모든 구성원이 도착할 때까지 기다린다 == awaitAdvance(arrive())
int awaitAdvance(int phase) + awaitAdvanceInterruptibly
    // 지정한 번호의 phase의 모든 구성원이 도착할 때까지 기다린다. 현재 phase의 번호와 다르거나, phaser가 종료된 경우엔 즉시 반환한다.

void forceTermination()
    // 계층 구조에 속해있다면, 모든 phaser가 종료된다
final int getPhase()
    // 현재 phase 번호를 반환한다. Phaser가 종료됐다면 음수(마지막 phase 번호 + Integer.MAX_VALUE)를 반환한다
</div></div><h2 class="marker">class ThreadLocalRandom extends Random</h2><p>현재 스레드에 격리된 난수 생성기</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static ThreadLocalRandom current()</div><h2 class="marker">enum TimeUnit</h2><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">NANOSECONDS, MICROSECONDS, MILLISECONDS, SECONDS, MINUTES, HOURS, DAYS

long convert(long sourceDuration, TimeUnit sourceUnit)

void timeWait(Object obj, long timeout)
    // timeout만큼 obj.wait()
void timedJoin(Thread thread, long timeout)
    // timeout만큼 Thread.join()
void sleep(long timeout)
</div></div><h1 class="marker">java.util.concurrent.atomic</h1><div><h2 class="marker">Package Summary</h2><ol><li>변수 하나에 대한 잠금 없는 스레드-안전성을 제공한다</li><li>VarHandle을 통해 변수를 원자적으로 접근한다</li><li>AtomicBoolean, AtomicInteger 등은 일반적인 Boolean, Integer 등을 대신할 수 없다</li><li>메모리 장벽을 만나면 CPU 코어의 캐시값이 RAM으로 반영된다</li></ol><h2 class="marker">abstract class VarHandle implements Constable Since 9</h2><ol><li>java.lang.invoke 패키지 멤버임</li><li>하나의 변수, 매개변수, 필드 등에 대한 동적인 타입 참조. plain 읽기/쓰기, volatile 읽기/쓰기, compare-and-set 접근을 지원한다</li></ol><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">final Object get(Object... args)
    // 변수가 non-volatile인 것처럼 읽는다(= plain read). 모든 VarHandle 인스턴스에서 지원된다
final void set(Object... args)
    // 변수가 non-volatile, non-final인 것처럼 쓴다(= plain write). 메서드 시그니처는 (CT1 ct1, ..., CTn ctn, T newValue)void.

final Object getVolatile(Object... args)
    // 변수가 volatile인 것처럼 읽는다.
final void setVolatile(Object... args)
    // 변수가 volatile인 것처럼 쓴다. 메서드 시그니처는 (CT1 ct1, ..., CTn ctn, T newValue)void.

final Object getOpaque(Object... args)
    // Opaque : Program order 순서대로 접근한다. 다른 스레드와의 조율은 없다
    // + setOpaque

final Object getAcquire(Object... args)
    // 같은 변수에 대해 이어지는 load/store 연산이 이 접근보다 먼저 발생하지 않는다
final void setRelease(Object... args)
    // 같은 변수에 대한 이전의 load/store 연산이 이 접근보다 나중에 발생하지 않는다

final boolean compareAndSet(Object... args)
    // 원자적으로 다음이 실행된다. getVolatile과 동일한 문맥으로 가져온 값(witness value)이 expectedValue와 동일(==)하면 setVolatile과 동일한 문맥으로 newValue 설정 후 true 반환, 그 외엔 false 반환
    // 메서드 시그니처는 (CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)boolean
final Object compareAndExchange(Object... args)
    // 원자적으로 다음이 실행된다. getVolatile과 동일한 문맥으로 가져온 값(witness value)이 expectedValue와 동일(==)하면 setVolatile과 동일한 문맥으로 newValue 설정. 반환값은 witness value
final Object compareAndExchangeAcquire(Object... args)
    // 원자적으로 다음이 실행된다. getAcquire와 동일한 문맥으로 가져온 값(witness value)이 expectedValue와 동일(==)하면 set와 동일한 문맥으로 newValue 설정. 반환값은 witness value
final Object compareAndExchangeRelease(Object... args)
    // 원자적으로 다음이 실행된다. get와 동일한 문맥으로 가져온 값(witness value)이 expectedValue와 동일(==)하면 setRelease와 동일한 문맥으로 newValue 설정. 반환값은 witness value

final boolean weakCompareAndSetPlain(Object... args)
    // 다음이 실행된다. get과 동일한 문맥으로 가져온 값(witness value)이 expectedValue와 동일(==)하면 set과 동일한 문맥으로 newValue 설정 후 true 반환. 그 외엔 false
final boolean weakCompareAndSet(Object... args) + ~Acquire, ~Release
    // 다음이 실행된다. getVolatile과 동일한 문맥으로 가져온 값(witness value)이 expectedValue와 동일(==)하면 setVolatile과 동일한 문맥으로 newValue 설정 후 true 반환. 그 외엔 false

final Object getAndSet(Object... args) + ~Acquire, ~Release
    // 원자적으로 다음이 실행된다. getVolatile과 동일한 문맥으로 값(witness value)을 가져오고, setVolatile과 동일한 문맥으로 newValue 설정 후 witness value 반환
final Object getAndAdd(Object... args) + ~Acquire, ~Release
    // 원자적으로 값을 더한 후 이전 값 반환. 메서드 시그니처는 (CT1 ct1, ..., CTn ctn, T value)T
final Object getAndBitwiseOr(Object... args)
    // 원자적으로 OR 연산 수행 후 이전 값 반환. 메서드 시그니처는 (CT1 ct1, ..., CTn ctn, T mask)T
    // + ~Acquire, ~Release, getAndBitwiseAnd~, getAndBitwiseXor~

static void acquireFence()
    // 장벽 이전의 load 연산이 장벽 이후의 load/store 뒤로 재배치되지 않음
static void fullFence()
    // 장벽 이전의 load/store 연산이 장벽 이후의 load/store 뒤로 재배치되지 않음
static void releaseFence()
    // 장벽 이전의 load/store 연산이 장벽 이후의 store 뒤로 재배치되지 않음
static void loadLoadFence()
    // 장벽 이전의 load 연산이 장벽 이후의 load 뒤로 재배치되지 않음
static void storeStoreFence()
    // 장벽 이전의 store 연산이 장벽 이후의 store 뒤로 재배치되지 않음</div><div><h3 class="marker">static enum VarHandle.AccessMode</h3><table><tr><th>GET</th><td>VarHandle.get</td></tr><tr><th>SET</th><td>VarHandle.set</td></tr><tr><th>GET_VOLATILE</th><td>VarHandle.getVolatile</td></tr><tr><th>SET_VOLATILE</th><td>VarHandle.setVolatile</td></tr><tr><th>GET_ACQUIRE</th><td>VarHandle.getAcquire</td></tr><tr><th>SET_RELEASE</th><td>VarHandle.setRelease</td></tr><tr><th>GET_OPAQUE</th><td>VarHandle.getOpaque</td></tr><tr><th>SET_OPAQUE</th><td>VarHandle.setOpaque</td></tr><tr><th>COMPARE_AND_SET</th><td>VarHandle.compareAndSet</td></tr><tr><th>COMPARE_AND_EXCHANGE</th><td>VarHandle.compareAndExchange</td></tr><tr><th>COMPARE_AND_EXCHANGE_ACQUIRE</th><td>VarHandle.compareAndExchangeAcquire</td></tr><tr><th>COMPARE_AND_EXCHANGE_RELEASE</th><td>VarHandle.compareAndExchangeRelease</td></tr><tr><th>WEAK_COMPARE_AND_SET_PLAIN</th><td>VarHandle.weakCompareAndSetPlain</td></tr><tr><th>WEAK_COMPARE_AND_SET</th><td>VarHandle.weakCompareAndSet</td></tr><tr><th>WEAK_COMPARE_AND_SET_ACQUIRE</th><td>VarHandle.weakCompareAndSetAcquire</td></tr><tr><th>WEAK_COMPARE_AND_SET_RELEASE</th><td>VarHandle.weakCompareAndSetRelease</td></tr><tr><th>GET_AND_SET</th><td>VarHandle.getAndSet</td></tr><tr><th>GET_AND_SET_ACQUIRE</th><td>VarHandle.getAndSetAcquire</td></tr><tr><th>GET_AND_SET_RELEASE</th><td>VarHandle.getAndSetRelease</td></tr><tr><th>GET_AND_ADD</th><td>VarHandle.getAndAdd</td></tr><tr><th>GET_AND_ADD_ACQUIRE</th><td>VarHandle.getAndAddAcquire</td></tr><tr><th>GET_AND_ADD_RELEASE</th><td>VarHandle.getAndAddRelease</td></tr><tr><th>GET_AND_BITWISE_OR</th><td>VarHandle.getAndBitwiseOr</td></tr><tr><th>GET_AND_BITWISE_OR_RELEASE</th><td>VarHandle.getAndBitwiseOrRelease</td></tr><tr><th>GET_AND_BITWISE_OR_ACQUIRE</th><td>VarHandle.getAndBitwiseOrAcquire</td></tr><tr><th>GET_AND_BITWISE_AND</th><td>VarHandle.getAndBitwiseAnd</td></tr><tr><th>GET_AND_BITWISE_AND_RELEASE</th><td>VarHandle.getAndBitwiseAndRelease</td></tr><tr><th>GET_AND_BITWISE_AND_ACQUIRE</th><td>VarHandle.getAndBitwiseAndAcquire</td></tr><tr><th>GET_AND_BITWISE_XOR</th><td>VarHandle.getAndBitwiseXor</td></tr><tr><th>GET_AND_BITWISE_XOR_RELEASE</th><td>VarHandle.getAndBitwiseXorRelease</td></tr><tr><th>GET_AND_BITWISE_XOR_ACQUIRE</th><td>VarHandle.getAndBitwiseXorAcquire</td></tr></table></div><h2 class="marker">class AtomicBoolean implements Serializable + AtomicInteger, AtomicLong, AtomicReference</h2><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">public AtomicBoolean(boolean initialValue)
    // 지정하지 않으면 false

final boolean get()                                                     // VarHandle#getVolatile
final boolean compareAndSet(boolean expectedValue, boolean newValue)    // VarHandle#compareAndSet
boolean weakCompareAndSetPlain(boolean expectedValue, boolean newValue) // Since 9, VarHandle#weakCompareAndSetPlain
final void set(boolean newValue)                                        // VarHandle#setVolatile
final void lazySet(boolean newValue)                                    // VarHandle#setRelease
final boolean getAndSet(boolean newValue)                               // VarHandle#getAndSet
final boolean getPlain()                                                // Since 9, VarHandle#get
final void setPlain(boolean newValue)                                   // Since 9, VarHandle#set
final boolean getOpaque()                                               // Since 9, VarHandle#getOpaque
final void setOpaque(boolean newValue)                                  // Since 9, VarHandle#setOpaque
final boolean getAcquire()                                              // Since 9, VarHandle#getAcquire
final void setRelease(boolean newValue)                                 // Since 9, VarHandle#setRelease
final boolean compareAndExchange(boolean expectedValue, boolean newValue)
    // Since 9, 메모리 영향은 VarHandle#compareAndExchange와 같다.
    //  + ~Acquire, ~Release
final boolean weakCompareAndSetVolatile(boolean expectedValue, boolean newValue)
    // Since 9, 메모리 영향은 VarHandle#weakCompareAndSet와 같다
    // + ~Acquire, ~Release
</div><h2 class="marker">class AtomicIntegerArray implements Serializable + AtomicLongArray, AtomicReferenceArray</h2><p>인덱스를 추가로 받는 것 외에, 지원하는 메서드들은 AtomicInteger와 같다.</p><h2 class="marker">abstract class AtomicIntegerFieldUpdater&lt;T> + AtomicLongFieldUpdater, AtomicReferenceFieldUpdater</h2><ol><li>지정된 volatile int 필드를 atomic 연산으로 갱신.</li><p>해당 필드를 단일 업데이터로만 접근한다면, compareAndSet 메서드들이 원자적으로 작동됨이 보장된다</p><li>지원하는 메서드는 AtomicInteger와 유사하다.</li></ol><h2 class="marker">class AtomicMarkableReference&lt;V></h2><p>원자적으로 갱신되는 마커 bit와 객체 참조 쌍</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">public AtomicMarkableReference(V initialRef, boolean initialMark)

V getReference()
V get(boolean[] markHolder)
    //markHolder[0]에 해당하는 참조 반환

boolean compareAndSet(V expectedReference, V newReference, boolean expectedMark, boolean newMark)
    // 기존 참조와 마커 bit가 모두 예상과 동일(==)하다면 원자적으로 갱신하고 true 반환. 그 외엔 false
    // + weakCompareAndSet
void set(V newReference, boolean newMark)
boolean attemptMark(V expectedReference, boolean newMark)
    // 기존 참조가 예상과 동일(==)하다면, 마커 bit를 원자적으로 갱신하고 true 반환. 그 외엔 false
</div><h2 class="marker">class AtomicStampedReference&lt;V></h2><p>원자적으로 갱신되는 index와 참조 쌍</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">public AtomicStampedReference(V initialRef, int initialStamp)

V getReference()
V get(int[] stampHolder)
    // stampHolder[0]에 해당하는 참조 반환

boolean compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp)
    // 기존 참조와 인덱스가 예상과 동일(==)하다면 원자적으로 갱신하고 true 반환. 그 외엔 false
    // + weakCompareAndSet
void set(V newReference, int newStamp)
boolean attempStamp(V expectedReference, int newStamp)
    //기존 참조가 예상과 동일(==)하다면, 인덱스를 원자적으로 갱신하고 true 반환. 그 외엔 false
</div><h2 class="marker">class LongAdder extends Number implements Serializable + DoubleAdder</h2><ol><li>초깃값 0으로 시작하는 스레드-안전한 합계.</li><p>합의 순서는 정의되지 않으므로 순서에 상관 없는 경우에 이용해야 한다.</p></ol><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">void add(long x)
void increment()
void decrement()
long sum() // 현재 합계
void reset()
long sumThenReset()
</div><h2 class="marker">class LongAccumulator extends Number implements Serializable + DoubleAccumulator</h2><ol><li>특정 값과 특정 함수로 갱신되는 long 값 유지.</li><p>주어진 accumulatorFunction은 부작용이 없어야 한다.</p></ol><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">void accumulate(long x)
long get()
void reset()
long getThenReset()
</div></div><h1 class="marker">java.util.function</h1><div><h2 class="marker">Consumer</h2><div><h3 class="marker">@FunctionalInterface interface Consumer&lt;T></h3><p>인자를 하나 먹고 아무것도 반환하지 않는 소비자.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">void accept(T t)
default Consumer&lt;T> andThen(Consumer&lt;? super T> after)
    // 이 소비자 다음에 after가 소비하는 병합된 소비자 반환.
</div><h3 class="marker">@FunctionalInterface interface DoubleConsumer + int, long</h3><h3 class="marker">@FunctionalInterface interface BiConsumer&lt;T, U></h3><p>인자 두개를 먹고 아무것도 뱉지 않는 소비자.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">void accept(T t, U u)
default BiConsumer&lt;T, U> andThen(BiConsumer&lt;? super T, ? super U> after)
    // 현재 소비자가 작업을 마치면 after가 실행되는 새로운 소비자 반환.
</div><h3 class="marker">@FunctionalInterface interface ObjDoubleConsumer&lt;T> + int, long</h3></div><h2 class="marker">Supplier</h2><div><h3 class="marker">@FunctionalInterface interface Supplier&lt;T></h3><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">T get()</div><h3 class="marker">@FunctionalInterface interface BooleanSupplier + int, double, long</h3><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">boolean getAsBoolean()</div></div><h2 class="marker">Function, Operator</h2><div><h3 class="marker">@FunctionalInterface interface Function&lt;T, R></h3><p>인자 하나를 먹고 결과 하나를 뱉는 함수.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">R apply(T t)
default &lt;V> Function&V, R> compose(Function&lt;? super V, ? extends T> before)
default &lt;V> Function&lt;T, V> andThen(Function&lt;? super R, ? extends V> after)
static &lt;T> Function&lt;T, T> identity()
    // 입력 인자 그대로 반환하는 함수.
</div><h3 class="marker">@FunctionalInterface interface IntFunction&lt;R> + double, long</h3><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">R apply(int value)</div><h3 class="marker">@FunctionalInterface interface DoubleToIntFunction + double, int, long 간의 모든 상호 변환</h3><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">int applyAsInt(double value)</div><h3 class="marker">@FunctionalInterface interface UnaryOperator&lt;T> extends Function&lt;T, T></h3><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static &lt;T> UnaryOperator&lt;T> identity()</div><h3 class="marker">@FunctionalInterface interface DoubleUnaryOperator + int, long</h3><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">double applyAsDouble(double operand)
default DoubleUnaryOperator compose(DoubleUnaryOperator before)
default DoubleUnaryOperator andThen(DoubleUnaryOperator after)
static DoubleUnaryOperator identity()
    // 항상 입력값 그대로 반환하는 단항 연산자 반환.
</div><h3 class="marker">@FunctionalInterface interface ToDoubleFunction&lt;T></h3><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">double applyAsDouble(T value) // + int, long</div><h3 class="marker">@FunctionalInterface interface BiFunction&lt;T, U, R></h3><p>인자 두개를 먹고 값을 반환하는 함수.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">default &lt;V> BiFunction&lt;T, U, V> andThen(Function&lt;? super R, ? extends V> after)
    // 함수가 실행되고 난 결과를 after가 처리하는 새로운 함수 반환.
</div><h3 class="marker">@FunctionalInterface interface ToDoubleBiFunction&lt;T, U></h3><details>double applyAsDouble(T t, U u) // + int, long</details><h3 class="marker">@FunctionalInterface interface BinaryOperator extends BiFunction&lt;T, T, T></h3><p>같은 타입의 인자 두개를 먹고 같은 타입의 값을 반환하는 함수.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static &lt;T> BinaryOperator&lt;T> minBy(Comparator&lt;? super T> comparator)
    // 주어진 comparator에 따라 둘 중 작은 것을 반환하는 함수를 생성.
    // + maxBy
</div><h3 class="marker">@FunctionalInterface interface DoubleBinaryOperator</h3><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">double applyAsDouble(double left, double right)
    // double 두개를 먹고 double 하나를 반환하는 함수. + int, long
</div></div><h2 class="marker">Predicate</h2><div><h3 class="marker">@FunctionalInterface interface Predicate&lt;T></h3><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">boolean test(T t)
default Predicate&lt;T> and(Predicate&lt;? super T> other)
default Predicate&lt;T> or(Predicate&lt;? super T> other)

static &lt;T> Predicate&lt;T> isEqual(Object targetRef)
    // Object.equals(Object, Object)를 이용해 비교하는 Predicate 반환
</div><h3 class="marker">@FunctionalInterface interface DoublePredicate + int, long</h3><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">default DoublePredicate negate()
</div><h3 class="marker">@FunctionalInterface interface BiPredicate&lt;T, U></h3><p>인자 두개를 먹고 가부를 판단하는 함수.</p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">default BiPredicate&lt;T, U> and(BiPredicate&lt;? super T, ? super U> other)
    // A short-circuiting logical AND of this predicate and other.
    // + or
default BiPredicate&lt;T, U> negate()
</div></div></div><h1 class="marker">java.util.regex</h1><div><h2 class="marker">interface MatchResult</h2><p>정규표현식 매칭 결과. group의 의미에 대해선 Pattern 참고.<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/regex/MatchResultExample.java" lan="java">View Code »</button></p><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">int start()             // 매치된 결과의 시작 인덱스 반환
int start(int group)    // group번째 매치된 결과의 시작 인덱스 반환
int end()               // 매치된 결과의 마지막 글자 다음 인덱스 반환
int end(int group)      // group번째 매치된 결과의 마지막 글자 다음 인덱스 반환
String group()          // 이전 매치된 결과 반환
String group(int group) // group번째 매치된 결과 반환
int groupCount()        // 매치된 group 개수 반환
</div><h2 class="marker">final class Pattern implements Serializable</h2><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">public static final int UNIX_LINES       // 줄끝 '\n'만 ., ^, $에서 동작. (?d) 플래그도 같은 의미.
public static final int CASE_INSENSITIVE // 대소문자 구분 없음. (?i) 플래그도 같은 의미.
public static final int COMMENTS         // 공백과 주석 허용. 공백과 #부터 줄 끝까지의 주석이 무시된다. (?x) 플래그도 같은 의미.
public static final int MULTILINE        // ^, $이 각 줄의 끝을 기준으로도 작동; 기본 동작은 입력 시작과 끝에서만 작동. (?m) 플래그도 같은 의미.
public static final int LITERAL          // 표현식 전체를 상수 문자열 취급.
public static final int DOTALL           // .이 줄 끝도 포함하여 매치; 기본 동작은 줄 끝 문자는 미포함. (?s) 플래그도 같은 의미.
public static final int UNICODE_CASE     // CASE_INSENSITIVE 플래그가 유니코드 표준 상에서 동작한다; 기본은 US-ASCII에서만 동작. (?u) 플래그도 같은 의미.


static Pattern compile(String regex)
static boolean matches(String regex, CharSequence input) // 1회용
static String quote(String s) // s를 매칭할 수 있는 정규표현식 리터럴 문자열 표현을 반환.
Predicate&lt;String> asPredicate()
Stream&lt;String> splitAsStream(CharSequence input)</div><div><h3 class="marker">Line terminator</h3><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">"\n", "\r\n", "\r", "\u0085", "\u2028", "\u2029"
// UNIX_LINES 모드에서는 "\n"만 줄 끝으로 인식</div><h3 class="marker">Groups and capturing</h3><ul><li>Group : 괄호로 감싸인 정규표현식 (X)</li><li>Capturing group : 괄호 순서에 따라 그룹에 ID가 매겨지며, 이는 나중에 참조(backreference)될 수 있다</li><p>0번 그룹은 항상 전체 표현을 가리킨다.<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java" displayRange="[16,26]" lan="java">예를 들어</button> (A)(B(C))에 대하여,</p><table class="no-sort"><tr><th>Group ID</th><th>Pattern</th></tr><tr><td>0</td><td>(A)(B(C))</td></tr><tr><td>1</td><td>(A)</td></tr><tr><td>2</td><td>(B(C))</td></tr><tr><td>3</td><td>(C)</td></tr></table><li>Non-capturing group : (?:X)는 후참조(backreference)할 수 없다<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java" displayRange="[28,37]" lan="java">View Code »</button></li></ul><h3 class="marker">Character expression</h3><ul><li>x, \\ : 각각 x, \에 대응<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java" displayRange="[39,39]" lan="java">View Code »</button></li><li>\0n, \0nn, \0nnn : 8진수 아스키 코드[0,255] == [00, 0377]<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java" displayRange="[40,40]" lan="java">View Code »</button></li><li>\xhh : 16진수 아스키 코드[0,255]<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java" displayRange="[41,41]" lan="java">View Code »</button></li><li>\uhhhh, \u{h...h} : 16진수 유니코드[Character.MIN_CODE_POINT, Character.MAX_CODE_POINT]<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java" displayRange="[42,42]" lan="java">View Code »</button></li><li>\N{name} : 유니코드 이름<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java" displayRange="[43,43]" lan="java">View Code »</button></li><li>\t(tab \u0009), \n(newline \u000A), \r(carriage-return \u000D), \f(form-feed \u000C), \a(alert \u0007), \e(escape \u001B), \cx(x에 관한 제어 문자)</li></ul><h3 class="marker">Character class</h3><ul><li>[abc] : 단순 집합<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java" displayRange="[44,44]" lan="java">View Code »</button></li><li>[^abc] : 여집합<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java" displayRange="[45,45]" lan="java">View Code »</button></li><li>[a-z] : 유니코드 Range(inclusive)<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java" displayRange="[46,46]" lan="java">View Code »</button></li><li>[a-d[m-p]] == [a-dm-p] : 합집합<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java" displayRange="[47,47]" lan="java">View Code »</button></li><li>[a-z&&[def]] : 교집합<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java" displayRange="[48,48]" lan="java">View Code »</button></li><li>[a-z&&[^bc]] : 차집합(A and not(B) == A - B)<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java" displayRange="[49,49]" lan="java">View Code »</button></li></ul><h3 class="marker">Predefined character classe</h3><ul><li>. : 임의 문자. DOTALL 플래그가 있으면 line terminator도 매칭</li><li>\d : [0-9], \D : [^\d]</li><li>\s : 공백 문자 [ \t\n\x0B\f\r], \S : [^\s]</li><li>\h : 수평 공백 [ \t\xA0\u1680\u180e\u2000-\u200a\u202f\u205f\u3000], \H : [^\h]</li><li>\v : 수직 공백 [\n\x0B\f\r\x85\u2028\u2029], \V : [^\v]</li><li>\w : Word character, \W : [^w]</li></ul><h3 class="marker">java.lang.Character class</h3><ul><li>\p{javaLowerCase} : Character.isLowerCase()</li><li>\p{javaUpperCase} : Character.isUpperCase()</li><li>\p{javaWhitespace} : Character.isWhitespace()</li><li>\p{javaMirrored} : Character.isMirrored()</li></ul><h3 class="marker">Unicode class</h3><ul><li>\R : 임의 줄바꿈 문자열 \u000D\u000A|[\u000A\u000B\u000C\u000D\u0085\u2028\u2029]</li><li>\X : Any Unicode extended grapheme cluster</li><li>\b{g} : A Unicode extended grapheme cluster boundary</li><li>\P{expr} == [^\p{expr}]</li>\p{IsLatin} : Latin<strong>script</strong>, \p{InGreek} : Greek<strong>block</strong>, \p{Lu} : Uppercase letter(<strong>category</strong>), \p{IsAlphabetic} :<strong>binary property</strong>, \p{Sc} : Currency symbol</ul><h3 class="marker">Boundary matcher</h3><ul><li>^ : 줄 시작, $ : 줄 끝</li><li>\b : 단어 경계, \B : 비단어 경계</li><li>\A : The beginning of the input</li><li>\G : The end of the previous match</li><li>\z » The end of the input</li></ul><h3 class="marker">Greedy quantifier</h3><ul><p>처음에 매치할 수 있는 만큼 최대한 매치. 그 다음 요소의 매칭이 없으면 백트래킹.<a class="w3-btn w3-round w3-round-xxlarge w3-small w3-green" href="https://stackoverflow.com/questions/5319840/greedy-vs-reluctant-vs-possessive-quantifiers" target="_blank">참고자료</a></p><li>X? : X, once or not at all</li><li>X* : X, zero or more times</li><li>X+ : X, one or more times</li><li>X{n} : X, exactly n times</li><li>X{n,} : X, at least n times</li><li>X{n,m} : X, at least n but not more than m times</li></ul><h3 class="marker">Reluctant quantifier</h3><p>처음에 최소한만 매치. 그 다음 요소의 매칭이 없으면 백트래킹.
X??, X*?, X+?, X{n}?, X{n,}?, X{n,m}?</p><h3 class="marker">Possessive quantifier</h3><p>Greedy quantifier와 같지만, 백트래킹은 없다.
X?+, X*+, X++, X{n}+, X{n,}+, X{n,m}+</p><h3 class="marker">Logical operation</h3><ul><li>XY : X followed by Y</li><li>X|Y : Either X or Y</li><li>(X) : X, as a capturing group</li></ul><h3 class="marker">Backreference</h3><ul><li>\n : The n-th capturing group matched</li><li>\k&lt;name> : Tthe named-capturing group "name" matched</li><p>↑ 정규표현식 내에서는 위 두 가지 backreference가 가능하며, replace()에서는 $0, $1, $2, ...로 표기한다<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java" displayRange="[51,57,59,71,73,85]" lan="java">View Code »</button></p></ul><h3 class="marker">Quotation</h3><ul><li>\ : Nothing, but quotes the following character</li><li>\Q : Nothing, but quotes all characters until \E</li><li>\E : Nothing, but ends quoting started by \Q</li></ul><h3 class="marker">Special construct</h3><ul><li>(?&lt;name>X) : X, as a named-capturing group<button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java" displayRange="[59,71]" lan="java">View Code »</button></li><li>(?:X) : X, as a non-capturing group</li><li>(?idmsuxU-idmsuxU) : 각 플래그를 켜거나 끈다</li><li>(?idmsux-idmsux:X) : 주어진 플래그로 non-capturing group X를 매칭한다</li><li>(?=X) : Positive lookahead, (?!X) : Negative lookahead</li><button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java" displayRange="[51,57]" lan="java">View Code »</button><button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java" displayRange="[87,102]" lan="java">금칙어 판별</button><li>(?&lt;=X) : Positive lookbehind, (?&lt;!X) : Negative lookbehind</li><li>(?>X) : Non-capturing group + Possessive</li></ul></div><h2 class="marker">final class Matcher implements MatchResult</h2><p>Pattern으로부터 만들어지는 매칭 엔진으로, 아래 세 가지 작업을 수행한다.</p><ol><li>matches() : 전체 입력에 대해 패턴 매칭</li><li>lookingAt() : 입력 시작부분 패턴 매칭</li><li>find() : 입력의 다음 부분 패턴 매칭</li></ol><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">MatchResult toMatchResult()
Stream&lt;MatchResult> results() // Since 9

Matcher usePattern(Pattern newPattern)
Matcher reset()

int start(String name) // 주어진 식별자에 해당하는 그룹의 시작 인덱스 반환
int end(String name)
String group(String name)

static String quoteReplacement(String s)
    // appendReplacement 메서드의 replacement로 사용될 s의 리터럴 표기를 반환.
Matcher appendReplacement(StringBuffer sb, String replacement)
    // 1. 입력 소스의 append position부터 start() 전까지 sb에 추가.
    // 2. replacement를 sb에 추가.
    // 3. 현재 matcher의 append position을 end()로 설정.
StringBuffer appendTail(StringBuffer sb)
    // 입력 소스의 append position부터를 sb에 추가.
    // appendReplacement 메서드를 호출한 뒤에 이를 호출하여 남머지 부분을 복사할 목적으로 만들어짐.

String replaceAll(String replacement)
    // 입력 소스의 모든 매칭되는 부분을 replacement로 변경.
String replaceAll(Function&lt;MatchResult, String> replacer) // Since 9
String replaceFirst(String replacement)

Matcher region(int start, int end)
    // 입력 소스의 특정 구간을 매칭 대상으로 하도록 초기화한다. transparency, anchoring 속성에 따라 동작이 다르다.
Matcher useTransparentBounds(boolean b)
    // region의 경계 너머를 패턴 매칭에 보이도록 할지 여부
Matcher useAnchoringBounds(boolean b)
    // region의 경계에서 ^, $를 작동하게 할지 여부

</div></div><h1 class="marker">java.util.stream</h1><div><h2 class="marker">interface BaseStream&lt;T, S extends BaseStream&lt;T, S>> extends AutoCloseable</h2><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">Iterator&lt;T> iterator()
Spliterator&lt;T> spliterator()
boolean isParallel()
S sequential() // 순차적인 스트림 반환(어쩌면 자기 자신)
S parallel()   // 병렬적인 스트림 반환(어쩌면 자기 자신)
S unordered()  // 순서 없는 스트림 반환(어쩌면 자기 자신)
S onClose(Runnable closeHandler)
</div><h2 class="marker">interface DoubleStream extends BaseStream&lt;Double, DoubleStream></h2><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">double sum()
OptionalDouble min(), max(), average(), findFirst(), findAny()
DoubleSummaryStatistics SummaryStatistics()
Stream&lt;Double> boxed()
</div><h2 class="marker">interface IntStream extends BaseStream&lt;Integer, Integer> + LongStream</h2><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static IntStream range(int startInclusive, int endExclusive)
static IntStream rangeClosed(int startInclusive, int endInclusive)
</div><h2 class="marker">interface Stream&lt;T> extends BaseStream&lt;T, Stream&lt;T>></h2><ol><li>2가지 스트림 연산</li><ul><li>Terminal Operation</li><p>종결 연산. 스트림 연산 파이프라인의 마지막으로, 더 이상 스트림 연산을 수행할 수 없다.</p><li>Intermediate Operation</li><p>중간 연산. 새로운 스트림을 반환한다.</p></ul><li>2가지 중간 연산</li><ul><li>Stateless Operation</li><p>요소의 연산 과정에 상태의 보존이 필요 없는 경우. filter, map 등</p><li>Stateful Operation</li><p>요소의 연산 과정에 상태의 보존이 필요한 경우. sorted, distinct 등.<br>이러한 연산을 사용하기 위해선 스트림 전체 인풋이 필요할 수 있으며, 병렬 스트림에서는 요구되는 버퍼의 크기가 늘어나게 된다.</p></ul><button class="w3-btn w3-round w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/util/FlatMapExample.java" lan="java">View Code »</button></ol><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">// 팩터리 메서드
static &lt;T> Stream.Builder&lt;T> builder()
static &lt;T> Stream&lt;T> empty()
static &lt;T> Stream&lt;T> of(T t)
static &lt;T> Stream&lt;T> ofNullable(T t) // Since 9
@SafeVarargs static &lt;T> Stream&lt;T> of(T... values)
static &lt;T> Stream&lt;T> iterate(T seed, UnaryOperator&lt;T> f)
static &lt;T> Stream&lt;T> iterate(T seed, Predicate&lt;? super T> hasNext, UnaryOperator&lt;T> next) // Since 9
static &lt;T> Stream&lt;T> generate(Supplier&lt;? extends T> s)
static &lt;T> Stream&lt;T> concat(Stream&lt;? extends T> a, Stream&lt;? extends T> b)


// 중간 연산
Stream&lt;T> filter(Predicate&lt;? super T> predicate)
    // predicate이 true인 요소만 남긴다.

&lt;R> Stream&lt;R> map(Function&lt;? super T, ? extends R> mapper)
    // mapper : 하나의 T 변수에서 하나의 R 변수로 대응하는 변환
IntStream mapToInt(ToIntFunction&lt;? super T> mapper)
    // + long, double
&lt;R> Stream&lt;R> flatMap(Function&lt;? super T, ? extends Stream&lt;? extends R>> mapper)
    // mapper : 하나의 T 변수에서 여러 R 변수(R 스트림)로 대응하는 변환.
    // mapper를 이용해 만들어진 여러 R 스트림을 일렬로 펴서(flattening) 하나의 R 스트림으로 변환. mapper가 null을 반환하면 빈 스트림을 대신 이용된다.
    // 최종적으로 반환되는 스트림 외의 모든 중간 스트림은 닫힌다.
IntStream flatMapToInt(Function&lt;? super T, ? extends IntStream> mapper )
    // + long, double

Stream&lt;T> distinct()
    // Object.equals(Object)를 이용해 유일한 것들만으로 구성. stateful 중간 연산.
Stream&lt;T> sorted()
    // 자연스러운 방향으로 정렬. T가 Comparable하지 않으면 예외 발생할 수 있음. stateful 중간 연산.
Stream&lt;T> sorted(Comparator&lt;? super T> comparator)

Stream&lt;T> peek(Consumer&lt;? super T> action)
    // forEach와 유사한 기능을 하는 중간 연산. 다른 중간 연산 전후의 값을 살펴보는 디버깅 용도로 만들어짐.

Stream&lt;T> limit(long maxSize)
    // 스트림의 크기가 maxSize 이하가 되도록 한다. short-circuiting stateful 중간 연산.
Stream&lt;T> skip(long n)
    // n개를 버린 나머지로 스트림을 구성해 반환한다. 더 없으면 빈 스트림이 반환된다.
default Stream&lt;T> takeWhile(Predicate&lt;? super T> predicate)
    // Since 9, 요소들을 하나씩 검사하여, predicate을 만족하지 않는 요소가 나오기 전까지로 구성된 스트림을 반환한다.
    // 순서 있는 스트림에 대하여는 조건을 만족하는 최장 길이 접두 요소들을 얻게 되며, 순서 없는 스트림은 조건을 만족하는 부분 집합을 얻게 된다.
    // short-circuiting stateful 중간 연산.
    // 일반적으로 연산이 저렴하지만, 순서 있는 병렬 스트림에 대하여는 최장 길이 접두 요소들을 찾기 위해 연산이 비싸지므로, 허용된다면 순서 없는 스트림 소스(generate(Supplier))를 이용하거나, BaseStream.unordered()를 이용해 순서를 없애는 것이 성능에 도움이 될 것이다.
default Stream&lt;T> dropWhile(Predicate&lt;? super T> predicate)
    // Since 9, stateful 중간 연산.


// 종결 연산
void forEach(Consumer&lt;? super T> action)
void forEachOrdered(Consumer&lt;? super T> action
    // 순서 있는 스트림의 경우, 이를 이용하면 요소의 순서대로 소비자가 실행된다.

Object[] toArray()
&lt;A> A[] toArray(IntFunction&lt;A[]> generator)
    // generator : 배열 크기를 먹고 배열을 뱉는 함수. 예: A[]::new.

T reduce(T identity, BinaryOperator&lt;T> accumulator)
    // 하나의 T 변수로 축약하는 종결 연산. 아래와 동치다.
{
    var result = identity;
    for(T element : stream)
        result = accumulator.apply(result, element);
    return result;
}
Optional&lt;T> reduce(BinaryOperator&lt;T> accumulator
    // 하나의 T로 축약하는 종결 연산. 처음 연산 결과는 null이며, 스트림 첫 번째 요소를 만나면 치환된다. 이후는 reduce(T, BinaryOperator)와 같다.
&lt;U> U reduce(U identity, BiFunction&lt;U, ? super T, U> accumulator, BinaryOperator&lt;U> combiner)
    // 하나의 U 변수로 축약하는 종결 연산. 연산은 reduce(T, BinaryOperator)와 동일한데, identity 값은 combiner 연산에 대한 항등원이어야 한다.
    // 다시 말해, 임의의 U 타입 변수 u에 대하여 u == combiner(identity, u)를 만족해야 한다.
    // 이는 연산 과정에서 다음의 검사를 통해 검증된다. combiner.apply(u, accumulator.apply(identity, t)) == accumulator.apply(u, t)
    // 이렇게 복잡하게 하는 것보다는 map과 reduce를 쪼개 이용하는 것이 훨씬 간결하므로 유념.

&lt;R> R collect(Supplier&lt;R> supplier, BiConsumer&lt;R, ? super T> accumulator, BiConsumer&lt;R, R> combiner)
    // 하나의 R 변수로 축약하는 종결 연산. reduce와 다르게 R 자체가 결과값에 대한 가변적인 컨테이너(ArrayList, String 등)가 되어야 한다. 아래와 동치다.
    // 여기서는 combiner를 사용하지 않는 것처럼 보이지만, combiner는 병렬 스트림 연산을 위해 존재하는 것이므로, 연산 결과 자체는 아래와 동치가 맞다.
{
    var result = supplier.get();
    for(T element : stream)
        accumulator.accept(result, element);
    return result;
}
    // 메서드 참조 예.
{
    collect(ArrayList::new, ArrayList::add, ArrayList::addAll);
    collect(StringBuilder::new, StringBuilder::append, StringBuilder::append);
}
&lt;R, A> collect(Collector&lt;? super T, A, R> collector)
    // collect(Supplier, BiConsumer, BiConsumer)의 매개변수를 캡슐화한 Collector를 이용.
    // Collectors 유틸리티 클래스에 이미 정의된 Collector들이 있으니 편하게 이용 가능.

Optional&lt;T> min(Comparator&lt;? super T> comparator) // + max
long count()
    // 개수를 반환하는 종결 연산.
boolean anyMatch(Predicate&lt;? super T> predicate)
    // short-circuiting 종결 연산.
    // + allMatch, noneMatch
Optional&lt;T> findFirst()
    // short-circuiting 종결 연산.
    // + findAny</div><div><h3 class="marker">static interface Stream.Builder&lt;T></h3><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">void accept(T t)
default Stream.Builder&lt;T> add(T t)
Stream&lt;T> build()
</div></div><h2 class="marker">final class StreamSupport</h2><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static &lt;T> Stream&lt;T> stream(Spliterator&lt;T> spliterator, boolean parallel)
static &lt;T> Stream&lt;T> stream(Supplier&lt;? extends Spliterator&lt;T>> supplier, int characteristics, boolean parallel)
    // characteristics = supplier.get().characteristics()
static IntStream intStream(Spliterator.OfInt spliterator, boolean parallel)
    // + long, double
static IntStream intStream(Supplier&lt;? extends Spliterator.OfInt> supplier, int characteristics, boolean parallel)
    // characteristics = supplier.get().characteristics()
</div><h2 class="marker">interface Collector&lt;T, A, R></h2><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static enum Collector.Characteristics {
    CONCURRENT, IDENTITY_FINISH, UNORDERED;
}

Supplier&lt;A> supplier()
    // 결과 컨테이너인 A를 생성하는 함수 반환.
BiConsumer&lt;A, T> accumulator()
    // A의 결과에 T 타입 데이터를 축적하는 함수
BinaryOperator&lt;A> combiner()
    // 두 결과 컨테이너를 받아 하나로 반환하는 함수
Function&lt;A, R> finisher()
    // 결과 컨테이너로부터 최종 결과 R으로 변환하는 함수 반환
Set&lt;Collector.Characteristics> characteristics()

static &lt;T, A, R> Collector&lt;T, A, R> of(Supplier&lt;A> supplier, BiConsumer&lt;A, T> accumulator, BinaryOperator&lt;A> combiner, Function&lt;A, R> finisher, Collector.Characteristics... characteristics)
</div><h2 class="marker">final class Collectors</h2><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static &lt;T, C extends Collection&lt;T>> Collector&lt;T, ?, C> toCollection(Supplier&lt;C> collectionFactory)
    // collectionFactory로 생성한 Collection 객체에 원소들을 만나는 순서대로 집어넣는 Collector 반환.
static &lt;T> Collector&lt;T, ?, List&lt;T>> toList()
    // 새로운 List 객체에 입력 원소들을 모두 담아 반환하는 Collector. 반환된 List의 타입, 변경 가능 여부, 직렬화, 스레드-안전 그 무엇도 보장하지 않음.
static &lt;T> Collector&lt;T, ?, List&lt;T>> toUnmodifiableList() // Since 10
static &lt;T> Collector&lt;T, ? Set&lt;T>> toSet()
    // 새로운 Set 객체에 입력 원소들을 모두 담아 반환하는 Collector. 반환된 Set의 타입, 변경 가능 여부, 직렬화, 스레드-안전 그 무엇도 보장하지 않음.
static &lt;T> Collector&lt;T, ?, Set&lt;T>> toUnmodifiableSet() // Since 10

static Collector&lt;CharSequence, ?, String> joining()
    // String에 만나는 순서대로 덧붙이는 Collector.

static &lt;T, U, A, R> Collector&lt;T, ?, R> mapping(Function&lt;? super T, ? extends U> mapper, Collector&lt;? super U, A, R> downstream)
    // U 타입 원소에 대한 Collector에 T 타입 원소를 mapper를 통해 U 타입으로 변환하여 받아들이는 Collector.
static &lt;T, U, A, R> Collector&lt;T, ?, R> flatMapping(Function&lt;? super T, ? extends Stream&lt;? extends U>> mapper, Collector&lt;? super U, A, R> downstream) // Since 9
    // Flat mapper는 입력 요소를 0개 이상의 요소를 담은 stream으로 만들어내며, downstream에 투입되면 해당 stream은 닫힌다.(null인 경우 빈 스트림을 대신 이용한다)

static &lt;T, A, R> Collector&lt;T, ?, R> filtering(Predicate&lt;? super T> predicate, Collector&lt;? super T, A, R> downstream) Since 9
    // 동일한 입력 타입 T 원소를 받아 predicate을 만족하면 downstream에 투입하는 Collector.

static &lt;T, A, R, RR> Collector&lt;T, A, RR> collectingAndThen(Collector&lt;T, A, R> downstream, Function&lt;R, RR> finisher)

static &lt;T> Collector&lt;T, ?, Long> counting()
static &lt;T> Collector&lt;T, ?, Optional&lt;T>> minBy(Comparator&lt;? super T> comparator)
static &lt;T> Collector&lt;T, ?, Optional&lt;T>> maxBy(Comparator&lt;? super T> comparator)
static &lt;T> Collector&lt;T, ?, Integer> summingInt(ToIntFunction&lt;? super T> mapper) // + Long, Double
static &lt;T> Collector&lt;T, ?, Double> averagingInt(ToIntFunction&lt;? super T> mapper) // + Long, Double
static &lt;T> Collector&lt;T, ?, IntSummaryStatistics> summarizingInt(ToIntFunction&lt;? super T> mapper) // + Long, Double
static &lt;T> Collector&lt;T, ? T> reducing(T identity, BinaryOperator&lt;T> op)
    // reducing 설명은 DoubleStream 참고

static &lt;T, K> Collector&lt;T, ?, Map&lt;K, List&lt;T>>> groupingBy(Function&lt;? super T, ? extends K> classifier)
static &lt;T, K> Collector&lt;T, ?, ConcurrentMap&lt;K, List&lt;T>>> groupingByConcurrent(Function&lt;? super T, ? extends K> classifier)
static &lt;T> Collector&lt;T, ?, Map&lt;Boolean, List&lt;T>>> partitioningBy(Predicate&lt;? super T> predicate)
static &lt;T, K, U> Collector&lt;T, ?, Map&lt;K, U>> toMap(Function&lt;? super T, ? extends K> keyMapper, Function&lt;? super T, ? extends U> valueMapper)
static &lt;T, K, U> Collector&lt;T, ?, Map&lt;K, U>> toUnmodifiableMap(Function&lt;? super T, ? extends K> keyMapper, Function&lt;? super T, ? extends U> valueMapper) // Since 10
static &lt;T, K, U> Collector&lt;T, ?, ConcurrentMap&lt;K, U>> toConcurrentMap(Function&lt;? super T, ? extends K> keyMapper, Function&lt;? super T, ? extends U> valueMapper)

</div></div><h1 class="marker">java.util.zip</h1><div><h2 class="marker">interface Checksum</h2><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">void update(int b)
default void update(byte[] b) // Since 9
void update(byte[] b, int off, int len)
default void update(ByteBuffer buffer) // Since 9
long getValue()
void reset()</div><ol><p>구현 클래스</p><li>class Adler32 implements Checksum</li><li>class CRC32 implements Checksum</li><li>class CRC32C implements Checksum Since 9</li></ol><h2 class="marker">class ZipInputStream extends InflaterInputStream</h2><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">public ZipInputStream(InputStream in, Charset charset)

ZipEntry getNextEntry()
void closeEntry()
    // 현재 ZipEntry를 닫고 읽기 위치를 다음 entry로 이동.
int available()
    // EOF를 만났으면 0, 아니면 1
</div><h2 class="marker">class ZipOutputStream extends DeflaterOutputStream</h2><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">public ZipOutputStream(OutputStream out, Charset charset)

void setComment(String comment)
void setMethod(int method)
    // ZipEntry에 설정되지 않은 경우 사용하는 압축 방법 : DEFLATED(압축, 기본값), STORED(비압축)
void setLevel(int level)
    // 압축 레벨 : 0(BEST_SPEED) ~ 9(BEST_COMPRESSION). 기본은 DEFAULT_COMPRESSION(-1)이며, 보통 6.
void putNextEntry(ZipEntry e)
void closeEntry()
    // 현재 ZipEntry를 닫고 다음 쓰기 위치로 이동. putNextEntry 메서드는 쓰기 전에 알아서 닫는다.
void finish()
    // 쓰기를 종료하고 스트림을 닫는다. 동일한 출력 스트림에 여러 필터를 적용한 경우에 사용.
</div><h2 class="marker">class ZipEntry implements Cloneable</h2><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">public ZipEntry(String name)
public ZipEntry(ZipEntry e) // e로 필드를 채운다.

String getName()
ZipEntry setLastModifiedTime(FileTime time)
ZipEntry setLastAccessTime(FileTime time)
ZipEntry setCreationTime(FileTime time)
void setSize(long size) // 비압축 크기 설정
void setCompressedSize(long csize)
void setCrc(long crc)
void setMethod(int method)
    // DEFLATED(압축), STORED(비압축), -1(미설정)
void setExtra(byte[] extra)
void setComment(String comment)
boolean isDirectory()
    // 이름이 "/"로 끝나면 디렉터리.
Object clone()
</div><h2 class="marker">class ZipFile implements Closeable</h2><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">public ZipFile(File file, int mode)
    // UTF-8
    // mode : OPEN_READ | OPEN_DELETE(파일이 close 호출 전까지 삭제됨, 내용은 객체를 통해 계속 접근 가능)
public ZipFile(File file, int mode, Charset charset)

ZipEntry getEntry(String name)
InputStream getInputStream(ZipEntry entry)
    // ZipFile이 닫히면 이 메서드가 반환한 모든 스트림도 같이 닫힌다.
Enumeration&lt;? extends ZipEntry> entries()
Stream&lt;? extends ZipEntry> stream()
int size() // entry 개수

</div></div><h1 class="marker">javax.crypto</h1>EMPTY<h1 class="marker">javax.net</h1><div><h2 class="marker">abstract class SocketFactory</h2><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static SocketFactory getDefault()
Socker createSocket(String host, int port)
</div><h2 class="marker">abstract class ServerSocketFactory</h2><strong>↓ java</strong><div lan="java" class="as-code code-div w3-leftbar w3-border-green">static ServerSocketFactory getDefault()
ServerSocker createServerSocket(int port)

</div></div><h1 class="marker">javax.net.ssl</h1>EMPTY</div><hr>&copy; 2020. <a href="mailto:hi.donggi@gmail.com">Donggi Kim</a> all rights reserved.<a class="w3-btn w3-round w3-round-xxlarge w3-small w3-green" href="/LICENSE" target="_blank">LICENSE</a></div></body></html>