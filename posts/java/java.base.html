<html lang="ko"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="google-site-verification" content="aH-DyzdytYQ0NPHNQFcs5dVoiu5YNs6CEEHYgqDmAFM"><meta name="author" content="Donggi Kim &lt;hi.donggi@gmail.com&gt;"><meta name="keywords" content="Java, java.base, JDK16"><meta name="description" content="JDK16 java.base 모듈 정리"><title>java.base 모듈 16</title><link id="w3css" rel="stylesheet" href="/source/w3.css"><link id="highlight-style" rel="stylesheet" href="/source/xcode.css"><link id="default-style" rel="stylesheet" href="/source/default.css"><script id="highlight-js" src="/source/highlight.pack.js"></script><script id="default-js" src="/source/default.min.js"></script><script id="dsq-count-scr" src="//donggi.disqus.com/count.js" async></script><script id="kakao-ads" src="//t1.daumcdn.net/kas/static/ba.min.js" async></script><script id="google-ads" data-ad-client="ca-pub-7897366614471210" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><script id="google-analytics" src="https://www.googletagmanager.com/gtag/js?id=UA-143098403-1" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-143098403-1');</script></head><body><div class="w3-bar-block w3-sidebar w3-animate-left" id="sidebar"><hr><a class="w3-bar-item w3-button" href="javascript:closeSidebar();">Close &times;</a><hr><div id="marker-list"></div><hr><div id="post-list"></div><hr><div class="w3-center"><ins class="kakao_ad_area" style="display:none;" data-ad-unit="DAN-1k1r635zxb6g3" data-ad-width="300" data-ad-height="250"></ins></div><hr><div id="file-list"></div><hr></div><div id="main"><div class="w3-bar w3-blue w3-large" id="nav" style="position:-webkit-sticky;position:sticky;top:0px;vertical-align:middle"><button class="w3-bar-item w3-button w3-hover-theme" onclick="toggleSidebar()">&#9776;</button><input class="w3-bar-item" id="query" type="text" placeholder="search" style="max-width:35%"><a class="w3-bar-item w3-button w3-hover-theme" href="/">Home</a></div><div class="w3-padding" id="contents"><h1>java.io</h1><div><h2>IO 종단점</h2><div><h3>Closeable</h3><ol><li>데이터의 출발지나 목적지를 닫을 수 있으면 Closeable</li><li>void close()</li><p>스트림 및 이와 관련된 시스템 자원을 해제한다. 이미 호출되었다면 아무 일도 하지 않는다<br>close() 실패했을 때, 예외를 던지는 대신 사용하던 자원을 모두 포기하고 Closeable 객체 내부적으로 '닫혔다(closed)'고 마크하길 권장한다</p></ol><h3>Flushable</h3><ol><li>flush 가능한 데이터 목적지는 Flushable</li><li>void flush()</li><p>버퍼에 저장된 데이터를 스트림에 모두 써 보낸다</p></ol></div><h2>바이트 단위 IO</h2><div><h3>DataInput</h3><ol><li>binary stream으로부터 바이트들을 읽고, 또 이를 자바 기본 타입 또는 String으로 만들어 반환하는 기능 정의</li><li>읽기는 1바이트 단위로 이루어진다</li><li class="marker">Modified UTF-8</li><p>DataInput과 DataOutput 인터페이스는 수정된 UTF-8을 이용한다</p><ul><li>'\u0001' ~ '\u007F'는 1바이트(0???????)로 표현한다</li><li>null('\u0000'), '\u0080' ~ '\u07FF'는 2바이트(110????? 10??????)로 표현한다</li><li>'\u0800' ~ '\uFFFF'는 3바이트(1110??? 10?????? 10??????)로 표현한다</li></ul></ol><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">String readLine()
    // 줄의 끝이나 파일 끝을 만나기까지의 문자열을 반환한다
    // 각 바이트들을 0 패딩하여 char로 변환하므로, 유니코드를 읽기는 부적합하다
    // 아무것도 읽지 못한 경우, 빈 문자열이 아닌 null이 반환된다

String readUTF()
    // 먼저 readUnsignedShort()와 같은 방법으로 2개 바이트를 읽어와 길이를 구한다
    // 구한 길이만큼의 바이트를 읽으면서 상기한 Modified UTF-8에 맞춰 String을 만든다
    // 길이만큼의 바이트를 다 읽기 전에 EOF를 만나면 예외를 던진다
</div><h3>DataOutput</h3><p>DataInput과 대칭</p><h3>InputStream</h3><ol><li>바이트 단위 읽기에 대한 최상위 추상 클래스</li><li>작업이 끝날 때까지 스레드가 블록되며, 스트림이 비동기적으로 닫히거나, 인터럽트가 발생하는 경우에 대해 대처하지 않는다</li></ol><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static InputStream nullInputStream()
    // 아무것도 읽지 않는 InputStream
    // 반환된 스트림은 처음부터 열려 있고, 마치 스트림의 끝에 도달한 것처럼 작동한다

long transferTo(OutputStream out)
    // 입력 스트림의 모든 바이트를 읽어들여 out에 쓴다
    // 총 전송 바이트 수를 반환하며, 스트림을 닫는 작업은 하지 않는다

byte[] readAllBytes()
byte[] readNBytes(int len)

long skip(long n)
    // 실제로 건너뛴 바이트 수를 반환. 음수 매개변수에 대해 0을 반환한다. 서브클래스들의 구현은 이와 다를 수 있다
int available()
    // 막힘 없이 한 번에 읽어올 수 있는 바이트 수 예상값을 반환
    // 구현에 따라 전체 바이트 수를 반환하기도, 그렇지 않기도 하다. InputStream 자체는 항상 0을 반환하며, 서브클래스에서 재정의해야 한다

boolean markSupported()    // mark, reset 메서드를 지원하는지 여부 반환. 기본 false
void mark(int readlimit)   // 현재 위치 마킹
void reset()               // 마지막 마킹 위치로 이동
</div><h3>OutputStream</h3><p>바이트 단위 쓰기에 대한 최상위 추상 클래스</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static OutputStream nullOutputStream()
    // 실제로 데이터를 쓰지는 않는 OutputStream 객체를 반환한다
</div><h3>ByteArrayInputStream</h3><p>내부 버퍼 byte[] buf에 대한 읽기 연산을 지원하는 InputStream</p><h3>ByteArrayOutputStream</h3><p>내부 버퍼 byte[] buf에 대해 쓰기 연산을 지원하는 OutputStream. 버퍼 크기는 자동으로 확장된다</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">void writeTo(OutputStream out)  // 버퍼를 out에 모두 쓴다. == out.write(buf, 0, count)
byte[] toByteArray()            // 사본 반환
void reset()                    // 버퍼 처음부터 재활용
String toString​(Charset charset)
</div><h3>PipedInputStream</h3><p>PipedOutputStream를 소스로 하는 InputStream. PipedOutputStream과 별개 스레드에서 동작해야 한다 <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/io/PipedStreamExample.java" lan="java">PipedStreamExample.java</button></p><h3>PipedOutputStream</h3><p>PipedInputStream에 쓰는 OutputStream. PipedInputStream과 별개 스레드에서 동작해야 한다 <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/io/PipedStreamExample.java" lan="java">PipedStreamExample.java</button></p><h3>SequenceInputStream</h3><p>여러 InputStream을 이어붙인듯이 활용하는 InputStream</p><h3>FileInputStream</h3><p>파일을 읽는 InputStream <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/io/SerializableExample.java" lan="java">SerializableExample.java</button></p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">FileChannel getChannel()
    // 유니크한 FileChannel을 반환하며, 채널에서의 위치는 스트림에서 읽어들인 만큼과 같다
</div><h3>FileOutputStream</h3><p>파일에 쓰는 OutputStream <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/io/SerializableExample.java" lan="java">SerializableExample.java</button></p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">FileChannel getChannel()
    // 유니크한 FileChannel을 반환하며, 채널에서의 위치는 스트림에서 쓴 바이트 수와 같다(append 모드가 아닐 경우)
    // append 모드에서는 파일의 크기와 채널의 위치가 동일하다
</div><h3>InputStream 장식자</h3><div><h4>FilterInputStream</h4><p>아무 기능 추가 없는 장식자</p><h4>BufferedInputStream</h4><p>버퍼를 이용해 mark(), reset() 지원</p><h4>DataInputStream</h4><p>DataInput을 구현 제공</p><span id="pos-1147391479" style="padding:0!important;margin:0!important;width:0!important;height:0!important;overflow:hidden!important"></span><h4>PushbackInputStream</h4><ul><li>이미 읽은 것을 취소하고 다시 읽을 수 있는 기능을 지원한다</li><li>이전에 읽은 내용을 저장하지는 않으므로, 덮어쓰기처럼 이용할 수 있다 <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/io/PushBackExample.java" lan="java">PushBackExample.java</button></li></ul></div><h3>OutputStream 장식자</h3><div><h4>FilterOutputStream</h4><p>아무 기능 추가 없는 장식자</p><h4>BufferedOutputStream</h4><p>버퍼를 이용해 쓰기 작업이 빈번하게 일어나지 않게 해준다</p><h4>DataOutputStream</h4><p>DataOutput 구현 제공</p><span id="pos1334583405" style="padding:0!important;margin:0!important;width:0!important;height:0!important;overflow:hidden!important"></span><h4>PrintStream</h4><ul><li>OutputStream, File에 기본 타입 및 각종 문자열을 쓰는 기능 제공</li><li>autoFlush : 바이트 배열을 다 쓰거나, 새 줄 문자, '\n'을 쓰면 자동으로 flush()</li></ul><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">boolean checkError()
    // flush()한 다음 오류 상태를 검사한다. 예외를 던지지 않으므로 이 메서드로 확인해야 한다
    // 스트림에 InterruptedIOException이 발생하면 Thread.currentThread().interrupt()를 실행한다
</div></div></div><h2>객체 IO(직렬화/역직렬화)</h2><div><h3>Serializable</h3><ol><li>직렬화와 역질렬화를 지원하는 마커 인터페이스. ObjectInputStream, ObjectOutputStream의 메서드들을 이용해 알아서 저장/복구한다<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/io/SerializableExample.java" lan="java">SerializableExample.java</button></li><li>직렬화하지 않을 멤버는 transient 키워드로 표시한다</li><li>직접 구현하고 싶다면 Externalizable 인터페이스를 구현하거나, 다음의 메서드들을 작성한다</li><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">@Serial private void writeObject(java.io.ObjectOutputStream out) // out에 알아서 객체 표현 바이트들을 쓰면 된다
@Serial private void readObject(java.io.ObjectInputStream in)    // in에서 바이트들을 읽어와 알아서 객체를 생성하면 된다
@Serial private void readObjectNoData()                          // 객체들의 버전이 다르거나, 기타 이유로 객체를 초기화할 필요가 있는 경우 사용</div><li>대체 객체를 이용해 저장 : @Serial ANY-ACCESS-MODIFIER Object writeReplace()</li><li>대체 객체를 이용해 복구 : @Serial ANY-ACCESS-MODIFIER Object readResolve()</li><li>클래스 버전</li><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">// 정의되지 않은 경우 기본값을 사용하지만, 명시할 것을 권장하고 있다
ANY-ACCESS-MODIFIER static final long serialVersionUID = (version number)L;
</div></ol><h3>Externalizable</h3><ul><li>객체 직렬화/역직렬화를 직접 구현하고자 할 때 이를 구현한다</li><li>객체 직렬화는 빈 객체를 만든 뒤 각 속성의 값을 쓰므로 기본 생성자가 필요하다<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/io/ExternalizableExample.java" lan="java">ExternalizableExample.java</button></li></ul><h3>ObjectInputStream</h3><p>역직렬화 관련 InputStream <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/io/SerializableExample.java" lan="java">SerializableExample.java</button></p><h3>ObjectOutputStream</h3><p>직렬화 관련 OutputStream <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/io/SerializableExample.java" lan="java">SerializableExample.java</button></p></div><h2>문자 단위 IO 관련</h2><div><h3>Console</h3><ol><li>JVM이 컨트롤할 수 있는 문자 기반 콘솔에 대한 접근 제공. 콘솔 존재 여부는 하위 플랫폼에 의존적이며, 싱글톤으로 System.console()을 통해 얻을 수 있다. 만일 가용한 콘솔이 없다면 null이 반환된다. <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/io/ConsoleExample.java" lan="java">ConsoleExample.java</button></li><li>콘솔에 대한 읽기/쓰기 작업은 모두 원자적으로 이루어지며, 따라서 다른 스레드가 대기할 가능성이 있다</li><li>콘솔에 대한 close()는 아무런 영향이 없다</li><li>유닉스의 Ctrl+D, 윈도우의 Ctrl+Z와 같은 종료 문자를 만나면 읽기 메서드는 null을 반환한다</li><li>보안 유의 : 패스워드와 같은 중요한 데이터를 읽을 때, readPassword(...) 메서드를 이용하고, 반환된 char[]는 사용 후 수동으로 0 초기화</li></ol><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">PrintWriter writer() // 유니크한 PrintWriter 객체 반환
Reader reader()      // 유니크한 Reader 객체 반환
</div><h3>Reader</h3><p>char 단위 읽기에 대한 최상위 추상 클래스</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static Reader nullReader()
    // 아무 것도 읽지 않는 Reader 객체를 반환한다

int read()
    // char 하나를 읽고 int로 반환. 스트림의 끝이라면 -1을 반환한다
boolean ready()
    // 다음 read()가 블록되지 않음을 보장하면 true, 보장하지 못하면 false

// 마킹 관련
boolean markSupported()         // mark, reset 메서드를 지원하는지 여부 반환. 기본 false
void mark(int readAheadLimit)   // 현재 위치 마킹
void reset()                    // 마지막 마킹 위치로 이동

long transterTo(Writer out)
    // 모든 글자를 읽어 out에 쓴다. 전송한 글자 수를 반환한다</div><h3>Writer</h3><ol><li>char 단위 쓰기에 대한 취상위 추상 클래스</li><li>Appendable하므로 편리함이 크다</li></ol><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static Writer nullWriter()
    // 아무것도 쓰지 않는 Writer 객체를 반환한다

void write(int c)
    // 하위 16비트만 쓴고 나머지는 무시한다
</div><h3>InputStreamReader</h3><p>InputStream에 대해 Reader 작업을 지원해주는 bridge 클래스 <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/io/BufferedReaderExample.java" lan="java">BufferedReaderExample.java</button></p><h3>OutputStreamWriter</h3><p>OutputStream에 Writer 작업을 지원해주는 bridge 클래스</p><h3>CharArrayReader</h3><p>내부 버퍼 char[] buf에 대한 읽기 연산을 지원하는 Reader</p><h3>CharArrayWriter</h3><p>내부 버퍼 char[] buf에 대해 쓰기 연산을 지원하는 Writer. 버퍼 크기는 자동으로 확장된다</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">void writeTo(Writer out)    // out에 버퍼의 모든 내용을 쓴다
void reset()                // 버퍼를 처음부터 재활용
char[] toCharArray()        // 사본 반환
</div><h3>StringReader</h3><p>String을 읽는 Reader</p><h3>StringWriter</h3><p>StringBuffer에 쓰는 Writer</p><h3>PipedReader</h3><p>PipedWriter를 소스로 하는 Reader <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/io/PipedReaderExample.java" lan="java">PipedReaderExample.java</button></p><h3>PipedWriter</h3><p>PipedReader로 쓰는 Writer <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/io/PipedReaderExample.java" lan="java">PipedReaderExample.java</button></p><h3>FileReader</h3><p>파일을 읽는 Reader</p><h3>FileWriter</h3><p>파일에 쓰는 Writer</p><h3>Reader 장식자</h3><div><h4>FilterReader</h4><p>아무 기능 추가 없는 장식자</p><h4>BufferedReader</h4><p>버퍼를 이용해 mark(), reset()를 지원하고, 기저 Reader에 대한 읽기 작업이 빈번하게 일어나지 않게 해준다 <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/io/BufferedReaderExample.java" lan="java">BufferedReaderExample.java</button></p></div><h3>Writer 장식자</h3><div><h4>FilterWriter</h4><p>아무 기능 추가 없는 장식자</p><h4>BufferedWriter</h4><p>버퍼를 이용해 기저 Writer에 대한 쓰기 작업이 빈번하게 일어나지 않도록 한다</p><h4>LineNumberReader</h4><p>줄 끝을 만날때마다 카운트</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">void setLineNumber(int lineNumber) // 읽고 있는 위치가 이동하는 건 아니다
int getLineNumber()
</div><h4>PushbackReader</h4><p><a class="w3-btn w3-round-xxlarge w3-small w3-green goto" href="#pos-1147391479" target="_self">Goto - PushbackInputStream</a>과 비슷 <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/io/PushBackExample.java" lan="java">PushBackExample.java</button></p><h4>PrintWriter</h4><ul><li><a class="w3-btn w3-round-xxlarge w3-small w3-green goto" href="#pos1334583405" target="_self">Goto - PrintStream</a>의 Writer 버전</li><li>다른 OutputStream, Writer, 파일에 기본 타입 및 각종 문자열을 쓰는 기능을 제공</li><li>PrintStream과 마찬가지로 checkError()로 실패를 확인해야 한다</li></ul></div></div><h2>파일 관련</h2><div><h3>File</h3><ol><li>추상화된 파일 및 디렉터리 경로에 대한 추상화된 표현 제공; 물리적 저장 장치 » 경로 문자열 » File 객체</li><li>경로 문자열은 절대 경로, 상대 경로 둘 다 허용된다. 상대 경로의 기준 위치는 System속성 "user.dir"로 얻을 수 있다</li><li>보다 많은 기능을 제공하는 java.nio.file 패키지가 존재한다</li></ol><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">public static final char separatorChar
public static final String separator
    // 시스템 속성 "file.separator", UNIX : '/', Windows : '\\'
public static final char pathSeparatorChar
public static final String pathSeparator
    // 시스템 속성 "path.separator", UNIX : ':', Windows : ';'

boolean mkdirs()    // 경로상 필요한 모든 디렉터리들 생성
String[] list()     // ls

static File[] listRoots()
static File createTempFile(String prefix, String suffix)
    // (특정) 디렉터리에 새로운 빈 파일을 만들어 반환한다
    // deleteOnExit()을 통해 자동으로 정리되어야 한다
    // prefix : 의미 있는 접두어, suffix : null이면 ".tmp"</div><p><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/io/FileFilterExample.java" lan="java">FileFilter 예</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/io/FilenameFilterExample.java" lan="java">FilenameFilter 예</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/io/FileExample.java" lan="java">File 예</button></p><h3>RandomAccessFile</h3><ul><li>읽기(DataInput)/쓰기(DataOutput) 가능한 임의 접근 파일</li><li>mode : "r" | "rw" | "rws"(파일 내용 및 메타데이터 변경을 곧바로 반영) | "rwd"(파일 내용 변경을 곧바로 반영)</li><li>읽기/쓰기의 기준 위치가 되는 file pointer가 존재</li><li>읽기로 예정된 바이트들을 모두 읽기 전에 EOF를 만나면 EOFException 발생</li></ul><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">long getFilePointer()
void seek(long pos) // file pointer 설정

long length()
void setLength(long newLength)
    // 기존 크기 > newLength         → 자르기
    // getFilePointer() > newLength → file pointer = newLength
    // 기존 크기 &lt; newLength         → 확장. 확장한 영역의 데이터는 초기화되지 않는다

</div></div></div><h1>java.lang</h1><div><h2>AutoCloseable</h2><ul><li>자동으로 자원을 해제하는 객체를 표현한다</li><li>try-with-resources 블록에 사용되면 close()가 자동으로 호출된다 <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/Basic/src/io/github/donggi/TryWithResources.java" lan="java">TryWithResources.java</button></li><li>IO 작업이 없는 것들을 try-with-resources 블록에 이용하는 것은 불필요한 일이다</li></ul><h2>Comparable&lt;T></h2><ol><li>인스턴스를 정렬하는 자연스러운 순서 정의</li><li>이를 구현한 클래스 객체들의 List, array는 Collections.sort, Arrays.sort로 각각 정렬할 수 있다</li><li>이를 구현한 클래스 객체들은 Comparator 정의 없이 SortedMap, SortedSet의 키로 이용할 수 있다</li><li>null은 객체가 아니므로 equals(null)이 false를 리턴하는 것과 달리 compareTo(null)은 NullPointerException을 내보내는 것이 바람직하다</li><li>다음 성질을 만족하도록 구현함이 권장된다<p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">(e1.compareTo(e2) == 0) == e1.equals(e2)</div></li></ol><h2>Iterable&lt;T></h2><p>이를 구현한 클래스 객체는 enhanced for statement의 순회 대상이 될 수 있다</p><h2>ProcessHandle</h2><ol><li>native process들에 대한 제어 제공</li><p>프로세스 생애 모니터링, 자식 프로세스 나열, 프로세스 정보 얻기, 프로세스 종료 등 <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/lang/ProcessHandleExample.java" lan="java">ProcessHandleExample.java</button></p><li>ProcessHandle 객체는 다음 팩터리 메서드로 반환된다</li><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">current(), of(long), children(), descendants(), parent(), allProcesses()</div><li>SecurityManager의 RuntimePermission("manageProcess")만큼의 제어 권한을 갖는다</li><li>ProcessHandle 객체들을 비교할 때는 equals, compareTo 메서드를 이용해야 한다</li></ol><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">ProcessHandle.Info info()

boolean supportsNormalTermination()
    // destroy() 메서드가 정상적으로 프로세스를 종료하는지 여부. false면 프로세스를 강제로 즉시 종료함을 의미
CompletableFuture&lt;ProcessHandle> onExit()
    // onExit().get()을 호출하면 프로세스가 종료되는 것을 기다린다
    // supportsNormalTermination()이 false일 경우 onExit()에 등록한 후처리들이 진행되지 않을 수 있음

boolean destroy()
    // 프로세스 종료에 시간이 걸릴 수 있으므로, isAlive()가 얼마간 true를 반환할 수 있다
    // 성공적으로 프로세스를 종료하면 true, 아니면 false를 반환한다
boolean destroyForcibly() // 강제 종료

long pid()
boolean isAlive() // PID가 유효하면 alive로 간주</div><div><h3>ProcessHandle.Info</h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">Optional&lt;String> command()            // 실행가능한 경로 반환
Optional&lt;String> commandLine()        // command()와 arguments()의 결과를 공백으로 구분한 결과 반환
Optional&lt;String[]> arguments()        // 프로세스의 인자 반환
Optional&lt;Instant> startInstant()      // 프로세스의 시작 시각 반환
Optional&lt;Duration> totalCpuDuration() // CPU 사용 시간 반환
Optional&lt;String> user()               // 프로세스 유저 반환
</div></div><h2>SecurityManager</h2><ol><li>보안 정책을 구현할 수 있는 클래스. 전형적인 확인 절차는 아래와 같다</li><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">SecurityManager security = System.getSecurityManager();
if (security != null) {
    security.checkXXX(argument, . . . );
}</div></ol><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">Object getSecurityContext()           // 현재 실행 환경을 캡슐화한 객체 반환
ThreadGroup getThreadGroup()          // 새로운 스레드를 생성할 수 있는 스레드그룹 반환
void checkPermission(Permission perm) // checkXXX()</div><h2>Math, StrictMath</h2><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static double IEEEremainder(double f1, double f2)

static double rint(double d) // round to even

// 오버플로우되면 예외
addExact, substractExact, multiplyExact, incrementExact, decrementExact, negateExact, toIntExact

static long multiplyFull(int x, int y)
static long multiplyHigh(long x, long y) // 상위 64개 비트를 반환

floorDiv(x, y)
    // x/y 이하 최대 정수
    // Integer.MIN_VALUE, Long.MIN_VALUE를 -1로 나누는 경우는 오버플로우가 발생하고, 각각 Integer.MIN_VALUE, Long.MIN_VALUE를 반환한다
floorMod(x, y)
    // x - (floorDiv(x, y) * y)를 반환한다. 부호는 y와 같다
fma(a, b, c)
    // a * b + c에 가장 가까운 float, double을 반환
</div><h2>공유 변수 관련</h2><div><h3>ClassValue&lt;T></h3><p>임의 타입에 대하여, 필요할 때에 연산된 값을 가져오도록 지원. 해당 값은 해당 타입에 대해 일관성을 갖는다</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">protected abstract T computeValue(Class&lt;?> type)
    // type에 대하여, 최초 get 메서드 호출 시 한 번만 호출되며, 이후 remove 메서드 호출이 없으면 더 이상 불리지 않는다
T get(Class&lt;?> type)
    // 값이 계산되지 않은 상태에서 여러 스레드들이 경합을 벌일 경우, 임의 스레드의 결과값을 모두에 반환한다
void remove(Class&lt;?> type)
    // 다음 get 호출 시 값을 새로 계산하도록 한다</div><h3>ThreadLocal&lt;T></h3><p>스레드 단위의 지역 변수를 제공한다. 호출 지점과 관계없이 한 스레드 내부에서 변수를 공유한다</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">protected T initialValue()
    // 초기값이 설정되지 않은 상태에서 최초 get() 호출에 의해 불린다. remove() 호출 후의 get() 요청으로 다시 불린다
static &lt;S> ThreadLocal&lt;S> withInitial(Supplier&lt;? extends S> supplier)
    // supplier로 초기값이 설정되는 ThreadLocal 반환</div><h3>InheritableThreadLocal&lt;T></h3><p>ThreadLocal에 상속성을 부여. 자식 스레드는 부모의 thread-local 변수들을 초기값으로 상속받고 시작한다. childValue 메서드를 재정의함으로써 부모의 값과 다르게 설정할 수도 있다</p></div><h2>타입 관련</h2><div><ul><li>각 래퍼 클래스의 TYPE 필드는 기본 타입 클래스 인스턴스를 가리킨다</li><p>e.g. Boolean.TYPE == boolean.class</p><li>각 래퍼 클래스의 valueOf() 함수는 기본 타입에 대해 래핑을 수행하며, 일부는 캐싱을 이용해 빠르게 수행한다</li><li>숫자 래퍼 클래스들은 MIN_VALUE, MAX_VALUE, SIZE(비트 크기), BYTES(바이트 크기) 필드를 갖는다</li><li>byte[] -> 다른 수 타입 변환을 원하는 경우, ByteBuffer 이용</li><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">ByteBuffer.wrap(new byte[] { 1, 1, 1, 1 }).getInt()</div><li>Boolean, Integer, Long은 시스템 속성 관련 유틸리티를 제공한다</li><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static X getX(String name, X defaultVal)</div><li>몇몇 래퍼 클래스들은 아래와 같은 비트 함수를 제공한다</li><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static X highestOneBit(X i)            // + lowestOneBit
static X numberOfLeadingZeros(X i)     // + numberOfTrailingZeros
static X bitCount(X i)
static X rotateLeft(X i, int distance) // + rotateRight
static X reverse(X i)
static X reverseBytes(X i)             // 바이트 단위로 뒤집기</div><li>정수 래퍼 클래스들은 아래와 같은 String 파싱을 제공한다</li><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static Z parseZ(String s, int radix)
static Z valueOf(String s, int radix)
    // 예외
    //      s가 null이거나 길이가 0
    //      s에 radix진수가 아닌 문자가 포함(단, s가 2글자 이상일 때 첫 '-', '+'는 가능)
    //      radix가 [Character.MIN_RADIX, Character.MAX_RADIX] 범위를 벗어날 때
    //      값이 Z를 벗어날 때
static Z decode(String nm)
    // 다음 문법으로 표현된 10진수, 16진수, 8진수를 parseZ()를 이용해 디코딩한다. 공백 비허용
    //      (Sign?)(10진수)
    //      (Sign?)(0x | 0X | #)(16진수)
    //      (Sign?)0(8진수)
    //      Sign: '-', '+'</div><li>정수 래퍼 클래스들은 몇몇 unsigned 함수를 제공한다</li><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static int compareUnsigned(Z x, Z y)
static Z divideUnsigned(Z dividend, Z divisor)
static Z parseUnsigned(...)
static Z remainderUnsigned(Z dividend, Z divisor)
static int toUnsignedInt(Z x)
static long toUnsignedLong(Z x)
static String toUnsignedString(Z i)
</div></ul><h3>CharSequence</h3><ul><li>일련의 char 값들을 표현 <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/lang/CharSequenceExample.java" lan="java">CharSequenceExample.java</button></li><li>equals(), hashCode()에 대한 규약이 없어, set이나 map의 키로 이용하기에 부적절하다</li></ul><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static int compare(CharSequence cs1, CharSequence cs2)
    // 사전순으로 비교

default IntStream chars()
    // char들을 int로 0패딩하여 스트림 생성. 두 char로 쪼개진 유니코드 보충 평면의 문자를 하나로 합치진 않는다
default IntStream codePoints()
    // 유니코드 값들을 스트림으로 생성. 보충 평면의 문자는 Character.toCodePoint 메서드를 통해 하나의 int 값으로 형성
</div><h3>Character</h3><ol><li>문자 집합(소문자, 숫자 등) 정의, 변환 기능을 제공한다</li><li>유니코드 표준을 따른다</li><ul><li>유효한 범위는 U+0000(MIN_CODE_POINT)부터 U+10FFFF(MAX_CODE_POINT)까지(== Unicode scalar value) <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/lang/CharacterExample.java" lan="java">CharacterExample.java</button></li><ol><li>[U+0000, U+FFFF] == 기본 문자 평면(BMP; Basic Multilingual Plane)</li><li>[U+10000 == MIN_SUPPLEMENTARY_CODE_POINT, ~) == 보충 문자 평면(supplementary characters)</li></ol><li>자바 플랫폼은 보충 평면의 문자들은 2개의 char의 쌍으로 표현한다</li><p>이때 첫번째 char는 high-surrogate([MIN_HIGH_SURROGATE, MAX_HIGH_SURROGATE]), 두번째 char는 low-surrogate([MIN_LOW_SURROGATE, MAX_LOW_SURROGATE]) 범위 안의 값이다</p><li>하위 21개 비트를 이용하여 int 하나로 모든 유니코드 code point를 표현할 수 있다</li></ul><li>int를 받는 메서드는 모든 유니코드를 처리할 수 있지만, char만을 받는 메서드는 보충 평면 문자를 처리하지 못한다</li></ol><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static String getName(int codePoint)
    // 이름 반환 : Character.UnicodeBlock.of(codePoint).toString().replace('_', ' ') + " " + Integer.toHexString(codePoint).toUpperCase(Locale.ROOT);
    // 정의되어 있지 않으면 null
static int codePointOf(String name)
    // 정의되어 있지 않으면 예외

static boolean isValidCodePoint(int codePoint)
    // + isBmpCodePoint, isSupplementaryCodePoint, isHighSurrogate, isLowSurrogate
static int getType(int codePoint)
static byte getDirectionality(char ch)
    // 문자 표시 순서 : DIRECTIONALITY_UNDEFINED, DIRECTIONALITY_LEFT_TO_RIGHT 등
static boolean isMirrored(char ch)
    // 좌우 대칭되는 문자가 존재하는지 여부

static boolean isDigit(char ch)
    // getType(ch) == DECIMAL_DIGIT_NUMBER
static boolean isLetter(char ch)
    // getType(ch) == *_LETTER, isLetterOrDigit
static boolean isAlphabetic(int codePoint)
    // UPPERCASE_LETTER, LOWERCASE_LETTER, TITLECASE_LETTER, MODIFIER_LETTER, OTHER_LETTER, LETTER_NUMBER, 및 기타 알파벳 문자인지 여부
static boolean isSpaceChar(char ch)
    // getType(ch) == *_SEPARATOR
static boolean isWhitespace(char ch)
    // 공백 문자 '\t', '\n', 'u000B', '\f', '\r', '\u001C', '\u001D', '\u001E', '\u001F'
    // 단, non-breaking space('\u00A0', '\u2007', '\u202F') 제외

static int charCount(int codePoint)
    // 표현에 필요한 char 수(1 or 2)
static char[] toChars(int codePoint)
static String toString(int codePoint)

static int toCodePoint(char high, char low)
static int codePointAt(CharSequence seq, int index)
    // + codePointBefore, highSurrogate, lowSurrogate
static int codePointCount(CharSequence seq, int beginIndex, int endIndex)
    // [beginIndex, endIndex) 사이의 유니코드 문자 수 반환
static int offsetByCodePoints(CharSequence seq, int index, int codePointOffset)
    // 지정된 index로부터 offset 개수만큼 유니코드를 건너뛴 위치. +일 경우 index 포함, -인 경우 index 미포함(예시 코드 참고)

static int toLowerCase(int codePoint)
    // + toUpperCase, toTitleCase
    // isLowerCase(toLowerCase(x))가 항상 true는 아니다

static int digit(int codePoint, int radix)
static char forDigit(int digit, int radix)
static int getNumericValue(int codePoint)</div><div><h4>Character.Subset</h4><p>이 클래스의 객체는 유니코드 문자 집합을 표현한다. Character 클래스 내부에서 정의한 문자 집합은 Character.UnicodeBlock뿐이다</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">final String toString() // name 반환</div><h4>Character.UnicodeBlock</h4><p>유니코드 문자 블록. 각 문자들은 최대 하나의 유니코드 블록에 포함된다</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">public static Character.UnicodeBlock ARABIC, GREEK, HANGUL, ...

static Character.UnicodeBlock of(char c)
static final Character.UnicodeBlock forName(String blockName)
    // 블록 이름이 변경된 경우, 변경 전/후 이름 둘 다 사용할 수 있다
</div><h4>Character.UnicodeScript</h4><p>유니코드 표준 스크립트 이름 정의. 모든 문자는 하나의 스크립트(각 언어|INHERITED|COMMON|UNKNOWN)에 할당된다</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">public static final Character.UnicodeScript ARABIC, GREEK, HANGUL, ...

static Character.UnicodeScript of(int codePoint)
</div></div><h3>Double</h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">public static final double POSITIVE_INFINITY // Double.longBitsToDouble(0x7ff0000000000000L)
public static final double NEGATIVE_INFINITY // Double.longBitsToDouble(0xfff0000000000000L)
public static final double NaN               // Double.longBitsToDouble(0x7ff8000000000000L)
public static final double MAX_VALUE         // Double.longBitsToDouble(0x7fefffffffffffffL), 0x1.fffffffffffffP+1023
public static final double MIN_NORMAL        // Double.longBitsToDouble(0x0010000000000000L), 0x1.0p-1022
    // 진수가 1 이상인 가장 작은 양수 표현
public static final double MIN_VALUE         // Double.longBitsToDouble(0x1L), 0x0.0000000000001P-1022
    // 가장 작은 양수 표현

static String toHexString(double d)
static long doubleToLongBits(double value)
    // double 표현 그대로 long으로 전환. 63번 비트는 부호, 62-52번 비트는 지수, 51-0번 비트는 진수
static long doubleToRawLongBits(double value)
    // NaN의 경우 각각의 NaN에 대응하는 값으로 반환
static double longBitsToDouble(long bits)
    // NaN : [0x7ff0000000000001L, 0x7fffffffffffffffL] or [0xfff0000000000001L, 0xffffffffffffffffL]

int compareTo(Double anotherDouble)
    // Double.NaN > Double.POSITIVE_INFINITY
    // 0.0d > -0.0d
</div><h3>Integer</h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static String toString(int i, int radix)
    // + toUnsignedString, toBinaryString, toOctalString, toHexString
</div><h3>String</h3><p>로캐일을 고려한 문자열 비교는 Collator 클래스를 이용하면 된다</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static final Comparator&lt;String> CASE_INSENSITIVE_ORDER
    // 대소문자 구분없는 비교자. 직렬화 가능

static String format(String format, Object... args)
String formatted​(Object... args)
static String valueOf(Object obj)

boolean isEmpty() // 길이가 0인지 여부
boolean isBlank() // 비거나 공백 문자로만 이루어졌는지 여부

byte[] getBytes(Charset charset)
    // 문자셋이 지정되지 않은 경우, 플랫폼 기본 문자셋을 이용한다. 기본 문자셋을 변경하려면 JVM 옵션을 조정하면 된다

// 비교
boolean contentEquals(StringBuffer sb)
boolean equalsIgnoreCase(String anotherString)
int compareToIgnoreCase(String str)
boolean regionMatches(int tooffset, String other, int ooffset, int len)
    // 부분 문자열이 일치하는지 여부 반환. t(his's)offset, o(ther's)offset
boolean startsWith(String prefix, int toffset)
boolean endsWith(String suffix)

// 검색
int indexOf(String str, int fromIndex) // + lastIndexOf
boolean matches(String regex)          // == Pattern.matches(regex, str)
boolean contains(CharSequence s)
String replaceAll(String regex, String replacement) // + replaceFirst
String replace(CharSequence target, CharSequence replacement)

String[] split(String regex, int limit)
    // limit이 음수인 경우, 제한 없이 분리. 0인 경우 빈 문자열로 끝나지 않음
static String join(CharSequence delimiter, CharSequence... elements)

String trim()             // 시작과 끝의 공백(&lt;= U+0020) 제거
String strip()            // + stripLeading, stripTrailing. 공백 제거
Stream&lt;String> lines()    // 줄 끝(\n, \r, \r\n) 기준으로 분리
String indent(int n)      // 각 줄이 n개의 공백으로 시작하도록 조정하고, 줄 끝을 \n로 정규화한다. n이 음수인 경우, 최대 n개의 앞선 공백을 제거한다
String stripIndent()      // 모든 줄이 공유하는 불필요한 들여쓰기 제거

&lt;R> R transform(Function&lt;? super String, ? extends R> f)
String repeat(int count)
</div><h3>StringBuffer</h3><p>스레드-안전한 변경 가능한 문자열</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">void trimToSize()
    // 버퍼 크기를 줄여 문자열 크기에 맞춘다
void setLength(int newLength)
    // 새로운 크기의 문자열에 기존 문자열을 복사. 남는 부분은 '\u0000'(null)로 채워진다
void ensureCapacity(int minimumCapacity)
StringBuffer reverse()
</div><h3>StringBuilder</h3><p>StringBuffer의 비동기화 버전</p></div><h2>클래스 관련</h2><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/lang/ClassExample.java" lan="java">ClassExample.java</button><div><h3>Class&lt;T></h3><div><h4>Nest</h4><ul><li>Nest는 같은 런타임 패키지 안의, private member에 접근 가능한 클래스와 인터페이스의 집합</li><li>Nest에 속한 클래스, 인터페이스를 nestmate라 부르고, 하나의 nest에서 하나의 nestmate는 host 역할을 하고 나머지 nestmate 목록을 갖는다</li></ul><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">Class&lt;?> getNestHost()
Class&lt;?>[] getNestMembers()
boolean isNestmateOf​(Class&lt;?> c)
</div></div><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">// ClassLoader 관련
ClassLoader getClassLoader()
InputStream getResourceAsStream(String name)
URL getResource(String name)
static Class&lt;?> forName(String name, boolean initialize, ClassLoader loader)

// 타입 관련
T cast(Object obj)
    // obj를 호출한 Class 객체와 같은 타입으로 변환
boolean isInstance(Object obj)
    // instanceof 연산자의 동적인 형태. 원시타입 클래스 객체는 false만 반환한다
boolean isAssignableFrom(Class&lt;?> cls)
    // cls 타입 객체를 현재 클래스의 참조 변수로 참조할 수 있는지 여부 반환
boolean isInterface()
    // + isArray, isPrimitive, isAnnotation, isEnum, isAnonymousClass, isLocalClass, isMemberClass, isRecord
    // wrapper 클래스는 원시타입이 아님에 유의 : Integer.class != Integer.TYPE == int.class

// 클래스 이름 관련
String toGenericString()
    // 접근한정자 및 타입 포함하여 반환
String getName()
    // 배열의 경우 차원마다 '['를 붙이며, 배열 원소 타입을 아래와 같이 인코딩한다
    // boolean : Z, byte : B, char : C, class : L{className};, double : D, float : F, int : I, long : J, short : S
String getSimpleName()
    // 익명 클래스면 빈 문자열 반환
String getCanonicalName()
    // Local class, 익명 클래스, 또는 이들의 배열은 canonical name이 없어 null을 반환한다

// 리플렉션 관련
Class&lt;?>[] getClasses()
    // public 멤버로 정의된 클래스, 인터페이스 Class 객체 배열 반환
    // + getFields, getMethods, getConstructors
Class&lt;?>[] getDeclaredClasses()
    // 상속된 것을 제외하고, 호출하는 클래스 내부에 정의된 public, protected, default, private 클래스와 인터페이스들을 반환한다
    // + getDeclaredFields, getDeclaredMethods, getDeclaredConstructors

Class&lt;?> getComponentType()
    // 배열 원소 타입 클래스 객체 반환. 배열이 아닌 경우 null 반환
Method getEnclosingMethod()
    // 이 클래스가 메서드 내부에서 정의된 경우, 해당 메서드를 반환한다
    // + getEnclosingConstructor, getDeclaringClass, getEnclosingClass

 &lt;A extends Annotation> A getAnnotation​(Class&lt;A> annotationClass)
boolean isAnnotationPresent(Class&lt;? extends Annotation> annotationClass)

// record 관련
RecordComponent[] getRecordComponents()
</div><h3>ClassLoader</h3><ol><li>전형적으로, 로드할 클래스 이름을 파일명으로 변환하여 ".class"파일을 읽어온다</li><li>모든 Class 객체들은 ClassLoader에 대한 참조를 갖고 있다</li><li>배열의 경우 런타임에 Class 객체가 생성되며, 이때 Class.getClassLoader()는 원소의 것과 동일하다</li><li>클래스를 로드하는 것 외에, 자원(.class 파일, 구성 파일, 이미지 등)을 배치하는 책임도 진다</li><li>Delegation model : ClassLoader 객체들은 각기 parent class loader를 갖는다. 클래스나 자원을 찾기 전에 parent를 먼저 조사하게 된다</li><li>동시 로딩을 지원하는 parallel capable class loader들은 클래스 초기화 시 registerAsParallelCapable()를 통해 등록해야 한다. ClassLoader 클래스는 기본적으로 등록되나, 서브클래스들도 자신을 등록해야 한다</li><li>계층구조가 약한 delegation model의 경우 클래스 로더들이 parallel capable하지 않으면 deadlock 발생 가능성이 있다</li><li>Run-time Built-in Class Loaders</li><ul><li>Bootstrap class loader : JVM 내장 클래스 로더. 보통 null이며, parent가 없다</li><li>Platform class loader : Java SE APIs, JDK-specific run-time classes</li><li>System class loader, a.k.a Application class loader : Used to define classes on the application class path, module path, and JDK-specific tools</li></ul><li>파일이 아닌 네트워크 같은 다른 소스로부터 클래스를 로드할 경우, defineClass()를 통해 Class 객체를 얻고 Constructor.newInstance()를 통해 클래스 객체를 생성하면 된다</li><li>네트워크 클래스 로더는 findClass(), loadClassData() 메서드를 반드시 작성해야 한다</li><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">public Class findClass(String name) {
    byte[] b = loadClassData(name);
    return defineClass(name, b, 0, b.length);
}
private byte[] loadClassData(String name) { /**/ }</div><span id="pos-1291483511" style="padding:0!important;margin:0!important;width:0!important;height:0!important;overflow:hidden!important"></span><li>Binary names</li><p>ClassLoader 메서드에 전달하는 String 타입 클래스 이름은 아래와 같은 형식을 따라야 한다</p><ul><li>"java.lang.String"</li><li>"javax.swing.JSpinner$DefaultEditor"</li><li>"java.security.KeyStore$Builder$FileBuilder$1"</li><li>"java.net.URLClassLoader$3$1"</li></ul></ol><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static ClassLoader getPlatformClassLoader()
static ClassLoader getSystemClassLoader()
    // 시스템 클래스 로더를 반환하며, 이는 새롭게 정의되는 클래스 로더들의 default delegation parent다

Class&lt;?> loadClass(String name)
    // == loadClass(name, false)
protected Class&lt;?> loadClass(String name, boolean resolve)
    // 1. findLoadedClass(String)로 이미 로드됐나 확인
    //     없으면 : parent 혹은 VM의 클래스 로더의 loadClass를 호출
    //     없으면 : findClass(String) 호출
    // 2. 위를 통해 클래스를 찾았고, resolve가 true면 resolveClass(Class) 호출
    // 3. ClassLoader의 서브클래스들은 이 메서드가 아닌 findClass(String)을 재정의하면 된다
    // 4. 재정의되지 않은 이상, getClassLoadingLock()을 통해 메서드는 동기화된다
protected final void resolveClass(Class&lt;?> c)
    // 클래스를 링크(초기화)한다

// 리소스 관련
? *Resource*(String name)
    // name은 '/'으로 구분된 경로
</div><h3>Module</h3><p>이름 있는 모듈에 속하지 않은 모든 타입은 각 클래스 로더의 익명 모듈에 속한다</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">InputStream getResourceAsStream(String name)
    // 해당 모듈의 리소스를 스트림으로 반환. name은 '/'으로 구분된 경로
</div></div><h2>프로그램 실행 단위</h2><div><h3>Thread</h3><ol><li>스레드는 실행 우선순위를 가지며, 그 초깃값은 스레드를 생성한 스레드의 것과 같다. 데몬 스레드로부터 생성된 스레드도 데몬 스레드다</li><li>JVM이 시작되면 하나의 non-daemon 스레드가 존재하며, 전형적으로 main 메서드를 호출한다. JVM은 다음의 상황 중 하나라도 일어나기 전까지 실행을 계속한다</li><ul><li>Runtime 클래스의 exit 메서드 호출, 또는 SecurityManager의 exit 허용</li><li>모든 데몬 스레드가 아닌 스레드들의 종료 : run 메서드의 반환이든 예외 발생이든 관계없이</li></ul></ol><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">public static final int MIN_PRIORITY
public static final int NORM_PRIORITY
public static final int MAX_PRIORITY

final void setDaemon(boolean on)
    // 스레드를 daemon 또는 user 스레드로 변경. 스레드가 시작되기 전에 호출돼야한다
    // user 스레드가 하나도 없으면 프로그램은 종료된다

void start() // JVM이 run() 호출. 스레드를 재시작하는 것은 허용되지 않는다
void run()   // 관련된 Runnable의 run() 호출
void interrupt()
    // 1. checkAccess()가 호출된다. wait, join, sleep으로 블록된 경우 인터럽트 상태가 초기화되고, InterruptedException 발생
    // 2. InterruptibleChannel로 I/O 작업 중 블록된 경우, 인터럽트 상태가 설정되고 채널은 닫힌다. ClosedByInterruptException 발생
    // 3. Selector에서 블록된 경우, 인터럽트 상태가 설정되고 selection 연산에서 즉시 반환된다. 그 외의 경우 인터럽트 상태가 설정된다

static Thread currentThread()
ClassLoader getContextClassLoader()

long             getId()
Thread.State     getState()
static boolean   interrupted()     // 현재 스레드가 인터럽드됐는지 여부. 스레드의 인터럽트 상태는 이 메서드로 인해 초기화된다
boolean          isInterrupted()   // 스레드의 인터럽트 상태를 변경하지 않고 반환한다
final boolean    isAlive()
final void       join(long millis) // 이 스레드가 중지되기까지 일시 대기. 0이면 무기한 대기. 지정 되지 않은 경우 0

static void dumpStack()
    // 현재 스레드의 스택 추적을 표준 에러 출력
final void checkAccess()
    // 현재 스레드가 이 스레드를 변경할 수 없으면 SecurityException 발생
static boolean holdsLock(Object obj)
    // 특정 객체를 lock으로 갖는지 확인

static void setDefaultUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)
void        setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)</div><div><h4>static void onSpinWait()</h4><p>Spin-wait 루프에서 조건이 충족되어 루프를 벗어나기를 기다린다</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">class EventHandler {
    volatile boolean eventNotificationNotReceived;
    void waitForEventAndHandleIt() {
        while ( eventNotificationNotReceived ) {
            java.lang.Thread.onSpinWait();
        }
        readAndProcessEvent();
    }

    void readAndProcessEvent() {
        // Read event from some source and process it
        ...
    }
}</div><h4>Thread.State</h4><p>NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED</p><h4>Thread.UncaughtExceptionHandler</h4><ol><li>처리되지 않은 예외로 인해 스레드가 종료되는 상황을 대비한 핸들러. 그러한 상황에서, 먼저 Thread.getUncaughtExceptionHandler()를 통해 얻은 핸들러에 해당 스레드와 예외 객체를 전달한다</li><li>만일 스레드에 핸드러가 설정되지 않은 경우, ThreadGroup의 핸들러를 이용하며, ThreadGroup에도 없는 경우 default 핸들러를 이용할 수 있다</li></ol></div><h3>Process</h3><p>ProcessBuilder.start, Runtime.exec으로 시작된 native process들에 대한 제어 제공</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">abstract OutputStream getOutputStream()
    // + getInputStream, getErrorStream

abstract int waitFor()
    // 현재 스레드가 이 프로세스의 종료를 기다린다. 프로세스의 종료 값을 반환
boolean waitFor(long timeout, TimeUnit unit)
    // 시간 내에 프로세스가 종료되었다면 true 반환

abstract int exitValue()
abstract void destroy()   // 정상 종료
Process destroyForcibly() // 강제, 즉시 종료
boolean isAlive()

long pid()
boolean supportsNormalTermination()
CompletableFuture&lt;Process> onExit()
ProcessHandle toHandle()
ProcessHandle.Info info()
Stream&lt;ProcessHandle> children()
Stream&lt;ProcessHandle> descendants()
</div><h3>ProcessBuilder</h3><p>이 클래스는 스레드-안전하지 않다</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">ProcessBuilder command(String... command)
ProcessBuilder directory(File directory)
ProcessBuilder redirectInput(ProcessBuilder.Redirect source)
    // + redirectOutput, redirectError
ProcessBuilder inheritIO()
ProcessBuilder redirectErrorStream(boolean redirectErrorStream)
    // true면 서브프로세스들의 에러 출력이 표준 출력으로 나온다

Process start()

static List&lt;Process> startPipeline(List&lt;ProcessBuilder> builders)
    // 프로세스들의 표준 출력을 다음 프로세스의 표준 입력으로 연결한다</div><div><h4>ProcessBuilder.Redirect</h4><p>서브프로세스의 입력 소스 또는 출력 방향을 표현한다</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">public static final ProcessBuilder.Redirect PIPE    // 현재 프로세스와 파이프로 연결
public static final ProcessBuilder.Redirect INHERIT // 현재 프로세스의 것과 동일
public static final ProcessBuilder.Redirect DISCARD // 출력 버림

static ProcessBuilder.Redirect from(File file)
static ProcessBuilder.Redirect to(File file)        // file의 이전 내용은 새로운 쓰기 작업에 의해 버려진다
static ProcessBuilder.Redirect appendTo(File file)</div><div><h5>ProcessBuilder.Redirect.Type</h5><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">APPEND, // Redirect.appendTo(File)
INHERIT,
PIPE,
READ,   // Redirect.from(File)
WRITE   // Redirect.to(File)
</div></div></div><h3>Runtime</h3><p>모든 Java 애플리케이션은 하나의 Runtime 인스턴스를 가진다</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static Runtime getRuntime()

void exit(int status)
    // 현재 실행중인 JVM을 종료
void addShutdownHook(Thread hook)
    // + removeShutdownHook
    // JVM이 종료 절차에 진입하면 등록된 모든 hook를 실행
void halt(int status)
    // 강제종료
Process exec(String[] cmdarray, String[] envp, File dir)

int availableProcessors()
long freeMemory()
    // + totalMemory, maxMemory
void gc()
void runFinalization()
    // 소멸 대기중인 모든 객체 소멸
</div><h3>System</h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">public static final InputStream in // + out, err
static void setIn(InputStream in)  // + setOut, setErr

static long currentTimeMillis() // + nanoTime
static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)
static int identityHashCode(Object x)

static String lineSeparator()
static void setProperties(Properties props) // getProperties
static String setProperty(String key, String value)
static String clearProperty(String key)
static String getenv(String name) // 환경변수
static void exit(int status)
</div><h3>StackWalker</h3><p>현재 스레드의 StackFrame에 대한 스트림을 열고 특정 작업을 수행한다. 스트림은 실행 지점인 맨 위 frame부터 아래로 내려가면서 작업한다</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static StackWalker getInstance(...)
    // 기본 설정 : 숨겨진 프레임 생략. 클래스 정보 미포함

&lt;T> T walk(Function&lt;? super Stream&lt;StackWalker.StackFrame>, ?
    // 예. 현재 스레드의 상위 10개 스택 프레임 가져오기
    StackWalker.getInstance().walk(s -> s.limit(10).collect(Collectors.toList()));
void forEach(Consumer&lt; super StackWalker.StackFrame> action)

Class&lt;&?> getCallerClass()
    // 이 메서드를 호출하는 호출자의 클래스 객체를 반환
    // Util::getResourceBundle 메서드는 이 메서드를 통해 얻은 호출자의 클래스로부터 클래스 로더를 얻고, 클래스 로더를 통해 리소스를 로드한다</div><div><h4>StackWalker.Option</h4><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">RETAIN_CLASS_REFERENCE // StackFrame에 클래스 정보 유지
SHOW_HIDDEN_FRAMES     // 숨겨진 프레임 표시
SHOW_REFLECT_FRAMES    // reflection 프레임 표시
</div><h4>StackWalker.StackFrame</h4><p>각 StackFrame 객체는 StackWalker로부터 반환된, 메서드 호출을 표현한다</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">String            getMethodName()       // 메서드 이름 반환
String            getClassName()        // 메서드가 정의된 클래스의 binary name 반환
Class&lt;?>       getDeclaringClass()   // 메서드가 정의된 클래스 객체 반환. Option.RETAIN_CLASS_REFERENCE 설정 필요
StackTraceElement toStackTraceElement() // 프레임에 관한 StackTraceElement 반환
</div></div><h3>StackTraceElement</h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">String  getFileName()
int     getLineNumber()
String  getMethodName()
String  getClassName()
String  getClassLoaderName()
String  getModuleName()
</div></div></div><h1>java.lang.annotation</h1><div><h2>Annotation</h2><p>이 인터페이스를 구현하는 것으로 새로운 애너테이션을 정의할 순 없다</p><h2>ElementType</h2><p>애너테이션이 적용되는 요소를 표현한다</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VALIABLE, ANNOTATION_TYPE, PACKAGE, TYPE_PARAMETER, MODULE</div><h2>RetentionPolicy</h2><p>애너테이션 유지 정책</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">SOURCE  // 컴파일러가 제거
CLASS   // 컴파일러가 클래스 파일에 기록(default)
RUNTIME // 클래스 파일에 기록하고 JVM 런타임에도 유지. 따라서 리플렉션 가능
</div><h2>@Documented @Retention(RUNTIME) @Target(ANNOTATION_TYPE) @interface Documented</h2><p>@Documented가 다른 애너테이션 타입 A에 존재하면, @A로 꾸며진 요소의 공개적인 서명으로 인식하여 JavaDoc에 포함된다</p><h2>@Documented @Retention(RUNTIME) @Target(ANNOTATION_TYPE) @interface Inherited</h2><p>Superclass의 애너테이션을 상속함을 표시. 클래스에만 유효한 애너테이션이다</p><h2>@Documented @Retention(RUNTIME) @Target(ANNOTATION_TYPE) @interface Repeatable</h2><p>애너테이션을 반복적으로 정의할 수 있음을 표현<a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://docs.oracle.com/javase/tutorial/java/annotations/repeating.html">참고자료</a></p><h2>@Documented @Retention(RUNTIME) @Target(ANNOTATION_TYPE) @interface Retention</h2><p>애너테이션을 얼마나 유지할 지 표현. value ← RetentionPolicy</p><h2>@Documented @Retention(RUNTIME) @Target(ANNOTATION_TYPE) @interface Target</h2><p>애너테이션을 적용할 요소들을 표현한다. 여러 개(또는 0개)일 경우 배열 리터럴 표기 {}를 이용한다. value ← ElementType[]</p></div><h1>java.lang.module</h1><div><h2>ModuleFinder</h2><ol><li>Module Resolution : 모듈들의 연관 관계를 계산하는 작업. 각 모듈의 필요(requires) 모듈들을 반복적으로 찾아내고 관계 그래프를 구한다</li><li>ModuleFinder는 module resolution과 service binding(Configuration::resolveAndBind)에서 모듈을 찾는 데 이용된다</li></ol><h2>ModuleReader</h2><p>모듈 내용에 대한 접근 제공</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">Optional&lt;URI> find(String name)
default Optional&lt;InputStream> open(String name)
default Optional&lt;ByteBuffer> read(String name)
Stream&lt;String> list()
</div></div><h1>java.lang.ref</h1><div><h2>Package Summary</h2><ol><li><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://web.archive.org/web/20061130103858/http://weblogs.java.net/blog/enicholas/archive/2006/05/understanding_w.html">java.net 포스트</a><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://d2.naver.com/helloworld/329631">NAVER 개발 포스트</a></li><li>다른 객체(referent)를 참조하는 reference object를 이용해 GC 절차 일부와 상호작용할 수 있다</li><li>3단계의 참조 레벨을 제공한다 : Soft > Weak > Phantom</li><li>객체 참조 레벨</li><ol><li>Strongly reachable</li><ul><li>Reference object 없이 객체에 직접 접근 가능한 스레드가 존재</li><p>e.g. 객체를 생성한 스레드, 객체를 매개변수로 받아 실행 중인 스레드 등</p></ul><li>Softly reachable</li><ul><li>Not strongly reachable && Soft reference object가 객체를 참조 중</li><li>마지막으로 strongly reachable한 이후 기간, 여유 힙 크기, JVM 옵션(-XX:SoftRefLRUPolicyMSPerMB)에 따라 GC 여부가 결정된다</li><li>지정한 경우, GC 대상으로 판별된 즉시(약간의 지연은 있을 수 있다) ReferenceQueue에 등록된다</li></ul><li>Weakly reachable</li><ul><li>Not strongly reachable && Not softly reachable && Weak reference object가 객체를 참조 중</li><li>Referent는 GC 대상이며, 따라서 get()은 null을 반환할 수 있다</li><li>지정한 경우, GC 대상으로 판별된 즉시(약간의 지연은 있을 수 있다) ReferenceQueue에 등록된다</li></ul><li>Phantom reachable</li><ul><li>Not strongly reachable && Not softly reachable && Not weakly reachable && 객체는 소멸(finalize)됐지만 Phantom reference object가 참조 중</li><li>Finalization 이후 ReferenceQueue에 등록된다</li><li>객체 소멸 감지를 위해 존재하므로, get()은 항상 null을 반환한다</li><li>ReferenceQueue에서 꺼낸 뒤, 메모리 해제를 위해 clear()를 호출해야 한다</li></ul><li>Unreachable</li><p>참조 불가능하며, 따라서 GC 대상이 된다</p></ol></ol><h2>Cleaner</h2><ol><li>객체 참조와 관련 정리 작업을 관리한다</li><p>객체가 phantom reachable 상태로 변했음을 통지받으면 정리 작업이 실행된다. 참조 레벨의 변경을 통지받기 위해 PhantomReference와 ReferenceQueue를 이용한다</p><li>객체 참조와 정리 작업을 등록하면 Cleanable 인스턴스가 반환된다</li><p>가장 효과적인 사용법은 객체의 close() 메서드나, 객체가 필요없는 시점에 명시적으로 clean()을 호출하는 것</p><li>등록하는 객체를 객체 정리 작업이 참조하면 안 된다</li><p>참조하는 경우, 객체는 Phantom reachable 레벨에 도달할 수 없고, 따라서 자동으로 정리 작업이 호출될 수 없다</p><li>정리 작업은 Runnable이며, 실행 중 발생하는 모든 예외는 무시된다. 발생한 예외는 Cleaner와 다른 정리 작업에 영향을 미치지 않는다 Cleaner 인스턴스와 관계된 스레드가 정리 작업을 실행하며, 모든 정리 작업이 실행된 후엔 Cleaner 인스턴스가 GC에 의해 정리된다</li><li>System.exit 도중의 정리 작업의 실행은 정의되지 않는다</li></ol><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static Cleaner create()
Cleaner.Cleanable register(Object obj, Runnable action)</div><div><h3>Cleaner.Cleanable</h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">void clean()
    // cleanable을 등록 취소하고 정리 작업을 실행한다. 반복 호출되도 정리 작업은 최대 1번만 실행된다
</div></div><h2>ReferenceQueue&lt;T></h2><p>참조 큐. 참조 레벨 변화를 감지하면 GC가 reference object를 큐에 추가한다</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">Reference&lt;?
    // reference object가 즉시 사용 가능하면 큐에서 제거하고 반환한다. 그 외의 경우 즉시 null을 반환한다
Reference&lt;?
    // 다음 reference object를 규에서 제거하고 반환한다. 그 다음 reference object가 사용 가능해질 때까지 최대 timeout 만큼 대기한다
</div><h2>Reference&lt;T></h2><p>GC와 상호작용하기 위한 메서드들을 정의한다. 이 클래스를 직접 상속하지 않아야 한다</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">T get()
    // 참조하는 객체를 반환한다
void clear()
boolean enqueue()
    // reference object를 정리하고 등록된 큐에 넣는다
    // + isEnqueued</div><div><h3>Sub Classes</h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">class SoftReference&lt;T> extends Reference&lt;T>
class WeakReference&lt;T> extends Reference&lt;T>
class PhantomReference&lt;T> extends Reference&lt;T>
</div></div></div><h1>java.lang.reflect</h1><div><h2>자바 제네릭 제약사항</h2><ol><li>자바의 제네릭은 컴파일 과정에서 모두 Object 또는 바운드된 클래스로 교체된다</li><li>따라서 List&lt;T> 참조 변수만 가지고 T가 어떤 타입인지 런타임에 알아내는 방법은 없다</li><p>다만, 원소가 존재한다면 instanceof, Class::isInstanse, Class::isAssignableFrom을 이용한 판별은 가능하다</p><li>따라서 제네릭 타입에 대한 직접적인 연산은 모두 무효하다</li></ol><h2>Array</h2><p>동적으로 자바 배열을 생성하고 접근하는 static 메서드들을 제공</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static Object newInstance(Class&lt;?> componentType, int length)
static Object get(Object array, int index)
    // + getBoolean, getByte, ..., + set...
</div><h2>Modifier</h2><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">public static final int PUBLIC, PRIVATE, PROTECTED, STATIC, FINAL, SYNCHRONIZED, VOLATILE, TRANSIENT, NATIVE, INTERFACE, ABSTRACT, STRICT
static int classModifiers()
    // 사용할 수 있는 제한자들을 OR하여 반환
    // + interfaceModifiers, constructorModifiers, ...
</div><h2>지원 타입 종류</h2><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">interface Type                           // 모든 타입의 공통 super interface
interface ParameterizedType extends Type // Collection&lt;String>처럼 파라미터화된 타입을 표현
interface GenericArrayType extends Type  // 원소 타입이 parameterized type 또는 type 변수인 배열 타입을 표현
interface WildcardType extends Type      // ?, ? extends Number, ? super Integer와 같은 와일드카드 타입을 표현
interface AnnotatedElement               // 애너테이트된 요소를 표현
interface AnnotatedType extends AnnotatedElement {
    default AnnotatedType getAnnotatedOwnerType();
        // 이 타입이 멤버로 속해있는, 애너테이트된 타입 반환. 예를 들어 이 타입이 @TA O&lt;T>.I&lt;S>라면, @TA O&lt;T>를 반환
        // null이 반환되는 경우 ↓
        //     타입이 top-level이거나 local 클래스, 익명 클래스, 기본 자료형, void인 경우
        //     타입이 AnnotatedArrayType, AnnotatedTypeVariable, AnnotatedWildcardType의 인스턴스인 경우
    Type getType();
        // 이 애너테이트된 타입의 기저 타입
}
interface AnnotatedArrayType extends AnnotatedType         // 원소가 애너테이트된 배열을 표현
interface AnnotatedParameterizedType extends AnnotatedType // 타입 인자들이 애너테이트된 parameterized type을 표현
interface TypeVariable&lt;D extends GenericDeclaration> extends Type, AnnotatedElement // 타입 변수에 관한 공통 superinterface
interface GenericDeclaration extends AnnotatedElement      // 모든 타입 변수 정의들에 대한 공통 인터페이스
interface AnnotatedTypeVariable extends AnnotatedType      // 애너테이트된 바운드를 가진 타입 변수를 표현
interface AnnotatedWildcardType extends AnnotatedType      // 애너테이트된 upper 또는 lower 바운드들에 대한 와일드카드 타입을 표현
</div><h2>클래스 멤버 관련</h2><div><h3>Member</h3><p>하나의 멤버(필드나 메서드) 또는 생성자를 가리킨다</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">boolean isSynthetic() // 컴파일러에 의해 만들어진 멤버인지 여부</div><h3>AccessibleObject</h3><p>Field, Method, Constructor의 base 클래스. 리플렉트된 객체를 사용하기 전에 suppressing check 표시한다</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">void setAccessible(boolean flag)
static void setAccessible(AccessibleObject[] array, boolean flag)
    // 배열의 각 원소들을 setAccessible(boolean)으로 설정할 수 있을 때, 한번에 하기 위한 메서드

final boolean canAccess(Object obj)
final boolean trySetAccessible()
    // accessible flag 값을 반환한다. 실패할 경우 예외를 발생하지 않고 false를 반환
</div><h3>Field</h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">boolean isEnumConstant()
void set(Object obj, Object value)
    // + get, setBoolean, getBoolean, ...
</div><h3>Executable</h3><p>Method, Constructor의 공통 기능</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">abstract Class&lt;?>[] getParameterTypes()
Parameter[] getParameters()
</div><h3>Method</h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">Class&lt;&?> getReturnType()
Object invoke(Object obj, Object... args)
</div><h3>Constructor&lt;T></h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">T newInstance(Object... initargs)</div><h3>Parameter</h3><p>메서드 인자에 관한 정보</p><h3>InvocationHandler</h3><p>Proxy 인스턴스의 invocation handler에서 구현하는 인터페이스</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">Object invoke(Object proxy, Method method, Object[] args)</div><h3>Proxy</h3><ul><li>Proxy는 인터페이스 익명 객체처럼 행동하면서 사용자 정의 메서드를 호출할 수 있는 객체를 생성하는 static 메서드를 제공한다</li><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">// 예. 인터페이스 Foo의 프록시 인스턴스 생성
InvocationHandler handler = new MyInvocationHandler(...);
var f = (Foo) Proxy.newProxyInstance(Foo.class.getClassLoader(), new Class&lt;?>[] { Foo.class }, handler);</div><li>프록시 클래스 속성</li><p>"$Proxy"로 이름이 시작. final and non-abstract. java.lang.reflect.Proxy를 상속. 생성시 주어진 인터페이스들을 차례대로 구현. ProtectionDomain은 bootstrap 클래스 로더가 로드한 시스템 클래스들과 동일</p></ul><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static Object newProxyInstance(ClassLoader loader, Class&lt;?>[] interfaces, InvocationHandler h)
static boolean isProxyClass(Class&lt;?> cl)
static InvocationHandler getInvocationHandler(Object proxy)
</div></div></div><h1>java.math</h1><div><h2>BigDecimal</h2><p>임의 정밀도의 변경할 수 없는 10진 정수와 32비트 정수인 지수로 십진수를 표현한다</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">public static final BigDecimal ZERO, ONE, TEN

public BigDecimal(String val)
    // val   ::= (부호)?(진수부)(지수부)?
    // 진수부 ::= 정수부.(소수부) or .소수부 or 정수부
    // 지수부 ::= (e|E)정수

BigDecimal add(BigDecimal augend) // + subtract, multiply, divide
BigDecimal divideToIntegralValue(BigDecimal divisor) // 몫
BigDecimal remainder(BigDecimal divisor)             // 나머지
BigDecimal[] divideAndRemainder(BigDecimal divisor)
// + sqrt, pow, abs, negate, scale, precision, unscaledValue, round, movePointRight, scaleByPowerOfTen, ...
</div><h2>BigInteger</h2><p>변경할 수 없는 임의 길이의 정수. -2^(Integer.MAX_VALUE) ~ 2^(Integer.MAX_VALUE)</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">public static final BigInteger ZERO, ONE, TWO, TEN

public BigInteger(int signum, byte[] magnitude, int off, int len)
public BigInteger(String val, int radix)
public BigInteger(int numBits, Random rnd) : [0 ~ 2^numBits) 사이 난수
public BigInteger(int bitLength, int certainty, Random rnd)
    // rnd를 통해 난수를 생성하고, 특정 비트 길이의 양의 정수(아마도 소수) 반환. 소수일 확률은 (1 - 0.5^certainty) 초과

static BigInteger probablePrime(int bitLength, Random rnd)
    // 합성수일 가능성은 2^(-100)을 넘지 않는다
BigInteger nextProbablePrime()
    // 이 BigInteger보다 큰 첫 소수(아마도)를 반환한다. 합성수일 가능성은 2^(-100)을 넘지 않는다

// BigDecimal에는 없는 메서드
sqrtAndRemainder(), gcd(BigInteger), modPow(BigInteger, BigInteger), shiftLeft(int), and(BigInteger), testBit(int), setBit(n), flipBit(int)
</div><h2>MathContext</h2><p>정밀도, 반올림 모드를 캡슐화한 변경 불가능한 객체</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">public static final MathContext UNLIMITED
    // precision=0 && roundingMode=HALF_UP
public static final MathContext DECIMAL32, DECIMAL64, DECIMAL128
    // 각각 7/16/34digits && roundingMode=HALF_EVEN

int getPrecision()
RoundingMode getRoundingMode()
</div><h2>RoundingMode</h2><ul><li>CEILING, FLOOR, UP : 0에서 멀어지도록 선택</li><li>DOWN : 0에 가까워지도록 선택</li><li>HALF_UP, HALF_DOWN, HALF_EVEN : 가장 인접한 두 이웃들이 같은 거리에 있는 경우(*5인 경우), 각각 큰/작은/짝수 이웃을 선택</li><li>UNNECESSARY : 올림이나 내림이 필요없는 상태. 그 외엔 ArithmeticException 발생</li></ul></div><h1>java.net</h1><div><h2>Address</h2><div><h3>InetAddress</h3><p>IP 주소를 표현하며, IPv4, IPv6 각각에 대응하는 서브 클래스가 있다. 서브 클래스를 직접 이용하는 일은 별로 없을 거라고 한다<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/net/InetAddressTest.java" lan="java">InetAddressTest.java</button></p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static InetAddress getLoopbackAddress() // 127.0.0.1(127.*.*.*) or ::1
static InetAddress getByAddress(byte[] addr)
static InetAddress getByName(String host)
static InetAddress[] getAllByName(String host)
byte[] getAddress()
</div><h3>SocketAddress</h3><p>프로토콜과 무관한 소켓 주소를 의미</p><h3>InetSocketAddress</h3><p>IP 소켓 주소[(IP 주소 or 호스트 이름) + 포트]를 표현</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">public InetSocketAddress(int port)                   // port가 0이면 바인드시 자동 할당
public InetSocketAddress(InetAddress addr, int port) // addr이 null이면 와일드카드 할당
public InetSocketAddress(String hostname, int port)
</div><h3>InterfaceAddress</h3><ol><li>IPv4 : IP 주소 + 서브넷 마스크 + 브로드캐스트 주소</li><li>IPv6 : IP 주소 + network prefix length</li></ol></div><h2>Connection</h2><div><h3>URLConnection</h3><ol><p>URL이 지정하는 원격지와의 연결을 정의하며, 일반적으로 아래 단계에 따라 사용된다</p><li>openConnection 메서드를 통해 연결 객체 획득</li><li>구성 인자 및 요청 속성 설정</li><p>setAllowUserInteraction, setDoInput, setDoOutput, setIfModifiedSince, setUseCaches</p><li>connect 메서드로 연결 시도</li><li>연결 성공하면 헤더와 컨텐츠에 접근할 수 있다</li><p>getContent, getHeaderField, getInputStream, getOutputStream<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/net/HttpURLConnectionTest.java" lan="java">HttpURLConnectionTest.java</button><br>자주 사용되는 헤더 필드 접근 메서드 : getContentEncoding, getContentLength, getContentType, getDate, getExpiration, getLastModified</p></ol><h3>HttpURLConnection</h3><ol><li>HttpURLConnection은 요청을 1회만 하지만, 기저 네트워크 연결은 다른 인스턴스가 공유할 수 있다</li><li>public static final int HTTP_OK, HTTP_BAD_REQUEST, HTTP_NOT_FOUND, ...</li><li>int getResponseCode()<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/net/HttpURLConnectionTest.java" lan="java">HttpURLConnectionTest.java</button></li></ol><h3>JarURLConnection</h3><ol><li>원격지 jar에 대한 연결을 제공한다</li><li>JarEntry 표기 : jar:http://www.foo.com/bar/baz.jar!/COM/foo/Quux.class</li><li>JarFile 표기 : jar:http://www.foo.com/bar/baz.jar!/</li><li>Jar directory 표기 : jar:http://www.foo.com/bar/baz.jar!/COM/foo/</li></ol></div><h2>Socket</h2><div><h3>SocketOptions</h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">@Native static final int SO_REUSEPORT
    // 여러 소켓이 같은 주소와 포트를 listen할 수 있는지 여부
@Native static final int SO_LINGER
    // TCP 소켓 linger-on-close timeout 설정. 0이면 즉시 강제 종료. 양수면 최대 65,535까지 종료 대기. 그 외엔 일반적인 종료 절차
@Native static final int SO_TIMEOUT
    // ServerSocket::accept, SocketInputStream::read, DatagramSocket::receive에 대한 timeout 설정. 사용하기 전에 미리 설정돼야 한다
@Native static final int SO_SNDBUF
    // 전송 버퍼 크기에 대한 힌트 + SO_RCVBUF
@Native static final int SO_KEEPALIVE
    // TCP 연결에서 2시간(실제와 다를 수 있음) 동안 아무 교환이 없으면 keepalive probe를 보낸다. 응답이 ACK면 정상, RST면 상대가 리셋(리부트)되었으므로 연결 종료, 응답 없는 경우에도 연결 종료
@Native static final int SO_OOBINLINE
    // TCP 소켓에 설정되면 input stream을 통해 긴급 데이터(1바이트)를 받을 수 있다. 설정되지 않으면(기본) 버려진다
void setOption(int optID, Object value)
    // + getOption, ...
</div><h3>Socket</h3><p>TCP 클라이언트 소켓<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/net/SocketTest.java" lan="java">SocketTest.java</button></p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">void connect(SocketAddress endpoint, int timeout)
void bind(SocketAddress bindpoint)

SocketChannel getChannel()
    // SocketChannel::open 또는 ServerSocketChannel::accept로 생성된 경우에만 존재
InputStream getInputStream() + getOutputStream

&lt;T> Socket setOption(SocketOption&lt;T> name, T value)
&lt;T> T getOption(SocketOption&lt;T> name)
Set&lt;SocketOption&lt;?>> supportedOptions()
</div><h3>ServerSocket</h3><p>TCP 서버 소켓<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/net/SocketTest.java" lan="java">SocketTest.java</button></p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">public ServerSocket(int port)
    // port 0은 자동 할당. 들어오는 연결 큐의 크기(backlog)는 50

void bind(SocketAddress endpoint)
Socket accept()
ServerSocketChannel getChannel()
    // ServerSocketChannel::open으로 생성된 경우에만 존재

static void setSocketFactory(SocketImplFactory fac)
void setPerformancePreferences(int connectionTime, int latency, int bandwidth)

&lt;T> ServerSocket setOption(SocketOption&lt;T> name, T value)
&lt;T> T getOption(SocketOption&lt;T> name)
Set&lt;SocketOption&lt;?>> supportedOptions()
</div><h3>DatagramSocket</h3><p>UDP 소켓을 정의한다</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">void bind(SocketAddress addr)
void connect(InetAddress address, int port)
    // 기본적으로 UDP 데이터그램 소켓은 연결이 없다. 이 메서드로 원격지에 연결하는순간, 소켓은 해당 원격지와만 통신할 수 있다
    // 원격지와 연결하면 다음 메서드들이 동작한다. getInetAddress(), getPort(), getRemoteSocketAddress()

void send(DatagramPacket p)
void receive(DatagramPacket p)

void setTrafficClass(int tc) + getTrafficClass
    // 0&lt;=tc&lt;=255. IPv4에서, 하위 8개 비트를 IP 패킷의 TOS에 쓴다
    // IPv6에서, IP 헤더의 sin6_flowinfo 필드에 들어간다
    // RRC 1349의 TOS 값 정의
    //     IPTOS_LOWCOST(0x02), IPTOS_RELIABILITY(0x04), IPTOS_THROUGHPUT(0x08), IPTOS_LOWDELAY(0x10)

DatagramChannel getChannel()
    // DatagramChannel::open으로 생성된 경우에만 존재

static void setDatagramSocketImplFactory(DatagramSocketImplFactory fac)

&lt;T> DatagramSocket setOption(SocketOption&lt;T> name, T value)
    // + getOption, 각종 옵션 setter/getter
Set&lt;SocketOption&lt;?>> supportedOptions()
</div><h3>MulticastSocket</h3><ol><li>멀티캐스트 데이터그램 소켓을 제공한다</li><li>멀티캐스트 그룹 ::= Class D IP 주소 + UDP 포트</li><p>Class D ::= (224.0.0.0, 239.255.255.255]</p><li>멀티캐스트 그룹에 데이터그램을 보내면 모든 구독자들이 받게 된다</li><p>멀티캐스트 그룹의 멤버가 아니라도 멀티캐스트 데이터그램을 보내는 것은 가능하다</p></ol><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">// JavaDoc 예시
var group = InetAddress.getByName("228.5.6.7");
var s = new MulticastSocket(6789);
s.joinGroup(group);
var msg = "hello".getBytes();
s.send(new DatagramPacket(msg, msg.length, group, 6789));
var buf = new byte[1000];
s.receive(new DatagramPacket(buf, buf.length));
s.leaveGroup(group);
</div><h3>DatagramPacket</h3><ol><li>UDP 패킷을 정의한다. 송신용 생성자는 byte[]와 길이 정보가 필요하고, 수신용 생성자는 주소 정보가 추가로 필요하다</li><li>패킷 데이터, 길이, 주소 각각에 대한 getter/setter 제공</li></ol></div><h2>URI</h2><div><h3>URI</h3><div><h4>URI syntax and components</h4><ol><li>syntax : [scheme:]scheme-specific-part[#fragment]</li><li>Absolute URI : 스킴을 명시한 URI</li><li>Relative URI : Not absolute URI</li><li>Opaque URI : scheme-specific-part가 '/'로 시작하지 않는 absolute URI</li><p>예: "mailto:java-net@java.sun.com", "urn:isbn:096139210x"</p><li>Hierarchical URI : scheme-specific-part가 '/'로 시작하는 absolute or relative URI</li><p>[scheme:][//authority][path][?query][#fragment]<br>예: "http://example.com/languages/java", "sample/a/index.html#28", "../../demo/b/index.html"</p><li>Server-based authority : [user-info@]host[:port]</li><li>Registry-based authority : not server-based authority</li></ol><h4>Operations on URI instances</h4><ol><li>Normalization : "."과 ".."을 제거</li><li>Resolution : 상대 URI와 base URI를 이용해 단일 URI를 찾는 작업</li><li>Relativization : Resolution의 역</li><p>임의의 정규화된 두 URI u, v에 대하여, u.relativize(u.resolve(v)).equals(v)와 u.resolve(u.relativize(v)).equals(v)는 항상 성립한다</p></ol></div><h3>URL</h3><p>인스턴스 생성 시, URI와 다르게 정의된 scheme에 대한 핸들러를 찾기 때문에, 핸들러를 찾지 못하면 예외가 발생한다<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/net/HttpURLConnectionTest.java" lan="java">HttpURLConnectionTest.java</button></p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">boolean sameFile(URL other) : fragment(#) 제외하고 같은 파일인지 여부
URI toURI()

URLConnection openConnection()
final InputStream openStream() // == openConnection().getInputStream()
final Object getContent()      // == openConnection().getContent()
</div><h3>URLDecoder</h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static String decode(String s, Charset charset)</div><h3>URLEncoder</h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static String encode(String s, Charset charset)</div><h3>URLClassLoader</h3><p>URL을 이용한 클래스 로더를 제공한다</p></div><h2>NetworkInterface</h2><p>이름과 할당된 IP 주소들로 구성된 Network Interface 표현<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/net/NetworkInterfaceTest.java" lan="java">NetworkInterfaceTest.java</button></p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static Stream&lt;NetworkInterface> networkInterfaces()
    // + getNetworkInterfaces

Stream&lt;InetAdress> inetAddresses()
    // + getInetAddresses
byte[] getHardwareAddress()
    // 보통 MAC 주소
</div></div><h1>java.nio</h1><div><h2>버퍼 관련</h2><div><h3>Buffer</h3><ol><li>버퍼는 일련의 유한한 기본 자료형 원소들의 나열</li><ul><li>Capacity : 저장하고 있는 원소들의 개수</li><li>Limit : 읽거나 쓸 수 없는 최초의 인덱스. 0보다 작거나 capacity보다 클 수 없다</li><li>Position : 다음에 읽거나 쓸 대상의 인덱스. 0보다 작거나 limit보다 클 수 없다</li><li>0&lt;=mark&lt;=position&lt;=limit&lt;=capacity // 마킹은 지원되지 않을수도 있다</li></ul><li>get/put 연산의 Relative/Absolute 구분</li><ul><li>Relative : 버퍼의 현재 Position에 대한 연산</li><li>Absolute : 버퍼의 특정 위치를 지정한 연산</li></ul><li>Additional operations</li><ul><li>clear() : 새로운 채널-읽기 또는 relative put 연산을 준비; limit을 capacity로, position을 0으로</li><li>flip() : 새로운 채널-쓰기 또는 relative get 연산을 준비; limit을 position으로, position을 0으로</li><li>rewind() : 이미 읽은 것을 다시 읽도록; limit은 그대로, position을 0으로</li><li>slice() : 기존 버퍼의 부분 시퀀스 생성</li><li>duplicate() : 기존 버퍼의 얕은 복사본 생성</li></ul></ol><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">abstract boolean hasArray()
    // 기저 배열의 존재 유무. true면 array()와 arrayOffset() 사용가능
abstract boolean isDirect()
    // Direct 버퍼(즉시 읽기/쓰기)인지 여부

abstract Buffer slice()
    // 현재 버퍼의 현재 위치부터 시작하는 부분 버퍼 생성(내용 공유). direct, read-only 속성을 공유
abstract Buffer duplicate()
    // 복사본(내용 공유) 반환
</div><h3>ByteBuffer</h3><ol><li>다음 연산을 정의</li><ul><li>바이트 하나에 대한 absolute/relative get/put</li><li>바이트 시퀀스에 대한 bulk get/put</li><li>다른 원시 타입에 대한 absolute/relative get/put</li><li>다른 원시 타입으로 읽기 가능한 view 버퍼 생성</li><li>compact : 인덱스 [0, position) 사이의 데이터가 버려진다(Optional operation)</li></ul><li>Direct 버퍼</li><p>읽기/쓰기 연산이 직접적으로 이루어지며, 별개의 복사본을 이용하는 non-direct 버퍼에 비해 할당/제거 비용이 크다. Direct 버퍼는 allocateDirect 팩토리 메서드로 생성된다</p><li>Access to binary data</li><p>버퍼의 byte order는 해당 버퍼에 대한 연산의 기준이 된다. 기본값은 ByteOrder.BIG_ENDIAN</p><li>인덱싱</li><p>ByteBuffer인덱스를 지정하는 absolute get/put의 인덱스는 바이트 단위다. 뷰 버퍼의 인덱스는 해당 타입 크기 단위다</p><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/nio/ByteBufferExample.java" lan="java">ByteBufferExample.java</button></ol><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">abstract byte get(int index)
ByteBuffer get(byte[] dst, int offset, int length)
ByteBuffer put(ByteBuffer src)

abstract CharBuffer asCharBuffer() // + short, int, long, float, double

final int alignmentOffset(int index, int unitSize)
    // index % unitSize를 반환한다. 0이 아니면 unitSize 단위로 자르기 부적합하다는 의미. unitSize는 2의 거듭제곱이어야 한다
final ByteBuffer alignedSlice(int unitSize)
    // 현재 버퍼를 unitSize 크기씩 잘라 view 버퍼를 생성(BIG_ENDIAN)한다
    // 현재 위치가 unitSize의 배수가 아니라면 바로 다음 배수 위치부터 포함하며, limit도 unitSize 배수에 맞춰 끊는다

int mismatch(ByteBuffer that)
    // 두 바이트 버퍼의 현재 읽기 위치들을 시작 위치로 하여, 바이트 값이 다른 최초 index를 반환한다
</div><h3>MappedByteBuffer</h3><p>FileChannel::map 메서드로 생성되는 direct 바이트 버퍼. 기저 파일이 (외부에서) 변경되면 버퍼 내용도 변경된다. 역도 성립</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">final BappedByteBuffer load()  // 파일 내용을 메모리에 적재한다
final MappedByteBuffer force() //강제로 버퍼 변경 내용을 파일에 쓴다
</div><h3>CharBuffer</h3><ol><li>+ ShortBuffer, DoubleBuffer</li><li>다음 연산을 정의</li><ul><li>단일 char에 대한 absolute/relative get/put</li><li>char 시퀀스에 대한 bulk get/set</li><li>compact : ByteBuffer의 설명과 동일</li></ul></ol></div><h2>ByteOrder</h2><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">public static final ByteOrder BIG_ENDIAN, LITTLE_ENDIAN
static ByteOrder nativeOrder()
</div></div><h1>java.nio.channels</h1><div><h2>채널 인터페이스</h2><div><h3>Channel</h3><p>채널이란 독립적인 IO를 수행할 수 있는 개체에 대한 연결이다</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">boolean isOpen()</div><h3>ReadableByteChannel</h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">int read(ByteBuffer dst)
    // dst.remaining()만큼 읽어 dst에 저장. 읽은 바이트 개수를 반환. 스트림의 끝이면 -1
</div><h3>WritableByteChannel</h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">int write(ByteBuffer src)
    // src.remaining() 부분을 채널에 쓴다
</div><h3>ByteChannel</h3><p>바이트 단위 읽기/쓰기 모두 가능한 채널</p><h3>AsynchronousChannel</h3><p>비동기 I/O를 지원하는 채널. close()도 비동기적으로 수행되며, 도중/이후 작업은 AsynchronousCloseException 발생시키면 된다</p><h3>InterruptibleChannel</h3><p>"instanceof InterruptibleChannel" IFF "비동기적으로 close() 메서드를 통해 인터럽트되고 닫을 수 있는 채널"</p><h3>AsynchronousByteChannel</h3><p>비동기 IO를 지원하는 바이트 채널</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">&lt;A> void read(ByteBuffer dst, A attachment, CompletionHandler&lt;Integer, ? super A> handler)
    // 기본 동작은 ReadableByteChannel::read와 동일. 쓰기가 완료(실패)되면 handler가 호출된다. handler에 전달될 첫 인자는 읽은 바이트 수
Future&lt;Integer> read(ByteBuffer dst)
    // 반환된 Future::get 메서드로 읽은 바이트 수를 얻을 수 있다
</div><h3>ScatteringByteChannel</h3><p>채널의 바이트들을 여러 버퍼에 순서대로 저장. 네트워크 헤더나 파일 메타데이터처럼 고정 길이의 헤더를 읽는 데 유용</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">long read(ByteBuffer[] dsts, int offset, int length)
    // dsts[offset]부터 length개의 버퍼가 각각의 remaining()만큼씩 바이트를 읽어 가져간다
</div><h3>GatheringByteChannel</h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">long write(ByteBuffer[] srcs, int offset, int length)
    // srcs[offset]부터 length개의 버퍼의 remaining() 부분을 채널에 쓴다
</div><h3>SeekableByteChannel</h3><p>현재 위치를 기억하는 바이트 채널</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">SeekableByteChannel truncate(long size)
    // 채널에 연결된 개체의 크기를 size로 조정. size가 현재보다 작은 경우 나머지는 버려진다(position이 size보다 큰 경우 size로 조정된다). size가 현재 이상인 경우 아무 변경 없다
</div><h3>NetworkChannel</h3><p>네트워크 소켓에 대한 채널</p><h3>MulticastChannel</h3><p>IP 계층 멀티캐스팅 가능한 채널</p></div><h2>비동기 채널 관련</h2><div><h3>CompletionHandler&lt;V, A></h3><p>비동기 I/O 작업의 결과를 소비하는 소비자</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">void completed(V result, A attachment)   // 성공시 호출
void failed(Throwable exc, A attachment) // 실패시 호출
</div><h3>AsynchronousChannelGroup</h3><p>그룹 지정되지 않은 비동기 채널들은 시스템 기본 그룹에 묶인다</p><p>시스템 속성에 따라 생성된 ThreadFactory가 비동기 작업을 실행할 데몬 스레드들을 만든다</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static AsynchronousChannelGroup withFixedThreadPool(int nThreads, ThreadFactory threadFactory)
    // 최대 nThreads의 스레드만 동시에 실행된다. 시스템 기본 AsynchronousChannelProvider 객체의 openAsynchronousChannelGroup(int, ThreadFactory) 메서드를 통해 만들어진다
static AsynchronousChannelGroup withCachedThreadPool(ExecutorService executor, int initialSize)
    // 시스템 기본 AsynchronousChannelProvider 객체의 openAsynchronousChannelGroup(ExecutorService, int) 메서드를 통해 만들어진다
    // 채널 그룹의 종료(shutdown)는 ExecutorService의 shutdown()으로 이어진다. 따라서 ExecutorService가 외부에서 닫히는 경우엔 무슨 일이 일어날 지 모른다

abstract void shutdown()
    // 순차적 종료 절차에 진입한다
abstract void shutdownNow()
    // shutdown() + 모든 열린 채널들을 닫는다. 실행 중인 CompletionHandler들은 끝날 때까지 기다린다. 도중에 다른 스레드에서 이 메서드를 호출하는 경우, 현재 작업이 완료될 때까지 블록된다; 더 불러도 추가 작업은 없다
abstract boolean awaitTermination(long timeout, TimeUnit unit)
</div><h3>AsynchronousFileChannel</h3><ol><li>파일에 대한 비동기 채널. I/O의 기준이 되는 현재 위치를 갖고 있지 않으며, 메서드에서 지정한다</li><li>생성된 채널들은 스레드-안전하며, 완료 핸들러들은 별개의 스레드에서 실행됨이 보장된다</li><p>연산에 사용되는 ByteBuffer 자체는 스레드-안전하지 않음에 유의</p></ol><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static AsynchronousFileChannel open(Path file, Set&lt;? extends OpenOption> options, ExecutorService executor, FileAttribute&lt;?>... attrs)
    // 파일을 열거나 생성한 뒤 비동기 채널을 하나 반환한다. options에는 java.nio.file.StandardOpenOption을 이용하면 된다

abstract AsynchronousFileChannel truncate(long size)
    // size() > size인 경우 파일을 자른다. return this;

abstract void force(boolean metaData)
    // 메서드 호출 시점부터 true면 StandardOpenOption.SYNC를, false면 StandardOpenOption.DSYNC를 적용하는 것과 같다. 기저 파일이 로컬에 존재하는 경우에만 유효하다

abstract &lt;A> void lock(long position, long size, boolean shared, A attachment, CompletionHandler&lt;FileLock, ? super A> handler)
    // 기저 파일 일부에 대한 잠금을 얻는다. handler는 잠금을 얻는 데 성공/실패하면 호출된다. 잠금 size는 고정이므로, 파일 크기가 커질 것도 고려하여 필요한 만큼 신청해놔야 한다
abstract FileLock tryLock(long position, long size, boolean shared)
    // 스레드를 블록하지 않는다. OverlappingFileLockException에 해당하는 상황에는 null이 반환된다

abstract &lt;A> void read(ByteBuffer dst, long position, A attachment, CompletionHandler&lt;Integer, ? super A> handler)
    // handler에 전달되는 Integer는 읽은 바이트 길이, 또는 -1(position > size())
abstract &lt;A> void write(ByteBuffer src, long position, A attachment, CompletionHandler&lt;Integer, ? super A> handler)
    // position > size()인 경우, 그 사이 바이트 값은 쓰레기 값이다
</div><h3>AsynchronousServerSocketChannel</h3><ol><li>스트림 지향 읽기 소켓 채널<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/nio/AsynchronousSocketChannelTest.java" lan="java">AsynchronousSocketChannelTest.java</button></li><li>스레드-안전하지만 최대 accept 가능한 스레드는 하나 뿐이며, accept 도중 중복되는 요청은 AcceptPendingException</li><li>지원하는 소켓 옵션 : SO_RCVBUF(수신 버퍼 크기), SO_REUSEADDR(주소 재사용); 구현에 따라 추가될 수도 있다</li></ol><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static AsynchronousServerSocketChannel open(AsynchronousChannelGroup group)
    // group을 지정하지 않거나 null로 설정하는 경우 시스템 기본 그룹이 이용된다

final AsynchronousServerSocketChannel bind(SocketAddress local, int backlog)
    // backlog는 소켓에 대한 최대 pending connection 수. 0이나 음수로 설정하면 구현체의 기본값을 이용한다. return this;

abstract &lt;A> void accept(A attachment, CompletionHandler&lt;AsynchronousSocketChannel, ? super A> handler)
    // 신규 연결된 AsynchronousSocketChannel은 현재 채널과 동일한 채널 그룹에 묶인다. 그룹이 닫힌 경우, 신규 연결도 닫히고 ShutdownChannelGroupException
</div><h3>AsynchronousSocketChannel</h3><ol><li>스트림 지향 소켓 채널. open 팩터리 메서드로 직접 열거나(Unbound), AsynchronousServerSocketChannel::accept로 열 수(Bound) 있다<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/nio/AsynchronousSocketChannelTest.java" lan="java">AsynchronousSocketChannelTest.java</button></li><li>스레드-안전하지만 최대 하나의 읽기/쓰기만 각각 동시에 존재할 수 있다</li><p>도중에 중복되는 요청은 각각 ReadPendingException, WritePendinException 발생</p><li>지원하는 소켓 옵션 : SO_SNDBUF(전송 버퍼 크기), SO_RCVBUF(수신 버퍼 크기), SO_KEEPALIVE(기본 false, keep-alive 작동은 구현체에 의존적이다), TCP_NODELAY(Nagle 알고리즘 비활성)</li><li>읽기/쓰기 시 양수의 타임아웃을 지정한 경우, 시간 내에 완료되지 못하면 InterruptedByTimeoutException으로 종료되고, 이후 상태는 비결정적이며, 따라서 사용된 채널, 버퍼들은 버리는 게 낫다</li></ol><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static AsynchronousSocketChannel open(AsynchronousChannelGroup group)
    // group이 지정되지 않거나 null인 경우, 시스템 기본 그룹이 이용된다

abstract AsynchronousSocketChannel shutdownInput()
    // 채널을 더 이상 읽을 수 없게 한다. 이후의 읽기는 모두 -1을 반환한다. return this;
abstract AsynchronousSocketChannel shutdownOutput()
    // 채널을 더 이상 쓸 수 없게 한다. 이후의 쓰기는 모두 ClosedChannelException ─ 읽기는 가능할 수 있다 ─ 으로 종료된다

abstract &lt;A> void connect(SocketAddress remote, A attachment, CompletionHandler&lt;Void, ? super A> handler)

abstract &lt;A> void read(ByteBuffer dst, long timeout, TimeUnit unit, A attachment, CompletionHandler&lt;Integer, ? super A> handler)
    // ScatteringByteChannel::read와 유사한 메서드도 지원한다
abstract &lt;A> void write(ByteBuffer src, long timeout, TimeUnit unit, A attachment, CompletionHandler&lt;Integer, ? super A> handler)
    // GatheringByteChannel::write와 유사한 메서드도 지원한다
</div></div><h2>채널 클래스</h2><div><h3>Channels</h3><p>채널과 스트림에 관한 유틸리티 클래스</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static InputStream newInputStream(ReadableByteChannel ch)
    // 채널이 논-블로킹 모드면 읽기 시 예외 발생. 버퍼링, mark/reset 미지원. 스레드-안전. 닫으면 채널도 닫힌다
static OutputStream newOutputStream(WritableByteChannel ch)
    // 채널이 논-블로킹 모드면 쓰기 시 예외 발생. 버퍼링 미지원. 스레드-안전. 닫으면 채널도 닫힌다
static InputStream newInputStream(AsynchronousByteChannel ch)
    // 버퍼링, mark/reset 미지원. 스레드-안전. 닫으면 채널도 닫힌다
static OutputStream newOutputStream(AsynchronousByteChannel ch)
    // 버퍼링 미지원. 스레드-안전. 닫으면 채널도 닫힌다

static ReadableByteChannel newChannel(InputStream in)
    // 버퍼링 미지원. 닫으면 스트림도 닫힌다
static WritableByteChannel newChannel(OutputStream out)
    // 버퍼링 미지원. 닫으면 스트림도 닫힌다
static Reader newReader(ReadableByteChannel ch, Charset charset)
    // 채널이 논-블로킹 모드면 읽기 시 예외 발생. 버퍼링 지원. mark/reset 미지원. 닫으면 채널도 닫힌다
static Writer newWriter(WritableByteChannel ch, Charset charset)
    // 채널이 논-블로킹 모드면 쓰기 시 예외 발생. 버퍼링 지원. 닫으면 채널도 닫힌다
</div><h3>FileChannel</h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">abstract MappedByteBuffer map(FileChannel.MapMode mode, long position, long size)
    // 매핑 : 파일의 일부분을 메모리에 올려놓고 작업. 큰 파일은 이쪽이 효율이 좋다
    // READ_ONLY : 변경 불가, READ_WHITE : 변경이 기저 파일에 전파, PRIVATE : 변경이 전파되지 않음
</div><h3>ServerSocketChannel</h3><p>스트림-지향 읽기 소켓 채널. AsynchronousServerSocketChannel 참고</p><h3>SocketChannel</h3><p>스트림-지향 소켓 채널. AsynchronousSocketChannel 참고</p><h3>DatagramChannel</h3><ol><li>데이터그램-지향 소켓 채널</li><li>기존 데이터그램 소켓에서 채널을 얻는 방법은 없으며, open 팩터리 메서드로 획득해야 한다</li><li>send/receive 메서드는 연결없이 사용할 수 있지만, read/write 메서드는 connect 메서드를 통해 연결해야 이용할 수 있다</li><p>연결된 경우, 송/수신에 불필요한 보안 체크를 하지 않는다</p><li>지원하는 소켓 옵션 : SO_SNDBUF, SO_RCVBUF, SO_REUSEADDR, SO_BROADCAST, IP_TOS, IP_MULTICAST_IF, IP_MULTICAST_TTL, IP_MULTICAST_LOOP</li></ol><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static DatagramChannel open()
    // IP 멀티캐스팅에 이용하려는 경우, 멀티캐스트 그룹 타입을 ProtocolFamily에 지정해줘야 한다
</div><h3>SelectableChannel</h3><ol><li>스레드-안전. Selector를 통해 멀티플렉싱될 수 있는 채널을 정의한다</li><li>Selector에 등록함으로써 SelectionKey가 발행된다. 나가는 건 마음대로 할 수 없다</li><p>채널이 닫히면 채널에 대한 모든 SelectionKey들은 cancel된다</p><li>각 Selector에는 최대 한 번씩만 등록할 수 있다. Selector가 닫히면 등록된 모든 채널이 내려가고, 각 키들은 즉시 무효하게 된다</li><li>Non-blocking mode</li><p>새로 생성된 SelectableChannel은 블로킹 모드지만, configureBlocking(boolean) 메서드로 모드를 변경할 수 있다. 이 경우, Selector에 등록하기 전에 논-블로킹으로 설정해야 하며, 한 번 등록되면 등록 취소되기 전까지 논-블로킹 모드로 작동한다<br>논-블로킹 모드에서는 I/O 연산이 절대 블로킹되지 않지만, 요청보다 적은 데이터가 보내지거나 아예 전송되지 않을 수 있다</p></ol><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">abstract SelectorProvider provider()
    // 이 채널을 생성한 provider를 반환한다

abstract SelectableChannel configureBlocking(boolean block)
    // 이미 어느 Selector에 등록된 채널이라면 논-블로킹 설정 시 IllegalBlockingModeException 발생

abstract Object blockingLock()
    // configureBlocking, register 메서드에서 동기화에 이용되는 객체를 반환한다
</div></div><h2>Pipe</h2><ol><li>2개 채널로 이루어진 단방향 파이프를 정의한다</li><p>SinkChannel : 쓰기 전용, SourceChannel : 읽기 전용</p></ol><h2>FileLock</h2><ol><li>Adivisory Lock : 응용 프로그램이 잠금을 직접 확인하고, 알아서 읽기/쓰기를 수행할 지 결정한다</li><li>Mandatory Lock : 커널이 잠금을 관리하기 때문에, 관련되지 않은 프로세스는 접근 불가</li><p>모든 잠금을 Adivisory Lock으로 간주하여 관리함이 바람직하다</p><li>On some systems, 잠금의 존재로 인해 매핑(FileChannel::map)이 불가능할 수 있음에 유의</li><li>On some systems, 채널을 닫으면 해당 파일에 대한 모든 잠금이 해제될 수 있음에 유의</li><li>Some network filesystems, 잠금 영역 크기가 하드웨어 페이지 크기의 배수인 경우에만 매핑을 지원함에 유의</li><li>Some network filesystems, 2^30 또는 2^31 이상 크기에 대한 잠금을 지원하지 않음에 유의</li></ol><h2>MembershipKey</h2><p>IP 멀티캐스트 그룹에 대한 멤버십을 표현한다</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">abstract boolean isValid()
abstract void drop()
abstract InetAddress group()
abstract MulticastChannel channel()
    // 이 멤버십 키를 생성한 채널을 반환한다
abstract InetAddress sourceAddress()
    // 특정 소스의 데이터그램만 수신하는 멤버십(Source-specific membership key)인 경우, 유효한 주소를 반환한다
abstract MembershipKey block(InetAddress source) + unblock
    // OS가 소스 필터링을 적용하지만, 적용되지 않은 멤버십에 대하여 이를 호출하면 특정 소스를 차단할 수 있다
abstract NetworkInterface networkInterface()
</div><h2>Selector</h2><ol><li>SelectableChannel에 대한 멀티플렉서. 스레드-안전</li><li>SelectableChannel을 등록하면 SelectionKey가 발행되며, 3가지 집합으로 관리된다</li><ul><li>Key set : 현재 등록된 채널들에 관한 키. SelectableChannel::register 메서드로 등록. Selector::keys 메서드로 획득</li><li>Selected-key set : 선택 연산에 의해, 최소 하나의 연산에 대해 ready 상태로 파악된 키. 자동 등록(수동 삭제만 가능). selectedKeys 메서드로 획득</li><li>Cancelled-key set : 취소되었지만 채널은 아직 등록되어 있는 키</li></ul><li>선택 연산에는 2가지 종류가 있다</li><ul><li>select(), select(long), selectNow() : 지정된 연산에 대해 준비된 상태인지 확인하여 selected-key set 업데이트</li><ol><li>Cancelled-key set의 멤버들에 대해, 키 집합에서 제거하고 채널을 등록 취소한다. 결과적으로 cancelled-key set은 비게 된다</li><p>아래 작업 중 Cacelled-key set에 추가된 키들에 대해서도 추가로 작업한다</p><li>Selected-key set에 없는 키에 대해, 키의 interest set의 연산 중 하나라도 준비되었다면 selected-key set으로 추가되고, 키의 ready set이 설정된다</li><li>Selected-key set에 있는 키에 대해, 키의 ready set 외의 연산 중 준비된 것들은 ready set으로 추가된다</li></ol><li>select(Consumer), select(Consumer, long), selectNow(Consumer) : 준비된 채널들에 대해 작업 실행. selected-key set을 업데이트하지 않음</li><ol><li>Cancelled-key set의 멤버들에 대한 작업은 전과 같다</li><p>마찬가지로 아래 작업 중 Cacelled-key set에 추가된 키들에 대해서도 추가로 작업한다</p><li>키의 ready set이 최소 하나의 연산에 대해 준비되었다면, ready set은 준비된 연산들로만 설정되고, 주어진 Consumer가 키를 소비한다</li><p>키의 ready set이 2개 이상의 연산에 대해 준비되었다면, Consumer는 여러 번 호출될 수 있다. Consumer를 호출하기 전에 ready set에서 해당 연산을 빼기 때문에, 한 번의 선택 연산에서 같은 연산에 대해 2번 호출되지 않는다</p></ol></ul><li>선택 연산에서 사용되는 키의 interest set은 연산의 시작 시점의 것으로, 중간에 변경됐다면 다음 선택 연산에 적용된다</li><li>키와 채널은 언제든 닫힐 수 있으므로, 사용 시 다른 스레드에서 키나 채널을 닫는지 유의해야 한다</li></ol><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">abstract int selectNow()
    // 논-블로킹으로 선택한다. 선택 연산으로 ready set이 업데이트된 키의 수를 반환한다. 이전 wakeup()의 영향을 제거한다
abstract int select(long timeout)
    // 블로킹으로 선택한다. timeout이 지정되지 않은 경우엔 무기한. 적어도 하나의 채널이 선택되면 반환한다
int selectNow(Consumer&lt;SelectionKey> action)
    // 논-블로킹으로 키를 소비한다. 소비된 유니크한 키의 개수를 반환한다. 이전 wakeup()의 영향을 제거한다
int select(Consumer&lt;SelectionKey> action, long timeout)
    // 블로킹으로 키를 소비한다. 소비된 유니크한 키의 개수를 반환한다. 시간 초과 되거나, 적어도 하나의 채널이 선택되면 wakeup()으로 깨어난다
abstract Selector wakeup()
    // 아직 반환하지 않은 선택 연산이 즉시 반환하도록 한다. 현재 실행 중인 선택 연산이 없다면 다음 선택 연산(selectNow 제외)에 대해 적용된다
</div><h2>SelectionKey</h2><ol><li>SelectableChannel이 Selector에 등록됨을 나타내는 토큰. 채널이나 Selector가 닫히면서 cancel 메서드로 닫히기 전까지 유효</li><li>각 SelectionKey는 2가지 연산 집합을 갖는다. 각 집합은 int로 표현되고, 설정된 비트는 채널이 해당 연산을 지원함을 의미한다</li><ul><li>Interest set : Selector의 선택 연산에서 ready 상태인지 검사될 연산 집합. 최초 채널 등록 시 제공된 int값이며, interestOps(int)로 변경할 수 있다</li><li>Ready set : 키의 채널이 ready 상태인 연산들의 집합. 최초 생성 시 0이며, Selector의 선택 연산으로 변경된다. 직접 변경할 수는 없다</li></ul><li>이 클래스에서 공통적인 지원 연산에 대해 정의하지만, 각 SelectableChannel의 서브 클래스에서 제공하는 validOps()가 정확하다</li></ol><div><h3>Field Detail</h3><ol><li>static final int OP_READ</li><p>Selector의 선택 연산 시 interest set에 포함되어 있을 때. 채널이 읽기 가능하거나, end-of-stream에 도달했거나, 원격지에서 닫았거나, 에러 대기 상태면 ready set에 추가</p><li>static final int OP_WRITE</li><p>Selector의 선택 연산 시 interest set에 포함되어 있을 때. 채널이 쓰기 가능하거나, 원격지에서 닫았거나, 에러 대기 상태만 ready set에 추가</p><li>static final int OP_CONNECT</li><p>Selector의 선택 연산 시 interest set에 포함되어 있을 때, 채널이 연결 완료될 수 있거나, 에러 대기 상태면 ready set에 추가</p><li>static final int OP_ACCEPT</li><p>Selector의 선택 연산 시 interest set에 포함되어 있을 때. 서버 채널이 연결을 허용할 수 있거나, 에러 대기 상태면 ready set에 추가</p></ol></div></div><h1>java.nio.charset</h1><div><h2>Charset</h2><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static SortedMap&lt;String, Charset> availableCharsets()
static boolean isSupported(String charsetName)
static Charset forName(String charsetName)
static Charset defaultCharset()

boolean canEncode()
abstract CharsetDecoder newDecoder()   // + newEncoder
final CharBuffer decode(ByteBuffer bb) // + encode
</div><h2>CharsetDecoder</h2><p>바이트열을 문자열로 변환</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">final CharBuffer decode(ByteBuffer in)
final CoderResult decode(ByteBuffer in, CharBuffer out, boolean endOfInput)

final float averageCharsPerByte() // + maxCharsPerByte
</div><h2>CharsetEncoder</h2><p>문자열을 바이트열로 변환</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">final ByteBuffer encode(CharBuffer in)
final CoderResult encode(CharBuffer in, ByteBuffer out, boolean endOfInput)

final float averageBytesPerChar() // + maxBytesPerChar
</div><h3>StandardCharsets</h3><p>표준 문자집합 : US-ASCII(= ISO646-US), ISO-8859-1(= ISO-LATIN-1), UTF-8, UTF-16BE, UTF-16LE, UTF-16</p></div><h1>java.nio.file</h1><div><h2>파일 감시 관련</h2><div><h3>Watchable</h3><p>WatchService에 등록되어 그 변화나 이벤트가 감시될 수 있는 객체. 정의된 register 메서드는 등록되었음을 WatchKey 객체로 반환한다</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">WatchKey register(WatchService watcher, WatchEvent.Kind&lt;?>... events)</div><h3>WatchEvent&lt;T></h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">WatchEvent.Kind&lt;T> kind()
int count() // 1보다 크면 반복 이벤트
T context()</div><div><h4>WatchEvent.Kind&lt;T></h4><p>식별을 위한 이벤트 종류</p><h4>WatchEvent.Modifier</h4><p>Watchable 객체가 어떻게 등록되었는지</p></div><h3>StandardWatchEventKinds</h3><ol><li>public static final WatchEvent.Kind&lt;Object> OVERFLOW : 자리가 없어 이벤트가 버려짐</li><li>public static final WatchEvent.Kind&lt;Path> ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY : 디렉터리 생성/삭제/변경</li></ol><h3>WatchKey</h3><ol><li>WatchService에 Watchable 객체가 등록되었음을 표현하는 토큰</li><li>처음 생성되면 ready 상태. 이벤트를 감지하면 reset()되기 전까지 signalled 상태가 되고, WatchService 큐에 진입하여 처리된다. reset()되면 다시 ready</li></ol><h3>WatchService</h3><p>스레드-안전. FileSystem::newWatchService 메서드로 획득한다</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">WatchKey poll()
    // 다음 WatchKey를 제거. 없으면 null
WatchKey poll(long timeout, TimeUnit unit)
    // 다음 WatchKey를 제거. 없으면 대기. timeout 후에도 없으면 null
WatchKey take()
    // 다음 WatchKey를 제거. 없으면 대기
</div></div><h2>파일 순회 관련</h2><div><h3>DirectoryStream&lt;T></h3><ol><li>Files::newDirectoryStream 메서드로 획득</li><li>일회용 이터러블이다. 2번째 호출부터는 IllegalStateException 발생</li></ol><h3>SecureDirectoryStream&lt;T></h3><ol><li>열린 디렉터리에 대한 상대 경로를 이용한 연산들을 추가로 지원한다</li><li>OS에서 이를 지원한다면, Files::newDirectoryStream 메서드로 획득한 DirectoryStream은 SecureDirectoryStream이다</li></ol><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">SecureDirectoryStream&lt;T> newDirectoryStream(T path, LinkOption... options)
    // path가 절대 경로면 Files::newDirectoryStream과 동일
SeekableByteChannel newByteChannel(T path, Set&lt;? extends OpenOption> options, FileAttribute&lt;?>... attrs)
    // path가 절대 경로면 Files::newByteChannel과 동일. path에 해당하는 파일을 열거나 만든 뒤, 파일에 대한 채널을 반환한다

void deleteFile(T path)
    // Files::delete와 다르게 path가 디렉터리인지 확인하지 않는다. 이로써 디렉터리가 실제로 지워지는 지는 시스템에 의존적이다. 심볼릭 링크의 경우 링크 자체만 지운다
void deleteDirectory(T path)
    // Files::delete와 다르게 path가 디렉터리인지 확인하지 않는다. 이로써 일반 파일이 지워지는 지는 시스템에 의존적이다
void move(T srcpath, SecureDirectoryStream&lt;T> targetdir, T targetpath)
    // ATOMIC_MOVE 옵션이 적용된 Files::move와 비슷하게 작업한다. 현재 디렉터리를 기준으로, 파일 하나를 다른 디렉터리에 대한 상대경로가 지정하는 위치에 원자적으로 옮긴다
</div><h3>FileVisitor&lt;T></h3><p>Files::walkFileTree 메서드에 사용</p><h3>SimpleFileVisitor&lt;T></h3><ol><li>preVisitDirectory : CONTINUE 반환</li><li>visitFile : CONTINUE 반환</li><li>visitFileFailed : rethrow</li><li>postVisitDirectory : 예외없으면 CONTINUE, 있으면 rethrows</li></ol><h3>FileVisitResult</h3><ol><li>CONTINUE : 순회 계속</li><li>TERMINATE : 순회 종료</li><li>SKIP_SUBTREE : FileVIsitor::preVisitDirectory에서 반환된 경우, 하위 레벨 트리는 순회하지 않는다</li><li>SKIP_SIBLINGS : 현재 요소가 포함된 디렉터리 내부에서, 현재 요소와 동일한 레벨의 요소들은 더 이상 순회하지 않는다</li><p>FileVIsitor::preVisitDirectory에서 반환된 경우, 현재 디렉터리의 내부 요소들과 postVisitDirectory 모두 건너뛴다</p></ol></div><h2>옵션 관련</h2><div><h3>CopyCption</h3><h3>StandardCopyOption</h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">REPLACE_EXISTING, COPY_ATTRIBUTES, ATOMIC_MOVE</div><h3>OpenOption</h3><h3>StandardOpenOption</h3><ol><li>READ : 읽기</li><li>WRITE : 쓰기</li><li>APPEND : TRUNCATE_EXISTING 옵션이 있거나 읽기 전용일 때는 적용되지 않는다</li><li>TRUNCATE_EXISTING : 파일을 열 때 크기를 0바이트로 줄인다. 읽기 전용으로 열 때는 적용되지 않는다</li><li>CREATE : 기존 파일이 존재하면 열고, 없으면 새로 생성한다</li><li>CREATE_NEW : 신규 파일을 생성한다. 기존 파일이 존재하면 실패한다</li><li>DELETE_ON_CLOSE : close() 호출 시 파일을 지운다(best effort)</li><li>SPARSE : 파일이 sparse임을 OS에 알려준다. 신규 파일을 생성하는 경우에만 유효하다</li><li>SYNC : 파일 내용 및 메타데이터의 변경을 동기적으로 물리 장치에 기록한다</li><li>DSYNC : 파일 내용 변경을 동기적으로 물리 장치에 기록한다</li></ol><h3>FileVisitOption</h3><p>FOLLOW_LINKS : 심볼릭 링크를 따라 들어가는 경우</p><h3>LinkOption</h3><p>NOFOLLOW_LINKS : 심볼릭 링크를 따라 들어가지 않는 경우</p></div><h2>파일 시스템 관련</h2><div><h3>Path</h3><p>파일 경로를 가리킨다. 사용자 정의 파일 시스템을 개발하기 위해 만들어짐<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/nio/PathTest.java" lan="java">PathTest.java</button></p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static Path of(String first, String... more)
    // 예. FileSystem::getSeparator == "/"일때, of("/foo", "bar", "gus") → "/foo/bar/gus"

static Path of(URI uri)
    // ↔ toUri

FileSystem getFileSystem()
    // 이 Path를 만든 FileSystem 반환
Path getRoot()
    // + getFileName, getParent, getNameCount, getName, subpath, toAbsolutePath, toRealPath

Path normalize()
    // 불필요한 ".", ".." 제거
Path resolve(Path other)
    // 호출한 path를 기준 디렉터리로 하여, other가 가리키는 지점을 단일 Path로 반환한다
default Path resolveSibling(Path other)
    // (getParent() == null) ? other : getParent().resolve(other);
Path relativize(Path other)
    // 호출한 path를 기준으로, other에 도달하는 상대경로를 반환한다
</div><h3>Files</h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static InputStream newInputStream(Path path, OpenOption... options)
    // + newOutputStream, newByteChannel, newBufferedReader, newBufferedWriter

static DirectoryStream&lt;Path> newDirectoryStream(Path dir, String glob)
    // 예. Files.newDirectoryStream(dir, "*.java"));
    // 예. Files.newDirectoryStream(dir, "*.{c,h,cpp,hpp,java}"));

static Path createFile(Path path, FileAttribute&lt;?>... attrs)
    // + createDirectory, createDirectories(경로 상의 모든 디렉터리 생성), createTempFile, createTempDirectory, createSymbolicLink, createLink(하드 링크)

static void delete(Path path)
    // + deleteIfExists, copy, move

static bolean isSameFile(Path path, Path path2)
static long mismatch(Path path, Path path2)
    // 두 파일이 불일치하는 최초의 바이트 위치를 반환한다. 같으면 -1L

static byte[] readAllBytes(Path path)
    // + readString Since 11, lines, readAllLines
static Path write(Path path, Iterable&lt;? extends CharSequence> lines, OpenOption... options)
static Path writeString(Path path, CharSequence csq, Charset cs, OpenOption... options) // Since 11

static boolean isHidden(Path path)
    // + isDirectory, isSymbolicLink, isRegularFile, exists, notExists, isReadable, isWritable, isExecutable
static String probeContentType(Path path)
    // + getFileAttributeView, readAttributes, getAttribute, setAttribute, getLastModifiedTime, setLastModifiedTime, size

static Stream&lt;Path> list(Path dir)
static Stream&lt;Path> walk(Path start, int maxDepth, FIleVisitOption... options)
    // + walkFileTree
static Stream&lt;Path> find(Path start, int maxDepth, BiPredicate&lt;Path, BasicFileAttributes> matcher, FIleVisitOption... options)
</div><h3>FileSystems</h3><p>FileSystem 팩터리</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static FileSystem getDefault()
static FileSystem getFileSystem(URI uri)
static FileSystem newFileSystem(Path path, ClassLoader loader)
</div></div></div><h1>java.security</h1><div><h2>암호적으로 안전한 난수 생성기</h2><div><h3>SecureRandomParameters</h3><p>SecureRandom 메서드 인자임을 나타내는 마커 인터페이스</p><h3>SecureRandom</h3><ol><li>비결정적인 출력을 위해, 전달되는 시드 역시 예측할 수 없어야 한다</li><p>시드를 제공하지 않은 경우, 최초 nextBytes 호출 시 구현체에서 정의하는 엔트로피 소스로부터 시드를 선택한다</p><li>SecureRandom 인스턴스는 스레드-안전하다</li><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/security/SecureRandomTest.java" lan="java">SecureRandomTest.java</button></ol><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static SecureRandom getInstance(String algorithm)
    // https://docs.oracle.com/en/java/javase/12/docs/specs/security/standard-names.html#securerandom-number-generation-algorithms
static SecureRandom getInstance(String algorithm, SecureRandomParameters params)
    // SecureRandom.getInstance("DRBG", DrbgParameters.instantiation(128, RESEED_ONLY, null));
static SecureRandomParameters getInstanceStrong()

void reseed()
    // 엔트로피 소스로부터 시드 재선택
void nextBytes(byte[] bytes)
    // + generateSeed
</div><h3>DrbgParameters</h3><ol><li>DRBG; Deterministic Random Bit Generator 이용을 위한 파라미터</li><p>기본 파라미터 외에 직접 지정하고 싶은 경우, 메서드의 SecureRandomParameters 파라미터로 넘기면 된다</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">var drbg = SecureRandom.getInstance("DRBG", DrbgParameters.instantiation(112, NONE, null));
    // Weak DRBG 인스턴스. 112비트 보안 강도
drbg.nextBytes(buffer, DrbgParameters.nextBytes(256, false, "more".getBytes()));
    // 보안 강도 112비트를 초과하여 실패
drbg.nextBytes(buffer, DrbgParameters.nextBytes(112, true, "more".getBytes()));
    // 예측 저항(PR_AND_RESEED) 없으므로 실패</div><li>시스템 속성</li><p>securerandom.drbg.config → 기본값 : Hash_DRBG with SHA-256</p></ol><div><h4>Nested Classes</h4><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static final class DrbgParameters.Instantiation implements SecureRandomParameters
    // DRBG 인스턴스 생성 시 사용
static enum DrbgParameters.Capability {
    NONE(예측 저항 x, reseed x), PR_AND_RESEED(예측 저항 o, reseed o), RESEED_ONLY(예측 저항 x, reseed o)
}
static final class DrbgParameters.Reseed implements SecureRandomParameters
    // DRBG 인스턴스 reseed에 이용
static final class DrbgParameters.NextBytes implements SecureRandomParameters
    // DRBG 인스턴스의 랜덤 비트열 생성에 이용
</div></div></div></div><h1>java.text</h1><div><h2>Format</h2><ol><li>자바에서 제공하는 주요 Format 서브 클래스는 DateFormat, MessageFormat, NumberFormat</li><li>콘크리트 서브 클래스는 아래 3개 메서드를 반드시 구현해야 한다</li><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">format(Object, StringBuffer, FieldPosition)
formatToCharacterIterator(Object)
parseObject(String, ParsePosition)
</div></ol><h2>Normalizer</h2><ol><li>유니코드<a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://ko.wikipedia.org/wiki/유니코드_정규화">정규화/역정규화</a> 관련 기능을 제공한다</li></ol><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static enum Normalizer.Form {
    NFC, NFD, NFKC, NFKD
}

static String normalize(CharSequence src, Normalizer.Form form)
    // + isNormalized
</div><h2>NumberFormat</h2><p><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/text/NumberFormatTest.java" lan="java">NumberFormatTest.java</button></p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static enum NumberFormat.Style {
    SHORT, LONG
}
static class NumberFormat.Field
    INTEGER(정수부), FRACTION(분수), EXPONENT(지수부), DECIMAL_SEPARATOR(소수 구분 기호), SIGN(부호), GROUPING_SEPARATOR(단위 구분 문자), EXPONENT_SYMBOL, PERCENT, PERMILLE, CURRENCY, EXPONENT_SIGN, PREFIX, SUFFIX
}

static final NumberFormat getInstance(Locale inLocale)
    // + getNumberInstance : 범용
    // + getIntegerInstance : 포맷에 HALF_EVEN을 이용하고, 파싱은 정수부만
</div><h2>SimpleDateFormat</h2><table><tr><th>문자</th><th>표현요소</th><th>예</th></tr><tr><th>G</th><td>기원 전/후</td><td>AD<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/text/SimpleDateFormatTest.java" displayRange="[18,23]" lan="java">예</button></td></tr><tr><th>y</th><td>년</td><td>1996; 96<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/text/SimpleDateFormatTest.java" displayRange="[26,31]" lan="java">예</button></td></tr><tr><th>Y</th><td>Week year</td><td>2009; 09<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/text/SimpleDateFormatTest.java" displayRange="[34,43]" lan="java">예</button></td></tr><tr><th>M</th><td>월(context sensitive)</td><td>July; Jul; 07<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/text/SimpleDateFormatTest.java" displayRange="[26,31]" lan="java">예</button></td></tr><tr><th>L</th><td>월 (standalone form)</td><td>July; Jul; 07</td></tr><tr><th>w</th><td>Week in year</td><td>27<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/text/SimpleDateFormatTest.java" displayRange="[34,43]" lan="java">예</button></td></tr><tr><th>W</th><td>Week in month</td><td>2</td></tr><tr><th>D</th><td>Day in year</td><td>189</td></tr><tr><th>d</th><td>Day in month</td><td>10<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/text/SimpleDateFormatTest.java" displayRange="[26,31]" lan="java">예</button></td></tr><tr><th>F</th><td>Day of week in month</td><td>2</td></tr><tr><th>E</th><td>Day name in week</td><td>Tuesday; Tue<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/text/SimpleDateFormatTest.java" displayRange="[34,43]" lan="java">예</button></td></tr><tr><th>u</th><td>Day number of week</td><td>1 = Monday, ..., 7 = Sunday<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/text/SimpleDateFormatTest.java" displayRange="[34,43]" lan="java">예</button></td></tr><tr><th>a</th><td>Am/pm</td><td>PM<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/text/SimpleDateFormatTest.java" displayRange="[46,51]" lan="java">예</button></td></tr><tr><th>H</th><td>Hour in day (0-23)</td><td>0<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/text/SimpleDateFormatTest.java" displayRange="[26,31]" lan="java">예</button></td></tr><tr><th>k</th><td>Hour in day (1-24)</td><td>24</td></tr><tr><th>K</th><td>Hour in am/pm (0-11)</td><td>0</td></tr><tr><th>h</th><td>Hour in am/pm (1-12)</td><td>12<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/text/SimpleDateFormatTest.java" displayRange="[46,51]" lan="java">예</button></td></tr><tr><th>m</th><td>Minute in hour</td><td>30<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/text/SimpleDateFormatTest.java" displayRange="[26,31]" lan="java">예</button></td></tr><tr><th>s</th><td>Second in minute</td><td>55<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/text/SimpleDateFormatTest.java" displayRange="[26,31]" lan="java">예</button></td></tr><tr><th>S</th><td>Millisecond</td><td>978<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/text/SimpleDateFormatTest.java" displayRange="[46,51]" lan="java">예</button></td></tr><tr><th>z</th><td>General time zone</td><td>Pacific Standard Time; PST; GMT-08:00</td></tr><tr><th>Z</th><td>RFC 822 time zone</td><td>-0800<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/text/SimpleDateFormatTest.java" displayRange="[46,51]" lan="java">예</button></td></tr><tr><th>X</th><td>ISO 8601 time zone</td><td>-08; -0800; -08:00</td></tr></table><h2>MessageFormat</h2><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">MessageFormatPattern ::= String | MessageFormatPattern FormatElement String
FormatElement        ::= { ArgumentIndex[, FormatType[, FormatStyle]] }
FormatType           ::= number | date | time | choice
FormatStyle          ::= short | medium | long | full | integer | currency | percent | SubformatPattern</div><ol><li>'' 안의 포맷 문자열은 이스케이프된다</li><li>동일 요소에 대한 반복적인 파싱은 마지막 파싱 결과만 유효하다<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/text/MessageFormatTest.java" lan="java">MessageFormatTest.java</button></li></ol><table><tr><th>FormatType</th><th>FormatStyle</th><th>Subformat Created</th></tr><tr><th>(none)</th><th>(none)</th><td>null</td></tr><tr><th rowspan="5">number</th><th>(none)</th><td>NumberFormat.getInstance(getLocale())</td></tr><tr><th>integer</th><td>NumberFormat.getIntegerInstance(getLocale())</td></tr><tr><th>currency</th><td>NumberFormat.getCurrencyInstance(getLocale())</td></tr><tr><th>percent</th><td>NumberFormat.getPercentInstance(getLocale())</td></tr><tr><th>SubformatPattern</th><td>new DecimalFormat(subformatPattern, DecimalFormatSymbols.getInstance(getLocale()))</td></tr><tr><th rowspan="6">date</th><th>(none)</th><td>DateFormat.getDateInstance(DateFormat.DEFAULT, getLocale())</td></tr><tr><th>short</th><td>DateFormat.getDateInstance(DateFormat.SHORT, getLocale())</td></tr><tr><th>medium</th><td>DateFormat.getDateInstance(DateFormat.DEFAULT, getLocale())</td></tr><tr><th>long</th><td>DateFormat.getDateInstance(DateFormat.LONG, getLocale())</td></tr><tr><th>full</th><td>DateFormat.getDateInstance(DateFormat.FULL, getLocale())</td></tr><tr><th>SubformatPattern</th><td>new SimpleDateFormat(subformatPattern, getLocale())</td></tr><tr><th rowspan="6">time</th><th>(none)</th><td>DateFormat.getTimeInstance(DateFormat.DEFAULT, getLocale())</td></tr><tr><th>short</th><td>DateFormat.getTimeInstance(DateFormat.SHORT, getLocale())</td></tr><tr><th>medium</th><td>DateFormat.getTimeInstance(DateFormat.DEFAULT, getLocale())</td></tr><tr><th>long</th><td>DateFormat.getTimeInstance(DateFormat.LONG, getLocale())</td></tr><tr><th>full</th><td>DateFormat.getTimeInstance(DateFormat.FULL, getLocale())</td></tr><tr><th>SubformatPattern</th><td>new SimpleDateFormat(subformatPattern, getLocale())</td></tr><tr><th>choice</th><th>SubformatPattern</th><td>new ChoiceFormat(subformatPattern)</td></tr></table></div><h1>java.time</h1><div><h2>Clock</h2><p>시간대(time-zone)을 이용한 현재의 date와 time 제공. 지정하지 않는 이상, 시계 내부의 시각은 계속 변한다<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/time/ClockTest.java" lan="java">ClockTest.java</button></p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static Clock system(ZoneId zone)
    // 특정 시간대의 시계 반환
    // systemUTC() == system(ZoneOffset.UTC)
    // systemDefaultZone() == system(ZoneId.systemDefault())

static Clock tick(Clock baseClock, Duration tickDuration)
    // 지정된 시계의 tick 단위를 조정. 예를 들어 1분이 지정된 경우, 1분 미만의 값은 버려진다
    // tickMillis(ZoneId zone) == tick(system(zone), Duration.ofMillis(1))

static Clock fixed(Instant fixedInstant, ZoneId zone)
    // 현재 시각으로 멈춘 시계 반환
static Clock offset(Clock baseClock, Duration offsetDuration)
    // 시각을 조정한 새로운 시계 반환
abstract Clock withZone(ZoneId zone)
    // 지정된 시간대에 현재 시계의 복사본을 생성하여 반환한다. 따라서 시각 자체는 조정하지 않는다
</div><h2>Duration</h2><p><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/time/DurationTest.java" lan="java">DurationTest.java</button></p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static Duration of(long amount, TemporalUnit unit)
static Duration from(TemporalAmount amount)
    // amount 그대로 Duration으로 변환
static Duration parse(CharSequence text)
    // ISO-8601 duration format PnDTnHnMn.nS
    // 추가로 접두 부호 가능
static Duration between(Temporal startInclusive, Temporal endExclusive)

Duration withSeconds(long seconds)
    // 나노초 단위만 남기고 seconds로 변경
Duration withNanos(int nanoOfSecond)
    // 나노초 단위만 nanoOfSecond로 변경
</div><h2>Instant</h2><p>Epoch(1970-01-01 00:00:00)를 기준으로 한 초(long)와 나노초(int)로 시각을 표현한다. 음수면 epoch 이전</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">public static final Instant EPOCH, MIN(아주 먼 옛날), MAX(아주 먼 미래)

static Instant now()
static Instant parse(CharSequence text)
    // DateTimeFormatter.ISO_INSTANT
    // 예. 2007-12-03T10:15:30.00Z)
</div><h2>DayOfWeek</h2><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">public static final DayOfWeek MONDAY ~ SUNDAY
int getValue() // ISO-8601. 1(MONDAY) ~ 7(SUNDAY)
</div><h2>Month</h2><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">public static final Month JANUARY ~ DECEMBER
int getValue() // ISO-8601. 1(JANUARY) ~ 12(DECEMBER)
</div></div><h1>java.time.format</h1><div><h2>DateTimeFormatter</h2><p><a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/time/format/DateTimeFormatter.html#predefined">DateTimeFormatter.html#predefined</a></p><table><tr><th>Formatter</th><th>Description</th><th>Example</th></tr><tr><th>ofLocalizedDate(dateStyle)</th><td>Formatter with date style from the locale</td><td>'2011-12-03'</td></tr><tr><th>ofLocalizedTime(timeStyle)</th><td>Formatter with time style from the locale</td><td>'10:15:30'</td></tr><tr><th>ofLocalizedDateTime(dateTimeStyle)</th><td>Formatter with a style for date and time from the locale</td><td>'3 Jun 2008 11:05:30'</td></tr><tr><th>ofLocalizedDateTime(dateStyle,timeStyle)</th><td>Formatter with date and time styles from the locale</td><td>'3 Jun 2008 11:05'</td></tr><tr><th>BASIC_ISO_DATE</th><td>Basic ISO date</td><td>'20111203'</td></tr><tr><th>ISO_LOCAL_DATE</th><td>ISO Local Date</td><td>'2011-12-03'</td></tr><tr><th>ISO_OFFSET_DATE</th><td>ISO Date with offset</td><td>'2011-12-03+01:00'</td></tr><tr><th>ISO_DATE</th><td>ISO Date with or without offset</td><td>'2011-12-03+01:00'; '2011-12-03'</td></tr><tr><th>ISO_LOCAL_TIME</th><td>Time without offset</td><td>'10:15:30'</td></tr><tr><th>ISO_OFFSET_TIME</th><td>Time with offset</td><td>'10:15:30+01:00'</td></tr><tr><th>ISO_TIME</th><td>Time with or without offset</td><td>'10:15:30+01:00'; '10:15:30'</td></tr><tr><th>ISO_LOCAL_DATE_TIME</th><td>ISO Local Date and Time</td><td>'2011-12-03T10:15:30'</td></tr><tr><th>ISO_OFFSET_DATE_TIME</th><td>Date Time with Offset</td><td>'2011-12-03T10:15:30+01:00'</td></tr><tr><th>ISO_ZONED_DATE_TIME</th><td>Zoned Date Time</td><td>'2011-12-03T10:15:30+01:00[Europe/Paris]'</td></tr><tr><th>ISO_DATE_TIME</th><td>Date and time with ZoneId</td><td>'2011-12-03T10:15:30+01:00[Europe/Paris]'</td></tr><tr><th>ISO_ORDINAL_DATE</th><td>Year and day of year</td><td>'2012-337'</td></tr><tr><th>ISO_WEEK_DATE</th><td>Year and Week</td><td>'2012-W48-6'</td></tr><tr><th>ISO_INSTANT</th><td>Date and Time of an Instant</td><td>'2011-12-03T10:15:30Z'</td></tr><tr><th>RFC_1123_DATE_TIME</th><td>RFC 1123 / RFC 822</td><td>'Tue, 3 Jun 2008 11:05:30 GMT'</td></tr></table></div><h1>java.util</h1><div><h2>Collection API</h2><div><h3>컬렉션 자료형 인터페이스</h3><div><h4>Collection&lt;E></h4><ol><li>컬렉션 최소 연산을 정의</li><li>서브 컬렉션을 작성할 때, 인자없는 생성자와 Collection 인자 하나만 받는 생성자를 각각 작성하도록 권장한다</li><li>정의하지 않아도 되는 선택적 메서드들에 대하여, 구현하지 않는 경우 UnsupportedOperationException을 던져야 한다</li><li>컬렉션이 자기 자신을 요소로 갖는 경우 일부 메서드 실행 중 예외가 발생할 수 있다</li><p><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/util/CollectionExample.java" lan="java">CollectionExample.java</button></p></ol><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">int size()
boolean isEmpty()

boolean add(E e)
boolean addAll(Collection&lt;? extends E> c)

boolean contains(Object o)
boolean containsAll(Collection&lt;?> c)

boolean retainAll(Collection&lt;?> c)
    // c에 속한 원소만 남기고 모두 제거한다. 이 연산으로 컬렉션이 변경됐다면 true 반환
boolean remove(Object o)
boolean removeAll(Collection&lt;?> c)
default boolean removeIf(Predicate&lt;? super E> filter)
void clear()

Object[] toArray()
&lt;T> T[] toArray(T[] a)
    // 사용 : toArray(new Clazz[0])
default &lt;T> T[] toArray(IntFunction&lt;T[]> generator)
    // 사용 : toArray(Clazz[]::new)

default Stream&lt;E> stream()
default Stream&lt;E> parallelStream()
</div><h4>Queue&lt;E></h4><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">boolean add(E e)   // 추가할 수 없으면 예외 발생. 따라서 반환이 있다면 그 값은 항상 true
boolean offer(E e) // 예외 발생하지 않는 add

E remove()         // 앞쪽 원소 하나 제거. 없으면 예외
E poll()           // 앞쪽 원소 하나 제거. 없으면 null

E element()        // 앞쪽 원소 하나 제거하지 않고 가져오기. 없으면 예외
E peek()           // 앞쪽 원소 하나 제거하지 않고 가져오기. 없으면 null
</div><h4>Deque&lt;E></h4><p>양방향 삽입/삭제 가능한 Queue</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">boolean removeFirstOccurrence(Object o)
    // + removeLastOccurrence
Iterator&lt;E> descendingIterator()
    // iterator()의 역순
</div><h4>List&lt;E></h4><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">default void replaceAll(UnaryOperator&lt;E> operator)
    // 모든 원소를 연산 결과로 대체

default void sort(Comparator&lt;? super E> c)

int hashCode()
    // hashCode = 31*hashCode + (e==null ? 0 : e.hashCode());

E set(int index, E element) // 이전 값은 반환

int indexOf(Object o)
    // + lastIndexOf

ListIterator&lt;E> listIterator()
List&lt;E> subList(int fromIndex, int toIndex)</div><p>Unmodifiable List</p><ul><li>List::of, List::copyOf는 null 허용하지 않는 변경 불가능한 리스트를 반환한다</li><li>모든 원소가 serializable하면 반환된 리스트도 그러하다</li></ul><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static &lt;E> List&lt;E> of() // Since 9
static &lt;E> List&lt;E> copyOf(Collection&lt;? extends E> coll) // Since 10
</div><h4>Set&lt;E></h4><p>Unmodifiable Set</p><ul><li>Set::of, Set::copyOf는 null 허용하지 않는 변경 불가능한 집합을 반환한다</li><li>모든 원소가 serializable하면 반환된 집합도 그러하다</li></ul><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static &lt;E> Set&lt;E> of() // Since 9
static &lt;E> Set&lt;E> copyOf(Collection&lt;? extends E> coll) // Since 10
</div><h4>SortedSet&lt;E></h4><p>원소가 정렬된 Set. 다음 4가지 생성자를 구현할 것을 권장. (void), (Comparator), (Collection), (SortedSet)</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">SortedSet&lt;E> subSet(E fromElement, E toElement)
    // 부분집합 반환. toElement는 미포함
    // + headSet, tailSet
E first() // + last
</div><h4>NavigableSet&lt;E></h4><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">E lower(E e)
    // e보다 작은 원소들 중 최댓값을 반환. 없으면 null
    // + floor: &lt;=e, ceiling: >=e, higher: >e

NavigableSet&lt;E> descendingSet()
Iterator&lt;E> descendingIterator()
</div><h4>Map&lt;K, V></h4><ul><li>default V getOrDefault(Object key, V defaultValue)<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/util/MapExample.java" displayRange="[12,16]" lan="java">MapExample.java</button></li><li>V put(K key, V value) : 이전 값은 반환된다</li><li>default V putIfAbsent(K key, V value)<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/util/MapExample.java" displayRange="[18,24]" lan="java">MapExample.java</button></li><li>default V compute(K key, BiFunction&lt;? super K, ? super V, ? extends V> remappingFunction)</li><p>값을 다시 계산하여 덮어쓴다<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/util/MapExample.java" displayRange="[26,32]" lan="java">MapExample.java</button></p><li>default V computeIfAbsent(K key, Function&lt;? super K, ? extends V> mappingFunction) + computeIfPresent</li><p>computeIfAbsent : key가 맵에 없거나, 대응하는 값이 null인 경우 새로운 값을 계산하여 넣는다. 계산된 값이 null이면 null 반환. 그 외의 경우 현재값 반환<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/util/MapExample.java" displayRange="[34,56]" lan="java">MapExample.java</button></p><p>computeIfPresent : key가 존재하고, 대응하는 값이 null이 아닌 경우 새로운 값을 계산하여 넣는다. 키가 존재하면 현재값 반환. 그 외의 경우 null 반환</p><li>default V replace(K key, V value) + replaceAll</li><p>key가 있을 때만 대체. 없으면 null 반환<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/util/MapExample.java" displayRange="[58,70]" lan="java">MapExample.java</button></p><li>default V merge(K key, V value, BiFunction&lt;? super V, ? super V, ? extends V> remappingFunction)<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/util/MapExample.java" displayRange="[72,89]" lan="java">MapExample.java</button></li><ul><li>key가 맵에 없거나, 대응하는 값이 null인 경우 : null이 아닌 value로 연결</li><li>주어진 함수를 통해 새로운 값에 연결</li><li>결과가 null인 경우 맵에서 제거</li></ul><li>Unmodifiable Instance</li><ul><li>Map::of, Map::ofEntries, Map::copyOf 메서드는 변경 불가능한 맵을 반환한다</li><p>변경 불가능한 맵은 키와 값 모두 null을 허용하지 않으며, 모든 키와 값이 serializable하면 맵도 그러하다</p><li>Map.Entry::entry 메서드는 변경 불가능한 엔트리를 반환한다</li></ul></ul><div><h5>Map.Entry&lt;K, V></h5><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static &lt;K extends Comparable&lt;? super K>, V> Comparator&lt;Map.Entry&lt;K, V>> comparingByKey()
    // 키를 자연스러운 순서로 비교하는 비교자 반환. 인자 있는 함수의 경우 해당 비교자를 이용
    // + comparingByValue
</div></div><span id="pos1997071679" style="padding:0!important;margin:0!important;width:0!important;height:0!important;overflow:hidden!important"></span><h4>SortedMap&lt;K, V></h4><p>키가 정렬된 Map. 다음 4가지 생성자를 구현할 것을 권장. (void), (Comparator), (Map), (SortedMap)</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">SortedMap&lt;K, V> subMap(K fromKey, K toKey)
    // 지정된 범위의 키만으로 구성된 서브 맵 반환. toKey는 미포함
    // + headMap, tailMap
</div><h4>NavigableMap&lt;K, V></h4><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">Map.Entry&lt;K, V> lowerEntry(K key)
    // key보다 작은 키들 중 최댓값에 대한 entry 반환. 없으면 null
    // + floorEntry: &lt;=key, ceilingEntry: >=key, higherEntry: >key
K lowerKey(K key)
    // key보다 작은 키들 중 최댓값 반환. 없으면 null
    // + floorKey: &lt;=key, ceilingKey: >=key, higherKey: >key

NavigableMap&lt;K, V> descendingMap()
NavigableMap&lt;K, V> subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)
    // + headMap, tailMap
</div></div><h3>컬렉션 연산 인터페이스</h3><div><h4>Enumeration&lt;E></h4><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">boolean hasMoreElements()
E nextElement()
default Iterator&lt;E> asIterator()
</div><h4>Iterator&lt;E></h4><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">boolean hasNext()
E next()
default void remove()
    // 마지막으로 반환된 원소를 제거. next() 호출 뒤 한 번만 호출 가능
default void forEachRemaining(Consumer&lt;? super E> action)
</div><h4>ListIterator&lt;E></h4><p>양방향으로 이동 가능한 iterator</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">boolean hasPrevious()
E previous()
int nextIndex() // + previousIndex
void set(E e)   // 마지막으로 반환된 요소를 변경
void add(E e)   // next()로 반환될 요소 바로전에 삽입
</div><h4>PrimitiveIterator&lt;T, T_CONS></h4><ol><li>기본 타입의 박싱을 회피하기 위한 이터레이터를 제공한다</li><li>OfInt, OfLong, OfDouble이 제공된다</li></ol><div><h5>PrimitiveIterator.OfInt</h5><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">int nextInt()
default void forEachRemaining(IntConsumer action)
</div></div><h4>Spliterator&lt;T></h4><ol><li>Iterator와 마찬가지로 순회를 위한 기능을 제공한다. Iterator와 달리 병렬 순회가 가능하며, 순회 메서드가 hasNext(), next()로 이분화되지 않는다</li><li>병렬 순회하려는 경우, 동일 Spliterator 객체를 이용하지 말고, 다른 스레드는 trySplit()을 통해 얻은 객체로 순회해야 한다</li><li>박싱을 피하기 위한 Spliterator를 제공한다. OfInt, OfLong, OfDouble</li></ol><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static int CONCURRENT, DISTINCT, IMMUTABLE, NONNULL, ORDERED, SIZED, SORTED, SUBSIZED

boolean tryAdvance(Consumer&lt;? super T> action)
    // 남은 원소가 존재하면 하나를 소비하고 true 반환. 그 외엔 false
default void forEachRemaining(Consumer&lt;? super T> action)

Spliterator&lt;T> trySplit()
    // 이 spliterator를 분리할 수 있다면, 일부분을 분리하여 반환하고, 이 spliterator는 나머지 원소들을 순회한다. 그 외엔 null

long estimateSize()
    // forEachRemaining() 메서드에서 순회할 원소의 수를 예측하여 반환한다. 무한하거나, 알 수 없거나, 계산하는 연산이 비싼 경우 Long.MAX_VALUE를 반환하면 된다
default long getExactSizeIfKnown()
    // 이 spliterator가 SIZED인 경우 estimateSize()를 반환한다. 그 외엔 -1

default Comparator&lt;? super T> getComparator()
    // 이 spliterator의 소스가 Comparator를 이용해 정렬된(SORTED) 경우, 해당 Comparator를 반환한다. 그 외엔 null, 또는 IllegalStateException</div><div><h5>Spliterator.OfInt</h5><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">default boolean tryAdvance(Consumer&lt;? super Integer> action)
    // action이 IntConsumer 인스턴스면 형변환되어 사용된다
    // + forEachRemaining
</div></div><h4>RandomAccess</h4><p>빠른(보통 상수 시간) 임의 접근이 가능한 List를 나타내는 마커 인터페이스</p></div><h3>컬렉션 자료형 콘크리트 클래스</h3><div><h4>AbstractMap.SimpleEntry&lt;K, V></h4><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">public SimpleEntry(K key, V value)</div><h4>AbstractMap.SimpleImmutableEntry&lt;K, V></h4><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">public SimpleImmutableEntry(K key, V value)</div><h4>ArrayDeque&lt;E></h4><p>가변 길이 배열로 구현한 Deque. 스레드-안전하지 않음</p><h4>ArrayList&lt;E></h4><p>가변 길이 배열로 구현한 List. 스레드-안전하지 않음</p><h4>Vector&lt;E></h4><p>ArrayList와 달리 스레드-안전하다</p><h4>BitSet</h4><p>각 비트의 기본값은 false. 스레드-안전하지 않음</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">void andNot(BitSet set)
    // set에 true로 설정된 모든 index에 대해 false 설정

boolean intersects(BitSet set)
    // 하나라도 true로 일치하는 경우

int size()        // 총 비트 수
int cardinality() // true 비트 수
int length()      // the index of the highest set bit
</div><h4>EnumMap&lt;K extends Enum&lt;K>, V></h4><p>Enum을 키로 이용</p><h4>EnumSet&lt;E extends Enum&lt;E>></h4><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static &lt;E extends Enum&lt;E>> EnumSet&lt;E> of(E e)
static &lt;E extends Enum&lt;E>> EnumSet&lt;E> range(E from, E to)
static &lt;E extends Enum&lt;E>> EnumSet&lt;E> noneOf(Class&lt;E> elementType) // 공집합 반환
static &lt;E extends Enum&lt;E>> EnumSet&lt;E> allOf(Class&lt;E> elementType)  // 전체 집합 반환
static &lt;E extends Enum&lt;E>> EnumSet&lt;E> complementOf(EnumSet&lt;E> s)   // 여집합 반환
static &lt;E extends Enum&lt;E>> EnumSet&lt;E> copyOf(Collection&lt;E> c)
</div><h4>HashMap&lt;K, V></h4><p>스레드-안전하지 않음</p><h4>HashSet&lt;E></h4><p>스레드-안전하지 않음</p><h4>IdentityHashMap&lt;K, V></h4><p>스레드-안전하지 않다. 일반적으로 (k1==null ? k2==null : k1.equals(k2))로 키를 비교하는 것과 달리 (k1==k2)로 비교한다</p><p>keySet()으로 반환되는 Set&lt;K>, values()로 반환되는 Collection&lt;V>, entrySet()으로 반환되는 Set&lt;Map.Entry&lt;K, V>> 모두 원소의 비교를 == 연산으로 한다</p><h4>LinkedList&lt;E></h4><p>List와 Deque을 모두 구현. 스레드-안전하지 않음</p><h4>LinkedHashMap&lt;K, V></h4><p>키가 삽입된 순서대로 원소를 유지하는 이중 연결 리스트를 가진다. 키가 존재하는 상황에서 put() 호출로 순서가 변경되지 않는다. 스레드-안전하지 않다</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder)
    // accessOrder == true ? 접근 빈도로 정렬 : 삽입 순서로 정렬
</div><h4>LinkedHashSet&lt;E></h4><p>삽입된 순서대로 원소를 유지하는 이중 연결 리스트를 가진다. 원소가 존재하는 상황에서 add() 호출로 순서가 변경되지 않는다. 스레드-안전하지 않다</p><h4>PriorityQueue&lt;E></h4><p>우선순위 힙에 기반한 unbounded 우선순위 큐. head가 가장 우선순위가 작은 원소</p><h4>Stack&lt;E></h4><p>LIFO 스택</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">int search(Object o) // top으로부터 거리 반환</div><h4>TreeMap&lt;K, V></h4><p>Red-Black tree(이진 탐색 트리의 일종) 기반의 NavigableMap 구현. log(n) 시간의 작업을 보장한다. 스레드-안전하지 않다</p><h4>TreeSet&lt;E></h4><p>TreeMap 기반의 NavigableSet 구현. 스레드-안전하지 않다</p><h4>WeakHashMap&lt;K, V></h4><p>key의 존재 여부는 key가 GC 대상이 되는 것에 영향이 없다. key 객체가 유효하지 않게 되면 자동으로 맵에서 삭제한다. key, value 모두에 null을 허용한다. 단, value가 key의 참조를 가지지 않도록 유의해야 한다. 스레드-안전하지 않다</p><h4>Hashtable&lt;K, V&gt;</h4><p>스레드-안전한 해시 테이블 구현. 스레드-안전할 필요가 없으면 HashMap, 높은 동시성이 요구되는 경우엔 ConcurrentHashMap을 이용하는 것이 좋다</p></div><h3>유틸리티 클래스</h3><div><h4>Collections</h4><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">public static final Set EMPTY_SET   // 변경 불가
public static final List EMPTY_LIST // 변경 불가
public static final Map EMPTY_MAP   // 변경 불가

// 리스트 연산
static &lt;T extends Comparable&lt;? super T>> void sort(List&lt;T> list)
    // T 자체가 Comparable하거나, T에 대한 Comparator를 넘기거나
static &lt;T> int binarySearch(List&lt;? extends Comparable&lt;? super T>> list, T key)
static void reverse(List&lt;?> list)
    // + shuffle, swap, fill, rotate
static &lt;T> void copy(List&lt;? super T> dest, List&lt;? extends T> src)
static &lt;T> boolean replaceAll(List&lt;T> list, T oldVal, T newVal)
static int indexOfSubList(List&lt;?> source, List&lt;?> target)
    // + lastIndexOfSubList
static &lt;T> ArrayList&lt;T> list(Enumeration&lt;T> e)

// Collection 연산
static &lt;T extends Object & Comparable&lt;? super T>> T min(Collection&lt;? extends T> coll)
static int frequency(Collection&lt;?> c, Object o)
static boolean disjoint(Collection&lt;?> c1, Collection&lt;?> c2)
    // 공통 원소가 없는지 여부

// 변경 불가능한 Collection Factory
static &lt;T> Collection&lt;T> unmodifiableCollection(Collection&lt;? extends T> c)
    // + ...

// Synchronization
//     비결정 상태에 빠지는 것을 방지하기 위해, 반환된 컬렉션에 대해 synchronized 제약을 걸고 이용하는 것이 좋다
static &lt;T> Collection&lt;T> synchronizedCollection(Collection&lt;T> c)
    // + ...

// 타입 체킹 추가
static &lt;E> Collection&lt;E> checkedCollection(Collection&lt;E> c, Class&lt;E> type)
    // + ...

// Empty Collection(변경 불가)
static &lt;T> Iterator&lt;T> emptyIterator()
    // + ...

// Singleton Collection(변경 불가)
static &lt;T> Set&lt;T> singleton(T o)
static &lt;T> List&lt;T> nCopies(int n, T o)
static &lt;T> List&lt;T> singletonList(T o)
static &lt;K, V> Map&lt;K, V> singletonMap(K key, V value)

// 기타
static &lt;T> Comparator&lt;T> reverseOrder()
    // 자연스러운 비교자의 역 반환
static &lt;T> Comparator&lt;T> reverseOrder(Comparator&lt;T> cmp)
static &lt;T> Queue&lt;T> asLifoQueue(Deque&lt;T> deque)
    // deque에 대한 LIFO view를 Queue로 반환한다
</div><h4>Spliterators</h4><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static &lt;T> Spliterator&lt;T> emptySpliterator()
    // + emptyIntSpliterator, emptyLongSpliterator, emptyDoubleSpliterator
static &lt;T> Spliterator&lt;T> spliterator(Object[] array, int additionalCharacteristics)
    // Arrays.spliterator()가 제공하는 것에 특성을 추가하고 싶을 때 사용. 전형적으로 IMMUTABLE, ORDERED

static &lt;T> Spliterator&lt;T> spliteratorUnknownSize(Iterator&lt;? extends T> iterator, int characteristics)
    // Spliterator로 래핑한 후에 iterator를 사용하면 안 된다
static &lt;T> Iterator&lt;T> iterator(Spliterator&lt;? extends T> spliterator)
    // Iterator로 래핑한 후에 spliterator를 사용하면 안 된다.        </div><div><h5>Spliterators.AbstractSpliterator&lt;T></h5><p>estimateSize(), characteristics(), trySplit()을 구현한 추상 클래스</p></div></div></div><h2>객체, 배열 관련</h2><div><h3>Comparator&lt;T></h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">default Comparator&lt;T> reversed()

default Comparator&lt;T> thenComparing(Comparator&lt;? super T> other)
    // 이 비교자가 두 객체를 같다고 판단하면, other가 새로 판단한다
    // + thenComparingInt, Long, Double

static &lt;T extends Comparable&lt;? super T>> Comparator&lt;T> naturalOrder()
    // 자연스러운 비교자를 반환한다
    // + reverseOrder

static &lt;T> Comparator&lt;T> nullsFirst(Comparator&lt;? super T> comparator)
    // null은 모든 non-null 값보다 작다고 간주한다. null끼리는 서로 같다고 간주한다
    // + nullsLast

static &lt;T, U> Comparator&lt;T> comparing(Function&lt;? super T, ? extends U> keyExtractor, Comparator&lt;? super U> keyComparator)
    // 정렬에 이용할 키를 생성하는 함수와, 키를 이용해 비교하는 비교자를 넘기면 둘을 포함하는 T타입 비교자를 반환
    // + comparingInt, Long, Double
</div><h3>Arrays</h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">// 정렬, 검색
static void sort(int[] a)
static void parallelSort(byte[] a)
    // 병합 정렬을 병렬로 수행한다. 모든 병렬 작업은 ForkJoin common pool을 이용해 이루어진다
static int binarySearch(long[] a, long key)

// 변경, 변환
static void fill(long[] a, long val)
static &lt;T> void setAll(T[] array, IntFunction&lt;? extends T> generator)
static &lt;T> void parallelSetAll(T[] array, IntFunction&lt;? extends T> generator)
static &lt;T> void parallelPrefix(T[] array, BinaryOperator&lt;T> op)
    // 전체 원소에 순차적으로 연산 적용하여 값 변경. 큰 배열은 루프보다 이게 더 빠르다

static String toString(long[] a)
static String deepToString(Object[] a)
    // toString(Object[])이 o.toString()을 이용하는 반면 여기서는 String.valueOf(Object)가 이용되고, 원소가 배열인 경우 "[]"를 추가하고 해당 배열의 원소들에 대해 같은 작업을 한다

static &lt;T> List&lt;T> asList(T... a)
static &lt;T> Spliterator&lt;T> spliterator(T[] array)
    // characteristics()에서 SIZED | SUBSIZED | ORDERED | IMMUTABLE를 반환하는 Spliterator 인스턴스를 반환한다
static &lt;T> Stream&lt;T> stream(T[] array)

// 복사
static &lt;T, U> T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]> newType)
static &lt;T> T[] copyOf(T[] original, int newLength)
static &lt;T, U> T[] copyOfRange(U[] original, int from, int to, Class&lt;? extends T[]> newType)
static &lt;T> T[] copyOfRange(T[] original, int from, int to)

// 비교
static int mismatch(boolean[] a, boolean[] b)  // Since 9
    // 처음으로 일치하지 않는 인덱스 반환
static boolean equals(long[] a, int aFromIndex, int aToIndex, long[] b, int bFromIndex, int bToIndex) // Since 9
    // Object의 경우, Objects.equals(e1, e2)일 때 같다고 간주한다
static boolean deepEquals(Object[] a1, Object[] a2)
    // null일 수 있는 각 배열의 두 원소 e1, e2에 대하여, 다음 4가지 경우에 대해 둘이 같다고 판단한다
    //     1. e1 == e2
    //     2. 둘 모두 참조변수에 대한 배열이고, Arrays.deepEquals(e1, e2)가 true
    //     3. 둘 모두 원시타입에 대한 배열이고, Arrays.equals(e1, e2)가 true
    //     4. e1.equals(e2)가 true

// 해싱
static int hashCode(long[] a)
    // 동일 원소를 가진 List의 해시코드와 동일. null이면 0 반환
static int deepHashCode(Object[] a)
    // 원소가 배열인 경우, 해당 원소의 해시를 deepHashCode로 구한다. 자기 자신을 포함하는 배열 등은 적합하지 않다
</div><h3>Objects</h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">// 비교
static boolean deepEquals(Object a, Object b)
    // 둘 다 null이면 true. 둘 다 배열이면 Arrays.deepEquals(), 나머진 a.equals(b)
static &lt;T> int compare(T a, T b, Comparator&lt;? super T> c)

// hashCode
static int hash(Object... values)
    // values가 하나의 배열에 든 것처럼 Arrays.hashCode(Object[])를 이용한다. Object.hashCode()의 간편한 구현으로 이용할 수 있다
    // 주의. hashCode(o) != hash(o)

// toString
static String toString(Object o, String nullDefault)

// null
static boolean isNull(Object obj)
    // Predicate, filter(Objects::isNull)에 이용
static &lt;T> T requireNonNull(T obj)
    // 메서드나 생성자에서 null검사를 하도록 설계되었다
static &lt;T> T requireNonNullElse(T obj, T defaultObj) // Since 9
static &lt;T> T requireNonNullElseGet(T obj, Supplier&lt;? extends T> supplier) // Since 9

// index
static int checkIndex(int index, int length)
    // index가 [0, length)에 존재하면 그대로 반환. 아니면 예외 발생
static int checkFromToIndex(int fromIndex, int toIndex, int length)
    // subrange [fromIndex, toIndex)가 [0, length)에 포함되면 fromIndex 반환. 아니면 예외 발생
static int checkFromIndexSize(int fromIndex, int size, int length)
    // subrange [fromIndex, fromIndex + size)가 [0, length)에 포함되면 fromIndex 반환. 아니면 예외 발생
</div><h3>Optional&lt;T> + OptionalInt, OptionalDouble, OptionalLong</h3><p>null을 허용하지 않는 객체에 대한 컨테이너. value-based므로 identity-sensitive한 연산은 피해야 한다</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static &lt;T> Optional&lt;T> empty()
static &lt;T> Optional&lt;T> of(T value)
static &lt;T> Optional&lt;T> ofNullable(T value)
    // null이면 empty(), 아니면 of(value)

T get()
T orElse(T other)
T orElseGet(Supplier&lt;? extends T> supplier)
Optional&lt;T> or(Supplier&lt;? extends Optional&lt;? extends T>> supplier)
    // Since 9, 값이 존재하면 그대로 반환. 없으면 제공되는 값 반환
T orELseThrow()
    // 값이 없으면 NoSuchElementException

boolean isPresent()
    // + isEmpty
void ifPresent(Consumer&lt;? super T> action)
void ifPresentOrElse(Consumer&lt;? super T> action, Runnable emptyAction)

Optional&lt;T> filter(Predicate&lt;? super T> predicate)
    // 값이 존재하고 필터를 통과하면 그대로 반환. 아니면 빈 컨테이너 반환
Stream&lt;T> stream()
    // 값이 존재하면 해당 값 하나만 포함하는 스트림 반환. 없으면 빈 스트림 반환

&lt;U> Optional&lt;U> map(Function&lt;? super T, ? extends U> mapper)
&lt;U> Optional&lt;U> flatMap(Function&lt;? super T, ? extends Optional&lt;? extends U>> mapper)
    // mapper가 반환하는 값 자체가 Optional이므로 map()과 달리 추가적인 Optional로 감싸지 않는다
</div></div><h2>시간 관련</h2><div><h3>Date</h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">long getTime()
boolean before(Date when)
static Date from(Instant instant)
</div><h3>Calendar</h3><ol><li>관대함(Leniency) : 범위를 벗어나는 값도 받아들이며, 나중에 정규화한다. 예를 들어 1월 32일은 2월 1일이 된다</li><li>add와 roll : add는 오버플로되면 다음 단위가 변하지만, roll은 modulo연산처럼 해당 단위만 변한다</li></ol><div><h4>Field Detail</h4><ol><li>시간 단위</li><p>public static final int ERA, YEAR, MONTH, WEEK_OF_YEAR, WEEK_OF_MONTH_, DATE, ...</p><li>단위 상수</li><p>public static final int SUNDAY, ..., JANUARY, ...AM, PM</p><li>스타일</li><p>public static final int ALL_STYLES, SHORT, LONG, NARROW_FORMAT, ...</p></ol></div><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static Calendar getInstance()
static Locale[] getAvailableLocales()
static Set&lt;String> getAvailableCalendarTypes()

// 달력의 현재 시점을 저장하고 있으므로, 시각 비교, 설정 등의 연산 제공
final Date getTime()
int get(int field)
abstract void add(int field, int amount)
void roll(int field, int amount)
abstract void roll(int field, boolean up) // 1 기본단위만큼 up/down

boolean isLenient()
int getFirstDayOfWeek()
int getMinimalDaysInFirstWeek()
    // 첫 주의 시작이 1월 1일인 경우 1, 그 외의 경우 7
boolean isWeekDateSupported()
    // default false
    // getWeekYear(), setWeekDate(int,int,int), getWeeksInWeekYear() 등을 지원하는지 여부</div><div><h4>Calendar.Builder</h4><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">Calendar.Builder setInstant(long instant) // 밀리초
Calendar.Builder set(int field, int value)
Calendar.Builder setFields(int... fieldValuePairs)
    // 예: setFields(Calendar.YEAR, 2013, Calendar.MONTH, Calendar.DECEMBER, Calendar.DAY_OF_MONTH, 23)
Calendar.Builder setTimeZone(TimeZone zone)
Calendar.Builder setLenient(boolean lenient) : build()에서 사용된다
</div></div><h3>GregorianCalendar</h3><p>GregorianCalendar는 아래 메서드를 지원한다</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">int getWeekYear()
void setWeekDate(int weekYear, int weekOfYear, int dayOfWeek)
int getWeeksInWeekYear()
final Instant toInstant()
int getActualMaximum(int field)
int getActualMinimum(int field)
</div><h3>Timer</h3><ol><li>백그라운드 스레드에서 미래에 실행될 작업들을 스케쥴링하는 기능을 제공한다. 작업은 일회용일수도, 일정한 주기를 가지고 반복될 수도 있다. 한 타이머의 모든 작업들은 하나의 백그라운드 스레드를 공유하기 때문에, 작업의 실행은 직렬적이며, 따라서 각 작업들은 가능한 한 빠르게 종료되어야 한다. 그렇지 않은 경우, 뒤에 대기하는 모든 작업이 밀려 제대로 실행되지 않을 수 있다</li><li>스레드-안전하다. 정시성을 보장하지 않는다. 스케쥴은 Object.wait(long) 메서드를 통해 이루어진다. java.util.concurrent 패키지의 ScheduledThreadPoolExecutor가 더 나은 대안으로 이용될 수 있다</li><li>기본적으로 타이머의 백그라운드 스레드는 데몬 스레드가 아니다. 따라서 타이머의 작업이 전체 프로그램의 종료를 지연시킬 수 있다. 백그라운드 스레드는 타이머 임의의 생성자에 의해 시작된다</li></ol><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">void schedule(TimerTask task, long delay)
    // delay밀리초 이후 task가 실행되도록 스케쥴
void schedule(TimerTask task, Date time)
    // time에 task가 실행되도록 스케쥴. time이 과거라면 즉시 실행
void schedule(TimerTask task, long delay, long period)
    // delay밀리초 이후 period 주기를 갖고 task가 실행되도록 스케쥴
void schedule(TimerTask task, Date firstTime, long period)
    // firstTime 이후 period 주기를 갖고 task가 실행되도록 스케쥴
void scheduleAtFixedRate(TimerTask task, long delay, long period)
    // period가 이전 task 종료가 아닌 최초 실행 시점을 기준으로 작동한다. 따라서 어떤 이유로 이전 작업이 지연된 경우, 시간당 작업률을 맞추기 위해 이후 작업이 연속적으로 실행될 수 있다
void cancel()
    // 타이머를 종료한다. 스케쥴된 모든 작업을 버리고, 현재 실행중인 작업에는 간섭하지 않는다. 타이머 종료 후 백그라운드 스레드도 우아하게 종료되어 GC 대상이 된다. 이후 더 이상의 스케쥴은 불가능하다
int purge()
    // 호출할 일이 거의 없는 메서드. 많은 작업을 한번에 취소한 경우, 취소한 작업들을 제거하여 참조가 없는 경우 GC 대상이 되도록 한다
</div><h3>TimerTask</h3><p>Timer 작업으로 사용하기 위한 Runnable</p><ol><li>boolean cancel()</li><ul><li>작업을 취소한다</li><li>작업이 1회용으로 스케쥴되었지만 아직 실행되지 않은 경우, 또는 아직 스케쥴되지 않은 경우 작업은 결코 실행되지 않는다</li><li>반복 작업으로 스케쥴된 경우, 작업은 결코 반복되지 않는다</li><li>작업 도중에 호출된 경우, 작업은 마무리까지 실행된다</li><li>반복 호출 가능하며 2회째 호출부터는 아무런 영향이 없다</li><li>true 반환 : 1회용으로 스케쥴되었지만 아직 실행되지 않은 경우, 반복 작업으로 스케쥴된 경우</li><li>false 반환 : 1회용으로 스케쥴되어 이미 실행된 경우, 아직 스케쥴되지 않은 경우, 이미 취소된 경우</li></ul><li>long scheduledExecutionTime()</li><p>가장 최근에 스케쥴된 ─ 또한 실제로 실행된 ─ 시점을 반환한다. 전형적으로 run 메서드에서, 작업이 너무 길어지는 것을 방지하기 위해 사용된다</p></ol></div><h2>숫자 관련</h2><div><h3>DoubleSummaryStatistics</h3><ol><li>double에 관한 통계를 모은 상태 객체. 스트림과 함께 사용되도록 설계되었다</li><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">var stats = doubleStream.collect(DoubleSummaryStatistics::new, DoubleSummaryStatistics::accept, DoubleSummaryStatistics::combine);
var stats = people.stream().collect(Collectors.summarizingDouble(Person::getWeight));</div></ol><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">public DoubleSummaryStatistics()
    // 개수 0, 합계 0, 최솟값 Double.POSITIVE_INFINITY, 최댓값 Double.NEGATIVE_INFINITY, 평균 0인 객체 생성
    // + (long count, double min, double max, double sum)
void accept(double value)
    // 요약 정보에 value를 추가
</div><h3>Random</h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">public Random()
    // 의사난수 생성기. 스레드-안전하지만 성능 저하 가능성이 있으므로 ThreadLocalRandom을 고려할 것

void nextBytes(byte[] bytes)
double nextGaussian()
    // 평균 0, 표준분산 1인 정규분포 난수 반환

// 난수 스트림 : + Long, Double 버전 존재
IntStream ints(long streamSize)
IntStream ints() // == ints(Long.MAX_VALUE)
IntStream ints(long streamSize, int randomNumberOrigin, int randomNumberBound) // [origin, bound)
</div><h3>SplittableRandom</h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">public SplittableRandom()
    // 분열하는 의사난수 생성기. 스레드-안전하지 않으며, 분열하여 스레드들이 각자 하나씩 갖도록 설계되었다

SplittableRandom split()
    // 분열. 상태를 공유하진 않지만, 생성한 난수는 통계적으로 유사한 속성을 갖는다
</div></div><h2>문자열 및 국제화 관련</h2><div><h3>Base64</h3><p>Base64 인코더와 디코더를 반환하는 유틸리티. RFC 2045, 4648</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static Base64.Encoder getEncoder()
static Base64.Encoder getUrlEncoder()
static Base64.Encoder getMimeEncoder()
static Base64.Encoder getMimeEncoder(int lineLength, byte[] lineSeparator)
static Base64.Decoder getDecoder()
static Base64.Decoder getUrlDecoder()
static Base64.Decoder getMimeDecoder()</div><div><h4>Base64.Encoder</h4><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">byte[] encode(byte[] src)
String encodeToString(byte[] src)
    // new String(encode(src), StandardCharsets.ISO_8859_1)
OutputStream wrap(OutputStream os)
Base64.Encoder withoutPadding()
</div><h4>Base64.Decoder</h4><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">byte[] decode(byte[] src)
InputStream wrap(InputStream is)
</div></div><h3>Locale</h3><p>public static final Locale US, ENGLISH, KOREA, KOREAN, ...</p><h3>Scanner</h3><ol><li>정규 표현식을 통해 원시 타입과 String을 분리해내는 간단한 text scanner</li><li>지정되지 않은 경우, 기본 구분자 패턴은 공백 문자(Character::isWhitespace)</li><li>기저 스트림으로부터 입력을 대기하는 동안 스레드가 블록될 수 있다</li><li>기저 Readable의 read()에서 IOException이 발생한 경우 소스의 끝에 도달했다고 판단하며, 가장 최근의 예외는 ioException()을 통해 얻을 수 있다</li><li>기저 스트림이 Closeable인 경우, Scanner에 대해 close()가 호출되면 기저 스트림도 닫힌다</li></ol><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">public Scanner(Readable source)
public Scanner(InputStream source)
public Scanner(File source)
public Scanner(Path source)
public Scanner(String source)
public Scanner(ReadableByteChannel source)

Pattern delimiter() // + useDelimiter
Locale locale()     // + useLocale
int radix()         // + useRadix

String findInLine(Pattern pattern)
    // 구분자를 무시하고 pattern을 검색한다. 줄 바꿈 문자 전에 문자열을 찾으면 해당 문자열을 반환하고 다음 라인으로 넘어간다. 줄 바꿈 문자를 만날 때까지 매칭이 없으면 읽기 위치는 변경없이 null을 반환한다
String findWithinHorizon(Pattern pattern, int horizon)
    // 구분자를 무시하고 pattern을 검색한다. 현재 위치로부터 최대 horizon개의 code point만을 검색에 이용한다. horizon == 0인 경우, 제한없이 검색을 수행한다. 매칭된 문자열이 없으면 읽기 위치 변경없이 null을 반환한다
Scanner skip(Pattern pattern)
    // 구분자를 무시하고 pattern을 검색한다. 매칭된 문자열이 있으면 건너뛰고, 없으면 읽기 위치 변경 없이 NoSuchElementException 발생
MatchResult match()
    // 가장 최근의 매칭 결과를 반환한다. MatchResult는 각종 next, findInLine, findWithinHorizon, skip 메서드의 성공적인 실행으로 설정된다
Stream&lt;MatchResult> findAll(Pattern pattern)
    // 스트림의 MatchResult 순서는 findWithinHorizon(pattern, 0), match()를 반복적으로 호출한 것과 동일하다

Stream&lt;String> tokens()
    // 구분자로 자른 문자열들의 스트림을 반환한다
Scanner reset()
    // scanner.useDelimiter("\\p{javaWhitespace}+").useLocale(Locale.getDefault(Locale.Category.FORMAT)).useRadix(10);
</div></div><h2>Properties</h2><p>stream을 통해 로드/저장되는 영구적인 속성값들을 표현. 기본값으로 이용하기 위해 다른 Properties를 포함할 수 있다. 스레드-안전하다</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">Object setProperty(String key, String value)
String getProperty(String key, String defaultValue)

void list(PrintStream out) // 디버깅에 유용

void load(Reader reader)
void store(Writer writer, String comments)
void loadFromXML(InputStream in)
void storeToXML(OutputStream os, String comment)
</div><h2>UUID</h2><p>+ com.fasterxml.uuid, com.datastax.cassandra</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">public UUID(long mostSigBits, long leastSigBits)
    // 2개 long을 이용해 128비트 UUID 생성
static UUID randomUUID()
    // version 4 UUID 생성
static UUID nameUUIDFromBytes(byte[] name)
    // version 3 UUID 생성
static UUID fromString(String name)

int version()
    // 1 Time-based UUID
    // 2 DCE security UUID
    // 3 Name-based UUID
    // 4 Randomly generated UUID

int variant()
    // 0 Reserved for NCS
    // 2 RFC 4122(이 클래스에서 사용)
    // 6 Reserved for Microsoft
    // 7 Reserved for future

long timestamp()
    // 60비트로 구성된 Time-based UUID의 시각을 반환한다. 1582-10-15 00:00:00 UTC로부터 몇 100ns가 흘렀는지를 의미한다
long node()
    //Time-based UUID의 48비트 Mac address를 반환한다
</div></div><h1>java.util.concurrent</h1><div><h2>Callable&lt;V></h2><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">V call() // 매개변수 없는, 결과를 반환하는 작업을 정의. Runnable과 달리 checked 예외를 던져도 된다</div><h2>ThreadFactory</h2><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">Thread newThread(Runnable r)</div><h2>비동기 자료형 관련</h2><div><h3>Future&lt;V></h3><p>비동기적 계산의 결과를 표현. 결과는 오직 get 메서드로만 얻을 수 있으며, 필요하다면 결과가 준비될 때까지 블록시킨다</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">boolean cancel(boolean mayInterruptIfRunning)
    // 작업이 완료됐거나 이미 취소된 경우 false를 반환한다. 이 메서드가 종료된 후의 isDone()은 항상 true
boolean isDone()
V get()
    // 결과가 준비될 때까지 대기
V get(long timeout, TimeUnit unit)
    // 결과가 준비될 때까지 최대 timeout만큼 대기
</div><h3>RunnableFuture&lt;V></h3><p>Runnable한 Future. 즉 비동기 연산과 그 결과를 표현한다</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">void run() // Future로 하여금 결과를 설정하도록 한다</div><h3>FutureTask&lt;V></h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">public FutureTask(Callable&lt;V> callable)
public FutureTask(Runnable runnable, V result)

protected void done()           // 완료 상태로 천이되면 호출된다
protected void set(V v)         // 결과 설정
protected boolean runAndReset() // 반복 실행 목적
</div><h3>Delayed</h3><p>객체가 일정 지연 뒤 작동함을 마킹하는 인터페이스. 이를 구현할 땐 compareTo를 반드시 같이 구현해야 한다</p><h3>ScheduledFuture&lt;V></h3><p>ScheduledExecutorService의 스케쥴링 결과</p><h3>RunnableScheduledFuture&lt;V></h3><p>Runnable한 ScheduledFuture</p><h3>CompletionStage&lt;T></h3><ol><li>비동기적일 수 있는 계산 단계. 다른 CompletionStage가 완료된 뒤 어떠한 동작을 수행하거나 값을 계산한다</li><p>Stage에서 수행되는 연산은 Function, Consumer, Runnable로 표현되어야 한다. 각각은 apply, accept, run 메서드로 stage에 제공된다<br>연산에 넘겨지는 인자는 트리거 stage의 결과이며, 이를 통해 연산의 pipeline을 만들 수 있다<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/concurrent/CompletionStageTest.java" lan="java">CompletionStageTest.java</button></p><li>아래 각 메서드들은 async 버전이 존재한다</li></ol><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">// 이전 연산이 완료되면 그 결과로 fn, action 호출
&lt;U> CompletionStage&lt;U> thenApply(Function&lt;? super T, ? extends U> fn)
CompletionStage&lt;Void> thenAccept(Consumer&lt;? super T> action)
CompletionStage&lt;Void> thenRun(Runnable action)

// this와 other 모두가 종료되면 그 결과로 fn, action 호출
&lt;U, V> CompletionStage&lt;V> thenCombine(CompletionStage&lt;? extends U> other, BiFunction&lt;? super T, ? super U, ? extends V> fn)
&lt;U> CompletionStage&lt;Void> thenAcceptBoth(CompletionStage&lt;? extends U> other, BiConsumer&lt;? super T, ? super U> action)
CompletionStage&lt;Void> runAfterBoth(CompletionStage&lt;?> other, Runnable action)

// this나 other 둘 중 하나라도 종료되면 그 결과로 fn, action 호출
&lt;U> CompletionStage&lt;U> applyToEither(CompletionStage&lt;? extends T> other, Function&lt;? super T, U> fn)
CompletionStage&lt;Void> acceptEither(CompletionStage&lt;? extends T> other, Consumer&lt;? super T> action)
CompletionStage&lt;Void> runAfterEither(CompletionStage&lt;?> other, Runnable action)

// this의 결과를 인자로 fn이 반환하는 CompletionStage가 실행되고, 실행된 결과와 같은 값으로 종료되는 CompletionStage를 반환한다
&lt;U> CompletionStage&lt;U> thenCompose(Function&lt;? super T, ? extends CompletionStage&lt;U>> fn)

// this가 종료되면 결과와 예외를 인자로 fn을 실행하고, fn의 결과로 반환된 stage를 종료한다
&lt;U> CompletionStage&lt;U> handle(BiFunction&lt;? super T, Throwable, ? extends U> fn)

// this가 종료되면 결과와 예외를 인자로 action을 실행하고, action이 종료되면 반환된 stage도 종료된다
CompletionStage&lt;T> whenComplete(BiConsumer&lt;? super T, ? super Throwable> action)

// this가 예외를 발생하면 그것을 인자로 fn 실행하는 CompletionStage 반환. 예외 발생이 없는 경우, this의 결과와 같은 값으로 반환된 stage가 종료된다
CompletionStage&lt;T> exceptionally(Function&lt;Throwable, ? extends T> fn) // Since 12

// this가 예외를 발생하면 fn이 반환하는 CompletionStage로 구성된다
default CompletionStage&lt;T> exceptionallyCompose(Function&lt;Throwable, ? extends CompletionStage&lt;T>> fn) // Since 12

CompletableFuture&lt;T> toCompletableFuture()
</div><h3>CompletableFuture&lt;T></h3><ol><li>CompletionStage로 이용될 수 있는, 명시적으로 종료(값과 상태를 설정)되는 Future</li><li>둘 이상의 스레드가 complete, completeExceptionally, cancel을 호출할 경우, 하나만 성공한다</li><li>non-async 메서드로 등록된 작업은 현재 CompletableFuture가 완료된 스레드 또는 호출자에서 실행된다</li><li>명시적인 Executor 없이 async 메서드로 등록된 작업은 ForkJoinPool::commonPool에서 수행</li><li>CompletionStage 메서드들을 독립적으로 구현했기 때문에, 하나를 재정의해도 다른 메서드에 영향이 없다</li><li>CompletionStage 메서드들만 이용하도록 하려면 minimalCompletionStage()를, future를 변경하지 못하도록 하려면 copy()를 이용</li><li>전반적인 계산에 대한 직접적인 제어를 할 수 없어서 cancel()의 호출은 completeExceptionally(new CancellationException()) 호출과 동일하다</li><li>서브클래스들은 각자의 클래스 인스턴스를 반환하도록 newIncompletableFuture 메서드를 재정의해야 한다</li></ol><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static &lt;U> CompletableFuture&lt;U> supplyAsync(Supplier&lt;U> supplier)
    // supplier의 결과를 가지고 비동기 종료되는 CompletableFuture 반환
static CompletableFuture&lt;Void> runAsync(Runnable runnable)
    // runnable을 실행하고 비동기 종료되는 CompletableFuture 반환
static &lt;U> CompletableFuture&lt;U> completedFuture(U value)
    // 이미 특정 값으로 종료된 CompletableFuture 반환
static CompletableFuture&lt;Void> allOf(CompletableFuture&lt;?>... cfs)
    // 모든 cfs가 종료되면 완료되는 새로운 CompletableFuture 객체 반환. 하나라도 예외 종료되면 반환된 CompletableFuture도 그러하다. cfs가 빈 경우, null로 종료된다
static CompletableFuture&lt;Object> anyOf(CompletableFuture&lt;?>... cfs)
    // 하나라도 종료되면, 그 결과와 같은 값으로 종료되는 CompletableFuture 객체 반환. cfs가 빈 경우, 완료되지 않는다

T join()
    // 종료되면 결과 값 반환, 또는 발생한 예외 던지기. 예외는 CompletionException이고, 기저 예외를 cause로 설정한다
T getNow(T valueIfAbsent)
    // 종료되었다면 결과 값 반환, 또는 발생한 예외 던지기. 아니면 valueIfAbsent 반환
boolean complete(T value)
    // 종료되지 않았다면 get()과 연관 메서드들의 반환값을 value로 설정. 이 호출로 CompletableFuture가 완료 상태로 천이되었다면 true 반환
boolean completeExceptionally(Throwable ex)
    // 종료되지 않았다면 get()과 연관 메서드들이 주어진 예외를 던지도록 한다. 이 호출로 CompletableFuture가 완료 상태로 천이되었다면 true 반환

boolean isCompletedExeptionally()
void obtrudeValue(T value)
    // 강제로 get()과 연관 메서드들의 반환값 설정. 에러 복구를 위해 설계됨
    // + obtrudeException
int getNumberOfDependents()
    // 종료 대기중인 CompletableFuture의 개수 추정. 동기화가 아닌 시스템 모니터링을 위해 설계됨

static Executor delayedExecutor(long delay, TimeUnit unit)
    // 주어진 딜레이 이후에 executor로 작업을 제출하는 새로운 Executor 반환
static &lt;U> CompletionStage&lt;U> completedStage(U value)
    // 주어진 value로 이미 종료된 새로운 CompletionStage 반환
static &lt;U> CompletableFuture&lt;U> failedFuture(Throwable ex)
    // 주어진 예외로 이미 종료된 새로운 CompletableFuture 객체 반환
static &lt;U> CompletionStage&lt;U> failedStage(Throwable ex)
    // 주어진 예외로 이미 종료된 새로운 CompletionStage 반환
&lt;U> CompletableFuture&lt;U> newIncompletableFuture()
    // 완료되지 않은 새로운 CompletableFuture 객체를 반환한다. 서브클래스들은 각자의 클래스 인스턴스를 반환하도록 newIncompletableFuture 메서드를 재정의해야 한다
Executor defaultExecutor()

CompletableFuture&lt;T> copy()
    // 정상적으로 종료되었다면, 같은 값을 갖는 종료된 CompletableFuture 반환
    // 예외 종료되었다면, 해당 예외를 원인으로 한 CompletionException으로 예외 종료된 CompletableFuture 반환. 동작은 thenApply(x -> x)와 같다
CompletionStage&lt;T> minimalCompletionStage()
    // CompletionStage에 정의된 메서드만 이용 가능. 재정의되지 않았다면 toCompletableFuture() 메서드를 통해 그 외의 메서드에 접근 가능하다

CompletableFuture&lt;T> completeAsync(Supplier&lt;? extends T> supplier)
    // 이 CompletableFuture를 supplier의 결과값으로 종료한다
CompletableFuture&lt;T> orTimeout(long timeout, TimeUnit unit)
    // 이 CompletableFuture가 주어진 시간 내에 종료되지 않은 경우, TimeoutException으로 예외 종료한다
CompletableFuture&lt;T> completeOnTimeout(T value, long timeout, TimeUnit unit)
    // 이 CompletableFuture가 주어진 시간 내에 종료되지 않은 경우, value로 종료한다</div><div><h4>CompletableFuture.AsynchronousCompletionTask</h4><p>비동기 메서드에서 생성된 비동기 작업을 나타내는 마커 인터페이스</p></div><h3>ForkJoinTask&lt;V></h3><ol><li>ForkJoinPool의 실행 단위. 일반적인 스레드보다 훨씬 가벼운 유사-스레드</li><li>메인 ForkJoinTask가 존재하여 다른 subtask들을 실행한다</li><li>전형적으로는 fork, join 메서드 쌍만 이용하며, a.fork(); b.fork(); b.join(); a.join();처럼 join 순서에 유의</li><li>RecursiveAction : 반환이 필요없는 경우<br>RecursiveTask : 반환이 필요한 경우<br>CountedCompleter : 작업의 완료가 다른 작업의 트리거가 되는 경우</li></ol><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">final ForkJoinTask&lt;V> fork()
    // 작업 시작
final V join()
    // 종료 대기 후 결과 반환. 비정상 종료 시 RuntimeException 또는 Error 발생
final V invoke()
    // fork + join

static ForkJoinTask&lt;?> adapt(Runnable runnable)
static void invokeAll(ForkJoinTask&lt;?>... tasks)
    // 모든 작업을 시작. 모두 완료되면 반환. 하나라도 예외가 발생하면 rethrow. 예외 종료된 경우 각 작업의 상태는 직접 획득해야 한다

final boolean isCompleteNormally()
    // + isCompletedAbnormally
final Throwable getException()
</div><h3>RecursiveAction</h3><p>재귀적이며 결과없는 ForkJoinTask<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/concurrent/RecursiveActionTest.java" lan="java">RecursiveActionTest.java</button><br>코드 출처 : https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/concurrent/RecursiveAction.html</p><h3>RecursiveTask&lt;V></h3><p>재귀적이며 결과가 있는 ForkJoinTask<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/concurrent/RecursiveTaskTest.java" lan="java">RecursiveTaskTest.java</button><br>코드 출처 : https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/concurrent/RecursiveTask.html</p><h3>CountedCompleter&lt;T></h3><ol><li>다른 작업들을 기다린 뒤 트리거로 작업을 시작하는 ForkJoinTask</li><li>Concrete 서브클래스들은 compute() 메서드를 반드시 재정의해야 하며, 되도록이면 반환하기 전에 tryComplete()을 호출해야 한다</li><li>일반적으로 CountedCompleter는 결과를 갖지 않겠지만, 결과가 필요한 경우 getRawResult() 메서드를 재정의하면 된다</li><li><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/concurrent/CountedCompleterTest.java" displayRange="[14,34,75,85]" lan="java">예시 : setPendingCount + tryComplete</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/concurrent/CountedCompleterTest.java" displayRange="[36,54,75,85]" lan="java">예시 : addToPendingCount + propagateCompletion</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/concurrent/CountedCompleterTest.java" displayRange="[56,73,75,85]" lan="java">예시 : 생성자에서 pendingCount 설정</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/concurrent/CountedCompleterTest.java" displayRange="[87,130]" lan="java">예시 : quietlyCompleteRoot</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/concurrent/CountedCompleterTest.java" displayRange="[132,168]" lan="java">예시 : compute 사용없이 트리거로만 이용</button><br>출처 ; https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/concurrent/CountedCompleter.html</li></ol><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">abstract void compute()
    // 메인 작업

void onCompletion(CountedCompleter&lt;?> caller)
    // tryComplete()이 호출되고, 남은 pendingCount가 0이면 호출된다. 또는 complete(T)가 호출된 경우에도 실행된다
boolean onExceptionalCompletion(Throwable ex, CountedCompleter&lt;?> caller)
    // compute()에서 예외가 발생했거나, ForkJoinTask::completeExceptionally가 호출된 경우 실행된다. 기본 구현은 return true;
    // true를 반환하였고, caller가 아직 완료되지 않은 경우, caller도 같은 예외로 종료된다

final CountedCompleter&lt;?> getCompleter()
    // 생성자에서 지정한 부모 completer 반환 + getRoot
final void tryComplete()
    // pendingCount가 0이 아니면 1 감소시킨다. 0인 경우 onCompletion 메서드를 호출하고, parent completer에 대해서도 tryComplete()을 호출한다
final void propagateCompletion()
    // tryComplete()와 같지만, onCompletion 메서드는 호출하지 않는다

final CountedCompleter&lt;?> firstComplete()
    // pendingCount가 0이면 return this; 그 외엔 pendingCount를 감소시키고 return null;
final CountedCompleter&lt;?> nextComplete()
    // parent completer가 없는 경우, ForkJoinTask::quietlyComplete 호출하고 return null; pendingCount가 0이 아니면 감소시키고 return null;
    // 그 외엔 parent completer 반환
for(var c = firstComplete(); c != null; c = c.nextComplete()) { ... }

final void helpComplete(int maxTasks)
    // 이 작업이 완료되지 않았다면, completion path 상의 최대 maxTasks개 만큼의 시작되지 않은 작업을 진행시킨다
</div></div><h2>Executor 관련</h2><div><h3>Executor</h3><ol><li>전달받은 Runnable을 실행하는 객체. Executor 자체가 스레드의 병행성을 부여하진 않으며, 구현에서 호출자와 다른 스레드 공간을 마련해주어야 한다</li><li>void execute(Runnable command)</li></ol><h3>ExecutorService</h3><ol><li>java.util.concurrent 패키지의 기본적인 Executor 구현<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/concurrent/ExecutorServiceTest.java" lan="java">ExecutorServiceTest.java</button></li></ol><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">void shutdown()
    // 추가적인 Runnable을 받지 않는다. 이전에 추가된 것은 마저 실행한다
List&lt;&Runnable> shutdownNow()
    // 실행중인 모든 작업을 중지. 실행 대기중이었던 작업들은 반환

boolean isTerminated()
    // shutdown, shutdownNow 호출 이후 모든 작업이 끝났는지 여부
boolean awaitTermination(long timeout, TimeUnit unit)
    // shutdown 요청 후 모든 작업이 종료되기를 기다리며 블록한다. timeout 발생한 경우 false 반환

&lt;T> Future&lt;T> submit(Callable&lt;T> task)
    // 결과를 반환하는 작업을 등록한다. 작업이 성공적으로 종료되면 Future::get으로 결과를 확인할 수 있다
&lt;T> Future&lt;T> submit(Runnable atask, T result)
    // 작업을 등록한다. 작업이 성공적으로 종료되면 Future::get으로 result를 얻을 수 있다
Futur&lt;?> submit(Runnable task)
    // 작업을 등록한다. 작업이 성공적으로 종료되면 Future::get은 null을 반환한다

&lt;T> List&lt;Future&lt;T>> invokeAll(Collection&lt;? extends Callable&lt;T>> tasks)
    // 모든 작업이 종료되면 Future 리스트를 반환한다. 따라서 리스트 안의 각 Future::isDone은 true다
&lt;T> List&lt;Future&lt;T>> invokeAll(Collection&lt;? extends Callable&lt;T>> tasks, long timout, TimeUnit unit)
    // 모든 작업이 종료되거나 timeout이 발생하면 반환. 리스트 안의 각 Future::isDone은 true. timeout 발생 시 완료되지 않은 작업들은 취소된다
&lt;T> T invokeAny(Collection&lt;? extends Callable&lt;T>> tasks)
    // 성공적으로 완료된 첫 작업의 결과를 반환한다. 완료되지 않은 작업들은 취소된다
&lt;T> T invokeAny(Collection&lt;? extends Callable&lt;>> tasks, long timeout, TimeUnit unit)
    // timeout되면 TimeoutException 발생
</div><h3>ScheduledExecutorService</h3><p>실행 전에 딜레이를 두거나, 주기적으로 실행을 반복할 수 있는 ExecutorService</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">ScheduledFuture&lt;?> schedule(Runnable command, long delay, TimeUnit unit)
    // 주어진 delay 이후 command가 1회 실행되도록 한다
ScheduledFuture&lt;?> scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)
    // 반복되는 작업은 반환된 Future를 통해 취소할 수 있다
ScheduledFuture&lt;?> scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)
    // scheduleAtFixedRate와 달리, 이전 작업이 완료된 후 다음 작업이 시작된다
</div><h3>AbstractExecutorService</h3><p>submit, invokeAny, invokeAll 메서드 구현. 반환하는 RunnableFuture에는 FutureTask 이용</p><h3>ThreadPoolExecutor</h3><ol><li>각 작업들은 스레드풀의 별개 스레드에서 실행된다</li><li>Core and maximum pool sizes</li><p>corePoolSize에 도달할 때까지 신규 작업에 대해 신규 스레드를 할당한다. 대기 중인 스레드가 없으면 maxPoolSize에 도달할 때까지 신규 작업에 대해 신규 스레드를 할당한다</p><li>On-demand construction</li><p>처음부터 corePoolSize만큼의 스레드를 만들어놓을 지를 설정할 수 있다</p><li>Creating new threads</li><p>지정되지 않으면 Executors::defaultThreadFactory로부터 신규 스레드를 생성한다. 동일 스레드그룹 + NORM_PRIORITY + non-daemon</p><li>Keep-alive times</li><p>corePoolSize를 초과한 스레드들은 대기 상태가 keepAliveTime을 초과하면 종료된다. allowCoreThreadTimeOut 메서드로 코어 스레드에도 적용할 지 설정 가능</p><li>Queuing</li><ul><li>처리를 기다리는 작업들은 BlockingQueue에서 대기한다</li><li>corePoolSize 이상의 스레드가 활성 상태라면 작업은 우선 큐에 진입된다. 큐에 자리가 없으면 신규 스레드가 생성되어 작업을 처리한다</li><li>큐에 자리도 없고 활성 스레드 수가 maximumPoolSize와 같다면 추가 작업은 거부된다</li><li>큐잉 전략 1. Direct handoff</li><p>SynchronousQueue. 작업 가능한 스레드가 없으면 신규로 생성한다. 제한없는 maximumPoolSize 필요</p><li>큐잉 전략 2. Unbounded queue</li><p>무제한으로 큐에 작업을 추가하므로, 활성 스레드의 수는 항상 corePoolSize 이하다</p><li>큐잉 전략 3. Bounded queue</li><p>큐의 크기와 maxPoolSize의 적절한 trade off 필요</p></ul><li>Rejected tasks</li><ul><li>거부된 작업에 대하여 RejectedExecutionHandler::rejectedExecution 메서드가 실행된다</li><li>기본 정책. ThreadPoolExecutor.AbortPolicy : 핸들러가 RejectedExecutionException 발생</li><li>ThreadPoolExecutor.CallerRunsPolicy : 작업을 제출한 스레드가 직접 작업을 실행한다</li><li>ThreadPoolExecutor.DiscardPolicy : 거부된 작업은 버려진다</li><li>ThreadPoolExecutor.DiscardOldestPolicy : 신규 작업이 아닌, 큐에서 가장 오래된 작업이 버려진다. 신규 작업은 다시 시도된다</li></ul><li>Hook methods</li><p>beforeExecute, afterExecute, terminated 메서드를 재정의하여 작업 전후에 필요한 부분을 실행할 수 있다</p></ol><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">void execute(Runnable command)
    // command를 언젠가 실행한다. 작업 스레드가 실행하지 못하면, RejectedExecutionHandler가 처리한다
    // ↔ remove

void shutdown()
    // 순차적 종료 절차에 진입한다. 추가 작업은 받지 않고, 이미 제출된 작업들은 마저 처리한다
List&lt;Runnable> shutdownNow()
    // 대기 중인 작업에 더해 실행 중인 작업들도 모두 중지한다. 대기중이었던 작업들은 리스트로 반환한다. 실행 중인 작업들에 유예 시간을 주고 싶다면 ExecutorService::awaitTermination 이용
boolean isTerminating()
    // shutdown 또는 shutdownNow 메서드가 호출되었지만, 아직 중지가 완료되지는 않았다면 true

void setThreadFactory(ThreadFactory threadFactory)
    // + set/getRejectedExecutionHandler, set/getCorePoolSize, set/getMaximumPoolSize, set/getKeepAliveTime
void allowCoreThreadTimeOut(boolean value)
    // 코어 스레드에도 keep-alive를 적용할 지 여부

boolean prestartCoreThread()
    // 신규 스레드를 하나 생성한다. 이미 corePoolSize 만큼 스레드가 존재한다면 false 반환
int prestartAllCoreThreads()
    // 생성된 스레드의 수가 corePoolSize가 될 때까지 신규 스레드를 생성한다. 신규로 생성된 스레드의 수를 반환한다
BlockingQueue&lt;Runnable> getQueue()
               직접 조작하진 말고, 모니터링/디버깅 용도로 이용함이 바람직하다

int getPoolSize()            // 현재 풀 안의 스레드 수 반환
int getActiveCount()         // 현재 실행 중인 스레드 수 추정치 반환
int getLargestPoolSize()     // 풀에 동시에 존재했던 스레드의 최대 개수 반환
long getTaskCount()          // 실행 스케쥴된 작업의 총 개수의 근사치 반환
long getCompletedTaskCount() // 실행 완료된 작업의 총 개수의 근사치 반환</div><div><h4>RejectedExecutionHandler</h4><p>ThreadPoolExecutor에서 실행되지 않은 작업에 대한 처리를 위해 사용</p></div><h3>ScheduledThreadPoolExecutor</h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">void setContinueExistingPeriodicTasksAfterShutdownPolicy(boolean value)
    // 기본값 false. true면 shutdownNow가 호출되거나 이 정책이 false가 될 때까지 주기 작업을 계속 실행한다

void setExecuteExistingDelayedTasksAfterShutdownPolicy(boolean value)
    // 기본값 true. true면 shutdownNow가 호출되거나 종료 후 이 정책이 false가 되기 전까지는 지연 작업을 실행한다

void setRemoveOnCancelPolicy(boolean value)
    // 기본값 false. 취소된 작업을 즉시 큐에서 제거할 것인지, 또는 해당하는 딜레이 후 제거할 것인지 설정
</div><h3>CompletionService&lt;V></h3><p>생산자가 작업들을 추가하면, 소비자는 그것이 완료된 순서대로 이용할 수 있다</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">Future&lt;V> submit(Callable&lt;V> task)
Future&lt;V> submit(Runnable task, V result)
Future&lt;V> take()
    // 완료된 작업을 가져온다. 없으면 대기한다
Future&lt;V> poll()
    // 완료된 작업을 가져온다. 없으면 null
Futur&lt;V> poll(long timeout, TimeUnit unit)
</div><h3>ExecutorCompletionService&lt;V></h3><p>CompletionService 구현. 주어진 Executor를 실행에 이용한다. 완료되는 순서대로 작업을 take 메서드로 접근할 수 있는 큐에 배치한다</p><h3>ForkJoinWorkerThread</h3><p>ForkJoinPool에서 ForkJoinTask를 실행하는 스레드</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">int getPoolIndex()
    // 풀 안에서 이 스레드의 번호(Unique)
</div><h3>ForkJoinPool</h3><ol><li>ForkJoinTask에 관한 ExecutorService. Non-ForkJoinTask 호출자도 이용할 수 있는 메서드를 제공한다</li><p>execute(ForkJoinTask), invoke(ForkJoinTask), submit(ForkJoinTask)</p><li>모든 ForkJoinWorkerThread는 데몬 스레드로 초기화된다</li><li>Common pool 튜닝에 관한 시스템 속성</li><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">java.util.concurrent.ForkJoinPool.common.parallelism
    // parallelism level. 기본값은 프로세서 수
java.util.concurrent.ForkJoinPool.common.threadFactory
    // class name of a ForkJoinPool.ForkJoinWorkerThreadFactory
java.util.concurrent.ForkJoinPool.common.exceptionHandler
    // class name of a Thread.UncaughtExceptionHandler
java.util.concurrent.ForkJoinPool.common.maximumSpares
    // maximum number of allowed extra threads to maintain target parallelism (default 256).</div></ol><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static ForkJoinPool commonPool()

&lt;T> T invoke(ForkJoinTask&lt;T> task)
void execute(ForkJoinTask&lt;?> task)
&lt;T> ForkJoinTask&lt;T> submit(ForkJoinTask&lt;T> task)</div><div><h4>ForkJoinPool.ForkJoinWorkerThreadFactory</h4><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">ForkJoinWorkerThread newThread(ForkJoinPool pool)</div><h4>ForkJoinPool.ManagedBlocker</h4><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">boolean block()
    // 필요한 만큼 현재 스레드를 블록시킨다. 추가적인 블로킹이 필요하지 않으면 true 반환
boolean isReleasable
    // 블로킹이 필요없으면 true 반환
</div></div><h3>Executors</h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">// ExecutorService 관련
static ExecutorService newFixedThreadPool(int nThreads)
    // 최대 동시 실행 가능한 스레드 수 제한. 나머지 스레드는 큐에서 대기. 스레드들은 명시적으로 shutdown되기 전까지 풀에 존재한다
static ExecutorService newWorkStealingPool()
    // 사용 가능한 프로세서 수를 parallelism level로 이용. 반환되는 객체는 ForkJoinPool 인스턴스
static ExecutorService newSingleThreadExecutor()
    // 하나의 워커 스레드만 사용한다. 예기지 않게 워커가 종료되면 새로운 스레드가 나머지 작업을 위해 그 자리를 대신할 수 있다
    // 같은 특징을 갖는 newFixedThreadPool(1)과 다르게, 반환된 ExecutorService가 추가적인 워커 스레드를 이용하도록 설정할 수 없다
static ExecutorService newCachedThreadPool()
    // 이전에 종료된 스레드를 재사용. 60초 동안 이용되지 않으면 풀에서 삭제된다
static ExecutorService unconfigurableExecutorService(ExecutorService executor)
    // ExecutorService에 정의된 메서드들은 executor에 연결하고, 그 외 캐스트를 통해 이용할 수 있는 메서드들은 호출하지 못하도록 한다

// ScheduledExecutorService 관련
static ScheduledExecutorService newSingleThreadScheduledExecutor()
static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)
static ScheduledExecutorService unconfigurableScheduledExecutorService(ScheduledExecutorService executor)
    // ScheduledExecutorService에 정의된 메서드들은 executor에 연결하고, 그 외 캐스트를 통해 이용할 수 있는 메서드들은 호출하지 못하도록 한다

// ThreadFactory 관련
static ThreadFactory defaultThreadFactory()
    // 모든 스레드들을 같은 ThreadGroup으로 생성한다. 스레드의 우선순위는 Threa.NORM_PRIORITY와 그룹의 최대 허용치 중 작은 것으로 설정된다
    // 각 스레드들은 non-daemon으로 생성되며, Thread.getName()을 통해 얻을 수 있는 "pool-N-thread-M" 꼴의 이름으로 접근할 수 있다
static ThreadFactory privilegedThreadFactory()
    // 호출하는 스레드와 같은 권한으로 새로운 스레드를 생성하는 ThreadFactory 반환

// Callable 관련
static &lt;T> Callable&lt;T> callable(Runnable task, T result)
static Callable&lt;Object> callable(Runnable task)
    // 작업이 완료되면 null을 반환하는 Callable 반환
static Callable&lt;Object> callable(PrivilegedAction&lt;?> action)
    // 호출되면 action::run을 실행하고 그 결과를 반환하는 Callable 반환
static Callable&lt;Object> callable(PrivilegedExceptionAction&lt;?> action)
static &lt;T> Callable&lt;T> privilegedCallable(Callable&lt;T> callable)
    // 호출되면 callable을 현재 access control context에서 실행. AccessController.doPrivileged에서 호출되어야 한다
static &lt;T> Callable&lt;T> privilegedCallableUsingCurrentClassLoader(Callable&lt;T> callable)
</div></div><h2>리액티브 스트림<span id="pos-1912716076" style="padding:0!important;margin:0!important;width:0!important;height:0!important;overflow:hidden!important"></span></h2><p>https://github.com/reactive-streams/reactive-streams-jvm</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">final class Flow { // Since 9
    static int defaultBufferSize() // 256
}
@FunctionalInterface static interface Flow.Publisher&lt;T> {
    void subscribe(Flow.Subscriber&lt;? super T> subscriber)
}</div><div><h3>Publisher 규칙</h3><ol><li>Publisher가 Subscriber에 onNext로 신호를 보낸 횟수 &lt;= Subscriber가 Subscription으로 보낸 request의 횟수</li><p>이 규칙은 onNext의 호출에 대하여, 선행되는 request가 항상 존재함을 함의한다</p><li>Publisher가 onNext로 신호를 보낸 횟수가 request보다 적은 경우, Subscription을 onComplete 또는 onError로 종결한다</li><p>이 규칙은 request에 대한 onNext가 항상 존재하지는 않음을 명시한다</p><li>onSubscribe, onNext, onError, onComplete 신호는 직렬적이어야 한다</li><p>결코 다른 신호와 중첩되는 시점이 있어서는 안 된다</p><li>Publisher의 실패는 반드시 onError로 보내야 한다</li><li>스트림이 정상적으로 종결된 경우 Publisher는 반드시 onComplete 신호를 보내야 한다</li><li>Publisher가 onError, onComplete 신호를 보낸 경우, Subscription은 반드시 취소된 것으로 간주되야 한다</li><li>종료 상태(onError, onCompletion)에서 추가적인 신호의 발생은 절대 없다</li><li>Subscription이 취소된 경우, 추가적인 신호 전달은 절대 없다</li><li>Publisher.subscribe 안에서 onSubscribe를 반드시 호출해야 하며, 반드시 다른 신호를 보내기 전에 선행되어야 한다. 또, 이 경우 메서드는 반드시 정상 종결되어야 한다</li><p>Subscriber.onSubscribe 호출 시 null 검사는 필요없다. NullPointerException이 발생하게 내버려두면 된다</p><li>Publisher.subscribe는 여러 번 호출될 수 있지만, 하나의 Subscriber로부터는 최대 한 번만 호출되어야 한다</li><li>Publisher는 여러 Subscriber들에 대한 멀티캐스트를 지원할 수 있다</li></ol></div><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static interface Flow.Subsbriber&lt;T> {
    void onSubscribe(Flow.Subscription)
    onNext(T)
    onError(Throwable)
    onComplete(Void)
}</div><div><h3>Subscriber 규칙</h3><ol><li>Subscriber는 onNext 신호를 받고 싶다면 반드시 먼저 request 신호를 보내야 한다</li><li>신호를 보낼 때, Publisher의 완료를 기다리지 말고 비동기적으로 전달함이 권장된다</li><li>onComplete, onError 메서드는 절대 Subscription, Publisher 어느쪽의 메서드도 호출해선 안 된다</li><li>onComplete, onError 신호를 받은 이후부터, Subscription은 반드시 취소로 간주되어야 한다</li><li>유효한 Subscription이 존재한다면, 추가적인 onSubscribe 신호에 대해 반드시 cancel을 호출해야 한다</li><p>하나의 Subscriber는 둘 이상의 Publisher를 동시에 구독하지 않아야 한다</p><li>더 이상 필요없다면 반드시 Subscription.cancel을 호출해야 한다</li><li>Subscription으로 보내는 신호들은 반드시 직렬적이어야 한다</li><p>결코 동시에 두 신호를 보내는 순간은 없어야 한다</p><li>cancel의 호출은 대기 중인 작업의 취소를 보장하지 않는다. cancel 이후 추가적인 onNext 신호에 대해 준비되어야 한다</li><li>아무런 request를 보내지 않았더라도, onComplete, onError 신호에 대해 준비되어야 한다</li><li>onSubscribe, onNext, onError, onComplete는 인자가 null이 아닌 이상 반드시 정상 종료되어야 한다</li><p>Subscriber의 실패는 Subscription.cancel로만 통지할 수 있다. 이 규칙이 지켜지지 않은 경우, Subscription은 반드시 취소로 간주되어야 한다</p></ol></div><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static interface Flow.Subscription {
    void request(long)
    cancel(Void)
}</div><div><h3>Subscription 규칙</h3><ol><li>request, cancel은 반드시 Subscriber가 호출해야 한다</li><li>onNext, onSubscribe 안에서 동기적으로 request를 호출하는 것은 허용된다</li><li>cancel의 호출은 멱등이어야 하고, 그 실행은 스레드-안전해야 한다</li><li>Subscription이 취소됐다면, 이후의 request, cancel의 호출은 아무 작업도 하지 않아야 한다</li><li>0이하에 대한 request 호출은 onError로 IllegalArgumentException을 보내야 한다</li><li>Subscription이 취소됐다면, Publisher는 Subscriber에 대한 모든 참조를 제거해야 한다</li><li>request, cancel은 항상 정상 종료되어야 한다</li><li>Subscription은 반드시 무제한적인 request 호출을 허용해야 한다. n == Long.MAX_VALUE</li></ol></div><div><h3>SubmissionPublisher&lt;T></h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">public SubmissionPublisher(Executor executor, int maxBufferCapacity, BiConsumer&lt;? super Flow.Subscriber&lt;? super T>, ? super Throwable> handler)
    // executor : 비동기적으로 구독자에게 전달하는 데 쓰일 Executor
    // maxBufferCapacity : 각 구독자에 대한 버퍼의 한도. 실제 한도는 getMaxBufferCapacity()로 확인
    // handler : null이 아니면 onNext에서 발생한 예외를 처리
public SubmissionPublisher()
    // executor = ForkJoinPool.commonPool()
    // maxBufferCapacity = Flow.defaultBufferSize()
    // handler = null

int submit(T item)
    // 각 구독자에게 비동기적으로 item을 보낸다(onNext). lag(배포된 item 중에 아직 소비되지 않은 개수) 추정치를 반환한다
int offer(T item, BiPredicate&lt;Flow.Subscriber&lt;? super T>, ? super T> onDrop)
    // 가능하다면 각 구독자에게 비동기적으로 item을 보낸다(onNext). 리소스 초과(버퍼가 가득 찼다던지)로 실패한 경우 onDrop이 실행된다. onDrop이 true를 반환하면 onNext를 다시 시도한다
    // 반환값이 음수인 경우 drop된 구독자 수를 의미하고, 그 외의 경우 lag(배포된 item 중에 아직 소비되지 않은 개수) 추정치를 의미한다

long estimateMinimumDemand()
    // 각 구독자들이 요청한 아이템 수 중, 아직 공급되지 않은 수의 최소값(추정치) 반환
int estimateMaximumLag()
    // 각 구독자들에 보낸 아이템 중 아직 소비되지 않은 수의 최대값(추정치) 반환
CompletableFuture&lt;Void> consume(Consumer&lt;? super T> consumer)
    // 배포된 모든 아이템에 대해 consumer 실행. 정상적으로 모두 실행되면 onComplete가 호출되고, CompletableFuture도 정상 종료된다
</div></div><h2>Blocking 컬렉션</h2><div><h3>BlockingQueue&lt;E></h3><ol><li>기본적으로 스레드-안전하지만, addAll 따위의 bulk 연산은 특별히 표시되지 않는 한 그렇지 않다</li><li>요소를 획득할 때, 큐가 비어있는 경우 블로킹. 요소를 추가할 때, 큐에 빈 자리가 있을 때까지 블로킹</li></ol><table><tr><th></th><th>예외 발생</th><th>특별값 반환</th><th>블로킹</th><th>시간 제한</th></tr><tr><th>Insert</th><td>add(E)</td><td>offer(E)</td><td>put(E)</td><td>offer(E,long,TimeUnit)</td></tr><tr><th>Remove</th><td>remove()</td><td>poll()</td><td>take()</td><td>poll(long,TimeUnit)</td></tr><tr><th>Examine</th><td>element()</td><td>peek()</td><td>-</td><td>-</td></tr></table><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">int remainingCapacity()
    // 블로킹없이 삽입 가능한 요소의 수. 오차가 있을 수 있다
int drainTo(Collection&lt;? super E> c)
    // 모든 원소를 c로 옮긴다
</div><h3>ArrayBlockingQueue&lt;E></h3><ol><li>크기가 고정된 기저 배열을 이용한 BlockingQueue</li><li>기본적으로 삽입을 기다리는 스레드들 사이의 처리 순서는 보장되지 않지만, fairness를 설정하면 FIFO 순으로 처리된다</li><li>Collection, Iterator의 모든 선택적 연산을 구현했다</li></ol><h3>LinkedBlockingQueue&lt;E></h3><ol><li>크기를 고정할 수 있는 연결된 BlockingQueue</li><li>Collection, Iterator의 모든 선택적 연산을 구현했다</li></ol><h3>PriorityBlockingQueue&lt;E></h3><ol><li>크기 제한 없고, PriorityQueue와 비슷한 정렬을 이용한 BlockingQueue</li><li>Collection, Iterator의 모든 선택적 연산을 구현했다</li><p>다만 iterator(), spliterator()로 제공되는 인스턴스들은 순회하는 순서를 보장하지 않는다. 순차적인 순회를 원한다면 Arrays.sort(queue.toArray())를 고려할 것</p><li>같은 우선순위의 원소 사이의 정렬은 정의되지 않았다</li></ol><h3>SynchronousQueue&lt;E></h3><ol><li>서로 연관된 삽입 연산과 삭제 연산 한 쌍이 동시에 존재할 때까지 연산을 블로킹한다</li><li>Collection, Iterator의 모든 선택적 연산을 구현했지만, 빈 컬렉션처럼 동작한다</li></ol><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">public SynchronousQueue(boolean fair)
    // fair : 대기하는 스레드들이 순서대로 처리된다. 지정되지 않으면 false
</div><h3>DelayQueue&lt;E extends Delayed></h3><ol><li>Delayed 요소들로 구성된, 크기 제한없는 BlockingQueue. 요소의 지연 시간이 만료되어야 큐로부터 획득 가능하다</li><p>요소가 만료됐음은 getDelay(TimeUnit.NANOSECONDS) 리턴값이 0 이하일 때로 판정</p><li>Collection, Iterator의 모든 선택적 연산을 구현했다</li></ol><h3>BlockingDeque&lt;E></h3><p>요소를 획득할 때, 덱이 비어있는 경우 블로킹. 요소를 추가할 때, 덱에 빈 자리가 있을 때까지 블로킹</p><table><tr><th></th><th>예외 발생</th><th>특별값 반환</th><th>블로킹</th><th>시간 제한</th></tr><tr><th>Insert</th><td>addFirst(E)<br>addLast(E)</td><td>offerFirst(E)<br>offerLast(E)</td><td>putFirst(E)<br>putLast(E)</td><td>offerFirst(E,long,TimeUnit)<br>offerLast(E,long,TimeUnit)</td></tr><tr><th>Remove</th><td>removeFirst()<br>removeLast()</td><td>pollFirst()<br>pollLast()</td><td>takeFirst()<br>takeLast()</td><td>pollFirst(long,TimeUnit)<br>pollLast(long,TimeUnit)</td></tr><tr><th>Examine</th><td>getFirst()<br>getLast()</td><td>peekFirst()<br>peekLast()</td><td>-</td><td>-</td></tr></table><h3>LinkedBlockingDeque&lt;E></h3><ol><li>크기를 제한할 수 있는 BlockingDeque</li><li>Collection, Iterator의 모든 선택적 연산을 구현했다</li></ol><h3>TransferQueue&lt;E></h3><ol><li>생산자가 소비자가 소비할 때까지 대기할 수 있는 BlockingQueue</li><li>기존의 BlockingQueue와 SynchronousQueue 기능 모두를 선택적으로 이용할 수 있다</li></ol><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">void transfer(E e)
    // 소비자에게 e를 전달한다. 소비자가 소비할 때까지 대기한다
boolean tryTransfer(E e)
    // 대기 중인 소비자에게 e를 전달한다. 대기 중인 소비자가 없다면 즉시 false를 반환한다
boolean tryTransfer(E e, long timeout, TimeUnit unit)
    // timeout이 지나도록 대기 중인 소비자가 없다면 false를 반환한다
</div><h3>LinkedTransferQueue&lt;E></h3><ol><li>크기 제한없고 연결된 TransferQueue</li><li>size 계산에 순회가 필요하므로 정확하지 않을 수 있다</li><li>addAll 따위의 bulk 연산은 원자적으로 실행되지 않을 수 있다</li><li>Collection, Iterator의 모든 선택적 연산을 구현했다</li></ol></div><h2>Non-Blocking 컬렉션</h2><div><h3>CopyOnWriteArrayList&lt;E></h3><ol><li>스레드-안전한 ArrayList</li><li>add, set 등의 연산마다 새로운 배열을 만든다. 따라서 일반적인 용도로는 매우 나쁘다</li><li>iterator는 생성된 시점의 snapshot을 순회함이 보장되지만, iterator를 통한 요소의 변경은 불가하다</li></ol><h3>CopyOnWriteArraySet&lt;E></h3><p>모든 연산에 CopyOnWriteArrayList를 사용하는 Set</p><h3>ConcurrentLinkedQueue&lt;E></h3><ol><li>크기 제한 없고, 스레드-안전한 연결된 Queue</li><li>size 계산에 순회가 필요하므로, 오차가 있을 수 있다</li><li>addAll 따위의 bulk 연산은 원자적으로 실행되지 않을 수 있다</li><li>Collection, Iterator의 모든 선택적 연산을 구현했다</li></ol><h3>ConcurrentlinkedDeque&lt;E></h3><ol><li>크기 제한 없고, 스레드-안전한 연결된 Deque</li><li>size 계산에 순회가 필요하므로, 오차가 있을 수 있다</li><li>addAll 따위의 bulk 연산은 원자적으로 실행되지 않을 수 있다</li><li>Collection, Iterator의 모든 선택적 연산을 구현했다</li></ol><h3>ConcurrentMap&lt;K, V></h3><ol><li>스레드-안전, 작업의 원자성 보장</li><p>Map의 각 연산, Map이 반환하는 컬렉션들의 연산 모두 재정의해야 한다</p></ol><h3>ConcurrentNavigableMap&lt;K, V></h3><p>NavigableMap 연산을 지원하는 ConcurrentMap</p><h3>ConcurrentHashMap&lt;K, V></h3><ol><li>읽기 연산에 대해서는 완전한 동시성을, 갱신 연산에 대해서는 높은 수준의 동시성을 제공</li><p>Hashtable의 모든 연산을 구현했다. 읽기 연산에 대해 원소를 잠그지는 않으며, 테이블 전체를 잠기는 기능 또한 없다. 가져간 원소를 사용하려고 하는 시점에는 맵에서 제거됐을 수도 있다</p><li>카운터로 사용할 수 있다. 예. map.computeIfAbsent(key, x -> new LongAdder()).increment();</li><li>Map, Iterator의 모든 선택적 연산을 구현했다</li><li>3가지 Bulk 연산을 지원한다 : forEach, search, reduce</li><p>인자로 받은 parallelismThreshold보다 맵이 작다고 판단되면 순차적으로 원소를 소비, 그 외엔 병렬로 소비. 1이면 최대 병렬성, Long.MAX_VALUE면 병렬 X</p><li>모든 작업 메서드의 매개변수는 non-null이어야 한다</li></ol><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">long mappingCount()
    // 크기가 매우 큰 경우, Map.size() 대신 이용

void forEach(long parallelismThreshold, BiConsumer&lt;? super K, ? super V> action)
    // + forEachKey, forEachValue, forEachEntry
&lt;U> U search(long parallelismThreshold, BiFunction&lt;? super K, ? super V, ? extends U> searchFunction)
    // 찾는 원소에 대해서는 non-null 반환
    // + searchKeys, searchValues, searchEntries
&lt;U> U reduce(long parallelismThreshold, BiFunction&lt;? super K, ? super V, ? extends U> transformer, BiFunction&lt;? super U, ? super U, ? extends U> reducer)
    // + reduceToDouble ~ Int, reduceKeys, reduceKeysToDouble ~ Int, reduceValues, reduceValuesToDouble ~ Int, reduceEntries, reduceEntriesToDouble ~ Int
</div><h3>ConcurrentSkipListMap&lt;K,V></h3><ol><li>ConcurrentNavigableMap 구현체. 평균 log(n) 시간이 소요되는, 스레드-안전한<a class="w3-btn w3-round-xxlarge w3-small w3-green" href="http://en.wikipedia.org/wiki/Skip_list">SkipList</a> 구현을 이용</li><li>오름차순 정렬된 뷰와 이터레이터가 내림차순보다 빠르다</li><li>putAll과 같은 bulk 연산은 원자적으로 종료되지 않을 수 있다</li><li>Map, Iterator의 모든 선택적 연산을 구현했다</li></ol><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">public ConcurrentSkipListMap(Comparator&lt;? super K> comparator)
    // 지정하지 않은 경우, 자연스러운 정렬을 이용한다
</div><h3>ConcurrentSkipListSet&lt;E></h3><p>ConcurrentSkipListMap을 이용한 NavigableSet</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">public ConcurrentSkipListSet(Comparator&lt;? super E> comparator)
    // 지정하지 않은 경우, 자연스러운 정렬을 이용한다
</div></div><h2>실행 기법</h2><div><h3>Semaphore</h3><ol><li>제한된 수의 접근 권한을 acquire()로 획득, release()로 반환</li><p>fairness : acquire()호출 순서대로 권한 획득</p><li>public Semaphore(int permits, boolean fair)</li><p>fair : 지정하지 않은 경우 false</p></ol><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">void acquire()
    // 권한을 하나 요구한다. 권한을 얻을 때까지 대기하며, 대기 중인 스레드는 인터럽트될 수 있다
void acquireUninterruptibly()
    // 대기 중일 때 인터럽트되더라도 계속 대기한다. 인터럽트되지 않았을 경우와 권한을 얻는 시기가 달라질 수 있다
boolean tryAcquire()
void release()
int availablePermits()
int drainPermits()
    // 가용한 모든 권한을 얻는다. 만약 음수라면 release하여 0으로 맞춘다
boolean isFair()

final boolean hasQueuedThreads()
final int getQueueLength()
</div><h3>CountDownLatch</h3><p>count가 0일 될때까지(원하는 작업들이 완료될 때까지), 1개 이상의 스레드가 대기하는 동기화 제공</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">public CountDownLatch(int count)

void await()
    // count가 0이 될때까지 대기한다. 대기 중에 인터럽트될 수 있다
boolean await(long timeout, TimeUnit unit)
    // 대기 중에 timeout을 넘으면 즉시 false 반환
void countDown()
    // --count, count가 0이면 대기하는 모든 스레드를 깨운다
</div><h3>CyclicBarrier</h3><p>스레드들이 공통의 목적이 달성되기까지 함께 대기. 그 목적을 barrier라고 하며, barrier를 재사용할 수 있어 cyclic하다</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">public CyclicBarrier(int parties, Runnable barrierAction)
    // barrierAction : barrier를 넘을 때 실행. 지정하지 않은 경우, 대기하던 스레드를 깨우기만 한다

int getParties()
int await()
    // 마지막 스레드가 await을 호출할 때까지 대기한다. 대기 중에 인터럽트될 수 있다. 현재 스레드의 대기 순번 반환. getParties() - 1이 첫 번째, 0이 마지막 스레드
int await(long timeout, TimeUnit unit)
    // timeout을 초과하여 대기하면 barrier는 부서진다
boolean isBroken()
void reset()
    // barrier를 초기 상태로 재설정한다. 이미 대기 중인 스레드가 있다면 BrokenBarrierException 발생. 부서진 barrier를 재사용하려면 별도의 동기화가 필요하므로, 차라리 새로 하나 만들자
int getNumberWaiting()
</div><h3>Exchanger&lt;V></h3><p>두 스레드가 같은 시점에 값을 서로 교환하도록 해준다</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">V exchange(V x) throws InterruptedException
    // 다른 스레드가 같은 지점에 도달하기까지 기다렸다가, 서로 값을 교환한다
V exchange(V x, long timeout, TimeUnit unit) throws InterruptedException, TimeoutException
    // timeout 초과 시 TimeoutException 발생
</div><h3>Phaser</h3><ol><li>재사용 가능한 동기화 barrier. CyclicBarrier, CountDownLatch 기능에 더해 보다 유연한 메서드 제공</li><li>CyclicBarrier와 다르게 각 회전마다 총 대기하는 스레드 수가 다를 수 있다</li><p>현재 phase가 완료되기 전에 미리 이후의 phase(들)을 등록할 수 있다. 각 phase는 0부터 시작하는 번호를 가진다(Integer.MAX_VALUE에 도달하면 다음은 다시 0)</p><li>계층 구조를 구성할 수 있다. 자식 Phaser의 parties가 0이 아니게 되는 순간 parent에 등록되고, 0이 되는 순간 parent에서 제거된다</li></ol><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">public Phaser(int parties)
    // parties : 다음 phase로 넘어가기 위해 필요한 수
public Phaser(Phaser parent, int parties)
    // parties : 다음 phase로 넘어가기 위해 필요한 수. 지정하지 않으면 0

int register()
    // 새로운 phase를 등록한다
    // + bulkRegister

int arrive()
    // 현재 phaser에 도착한다. 다른 스레드의 도착을 기다리지는 않는다. 현재 phase 번호를 반환한다(종료됐다면 음수)
int arriveAndDeregister()
    // 현재 phaser에 도착하고, 이후 phase에서는 자신이 빠짐을 알린다
int arriveAndAwaitAdvance()
    // 현재 phaser에 도착하고, 현재 phase의 모든 구성원이 도착할 때까지 기다린다 == awaitAdvance(arrive())
int awaitAdvance(int phase) + awaitAdvanceInterruptibly
    // 지정한 번호의 phase의 모든 구성원이 도착할 때까지 기다린다. 현재 phase의 번호와 다르거나, phaser가 종료된 경우엔 즉시 반환한다

void forceTermination()
    // 계층 구조에 속해있다면, 모든 phaser가 종료된다
final int getPhase()
    // 현재 phase 번호를 반환한다. Phaser가 종료됐다면 음수(마지막 phase 번호 + Integer.MAX_VALUE)를 반환한다
</div></div><h2>ThreadLocalRandom</h2><p>현재 스레드에 격리된 난수 생성기</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static ThreadLocalRandom current()</div><h2>TimeUnit</h2><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">NANOSECONDS, MICROSECONDS, MILLISECONDS, SECONDS, MINUTES, HOURS, DAYS

long convert(long sourceDuration, TimeUnit sourceUnit)

void timeWait(Object obj, long timeout)
    // timeout만큼 obj.wait()
void timedJoin(Thread thread, long timeout)
    // timeout만큼 Thread.join()
void sleep(long timeout)
</div></div><h1>java.util.concurrent.atomic</h1><div><h2>Package Summary</h2><ol><li>변수 하나에 대한 잠금 없는 스레드-안전성을 제공한다</li><li>VarHandle을 통해 변수를 원자적으로 접근한다</li><li>AtomicBoolean, AtomicInteger 등은 일반적인 Boolean, Integer 등을 대신할 수 없다</li><li>메모리 장벽을 만나면 CPU 코어의 캐시값이 RAM으로 반영된다</li></ol><h2>VarHandle</h2><ol><li>java.lang.invoke 패키지 멤버임</li><li>하나의 변수, 매개변수, 필드 등에 대한 동적인 타입 참조. plain 읽기/쓰기, volatile 읽기/쓰기, compare-and-set 접근을 지원한다</li></ol><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">final Object get(Object... args)
    // 변수가 non-volatile인 것처럼 읽는다(= plain read). 모든 VarHandle 인스턴스에서 지원된다
final void set(Object... args)
    // 변수가 non-volatile, non-final인 것처럼 쓴다(= plain write). 메서드 시그니처는 (CT1 ct1, ..., CTn ctn, T newValue)void

final Object getVolatile(Object... args)
    // 변수가 volatile인 것처럼 읽는다
final void setVolatile(Object... args)
    // 변수가 volatile인 것처럼 쓴다. 메서드 시그니처는 (CT1 ct1, ..., CTn ctn, T newValue)void

final Object getOpaque(Object... args)
    // Opaque : Program order 순서대로 접근한다. 다른 스레드와의 조율은 없다
    // + setOpaque

final Object getAcquire(Object... args)
    // 같은 변수에 대해 이어지는 load/store 연산이 이 접근보다 먼저 발생하지 않는다
final void setRelease(Object... args)
    // 같은 변수에 대한 이전의 load/store 연산이 이 접근보다 나중에 발생하지 않는다

final boolean compareAndSet(Object... args)
    // 원자적으로 다음이 실행된다. getVolatile과 동일한 문맥으로 가져온 값(witness value)이 expectedValue와 동일(==)하면 setVolatile과 동일한 문맥으로 newValue 설정 후 true 반환, 그 외엔 false 반환
    // 메서드 시그니처는 (CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)boolean
final Object compareAndExchange(Object... args)
    // 원자적으로 다음이 실행된다. getVolatile과 동일한 문맥으로 가져온 값(witness value)이 expectedValue와 동일(==)하면 setVolatile과 동일한 문맥으로 newValue 설정. 반환값은 witness value
final Object compareAndExchangeAcquire(Object... args)
    // 원자적으로 다음이 실행된다. getAcquire와 동일한 문맥으로 가져온 값(witness value)이 expectedValue와 동일(==)하면 set와 동일한 문맥으로 newValue 설정. 반환값은 witness value
final Object compareAndExchangeRelease(Object... args)
    // 원자적으로 다음이 실행된다. get와 동일한 문맥으로 가져온 값(witness value)이 expectedValue와 동일(==)하면 setRelease와 동일한 문맥으로 newValue 설정. 반환값은 witness value

final boolean weakCompareAndSetPlain(Object... args)
    // 다음이 실행된다. get과 동일한 문맥으로 가져온 값(witness value)이 expectedValue와 동일(==)하면 set과 동일한 문맥으로 newValue 설정 후 true 반환. 그 외엔 false
final boolean weakCompareAndSet(Object... args) + ~Acquire, ~Release
    // 다음이 실행된다. getVolatile과 동일한 문맥으로 가져온 값(witness value)이 expectedValue와 동일(==)하면 setVolatile과 동일한 문맥으로 newValue 설정 후 true 반환. 그 외엔 false

final Object getAndSet(Object... args) + ~Acquire, ~Release
    // 원자적으로 다음이 실행된다. getVolatile과 동일한 문맥으로 값(witness value)을 가져오고, setVolatile과 동일한 문맥으로 newValue 설정 후 witness value 반환
final Object getAndAdd(Object... args) + ~Acquire, ~Release
    // 원자적으로 값을 더한 후 이전 값 반환. 메서드 시그니처는 (CT1 ct1, ..., CTn ctn, T value)T
final Object getAndBitwiseOr(Object... args)
    // 원자적으로 OR 연산 수행 후 이전 값 반환. 메서드 시그니처는 (CT1 ct1, ..., CTn ctn, T mask)T
    // + ~Acquire, ~Release, getAndBitwiseAnd~, getAndBitwiseXor~

static void acquireFence()
    // 장벽 이전의 load 연산이 장벽 이후의 load/store 뒤로 재배치되지 않음
static void fullFence()
    // 장벽 이전의 load/store 연산이 장벽 이후의 load/store 뒤로 재배치되지 않음
static void releaseFence()
    // 장벽 이전의 load/store 연산이 장벽 이후의 store 뒤로 재배치되지 않음
static void loadLoadFence()
    // 장벽 이전의 load 연산이 장벽 이후의 load 뒤로 재배치되지 않음
static void storeStoreFence()
    // 장벽 이전의 store 연산이 장벽 이후의 store 뒤로 재배치되지 않음</div><div><h3>VarHandle.AccessMode</h3><table><tr><th>GET</th><td>VarHandle.get</td></tr><tr><th>SET</th><td>VarHandle.set</td></tr><tr><th>GET_VOLATILE</th><td>VarHandle.getVolatile</td></tr><tr><th>SET_VOLATILE</th><td>VarHandle.setVolatile</td></tr><tr><th>GET_ACQUIRE</th><td>VarHandle.getAcquire</td></tr><tr><th>SET_RELEASE</th><td>VarHandle.setRelease</td></tr><tr><th>GET_OPAQUE</th><td>VarHandle.getOpaque</td></tr><tr><th>SET_OPAQUE</th><td>VarHandle.setOpaque</td></tr><tr><th>COMPARE_AND_SET</th><td>VarHandle.compareAndSet</td></tr><tr><th>COMPARE_AND_EXCHANGE</th><td>VarHandle.compareAndExchange</td></tr><tr><th>COMPARE_AND_EXCHANGE_ACQUIRE</th><td>VarHandle.compareAndExchangeAcquire</td></tr><tr><th>COMPARE_AND_EXCHANGE_RELEASE</th><td>VarHandle.compareAndExchangeRelease</td></tr><tr><th>WEAK_COMPARE_AND_SET_PLAIN</th><td>VarHandle.weakCompareAndSetPlain</td></tr><tr><th>WEAK_COMPARE_AND_SET</th><td>VarHandle.weakCompareAndSet</td></tr><tr><th>WEAK_COMPARE_AND_SET_ACQUIRE</th><td>VarHandle.weakCompareAndSetAcquire</td></tr><tr><th>WEAK_COMPARE_AND_SET_RELEASE</th><td>VarHandle.weakCompareAndSetRelease</td></tr><tr><th>GET_AND_SET</th><td>VarHandle.getAndSet</td></tr><tr><th>GET_AND_SET_ACQUIRE</th><td>VarHandle.getAndSetAcquire</td></tr><tr><th>GET_AND_SET_RELEASE</th><td>VarHandle.getAndSetRelease</td></tr><tr><th>GET_AND_ADD</th><td>VarHandle.getAndAdd</td></tr><tr><th>GET_AND_ADD_ACQUIRE</th><td>VarHandle.getAndAddAcquire</td></tr><tr><th>GET_AND_ADD_RELEASE</th><td>VarHandle.getAndAddRelease</td></tr><tr><th>GET_AND_BITWISE_OR</th><td>VarHandle.getAndBitwiseOr</td></tr><tr><th>GET_AND_BITWISE_OR_RELEASE</th><td>VarHandle.getAndBitwiseOrRelease</td></tr><tr><th>GET_AND_BITWISE_OR_ACQUIRE</th><td>VarHandle.getAndBitwiseOrAcquire</td></tr><tr><th>GET_AND_BITWISE_AND</th><td>VarHandle.getAndBitwiseAnd</td></tr><tr><th>GET_AND_BITWISE_AND_RELEASE</th><td>VarHandle.getAndBitwiseAndRelease</td></tr><tr><th>GET_AND_BITWISE_AND_ACQUIRE</th><td>VarHandle.getAndBitwiseAndAcquire</td></tr><tr><th>GET_AND_BITWISE_XOR</th><td>VarHandle.getAndBitwiseXor</td></tr><tr><th>GET_AND_BITWISE_XOR_RELEASE</th><td>VarHandle.getAndBitwiseXorRelease</td></tr><tr><th>GET_AND_BITWISE_XOR_ACQUIRE</th><td>VarHandle.getAndBitwiseXorAcquire</td></tr></table></div><h2>AtomicBoolean</h2><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">public AtomicBoolean(boolean initialValue)
    // 지정하지 않으면 false

final boolean get()                                                     // VarHandle::getVolatile
final boolean compareAndSet(boolean expectedValue, boolean newValue)    // VarHandle::compareAndSet
boolean weakCompareAndSetPlain(boolean expectedValue, boolean newValue) // VarHandle::weakCompareAndSetPlain
final void set(boolean newValue)                                        // VarHandle::setVolatile
final void lazySet(boolean newValue)                                    // VarHandle::setRelease
final boolean getAndSet(boolean newValue)                               // VarHandle::getAndSet
final boolean getPlain()                                                // VarHandle::get
final void setPlain(boolean newValue)                                   // VarHandle::set
final boolean getOpaque()                                               // VarHandle::getOpaque
final void setOpaque(boolean newValue)                                  // VarHandle::setOpaque
final boolean getAcquire()                                              // VarHandle::getAcquire
final void setRelease(boolean newValue)                                 // VarHandle::setRelease
final boolean compareAndExchange(boolean expectedValue, boolean newValue)
    // 메모리 영향은 VarHandle::compareAndExchange와 같다
    //  + ~Acquire, ~Release
final boolean weakCompareAndSetVolatile(boolean expectedValue, boolean newValue)
    // 메모리 영향은 VarHandle::weakCompareAndSet와 같다
    // + ~Acquire, ~Release
</div><h2>AtomicIntegerArray</h2><p>인덱스를 추가로 받는 것 외에, 지원하는 메서드들은 AtomicInteger와 같다</p><h2>AtomicIntegerFieldUpdater&lt;T> + AtomicLongFieldUpdater, AtomicReferenceFieldUpdater</h2><ol><li>지정된 volatile int 필드를 atomic 연산으로 갱신</li><p>해당 필드를 단일 업데이터로만 접근한다면, compareAndSet 메서드들이 원자적으로 작동됨이 보장된다</p><li>지원하는 메서드는 AtomicInteger와 유사하다</li></ol><h2>AtomicMarkableReference&lt;V></h2><p>원자적으로 갱신되는 마커 bit와 객체 참조 쌍</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">public AtomicMarkableReference(V initialRef, boolean initialMark)

V getReference()
V get(boolean[] markHolder)
    //markHolder[0]에 해당하는 참조 반환

boolean compareAndSet(V expectedReference, V newReference, boolean expectedMark, boolean newMark)
    // 기존 참조와 마커 bit가 모두 예상과 동일(==)하다면 원자적으로 갱신하고 true 반환. 그 외엔 false
    // + weakCompareAndSet
void set(V newReference, boolean newMark)
boolean attemptMark(V expectedReference, boolean newMark)
    // 기존 참조가 예상과 동일(==)하다면, 마커 bit를 원자적으로 갱신하고 true 반환. 그 외엔 false
</div><h2>AtomicStampedReference&lt;V></h2><p>원자적으로 갱신되는 index와 참조 쌍</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">public AtomicStampedReference(V initialRef, int initialStamp)

V getReference()
V get(int[] stampHolder)
    // stampHolder[0]에 해당하는 참조 반환

boolean compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp)
    // 기존 참조와 인덱스가 예상과 동일(==)하다면 원자적으로 갱신하고 true 반환. 그 외엔 false
    // + weakCompareAndSet
void set(V newReference, int newStamp)
boolean attempStamp(V expectedReference, int newStamp)
    //기존 참조가 예상과 동일(==)하다면, 인덱스를 원자적으로 갱신하고 true 반환. 그 외엔 false
</div><h2>LongAdder</h2><ol><li>초깃값 0으로 시작하는 스레드-안전한 합계</li><p>합의 순서는 정의되지 않으므로 순서에 상관 없는 경우에 이용해야 한다</p></ol><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">void add(long x)
void increment()
void decrement()
long sum() // 현재 합계
void reset()
long sumThenReset()
</div><h2>LongAccumulator</h2><ol><li>특정 값과 특정 함수로 갱신되는 long 값 유지</li><p>주어진 accumulatorFunction은 부작용이 없어야 한다</p></ol><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">void accumulate(long x)
long get()
void reset()
long getThenReset()
</div></div><h1>java.util.function</h1><div><h2>Consumer</h2><div><h3>Consumer&lt;T></h3><p>인자를 하나 먹고 아무것도 반환하지 않는 소비자</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">void accept(T t)
default Consumer&lt;T> andThen(Consumer&lt;? super T> after)
    // 이 소비자 다음에 after가 소비하는 병합된 소비자 반환
</div><h3>DoubleConsumer + int, long</h3><h3>BiConsumer&lt;T, U></h3><p>인자 두개를 먹고 아무것도 뱉지 않는 소비자</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">void accept(T t, U u)
default BiConsumer&lt;T, U> andThen(BiConsumer&lt;? super T, ? super U> after)
    // 현재 소비자가 작업을 마치면 after가 실행되는 새로운 소비자 반환
</div><h3>ObjDoubleConsumer&lt;T> + int, long</h3></div><h2>Supplier</h2><div><h3>Supplier&lt;T></h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">T get()</div><h3>BooleanSupplier + int, double, long</h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">boolean getAsBoolean()</div></div><h2>Function, Operator</h2><div><h3>Function&lt;T, R></h3><p>인자 하나를 먹고 결과 하나를 뱉는 함수</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">R apply(T t)
default &lt;V> Function&V, R> compose(Function&lt;? super V, ? extends T> before)
default &lt;V> Function&lt;T, V> andThen(Function&lt;? super R, ? extends V> after)
static &lt;T> Function&lt;T, T> identity()
    // 입력 인자 그대로 반환하는 함수
</div><h3>IntFunction&lt;R> + double, long</h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">R apply(int value)</div><h3>DoubleToIntFunction + double, int, long 간의 모든 상호 변환</h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">int applyAsInt(double value)</div><h3>UnaryOperator&lt;T></h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static &lt;T> UnaryOperator&lt;T> identity()</div><h3>DoubleUnaryOperator + int, long</h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">double applyAsDouble(double operand)
default DoubleUnaryOperator compose(DoubleUnaryOperator before)
default DoubleUnaryOperator andThen(DoubleUnaryOperator after)
static DoubleUnaryOperator identity()
    // 항상 입력값 그대로 반환하는 단항 연산자 반환
</div><h3>ToDoubleFunction&lt;T></h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">double applyAsDouble(T value) // + int, long</div><h3>BiFunction&lt;T, U, R></h3><p>인자 두개를 먹고 값을 반환하는 함수</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">default &lt;V> BiFunction&lt;T, U, V> andThen(Function&lt;? super R, ?
    // 함수가 실행되고 난 결과를 after가 처리하는 새로운 함수 반환
</div><h3>ToDoubleBiFunction&lt;T, U></h3><details>double applyAsDouble(T t, U u) // + int, long</details><h3>BinaryOperator</h3><p>같은 타입의 인자 두개를 먹고 같은 타입의 값을 반환하는 함수</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static &lt;T> BinaryOperator&lt;T> minBy(Comparator&lt;? super T> comparator)
    // 주어진 comparator에 따라 둘 중 작은 것을 반환하는 함수를 생성
    // + maxBy
</div><h3>DoubleBinaryOperator</h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">double applyAsDouble(double left, double right)
    // double 두개를 먹고 double 하나를 반환하는 함수. + int, long
</div></div><h2>Predicate</h2><div><h3>Predicate&lt;T></h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">boolean test(T t)
default Predicate&lt;T> and(Predicate&lt;? super T> other)
default Predicate&lt;T> or(Predicate&lt;? super T> other)

static &lt;T> Predicate&lt;T> isEqual(Object targetRef)
    // Object.equals(Object, Object)를 이용해 비교하는 Predicate 반환
</div><h3>DoublePredicate + int, long</h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">default DoublePredicate negate()
</div><h3>BiPredicate&lt;T, U></h3><p>인자 두개를 먹고 가부를 판단하는 함수</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">default BiPredicate&lt;T, U> and(BiPredicate&lt;? super T, ? super U> other)
    // A short-circuiting logical AND of this predicate and other
    // + or
default BiPredicate&lt;T, U> negate()
</div></div></div><h1>java.util.regex</h1><div><h2>MatchResult</h2><p>정규표현식 매칭 결과. group의 의미에 대해선 Pattern 참고<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/regex/MatchResultExample.java" lan="java">MatchResultExample.java</button></p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">int start()             // 매치된 결과의 시작 인덱스 반환
int start(int group)    // group번째 매치된 결과의 시작 인덱스 반환
int end()               // 매치된 결과의 마지막 글자 다음 인덱스 반환
int end(int group)      // group번째 매치된 결과의 마지막 글자 다음 인덱스 반환
String group()          // 이전 매치된 결과 반환
String group(int group) // group번째 매치된 결과 반환
int groupCount()        // 매치된 group 개수 반환
</div><h2>Pattern</h2><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">public static final int UNIX_LINES       // 줄끝 '\n'만 ., ^, $에서 동작. (?d) 플래그도 같은 의미
public static final int CASE_INSENSITIVE // 대소문자 구분 없음. (?i) 플래그도 같은 의미
public static final int COMMENTS         // 공백과 주석 허용. 공백과 #부터 줄 끝까지의 주석이 무시된다. (?x) 플래그도 같은 의미
public static final int MULTILINE        // ^, $이 각 줄의 끝을 기준으로도 작동; 기본 동작은 입력 시작과 끝에서만 작동. (?m) 플래그도 같은 의미
public static final int LITERAL          // 표현식 전체를 상수 문자열 취급
public static final int DOTALL           // .이 줄 끝도 포함하여 매치; 기본 동작은 줄 끝 문자는 미포함. (?s) 플래그도 같은 의미
public static final int UNICODE_CASE     // CASE_INSENSITIVE 플래그가 유니코드 표준 상에서 동작한다; 기본은 US-ASCII에서만 동작. (?u) 플래그도 같은 의미


static Pattern compile(String regex)
static boolean matches(String regex, CharSequence input) // 1회용
static String quote(String s) // s를 매칭할 수 있는 정규표현식 리터럴 문자열 표현을 반환
Predicate&lt;String> asPredicate()
Stream&lt;String> splitAsStream(CharSequence input)</div><div><h3>Line terminator</h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">"\n", "\r\n", "\r", "\u0085", "\u2028", "\u2029"
// UNIX_LINES 모드에서는 "\n"만 줄 끝으로 인식</div><h3>Groups and capturing</h3><ul><li>Group : 괄호로 감싸인 정규표현식 (X)</li><li>Capturing group : 괄호 순서에 따라 그룹에 ID가 매겨지며, 이는 나중에 참조(backreference)될 수 있다</li><p>0번 그룹은 항상 전체 표현을 가리킨다<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java" displayRange="[16,26]" lan="java">예를 들어</button> (A)(B(C))에 대하여,</p><table class="no-sort"><tr><th>Group ID</th><th>Pattern</th></tr><tr><td>0</td><td>(A)(B(C))</td></tr><tr><td>1</td><td>(A)</td></tr><tr><td>2</td><td>(B(C))</td></tr><tr><td>3</td><td>(C)</td></tr></table><li>Non-capturing group : (?:X)는 후참조(backreference)할 수 없다<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java" displayRange="[28,37]" lan="java">RegexExample.java</button></li></ul><h3>Character expression</h3><ul><li>x, \\ : 각각 x, \에 대응<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java" displayRange="[39,39]" lan="java">RegexExample.java</button></li><li>\0n, \0nn, \0nnn : 8진수 아스키 코드[0,255] == [00, 0377]<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java" displayRange="[40,40]" lan="java">RegexExample.java</button></li><li>\xhh : 16진수 아스키 코드[0,255]<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java" displayRange="[41,41]" lan="java">RegexExample.java</button></li><li>\uhhhh, \u{h...h} : 16진수 유니코드[Character.MIN_CODE_POINT, Character.MAX_CODE_POINT]<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java" displayRange="[42,42]" lan="java">RegexExample.java</button></li><li>\N{name} : 유니코드 이름<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java" displayRange="[43,43]" lan="java">RegexExample.java</button></li><li>\t(tab \u0009), \n(newline \u000A), \r(carriage-return \u000D), \f(form-feed \u000C), \a(alert \u0007), \e(escape \u001B), \cx(x에 관한 제어 문자)</li></ul><h3>Character class</h3><ul><li>[abc] : 단순 집합<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java" displayRange="[44,44]" lan="java">RegexExample.java</button></li><li>[^abc] : 여집합<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java" displayRange="[45,45]" lan="java">RegexExample.java</button></li><li>[a-z] : 유니코드 Range(inclusive)<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java" displayRange="[46,46]" lan="java">RegexExample.java</button></li><li>[a-d[m-p]] == [a-dm-p] : 합집합<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java" displayRange="[47,47]" lan="java">RegexExample.java</button></li><li>[a-z&&[def]] : 교집합<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java" displayRange="[48,48]" lan="java">RegexExample.java</button></li><li>[a-z&&[^bc]] : 차집합(A and not(B) == A - B)<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java" displayRange="[49,49]" lan="java">RegexExample.java</button></li></ul><h3>Predefined character classe</h3><ul><li>. : 임의 문자. DOTALL 플래그가 있으면 line terminator도 매칭</li><li>\d : [0-9], \D : [^\d]</li><li>\s : 공백 문자 [ \t\n\x0B\f\r], \S : [^\s]</li><li>\h : 수평 공백 [ \t\xA0\u1680\u180e\u2000-\u200a\u202f\u205f\u3000], \H : [^\h]</li><li>\v : 수직 공백 [\n\x0B\f\r\x85\u2028\u2029], \V : [^\v]</li><li>\w : Word character, \W : [^w]</li></ul><h3>java.lang.Character class</h3><ul><li>\p{javaLowerCase} : Character.isLowerCase()</li><li>\p{javaUpperCase} : Character.isUpperCase()</li><li>\p{javaWhitespace} : Character.isWhitespace()</li><li>\p{javaMirrored} : Character.isMirrored()</li></ul><h3>Unicode class</h3><ul><li>\R : 임의 줄바꿈 문자열 \u000D\u000A|[\u000A\u000B\u000C\u000D\u0085\u2028\u2029]</li><li>\X : Any Unicode extended grapheme cluster</li><li>\b{g} : A Unicode extended grapheme cluster boundary</li><li>\P{expr} == [^\p{expr}]</li>\p{IsLatin} : Latin<strong>script</strong>, \p{InGreek} : Greek<strong>block</strong>, \p{Lu} : Uppercase letter(<strong>category</strong>), \p{IsAlphabetic} :<strong>binary property</strong>, \p{Sc} : Currency symbol</ul><h3>Boundary matcher</h3><ul><li>^ : 줄 시작, $ : 줄 끝</li><li>\b : 단어 경계, \B : 비단어 경계</li><li>\A : The beginning of the input</li><li>\G : The end of the previous match</li><li>\z » The end of the input</li></ul><h3>Greedy quantifier</h3><ul><p>처음에 매치할 수 있는 만큼 최대한 매치. 그 다음 요소의 매칭이 없으면 백트래킹<a class="w3-btn w3-round-xxlarge w3-small w3-green" href="https://stackoverflow.com/questions/5319840/greedy-vs-reluctant-vs-possessive-quantifiers">참고자료</a></p><li>X? : X, once or not at all</li><li>X* : X, zero or more times</li><li>X+ : X, one or more times</li><li>X{n} : X, exactly n times</li><li>X{n,} : X, at least n times</li><li>X{n,m} : X, at least n but not more than m times</li></ul><h3>Reluctant quantifier</h3><p>처음에 최소한만 매치. 그 다음 요소의 매칭이 없으면 백트래킹X??, X*?, X+?, X{n}?, X{n,}?, X{n,m}?</p><h3>Possessive quantifier</h3><p>Greedy quantifier와 같지만, 백트래킹은 없다X?+, X*+, X++, X{n}+, X{n,}+, X{n,m}+</p><h3>Logical operation</h3><ul><li>XY : X followed by Y</li><li>X|Y : Either X or Y</li><li>(X) : X, as a capturing group</li></ul><h3>Backreference</h3><ul><li>\n : The n-th capturing group matched</li><li>\k&lt;name> : Tthe named-capturing group "name" matched</li><p>↑ 정규표현식 내에서는 위 두 가지 backreference가 가능하며, replace()에서는 $0, $1, $2, ...로 표기한다<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java" displayRange="[51,57,59,71,73,85]" lan="java">RegexExample.java</button></p></ul><h3>Quotation</h3><ul><li>\ : Nothing, but quotes the following character</li><li>\Q : Nothing, but quotes all characters until \E</li><li>\E : Nothing, but ends quoting started by \Q</li></ul><h3>Special construct</h3><ul><li>(?&lt;name>X) : X, as a named-capturing group<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java" displayRange="[59,71]" lan="java">RegexExample.java</button></li><li>(?:X) : X, as a non-capturing group</li><li>(?idmsuxU-idmsuxU) : 각 플래그를 켜거나 끈다</li><li>(?idmsux-idmsux:X) : 주어진 플래그로 non-capturing group X를 매칭한다</li><li>(?=X) : Positive lookahead, (?!X) : Negative lookahead</li><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java" displayRange="[51,57]" lan="java">RegexExample.java</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java" displayRange="[87,102]" lan="java">금칙어 판별</button><li>(?&lt;=X) : Positive lookbehind, (?&lt;!X) : Negative lookbehind</li><li>(?>X) : Non-capturing group + Possessive</li></ul></div><h2>Matcher</h2><p>Pattern으로부터 만들어지는 매칭 엔진으로, 아래 세 가지 작업을 수행한다</p><ol><li>matches() : 전체 입력에 대해 패턴 매칭</li><li>lookingAt() : 입력 시작부분 패턴 매칭</li><li>find() : 입력의 다음 부분 패턴 매칭</li></ol><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">MatchResult toMatchResult()
Stream&lt;MatchResult> results()

Matcher usePattern(Pattern newPattern)
Matcher reset()

int start(String name) // 주어진 식별자에 해당하는 그룹의 시작 인덱스 반환
int end(String name)
String group(String name)

static String quoteReplacement(String s)
    // appendReplacement 메서드의 replacement로 사용될 s의 리터럴 표기를 반환
Matcher appendReplacement(StringBuffer sb, String replacement)
    // 1. 입력 소스의 append position부터 start() 전까지 sb에 추가
    // 2. replacement를 sb에 추가
    // 3. 현재 matcher의 append position을 end()로 설정
StringBuffer appendTail(StringBuffer sb)
    // 입력 소스의 append position부터를 sb에 추가
    // appendReplacement 메서드를 호출한 뒤에 이를 호출하여 남머지 부분을 복사할 목적으로 만들어짐

String replaceAll(String replacement)
    // 입력 소스의 모든 매칭되는 부분을 replacement로 변경
String replaceAll(Function&lt;MatchResult, String> replacer)
String replaceFirst(String replacement)

Matcher region(int start, int end)
    // 입력 소스의 특정 구간을 매칭 대상으로 하도록 초기화한다. transparency, anchoring 속성에 따라 동작이 다르다
Matcher useTransparentBounds(boolean b)
    // region의 경계 너머를 패턴 매칭에 보이도록 할지 여부
Matcher useAnchoringBounds(boolean b)
    // region의 경계에서 ^, $를 작동하게 할지 여부

</div></div><h1>java.util.stream</h1><div><h2>BaseStream&lt;T, S</h2><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">Iterator&lt;T> iterator()
Spliterator&lt;T> spliterator()
boolean isParallel()
S sequential() // 순차적인 스트림 반환(어쩌면 자기 자신)
S parallel()   // 병렬적인 스트림 반환(어쩌면 자기 자신)
S unordered()  // 순서 없는 스트림 반환(어쩌면 자기 자신)
S onClose(Runnable closeHandler)
</div><h2>DoubleStream</h2><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">double sum()
OptionalDouble min(), max(), average(), findFirst(), findAny()
DoubleSummaryStatistics SummaryStatistics()
Stream&lt;Double> boxed()
</div><h2>IntStream</h2><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static IntStream range(int startInclusive, int endExclusive)
static IntStream rangeClosed(int startInclusive, int endInclusive)
</div><h2>Stream&lt;T></h2><ol><li>2가지 스트림 연산</li><ul><li>Terminal Operation</li><p>종결 연산. 스트림 연산 파이프라인의 마지막으로, 더 이상 스트림 연산을 수행할 수 없다</p><li>Intermediate Operation</li><p>중간 연산. 새로운 스트림을 반환한다</p></ul><li>2가지 중간 연산</li><ul><li>Stateless Operation</li><p>요소의 연산 과정에 상태의 보존이 필요 없는 경우. filter, map 등</p><li>Stateful Operation</li><p>요소의 연산 과정에 상태의 보존이 필요한 경우. sorted, distinct 등<br>이러한 연산을 사용하기 위해선 스트림 전체 인풋이 필요할 수 있으며, 병렬 스트림에서는 요구되는 버퍼의 크기가 늘어나게 된다</p></ul><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/JavaSE/src/util/FlatMapExample.java" lan="java">FlatMapExample.java</button></ol><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">// 팩터리 메서드
static &lt;T> Stream.Builder&lt;T> builder()
static &lt;T> Stream&lt;T> empty()
static &lt;T> Stream&lt;T> of(T t)
static &lt;T> Stream&lt;T> ofNullable(T t)
@SafeVarargs static &lt;T> Stream&lt;T> of(T... values)
static &lt;T> Stream&lt;T> iterate(T seed, UnaryOperator&lt;T> f)
static &lt;T> Stream&lt;T> iterate(T seed, Predicate&lt;? super T> hasNext, UnaryOperator&lt;T> next) // Since 9
static &lt;T> Stream&lt;T> generate(Supplier&lt;? extends T> s)
static &lt;T> Stream&lt;T> concat(Stream&lt;? extends T> a, Stream&lt;? extends T> b)


// 중간 연산
Stream&lt;T> filter(Predicate&lt;? super T> predicate)
    // predicate이 true인 요소만 남긴다

&lt;R> Stream&lt;R> map(Function&lt;? super T, ? extends R> mapper)
    // mapper : 하나의 T 변수에서 하나의 R 변수로 대응하는 변환
IntStream mapToInt(ToIntFunction&lt;? super T> mapper)
    // + long, double
&lt;R> Stream&lt;R> flatMap(Function&lt;? super T, ? extends Stream&lt;? extends R>> mapper)
    // mapper : 하나의 T 변수에서 여러 R 변수(R 스트림)로 대응하는 변환
    // mapper를 이용해 만들어진 여러 R 스트림을 일렬로 펴서(flattening) 하나의 R 스트림으로 변환. mapper가 null을 반환하면 빈 스트림을 대신 이용된다
    // 최종적으로 반환되는 스트림 외의 모든 중간 스트림은 닫힌다
IntStream flatMapToInt(Function&lt;? super T, ? extends IntStream> mapper )
    // + long, double

Stream&lt;T> distinct()
    // Object.equals(Object)를 이용해 유일한 것들만으로 구성. stateful 중간 연산
Stream&lt;T> sorted()
    // 자연스러운 방향으로 정렬. T가 Comparable하지 않으면 예외 발생할 수 있음. stateful 중간 연산
Stream&lt;T> sorted(Comparator&lt;? super T> comparator)

Stream&lt;T> peek(Consumer&lt;? super T> action)
    // forEach와 유사한 기능을 하는 중간 연산. 다른 중간 연산 전후의 값을 살펴보는 디버깅 용도로 만들어짐

Stream&lt;T> limit(long maxSize)
    // 스트림의 크기가 maxSize 이하가 되도록 한다. short-circuiting stateful 중간 연산
Stream&lt;T> skip(long n)
    // n개를 버린 나머지로 스트림을 구성해 반환한다. 더 없으면 빈 스트림이 반환된다
default Stream&lt;T> takeWhile(Predicate&lt;? super T> predicate)
    // 요소들을 하나씩 검사하여, predicate을 만족하지 않는 요소가 나오기 전까지로 구성된 스트림을 반환한다
    // 순서 있는 스트림에 대하여는 조건을 만족하는 최장 길이 접두 요소들을 얻게 되며, 순서 없는 스트림은 조건을 만족하는 부분 집합을 얻게 된다
    // short-circuiting stateful 중간 연산
    // 일반적으로 연산이 저렴하지만, 순서 있는 병렬 스트림에 대하여는 최장 길이 접두 요소들을 찾기 위해 연산이 비싸지므로, 허용된다면 순서 없는 스트림 소스(generate(Supplier))를 이용하거나, BaseStream.unordered()를 이용해 순서를 없애는 것이 성능에 도움이 될 것이다
default Stream&lt;T> dropWhile(Predicate&lt;? super T> predicate)
    // stateful 중간 연산


// 종결 연산
void forEach(Consumer&lt;? super T> action)
void forEachOrdered(Consumer&lt;? super T> action
    // 순서 있는 스트림의 경우, 이를 이용하면 요소의 순서대로 소비자가 실행된다

Object[] toArray()
&lt;A> A[] toArray(IntFunction&lt;A[]> generator)
    // generator : 배열 크기를 먹고 배열을 뱉는 함수. 예: A[]::new

T reduce(T identity, BinaryOperator&lt;T> accumulator)
    // 하나의 T 변수로 축약하는 종결 연산. 아래와 동치다
{
    var result = identity;
    for(T element : stream)
        result = accumulator.apply(result, element);
    return result;
}
Optional&lt;T> reduce(BinaryOperator&lt;T> accumulator
    // 하나의 T로 축약하는 종결 연산. 처음 연산 결과는 null이며, 스트림 첫 번째 요소를 만나면 치환된다. 이후는 reduce(T, BinaryOperator)와 같다
&lt;U> U reduce(U identity, BiFunction&lt;U, ? super T, U> accumulator, BinaryOperator&lt;U> combiner)
    // 하나의 U 변수로 축약하는 종결 연산. 연산은 reduce(T, BinaryOperator)와 동일한데, identity 값은 combiner 연산에 대한 항등원이어야 한다
    // 다시 말해, 임의의 U 타입 변수 u에 대하여 u == combiner(identity, u)를 만족해야 한다
    // 이는 연산 과정에서 다음의 검사를 통해 검증된다. combiner.apply(u, accumulator.apply(identity, t)) == accumulator.apply(u, t)
    // 이렇게 복잡하게 하는 것보다는 map과 reduce를 쪼개 이용하는 것이 훨씬 간결하므로 유념

&lt;R> R collect(Supplier&lt;R> supplier, BiConsumer&lt;R, ? super T> accumulator, BiConsumer&lt;R, R> combiner)
    // 하나의 R 변수로 축약하는 종결 연산. reduce와 다르게 R 자체가 결과값에 대한 가변적인 컨테이너(ArrayList, String 등)가 되어야 한다. 아래와 동치다
    // 여기서는 combiner를 사용하지 않는 것처럼 보이지만, combiner는 병렬 스트림 연산을 위해 존재하는 것이므로, 연산 결과 자체는 아래와 동치가 맞다
{
    var result = supplier.get();
    for(T element : stream)
        accumulator.accept(result, element);
    return result;
}
    // 메서드 참조 예
{
    collect(ArrayList::new, ArrayList::add, ArrayList::addAll);
    collect(StringBuilder::new, StringBuilder::append, StringBuilder::append);
}
&lt;R, A> collect(Collector&lt;? super T, A, R> collector)
    // collect(Supplier, BiConsumer, BiConsumer)의 매개변수를 캡슐화한 Collector를 이용
    // Collectors 유틸리티 클래스에 이미 정의된 Collector들이 있으니 편하게 이용 가능

Optional&lt;T> min(Comparator&lt;? super T> comparator) // + max
long count()
    // 개수를 반환하는 종결 연산
boolean anyMatch(Predicate&lt;? super T> predicate)
    // short-circuiting 종결 연산
    // + allMatch, noneMatch
Optional&lt;T> findFirst()
    // short-circuiting 종결 연산
    // + findAny</div><div><h3>Stream.Builder&lt;T></h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">void accept(T t)
default Stream.Builder&lt;T> add(T t)
Stream&lt;T> build()
</div></div><h2>StreamSupport</h2><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static &lt;T> Stream&lt;T> stream(Spliterator&lt;T> spliterator, boolean parallel)
static &lt;T> Stream&lt;T> stream(Supplier&lt;? extends Spliterator&lt;T>> supplier, int characteristics, boolean parallel)
    // characteristics = supplier.get().characteristics()
static IntStream intStream(Spliterator.OfInt spliterator, boolean parallel)
    // + long, double
static IntStream intStream(Supplier&lt;? extends Spliterator.OfInt> supplier, int characteristics, boolean parallel)
    // characteristics = supplier.get().characteristics()
</div><h2>Collector&lt;T, A, R></h2><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static enum Collector.Characteristics {
    CONCURRENT, IDENTITY_FINISH, UNORDERED;
}

Supplier&lt;A> supplier()
    // 결과 컨테이너인 A를 생성하는 함수 반환
BiConsumer&lt;A, T> accumulator()
    // A의 결과에 T 타입 데이터를 축적하는 함수
BinaryOperator&lt;A> combiner()
    // 두 결과 컨테이너를 받아 하나로 반환하는 함수
Function&lt;A, R> finisher()
    // 결과 컨테이너로부터 최종 결과 R으로 변환하는 함수 반환
Set&lt;Collector.Characteristics> characteristics()

static &lt;T, A, R> Collector&lt;T, A, R> of(Supplier&lt;A> supplier, BiConsumer&lt;A, T> accumulator, BinaryOperator&lt;A> combiner, Function&lt;A, R> finisher, Collector.Characteristics... characteristics)
</div><h2>Collectors</h2><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static &lt;T, C extends Collection&lt;T>> Collector&lt;T, ?, C> toCollection(Supplier&lt;C> collectionFactory)
    // collectionFactory로 생성한 Collection 객체에 원소들을 만나는 순서대로 집어넣는 Collector 반환
static &lt;T> Collector&lt;T, ?, List&lt;T>> toList()
    // 새로운 List 객체에 입력 원소들을 모두 담아 반환하는 Collector. 반환된 List의 타입, 변경 가능 여부, 직렬화, 스레드-안전 그 무엇도 보장하지 않음
static &lt;T> Collector&lt;T, ?, List&lt;T>> toUnmodifiableList() // Since 10
static &lt;T> Collector&lt;T, ? Set&lt;T>> toSet()
    // 새로운 Set 객체에 입력 원소들을 모두 담아 반환하는 Collector. 반환된 Set의 타입, 변경 가능 여부, 직렬화, 스레드-안전 그 무엇도 보장하지 않음
static &lt;T> Collector&lt;T, ?, Set&lt;T>> toUnmodifiableSet() // Since 10

static Collector&lt;CharSequence, ?, String> joining()
    // String에 만나는 순서대로 덧붙이는 Collector

static &lt;T, U, A, R> Collector&lt;T, ?, R> mapping(Function&lt;? super T, ? extends U> mapper, Collector&lt;? super U, A, R> downstream)
    // U 타입 원소에 대한 Collector에 T 타입 원소를 mapper를 통해 U 타입으로 변환하여 받아들이는 Collector
static &lt;T, U, A, R> Collector&lt;T, ?, R> flatMapping(Function&lt;? super T, ? extends Stream&lt;? extends U>> mapper, Collector&lt;? super U, A, R> downstream) // Since 9
    // Flat mapper는 입력 요소를 0개 이상의 요소를 담은 stream으로 만들어내며, downstream에 투입되면 해당 stream은 닫힌다.(null인 경우 빈 스트림을 대신 이용한다)

static &lt;T, A, R> Collector&lt;T, ?, R> filtering(Predicate&lt;? super T> predicate, Collector&lt;? super T, A, R> downstream) Since 9
    // 동일한 입력 타입 T 원소를 받아 predicate을 만족하면 downstream에 투입하는 Collector

static &lt;T, A, R, RR> Collector&lt;T, A, RR> collectingAndThen(Collector&lt;T, A, R> downstream, Function&lt;R, RR> finisher)

static &lt;T> Collector&lt;T, ?, Long> counting()
static &lt;T> Collector&lt;T, ?, Optional&lt;T>> minBy(Comparator&lt;? super T> comparator)
static &lt;T> Collector&lt;T, ?, Optional&lt;T>> maxBy(Comparator&lt;? super T> comparator)
static &lt;T> Collector&lt;T, ?, Integer> summingInt(ToIntFunction&lt;? super T> mapper) // + Long, Double
static &lt;T> Collector&lt;T, ?, Double> averagingInt(ToIntFunction&lt;? super T> mapper) // + Long, Double
static &lt;T> Collector&lt;T, ?, IntSummaryStatistics> summarizingInt(ToIntFunction&lt;? super T> mapper) // + Long, Double
static &lt;T> Collector&lt;T, ? T> reducing(T identity, BinaryOperator&lt;T> op)
    // reducing 설명은 DoubleStream 참고

static &lt;T, K> Collector&lt;T, ?, Map&lt;K, List&lt;T>>> groupingBy(Function&lt;? super T, ? extends K> classifier)
static &lt;T, K> Collector&lt;T, ?, ConcurrentMap&lt;K, List&lt;T>>> groupingByConcurrent(Function&lt;? super T, ? extends K> classifier)
static &lt;T> Collector&lt;T, ?, Map&lt;Boolean, List&lt;T>>> partitioningBy(Predicate&lt;? super T> predicate)
static &lt;T, K, U> Collector&lt;T, ?, Map&lt;K, U>> toMap(Function&lt;? super T, ? extends K> keyMapper, Function&lt;? super T, ? extends U> valueMapper)
static &lt;T, K, U> Collector&lt;T, ?, Map&lt;K, U>> toUnmodifiableMap(Function&lt;? super T, ? extends K> keyMapper, Function&lt;? super T, ? extends U> valueMapper) // Since 10
static &lt;T, K, U> Collector&lt;T, ?, ConcurrentMap&lt;K, U>> toConcurrentMap(Function&lt;? super T, ? extends K> keyMapper, Function&lt;? super T, ? extends U> valueMapper)

</div></div><h1>java.util.zip</h1><div><h2>Checksum</h2><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">void update(int b)
default void update(byte[] b)
void update(byte[] b, int off, int len)
default void update(ByteBuffer buffer)
long getValue()
void reset()</div><ol><p>구현 클래스</p><li>class Adler32</li><li>class CRC32</li><li>class CRC32C</li></ol><h2>ZipInputStream</h2><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">public ZipInputStream(InputStream in, Charset charset)

ZipEntry getNextEntry()
void closeEntry()
    // 현재 ZipEntry를 닫고 읽기 위치를 다음 entry로 이동
int available()
    // EOF를 만났으면 0, 아니면 1
</div><h2>ZipOutputStream</h2><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">public ZipOutputStream(OutputStream out, Charset charset)

void setComment(String comment)
void setMethod(int method)
    // ZipEntry에 설정되지 않은 경우 사용하는 압축 방법 : DEFLATED(압축, 기본값), STORED(비압축)
void setLevel(int level)
    // 압축 레벨 : 0(BEST_SPEED) ~ 9(BEST_COMPRESSION). 기본은 DEFAULT_COMPRESSION(-1)이며, 보통 6
void putNextEntry(ZipEntry e)
void closeEntry()
    // 현재 ZipEntry를 닫고 다음 쓰기 위치로 이동. putNextEntry 메서드는 쓰기 전에 알아서 닫는다
void finish()
    // 쓰기를 종료하고 스트림을 닫는다. 동일한 출력 스트림에 여러 필터를 적용한 경우에 사용
</div><h2>ZipEntry</h2><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">public ZipEntry(String name)
public ZipEntry(ZipEntry e) // e로 필드를 채운다

String getName()
ZipEntry setLastModifiedTime(FileTime time)
ZipEntry setLastAccessTime(FileTime time)
ZipEntry setCreationTime(FileTime time)
void setSize(long size) // 비압축 크기 설정
void setCompressedSize(long csize)
void setCrc(long crc)
void setMethod(int method)
    // DEFLATED(압축), STORED(비압축), -1(미설정)
void setExtra(byte[] extra)
void setComment(String comment)
boolean isDirectory()
    // 이름이 "/"로 끝나면 디렉터리
Object clone()
</div><h2>ZipFile</h2><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">public ZipFile(File file, int mode)
    // UTF-8
    // mode : OPEN_READ | OPEN_DELETE(파일이 close 호출 전까지 삭제됨, 내용은 객체를 통해 계속 접근 가능)
public ZipFile(File file, int mode, Charset charset)

ZipEntry getEntry(String name)
InputStream getInputStream(ZipEntry entry)
    // ZipFile이 닫히면 이 메서드가 반환한 모든 스트림도 같이 닫힌다
Enumeration&lt;? extends ZipEntry> entries()
Stream&lt;? extends ZipEntry> stream()
int size() // entry 개수

</div></div><h1>javax.crypto</h1>EMPTY<h1>javax.net</h1><div><h2>SocketFactory</h2><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static SocketFactory getDefault()
Socker createSocket(String host, int port)
</div><h2>ServerSocketFactory</h2><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static ServerSocketFactory getDefault()
ServerSocker createServerSocket(int port)

</div></div><h1>javax.net.ssl</h1>EMPTY<ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-7897366614471210" data-ad-slot="6629226643" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({})</script></div><hr>&copy; 2020. <a href="mailto:hi.donggi@gmail.com">Donggi Kim</a> all rights reserved.<a class="w3-btn w3-round-xxlarge w3-small w3-green" href="/LICENSE">LICENSE</a></div></body></html>