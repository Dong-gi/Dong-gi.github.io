<script src="/source/utility.js?200203_1003"></script>
<script src="/source/redirect.js?200203_0949"></script>
<hr>

<details>
    <summary>Collection API</summary>
    <details>
        <summary>컬렉션 자료형 인터페이스</summary>
        <details>
            <summary>interface Collection&lt;E&gt; extends Iterable&lt;E&gt; Since 1.2</summary>
            <ol>
                <li>컬렉션 최소 연산을 정의.</li>
                <li>서브 컬렉션을 작성할 때, 인자없는 생성자와 Collection 인자 하나만 받는 생성자를 각각 작성하도록 권장한다</li>
                <li>정의하지 않아도 되는 선택적 메서드들에 대하여, 구현하지 않는 경우 UnsupportedOperationException을 던져야 한다</li>
                <li>컬렉션이 자기 자신을 요소로 갖는 경우 일부 메서드 실행 중 예외가 발생할 수 있다.</li>
            </ol>
            <details>
                <summary>Method Detail</summary>
                <ol>
                    <li>int size()</li>
                    <li>boolean isEmpty()</li>
                    <li>boolean add(E e)</li>
                    <li>boolean addAll(Collection&lt;? extends E&gt; c)</li>
                    <li>boolean contains(Object o)</li>
                    <li>boolean containsAll(Collection&lt;?&gt; c)</li>
                    <li>boolean retainAll(Collection&lt;?&gt; c)</li>
                    c에 속한 원소만 남기고 모두 제거한다. 이 연산으로 컬렉션이 변경됐다면 true 반환.
                    <button class="btn-code" path="Repositories/Eclipse/JavaSE/src/util/CollectionExample.java" lan="java">예시 코드 »</button>
                    <li>boolean remove(Object o)</li>
                    <li>boolean removeAll(Collection&lt;?&gt; c)</li>
                    <li>default boolean removeIf(Predicate&lt;? super E&gt; filter) Since 1.8</li>
                    <li>void clear()</li>
                    <li>Object[] toArray()</li>
                    <li>&lt;T&gt; T[] toArray(T[] a)</li>
                    사용 : toArray(new Clazz[0])
                    <li>default &lt;T&gt; T[] toArray(IntFunction&lt;T[]&gt; generator) Since 11</li>
                    사용 : toArray(Clazz[]::new)
                    <li>default Stream&lt;E&gt; stream() Since 1.8</li>
                    <li>default Stream&lt;E&gt; parallelStream() Since 1.8</li>
                </ol>
            </details>
        </details>

        <details>
            <summary>interface Queue&lt;E&gt; extends Collection&lt;E&gt; Since 1.5</summary>
            <ol>
                <li>boolean add(E e) : 추가할 수 없으면 예외 발생. 따라서 반환이 있다면 그 값은 항상 true</li>
                <li>boolean offer(E e) : 예외 발생하지 않는 add</li>
                <li>E remove() : 앞쪽 원소 하나 제거. 없으면 예외.</li>
                <li>E poll() : 앞쪽 원소 하나 제거. 없으면 null.</li>
                <li>E element() : 앞쪽 원소 하나 제거하지 않고 가져오기. 없으면 예외.</li>
                <li>E peek() : 앞쪽 원소 하나 제거하지 않고 가져오기. 없으면 null.</li>
            </ol>
        </details>

        <details>
            <summary>interface Deque&lt;E&gt; extends Queue&lt;E&gt; Since 1.6</summary>
            <ol>
                <li>추가 못하면 예외 발생 : void addFirst(E) == push(E), addLast(E)</li>
                <li>추가 못하면 false : boolean offerFirst(E), offerLast(E)</li>
                <li>없으면 예외 발생 : E removeFirst() == pop(), removeLast(), getFirst(), getLast()</li>
                <li>없으면 null : E pollFirst(), pollLast(), peekFirst(), peekLast()</li>

                <li>boolean removeFirstOccurrence(Object o) + removeLastOccurrence</li>
                <li>Iterator&lt;E&gt; descendingIterator() : iterator()의 역순</li>
            </ol>
        </details>

        <details>
            <summary>interface List&lt;E&gt; extends Collection&lt;E&gt; Since 1.2</summary>
            <ol>
                <li>boolean addAll(int index, Collection&lt;? extends E&gt; c)</li>

                <li>default void replaceAll(UnaryOperator&lt;E&gt; operator) Since 1.8</li>
                모든 원소를 연산 결과로 대체

                <li>default void sort(Comparator&lt;? super E&gt; c) Since 1.8</li>

                <li>int hashCode()</li>
                hashCode = 31*hashCode + (e==null ? 0 : e.hashCode());

                <li>E get(int index)</li>
                <li>E set(int index, E element) : 이전 값은 반환.</li>
                <li>void add(int index, E element)</li>
                <li>E remove(int index)</li>
                <li>int indexOf(Object o) + lastIndexOf</li>

                <li>ListIterator&lt;E&gt; listIterator() + 1 오버로딩</li>

                <li>List&lt;E&gt; subList(int fromIndex, int toIndex)</li>

                <li>static &lt;E&gt; List&lt;E&gt; of() Since 9 + 11 오버로딩<br>
                    static &lt;E&gt; List&lt;E&gt; copyOf(Collection&lt;? extends E&gt; coll) Since 10</li>
                null 허용하지 않는 변경 불가능한 리스트. 모든 원소가 serializable하면 리스트도 그러하다.
            </ol>
        </details>

        <details>
            <summary>interface Set&lt;E&gt; extends Collection&lt;E&gt; Since 1.2</summary>
            <ol>
                <li>static &lt;E&gt; Set&lt;E&gt; of() Since 9 + 11 오버로딩<br>
                    static &lt;E&gt; Set&lt;E&gt; copyOf(Collection&lt;? extends E&gt; coll) Since 10</li>
                변경 불가능한 집합을 반환한다. null 원소를 허용하지 않으며, 모든 원소가 serializable하면 집합도 그러하다.
            </ol>
        </details>

        <details>
            <summary>interface SortedSet&lt;E&gt; extends Set&lt;E&gt; Since 1.2</summary>
            <ol>
                <li>원소가 정렬된 Set. 다음 4가지 생성자를 구현할 것을 권장. (void), (Comparator), (Collection), (SortedSet)</li>
                <li>Comparator&lt;? super E&gt; comparator()</li>
                <li>SortedSet&lt;E&gt; subSet(E fromElement, E toElement) + headSet, tailSet</li>
                부분집합 반환. toElement는 미포함
                <li>E first() + last</li>
            </ol>
        </details>

        <details>
            <summary>interface NavigableSet&lt;E&gt; extends SortedSet&lt;E&gt; Since 1.6</summary>
            <ol>
                <li>E lower(E e) + floor: &lt;=e, ceiling: &gt;=e, higher: &gt;e</li>
                e보다 작은 원소들 중 최댓값을 반환. 없으면 null
                <li>E pollFirst() + pollLast</li>
                제거하고 반환

                <li>NavigableSet&lt;E&gt; descendingSet()</li>
                <li>Iterator&lt;E&gt; descendingIterator()</li>
                <li>NavigableSet&lt;E&gt; subSet(E fromElement, boolean fromInclusive, E toElement, bolean toInclusive) + headSet, tailSet</li>
            </ol>
        </details>

        <details>
            <summary>interface Map&lt;K, V&gt; Since 1.2</summary>
            <details>
                <summary>static interface Map.Entry&lt;K, V&gt; Since 1.2</summary>
                <ol>
                    <li>K getKey() + getValue</li>
                    <li>V setValue(V value)</li>

                    <li>static &lt;K extends Comparable&lt;? super K&gt;, V&gt; Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparingByKey() Since 1.8 + 1 오버로딩 + comparingByValue</li>
                    키를 자연스러운 순서로 비교하는 비교자 반환. 인자 있는 함수의 경우 해당 비교자를 이용.
                </ol>
            </details>
            <details>
                <summary>Method Detail</summary>
                <ol>
                    <li>Collection과 유사한 메서드는 생략</li>

                    <li>boolean containsKey(Object key)</li>
                    <li>boolean containsValue(Object value)</li>

                    <li>V get(Object key)</li>
                    <li>default V getOrDefault(Object key, V defaultValue) Since 1.8
                        <button class="btn-code" path="Repositories/Eclipse/JavaSE/src/util/MapExample.java" displayRange="[12,16]" lan="java">예시 코드 »</button></li>
                    <li>V put(K key, V value) : 이전 값은 반환된다.</li>
                    <li>default V putIfAbsent(K key, V value) Since 1.8
                        <button class="btn-code" path="Repositories/Eclipse/JavaSE/src/util/MapExample.java" displayRange="[18,24]" lan="java">예시 코드 »</button></li>
                    <li>void putAll(Map&lt;? extends K, ? extends V&gt; m)</li>
                    <li>default V compute(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) Since 1.8
                        <button class="btn-code" path="Repositories/Eclipse/JavaSE/src/util/MapExample.java" displayRange="[26,32]" lan="java">예시 코드 »</button></li>
                    값을 다시 계산하여 덮어쓴다.
                    <li>default V computeIfAbsent(K key, Function&lt;? super K, ? extends V&gt; mappingFunction) Since 1.8 + computeIfPresent
                        <button class="btn-code" path="Repositories/Eclipse/JavaSE/src/util/MapExample.java" displayRange="[34,56]" lan="java">예시 코드 »</button></li>
                    computeIfAbsent : key가 맵에 없거나, 대응하는 값이 null인 경우 새로운 값을 계산하여 넣는다. 계산된 값이 null이면 null 반환. 그 외의 경우 현재값 반환<br>
                    computeIfPresent : key가 존재하고, 대응하는 값이 null이 아닌 경우 새로운 값을 계산하여 넣는다. 키가 존재하면 현재값 반환. 그 외의 경우 null 반환
                    <li>default V replace(K key, V value) Since 1.8 + 1 오버로딩 + replaceAll
                        <button class="btn-code" path="Repositories/Eclipse/JavaSE/src/util/MapExample.java" displayRange="[58,70]" lan="java">예시 코드 »</button></li>
                    key가 있을 때만 대체. 없으면 null 반환
                    <li>default V merge(K key, V value, BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) Since 1.8
                        <button class="btn-code" path="Repositories/Eclipse/JavaSE/src/util/MapExample.java" displayRange="[72,89]" lan="java">예시 코드 »</button></li>
                    <ul>
                        <li>key가 맵에 없거나, 대응하는 값이 null인 경우 : null이 아닌 value로 연결.</li>
                        <li>주어진 함수를 통해 새로운 값에 연결</li>
                        <li>결과가 null인 경우 맵에서 제거.</li>
                    </ul>

                    <li>default boolean remove(Object key, Object value) Since 1.8</li>

                    <li>Set&lt;K&gt; keySet()</li>
                    <li>Collection&lt;V&gt; values()</li>
                    <li>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()</li>

                    <li>default void forEach(BiConsumer&lt;? super K, ? super V&gt; action) Since 1.8</li>

                    <li>static &lt;K, V&gt; Map&lt;K, V&gt; of() Since 9 + 11 오버로딩<br>
                        @SafeVarargs static &lt;K, V&gt; Map&lt;K, V&gt; ofEntries(Map.Entry&lt;? extends K, ? extends V&gt;... entries) Since 9<br>
                        static &lt;K, V&gt; Map.Entry&lt;K, V&gt; entry(K k, V v) Since 9<br>
                        static &lt;K, V&gt; Map&lt;K, V&gt; copyOf(Map&lt;? extends K, ? extends V&gt; map) Since 10</li>
                    변경 불가능한 객체를 반환한다. 변경 불가능한 맵은 키와 값 모두 null을 허용하지 않으며, 모든 키와 값이 serializable하면 맵도 그러하다.
                </ol>
            </details>
        </details>

        <details>
            <summary>interface SortedMap&lt;K, V&gt; extends Map&lt;K, V&gt; Since 1.2</summary>
            <ol>
                <li>키가 정렬된 Map. 다음 4가지 생성자를 구현할 것을 권장. (void), (Comparator), (Map), (SortedMap)</li>
                <li>Comparator&lt;? super K&gt; comparator()</li>
                <li>SortedMap&lt;K, V&gt; subMap(K fromKey, K toKey) + headMap, tailMap</li>
                지정된 범위의 키만으로 구성된 서브 맵 반환. toKey는 미포함
                <li>K firstKey() + lastKey</li>
            </ol>
        </details>

        <details>
            <summary>interface NavigableMap&lt;K, V&gt; extends SortedMap&lt;K, V&gt; Since 1.6</summary>
            <ol>
                <li>Map.Entry&lt;K, V&gt; lowerEntry(K key) + floorEntry: &lt;=key, ceilingEntry: &gt;=key, higherEntry: &gt;key</li>
                key보다 작은 키들 중 최댓값에 대한 entry 반환. 없으면 null

                <li>K lowerKey(K key) + floorKey: &lt;=key, ceilingKey: &gt;=key, higherKey: &gt;key</li>
                key보다 작은 키들 중 최댓값 반환. 없으면 null

                <li>Map.Entry&lt;K, V&gt; firstEntry() + lastEntry, pollFirstEntry, pollLastEntry</li>
                poll~ : 제거하고 반환

                <li>NavigableSet&lt;K&gt; navigableKeySet() + descendingKeySet</li>
                <li>NavigableMap&lt;K, V&gt; descendingMap()</li>
                <li>NavigableMap&lt;K, V&gt; subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) + headMap, tailMap</li>
            </ol>
        </details>
    </details>

    <details>
        <summary>컬렉션 연산 인터페이스</summary>
        <details>
            <summary>interface Enumeration&lt;E&gt; Since 1.0</summary>
            <ol>
                <li>boolean hasMoreElements()</li>
                <li>E nextElement()</li>
                <li>default Iterator&lt;E&gt; asIterator() Since 9</li>
            </ol>
        </details>

        <details>
            <summary>interface Iterator&lt;E&gt; Since 1.2</summary>
            <ol>
                <li>boolean hasNext()</li>
                <li>E next()</li>
                <li>default void remove() : 마지막으로 반환된 원소를 제거. next() 호출 뒤 한 번만 호출 가능.</li>
                <li>default void forEachRemaining(Consumer&lt;? super E&gt; action) Since 1.8</li>
            </ol>
        </details>

        <details>
            <summary>interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt; Since 1.2</summary>
            <ol>
                <li>양방향으로 이동 가능한 iterator.</li>
                <li>boolean hasPrevious()</li>
                <li>E previous()</li>
                <li>int nextIndex() + previousIndex</li>
                <li>void set(E e) : 마지막으로 반환된 요소를 변경</li>
                <li>void add(E e) : next()로 반환될 요소 바로전에 삽입.</li>
            </ol>
        </details>

        <details>
            <summary>interface PrimitiveIterator&lt;T, T_CONS&gt; extends Iterator&lt;T&gt; Since 1.8</summary>
            <ol>
                <li>기본 타입의 박싱을 회피하기 위한 이터레이터를 제공한다</li>
                <li>OfInt, OfLong, OfDouble이 제공된다</li>
            </ol>
            <details>
                <summary>static interface PrimitiveIterator.OfInt extends PrimitiveIterator&lt;Integer, IntConsumer&gt; Since 1.8</summary>
                <ol>
                    <li>int nextInt()</li>
                    <li>default void forEachRemaining(IntConsumer action)</li>
                </ol>
            </details>
        </details>

        <details>
            <summary>interface Spliterator&lt;T&gt; Since 1.8</summary>
            <ol>
                <li>Iterator와 마찬가지로 순회를 위한 기능을 제공한다. Iterator와 달리 병렬 순회가 가능하며, 순회 메서드가 hasNext(), next()로 이분화되지 않는다.</li>
                <li>병렬 순회하려는 경우, 동일 Spliterator 객체를 이용하지 말고, 다른 스레드는 trySplit()을 통해 얻은 객체로 순회해야 한다.</li>
                <li>박싱을 피하기 위한 Spliterator를 제공한다. OfInt, OfLong, OfDouble.</li>
            </ol>
            <details>
                <summary>Field Summary</summary>
                static int CONCURRENT, DISTINCT, IMMUTABLE, NONNULL, ORDERED, SIZED, SORTED, SUBSIZED
            </details>
            <details>
                <summary>Method Detail</summary>
                <ol>
                    <li>boolean tryAdvance(Consumer&lt;? super T&gt; action)</li>
                    남은 원소가 존재하면 하나를 소비하고 true 반환. 그 외엔 false

                    <li>default void forEachRemaining(Consumer&lt;? super T&gt; action)</li>

                    <li>Spliterator&lt;T&gt; trySplit()</li>
                    이 spliterator를 분리할 수 있다면, 일부분을 분리하여 반환하고, 이 spliterator는 나머지 원소들을 순회한다. 그 외엔 null

                    <li>long estimateSize()</li>
                    forEachRemaining() 메서드에서 순회할 원소의 수를 예측하여 반환한다. 무한하거나, 알 수 없거나, 계산하는 연산이 비싼 경우 Long.MAX_VALUE를 반환하면 된다.

                    <li>default long getExactSizeIfKnown()</li>
                    이 spliterator가 SIZED인 경우 estimateSize()를 반환한다. 그 외엔 -1

                    <li>int characteristics() + hasCharacteristics</li>
                    이 spliterator의 특징 상수들을 OR로 반환하면 된다.

                    <li>default Comparator&lt;? super T&gt; getComparator()</li>
                    이 spliterator의 소스가 Comparator를 이용해 정렬된(SORTED) 경우, 해당 Comparator를 반환한다. 그 외엔 null, 또는 IllegalStateException
                </ol>
            </details>
            <details>
                <summary>static interface Spliterator.OfInt extends Spliterator.OfPrimitive&lt;Integer, IntConsumer, Spliterator.OfInt&gt; Since 1.8</summary>
                <ol>
                    <li>default boolean tryAdvance(Consumer&lt;? super Integer&gt; action) + forEachRemaining</li>
                    action이 IntConsumer 인스턴스면 형변환되어 사용된다.
                </ol>
            </details>
        </details>

        <details>
            <summary>interface RandomAccess Since 1.4</summary>
            빠른(보통 상수 시간) 임의 접근이 가능한 List를 나타내는 마커 인터페이스
        </details>
    </details>

    <details>
        <summary>컬렉션 자료형 콘크리트 클래스</summary>
        <details>
            <summary>static class AbstractMap.SimpleEntry&lt;K, V&gt; implements Map.Entry&lt;K, V&gt;, Serializable Since 1.6</summary>
            public SimpleEntry(K key, V value) + 오버로딩
        </details>
        <details>
            <summary>static class AbstractMap.SimpleImmutableEntry&lt;K, V&gt; implements Map.Entry&lt;K, V&gt;, Serializable Since 1.6</summary>
            public SimpleImmutableEntry(K key, V value) + 오버로딩
        </details>
        <details>
            <summary>class ArrayDeque&lt;E&gt; extends AbstractCollection&lt;E&gt; implements Deque&lt;E&gt;, Cloneable, Serializable Since 1.6</summary>
            <ol>
                <li>가변 길이 배열로 구현한 Deque. 스레드-안전하지 않음.</li>
                <li>public ArrayDeque() + (int numElements), (Collection&lt;? extends E&gt; c)</li>
            </ol>
        </details>
        <details>
            <summary>class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, Serializable Since 1.2</summary>
            <ol>
                <li>가변 길이 배열로 구현한 List. 스레드-안전하지 않음.</li>
                <li>public ArrayList() + (int initialCapacity), (Collection&lt;? extends E&gt; c)</li>
                <li>void trimToSize() + ensureCapacity</li>
                이 ArrayList의 capacity를 size에 맞춘다
            </ol>
        </details>
        <details>
            <summary>class Vector&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, Serializable Since 1.0</summary>
            <ol>
                <li>public Vector() + (int initialCapacity), (int initialCapacity, int capacityIncrement), (Collection&lt;? extends E&gt; c) Since 1.2</li>
                ArrayList와 달리 스레드-안전하다.
                <li>void copyInto(Object[] anArray)</li>
                <li>void trimToSize()</li>
                <li>void setSize(int newSize)</li>
                <li>int capacity()</li>
                <li>void ensureCapacity(int minCapacity)</li>
                <li>Enumeration&lt;E&gt; elements()</li>
                <li>int indexOf(Object o, int index) + lastIndexOf</li>
                <li>E firstElement() + lastElement</li>
            </ol>
        </details>
        <details>
            <summary>class BitSet implements Cloneable, Serializable Since 1.0</summary>
            <ol>
                <li>public BitSet() + (int nbits)</li>
                각 비트의 기본값은 false. 스레드-안전하지 않음.

                <li>static BitSet valueOf(long[] longs) Since 1.7 + LongBuffer, byte[], ByteBuffer</li>
                <li>byte[] toByteArray() Since 1.7 + toLongArray</li>

                <li>boolean get(int bitIndex)</li>
                <li>BitSet get(int fromIndex, int toIndex) Since 1.4</li>
                <li>void set(int fromIndex, int toIndex, boolean value) Since 1.4 + 3 오버로딩</li>
                <li>void clear(int fromIndex, int toIndex) Since 1.4 + 2 오버로딩 == set(~, false)</li>
                <li>void flip(int fromIndex, int toIndex) Since 1.4 + 1 오버로딩</li>

                <li>int nextSetBit(int fromIndex) Since 1.4 + nextClearBit, previousSetBit, previousClearBit</li>

                <li>void and(BitSet set) + or, xor</li>
                <li>void andNot(BitSet set) Since 1.2 : set에 true로 설정된 모든 index에 대해 false 설정</li>
                <li>boolean intersects(BitSet set) Since 1.4 : 하나라도 true로 일치하는 경우</li>

                <li>boolean imEmpty() Since 1.4</li>
                <li>int size() : 총 비트 수</li>
                <li>int cardinality() Since 1.4 : true 비트 수</li>
                <li>int length() Since 1.7 : the index of the highest set bit</li>

                <li>IntStream stream() Since 1.8</li>
            </ol>
        </details>
        <details>
            <summary>class EnumMap&lt;K extends Enum&lt;K&gt;, V&gt; extends AbstractMap&lt;K, V&gt; implements Serializable, Cloneable Since 1.5</summary>
            <ol>
                <li>public EnumMap(Class&lt;K&gt; keyType) + (EnumMap&lt;K, ? extends V&gt; m), (Map&lt;K, ? extends V&gt; m)</li>
                Enum을 키로 이용.
            </ol>
        </details>
        <details>
            <summary>abstract class EnumSet&lt;E extends Enum&lt;E&gt;&gt; extends AbstractSet&lt;E&gt; implements Cloneable, Serializable Since 1.5</summary>
            <ol>
                <li>static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; noneOf(Class&lt;E&gt; elementType) : 공집합 반환</li>
                <li>static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; allOf(Class&lt;E&gt; elementType) : 전체 집합 반환</li>
                <li>static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; copyOf(Collection&lt;E&gt; c) + 1 오버로딩</li>
                <li>static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; complementOf(EnumSet&lt;E&gt; s) : 여집합 반환</li>
                <li>static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; of(E e) + 5 오버로딩</li>
                <li>static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; range(E from, E to)</li>
            </ol>
        </details>
        <details>
            <summary>class HashMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; implements Map&lt;K, V&gt;, Cloneable, Serializable Since 1.2</summary>
            <ol>
                <li>public HashMap() + (int initialCapacity), (int initialCapacity, float loadFactor), (Map&lt;? extends K, ? extends V&gt; m)</li>
                스레드-안전하지 않음.
            </ol>
        </details>
        <details>
            <summary>class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, Serializable Since 1.2</summary>
            <ol>
                <li>public HashSet() + (int initialCapacity), (int initialCapacity, float loadFactor), (Collection&lt;? extends E&gt; c)</li>
                스레드-안전하지 않음.
            </ol>
        </details>
        <details>
            <summary>class IdentityHashMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; implements Map&lt;K, V&gt;, Serializable, Cloneable Since 1.4</summary>
            <ol>
                <li>public IdentityHashMap() + (int expectedMaxSize), (Map&lt;? extends K, ? extends V&gt; m)</li>
                스레드-안전하지 않다. 일반적으로 (k1==null ? k2==null : k1.equals(k2))로 키를 비교하는 것과 달리 (k1==k2)로 비교한다.<br>
                keySet()으로 반환되는 Set&lt;K&gt;, values()로 반환되는 Collection&lt;V&gt;, entrySet()으로 반환되는 Set&lt;Map.Entry&lt;K, V&gt;&gt; 모두 원소의 비교를 == 연산으로 한다.
            </ol>
        </details>
        <details>
            <summary>class LinkedList&lt;E&gt; entends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, Serializable Since 1.2</summary>
            <ol>
                <li>public LinkedList() + (Collection&lt;? extends E&gt; c)</li>
                List와 Deque을 모두 구현. 스레드-안전하지 않음.
            </ol>
        </details>
        <details>
            <summary>class LinkedHashMap&lt;K, V&gt; extends HashMap&lt;K, V&gt; implements Map&lt;K, V&gt; Since 1.4</summary>
            <ol>
                <li>public LinkedHashMap() + (int initialCapacity), (int initialCapacity, float loadFactor), (Map&lt;? extends K, ? extends V&gt; m)</li>
                키가 삽입된 순서대로 원소를 유지하는 이중 연결 리스트를 가진다. 키가 존재하는 상황에서 put() 호출로 순서가 변경되지 않는다. 스레드-안전하지 않다.

                <li>public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder)</li>
                accessOrder == true ? 접근 빈도로 정렬 : 삽입 순서로 정렬
            </ol>
        </details>
        <details>
            <summary>class LinkedHashSet extends HashSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, Serializable Since 1.4</summary>
            <ol>
                <li>pulbic LinkedHashSet() + (int initialCapacity), (int initialCapacity, float loadFactor), (Collection&lt;? extends E&gt; c)</li>
                삽입된 순서대로 원소를 유지하는 이중 연결 리스트를 가진다. 원소가 존재하는 상황에서 add() 호출로 순서가 변경되지 않는다. 스레드-안전하지 않다.
            </ol>
        </details>
        <details>
            <summary>class PriorityQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements Serializable Since 1.5</summary>
            <ol>
                <li>public PriorityQueue() + (int initialCapacity), (Comparator&lt;? super E&gt; comparator) Since 1.8, (int initialCapacity, Comparator&lt;? super E&gt; comparator), (Collection&lt;? extends E&gt; c), (PriorityQueue&lt;? extends E&gt; c) : c와 정렬 방향 같음, (SortedSet&lt;? extends E&gt; c) : c와 정렬 방향 같음</li>
                우선순위 힙에 기반한 unbounded 우선순위 큐. head가 가장 우선순위가 작은 원소.

                <li>Comparator&lt;? super E&gt; comparator()</li>
            </ol>
        </details>
        <details>
            <summary>class Stack&lt;E&gt; extends Vector&lt;E&gt; Since 1.0</summary>
            <ol>
                <li>public Stack()</li>
                LIFO 스택.
                <li>E push(E item) + pop, peek</li>
                <li>boolean empty() : 비었는지 여부</li>
                <li>int search(Object o) : top으로부터 거리 반환</li>
            </ol>
        </details>
        <details>
            <summary>class TreeMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; implements NavigableMap&lt;K, V&gt;, Cloneable, Serializable Since 1.2</summary>
            <ol>
                <li>public TreeMap() + (Comparator&lt;? super K&gt; comparator), (Map&lt;? extends K, ? extends V&gt; m), (SortedMap&lt;K, ? extends V&gt; m)</li>
                Red-Black tree(이진 탐색 트리의 일종) 기반의 NavigableMap 구현. log(n) 시간의 작업을 보장한다. 스레드-안전하지 않다.
            </ol>
        </details>
        <details>
            <summary>class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements NavigableSet&lt;E&gt;, Cloneable, Serializable Since 1.2</summary>
            <ol>
                <li>public TreeSet() + (Comparator&lt;? super E&gt; comparator), (Collection&lt;? extends E&gt; c), (SortedSet&lt;E&gt; s)</li>
                TreeMap 기반의 NavigableSet 구현. 스레드-안전하지 않다.
            </ol>
        </details>
        <details>
            <summary>class WeakHashMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; implements Map&lt;K, V&gt; Since 1.2</summary>
            <ol>
                <li>public WeakHashMap() + (int initialCapacity), (int initialCapacity, float loadFactor), (Map&lt;? extends K, ? extends V&gt; m) Since 1.3</li>
                key의 존재 여부는 key가 GC 대상이 되는 것에 영향이 없다. key 객체가 유효하지 않게 되면 자동으로 맵에서 삭제한다. key, value 모두에 null을 허용한다. 단, value가 key의 참조를 가지지 않도록 유의해야 한다. 스레드-안전하지 않다.
            </ol>
        </details>
    </details>

    <details>
        <summary>유틸리티 클래스</summary>
        <details>
            <summary>class Collections Since 1.2</summary>
            <details>
                <summary>필드</summary>
                <ul>
                    <li>public static final Set EMPTY_SET : 변경 불가</li>
                    <li>public static final List EMPTY_LIST : 변경 불가</li>
                    <li>public static final Map EMPTY_MAP Since 1.3 : 변경 불가</li>
                </ul>
            </details>

            <details>
                <summary>리스트 연산</summary>
                <ul>
                    <li>static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list) + 1 오버로딩</li>
                    T 자체가 Comparable하거나, T에 대한 Comparator를 넘기거나
                    <li>static &lt;T&gt; int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key) + 1 오버로딩</li>
                    <li>static void reverse(List&lt;?&gt; list) + shuffle, swap Since 1.4, fill, rotate Since 1.4</li>
                    <li>static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src)</li>
                    <li>static &lt;T&gt; boolean replaceAll(List&lt;T&gt; list, T oldVal, T newVal) Since 1.4</li>
                    <li>static int indexOfSubList(List&lt;?&gt; source, List&lt;?&gt; target) Since 1.4 + lastIndexOfSubList</li>
                    <li>static &lt;T&gt; ArrayList&lt;T&gt; list(Enumeration&lt;T&gt; e) Since 1.4</li>
                </ul>
            </details>

            <details>
                <summary>Collection 연산</summary>
                <ul>
                    <li>static &lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt; T min(Collection&lt;? extends T&gt; coll) + 1 오버로딩, max</li>
                    <li>static int frequency(Collection&lt;?&gt; c, Object o) Since 1.5</li>
                    <li>static boolean disjoint(Collection&lt;?&gt; c1, Collection&lt;?&gt; c2) Since 1.5 : 공통 원소가 없는지 여부.</li>
                    <li>static &lt;T&gt; boolean addAll(Collection&lt;? super T&gt; c, T... elements) Since 1.5</li>
                </ul>
            </details>

            <details>
                <summary>변경 불가능한 Collection Factory</summary>
                <ul>
                    <li>static &lt;T&gt; Collection&lt;T&gt; unmodifiableCollection(Collection&lt;? extends T&gt; c)</li>
                    <li>static &lt;T&gt; Set&lt;T&gt; unmodifiableSet(Set&lt;? extends T&gt; s)</li>
                    <li>static &lt;T&gt; SortedSet&lt;T&gt; unmodifiableSortedSet(SortedSet&lt;T&gt; s)</li>
                    <li>static &lt;T&gt; NavigableSet&lt;T&gt; unmodifiableNavigableSet(NavigableSet&lt;T&gt; s) Since 1.8</li>
                    <li>static &lt;T&gt; List&lt;T&gt; unmodifiableList(List&lt;? extends T&gt; list)</li>
                    <li>static &lt;K, V&gt; Map&lt;K, V&gt; unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m)</li>
                    <li>static &lt;K, V&gt; SortedMap&lt;K, V&gt; unmodifiableSortedMap(SortedMap&lt;K, ? extends V&gt; m)</li>
                    <li>static &lt;K, V&gt; NavigableMap&lt;K, V&gt; unmodifiableNavigableMap(NavigableMap&lt;K, ? extends V&gt; m) Since 1.8</li>
                </ul>
            </details>

            <details>
                <summary>Synchronization</summary>
                <ul>
                    <li>비결정 상태에 빠지는 것을 방지하기 위해, 반환된 컬렉션에 대해 synchronized 제약을 걸고 이용하는 것이 좋다.</li>
                    <li>static &lt;T&gt; Collection&lt;T&gt; synchronizedCollection(Collection&lt;T&gt; c)</li>
                    <li>static &lt;T&gt; Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s)</li>
                    <li>static &lt;T&gt; SortedSet&lt;T&gt; sychronizedSortedSet(SortedSet&lt;T&gt; s)</li>
                    <li>static &lt;T&gt; NavigableSet&lt;T&gt; synchronizedNavigableSet(NavigableSet&lt;T&bt; s) Since 1.8</li>
                    <li>static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list)</li>
                    <li>static &lt;K, V&gt; Map&lt;K, V&gt; synchronizedMap(Map&lt;K, V&gt; m)</li>
                    <li>static &lt;K, V&gt; SortedMap&lt;K, V&gt; synchronizedSortedMap(SortedMap&lt;K, V&gt; m)</li>
                    <li>static &lt;K, V&gt; NavigableMap&lt;K, V&gt; synchronizedNavigableMap(NavigableMap&lt;K, V&gt; m) Since 1.8</li>
                </ul>
            </details>

            <details>
                <summary>타입 체킹 추가</summary>
                <ul>
                    <li>static &lt;E&gt; Collection&lt;E&gt; checkedCollection(Collection&lt;E&gt; c, Class&lt;E&gt; type) Since 1.5</li>
                    <li>static &lt;E&gt; Queue&lt;E&gt; checkedQueue(Queue&lt;E&gt;, Class&lt;E&gt; type) Since 1.8</li>
                    <li>static &lt;E&gt; Set&lt;E&gt; checkedSet(Set&lt;E&gt; s, Class&lt;E&gt; type) Since 1.5</li>
                    <li>static &lt;E&gt; SortedSet&lt;E&gt; checkedSortedSet(SortedSet&lt;E&gt; s, Class&lt;E&gt; type) Since 1.5</li>
                    <li>static &lt;E&gt; NavigableSet&lt;E&gt; checkedNavigableSet(NavigableSet&lt;E&gt; s, Class&lt;E&gt; type) Since 1.8</li>
                    <li>static &lt;E&lt; List&lt;E&gt; checkedList(List&lt;E&gt; list, Class&lt;E&gt; type) Since 1.5</li>
                    <li>static &lt;K, V&gt; Map&lt;K, V&gt; checkedMap(Map&lt;K, V&gt; m, Class&lt;K&gt; keyType, Class&lt;V&gt; valueType) Since 1.5</li>
                    <li>static &lt;K, V&gt; sortedMap&lt;K, V&gt; checkedSortedMap(SortedMap&lt;K, V&gt; m, Class&lt;K&gt; keyType, Class&lt;V&gt; valueType) Since 1.5</li>
                    <li>static &lt;K, V&gt; NavigableMap&lt;K, V&gt; checkedNavigableMap(NavigableMap&lt;K, V&gt; m, Class&lt;K&gt; keyType, Class&lt;V&gt; valueType) Since 1.8</li>
                </ul>
            </details>

            <details>
                <summary>Empty Collection(변경 불가)</summary>
                <ul>
                    <li>static &lt;T&gt; Iterator&lt;T&gt; emptyIterator() Since 1.7</li>
                    <li>static &lt;T&gt; ListIterator&lt;T&gt; emptyListIterator() Since 1.7</li>
                    <li>static &lt;T&gt; Enumeration&lt;T&gt; emptyEnumeration() Since 1.7</li>
                    <li>static final &lt;T&gt; Set&lt;T&gt; emptySet() Since 1.5</li>
                    <li>static &lt;E&gt; SortedSet&lt;E&gt; emptySortedSet() Since 1.8</li>
                    <li>static &lt;E&gt; NavigableSet&lt;E&gt; emptyNavigableSet() Since 1.8</li>
                    <li>static final &lt;T&gt; List&lt;T&gt; emptyList() Since 1.5</li>
                    <li>static final &lt;K, V&gt; Map&lt;K, V&gt; emptyMap() Since 1.5</li>
                    <li>static final &lt;K, V&gt; SortedMap&lt;K, V&gt; emptySortedMap() Since 1.8</li>
                    <li>static final &lt;K, V&gt; NavigableMap&lt;K, V&gt; emptyNavigableMap() Since 1.8</li>
                </ul>
            </details>

            <details>
                <summary>Singleton Collection(변경 불가)</summary>
                <ul>
                    <li>static &lt;T&gt; Set&lt;T&gt; singleton(T o)</li>
                    <li>static &lt;T&gt; List&lt;T&gt; singletonList(T o) Since 1.3</li>
                    <li>static &lt;K, V&gt; Map&lt;K, V&gt; singletonMap(K key, V value) Since 1.3</li>
                    <li>static &lt;T&gt; List&lt;T&gt; nCopies(int n, T o)</li>
                </ul>
            </details>

            <details>
                <summary>기타</summary>
                <ul>
                    <li>static &lt;T&gt; Comparator&lt;T&gt; reverseOrder()</li>
                    자연스러운 비교자의 역 반환.
                    <li>static &lt;T&gt; Comparator&lt;T&gt; reverseOrder(Comparator&lt;T&gt; cmp) Since 1.5</li>
                    <li>static &lt;T&gt; Enumeration&lt;T&gt; enumeration(Collection&lt;T&gt; c)</li>
                    <li>static &lt;E&gt; Set&lt;E&gt; newSetFromMap(Map&lt;E, Boolean&lt; map) Since 1.6</li>
                    map은 반드시 비어있어야 하며, 호출 뒤 map을 직접 접근하지 말아야 한다.
                    <li>static &lt;T&gt; Queue&lt;T&gt; asLifoQueue(Deque&lt;T&gt; deque) Since 1.6</li>
                    deque에 대한 LIFO view를 Queue로 반환한다.
                </ul>
            </details>
        </details>
        <details>
            <summary>final class Spliterators Since 1.8</summary>
            <details>
                <summary>abstract static class Spliterators.AbstractSpliterator&lt;T&gt; implements Spliterator&lt;T&gt; Since 1.8</summary>
                <ol>
                    <li>estimateSize(), characteristics(), trySplit()을 구현한 추상 클래스</li>
                    <li>+ AbstractIntSpliterator, AbstractDoubleSpliterator, AbstractLongSpliterator</li>
                </ol>
            </details>
            <details>
                <summary>Method Detail</summary>
                <ol>
                    <li>static &lt;T&gt; Spliterator&lt;T&gt; emptySpliterator()</li>
                    + emptyIntSpliterator, emptyLongSpliterator, emptyDoubleSpliterator

                    <li>static &lt;T&gt; Spliterator&lt;T&gt; spliterator(Object[] array, int additionalCharacteristics) + 12 오버로딩</li>
                    Arrays.spliterator()가 제공하는 것에 특성을 추가하고 싶을 때 사용. 전형적으로 IMMUTABLE, ORDERED

                    <li>static &lt;T&gt; Spliterator&lt;T&gt; spliteratorUnknownSize(Iterator&lt;? extends T&gt; iterator, int characteristics) + 3 오버로딩</li>
                    Spliterator로 래핑한 후에 iterator를 사용하면 안 된다.

                    <li>static &lt;T&gt; Iterator&lt;T&gt; iterator(Spliterator&lt;? extends T&gt; spliterator) + 3 오버로딩</li>
                    Iterator로 래핑한 후에 spliterator를 사용하면 안 된다.
                </ol>
            </details>
        </details>
    </details>
</details>

<hr>

<details>
    <summary>객체, 배열 관련</summary>
    <details>
        <summary>@FunctionalInterface interface Comparator&lt;T&gt; Since 1.2</summary>
        <ol>
            <li>int compare(T o1, T o2)</li>

            <li>default Comparator&lt;T&gt; reversed() Since 1.8</li>

            <li>default Comparator&lt;T&gt; thenComparing(Comparator&lt;? super T&gt; other) Since 1.8 + 2 오버로딩 + thenComparingInt, Long, Double</li>
            이 비교자가 두 객체를 같다고 판단하면, other가 새로 판단한다.

            <li>static &lt;T extends Comparable&lt;? super T&gt;&gt; Comparator&lt;T&gt; naturalOrder() Since 1.8 + reverseOrder</li>
            자연스러운 비교자를 반환한다.

            <li>static &lt;T&gt; Comparator&lt;T&gt; nullsFirst(Comparator&lt;? super T&gt; comparator) Since 1.8 + nullsLast</li>
            null은 모든 non-null 값보다 작다고 간주한다. null끼리는 서로 같다고 간주한다.

            <li>static &lt;T, U&gt; Comparator&lt;T&gt; comparing(Function&lt;? super T, ? extends U&gt; keyExtractor, Comparator&lt;? super U&gt; keyComparator) Since 1.8 + 1 오버로딩 + comparingInt, Long, Double</li>
            정렬에 이용할 키를 생성하는 함수와, 키를 이용해 비교하는 비교자를 넘기면 둘을 포함하는 T타입 비교자를 반환.
        </ol>
    </details>
    <details>
        <summary>class Arrays Since 1.2</summary>
        <details>
            <summary>정렬, 검색</summary>
            <ol>
                <li>static void sort(int[] a) + 17 오버로딩</li>
                <li>static void parallelSort(byte[] a) Since 1.8 + 17 오버로딩</li>
                병합 정렬을 병렬로 수행한다. 모든 병렬 작업은 ForkJoin common pool을 이용해 이루어진다.

                <li>static int binarySearch(long[] a, long key) + 17 오버로딩</li>
            </ol>
        </details>
        <details>
            <summary>변경, 변환</summary>
            <ol>
                <li>static void fill(long[] a, long val) + 17 오버로딩</li>

                <li>static &lt;T&gt; void setAll(T[] array, IntFunction&lt;? extends T&gt; generator) Since 1.8 + 3 오버로딩</li>
                <li>static &lt;T&gt; void parallelSetAll(T[] array, IntFunction&lt;? extends T&gt; generator) SInce 1.8 + 3 오버로딩</li>

                <li>static &lt;T&gt; void parallelPrefix(T[] array, BinaryOperator&lt;T&gt; op) Since 1.8 + 7 오버로딩</li>
                전체 원소에 순차적으로 연산 적용하여 값 변경. 큰 배열은 루프보다 이게 더 빠르다.

                <li>static String toString(long[] a) Since 1.5 + 8 오버로딩</li>
                <li>static String deepToString(Object[] a) Since 1.5</li>
                toString(Object[])이 o.toString()을 이용하는 반면, 여기서는 String.valueOf(Object)가 이용되고, 원소가 배열인 경우 "[]"를 추가하고 해당 배열의 원소들에 대해 같은 작업을 한다.

                <li>static &lt;T&gt; List&lt;T&gt; asList(T... a)</li>

                <li>static &lt;T&gt; Spliterator&lt;T&gt; spliterator(T[] array) Since 1.8 + 7 오버로딩</li>
                characteristics()에서 SIZED | SUBSIZED | ORDERED | IMMUTABLE를 반환하는 Spliterator 인스턴스를 반환한다.

                <li>static &lt;T&gt; Stream&lt;T&gt; stream(T[] array) Since 1.8 + 7 오버로딩</li>
            </ol>
        </details>
        <details>
            <summary>복사</summary>
            <ol>
                <li>static &lt;T, U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) Since 1.6</li>
                <li>static &lt;T&gt; T[] copyOf(T[] original, int newLength) Since 1.6 + 8 오버로딩</li>
                <li>static &lt;T, U&gt; T[] copyOfRange(U[] original, int from, int to, Class&lt;? extends T[]&gt; newType) Since 1.6 </li>
                <li>static &lt;T&gt; T[] copyOfRange(T[] original, int from, int to) Since 1.6 + 8 오버로딩</li>
            </ol>
        </details>
        <details>
            <summary>비교</summary>
            <ol>
                <li>static int compare(boolean[] a, boolean[] b) Since 9 + 19 오버로딩</li>
                <li>static int compareUnsigned(byte[] a, byte[] b) Since 9 + 7 오버로딩</li>

                <li>static int mismatch(boolean[] a, boolean[] b) Since 9 + 19 오버로딩</li>
                처음으로 일치하지 않는 인덱스 반환.

                <li>static boolean equals(long[] a, long[] a2) + 9 오버로딩</li>
                <li>static boolean equals(long[] a, int aFromIndex, int aToIndex, long[] b, int bFromIndex, int bToIndex) Since 9 + 9 오버로딩</li>
                Object의 경우, Objects.equals(e1, e2)일 때 같다고 간주한다.

                <li>static boolean deepEquals(Object[] a1, Object[] a2) Since 1.5</li>
                null일 수 있는 각 배열의 두 원소 e1, e2에 대하여, 다음 4가지 경우에 대해 둘이 같다고 판단한다.
                <ol>
                    <li>e1 == e2</li>
                    <li>둘 모두 참조변수에 대한 배열이고, Arrays.deepEquals(e1, e2)가 true</li>
                    <li>둘 모두 원시타입에 대한 배열이고, Arrays.equals(e1, e2)가 true</li>
                    <li>e1.equals(e2)가 true</li>
                </ol>
            </ol>
        </details>
        <details>
            <summary>해싱</summary>
            <ol>
                <li>static int hashCode(long[] a) Since 1.5 + 8 오버로딩</li>
                동일 원소를 가진 List의 해시코드와 동일. null이면 0 반환
                <li>static int deepHashCode(Object[] a) Since 1.5</li>
                원소가 배열인 경우, 해당 원소의 해시를 deepHashCode로 구한다. 자기 자신을 포함하는 배열 등은 적합하지 않다.
            </ol>
        </details>
    </details>
    <details>
        <summary>final class Objects Since 1.7</summary>
        <details>
            <summary>비교</summary>
            <ul>
                <li>static boolean equals(Object a, Object b)</li>
                <li>static boolean deepEquals(Object a, Object b)</li>
                둘 다 null이면 true. 둘 다 배열이면 Arrays.deepEquals(), 나머진 a.equals(b)
                <li>static &lt;T&gt; int compare(T a, T b, Comparator&lt;? super T&gt; c)</li>
            </ul>
        </details>
        <details>
            <summary>hashCode</summary>
            <ul>
                <li>static int hashCode(Object o)</li>
                <li>static int hash(Object... values)</li>
                values가 하나의 배열에 든 것처럼 Arrays.hashCode(Object[])를 이용한다. Object.hashCode()의 간편한 구현으로 이용할 수 있다.<br>
                <strong>주의. hashCode(o) != hash(o)</strong>
            </ul>
        </details>
        <details>
            <summary>toString</summary>
            <ul>
                <li>static String toString(Object o)</li>
                <li>static String toString(Object o, String nullDefault)</li>
            </ul>
        </details>
        <details>
            <summary>null</summary>
            <ul>
                <li>static boolean isNull(Object obj) Since 1.8 + nonNull</li>
                Predicate, filter(Objects::isNull)에 이용
                <li>static &lt;T&gt; T requireNonNull(T obj) + 2 오버로딩</li>
                메서드나 생성자에서 null검사를 하도록 설계되었다.
                <li>static &lt;T&gt; T requireNonNullElse(T obj, T defaultObj) Since 9</li>
                <li>static &lt;T&gt; T requireNonNullElseGet(T obj, Supplier&lt;? extends T&gt; supplier) Since 9</li>
            </ul>
        </details>
        <details>
            <summary>index</summary>
            <ul>
                <li>static int checkIndex(int index, int length) Since 9</li>
                index가 [0, length)에 존재하면 그대로 반환. 아니면 예외 발생.
                <li>static int checkFromToIndex(int fromIndex, int toIndex, int length) Since 9</li>
                subrange [fromIndex, toIndex)가 [0, length)에 포함되면 fromIndex 반환. 아니면 예외 발생.
                <li>static int checkFromIndexSize(int fromIndex, int size, int length) Since 9</li>
                subrange [fromIndex, fromIndex + size)가 [0, length)에 포함되면 fromIndex 반환. 아니면 예외 발생.
            </ul>
        </details>
    </details>
    <details>
        <summary>final class Optional&lt;T&gt; Since 1.8 + OptionalInt, OptionalDouble, OptionalLong</summary>
        <ol>
            <li>static &lt;T&gt; Optional&lt;T&gt; empty()<br>
                static &lt;T&gt; Optional&lt;T&gt; of(T value)<br>
                static &lt;T&gt; Optional&lt;T&gt; ofNullable(T value) : null이면 empty(), 아니면 of(value)</li>
                null을 허용하지 않는 객체에 대한 컨테이너. value-based므로 identity-sensitive한 연산은 피해야 한다.

            <li>T get()</li>
            <li>boolean isPresent() + isEmpty Since 11</li>

            <li>void ifPresent(Consumer&lt;? super T&gt; action)</li>
            <li>void ifPresentOrElse(Consumer&lt;? super T&gt; action, Runnable emptyAction) Since 9</li>

            <li>Optional&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate) : 값이 존재하고 필터를 통과하면 그대로 반환. 아니면 빈 컨테이너 반환</li>
            <li>&lt;U&gt; Optional&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; mapper)</li>
            <li>&lt;U&gt; Optional&lt;U&gt; flatMap(Function&lt;? super T, ? extends Optional&lt;? extends U&gt;&gt; mapper)</li>
            mapper가 반환하는 값 자체가 Optional이므로 map()과 달리 추가적인 Optional로 감싸지 않는다.

            <li>Optional&lt;T&gt; or(Supplier&lt;? extends Optional&lt;? extends T&gt;&gt; supplier) Since 9</li>
            값이 존재하면 그대로 반환. 없으면 제공되는 값 반환.
            <li>T orElse(T other)</li>
            <li>T orElseGet(Supplier&lt;? extends T&gt; supplier)</li>
            <li>T orELseThrow() Since 10 : 값이 없으면 NoSuchElementException + 1 오버로딩</li>

            <li>Stream&lt;T&gt; stream() Since 9</li>
            값이 존재하면 해당 값 하나만 포함하는 스트림 반환. 없으면 빈 스트림 반환.
        </ol>
    </details>
</details>

<hr>

<details>
    <summary>시간 관련</summary>
    <details>
        <summary>class Date implements Serializable, Cloneable, Comparable&lt;Date&gt; Since 1.0</summary>
        <ol>
            <li>public Date() + (long date)</li>
            <li>long getTime() + setTime</li>
            <li>boolean before(Date when) + after</li>
            <li>static Date from(Instant instant) Since 1.8 + toInstant</li>
        </ol>
    </details>
    <details>
        <summary>abstract class Calendar implements Serializable, Cloneable, Comparable&lt;Calendar&gt; Since 1.1</summary>
        <ol>
            <li>관대함 Leniency : 범위를 벗어나는 값도 받아들이며, 나중에 정규화한다. 예를 들어 1월 32일은 2월 1일이 된다.</li>
            <li>add와 roll : add는 오버플로되면 다음 단위가 변하지만, roll은 modulo연산처럼 해당 단위만 변한다.</li>
        </ol>
        <details>
            <summary>static class Calendar.Builder Since 1.8</summary>
            <ul>
                <li>public Builder()</li>
            </ul>
            <ol>
                <li>Calendar.Builder setInstant(long instant) : 밀리초 + 1 오버로딩</li>
                <li>Calendar.Builder set(int field, int value)</li>
                <li>Calendar.Builder setFields(int... fieldValuePairs)</li>
                예: setFields(Calendar.YEAR, 2013, Calendar.MONTH, Calendar.DECEMBER, Calendar.DAY_OF_MONTH, 23)
                <li>Calendar.Builder setDate(int year, int month, int dayOfMonth)</li>
                <li>Calendar.Builder setWeekDate(int weekYear, int weekOfYear, int dayOfWeek)</li>
                <li>Calendar.Builder setTimeOfDay(int hourOfDay, int minute, int second) + 1 오버로딩</li>
                <li>Calendar.Builder setTimeZone(TimeZone zone)</li>
                <li>Calendar.Builder setCalendarType(String type) : Calendar.getAvailableCalendarTypes()</li>
                <li>Calendar.Builder setLocale(Locale locale)</li>
                <li>Calendar.Builder setWeekDefinition(int fistDayOfWeek, int minimalDaysInFirstWeek)</li>
                <li>Calendar.Builder setLenient(boolean lenient) : build()에서 사용된다</li>
            </ol>
            <ul>
                <li>Calendar build()</li>
            </ul>
        </details>
        <details>
            <summary>Field Detail</summary>
            <ol>
                <li>시간 단위</li>
                public static final int ERA, YEAR, MONTH, WEEK_OF_YEAR, WEEK_OF_MONTH_, DATE, ...
                <li>단위 개수</li>
                public static final int FIELD_COUNT
                <li>단위 상수</li>
                public static final int SUNDAY, ..., JANUARY, ...AM, PM
                <li>스타일</li>
                public static final int ALL_STYLES, SHORT, LONG, NARROW_FORMAT, ...
            </ol>
        </details>
        <details>
            <summary>Method Detail</summary>
            <ol>
                <li>static Calendar getInstance() + 3 오버로딩</li>
                <li>static Locale[] getAvailableLocales()</li>
                <li>static Set&lt;String&gt; getAvailableCalendarTypes() Since 1.8</li>

                <li>boolean equals(Object obj) + after, before</li>

                <li>final Date getTime() + setTime</li>
                <li>long getTimeInMillis() + setTimeInMillis</li>
                <li>int get(int field) + set</li>

                <li>abstract void add(int field, int amount)</li>
                <li>abstract void roll(int field, boolean up) : 1 기본단위만큼 up/down</li>
                <li>void roll(int field, int amount) Since 1.2</li>

                <li>final void clear() + 1 오버로딩 : 설정 취소. isSet()이 false를 반환</li>
                <li>final boolean isSet(int field)</li>

                <li>String getDisplayName(int field, int style, Locale locale) Since 1.6 + 1 오버로딩</li>
                <li>String getCalendarType() Since 1.8</li>
                <li>TimeZone getTimeZone() + setTimeZone</li>
                <li>boolean isLenient() + setLenient</li>
                <li>int getFirstDayOfWeek() + setFirstDayOfWeek</li>
                <li>int getMinimalDaysInFirstWeek() + setMinimalDaysInFirstWeek</li>
                첫 주의 시작이 1월 1일인 경우 1, 그 외의 경우 7
                <li>boolean isWeekDateSupported() Since 1.7 : default false</li>
                getWeekYear(), setWeekDate(int,int,int), getWeeksInWeekYear() 등을 지원하는지 여부.
            </ol>
        </details>
    </details>
    <details>
        <summary>class GregorianCalendar extends Calendar Since 1.1</summary>
        <ol>
            <li>GregorianCalendar는 아래 메서드를 지원한다.</li>
            <li>int getWeekYear() Since 1.7</li>
            <li>void setWeekDate(int weekYear, int weekOfYear, int dayOfWeek) Since 1.7</li>
            <li>int getWeeksInWeekYear()</li>
            <li>final Instant toInstant() Since 1.8</li>
            <li>int getActualMaximum(int field)</li>
            <li>int getActualMinimum(int field)</li>
        </ol>
    </details>
    <details>
        <summary>class Timer Since 1.3</summary>
        <ol>
            <li>백그라운드 스레드에서 미래에 실행될 작업들을 스케쥴링하는 기능을 제공한다. 작업은 일회용일수도, 일정한 주기를 가지고 반복될 수도 있다. 한 타이머의 모든 작업들은 하나의 백그라운드 스레드를 공유하기 때문에, 작업의 실행은 직렬적이며, 따라서 각 작업들은 가능한 한 빠르게 종료되어야 한다. 그렇지 않은 경우, 뒤에 대기하는 모든 작업이 밀려 제대로 실행되지 않을 수 있다.</li>
            스레드-안전하다. 정시성을 보장하지 않는다. 스케쥴은 Object.wait(long) 메서드를 통해 이루어진다. java.util.concurrent 패키지의 ScheduledThreadPoolExecutor가 더 나은 대안으로 이용될 수 있다.
            <li>기본적으로 타이머의 백그라운드 스레드는 데몬 스레드가 아니다. 따라서 타이머의 작업이 전체 프로그램의 종료를 지연시킬 수 있다. 백그라운드 스레드는 타이머 임의의 생성자에 의해 시작된다.</li>
        </ol>
        <details>
            <summary>Constructor Detail</summary>
            <ol>
                <li>public Timer()</li>
                <li>public Timer(boolean isDaemon)</li>
                <li>public Timer(String name) Since 1.5</li>
                <li>public Timer(String name, boolean isDaemon) Since 1.5</li>
            </ol>
        </details>
        <details>
            <summary>Method Detail</summary>
            <ol>
                <li>void schedule(TimerTask task, long delay)</li>
                delay밀리초 이후 task가 실행되도록 스케쥴.

                <li>void schedule(TimerTask task, Date time)</li>
                time에 task가 실행되도록 스케쥴. time이 과거라면 즉시 실행

                <li>void schedule(TimerTask task, long delay, long period)</li>
                delay밀리초 이후 period 주기를 갖고 task가 실행되도록 스케쥴.

                <li>void schedule(TimerTask task, Date firstTime, long period)</li>
                firstTime 이후 period 주기를 갖고 task가 실행되도록 스케쥴.

                <li>void scheduleAtFixedRate(TimerTask task, long delay, long period) + 1 오버로딩</li>
                period가 이전 task 종료가 아닌 최초 실행 시점을 기준으로 작동한다. 따라서 어떤 이유로 이전 작업이 지연된 경우, 시간당 작업률을 맞추기 위해 이후 작업이 연속적으로 실행될 수 있다.

                <li>void cancel()</li>
                타이머를 종료한다. 스케쥴된 모든 작업을 버리고, 현재 실행중인 작업에는 간섭하지 않는다. 타이머 종료 후 백그라운드 스레드도 우아하게 종료되어 GC 대상이 된다. 이후 더 이상의 스케쥴은 불가능하다.

                <li>int purge() Since 1.5</li>
                호출할 일이 거의 없는 메서드. 많은 작업을 한번에 취소한 경우, 취소한 작업들을 제거하여 참조가 없는 경우 GC 대상이 되도록 한다.
            </ol>
        </details>
    </details>
    <details>
        <summary>abstract class TimerTask implements Runnable Since 1.3</summary>
        <ol>
            <li>Timer 작업으로 사용하기 위한 Runnable</li>
        </ol>
        <details>
            <summary>Method Detail</summary>
            <ol>
                <li>boolean cancel()</li>
                <ul>
                    <li>작업을 취소한다.</li>
                    <li>작업이 1회용으로 스케쥴되었지만 아직 실행되지 않은 경우, 또는 아직 스케쥴되지 않은 경우 작업은 결코 실행되지 않는다.</li>
                    <li>반복 작업으로 스케쥴된 경우, 작업은 결코 반복되지 않는다.</li>
                    <li>작업 도중에 호출된 경우, 작업은 마무리까지 실행된다.</li>
                    <li>반복 호출 가능하며 2회째 호출부터는 아무런 영향이 없다.</li>
                    <li>true 반환 : 1회용으로 스케쥴되었지만 아직 실행되지 않은 경우, 반복 작업으로 스케쥴된 경우</li>
                    <li>false 반환 : 1회용으로 스케쥴되어 이미 실행된 경우, 아직 스케쥴되지 않은 경우, 이미 취소된 경우</li>
                </ul>

                <li>long scheduledExecutionTime()</li>
                가장 최근에 스케쥴된 ─ 또한 실제로 실행된 ─ 시점을 반환한다. 전형적으로 run 메서드에서, 작업이 너무 길어지는 것을 방지하기 위해 사용된다.
            </ol>
        </details>
    </details>
</details>

<hr>

<details>
    <summary>숫자 관련</summary>
    <details>
        <summary>class DoubleSummaryStatistics implements DoubleConsumer Since 1.8 + IntSummaryStatistics, LongSummaryStatistics</summary>
        <ol>
            <li>double에 관한 통계를 모은 상태 객체. 스트림과 함께 사용되도록 설계되었다.</li>
            예. var stats = doubleStream.collect(DoubleSummaryStatistics::new, DoubleSummaryStatistics::accept, DoubleSummaryStatistics::combine);<br>
            예. var stats = people.stream().collect(Collectors.summarizingDouble(Person::getWeight));

            <li>DoubleSummaryStatistics() + (long count, double min, double max, double sum) Since 10</li>
            갯수 0, 합계 0, 최솟값 Double.POSITIVE_INFINITY, 최댓값 Double.NEGATIVE_INFINITY, 평균 0인 객체 생성.

            <li>void accept(double value) : 요약 정보에 value를 추가</li>
            <li>void combine(DoubleSummaryStatistics other) : other를 호출자에 추가</li>
            <li>final long getCount() + getSum, getMin, getMax, getAverage</li>
        </ol>
    </details>
    <details>
        <summary>class Random implements Serializable Since 1.0</summary>
        <ol>
            <li>public Random() + (long seed)</li>
            의사난수 생성기. 스레드-안전하지만 성능 저하 가능성이 있으므로 ThreadLocalRandom을 고려할 것.

            <li>void setSeed(long seed)</li>
            <li>void nextBytes(byte[] bytes) Since 1.1</li>
            <li>int nextInt() + 1 오버로딩, nextLong, nextBoolean Since 1.2, nextFloat, nextDouble</li>
            <li>double nextGaussian()</li>
            평균 0, 표준분산 1인 정규분포 난수 반환

            <details>
                <summary>난수 스트림</summary>
                <ol>
                    <li>Long, Double 버전 존재</li>
                    <li>IntStream ints(long streamSize) Since 1.8</li>
                    <li>IntStream ints() Sine 1.8 : ints(Long.MAX_VALUE)</li>
                    <li>IntStream ints(long streamSize, int randomNumberOrigin, int randomNumberBound) Since 1.8 : [origin, bound)</li>
                    <li>IntStream ints(int randomNumberOrigin, int randomNumberBound) Since 1.8</li>
                </ol>
            </details>
        </ol>
    </details>
    <details>
        <summary>final class SplittableRandom Since 1.8</summary>
        <ol>
            <li>public SplittableRandom() + (long seed)</li>
            분열하는 의사난수 생성기. 스레드-안전하지 않으며, 분열하여 스레드들이 각자 하나씩 갖도록 설계되었다.
            <li>SplittableRandom split() : 분열. 상태를 공유하진 않지만, 발생한 난수들은 통계적으로 유사한 속성을 갖는다.</li>
        </ol>
    </details>
</details>

<hr>

<details>
    <summary>문자열 및 국제화 관련</summary>
    <details>
        <summary>class Base64 Since 1.8</summary>
        <ol>
            <li>Base64 인코더와 디코더를 반환하는 유틸리티. RFC 2045, 4648</li>
        </ol>
        <details>
            <summary>static class Base64.Encoder Since 1.8</summary>
            <ol>
                <li>byte[] encode(byte[] src)</li>
                <li>int encode(byte[] src, byte[] dst) : 쓴 바이트 수 반환</li>
                <li>String encodeToString(byte[] src) : new String(encode(src), StandardCharsets.ISO_8859_1)</li>
                <li>ByteBuffer encode(ByteBuffer buffer)</li>
                <li>OutputStream wrap(OutputStream os)</li>
                <li>Base64.Encoder withoutPadding()</li>
            </ol>
        </details>
        <details>
            <summary>static class Base64.Decoder Since 1.8</summary>
            <ol>
                <li>byte[] decode(byte[] src)</li>
                <li>byte[] decode(String src)</li>
                <li>int decode(byte[] src, byte[] dst)</li>
                <li>ByteBuffer decode(ByteBuffer buffer)</li>
                <li>InputStream wrap(InputStream is)</li>
            </ol>
        </details>
        <details>
            <summary>Method Detail</summary>
            <ol>
                <li>static Base64.Encoder getEncoder()</li>
                <li>static Base64.Encoder getUrlEncoder()</li>
                <li>static Base64.Encoder getMimeEncoder()</li>
                <li>static Base64.Encoder getMimeEncoder(int lineLength, byte[] lineSeparator)</li>
                <li>static Base64.Decoder getDecoder()</li>
                <li>static Base64.Decoder getUrlDecoder()</li>
                <li>static Base64.Decoder getMimeDecoder()</li>
            </ol>
        </details>
    </details>
    <details>
        <summary>final class Formatter implements Closeable, Flushable Since 1.5</summary>
        <ol>
            <li>formatter.format("%4$2s %3$2s %2$2s %1$2s", "a", "b", "c", "d")</li>
            <li><a class="w3-btn w3-round w3-round-xxlarge w3-small w3-green" target="_blank" href="https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/Formatter.html">https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/Formatter.html</a></li>
        </ol>
    </details>
    <details>
        <summary>final class Locale implements Cloneable, Serializable Since 1.1</summary>
        <ol>
            <li>public static final Locale US, ENGLISH, KOREA, KOREAN, ...</li>
            <li><a class="w3-btn w3-round w3-round-xxlarge w3-small w3-green" target="_blank" href="https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/Locale.html">https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/Locale.html</a></li>
        </ol>
    </details>
    <details>
        <summary>final class Scanner implements Iterator&lt;String&gt;, Closeable Since 1.5</summary>
        <ol>
            <li>정규 표현식을 통해 원시 타입과 String을 분리해내는 간단한 text scanner.</li>
            <li>지정되지 않은 경우, 기본 구분자 패턴은 공백 문자(Character::isWhitespace)</li>
            <li>기저 스트림으로부터 입력을 대기하는 동안 스레드가 블록될 수 있다.</li>
            <li>기저 Readable의 read()에서 IOException이 발생한 경우 소스의 끝에 도달했다고 판단하며, 가장 최근의 예외는 ioException()을 통해 얻을 수 있다</li>
            <li>기저 스트림이 Closeable인 경우, Scanner에 대해 close()가 호출되면 기저 스트림도 닫힌다</li>
        </ol>
        <details>
            <summary>Constructor Detail</summary>
            <ol>
                <li>public Scanner(Readable source)</li>
                <li>public Scanner(InputStream source) + 2 오버로딩</li>
                <li>public Scanner(File source) + 2 오버로딩</li>
                <li>public Scanner(Path source) Since 1.7 + 2 오버로딩</li>
                <li>public Scanner(String source)</li>
                <li>public Scanner(ReadableByteChannel source) + 2 오버로딩</li>
            </ol>
        </details>
        <details>
            <summary>Method Detail</summary>
            <ol>
                <li>Pattern delimiter() + useDelimiter</li>
                <li>Locale locale() + useLocale</li>
                <li>int radix() + useRadix</li>

                <li>boolean hasNext() + 2 오버로딩, next</li>
                + boolean, byte, short, int, long, float, double, BigInteger, BigDecimal
                <li>boolean hasNextLine() + nextLine</li>

                <li>String findInLine(Pattern pattern) + 1 오버로딩</li>
                구분자를 무시하고 pattern을 검색한다. 줄 바꿈 문자 전에 문자열을 찾으면 해당 문자열을 반환하고 다음 라인으로 넘어간다. 줄 바꿈 문자를 만날 때까지 매칭이 없으면 읽기 위치는 변경없이 null을 반환한다.
                <li>String findWithinHorizon(Pattern pattern, int horizon) + 1 오버로딩</li>
                구분자를 무시하고 pattern을 검색한다. 현재 위치로부터 최대 horizon개의 code point만을 검색에 이용한다. horizon == 0인 경우, 제한없이 검색을 수행한다. 매칭된 문자열이 없으면 읽기 위치 변경없이 null을 반환한다.
                <li>Scanner skip(Pattern pattern) + 1 오버로딩</li>
                구분자를 무시하고 pattern을 검색한다. 매칭된 문자열이 있으면 건너뛰고, 없으면 읽기 위치 변경 없이 NoSuchElementException 발생.

                <li>MatchResult match()</li>
                가장 최근의 매칭 결과를 반환한다. MatchResult는 각종 next, findInLine, findWithinHorizon, skip 메서드의 성공적인 실행으로 설정된다.
                <li>Stream&lt;MatchResult&gt; findAll(Pattern pattern) Since 9 + 1 오버로딩</li>
                스트림의 MatchResult 순서는 findWithinHorizon(pattern, 0), match()를 반복적으로 호출한 것과 동일하다.
                <li>Stream&lt;String&gt; tokens() Since 9</li>
                구분자로 자른 문자열들의 스트림을 반환한다

                <li>IOException ioException()</li>
                <li>Scanner reset() Since 1.6</li>
                scanner.useDelimiter("\\p{javaWhitespace}+").useLocale(Locale.getDefault(Locale.Category.FORMAT)).useRadix(10);
            </ol>
        </details>
    </details>
    <details>
        <summary>class StringTokenizer implements Enumberation&lt;Object&gt; Since 1.0</summary>
        <ol>
            <li>public StringTokenizer(String str, String delim, boolean returnDelims) + 2 오버로딩</li>

            <li>boolean hasMoreTokens()</li>
            <li>String nextToken() + 1 오버로딩</li>
            <li>int countTokens()</li>
        </ol>
    </details>
    <details>
        <summary>final class StringJoiner Since 1.8</summary>
        <ol>
            <li>public StringJoiner(CharSequence delimiter) + 1 오버로딩</li>

            <li>StringJoiner setEmptyValue(CharSequence emptyValue)</li>
            StringJoiner가 비어있을 때 toString()에서 반환할 대체문자열 설정.
            <li>StringJoiner add(CharSequence newElement)</li>
            <li>StringJoiner merge(StringJoiner other)</li>
            <li>int length()</li>
        </ol>
    </details>
</details>

<hr>

<details>
    <summary>class Properties extends Hashtable&lt;Object, Object&gt; Since 1.0</summary>
    <ol>
        <li>stream을 통해 로드/저장되는 영구적인 속성값들을 표현. 기본값으로 이용하기 위해 다른 Properties를 포함할 수 있다. 스레드-안전하다.</li>
    </ol>
    <details>
        <summary>Constructor Detail</summary>
        <ol>
            <li>public Properties()</li>
            <li>public Properties(int initialCapacity)</li>
            <li>public Properties(Properties defaults)</li>
        </ol>
    </details>
    <details>
        <summary>Method Detail</summary>
        <ol>
            <li>Object setProperty(String key, String value) Since 1.2</li>
            <li>String getProperty(String key)</li>
            <li>String getProperty(String key, String defaultValue)</li>

            <li>Enumeration&lt;?&gt; propertyNames()</li>
            <li>Set&lt;String&gt; stringPropertyNames() Since 1.6</li>

            <li>void load(Reader reader) Since 1.6</li>
            <li>void load(InputStream inStream) Since 1.2</li>
            <li>void store(Writer writer, String comments) Since 1.6</li>
            <li>void store(OutputStream out, String comments) Since 1.2</li>

            <li>void loadFromXML(InputStream in) Since 1.5</li>
            <li>void storeToXML(OutputStream os, String comment) Since 1.5 + 2 오버로딩</li>

            <li>void list(PrintStream out) + 1 오버로딩 : 디버깅에 유용</li>
        </ol>
    </details>
</details>

<hr>

<details>
    <summary>final class UUID implements Serializable, Comparable&lt;UUID&gt; Since 1.5</summary>
    <ol>
        <li>public UUID(long mostSigBits, long leastSigBits) : 2개 long을 이용해 128비트 UUID 생성</li>
        <li>static UUID randomUUID() : type 4 UUID 생성</li>
        <li>static UUID nameUUIDFromBytes(byte[] name) : type 3 UUID 생성</li>
        <li>static UUID fromString(String name) : toString() 결과로부터 UUID 생성</li>
        <li>+ com.fasterxml.uuid, com.datastax.cassandra</li>

        <li>int version()</li>
        1 Time-based UUID, 2 DCE security UUID, 3 Name-based UUID, 4 Randomly generated UUID
        <li>int variant()</li>
        0 Reserved for NCS, 2 RFC 4122(이 클래스에서 사용), 6 Reserved for Microsoft, 7 Reserved for future
        <li>long timestamp()</li>
        60비트로 구성된 Time-based UUID의 시각을 반환한다. 1582-10-15 00:00:00 UTC로부터 몇 100ns가 흘렀는지를 의미한다
        <li>long node()</li>
        Time-based UUID의 48비트 Mac address를 반환한다.
    </ol>
</details>

<hr>