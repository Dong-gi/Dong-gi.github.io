<hr>

<details>
    <summary>@FunctionalInterface interface Callable&lt;V&gt; Since 1.5</summary>
    V call() : 매개변수 없는, 결과를 반환하는 작업을 정의. Runnable과 달리 checked 예외를 던져도 된다.
</details>

<hr>

<details>
    <summary>interface ThreadFactory Since 1.5</summary>
    Thread newThread(Runnable r)
</details>

<hr>

<details>
    <summary>비동기 자료형 관련</summary>
    <details>
        <summary>interface Future&lt;V&gt; Since 1.5</summary>
        <ol>
            <li>비동기적 계산의 결과를 표현. 결과는 오직 get 메서드로만 얻을 수 있으며, 필요하다면 결과가 준비될 때까지 블록시킨다.</li>
            <li>boolean cancel(boolean mayInterruptIfRunning) + isCancelled</li>
            작업이 완료됐거나 이미 취소된 경우 false를 반환한다. 이 메서드가 종료된 후의 isDone()은 항상 true.
            <li>boolean isDone()</li>
            <li>V get()</li>
            결과가 준비될 때까지 대기
            <li>V get(long timeout, TimeUnit unit)</li>
            결과가 준비될 때까지 최대 timeout만큼 대기
        </ol>
    </details>
    <details>
        <summary>interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; Since 1.6</summary>
        <ol>
            <li>Runnable한 Future. 즉 비동기 연산과 그 결과를 표현한다.</li>
            <li>void run() : Future로 하여금 결과를 설정하도록 한다.</li>
        </ol>
    </details>
    <details>
        <summary>class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; Since 1.5</summary>
        <ol>
            <li>public FutureTask(Callable&lt;V&gt; callable)</li>
            <li>public FutureTask(Runnable runnable, V result)</li>
            <li>protected void done() : 완료 상태로 천이되면 호출된다</li>
            <li>protected void set(V v) : 결과 설정</li>
            <li>protected boolean runAndReset() : 반복 실행 목적</li>
        </ol>
    </details>
    <details>
        <summary>interface Delayed extends Comparable&lt;Delayed&gt; Since 1.5</summary>
        <ol>
            <li>객체가 일정 지연 뒤 작동함을 마킹하는 인터페이스. 이를 구현할 땐 compareTo를 반드시 같이 구현해야 한다.</li>
            <li>long getDelay(TimeUnit unit)</li>
        </ol>
    </details>
    <details>
        <summary>interface ScheduledFuture&lt;V&gt; extends Delayed, Future&lt;V&gt; Since 1.5</summary>
        ScheduledExecutorService의 스케쥴링 결과.
    </details>
    <details>
        <summary>interface RunnableScheduledFuture&lt;V&gt; extends RunnableFuture&lt;V&gt;, ScheduledFuture&lt;V&gt; Since 1.6</summary>
        <ol>
            <li>Runnable한 ScheduledFuture.</li>
            <li>boolean isPeriodic()</li>
        </ol>
    </details>
    <details>
        <summary>interface CompletionStage&lt;T&gt; Since 1.8</summary>
        <ol>
            <li>비동기적일 수 있는 계산 단계. 다른 CompletionStage가 완료된 뒤 어떠한 동작을 수행하거나 값을 계산한다.</li>
            Stage에서 수행되는 연산은 Function, Consumer, Runnable로 표현되어야 한다. 각각은 apply, accept, run 메서드로 stage에 제공된다.
            연산에 넘겨지는 인자는 트리거 stage의 결과이며, 이를 통해 연산의 pipeline을 만들 수 있다.
            <button class="btn-code" path="Repositories/Eclipse/JavaSE/src/concurrent/CompletionStageTest.java" lan="java">예시 코드 »</button>
    
            <li>&lt;U&gt; CompletionStage&lt;U&gt; thenApply(Function&lt;? super T, ? extends U&gt; fn) + thenApplyAsync<br>
                CompletionStage&lt;Void&gt; thenAccept(Consumer&lt;? super T&gt; action) + thenAcceptAsync<br>
                CompletionStage&lt;Void&gt; thenRun(Runnable action) + thenRunAsync</li>
            이전 연산이 완료되면 그 결과로 fn, action 호출
    
            <li>&lt;U, V&gt; CompletionStage&lt;V&gt; thenCombine(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? super T, ? super U, ? extends V&gt; fn) + thenCombineAsync<br>
                &lt;U&gt; CompletionStage&lt;Void&gt; thenAcceptBoth(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? super T, ? super U&gt; action) + thenAcceptBothAsync<br>
                CompletionStage&lt;Void&gt; runAfterBoth(CompletionStage&lt;?&gt; other, Runnable action) + runAfterBothAsync</li>
            this와 other 모두가 종료되면 그 결과로 fn, action 호출
    
            <li>&lt;U&gt; CompletionStage&lt;U&gt; applyToEither(CompletionStage&lt;? extends T&gt; other, Function&lt;? super T, U&gt; fn) + applyToEitherAsync<br>
                CompletionStage&lt;Void&gt; acceptEither(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action) + acceptEitherAsync<br>
                CompletionStage&lt;Void&gt; runAfterEither(CompletionStage&lt;?&gt; other, Runnable action) + runAfterEitherAsync</li>
            this나 other 둘 중 하나라도 종료되면 그 결과로 fn, action 호출
    
            <li>&lt;U&gt; CompletionStage&lt;U&gt; thenCompose(Function&lt;? super T, ? extends CompletionStage&lt;U&gt;&gt; fn) + thenComposeAsync</li>
            this의 결과를 인자로 fn이 반환하는 CompletionStage가 실행되고, 실행된 결과와 같은 값으로 종료되는 CompletionStage를 반환한다
    
            <li>&lt;U&gt; CompletionStage&lt;U&gt; handle(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn) + handleAsync</li>
            this가 종료되면 결과와 예외를 인자로 fn을 실행하고, fn의 결과로 반환된 stage를 종료한다.
    
            <li>CompletionStage&lt;T&gt; whenComplete(BiConsumer&lt;? super T, ? super Throwable&gt; action) + whenCompleteAsync</li>
            this가 종료되면 결과와 예외를 인자로 action을 실행하고, action이 종료되면 반환된 stage도 종료된다.
    
            <li>CompletionStage&lt;T&gt; exceptionally(Function&lt;Throwable, ? extends T&gt; fn) + exceptionallyAsync Since 12</li>
            this가 예외를 발생하면 그것을 인자로 fn 실행하는 CompletionStage 반환. 예외 발생이 없는 경우, this의 결과와 같은 값으로 반환된 stage가 종료된다.
    
            <li>default CompletionStage&lt;T&gt; exceptionallyCompose(Function&lt;Throwable, ? extends CompletionStage&lt;T&gt;&gt; fn) Since 12 + exceptionallyComposeAsync</li>
            this가 예외를 발생하면 fn이 반환하는 CompletionStage로 구성된다.

            <li>CompletableFuture&lt;T&gt; toCompletableFuture()</li>
        </ol>
    </details>
    <details>
        <summary>class CompletableFuture&lt;T&gt; impliments Future&lt;T&gt;, CompletionStage&lt;T&gt; Since 1.8</summary>
        <ol>
            <li>CompletionStage로 이용될 수 있는, 명시적으로 종료(값과 상태를 설정)되는 Future.</li>
            <li>둘 이상의 스레드가 complete, completeExceptionally, cancel을 호출할 경우, 하나만 성공한다.</li>
            <li>non-async 메서드로 등록된 작업은 현재 CompletableFuture가 완료된 스레드 또는 호출자에서 실행된다.</li>
            <li>명시적인 Executor 없이 async 메서드로 등록된 작업은 ForkJoinPool::commonPool에서 수행.</li>
            <li>CompletionStage 메서드들을 독립적으로 구현했기 때문에, 하나를 재정의해도 다른 메서드에 영향이 없다.</li>
            <li>CompletionStage 메서드들만 이용하도록 하려면 minimalCompletionStage()를, future를 변경하지 못하도록 하려면 copy()를 이용.</li>
            <li>전반적인 계산에 대한 직접적인 제어를 할 수 없어서 cancel()의 호출은 completeExceptionally(new CancellationException()) 호출과 동일하다</li>
            <li>서브클래스들은 각자의 클래스 인스턴스를 반환하도록 newIncompletableFuture 메서드를 재정의해야 한다</li>
        </ol>
        <details>
            <summary>static interface CompletableFuture.AsynchronousCompletionTask Since 1.8</summary>
            비동기 메서드에서 생성된 비동기 작업을 나타내는 마커 인터페이스
        </details>
        <details>
            <summary>Method Detail</summary>
            <ol>
                <li>static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier) + 1 오버로드</li>
                supplier의 결과를 가지고 비동기 종료되는 CompletableFuture 반환
    
                <li>static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable) + 1 오버로드</li>
                runnable을 실행하고 비동기 종료되는 CompletableFuture 반환
            
                <li>static &lt;U&gt; CompletableFuture&lt;U&gt; completedFuture(U value)</li>
                이미 특정 값으로 종료된 CompletableFuture 반환
    
                <li>static CompletableFuture&lt;Void&gt; allOf(CompletableFuture&lt;?&gt;... cfs)</li>
                모든 cfs가 종료되면 완료되는 새로운 CompletableFuture 객체 반환. 하나라도 예외 종료되면 반환된 CompletableFuture도 그러하다. cfs가 빈 경우, null로 종료된다
            
                <li>static CompletableFuture&lt;Object&gt; anyOf(CompletableFuture&lt;?&gt;... cfs)</li>
                하나라도 종료되면, 그 결과와 같은 값으로 종료되는 CompletableFuture 객체 반환. cfs가 빈 경우, 완료되지 않는다
    
                <li>T join()</li>
                종료되면 결과 값 반환, 또는 발생한 예외 던지기. 예외는 CompletionException이고, 기저 예외를 cause로 설정한다
    
                <li>T getNow(T valueIfAbsent)</li>
                종료되었다면 결과 값 반환, 또는 발생한 예외 던지기. 아니면 valueIfAbsent 반환.
    
                <li>boolean complete(T value)</li>
                종료되지 않았다면 get()과 연관 메서드들의 반환값을 value로 설정. 이 호출로 CompletableFuture가 완료 상태로 천이되었다면 true 반환.
    
                <li>boolean completeExceptionally(Throwable ex)</li>
                종료되지 않았다면 get()과 연관 메서드들이 주어진 예외를 던지도록 한다. 이 호출로 CompletableFuture가 완료 상태로 천이되었다면 true 반환.
    
                <li>boolean isCompletedExeptionally()</li>
            
                <li>void obtrudeValue(T value) + obtrudeException</li>
                강제로 get()과 연관 메서드들의 반환값 설정. 에러 복구를 위해 설계됨.
    
                <li>int getNumberOfDependents()</li>
                종료 대기중인 CompletableFuture의 개수 추정. 동기화가 아닌 시스템 모니터링을 위해 설계됨.
            </ol>
        </details>
        <details>
            <summary>Method Detail Since 9</summary>
            <ol>
                <li>static Executor delayedExecutor(long delay, TimeUnit unit) + 1 오버로딩</li>
                주어진 딜레이 이후에 executor로 작업을 제출하는 새로운 Executor 반환.

                <li>static &lt;U&gt; CompletionStage&lt;U&gt; completedStage(U value)</li>
                주어진 value로 이미 종료된 새로운 CompletionStage 반환.
        
                <li>static &lt;U&gt; CompletableFuture&lt;U&gt; failedFuture(Throwable ex)</li>
                주어진 예외로 이미 종료된 새로운 CompletableFuture 객체 반환.
        
                <li>static &lt;U&gt; CompletionStage&lt;U&gt; failedStage(Throwable ex)</li>
                주어진 예외로 이미 종료된 새로운 CompletionStage 반환.

                <li>&lt;U&gt; CompletableFuture&lt;U&gt; newIncompletableFuture()</li>
                완료되지 않은 새로운 CompletableFuture 객체를 반환한다. 서브클래스들은 각자의 클래스 인스턴스를 반환하도록 newIncompletableFuture 메서드를 재정의해야 한다
    
                <li>Executor defaultExecutor()</li>
                
                <li>CompletableFuture&lt;T&gt; copy()</li>
                정상적으로 종료되었다면, 같은 값을 갖는 종료된 CompletableFuture 반환. 예외 종료되었다면, 해당 예외를 원인으로 한 CompletionException으로 예외 종료된 CompletableFuture 반환. 동작은 thenApply(x -&gt; x)와 같다.
                
                <li>CompletionStage&lt;T&gt; minimalCompletionStage()</li>
                CompletionStage에 정의된 메서드만 이용 가능. 재정의되지 않았다면 toCompletableFuture() 메서드를 통해 그 외의 메서드에 접근 가능하다.
    
                <li>CompletableFuture&lt;T&gt; completeAsync(Supplier&lt;? extends T&gt; supplier) + 1 오버로딩</li>
                이 CompletableFuture를 supplier의 결과값으로 종료한다.
    
                <li>CompletableFuture&lt;T&gt; orTimeout(long timeout, TimeUnit unit)</li>
                이 CompletableFuture가 주어진 시간 내에 종료되지 않은 경우, TimeoutException으로 예외 종료한다.
                
                <li>CompletableFuture&lt;T&gt; completeOnTimeout(T value, long timeout, TimeUnit unit)</li>
                이 CompletableFuture가 주어진 시간 내에 종료되지 않은 경우, value로 종료한다.    
            </ol>
        </details>
    </details>
    <details>
        <summary>abstract class ForkJoinTask&lt;V&gt; implements Future&lt;V&gt;, Serializable Since 1.7</summary>
        <ol>
            <li>ForkJoinPool의 실행 단위. 일반적인 스레드보다는 훨씬 가벼운 유사-스레드</li>
            <li>메인 ForkJoinTask가 존재하여 다른 subtask들을 실행한다</li>
            <li>전형적으로는 fork, join 메서드 쌍만 이용하며, a.fork(); b.fork(); b.join(); a.join();처럼 join 순서에 유의</li>
            <li>RecursiveAction : 반환이 필요없는 경우<br>
                RecursiveTask : 반환이 필요한 경우<br>
                CountedCompleter : 작업의 완료가 다른 작업의 트리거가 되는 경우</li>
        </ol>
        <details>
            <summary>일반 Method Detail</summary>
            <ol>
                <li>final ForkJoinTask&lt;V&gt; fork() : 작업 시작</li>
                <li>final V join() : 종료 대기 후 결과 반환. 비정상 종료 시 RuntimeException 또는 Error 발생</li>
                <li>final V invoke() : fork + join</li>
                <li>static void invokeAll(ForkJoinTask&lt;?&gt;... tasks) + 오버로딩</li>
                모든 작업을 시작. 모두 완료되면 반환. 하나라도 예외가 발생하면 rethrow. 예외 종료된 경우 각 작업의 상태는 직접 획득해야 한다.
                <li>final boolean isCompleteNormally() + isCompletedAbnormally</li>
                <li>final Throwable getException()</li>
                <li>static ForkJoinTask&lt;?&gt; adapt(Runnable runnable) + 오버로딩</li>
            </ol>
        </details>
        <details>
            <summary>잘 안 쓸 것 같은 Method</summary>
            <ol>
                <li>void complete(V value) + completeExceptionally</li>
                <li>final void quietlyComplete() Since 1.8</li>
                값은 설정하지 말고 정상 종료. 가장 최근의 setRawResult(V) 값이 join 및 연관 메서드의 결과로 반환된다
                <li>final void quietlyJoin()</li>
                작업의 종료를 기다린다. 결과를 반환하지도, 예외를 던지지도 않는다
                <li>final void quietlyInvoke()</li>
                작업을 시작하고 종료를 기다린다. 결과를 반환하지도, 예외를 던지지도 않는다
                <li>void reinitialize()</li>
                초기화하여 다시 fork할 수 있게 한다
                <li>static ForkJoinPool getPool() + inForkJoinPool</li>
                현재 스레드를 호스팅하는 풀 반환. 없으면(inForkJoinPool() == false) null 반환
                <li>boolean tryUnfork()</li>
                성공하면 true 반환. 작업을 시작하도록 지시(fork)했지만 아직 다른 스레드에 넘겨져 실행되기 전에는 취소가 잘 된다
                <li>static int getQueuedTaskCount()</li>
                현재 워커 스레드로 fork됐지만 아직 실행되지는 않은 작업들의 개수 추정치
            </ol>
        </details>
    </details>
    <details>
        <summary>abstract class RecursiveAction extends ForkJoinTask&lt;Void&gt; Since 1.7</summary>
        재귀적이며 결과없는 ForkJoinTask
        <button class="btn-code" path="Repositories/Eclipse/JavaSE/src/concurrent/RecursiveActionTest.java" lan="java">예시 코드 »</button><br>
        코드 출처 : https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/concurrent/RecursiveAction.html
    </details>
    <details>
        <summary>abstract class RecursiveTask&lt;V&gt; extends ForkJoinTask&lt;V&gt; Since 1.7</summary>
        재귀적이며 결과가 있는 ForkJoinTask
        <button class="btn-code" path="Repositories/Eclipse/JavaSE/src/concurrent/RecursiveTaskTest.java" lan="java">예시 코드 »</button><br>
        코드 출처 : https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/concurrent/RecursiveTask.html
    </details>
    <details>
        <summary>abstract class CountedCompleter&lt;T&gt; extends ForkJoinTask&lt;T&gt; Since 1.8</summary>
        <ol>
            <li>다른 작업들을 기다린 뒤 트리거로 작업을 시작하는 ForkJoinTask</li>
            <li>Concrete 서브클래스들은 compute() 메서드를 반드시 재정의해야 하며, 되도록이면 반환하기 전에 tryComplete()을 호출해야 한다</li>
            <li>일반적으로 CountedCompleter는 결과를 갖지 않겠지만, 결과가 필요한 경우 getRawResult() 메서드를 재정의하면 된다</li>
            <li><button class="btn-code" path="Repositories/Eclipse/JavaSE/src/concurrent/CountedCompleterTest.java" displayRange="[14,34,75,85]" lan="java">예시 : setPendingCount + tryComplete</button>
                <button class="btn-code" path="Repositories/Eclipse/JavaSE/src/concurrent/CountedCompleterTest.java" displayRange="[36,54,75,85]" lan="java">예시 : addToPendingCount + propagateCompletion</button>
                <button class="btn-code" path="Repositories/Eclipse/JavaSE/src/concurrent/CountedCompleterTest.java" displayRange="[56,73,75,85]" lan="java">예시 : 생성자에서 pendingCount 설정</button>
                <button class="btn-code" path="Repositories/Eclipse/JavaSE/src/concurrent/CountedCompleterTest.java" displayRange="[87,130]" lan="java">예시 : quietlyCompleteRoot</button>
                <button class="btn-code" path="Repositories/Eclipse/JavaSE/src/concurrent/CountedCompleterTest.java" displayRange="[132,168]" lan="java">예시 : compute 사용없이 트리거로만 이용</button><br>
                출처 ; https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/concurrent/CountedCompleter.html</li>
        </ol>
        <details>
            <summary>Constructor Detail</summary>
            <ol>
                <li>protected CountedCompleter(CountedCompleter&lt;?&gt; completer, int initialPendingCount)</li>
                <li>protected CountedCompleter(CountedCompleter&lt;?&gt; completer) : initialPendingCount = 0</li>
                <li>protected CountedCompleter() : parent completer = null, initialPendingCount = 0</li>
            </ol>
        </details>
        <details>
            <summary>Method Detail</summary>
            <ol>
                <li>abstract void compute() : 메인 작업 정의</li>
                <li>void onCompletion(CountedCompleter&lt;?&gt; caller)</li>
                tryComplete()이 호출되고, 남은 pendingCount가 0이면 호출된다. 또는 complete(T)가 호출된 경우에도 실행된다
                <li>boolean onExceptionalCompletion(Throwable ex, CountedCompleter&lt;?&gt; caller)</li>
                compute()에서 예외가 발생했거나, ForkJoinTask::completeExceptionally가 호출된 경우 실행된다. 기본 구현은 return true;<br>
                true를 반환하였고, caller가 아직 완료되지 않은 경우, caller도 같은 예외로 종료된다
                <li>final CountedCompleter&lt;?&gt; getCompleter() : 생성자에서 지정한 부모 completer 반환 + getRoot</li>
                <li>final int getPendingCount()</li>
                + setPendingCount, addToPendingCount, compareAndSetPendingCount, decrementPendingCountUnlessZero
                <li>final void tryComplete()</li>
                pendingCount가 0이 아니면 1 감소시킨다. 0인 경우 onCompletion 메서드를 호출하고, parent completer에 대해서도 tryComplete()을 호출한다
                <li>final void propagateCompletion()</li>
                tryComplete()와 같지만, onCompletion 메서드는 호출하지 않는다
                <li>final CountedCompleter&lt;?&gt; firstComplete()<br>
                    final CountedCompleter&lt;?&gt; nextComplete()</li>
                firstComplete() : pendingCount가 0이면 return this; 그 외엔 pendingCount를 감소시키고 return null;<br>
                nextComplete() : parent completer가 없는 경우, ForkJoinTask::quietlyComplete 호출하고 return null; pendingCount가 0이 아니면 감소시키고 return null; 그 외엔 parent completer 반환<br>
                for(var c = firstComplete(); c != null; c = c.nextComplete()) { ... }
                <li>final void quietlyCompleteRoot() == getRoot().quietlyComplete()</li>
                <li>final void helpComplete(int maxTasks)</li>
                이 작업이 완료되지 않았다면, completion path 상의 최대 maxTasks개 만큼의 시작되지 않은 작업을 진행시킨다
            </ol>
        </details>
    </details>
</details>

<hr>

<details>
    <summary>Executor 관련</summary>
    <details>
        <summary>interface Executor Since 1.5</summary>
        <ol>
            <li>전달받은 Runnable을 실행하는 객체. Executor 자체가 스레드의 병행성을 부여하진 않으며, 구현에서 호출자와 다른 스레드 공간을 마련해주어야 한다.</li>
            <li>void execute(Runnable command)</li>
        </ol>
    </details>
    <details>
        <summary>interface ExecutorService extends Executor Since 1.5</summary>
        <ol>
            <li>java.util.concurrent 패키지의 기본적인 Executor 구현.
                <button class="btn-code" path="Repositories/Eclipse/JavaSE/src/concurrent/ExecutorServiceTest.java" lan="java">예시 코드 »</button></li>
            
            <li>void shutdown()</li>
            추가적인 Runnable을 받지 않는다. 이전에 추가된 것은 마저 실행한다.
    
            <li>List&lt;&Runnable&gt; shutdownNow()</li>
            실행중인 모든 작업을 중지. 실행 대기중이었던 작업들은 반환.
    
            <li>boolean isShutdown()</li>
            <li>boolean isTerminated()</li>
            shutdown, shutdownNow 호출 이후 모든 작업이 끝났는지 여부

            <li>boolean awaitTermination(long timeout, TimeUnit unit)</li>
            shutdown 요청 후 모든 작업이 종료되기를 기다리며 블록한다. timeout 발생한 경우 false 반환.
            
            <li>&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</li>
            결과를 반환하는 작업을 등록한다. 작업이 성공적으로 종료되면 Future::get으로 결과를 확인할 수 있다.
            
            <li>&lt;T&gt; Future&lt;T&gt; submit(Runnable atask, T result)</li>
            작업을 등록한다. 작업이 성공적으로 종료되면 Future::get으로 result를 얻을 수 있다.
            
            <li>Futur&lt;?&gt; submit(Runnable task)</li>
            작업을 등록한다. 작업이 성공적으로 종료되면 Future::get은 null을 반환한다.
            
            <li>&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</li>
            모든 작업이 종료되면 Future 리스트를 반환한다. 따라서 리스트 안의 각 Future::isDone은 true다.
            
            <li>&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timout, TimeUnit unit)</li>
            모든 작업이 종료되거나 timeout이 발생하면 반환. 리스트 안의 각 Future::isDone은 true. timeout 발생 시 완료되지 않은 작업들은 취소된다.
            
            <li>&lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</li>
            성공적으로 완료된 첫 작업의 결과를 반환한다. 완료되지 않은 작업들은 취소된다.
            
            <li>&lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;&gt;&gt; tasks, long timeout, TimeUnit unit)</li>
            timeout되면 TimeoutException 발생
        </ol>
    </details>
    <details>
        <summary>interface ScheduledExecutorService extends ExecutorService Since 1.5</summary>
        <ol>
            <li>실행 전에 딜레이를 두거나, 주기적으로 실행을 반복할 수 있는 ExecutorService</li>
            
            <li>ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit) + 오버로딩</li>
            주어진 delay 이후 command가 1회 실행되도록 한다
            
            <li>ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)</li>
            반복되는 작업은 반환된 Future를 통해 취소할 수 있다.
            
            <li>ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)</li>
            scheduleAtFixedRate와 달리, 이전 작업이 완료된 후 다음 작업이 시작된다.
        </ol>
    </details>
    <details>
        <summary>abstract class AbstractExecutorService implements ExecutorService Since 1.5</summary>
        <ol>
            <li>submit, invokeAny, invokeAll 메서드 구현. 반환하는 RunnableFuture에는 FutureTask 이용.</li>
            <li>protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) Since 1.6 + 오버로딩</li>
        </ol>
    </details>
    <details>
        <summary>class ThreadPoolExecutor extends AbstractExecutorService Since 1.5</summary>
        <ol>
            <li>각 작업들은 스레드풀의 별개 스레드에서 실행된다</li>
            <li>Core and maximum pool sizes</li>
            corePoolSize에 도달할 때까지 신규 작업에 대해 신규 스레드를 할당한다. 대기 중인 스레드가 없으면 maxPoolSize에 도달할 때까지 신규 작업에 대해 신규 스레드를 할당한다
            <li>On-demand construction</li>
            처음부터 corePoolSize만큼의 스레드를 만들어놓을 지를 설정할 수 있다
            <li>Creating new threads</li>
            지정되지 않으면 Executors::defaultThreadFactory로부터 신규 스레드를 생성한다. 동일 스레드그룹 + NORM_PRIORITY + non-daemon
            <li>Keep-alive times</li>
            corePoolSize를 초과한 스레드들은 대기 상태가 keepAliveTime을 초과하면 종료된다. allowCoreThreadTimeOut 메서드로 코어 스레드에도 적용할 지 설정 가능
            <li>Queuing</li>
            <ul>
                <li>처리를 기다리는 작업들은 BlockingQueue에서 대기한다.</li>
                <li>corePoolSize 이상의 스레드가 활성 상태라면 작업은 우선 큐에 진입된다. 큐에 자리가 없으면 신규 스레드가 생성되어 작업을 처리한다.</li>
                <li>큐에 자리도 없고 활성 스레드 수가 maximumPoolSize와 같다면 추가 작업은 거부된다</li>
                <li>큐잉 전략 1. Direct handoff</li>
                SynchronousQueue. 작업 가능한 스레드가 없으면 신규로 생성한다. 제한없는 maximumPoolSize 필요
                <li>큐잉 전략 2. Unbounded queue</li>
                무제한으로 큐에 작업을 추가하므로, 활성 스레드의 수는 항상 corePoolSize 이하다
                <li>큐잉 전략 3. Bounded queue</li>
                큐의 크기와 maxPoolSize의 적절한 trade off 필요
            </ul>
            <li>Rejected tasks</li>
            <ul>
                <li>거부된 작업에 대하여 RejectedExecutionHandler::rejectedExecution 메서드가 실행된다</li>
                <li>기본 정책. ThreadPoolExecutor.AbortPolicy : 핸들러가 RejectedExecutionException 발생</li>
                <li>ThreadPoolExecutor.CallerRunsPolicy : 작업을 제출한 스레드가 직접 작업을 실행한다</li>
                <li>ThreadPoolExecutor.DiscardPolicy : 거부된 작업은 버려진다</li>
                <li>ThreadPoolExecutor.DiscardOldestPolicy : 신규 작업이 아닌, 큐에서 가장 오래된 작업이 버려진다. 신규 작업은 다시 시도된다</li>
            </ul>
            <li>Hook methods</li>
            beforeExecute, afterExecute, terminated 메서드를 재정의하여 작업 전후에 필요한 부분을 실행할 수 있다
        </ol>
        <details>
            <summary>interface RejectedExecutionHandler Since 1.5</summary>
            <ol>
                <li>ThreadPoolExecutor에서 실행되지 않은 작업에 대한 처리를 위해 사용.</li>
                <li>void rejectedExecution(Runnable r, ThreadPoolExecutor executor)</li>
                <li>static class ThreadPoolExecutor.AbortPolicy implements RejectedExecutionHandler</li>
                <li>static class ThreadPoolExecutor.CallerRunsPolicy implements RejectedExecutionHandler</li>
                <li>static class ThreadPoolExecutor.DiscardPolicy implements RejectedExecutionHandler</li>
                <li>static class ThreadPoolExecutor.DiscardOldestPolicy implements RejectedExecutionHandler</li>
            </ol>
        </details>
        <details>
            <summary>Constructor Detail</summary>
            <ol>
                <li>public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</li>
                <li>public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory)</li>
                <li>public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler)</li>
                <li>public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)</li>
            </ol>
        </details>
        <details>
            <summary>Method Detail</summary>
            <ol>
                <li>void execute(Runnable command) ↔ remove</li>
                command를 언젠가 실행한다. 작업 스레드가 실행하지 못하면, RejectedExecutionHandler가 처리한다
                <li>void shutdown()</li>
                순차적 종료 절차에 진입한다. 추가 작업은 받지 않고, 이미 제출된 작업들은 마저 처리한다
                <li>List&lt;Runnable&gt; shutdownNow()</li>
                대기 중인 작업에 더해 실행 중인 작업들도 모두 중지한다. 대기중이었던 작업들은 리스트로 반환한다. 실행 중인 작업들에 유예 시간을 주고 싶다면 ExecutorService::awaitTermination 이용
                <li>boolean isTerminating()</li>
                shutdown 또는 shutdownNow 메서드가 호출되었지만, 아직 중지가 완료되지는 않았다면 true
                <li>void setThreadFactory(ThreadFactory threadFactory) + getter 메서드</li>
                + set/getRejectedExecutionHandler, set/getCorePoolSize, set/getMaximumPoolSize, set/getKeepAliveTime
                <li>boolean prestartCoreThread()</li>
                신규 스레드를 하나 생성한다. 이미 corePoolSize 만큼 스레드가 존재한다면 false 반환.
                <li>int prestartAllCoreThreads()</li>
                생성된 스레드의 수가 corePoolSize가 될 때까지 신규 스레드를 생성한다. 신규로 생성된 스레드의 수를 반환한다
                <li>void allowCoreThreadTimeOut(boolean value) Since 1.6 + 오버로딩</li>
                코어 스레드에도 keep-alive를 적용할 지 여부 setter/getter
                <li>BlockingQueue&lt;Runnable&gt; getQueue()</li>
                직접 조작하진 말고, 모니터링/디버깅 용도로 이용함이 바람직하다
                <li>void purge() : 취소된 Future 작업들을 큐에서 제거</li>
                <li>int getPoolSize()</li>
                현재 풀 안의 스레드 수 반환
                <li>int getActiveCount()</li>
                현재 실행 중인 스레드 수 추정치 반환
                <li>int getLargestPoolSize()</li>
                풀에 동시에 존재했던 스레드의 최대 개수 반환
                <li>long getTaskCount()</li>
                실행 스케쥴된 작업의 총 개수의 근사치 반환
                <li>long getCompletedTaskCount()</li>
                실행 완료된 작업의 총 개수의 근사치 반환
            </ol>
        </details>
    </details>
    <details>
        <summary>class ScheduledThreadPoolExecutor extends ThreadPoolExecutor implements ScheduledExecutorService Since 1.5</summary>
        <ol>
            <li>생성자는 ThreadPoolExecutor와 유사</li>
            <li>protected &lt;V&gt; RunnableScheduledFuture&lt;V&gt; decorateTask(Runnable runnable, RunnableScheduledFuture&lt;V&gt; task) Since 1.6 + 오버로딩</li>
            
            <li>void setContinueExistingPeriodicTasksAfterShutdownPolicy(boolean value) + getter</li>
            기본값 false. true면 shutdownNow가 호출되거나 이 정책이 false가 될 때까지 주기 작업을 계속 실행한다
            <li>void setExecuteExistingDelayedTasksAfterShutdownPolicy(boolean value) + getter</li>
            기본값 true. true면 shutdownNow가 호출되거나 종료 후 이 정책이 false가 되기 전까지는 지연 작업을 실행한다
            <li>void setRemoveOnCancelPolicy(boolean value) Since 1.7 + getter</li>
            기본값 false. 취소된 작업을 즉시 큐에서 제거할 것인지, 또는 해당하는 딜레이 후 제거할 것인지 설정.
        </ol>
    </details>
    <details>
        <summary>interface CompletionService&lt;V&gt; Since 1.5</summary>
        <ol>
            <li>생산자가 작업들을 추가하면, 소비자는 그것이 완료된 순서대로 이용할 수 있다.</li>
            
            <li>Future&lt;V&gt; submit(Callable&lt;V&gt; task)</li>
            <li>Future&lt;V&gt; submit(Runnable task, V result)</li>
            <li>Future&lt;V&gt; take()</li>
            완료된 작업을 가져온다. 없으면 대기한다.
            <li>Future&lt;V&gt; poll()</li>
            완료된 작업을 가져온다. 없으면 null.
            <li>Futur&lt;V&gt; poll(long timeout, TimeUnit unit)</li>
        </ol>
    </details>
    <details>
        <summary>class ExecutorCompletionService&lt;V&gt; impliments CompletionService&lt;V&gt</summary>
        <ol>
            <li>CompletionService 구현. 주어진 Executor를 실행에 이용한다. 완료되는 순서대로 작업을 take 메서드로 접근할 수 있는 큐에 배치한다.</li>
            <li>public ExecutorCompletionService(Executor executor)</li>
            <li>public ExecutorCompletionService(Executor executor, BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue)</li>
        </ol>
    </details>
    <details>
        <summary>class ForkJoinWorkerThread extends Thread Since 1.7</summary>
        <ol>
            <li>ForkJoinPool에서 ForkJoinTask를 실행하는 스레드</li>
            <li>protected ForkJoinWorkerThread(ForkJoinPool pool) + getPool</li>
            <li>int getPoolIndex() : 풀 안에서 이 스레드의 번호(Unique)</li>
            <li>protected void onStart() + onTermination</li>
        </ol>
    </details>
    <details>
        <summary>class ForkJoinPool extends AbstractExecutorService Since 1.7</summary>
        <ol>
            <li>ForkJoinTask에 관한 ExecutorService. Non-ForkJoinTask 호출자도 이용할 수 있는 메서드를 제공한다</li>
            execute(ForkJoinTask), invoke(ForkJoinTask), submit(ForkJoinTask)
            <li>모든 ForkJoinWorkerThread는 데몬 스레드로 초기화된다</li>
            <li>Common pool 튜닝에 관한 시스템 속성</li>
            java.util.concurrent.ForkJoinPool.common.parallelism : parallelism level. 기본값은 프로세서 수<br>
            java.util.concurrent.ForkJoinPool.common.threadFactory : class name of a ForkJoinPool.ForkJoinWorkerThreadFactory<br>
            java.util.concurrent.ForkJoinPool.common.exceptionHandler : class name of a Thread.UncaughtExceptionHandler<br>
            java.util.concurrent.ForkJoinPool.common.maximumSpares : maximum number of allowed extra threads to maintain target parallelism (default 256).
        </ol>
        <details>
            <summary>static interface ForkJoinPool.ForkJoinWorkerThreadFactory</summary>
            ForkJoinWorkerThread newThread(ForkJoinPool pool)
        </details>
        <details>
            <summary>static interface ForkJoinPool.ManagedBlocker</summary>
            <ol>
            <li>boolean block()</li>
            필요한 만큼 현재 스레드를 블록시킨다. 추가적인 블로킹이 필요하지 않으면 true 반환
            <li>boolean isReleasable</li>
            블로킹이 필요없으면 true 반환
            </ol>
        </details>
        <details>
            <summary>Field, Constructor Detail</summary>
            <ol>
                <li>public static final ForkJoinPool.ForkJoinWorkerThreadFactory defaultForkJoinWorkerThreadFactory</li>
                <li>public ForkJoinPool() == this(Runtime.availableProcessors())</li>
                <li>public ForkJoinPool(int parallelism)</li>
                <li>public ForkJoinPool(int parallelism, ForkJoinPool.ForkJoinWorkerThreadFactory factory, Thread.UncaughtExceptionHandler handler, boolean asyncMode)</li>
                <li>public ForkJoinPool(int parallelism, ForkJoinPool.ForkJoinWorkerThreadFactory factory, Thread.UncaughtExceptionHandler handler, boolean asyncMode, int corePoolSize, int maximumPoolSize, int minimumRunnable, Predicate&lt;? super ForkJoinPool&gt; saturate, long keepAliveTime, TimeUnit unit) Since 9</li>
            </ol>
        </details>
        <details>
            <summary>Method Detail</summary>
            <ol>
                <li>static ForkJoinPool commonPool() Since 1.8</li>
                <li>static void managedBlock(ForkJoinPool.ManagedBlocker blocker)</li>
                <li>&lt;T&gt; T invoke(ForkJoinTask&lt;T&gt; task)<br>
                    void execute(ForkJoinTask&lt;?&gt; task) + 오버로딩<br>
                    &lt;T&gt; ForkJoinTask&lt;T&gt; submit(ForkJoinTask&lt;T&gt; task) + 오버로딩</li>
                <li>void shutdown()</li>
                + shutdownNow(), isTerminated, isTerminating, isShutdown, awaitTermination, awaitQuiescence
                <li>ForkJoinPool.ForkJoinWorkerThreadFactory getFactory()</li>
                + getUncaughtExceptionHandler, getParallelism, getPoolSize, getAsyncMode, getRunningThreadCount, getActiveThreadCount, isQuiescent, getStealCount, getQueuedTaskCount, getQueuedSubmissionCount, hasQueuedSubmissions
            </ol>
        </details>
    </details>
    <details>
        <summary>class Executors Since 1.5</summary>
        <details>
            <summary>ExecutorService 관련</summary>
            <ul>
                <li>static ExecutorService newFixedThreadPool(int nThreads) + 오버로딩</li>
                최대 동시 실행 가능한 스레드 수가 제한. 나머지 스레드는 큐에서 대기. 스레드들은 명시적으로 shutdown되기 전까지 풀에 존재한다.
                <li>static ExecutorService newWorkStealingPool() Since 1.8 + 오버로딩</li>
                사용 가능한 프로세서 수를 parallelism level로 이용. 반환되는 객체는 ForkJoinPool 인스턴스
                <li>static ExecutorService newSingleThreadExecutor() + 오버로딩</li>
                하나의 워커 스레드만 사용한다. 예기지 않게 워커가 종료되면 새로운 스레드가 나머지 작업을 위해 그 자리를 대신할 수 있다.<br>
                같은 특징을 갖는 newFixedThreadPool(1)과 다르게, 반환된 ExecutorService가 추가적인 워커 스레드를 이용하도록 설정할 수 없다.
                <li>static ExecutorService newCachedThreadPool() + 오버로딩</li>
                이전에 종료된 스레드를 재사용. 60초 동안 이용되지 않으면 풀에서 삭제된다.
                <li>static ExecutorService unconfigurableExecutorService(ExecutorService executor)</li>
                ExecutorService에 정의된 메서드들은 executor에 연결하고, 그 외 캐스트를 통해 이용할 수 있는 메서드들은 호출하지 못하도록 한다.
            </ul>
        </details>
        <details>
            <summary>ScheduledExecutorService 관련</summary>
            <ul>
                <li>static ScheduledExecutorService newSingleThreadScheduledExecutor() + 오버로딩</li>
                <li>static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) + 오버로딩</li>
                <li>static ScheduledExecutorService unconfigurableScheduledExecutorService(ScheduledExecutorService executor)</li>
                ScheduledExecutorService에 정의된 메서드들은 executor에 연결하고, 그 외 캐스트를 통해 이용할 수 있는 메서드들은 호출하지 못하도록 한다.
            </ul>
        </details>
        <details>
            <summary>ThreadFactory 관련</summary>
            <ul>
                <li>static ThreadFactory defaultThreadFactory()</li>
                모든 스레드들을 같은 ThreadGroup으로 생성한다. 스레드의 우선순위는 Threa.NORM_PRIORITY와 그룹의 최대 허용치 중 작은 것으로 설정된다.<br>
                각 스레드들은 non-daemon으로 생성되며, Thread.getName()을 통해 얻을 수 있는 "pool-N-thread-M" 꼴의 이름으로 접근할 수 있다.
                <li>static ThreadFactory privilegedThreadFactory()</li>
                호출하는 스레드와 같은 권한으로 새로운 스레드를 생성하는 ThreadFactory 반환.
            </ul>
        </details>
        <details>
            <summary>Callable 관련</summary>
            <ul>
                <li>static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result)</li>
                <li>static Callable&lt;Object&gt; callable(Runnable task)</li>
                작업이 완료되면 null을 반환하는 Callable 반환
                <li>static Callable&lt;Object&gt; callable(PrivilegedAction&lt;?&gt; action)</li>
                호출되면 action::run을 실행하고 그 결과를 반환하는 Callable 반환
                <li>static Callable&lt;Object&gt; callable(PrivilegedExceptionAction&lt;?&gt; action)</li>
                <li>static &lt;T&gt; Callable&lt;T&gt; privilegedCallable(Callable&lt;T&gt; callable)</li>
                호출되면 callable을 현재 access control context에서 실행. AccessController.doPrivileged에서 호출되어야 한다.
                <li>static &lt;T&gt; Callable&lt;T&gt; privilegedCallableUsingCurrentClassLoader(Callable&lt;T&gt; callable)</li>
            </ul>
        </details>
    </details>
</details>

<hr>

<details>
    <summary>리액티브 스트림</summary>
    <ol>
        <li>https://github.com/reactive-streams/reactive-streams-jvm</li>
        <li>final class Flow Since 9</li>
        static int defaultBufferSize() : 256
        <li>@FunctionalInterface static interface Flow.Publisher&lt;T&gt;</li>
        void subscribe(Flow.Subscriber&lt;? super T&gt; subscriber)
        <details>
            <summary>규칙</summary>
            <ol>
                <li>Publisher가 Subscriber에 onNext로 신호를 보낸 횟수 &lt;= Subscriber가 Subscription으로 보낸 request의 횟수</li>
                이 규칙은 onNext의 호출에 대하여, 선행되는 request가 항상 존재함을 함의한다
                <li>Publisher가 onNext로 신호를 보낸 횟수가 request보다 적은 경우, Subscription을 onComplete 또는 onError로 종결한다</li>
                이 규칙은 request에 대한 onNext가 항상 존재하지는 않음을 명시한다
                <li>onSubscribe, onNext, onError, onComplete 신호는 직렬적이어야 한다</li>
                결코 다른 신호와 중첩되는 시점이 있어서는 안 된다
                <li>Publisher의 실패는 반드시 onError로 보내야 한다</li>
                <li>스트림이 정상적으로 종결된 경우 Publisher는 반드시 onComplete 신호를 보내야 한다</li>
                <li>Publisher가 onError, onComplete 신호를 보낸 경우, Subscription은 반드시 취소된 것으로 간주되야 한다</li>
                <li>종료 상태(onError, onCompletion)에서 추가적인 신호의 발생은 절대 없다</li>
                <li>Subscription이 취소된 경우, 추가적인 신호 전달은 절대 없다</li>
                <li>Publisher.subscribe 안에서 onSubscribe를 반드시 호출해야 하며, 반드시 다른 신호를 보내기 전에 선행되어야 한다. 또, 이 경우 메서드는 반드시 정상 종결되어야 한다</li>
                Subscriber.onSubscribe 호출 시 null 검사는 필요없다. NullPointerException이 발생하게 내버려두면 된다.
                <li>Publisher.subscribe는 여러 번 호출될 수 있지만, 하나의 Subscriber로부터는 최대 한 번만 호출되어야 한다</li>
                <li>Publisher는 여러 Subscriber들에 대한 멀티캐스트를 지원할 수 있다</li>
            </ol>
        </details>
        <li>static interface Flow.Subsbriber&lt;T&gt;</li>
        void onSubscribe(Flow.Subscription), onNext(T), onError(Throwable), onComplete(Void)
        <details>
            <summary>규칙</summary>
            <ol>
                <li>Subscriber는 onNext 신호를 받고 싶다면 반드시 먼저 request 신호를 보내야 한다</li>
                <li>신호를 보낼 때, Publisher의 완료를 기다리지 말고 비동기적으로 전달함이 권장된다</li>
                <li>onComplete, onError 메서드는 절대 Subscription, Publisher 어느쪽의 메서드도 호출해선 안 된다</li>
                <li>onComplete, onError 신호를 받은 이후부터, Subscription은 반드시 취소로 간주되어야 한다</li>
                <li>유효한 Subscription이 존재한다면, 추가적인 onSubscribe 신호에 대해 반드시 cancel을 호출해야 한다</li>
                하나의 Subscriber는 둘 이상의 Publisher를 동시에 구독하지 않아야 한다
                <li>더 이상 필요없다면 반드시 Subscription.cancel을 호출해야 한다</li>
                <li>Subscription으로 보내는 신호들은 반드시 직렬적이어야 한다</li>
                결코 동시에 두 신호를 보내는 순간은 없어야 한다
                <li>cancel의 호출은 대기 중인 작업의 취소를 보장하지 않는다. cancel 이후 추가적인 onNext 신호에 대해 준비되어야 한다</li>
                <li>아무런 request를 보내지 않았더라도, onComplete, onError 신호에 대해 준비되어야 한다</li>
                <li>onSubscribe, onNext, onError, onComplete는 인자가 null이 아닌 이상 반드시 정상 종료되어야 한다</li>
                Subscriber의 실패는 Subscription.cancel로만 통지할 수 있다. 이 규칙이 지켜지지 않은 경우, Subscription은 반드시 취소로 간주되어야 한다
            </ol>
        </details>
        <li>static interface Flow.Subscription</li>
        void request(long) , cancel(Void)
        <details>
            <summary>규칙</summary>
            <ol>
                <li>request, cancel은 반드시 Subscriber가 호출해야 한다</li>
                <li>onNext, onSubscribe 안에서 동기적으로 request를 호출하는 것은 허용된다</li>
                <li>cancel의 호출은 멱등이어야 하고, 그 실행은 스레드-안전해야 한다</li>
                <li>Subscription이 취소됐다면, 이후의 request, cancel의 호출은 아무 작업도 하지 않아야 한다</li>
                <li>0이하에 대한 request 호출은 onError로 IllegalArgumentException을 보내야 한다</li>
                <li>Subscription이 취소됐다면, Publisher는 Subscriber에 대한 모든 참조를 제거해야 한다</li>
                <li>request, cancel은 항상 정상 종료되어야 한다</li>
                <li>Subscription은 반드시 무제한적인 request 호출을 허용해야 한다. n == Long.MAX_VALUE</li>
            </ol>
        </details>
        <li>static interface Flow.Processor&lt;T, R&gt; extends Flow.Subscriber&lt;T&gt;, Flow.Publisher&lt;R&gt;</li>
    </ol>
    <details>
        <summary>class SubmissionPublisher&lt;T&gt; implements Flow.Publisher&lt;T&gt;, AutoCloseable Since 9</summary>
        <details>
            <summary>Constructor Detail</summary>
            <ol>
                <li>public SubmissionPublisher(Executor executor, int maxBufferCapacity, BiConsumer&lt;? super Flow.Subscriber&lt;? super T&gt;, ? super Throwable&gt; handler) + 오버로딩</li>
                executor : 비동기적으로 구독자에게 전달하는 데 쓰일 Executor<br>
                maxBufferCapacity : 각 구독자에 대한 버퍼의 한도. 실제 한도는 getMaxBufferCapacity()로 확인<br>
                handler : null이 아니면 onNext에서 발생한 예외를 처리
                <li>public SubmissionPublisher()</li>
                executor = ForkJoinPool.commonPool(), maxBufferCapacity = Flow.defaultBufferSize(), handler = null
            </ol>
        </details>
        <details>
            <summary>Method Detail</summary>
            <ol>
                <li>int submit(T item)</li>
                각 구독자에게 비동기적으로 item을 보낸다(onNext). lag(배포된 item 중에 아직 소비되지 않은 개수) 추정치를 반환한다.
                <li>int offer(T item, BiPredicate&lt;Flow.Subscriber&lt;? super T&gt;, ? super T&gt; onDrop) + 오버로딩</li>
                가능하다면 각 구독자에게 비동기적으로 item을 보낸다(onNext). 리소스 초과(버퍼가 가득 찼다던지)로 실패한 경우 onDrop이 실행된다. onDrop이 true를 반환하면 onNext를 다시 시도한다.<br>
                반환값이 음수인 경우 drop된 구독자 수를 의미하고, 그 외의 경우 lag(배포된 item 중에 아직 소비되지 않은 개수) 추정치를 의미한다
                <li>void closeExceptionally(Throwable error) + getClosedException</li>
                <li>boolean isClosed()</li>
                <li>boolean hasSubscribers()</li>
                + getNumberOfSubscribers(), getExecutor(), getMaxBufferCapacity(), getSubscribers(), isSubscribed(Flow.Subscriber&lt;? super T&gt; subscriber)
                <li>long estimateMinimumDemand()</li>
                각 구독자들이 요청한 아이템 수 중, 아직 공급되지 않은 수의 최소값(추정치) 반환
                <li>int estimateMaximumLag()</li>
                각 구독자들에 보낸 아이템 중 아직 소비되지 않은 수의 최대값(추정치) 반환
                <li>CompletableFuture&lt;Void&gt; consume(Consumer&lt;? super T&gt; consumer)</li>
                배포된 모든 아이템에 대해 consumer 실행. 정상적으로 모두 실행되면 onComplete가 호출되고, CompletableFuture도 정상 종료된다
            </ol>
        </details>
    </details>
</details>

<hr>

<details>
    <summary>Blocking 컬렉션</summary>
    <details>
        <summary>interface BlockingQueue&lt;E&gt; extends Queue&lt;E&gt; Since 1.5</summary>
        <ol>
            <li>기본적으로 스레드-안전하지만, addAll 따위의 bulk 연산은 특별히 표시되지 않는 한 그렇지 않다.</li>
            <li>요소를 획득할 때, 큐가 비어있는 경우 블로킹. 요소를 추가할 때, 큐에 빈 자리가 있을 때까지 블로킹</li>
            <table>
                <tbody>
                    <tr><th></th><th>예외 발생</th><th>특별값 반환</th><th>블로킹</th><th>시간 제한</th></tr>
                    <tr><th>Insert</th><td>add(E)</td><td>offer(E)</td><td>put(E)</td><td>offer(E,long,TimeUnit)</td></tr>
                    <tr><th>Remove</th><td>remove()</td><td>poll()</td><td>take()</td><td>poll(long,TimeUnit)</td></tr>
                    <tr><th>Examine</th><td>element()</td><td>peek()</td><td>-</td><td>-</td></tr>
                </tbody>
            </table>
            <li>int remainingCapacity()</li>
            블로킹없이 삽입 가능한 요소의 수. 오차가 있을 수 있다
            <li>int drainTo(Collection&lt;? super E&gt; c) + 오버로딩</li>
            모든 원소를 c로 옮긴다
        </ol>
    </details>
    <details>
        <summary>class ArrayBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements BlockingQueue&lt;E&gt;, Serializable Since 1.5</summary>
        <ol>
            <li>크기가 고정된 기저 배열을 이용한 BlockingQueue</li>
            <li>기본적으로 삽입을 기다리는 스레드들 사이의 처리 순서는 보장되지 않지만, fairness를 설정하면 FIFO 순으로 처리된다</li>
            <li>Collection, Iterator의 모든 선택적 연산을 구현했다.</li>
            <li>public ArrayBlockingQueue(int capacity, boolean fair) + 오버로딩</li>
        </ol>
    </details>
    <details>
        <summary>class LinkedBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements BlockingQueue&lt;E&gt;, Serializable Since 1.5</summary>
        <ol>
            <li>크기를 고정할 수 있는 연결된 BlockingQueue</li>
            <li>Collection, Iterator의 모든 선택적 연산을 구현했다</li>
            <li>public LinkedBlockingQueue(int capacity) + 오버로딩</li>
            지정하지 않은 경우, 기본 크기는 Integer.MAX_VALUE
        </ol>
    </details>
    <details>
        <summary>class PriorityBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements BlockingQueue&lt;E&gt;, Serializable Since 1.5</summary>
        <ol>
            <li>크기 제한 없고, PriorityQueue와 비슷한 정렬을 이용한 BlockingQueue</li>
            <li>Collection, Iterator의 모든 선택적 연산을 구현했다</li>
            다만 iterator(), spliterator()로 제공되는 인스턴스들은 순회하는 순서를 보장하지 않는다. 순차적인 순회를 원한다면 Arrays.sort(queue.toArray())를 고려할 것
            <li>같은 우선순위의 원소 사이의 정렬은 정의되지 않았다</li>
            <li>public PriorityBlockingQueue(int initialCapacity, Comparator&lt;? super E&gt; comperator) + 오버로딩</li>
            initialCapacity는 지정되지 않은 경우 11, comperator는 지정되지 않은 경우 자연스러운 정렬을 이용
            <li>Comparator&lt;? super E&gt; comparator()</li>
        </ol>
    </details>
    <details>
        <summary>class SynchronousQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements BlockingQueue&lt;E&gt;, Serializable Since 1.5</summary>
        <ol>
            <li>서로 연관된 삽입 연산과 삭제 연산 한 쌍이 동시에 존재할 때까지 연산을 블로킹한다</li>
            <li>Collection, Iterator의 모든 선택적 연산을 구현했지만, 빈 컬렉션처럼 동작한다</li>
            <li>public SynchronousQueue(boolean fair) + 오버로딩</li>
            fair : 대기하는 스레드들이 순서대로 처리된다. 지정되지 않으면 false
        </ol>
    </details>
    <details>
        <summary>class DelayQueue&lt;E extends Delayed&gt; extends AbstractQueue&lt;E&gt; implements BlockingQueue&lt;E&gt; Since 1.5</summary>
        <ol>
            <li>Delayed 요소들로 구성된, 크기 제한없는 BlockingQueue. 요소의 지연 시간이 만료되어야 큐로부터 획득 가능하다</li>
            요소가 만료됐음은 getDelay(TimeUnit.NANOSECONDS) 리턴값이 0 이하일 때로 판정
            <li>Collection, Iterator의 모든 선택적 연산을 구현했다</li>
            <li>public DelayQueue() + 오버로딩</li>
        </ol>
    </details>
    <details>
        <summary>interface BlockingDeque&lt;E&gt; extends BlockingQueue&lt;E&gt;, Deque&lt;E&gt; Since 1.6</summary>
        요소를 획득할 때, 덱이 비어있는 경우 블로킹. 요소를 추가할 때, 덱에 빈 자리가 있을 때까지 블로킹
        <table>
            <tbody>
                <tr><th></th><th>예외 발생</th><th>특별값 반환</th><th>블로킹</th><th>시간 제한</th></tr>
                <tr><th>Insert</th><td>addFirst(E)<br>addLast(E)</td><td>offerFirst(E)<br>offerLast(E)</td><td>putFirst(E)<br>putLast(E)</td><td>offerFirst(E,long,TimeUnit)<br>offerLast(E,long,TimeUnit)</td></tr>
                <tr><th>Remove</th><td>removeFirst()<br>removeLast()</td><td>pollFirst()<br>pollLast()</td><td>takeFirst()<br>takeLast()</td><td>pollFirst(long,TimeUnit)<br>pollLast(long,TimeUnit)</td></tr>
                <tr><th>Examine</th><td>getFirst()<br>getLast()</td><td>peekFirst()<br>peekLast()</td><td>-</td><td>-</td></tr>
            </tbody>
        </table>
    </details>
    <details>
        <summary>class LinkedBlockingDeque&lt;E&gt; extends AbstractQueue&lt;E&gt; implements BlockingDeque&lt;E&gt;, Serializable Since 1.6</summary>
        <ol>
            <li>크기를 제한할 수 있는 BlockingDeque.</li>
            <li>Collection, Iterator의 모든 선택적 연산을 구현했다</li>
            <li>public LinkedBlockingDeque(int capacity) + 오버로딩</li>
            지정하지 않은 경우 Integer.MAX_VALUE가 사용된다
        </ol>
    </details>
    <details>
        <summary>interface TransferQueue&lt;E&gt; extends BlockingQueue&lt;E&gt; Since 1.7</summary>
        <ol>
            <li>생산자가 소비자가 소비할 때까지 대기할 수 있는 BlockingQueue.</li>
            기존의 BlockingQueue와 SynchronousQueue 기능 모두를 선택적으로 이용할 수 있다
            <li>void transfer(E e)</li>
            소비자에게 e를 전달한다. 소비자가 소비할 때까지 대기한다
            <li>boolean tryTransfer(E e)</li>
            대기 중인 소비자에게 e를 전달한다. 대기 중인 소비자가 없다면 즉시 false를 반환한다
            <li>boolean tryTransfer(E e, long timeout, TimeUnit unit)</li>
            timeout이 지나도록 대기 중인 소비자가 없다면 false를 반환한다
            <li>boolean hasWaitingConsumer()</li>
            <li>int getWaitingConsumerCount()</li>
        </ol>
    </details>
    <details>
        <summary>class LinkedTransferQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements TransferQueue&lt;E&gt;, Serializable Since 1.7</summary>
        <ol>
            <li>크기 제한없고 연결된 TransferQueue.</li>
            <li>size 계산에 순회가 필요하므로 정확하지 않을 수 있다</li>
            <li>addAll 따위의 bulk 연산은 원자적으로 실행되지 않을 수 있다</li>
            <li>Collection, Iterator의 모든 선택적 연산을 구현했다</li>
            <li>public LinkedTransferQueue() + 오버로딩</li>
        </ol>
    </details>
</details>

<hr>

<details>
    <summary>Non-Blocking 컬렉션</summary>
    <details>
        <summary>class CopyOnWriteArrayList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, Serializable Since 1.5</summary>
        <ol>
            <li>스레드-안전한 ArrayList</li>
            <li>add, set 등의 연산마다 새로운 배열을 만든다. 따라서 일반적인 용도로는 매우 나쁘다</li>
            <li>iterator는 생성된 시점의 snapshot을 순회함이 보장되지만, iterator를 통한 요소의 변경은 불가하다</li>
            <li>public CopyOnWriteArrayList() + 오버로딩</li>
            <li>int indexOf(E e, int index) + lastIndexOf</li>
            <li>boolean addIfAbsent(E e) + addAllAbsent</li>
        </ol>
    </details>
    <details>
        <summary>class CopyOnWriteArraySet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Serializable Since 1.5</summary>
        모든 연산에 CopyOnWriteArrayList를 사용하는 Set
    </details>
    <details>
        <summary>class ConcurrentLinkedQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements Queue&lt;E&gt;, Serializable Since 1.5</summary>
        <ol>
            <li>크기 제한 없고, 스레드-안전한 연결된 Queue</li>
            <li>size 계산에 순회가 필요하므로, 오차가 있을 수 있다</li>
            <li>addAll 따위의 bulk 연산은 원자적으로 실행되지 않을 수 있다</li>
            <li>Collection, Iterator의 모든 선택적 연산을 구현했다.</li>
        </ol>
    </details>
    <details>
        <summary>class ConcurrentlinkedDeque&lt;E&gt; extends AbstractCollection&lt;E&gt; implements Deque&lt;E&gt;, Serializable Since 1.7</summary>
        <ol>
            <li>크기 제한 없고, 스레드-안전한 연결된 Deque</li>
            <li>size 계산에 순회가 필요하므로, 오차가 있을 수 있다</li>
            <li>addAll 따위의 bulk 연산은 원자적으로 실행되지 않을 수 있다</li>
            <li>Collection, Iterator의 모든 선택적 연산을 구현했다.</li>
        </ol>
    </details>
    <details>
        <summary>interface ConcurrentMap&lt;K, V&gt; extends Map&lt;K, V&gt; Since 1.5</summary>
        <ol>
            <li>스레드-안전, 작업의 원자성 보장</li>
            Map의 각 연산, Map이 반환하는 컬렉션들의 연산 모두 재정의해야 한다
        </ol>
    </details>
    <details>
        <summary>interface ConcurrentNavigableMap&lt;K, V&gt; extends ConcurrentMap&lt;K, V&gt;, NavigableMap&lt;K, V&gt; Since 1.6</summary>
        NavigableMap 연산을 지원하는 ConcurrentMap
    </details>
    <details>
        <summary>class ConcurrentHashMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; implements ConcurrentMap&lt;K, V&gt;, Serializable Since 1.5</summary>
        <ol>
            <li></li>
        </ol>
    </details>
    
        ConcurrentHashMap.KeySetView
        ConcurrentSkipListMap
        ConcurrentSkipListSet
        
        
        
        
        
</details>

<hr>

<details>
    <summary>class Semaphore implements Serializable Since 1.5</summary>
    <ol>
        <li>제한된 수의 접근 권한을 acquire()로 획득, release()로 반환.</li>
        fairness : acquire()호출 순서대로 권한 획득.
        
        <li>public Semaphore(int permits) : nonfair</li>
        <li>public Semaphore(int permits, boolean fair)</li>
        
        <li>void acquire()</li>
        <li>void acquireUninterruptibly()</li>
        <li>boolean tryAcquire()</li>
        <li>boolean tryAcquire(long timeout, TimeUnit unit)</li>
        <li>void release()</li>
        <li>void acquire(int permits)</li>
        <li>void acquireUninterruptibly(int permits)</li>
        <li>boolean tryAcquire(int permits)</li>
        <li>boolean tryAcquire(int permits, long timeout, TimeUnit unit)</li>
        <li>void release(int permits)</li>
        <li>int availablePermits()</li>
        <li>int drainPermits() : 가용한 모든 권한을 얻는다. 만약 음수라면 release하여 0으로 맞춘다.</li>
        <li>boolean isFair()</li>
        <li>final int getQueueLength()</li>
        <li>protected Collection&lt;Thread&gt; getQueuedThreads()</li>
        <li>protected void reducePermits(int recudtion)</li>
    </ol>
</details>

<hr>

<details>
    <summary>class CountDownLatch Since 1.5</summary>
    <ol>
        <li>count가 0일 될때까지 대기.</li>
        
        <li>public CountDownLatch(int count)</li>
        
        <li>void await()</li>
        <li>boolean await(long timeout, TimeUnit unit)</li>
        <li>void countDown()</li>
        <li>long getCount()</li>
    </ol>
</details>

<hr>

<details>
    <summary>class CyclicBarrier Since 1.5</summary>
    <ol>
        <li>스레드들이 공통의 목적이 달성되기까지 함께 대기. 이를 barrier라고 하며, barrier가 재사용될 수 있어 cyclic하다.</li>
        
        <li>public CyclicBarrier(int parties, Runnable barrierAction)</li>
        barrierAction : barrier를 넘을 때 실행.
        <li>public CyclicBarrier(int parties)</li>
        
        <li>int getParties()</li>
        <li>int await()</li>
        반환값 : 현재 스레드의 대기 순번. getParties() - 1이 첫 번째, 0이 마지막 스레드.
        <li>int await(long timeout, TimeUnit unit)</li>
        <li>boolean isBroken()</li>
        <li>void reset()</li>
        <li>int getNumberWaiting()</li>
    </ol>
</details>

<hr>

<details>
    <summary>class Exchanger&lt;V&gt; Since 1.5</summary>
    <ol>
        <li>두 스레드가 같은 시점에 값을 서로 교환하도록 해준다.</li>
        
        <li>public Exchanger()</li>
        
        <li>V exchange(V x) throws InterruptedException</li>
        다른 스레드가 같은 지점에 도달하기까지 기다렸다가, 서로 값을 교환한다.
        
        <li>V exchange(V x, long timeout, TimeUnit unit) throws InterruptedException, TimeoutException</li>
        timeout : 최대 대기 시간.
    </ol>
</details>

<hr>

Semaphore
CountDownLatch
CyclicBarrier
Exchanger
Phaser

ThreadLocalRandom



<details>
    <summary>enum TimeUnit Since 1.5</summary>
    <ol>
        <li>NANOSECONDS, MICROSECONDS, MILLISECONDS, SECONDS, MINUTES Since 1.6, HOURS Since 1.6, DAYS Since 1.6</li>
        <li>long convert(long sourceDuration, TimeUnit sourceUnit)</li>
        <li>long toNanos(long duration) == NANOSECONDS.convert(duration, this)</li>
        + toMicros, toMillis, toSeconds, toMinutes, toHours, toDays</li>
        
        <li>void timeWait(Object obj, long timeout)</li>
        timeout만큼 obj.wait()
        <li>void timedJoin(Thread thread, long timeout)</li>
        timeout만큼 Thread.join()
        
        <li>void sleep(long timeout)</li>
        <li>ChronoUnit toChronoUnit() Since 9</li>
        <li>static TimeUnit of(ChronoUnit chronoUnit) Since 9</li>
    </ol>
</details>

<hr>