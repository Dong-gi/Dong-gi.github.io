<script src="/source/redirect.js?200226_1657"></script>
<hr>

<details>
    <summary>NPM</summary>
    <ol>
        <li>npm 패키지 버전 : Major.Minor.Patch</li>
        <li>Major : 이전 버전과 호환되지 않으면 변경</li>
        <li>Minor : 이전 버전과 호환되면서 신규 기능 추가</li>
        <li>Patch : 이전 버전과 호환되면서 버그 수정</li>
        <li>^1.2.2 : [1.2.2, 2.0.0) 호환</li>
        0이 아닌 최초 버전의 하위 버전 변경 모두를 포함
        <li>~1.2.2 : [1.2.2, 1.3) 호환</li>
        지정된 버전의 상위 버전 변경 전까지 모두를 포함
        <li>1.2.2-1.4.4 : 직접 지정</li>
        <li>1.2.x : 와일드카드</li>
    </ol>
</details>

<hr>

<details>
    <summary>TypeScript</summary>
    <ol>
        <li>JavaScript에 타입이 추가된 수퍼셋. 컴파일하면 자바스크립트 코드가 된다</li>
        <li>npm install -g typescript</li>
        <li>tsc file-name.ts --target es6</li>
        <li>타입스크립트에서는 생성자 매개변수 앞에 public/private 접근한정자가 있으면 자동으로 클래스의 속성으로 선언한다</li>
        <li>VS Code의 타입스크립트 컴파일러를 npm 패키지로 설정</li>
        "typescript.tsdk": "C:/Users/name/AppData/Roaming/npm/node_modules/typescript/bin/tsc"
    </ol>
</details>

<hr>

<details>
    <summary>Lib/Console</summary>
    <ul>
        <li>console.log(any data[, any ...args]) + info, debug, warn, error</li>
        util.format(format[, ...args]) 형태의 호출 가능
        <li>console.table(any tabularData[, string[] properties]) Since 10</li>
        <li>console.time([string label]) + timeEnd</li>
        label(기본값 'default')로 타이머 시작/종료
        <li>console.timeLog([string label][, any ...data]) Since 10.7</li>
        label(기본값 'default')의 타이머를 중지하지 않고, 경과 시간과 data 출력
        <li>console.trace([any message][, any ...args])</li>
        스택 출력
        <li>new console.Console(stream.Writable stdout[, stream.Writable stderr][, boolean ignoreErrors])</li>
        <li>console.assert(any value[, any ...message])</li>
        value가 false면 console.error(...message)
        <li>console.count([string label]) Since 8.3 + countReset</li>
        label(기본값 'default')로 몇 번 호출했는지 출력한다
        <li>console.dir(any obj[, Object options])</li>
        <ul>
            <li>boolean options.showHidden : 기본값 false</li>
            <li>number options.depth : 기본값 2. null이면 끝까지 재귀</li>
        </ul>
        <li>console.group([any ...label]) + groupEnd</li>
        console.log(...label)실행 후, 다음 출력부터는 앞에 공백 2개 추가
    </ul>
</details>

<hr>

<details>
    <summary>Lib/Events</summary>
    <ul>
        <li>class EventEmitter</li>
        <ul>
            <li>이벤트 발행 주체</li>
            기본적으로 이벤트 구독/해지에 대해 자동으로 'newListener', 'removeListener' 이벤트 발행
            <li>events 모듈의 exports 자체가 EventEmitter 클래스다</li>
            const EventEmitter = require('events')<br>
            class My extends EventEmitter {}
            <li>EventEmitter.defaultMaxListeners</li>
            기본값 10
            <li>emitter.on(string|symbol eventName, Function listener) == addListener ↔ off, + removeListener, prependListener, removeAllListeners</li>
            이벤트 핸들러 등록(구독)
            <li>emitter.once(string|symbol eventName, Function listener) + prependOnceListener</li>
            이벤트 1회 구독
            <li>emitter.emit(string|symbol eventName[, any ...args])</li>
            <ol>
                <li>이벤트 발행.</li>
                구독자가 있으면 true, 없으면 false 반환
                <li>이벤트 핸들러는 동기적으로 실행되며, 반환값은 무시된다.</li>
                <li>핸들러 내에서 this 키워드는 이벤트를 발행한 EventEmitter 인스턴스를 가리킨다.</li>
                단, 람다 함수에서는 this 키워드가 EventEmitter 인스턴스를 가리키지 않는다.
            </ol>
            <li>emitter.eventNames()</li>
            사용자가 구독 요청한 이벤트 이름들을 배열로 반환
            <li>emitter.getMaxListeners() + setMaxListeners</li>
            <li>emitter.listeners(string|symbol eventName) + listenerCount, rawListeners Since 9.4</li>
            <li>error 이벤트</li>
            'error' 이벤트 구독자가 없는 경우, EventEmitter 내의 예외는 밖으로 던져지고 프로세스는 종료된다.
            <li>newListener, removeListener 이벤트</li>
            핸들러 : (string|symbol eventName, Function listener)
        </ul>
        <li>events.once(EventEmitter emitter, string name) : Promise Since 11.13</li>
        name 이벤트 발행 또는 'error' 이벤트 발행시 emit()의 args 그대로 Promise가 실행된다.
        <li>events.on(EventEmitter emitter, string|symbol eventName) : AsyncIterator</li>
        <ul>
            <li>eventName 이벤트 발행 시 emit()의 args를 배열로 받는다.</li>
        </ul>
        const { on, EventEmitter } = require('events');<br>
        (async () =&gt; { //... <br>
        &nbsp;&nbsp;&nbsp;&nbsp;for await (const event of on(emitter, 'foo')) {}<br>
        })
    </ul>
</details>

<hr>

<details>
    <summary>Lib/Globals</summary>
    <ul>
        <li>this == global</li>
        <li>TextDecoder Since 11 == util.TextDecoder</li>
        <li>TextEncoder Since 11 == util.TextEncoder</li>
        <li>URL == url.URL</li>
        <li>URLSearchParams Since 10 == url.URLSearchParams</li>
        <li>WebAssembly Since 8</li>
        아직 개발중인 웹 어셈블리와의 호환을 위한 네임스페이스
        
        <li>class Buffer</li>
        <li>__filename, __dirname : 실행 중인 소스 파일 정보. REPL 모드에서는 당연히 없다</li>
        <li>console : 콘솔 관련</li>
        <li>exports, module, require() : 모듈 관련</li>
        <li>process : 프로세스 관련</li>
        <li>setTimeout, clearTimeout, setInterval, clearInterval, setImmediate, clearImmediate : timer 관련</li>
        <li>queueMicrotask(Function callback) Since 11</li>
        "microtask queue"는 V8 엔진이 관리하며, 동작은 process.nextTick()과 유사하다. 이벤트 루프 어느 페이즈에서든지 "next tick queue"가 항상 "microtask queue"보다 먼저 실행된다. 
    </ul>
</details>

<hr>

<details>
    <summary>Lib/Modules</summary>
    <ol>
        <li>require(string id)</li>
        <ul>
            <li>각 파일들은 별개의 모듈로 취급된다</li>
            require('./foo/bar.js');
            <li>로드된 모듈은 캐시되므로, 반복적인 require()는 같은 객체를 반환한다</li>
            require()가 두 개 이상의 파일을 찾은 경우, 요구한 이름의 대소문자를 바꾼 경우 등은 예외
            <li>모듈이 Node에 의해 직접 실행되는 경우, require.main으로 설정된다</li>
            따라서 require.main === module로 현재 모듈이 메인인지 판별 가능하다
            <li>모듈 사이에 require() 사이클이 존재하는 경우, 초기화 완료되지 않은 exports 객체를 반환하여 무한 반복을 방지한다</li>
            <li>모듈을 /usr/lib/node_modules/{name}/{version} 경로로 관리하면 효율적인 require() 가능</li>
            <li>require <a class="w3-btn w3-round w3-round-xxlarge w3-small w3-green" target="_blank" href="https://nodejs.org/dist/latest-v12.x/docs/api/modules.html#modules_all_together">알고리즘</a></li>
            확장자 없는 파일 X, X.js 파일, X.json 파일, X.node 파일, X/index.js 디렉터리, X/package.json 디렉터리 등을 적절히 처리
            <li>선두 '/', './', '../' 없이 요구된 모듈</li>
            <ol>
                <li>core 모듈이면 해당 모듈 로드</li>
                <li>ROOT 디렉터리에 도달할 때까지, {부모 디렉터리}/node_modules/{X} 모듈을 탐색</li>
            </ol>
            <li>아무데서도 모듈을 찾지 못한 경우, $NODE_PATH 환경변수의 디렉터리를 탐색하지만, $NODE_PATH 사용은 권장되지 않는다</li>
        </ul>
        <li>디렉터리를 모듈로</li>
        <ol>
            <li>package.json</li>
            { "name" : "some-library", "main" : "./lib/some-library.js" }
            <li>index.js</li>
        </ol>
        <li>로드된 모듈의 실행은 아래와 유사하다</li>
        (function(exports, require, module, __filename, __dirname) {<br>
        // Module code actually lives in here<br>
        });
        <ol>
            <li>모듈 top-level에 정의된 변수들이 모듈 스코프에 존재</li>
            <li>모듈 밖에서는 exports를 공유</li>
            최초 exports는 module.exports를 가리키므로, exports에 다른 객체를 할당하는 경우, 해당 부분은 외부와 공유되지 않는다. 외부에 공유하려면 module.exports = exports = newObject
            <li>모듈 안에서는 __filename, __dirname을 편리하게 획득</li>
        </ol>
    </ol>
</details>

<hr>

<details>
    <summary>Lib/Process</summary>
    <ul>
        <li>Event 'beforeExit'</li>
        정상 종료 전, process.exitCode를 인자로 콜백이 호출된다. process.exit() 등으로 종료하는 경우 호출되지 않는다. 콜백에서 비동기 호출로 프로그램 종료를 지연시킬 수 있다.
        <li>Event 'exit'</li>
        정상 종료 및 process.exit() 호출 시 process.exitCode를 인자로 콜백이 호출된다. 콜백은 동기적 연산만 수행해야 한다.
        <li>Event 'multipleResolves' Since 10.12</li>
        <ul>
            <li>임의 Promise의 두 번째 resolve 또는 reject 호출부터 콜백이 호출된다</li>
            Promise.race() 호출처럼, 경우에 따라서 이 이벤트 발생이 에러가 아닐수도 있다.
            <li>콜백 : (string type, Promise promise, any value)</li>
        </ul>
        <li>process.abort()</li>
        강제 종료. Worker 스레드에서는 실행 불가.
        <li>process.chdir(directory)</li>
        실행 위치 변경
        <li>string[] process.argv</li>
        <li>Object process.env</li>
        <li>string process.execPath</li>
        <li>string[] process.execArgv</li>
        <li>process.nextTick(Function callback[, any ...args])</li>
        callback을 "next tick queue"에 추가한다. args는 callback의 인자가 된다. callback은 현재 페이즈에서 실행 중인 코드가 모두 완료된 후 즉시 실행되며, setImmediate()보다 빠르게 실행된다.
        <li>integer process.pid</li>
        <li>integer process.ppid Since 9.2, Since 8.10</li>
        부모 프로세스 PID
        <li>Stream process.stdin, stdout, stderr</li>
    </ul>
</details>

<hr>

<details>
    <summary>3rd/express : Web Framework</summary>
    <ul>
        <li>서버 시작</li>
        <pre>const express = require('express')
const app = express()
app.listen(3000, () => console.log(`Server Started`))</pre>
        <li>실행 환경</li>
        <ol>
            <li>환경 변수 이름 : NODE_ENV</li>
            <li>기본 : development</li>
            <li>릴리스 : production</li>
            <li>process.env.NODE_ENV로 획득 가능</li>
        </ol>
        <li>Method 라우팅</li>
        <ul>
            <li>path에는 regex 사용 가능</li>
            <li>app.get('/', (req, res) => {})</li>
            <li>app.post('/', (req, res) => {})</li>
            <li>app.put('/', (req, res) => {})</li>
            <li>app.delete('/', (req, res) => {})</li>
        </ul>
        <li>static 파일 전송</li>
        <ol>
            <li>static 디렉터리 파일들을 전송하는 미들웨어 사용</li>
            app.use(express.static(path.join(__dirname, 'static')));
            <li>요청 URL과 실제 디렉터리 경로를 다르게 하고 싶은 경우</li>
            app.use('/static', express.static(path.join(__dirname, 'ag3t9a23gt')));
        </ol>
        <li>Middleware : 요청 처리 체인의 앞부분에서 전처리를 하며, 다음으로 넘어갈지 결정</li>
        <pre>function (req, res, next) {
    // Do something
    next();
}
app.use(middleware);</pre>
    </ul>
</details>

<hr>

<details>
    <summary>3rd/forever : 종료 시 자동 재시작</summary>
    <ul>
        <li>스크립트 영구 실행</li>
        <li>forever 모듈을 코드에서 호출하는 경우, forever-monitor가 도움이 된다</li>
        <li>CLI 호출 : forever [action] [options] SCRIPT [script-options]</li>
        <ul>
            <li>forever start name.js</li>
            <li>forever start config.json</li>
            <pre>[
  { // App1
    "uid": "app1",
    "append": true,
    "watch": true,
    "script": "index.js",
    "sourceDir": "/home/myuser/app1"
  },
  { // App2
    "uid": "app2",
    "append": true,
    "watch": true,
    "script": "index.js",
    "sourceDir": "/home/myuser/app2",
    "args": ["--port", "8081"]
  }
]</pre>
        </ul>
    </ul>
</details>

<hr>