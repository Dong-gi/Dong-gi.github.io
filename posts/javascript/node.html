<script src="/source/redirect.js?200226_1657"></script>
<hr>

<details>
    <summary>NPM</summary>
    <details>
        <summary>버전 정의</summary>
        <ul>
            <li>npm 패키지 버전 : Major.Minor.Patch</li>
            <ol>
                <li>Major : 이전 버전과 호환되지 않으면 변경</li>
                <li>Minor : 이전 버전과 호환되면서 신규 기능 추가</li>
                <li>Patch : 이전 버전과 호환되면서 버그 수정</li>
            </ol>
            <li>^1.2.2 : [1.2.2, 2.0.0) 호환</li>
            0이 아닌 최초 버전의 하위 버전 변경 모두를 포함
            <li>~1.2.2 : [1.2.2, 1.3) 호환</li>
            지정된 버전의 상위 버전 변경 전까지 모두를 포함
            <li>1.2.2-1.4.4 : 직접 지정</li>
            &gt;=1.2.2 &lt;=1.4.4와 동일
            <li>1.2.x : 와일드카드</li>
        </ul>
    </details>
    
    <details>
        <summary>프로젝트 의존성 관리</summary>
        <ol>
            <li>npm init</li>
            package.json 생성
            
            <details>
                <summary>package.json</summary>
                아래 예시는 다른 패키지의 것들을 맘대로 섞은 것임
<pre>{
  "name": "mongodb",    // 대문자 사용 불가. URL 안전해야 함.
  "version": "3.5.4",
  "description": "The official MongoDB driver for Node.js",
  "author": {           // 1명만 가능. name은 필수
    "name": "TJ Holowaychuk",
    "email": "tj@vision-media.ca",
    "url": "http://1.1.1.1/"
  },
  "contributors": [
    "Aaron Heckmann &lt;aaron.heckmann+github@gmail.com&gt;",
    "Ciaran Jessup &lt;ciaranj@gmail.com&gt;"
  ],
  "keywords": [         // npm 검색 키워드
    "mongodb",
    "driver"
  ],
  "homepage": "https://github.com/mongodb/node-mongodb-native",
  "repository": {       // 버전 관리 저장소
    "type": "git",
    "url": "git@github.com:mongodb/node-mongodb-native.git"
  },
  "bugs": {             // url 또는 email 하나만 적용
    "url": "https://github.com/mongodb/node-mongodb-native/issues"
  },
  "license": "Apache-2.0",
  "main": "index.js",   // 메인 모듈 설정. require시 해당 모듈의 exports가 넘겨진다
  "files": [            // 패키지 포함 목록. ".npmignore" 파일로 제외 항목 관리 가능
    "index.js",
    "lib"
  ],
  "bin": {              // 패키지 설치 시 실행 파일에 대한 링크를 만들어 CLI 실행 가능하게 한다
    "forever": "./bin/forever.js"
  },
  "dependencies": {     // 의존 패키지
    "bl": "^2.2.0",
  },
  "peerDependencies": { // 의존 관계 X. 같이 사용될 수 있는 패키지
    "kerberos": "^1.1.0",
  },                    // 패키지 테스트, 문서화에 필요한 패키지; 모듈 사용만 하는 경우엔 불필요한 패키지
  "devDependencies": {
    "eslint": "2.13.1",
    "mocha": "7.0.1"
  },
  "scripts": {          // npm이 패키지 관리 시 실행할 명령. https://docs.npmjs.com/misc/scripts
    "lint": "eslint .",
    "test": "mocha --require test/support/env --reporter spec --bail --check-leaks test/ test/acceptance/"
  },
  "engines": {          // Node 버전 제한
    "node": "&gt;=10"
  }
}</pre>
            </details>
            
            <li>npm install</li>
            package.json대로 의존 라이브러리 설치
            
            <li>npm install name --save<br>
                npm install name --save-dev</li>
            name 패키지 설치 후 package.json에 의존성 추가
        </ol>
    </details>
</details>

<hr>

<details>
    <summary>TypeScript</summary>
    <ol>
        <li>JavaScript에 타입이 추가된 수퍼셋. 컴파일하면 자바스크립트 코드가 된다</li>
        <li>npm install -g typescript</li>
        <li>tsc file-name.ts --target es6</li>
        <li>타입스크립트에서는 생성자 매개변수 앞에 public/private 접근한정자가 있으면 자동으로 클래스의 속성으로 선언한다</li>
        <li>VS Code의 타입스크립트 컴파일러를 npm 패키지로 설정</li>
        "typescript.tsdk": "C:/Users/name/AppData/Roaming/npm/node_modules/typescript/bin/tsc"
    </ol>
</details>

<hr>

<details>
    <summary>디버깅</summary>
    <ul>
        <li>코드 사이에 중단점 삽입 : debugger;</li>
        <li>node 실행 시 디버깅 켜기 : node debug app.js</li>
        또는 node inspect app.js
        <li>자동으로 디버깅 포트를 열며, chrome://inspect 등으로도 이용 가능</li>
        <li>명령어</li>
        <ol>
            <li>n : 다음 문장; next</li>
            <li>c : 다음 중단점; continue</li>
            <li>s : step into</li>
            <li>o : step out</li>
            <li>watch(expr) : expr 평가 감시</li>
            <li>exec(expr) : expr 평가</li>
            <li>repl : 디버깅 REPL에서 직접 코드로 확인</li>
            <li>help</li>
            <li>.exit</li>
        </ol>
    </ul>
</details>

<hr>

<details>
    <summary>Lib/Console</summary>
    <ul>
        <li>console.log(any data[, any ...args]) + info, debug, warn, error</li>
        util.format(format[, ...args]) 형태의 호출 가능
        <li>console.table(any tabularData[, string[] properties]) Since 10</li>
        <li>console.time([string label]) + timeEnd</li>
        label(기본값 'default')로 타이머 시작/종료
        <li>console.timeLog([string label][, any ...data]) Since 10.7</li>
        label(기본값 'default')의 타이머를 중지하지 않고, 경과 시간과 data 출력
        <li>console.trace([any message][, any ...args])</li>
        스택 출력
        <li>new console.Console(stream.Writable stdout[, stream.Writable stderr][, boolean ignoreErrors])</li>
        <li>console.assert(any value[, any ...message])</li>
        value가 false면 console.error(...message)
        <li>console.count([string label]) Since 8.3 + countReset</li>
        label(기본값 'default')로 몇 번 호출했는지 출력한다
        <li>console.dir(any obj[, Object options])</li>
        <ul>
            <li>boolean options.showHidden : 기본값 false</li>
            <li>number options.depth : 기본값 2. null이면 끝까지 재귀</li>
        </ul>
        <li>console.group([any ...label]) + groupEnd</li>
        console.log(...label)실행 후, 다음 출력부터는 앞에 공백 2개 추가
    </ul>
</details>

<hr>

<details>
    <summary>Lib/Events</summary>
    <ul>
        <li>class EventEmitter</li>
        <ul>
            <li>이벤트 발행 주체</li>
            기본적으로 이벤트 구독/해지에 대해 자동으로 'newListener', 'removeListener' 이벤트 발행
            <li>events 모듈의 exports 자체가 EventEmitter 클래스다</li>
            const EventEmitter = require('events')<br>
            class My extends EventEmitter {}
            <li>EventEmitter.defaultMaxListeners</li>
            기본값 10
            <li>emitter.on(string|symbol eventName, Function listener) == addListener ↔ off, + removeListener, prependListener, removeAllListeners</li>
            이벤트 핸들러 등록(구독)
            <li>emitter.once(string|symbol eventName, Function listener) + prependOnceListener</li>
            이벤트 1회 구독
            <li>emitter.emit(string|symbol eventName[, any ...args])</li>
            <ol>
                <li>이벤트 발행.</li>
                구독자가 있으면 true, 없으면 false 반환
                <li>이벤트 핸들러는 동기적으로 실행되며, 반환값은 무시된다.</li>
                <li>핸들러 내에서 this 키워드는 이벤트를 발행한 EventEmitter 인스턴스를 가리킨다.</li>
                단, 람다 함수에서는 this 키워드가 EventEmitter 인스턴스를 가리키지 않는다.
            </ol>
            <li>emitter.eventNames()</li>
            사용자가 구독 요청한 이벤트 이름들을 배열로 반환
            <li>emitter.getMaxListeners() + setMaxListeners</li>
            <li>emitter.listeners(string|symbol eventName) + listenerCount, rawListeners Since 9.4</li>
            <li>error 이벤트</li>
            'error' 이벤트 구독자가 없는 경우, EventEmitter 내의 예외는 밖으로 던져지고 프로세스는 종료된다.
            <li>newListener, removeListener 이벤트</li>
            핸들러 : (string|symbol eventName, Function listener)
        </ul>
        <li>events.once(EventEmitter emitter, string name) : Promise Since 11.13</li>
        name 이벤트 발행 또는 'error' 이벤트 발행시 emit()의 args 그대로 Promise가 실행된다.
        <li>events.on(EventEmitter emitter, string|symbol eventName) : AsyncIterator</li>
        <ul>
            <li>eventName 이벤트 발행 시 emit()의 args를 배열로 받는다.</li>
        </ul>
        const { on, EventEmitter } = require('events');<br>
        (async () =&gt; { //... <br>
        &nbsp;&nbsp;&nbsp;&nbsp;for await (const event of on(emitter, 'foo')) {}<br>
        })
    </ul>
</details>

<hr>

<details>
    <summary>Lib/Globals</summary>
    <ul>
        <li>this == global</li>
        <li>TextDecoder Since 11 == util.TextDecoder</li>
        <li>TextEncoder Since 11 == util.TextEncoder</li>
        <li>URL == url.URL</li>
        <li>URLSearchParams Since 10 == url.URLSearchParams</li>
        <li>WebAssembly Since 8</li>
        아직 개발중인 웹 어셈블리와의 호환을 위한 네임스페이스
        
        <li>class Buffer</li>
        <li>__filename, __dirname : 실행 중인 소스 파일 정보. REPL 모드에서는 당연히 없다</li>
        <li>console : 콘솔 관련</li>
        <li>exports, module, require() : 모듈 관련</li>
        <li>process : 프로세스 관련</li>
        <li>setTimeout, clearTimeout, setInterval, clearInterval, setImmediate, clearImmediate : timer 관련</li>
        <li>queueMicrotask(Function callback) Since 11</li>
        "microtask queue"는 V8 엔진이 관리하며, 동작은 process.nextTick()과 유사하다. 이벤트 루프 어느 페이즈에서든지 "next tick queue"가 항상 "microtask queue"보다 먼저 실행된다. 
    </ul>
</details>

<hr>

<details>
    <summary>Lib/Modules</summary>
    <ol>
        <li>require(string id)</li>
        <ul>
            <li>각 파일들은 별개의 모듈로 취급된다</li>
            require('./foo/bar.js');
            <li>로드된 모듈은 캐시되므로, 반복적인 require()는 같은 객체를 반환한다</li>
            require()가 두 개 이상의 파일을 찾은 경우, 요구한 이름의 대소문자를 바꾼 경우 등은 예외
            <li>모듈이 Node에 의해 직접 실행되는 경우, require.main으로 설정된다</li>
            따라서 require.main === module로 현재 모듈이 메인인지 판별 가능하다
            <li>모듈 사이에 require() 사이클이 존재하는 경우, 초기화 완료되지 않은 exports 객체를 반환하여 무한 반복을 방지한다</li>
            <li>모듈을 /usr/lib/node_modules/{name}/{version} 경로로 관리하면 효율적인 require() 가능</li>
            <li>require <a class="w3-btn w3-round w3-round-xxlarge w3-small w3-green" target="_blank" href="https://nodejs.org/dist/latest-v12.x/docs/api/modules.html#modules_all_together">알고리즘</a></li>
            확장자 없는 파일 X, X.js 파일, X.json 파일, X.node 파일, X/index.js 디렉터리, X/package.json 디렉터리 등을 적절히 처리
            <li>선두 '/', './', '../' 없이 요구된 모듈</li>
            <ol>
                <li>core 모듈이면 해당 모듈 로드</li>
                <li>ROOT 디렉터리에 도달할 때까지, {부모 디렉터리}/node_modules/{X} 모듈을 탐색</li>
            </ol>
            <li>아무데서도 모듈을 찾지 못한 경우, $NODE_PATH 환경변수의 디렉터리를 탐색하지만, $NODE_PATH 사용은 권장되지 않는다</li>
        </ul>
        <li>디렉터리를 모듈로</li>
        <ol>
            <li>package.json</li>
            { "name" : "some-library", "main" : "./lib/some-library.js" }
            <li>index.js</li>
        </ol>
        <li>로드된 모듈의 실행은 아래와 유사하다</li>
        (function(exports, require, module, __filename, __dirname) {<br>
        // Module code actually lives in here<br>
        });
        <ol>
            <li>모듈 top-level에 정의된 변수들이 모듈 스코프에 존재</li>
            <li>모듈 밖에서는 exports를 공유</li>
            최초 exports는 module.exports를 가리키므로, exports에 다른 객체를 할당하는 경우, 해당 부분은 외부와 공유되지 않는다. 외부에 공유하려면 module.exports = exports = newObject
            <li>모듈 안에서는 __filename, __dirname을 편리하게 획득</li>
        </ol>
    </ol>
</details>

<hr>

<details>
    <summary>Lib/Process</summary>
    <ul>
        <li>Event 'beforeExit'</li>
        정상 종료 전, process.exitCode를 인자로 콜백이 호출된다. process.exit() 등으로 종료하는 경우 호출되지 않는다. 콜백에서 비동기 호출로 프로그램 종료를 지연시킬 수 있다.
        <li>Event 'exit'</li>
        정상 종료 및 process.exit() 호출 시 process.exitCode를 인자로 콜백이 호출된다. 콜백은 동기적 연산만 수행해야 한다.
        <li>Event 'multipleResolves' Since 10.12</li>
        <ul>
            <li>임의 Promise의 두 번째 resolve 또는 reject 호출부터 콜백이 호출된다</li>
            Promise.race() 호출처럼, 경우에 따라서 이 이벤트 발생이 에러가 아닐수도 있다.
            <li>콜백 : (string type, Promise promise, any value)</li>
        </ul>
        <li>process.abort()</li>
        강제 종료. Worker 스레드에서는 실행 불가.
        <li>process.chdir(directory)</li>
        실행 위치 변경
        <li>string[] process.argv</li>
        <li>Object process.env</li>
        <li>string process.execPath</li>
        <li>string[] process.execArgv</li>
        <li>process.nextTick(Function callback[, any ...args])</li>
        callback을 "next tick queue"에 추가한다. args는 callback의 인자가 된다. callback은 현재 페이즈에서 실행 중인 코드가 모두 완료된 후 즉시 실행되며, setImmediate()보다 빠르게 실행된다.
        <li>integer process.pid</li>
        <li>integer process.ppid Since 9.2, Since 8.10</li>
        부모 프로세스 PID
        <li>Stream process.stdin, stdout, stderr</li>
    </ul>
</details>

<hr>

<details>
    <summary>3rd/express : Web Framework</summary>
    <ul>
        <li>Quick start</li>
        <ol>
            아래 명령으로 프로젝트 골격을 빠르게 구성할 수 있다.
            <li>$ npx express-generator # Since 8.2</li>
            <li>$ npm install -g express-generator<br>
                $ express # Before 8.2</li>
        </ol>
        <li>서버 시작</li>
        <pre>const express = require('express')
const app = express()
app.listen(3000, () => console.log(`Server Started`))</pre>
        <li>실행 환경</li>
        <ol>
            <li>환경 변수 이름 : NODE_ENV</li>
            <li>기본 : development</li>
            <li>릴리스 : production</li>
            <li>process.env.NODE_ENV로 획득 가능</li>
        </ol>
        <li>서버 설정</li>
        <table class="no-sort">
            <tr><td>app.set(name, value)</td><td>예약된 키워드들이 있음에 유의</td></tr>
            <tr><td>app.set('port', process.env.PORT || 55555)</td><td>서버 포트</td></tr>
            <tr><td>app.set('views', path.join(__dirname, 'templates'))</td><td>템플릿 디렉터리</td></tr>
            <tr><td>app.set('view engine', 'jade')</td><td>템플릿 확장자</td></tr>
        </table>
        <li>Method 라우팅</li>
        <ul>
            <li>path에는 regex 사용 가능</li>
            <li>app.all('/', (req, res) => {})</li>
            <li>app.get('/', (req, res) => {})</li>
            <li>app.post('/', (req, res) => {})</li>
        </ul>
        <li>응답</li>
        res.render(view[, data][, callback])
        <li>Middleware : 요청 처리 체인의 앞부분에서 전처리를 하며, 다음으로 넘어갈지 결정</li>
        <pre>function (req, res, next) {
    // Do something
    next();
}
app.use(middleware);</pre>
        <li>static 파일 전송 미들웨어</li>
        <ol>
            <li>static 디렉터리 파일들을 전송하는 미들웨어 사용</li>
            app.use(express.static(path.join(__dirname, 'static')));
            <li>요청 URL과 실제 디렉터리 경로를 다르게 하고 싶은 경우</li>
            app.use('/static', express.static(path.join(__dirname, 'ag3t9a23gt')));
        </ol>
        
    </ul>
</details>

<hr>

<details>
    <summary>3rd/forever : 종료 시 자동 재시작</summary>
    <ul>
        <li>스크립트 영구 실행</li>
        <li>forever 모듈을 코드에서 호출하는 경우, forever-monitor가 도움이 된다</li>
        <li>CLI 호출 : forever [action] [options] SCRIPT [script-options]</li>
        <ul>
            <li>forever start name.js</li>
            <li>forever start config.json</li>
            <pre>[
  { // App1
    "uid": "app1",
    "append": true,
    "watch": true,
    "script": "index.js",
    "sourceDir": "/home/myuser/app1"
  },
  { // App2
    "uid": "app2",
    "append": true,
    "watch": true,
    "script": "index.js",
    "sourceDir": "/home/myuser/app2",
    "args": ["--port", "8081"]
  }
]</pre>
        </ul>
    </ul>
</details>

<hr>

<details>
    <summary>3rd/Jade : 템플릿 엔진</summary>
    <ul>
        <li>jade -P // Pretty</li>
        기본 옵션은 불필요한 공백 제거
        <li>↓ 아래 코드들은 1.11.0 버전 결과임</li>
        <li>주석
            <button class="btn-code" path="Repositories/Node/jade-start/doc1.jade" lan="text">예시 »</button>
            <button class="btn-code" path="Repositories/Node/jade-start/doc1.html" lan="text">결과 »</button></li>
        <li>Plain Text
            <button class="btn-code" path="Repositories/Node/jade-start/doc2.jade" lan="text">예시 »</button>
            <button class="btn-code" path="Repositories/Node/jade-start/doc2.html" lan="text">결과 »</button></li>
        <li>Code
            <button class="btn-code" path="Repositories/Node/jade-start/doc3.jade" lan="text">예시 »</button>
            <button class="btn-code" path="Repositories/Node/jade-start/doc3.html" lan="text">결과 »</button></li>
    </ul>
</details>

<hr>

<details>
    <summary>3rd/mocha : 테스트 프레임워크</summary>
    <ul>
        <li>설치</li>
        <ul>
            <li>$ npm install mocha --save-dev</li>
            <li>$ mkdir test</li>
            <li>package.json</li>
            <pre>"scripts": {
  "test": "mocha"
}</pre>
            <button class="btn-code" path="Repositories/Node/mocha-start/test/test1.js" lan="javascript">예시 코드 »</button>
        </ul>
        
        <li>비동기 코드 테스트</li>
        <ul>
            <li>테스트 함수가 콜백을 인자로 받아 비동기 작업 완료 후 호출.</li>
            <li>예외 발생 시 예외 객체 그대로 전달하면 알아서 fail로 간주.</li>
            <li>콜백이 2회 이상 호출된 경우 fail로 간주.</li>
            <button class="btn-code" path="Repositories/Node/mocha-start/test/test2.js" lan="javascript">예시 코드 »</button>
            <li>또는 그냥 Promise를 반환하면 알아서 성공/실패 판단</li>
            <li>실행 환경이 지원한다면, 테스트 함수 자체를 async로 해도 무방</li>
        </ul>
        
        <li>Hooking</li>
        <ul>
            <button class="btn-code" path="Repositories/Node/mocha-start/test/test3.js" lan="javascript">예시 코드 »</button>
            <li>before : 첫 번째 테스트 실행 전 한 번만 실행</li>
            <li>beforeEach : 매 테스트 실행 전 한 번씩 실행</li>
            <li>after : 마지막 테스트 실행 후 한 번만 실행</li>
            <li>afterEach : 매 테스트 실행 후 한 번씩 실행</li>
            <li>각 hook들은 비동기 테스트 코드처럼 done을 받는 비동기 작업을 해도 된다</li>
        </ul>
        
        <li>describe.only(), it.only() : only 붙은 것만 테스트</li>
        <li>describe.skip(), it.skip() : 스킵</li>
        this.skip()으로 런타임 중 스킵 가능 ← 테스트 함수 및 'before' hook 안에서 사용 가능
        <li>this.retries(n) : (행위) 테스트에서 재시도를 하도록 설정</li>
        <li>시간 제한 : this.timeout(n), setTimeout(done, 300)</li>
    </ul>
</details>

<hr>