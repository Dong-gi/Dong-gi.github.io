<hr>

<details>
    <summary>표준 입출력</summary>
    <ol>
        <li>Console.Read() : 한 글자</li>
        <li>Console.ReadLine() : 한 줄</li>
        <li>Console.Write(), Console.WriteLine()</li>
    </ol>
</details>

<hr>

<details>
    <summary>텍스트</summary>
    <ol>
        <li>System.String</li>
        매개변수로 StringComparison를 받는 메서드들도 있다.<br>
        String.Format : {N[,W][:formatCharacter]}
        <ul>
            N : 매개 변수 위치 지정. 0부터 시작<br>
            W : 출력될 자릿수 폭. '-'를 붙이면 왼쪽 정렬.<br>
            Format character
            <li>d : 10진수, 날짜(DateTime)</li>
            <li>n : ','로 구분한 10진수</li>
            <li>e : 지수 표기</li>
            <li>f : 고정 소수점</li>
            <li>g : e, f중 간략한 형태</li>
            <li>p : 백분율</li>
            <li>x : 16진수</li>
        </ul>

        <li>String Interpolation</li>
        string.Format("이름: {0}, 이메일: {1}", Name, Email);<br>
        $"이름: {Name,-20}, 이메일: {Email,30}"

        <li>System.Text.StringBuilder</li>

        <li>System.Text.Encoding</li>
        Encoding.UTF8.GetBytes()

        <li>System.Text.RegularExpressions.Regex</li>
    </ol>
</details>

<hr>

<details>
    <summary>시간</summary>
    <ol>
        <li>System.DateTime</li>
        닷넷의 시간 기준은 1년 1월 1일. Tick의 간격은 천만 분의 일초

        <li>System.TimeSpan</li>
        System.DateTime의 - 연산 결과

        <li>System.Diagnostics.Stopwatch</li>
    </ol>
</details>

<hr>

<details>
    <summary>직렬화</summary>
    <ul>
        <li>System.BitConverter</li>
        기본 타입의 직렬화/역직렬화 제공. 리틀 엔디언/빅 엔디언 구분 필요

        <li>System.Runtime.Serialization.Formatters.Binary.BinaryFormatter</li>
        [Serializable] 특성 표기한 사용자 정의 클래스 직렬화.<br>
        new BinaryFormatter().Serialize()<br>
        직렬화에 배제할 요소는 [NonSerialized] 특성 표기

        <li>System.Xml.Serialization.XmlSerializer</li>
        기본 생성자가 있는 public 클래스의 public 필드에 대해 직렬화 제공.<br>
        new XmlSerializer(typeof(ClassName)).Serialize()

        <li>System.Runtime.Serialization.Json.DataContractJsonSerializer</li>
        System.Runtime.Serialization.dll<br>
        new DataContractJsonSerializer(typeof(ClassName)).WriteObject()
    </ul>
</details>

<hr>

<details>
    <summary>스트림</summary>
    <ul>
        <li>System.IO.MemoryStream</li>
        바이트 단위 스트림

        <li>System.IO.StreamWriter, StreamReader</li>

        <li>System.IO.BinaryWriter, BinaryReader</li>

        <li>System.IO.FileStream</li>
        비동기 처리 지원 : BeginRead, EndRead, BeginWrite, EndWrite
    </ul>
</details>

<hr>

<details>
    <summary>파일</summary>
    <ul>
        <li>System.IO.File, System.IO.Directory // 클래스 메서드</li>

        <li>System.IO.FileInfo, System.IO.DirectoryInfo // 객체 메서드</li>

        <li>System.IO.Path</li>
        Path.Combine() : 경로 접합 시에 디렉터리 구분 문자를 넣어야 되는지 알아서 판단해서 처리해준다<br>
        자바와 마찬가지로 임시 폴더/파일에 관한 기능 제공
    </ul>
</details>

<hr>

<details>
    <summary>Collection</summary>
    <ul>
        <li>System.Collections.ArrayList</li>
        Object에 대한 동적 배열 → List

        <li>System.Collections.Hashtable</li>
        Object 키-값 쌍 저장 → Dictionary

        <li>System.Collections.SortedList</li>
        Hashtable과 유사. 삽입과 동시에 키를 기준으로 정렬이 이루어진다. → SortedDictionary

        <li>System.Collections.Stack, Queue</li>

        <li>컬렉션 초기화 구문</li>
        ICollection&lt;T&gt; 타입은 {}로 초기화 가능. C# 6.0부터는 인터페이스를 구현하지 않은 경우라도 확장 메서드로 Add()가 정의됐는지 확인한다.<br>
        예. new List&lt;int&gt; {0, 1, 2}<br>
        new Dictionary&lt;int, string&gt; { {0, "Sunday"}, {6, "Saturday"} };<br>
        new Dictionary&lt;int, string&gt; { [0] = "Sunday", [6] = "Saturday" };
    </ul>
</details>

<hr>

<details>
    <summary>스레딩</summary>
    <ul>
        <li>System.Threading.Thread</li>
        인자 하나를 받는 스레드 함수의 시작 : thread.Start(obj)<br>
        thread.Abort(); 스레드 상태와 관계없이 종료. 지양<br>
        thread.Join(); 스레드 종료 대기<br>
        thread.Interrupt(); 스레드가 WaitJoinSleep 상태일 때 종료

        <li>System.Threading.ThreadPool</li>
        닷넷이 기본적으로 지원하는 스레드풀. 기본 개념은 동일한 함수로 만들어진 스레드를 계속 만들지 않고, 종료된 스레드를 재사용하는 것. 때문에 스레드풀에 람다식을 이용하는 건 아이러니<br>
        ThreadPool.QueueUserWorkItem(functionName[, paramObj])

        <li>System.Threading.EventWaitHandle</li>
        Join이 스레드의 종료를 대기한다면, EventWaitHandle은 그 도중에도 상대 스레드를 깨울 수 있다.<br>
        EventWaitHandle 인스턴스는 Signal, Non-signal 두 가지 상태를 가지며, 상태 전이 메서드도 Set(→ Signal), Reset(→ Non-signal) 2가지가 있다.<br>
        스레드가 WaitOne 메서드를 호출하면 이벤트가 Signal 상태가 될 때까지 대기한다.<br>
        EventResetMode : 자동(Set 호출 뒤 자동으로 Non-signal 상태로 전이), 수동(Reset 직접 호출) // 자동 리셋의 경우 대기하는 스레드 중 하나만 깨우고 상태를 변경한다

        <li>System.Threading.Interlocked</li>
        int, long에 대한 원자 연산 제공

        <li>System.Threading.Monitor 스레드 간 동기화</li>
        <ul>
            <li>Monitor 사용</li>
            Monitor.Enter(/* ojbect */);<br>
            try { /* body */ } finally{ Monitor.Exit(/* object */); }

            <li>Monitor 구문과 동치인 lock 블록</li>
            자바의 synchronized와 유사.<br>
            lock (/* object */) { /* body */ }

            <li>lock 블록과 Monitor를 혼용하여 대기 스레드들을 직접 관리</li>
            Monitor.Wait() : 스레드를 WaitSleepJoin 상태로 만들고 lock을 해제한 뒤 Waiting Queue에 들어간다.<br>
            Monitor.Pulse() : Waiting Queue의 첫 요소를 Ready Queue로 입력.<br>
            <br>
            readonly var myLock = new object();<br>
            var isDone = false;<br>
            lock (myLock)<br>
            {<br>
            　　while(!isDone) { Monitor.Wait(myLock); }<br>
            　　isDone = false;<br>
            　　// ToDo<br>
            　　isDone = true;<br>
            　　Monitor.Pulse(myLock);<br>
            }
        </ul>

        <li>비동기 처리 System.Threading.Tasks.Task</li>
        var task = new Task(() => { Thread.Sleep(1000); Console.WriteLine("Async"); });<br>
        task.start();<br>
        Console.WriteLine("Hello");<br>
        task.Wait(); // 종료 대기<br>
        Console.WriteLine("World");<br>
        <br>
        var task = Task.Run(() => { Thread.Sleep(1000); Console.WriteLine("Async"); });<br>
        Console.WriteLine("Hello");<br>
        task.Wait();<br>
        Console.WriteLine("World");<br>
        <br>
        Console.WriteLine("Hello");<br>
        await Task.Run(() => { Thread.Sleep(1000); Console.WriteLine("Async"); });<br>
        Console.WriteLine("World");<br>
        <br>
        await Task.Delay() : 입력시간 후 태스크 반환<br>
        Task.WaitAll(t1, t2, ...)<br>
        await Task.WhenAll(t1, t2, ...)<br>
        Task.Factory.StartNew()<br>
        Task.Factory.StartNew&lt;TResult&gt;()

        <li>비동기 실행 결과 취합 Task&lt;TResult&gt:</li>
        var task = Task&lt;List&lt;int&gt;&gt;.Run(() => {<br>
        　　Thread.Sleep(1000);<br>
        　　return new List&lt;int&gt; { 2 };<br>
        });<br>
        var myList = new List&lt;int&gt;(new int[] { 1 });<br>
        task.Wait();<br>
        myList.AddRange(task.Result);

        <li>병렬 처리 System.Threading.Tasks.Parallel</li>
        void DoSomething(int i) =&gt; Console.WriteLine(i);<br>
        Parallel.For(0, 100, DoSomething);
    </ul>
</details>

<hr>

<details>
    <summary>네트워킹</summary>
    <ul>
        <li>System.Net.IPAddress</li>

        <li>System.Net.IPEndPoint</li>
        IPAddress + port

        <li>System.Net.Dns</li>
        Dns.GetHostEntry()

        <li>System.Net.Sockets.Socket</li>
        Socket(IPv4/6, Stream, Tcp) or Socket(IPv4/6, Dgram, Udp)

        <li>System.Net.HttpWebRequest</li>
        WebRequest.Create() as HttpWebRequest

        <li>System.Net.WebClient</li>
    </ul>
</details>

<hr>

<details>
    <summary>DB : ADO.NET</summary>
    <ul>
        ADO.NET : DBMS 통신 닷넷 구현 라이브러리. 각 DBMS마다 만들어진 걸 이용하면 된다. 아래의 공통 인터페이스를 구현한다.

        <li>System.Data.IDbConnection</li>
        DB 서버와의 연결 담당<br>
        <br>
        트랜잭션 1<br>
        using(var transaction = sqlConnection.BeginTransaction) {<br>
        　　var command = new SqlCommand();<br>
        　　command.Connection = sqlConnection;<br>
        　　command.Transaction = transaction;<br>
        　　...<br>
        　　transaction.Commit();<br>
        }<br>
        <br>
        트랜잭션 2<br>
        using(var sqlConnection = new SqlConnection(connectionString);<br>
        　　var transactionScope = new TransactionScope()) {<br>
        　　sqlConnection.Open();<br>
        　　...<br>
        　　transactionScope.Complete();<br>
        }

        <li>System.Data.IDbCommand</li>
        DB 서버로 쿼리 전달
        <ul>
            <li>ExecuteNonQuery</li>
            INSERT, UPDATE, DELETE : 영향 받은 행의 수 반환

            <li>ExecuteScalar</li>
            SELECT : 단일값 반환

            <li>ExecuteReader</li>
            SELECT : 다중 레코드 반환
        </ul>

        <li>System.Data.IDataReader</li>
        쿼리 결과 해석

        <li>System.Data.IDbDataParameter</li>
        Parameterized command에 사용될 매개변수<br>
        var email = new SqlParameter("email", SqlDbType.NVarChar, 120);<br>
        sqlCommand.CommandText = "INSERT INTO t_account(account_id, email) VALUES(@account_id, @email)";

        <li>System.Data.IDbDataAdapter</li>
        System.Data.DataTable ↔ 닷넷 클래스(POCO; 자바의 POJO와 유사한 개념) 사이의 어댑터<br>
        var dataSet = new DataSet();<br>
        new SqlDataAdapter("select * from t_account", sqlConnection).Fill(dataSet, "t_account");

        <li>ORM</li>
        MS SQL 서버 또는 Azure와 연결하여 자동으로 모델을 구성할 수 있다.<br>
        추가 - 새 항목 - [데이터] ADO.NET 엔터티 데이터 모델<br>
        MySQL, PostgreSQL도 확장을 설치하거나 하면 된다는 것 같은데...<br>
        https://dev.mysql.com/downloads/windows/visualstudio/<br>
        https://dev.mysql.com/doc/visual-studio/en/visual-studio-entity-framework.html<br>
        https://stackoverflow.com/q/32045852/7369515
    </ul>
</details>

<hr>

<details>
    <summary>윈도우 레지스트리</summary>
    Registry.ClassesRoot : HKEY_CLASSES_ROOT<br>
    Registry.CurrentUser : HEKY_CURRENT_USER<br>
    Registry.LocalMachine : HKEY_LOCAL_MACHINE<br>
    Registry.Users : HKEY_USERS<br>
    Registry.CurrentConfig : HKEY_CURRENT_CONFIG<br>
    <br>
    Registry.LocalMachine.OpenSubKey(@"HARDWARE\DESCRIPTION\System\BIOS").GetValue("Key")<br>
    Registry.LocalMachine.OpenSubKey(@"HARDWARE\DESCRIPTION\System\BIOS", true).SetValue("Key", value)<br>
    <br>
    REG_SZ → string<br>
    REG_BINARY → byte[]<br>
    REG_DWORD → int<br>
    REG_QWORD → long<br>
    REG_MULTI_SZ → string[]
</details>

<hr>