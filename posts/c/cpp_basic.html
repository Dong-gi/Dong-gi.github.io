<ul>
    <li>기본 자료형</li>
    <ul>
        <li>네임스페이스 특정 이름만 using으로 포함시킬 수 있다.</li>
        <li>short &lt;= int &lt;= long &lt;= long long, unsigned ~</li>
        <li>float &lt;= double &lt;= long double</li>
        <li>char(8bits) &lt; char16_t &lt; char32_t, wchar_t</li>
        <li>bool, auto(c#의 var과 유사), decltype(x) : x와 같은 타입
            <button class="btn-code" path="Repositories/VisualStudio/C++ Basic/Type.cpp" lan="cpp">Type.cpp »</button></li>
    </ul>

    <li>복합 자료형</li>
    <ul>
        <li>enum Name { CONST1, CONST2 = num1, CONST3, ... };</li>
        <li>enum class Name { CONST1, ... }; // Type Safe</li>
        C#과 마찬가지로 enum class는 정수 타입을 상속함으로써 표현된다. enum class Name : long
        <li>struct Name { [fields] };</li>
        <li>std::array : vector와 달리 크기가 고정되어 오버헤드가 적다.
            <button class="btn-code" path="Repositories/VisualStudio/C++ Basic/Type.cpp" lan="cpp">Type.cpp »</button></li>
    </ul>

    <li>변수</li>
    <ul>
        <li>new ~ delete는 번거로우므로, unique_ptr이 도입되었다. 변수가 스코프를 벗어나면 자동으로 해제한다.</li>
        <li>물론 정적 할당된 객체는 선언된 영역을 벗어나면 해제된다. 정적 할당된 객체를 전달할 경우 복사생성자가 호출되어 복사본이 전달되며, const를 사용할 경우 참조가 전달된다.</li>
        <li>값에 의한 전달 : 주소값에 의한 전달 : 참조에 의한 전달(변수만 가능)</li>
        <li>try ~ (catch) : catch 생략 가능. exception ~ bad_alloc, bad_cast, bad_exception, logic_error, runtime_error 등
            <button class="btn-code" path="Repositories/VisualStudio/C++ Basic/Exception.cpp" lan="cpp">Exception.cpp »</button></li>
    </ul>

    <details>
        <summary>클래스</summary>
        <ol>
            <li>보통 헤더 파일에 선언, 구현 파일에 정의</li>
            class Name { Name() 생성자, ~Name() 소멸자 }<br>
            명시적 디폴트 생성자 : Name() = default;<br>
            복사 생성자 : Name(Name&amp; obj) {}<br>
            유틸리티 클래스 : Name() = delete; // 생성자를 가지지 않는다.

            <li>생성자 호출 종류</li>
            Car c1; // default constructor<br>
            Car c2(123, "white"); // constructor<br>
            Car c3 = Car(321, "black"); // 임시 객체 생성 후 복사<br>
            Car c4 = Car(c3); // 복사 생성<br>
            Car *c5 = new Car(); // 포인터 이용 시<br>
            c5-&gt;color; // 포인터 이용 시

            <li>멤버 초기화는 선언된 순서대로만 진행된다. 소멸시 반대 방향으로 소멸된다.</li>

            <li>접근제한자 : public, protected, private</li>
            <button class="btn-code" path="Repositories/VisualStudio/C++ Basic/Class.h" lan="cpp">Class.h »</button>
            <button class="btn-code" path="Repositories/VisualStudio/C++ Basic/Class.cpp" lan="cpp">Class.cpp »</button>

            <li>명시적 대입 연산자</li>
            Name&amp; operator=(const Name&amp; rValue) = default | delete

            <li>객체 복제 배제 : 복사생성자와 =연산자를 private으로.</li>

            <li>두 클래스가 서로를 필요로 할 때, 일반적인 #include로는 해결할 수 없어 포워드 선언을 한다.</li>

            <li>const 멤버는 const 메서드만 이용할 수 있다.</li>

            <li>mutable 멤버의 변경은 메서드의 const 선언을 해치지 않는다고 간주한다.</li>
            <button class="btn-code" path="Repositories/VisualStudio/C++ Basic/ClassA.h" lan="cpp">ClassA.h »</button>
            <button class="btn-code" path="Repositories/VisualStudio/C++ Basic/ClassB.h" lan="cpp">ClassB.h »</button>

            <li>오버로딩 메서드 시그너쳐에 delete 선언하면 호출할 수 없다.</li>

            <li>inline 함수는 호출 지점에 코드 자체가 복사되어 메서드 콜 오버헤드를 줄인다. 클래스 헤더에서 직접 구현하면 inline 키워드 없이도 자동적으로 inline 검사 대상이 된다.</li>

            <li>friend : 다른 클래스 또는 메서드에서 모든 멤버/메서드에 접근 허용.</li>

            <li>연산자 오버로딩 : 타입 A를 갖는 생성자가 존재한다면 타입 A의 인스턴스와 직접 연산 가능.</li>

            <li>복합 대입 연산자 오버로딩 : 임시 객체 없이 좌변 객체 변경후 객체 참조 리턴.
                <button class="btn-code" path="Repositories/VisualStudio/C++ Basic/ClassC.h" lan="cpp">ClassC.h »</button></li>
        </ol>
    </details>

    <details>
        <summary>상속</summary>
        <ul>
            <li>class Sub : public Super</li>
            <li>virtual이 없는 경우 발생하는 모호함(다형성 미지원)을 해소하기 위해 소멸자까지 기본적으로 virtual로 선언한다.</li>
            <li>재정의, 확장 방지 : final</li>
            "class Name final", "type method(param) final"
            <li>다중 상속 가능. 부모 메서드를 호출하기 위해 단일 키워드 대신 명시적으로 부모 이름을 이용.</li>
            <li>공변 리턴 : 메서드 리턴 타입이 클래스에 대한 포인터나 참조면 오버라이딩하면서 그 자식 타입의 것으로 변경 가능.</li>
            <li>static method는 재정의될 수(virtual할 수) 없다.</li>
            <li>method를 재정의하면 부모의 모든 오버로딩된 메서드들이 가려진다. 하지만 포인터를 통해(업캐스팅) 호출할 수는 있다.</li>
            <li>Java와 달리 private method도 재정의할 수 있다. C++에서 접근 제한자는 호출자만을 제한한다. 접근 범위를 강화할수도 있다.</li>
            <button class="btn-code" path="Repositories/VisualStudio/C++ Basic/SuperClass.h" lan="cpp">SuperClass.h »</button>
            <button class="btn-code" path="Repositories/VisualStudio/C++ Basic/SubClass.h" lan="cpp">SubClass.h »</button>
        </ul>
    </details>

    <li>참조 타입</li>
    <ul>
        <li>참조 타입 변수는 생성과 동시에 초기화되어야만 한다.</li>
        <li>참조 타입 변수의 참조 대상은 불변하다. 역참조가 허용되지 않아 안전하다.</li>
        <li>int*&amp; ref : 포인터에 대한 참조 타입 변수. cf. 참조에 대한 참조, 참조에 대한 포인터는 불가능.</li>
        <li>참조 대상을 변경해야 하는 경우, 메모리 해제가 필요한 경우만 포인터 이용.</li>
        <li>&amp;&amp; : rvalue 참조. 금방 해제될 객체, 지역 변수, 상수 참조 가능.</li>
        std::move() : lvalue를 rvalue로 변환
        <li>move constructor, move assignment operator</li>
        rvalue 참조 매개변수로 받은 객체로부터 값을 복사한 후 원본을 null로 변경하여 메모리 소유권 이동.(복사보다 이동이 좋다.)
    </ul>

    <details>
        <summary>const</summary>
        <ol>
            <li>const 키워드는 왼쪽에 적용된다. 단, 맨 처음 등장하는 "type const"는 "const type"과 같다.</li>
            const int a; // 변경 불가<br>
            void func() const {} // 멤버 변수 변경 불가<br>
            const Car c6(); // 변경 불가<br>
            <br>
            const int * : const int를 가리키는 포인터<br>
            int * const : int 포인터 변수 고정<br>
            const int * const * const * const ip = nullptr; // 가능;;

            <li>const method는 mutable 멤버 외의 멤버를 변경할 수 없다.</li>

            <li>constexpr : 상수표현식으로 사용 가능.</li>
            constexpr constructor : 사용자 정의 객체를 상수 표현 변수로 이용 가능.<br>
            constexpr를 이용한 함수/메서드/생성자는 매개변수로 상수만 받을 수 있어야 하며, 호출 전에 컴파일러에 의해 body가 해석되어야 한다.
            <button class="btn-code" path="Repositories/VisualStudio/C++ Basic/Constexpr.cpp" lan="cpp">Constexpr.cpp »</button>
        </ol>
    </details>
    
    <li>static</li>
    <ul>
        <li>static 멤버는 객체 유무와 무관하게 클래스 자체에 속한다.</li>
        <li>static linking : 같은 소스에서의 함수/변수 참조</li>
        static void func();는 외부에서 참조 불가.<br>
        static 의미 자체와 연관이 없어 anonymous namespace 도입 → namespace { void func(); }
        <li>extern : external link 명시</li>
        <li>함수 내 static 변수 : 해당 함수에서만 이용가능한 전역 변수와 같다.</li>
    </ul>

    <li>형 변환</li>
    <ul>
        <li>"typedef int INT32" == "using INT32 = int"</li>
        "typedef int (*FuncType)(int, int)" == "using FuncType = int (*)(int, int)"
    
        <li>const_cast : const 변수의 상수 속성을 제거. const_cast&lt;int*&gt;(p)</li>
        
        <li>static_cast : 언어 자체에서 허용하는 변환을 명시적으로 수행, 생성자나 변환 연산자가 구현되어 있을 때 명시적으로 변환, 같은 클래스 계층의 두 클래스 간 변환</li>
        
        <li>dynamic_cast : 같은 클래스 계층의 두 클래스 간 변환(타입 검사 수행)</li>

        <li>명시적 형 변환 : explicit
            <button class="btn-code" path="Repositories/VisualStudio/C++ Basic/Explicit.cpp" lan="cpp">Explicit.cpp »</button></li>
    </ul>

    <li>초기화</li>
    <ul>
        <li>클래스에서도 {}로 초기화 가능. public Name(int, int);</li>
        Name n(1, 2) → Name n = {1, 2} 가능, Name n{1, 2} 가능<br>
        vector&lt;string&gt; names = {"name1", "name2", "name3"}
        
        <li>initializer list를 이용한 단일 타입 가변 길이 매개변수 함수 작성 가능.</li>
    </ul>
</ul>