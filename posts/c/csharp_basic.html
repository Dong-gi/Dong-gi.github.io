<hr>

<details>
    <summary>.NET Framework 개요</summary>
    <ul>
        <li>프레임워크</li>
        제어 역전이 있는 대규모 라이브러리. 프로그램의 초기화부터 종료까지 직접 관리하며, 개발자는 일부분만 작성.

        <li>CLI; Common Language Infrastructure</li>
        닷넷 표준 규약. 자바와 마찬가지로 CLI 사양을 준수한 구현체에서 동작하는 파일은 다른 구현체에서도 실행된다.
        <ul>
            <li>CIL; Common Intermediate Language == IL. 중간 언어</li>
            IL은 자체 문법을 가지며 ILASM.EXE라는 전용 컴파일러도 있다.

            <li>CTS; Common Type System</li>
            닷넷 언어가 지켜야 할 타입의 표준. 전체를 구현하진 않아도 된다.

            <li>CLS; Common Language Specification</li>
            닷넷 언어가 지켜야 하는 최소 사양

            <li>메타데이터</li>
            실행 파일(exe/dll)은 외부에서 리플렉션을 통해 접근할 수 있는 메타데이터를 제공한다.

            <li>어셈블리</li>
            exe/dll 실행파일을 어셈블리라고 부른다.

            <li>모듈</li>
            어셈블리는 1개 이상의 모듈로 구성되며, 하나의 모듈은 하나의 파일에 대응된다.

            <li>매니페스트</li>
            여러 모듈이 하나의 어셈블리를 구성하는 경우, 모듈 중 하나는 모듈의 목록을 관리하는 매니페스트 데이터를 갖는다. 매니페스트를 포함하는 경우 확장자는 exe/dll, 그 외의 모듈은 보통
            netmodule이지만, 일반적으로 모든 어셈블리는 1개의 파일로 구성된다.
        </ul>

        <li>닷넷 구현체</li>
        <ul>
            <li>.NET Framework</li>
            CLR; Common Language Runtime + BCL; Base Class Library<br>
            CLR : CLI를 구현한 가상 머신. 중간 언어를 JIT 컴파일러를 이용해 기계어로 변환하고, GC를 운용한다.

            <li>.NET Core</li>
            CoreCLR + Core Library<br>
            윈도우, macOS, 리눅스에서 실행 가능

            <li>Mono</li>
            현재는 자마린에서 개발 중. 윈도우, macOS, 리눅스, 솔라리스, 안드로이드, 엑스박스 360 등에서 실행 가능
        </ul>
    </ul>
</details>

<hr>

<details>
    <summary>개발 환경</summary>
    <ol>
        <li>윈도우에는 기본적으로 닷넷 프레임워크가 설치돼있다. 또는 비주얼 스튜디오 설치 시 같이 설치된다.</li>
        <li>C# 컴파일러 : C:\Windows\Microsoft.NET\...\csc.exe</li>
        <li>닷넷 역컴파일러 : .NET Reflector(유료), JustDecompile(무료) 등</li>
        <li>IDE : Visual Studio, Visual Studio for Mac, Visual Studio Code, Xamarin Studio, Rider</li>
    </ol>
</details>

<hr>

<details>
    <summary>문법</summary>
    <details>
        <summary>기본 자료형</summary>
        <ul>
            <li>정수형</li>
            <table>
                <tr>
                    <td>sbyte</td>
                    <td>signed byte</td>
                    <td>System.Sbyte</td>
                </tr>
                <tr>
                    <td>byte</td>
                    <td>unsigned byte</td>
                    <td>System.Byte</td>
                </tr>
                <tr>
                    <td>short</td>
                    <td>signed 2bytes</td>
                    <td>System.Int16</td>
                </tr>
                <tr>
                    <td>ushort</td>
                    <td>unsigned short</td>
                    <td>System.UInt16</td>
                </tr>
                <tr>
                    <td>int</td>
                    <td>signed 4bytes</td>
                    <td>System.Int32</td>
                </tr>
                <tr>
                    <td>uint</td>
                    <td>unsigned int</td>
                    <td>System.UInt32</td>
                </tr>
                <tr>
                    <td>long</td>
                    <td>signed 8bytes</td>
                    <td>System.Int64</td>
                </tr>
                <tr>
                    <td>ulong</td>
                    <td>unsigned long</td>
                    <td>System.UInt64</td>
                </tr>
            </table>

            <li>실수형</li>
            <table>
                <tr>
                    <td>float</td>
                    <td>4바이트. 리터럴 접미사 f</td>
                    <td>System.Single</td>
                </tr>
                <tr>
                    <td>double</td>
                    <td>8바이트</td>
                    <td>System.Double</td>
                </tr>
                <tr>
                    <td>decimal</td>
                    <td>16바이트. 리터럴 접미사 m</td>
                    <td>System.Decimal</td>
                </tr>
            </table>

            <li>숫자 리터럴</li>
            16진수 표현 0xFFFF, 2진수 표현 0b1010, 구분 문자 '_' 사용 가능

            <li>문자형</li>
            <table>
                <tr>
                    <td>char</td>
                    <td>2바이트(유니코드)</td>
                    <td>System.Char</td>
                </tr>
                <tr>
                    <td>string</td>
                    <td>동적 크기. Indexer 구현</td>
                    <td>System.String</td>
                </tr>
            </table>

            <li>문자열 리터럴</li>
            <ul>
                <li>@"" : \ 이스케이프를 하지 않는다. ""로 일반 문자열의 \"를 대신할 수 있다</li>
                <li>$"" Since C# 6 : 간편한 포맷 문자열을 제공한다. {<i>표현식</i>[, <i>alignment</i>][: <i>formatString</i>]}
                    <button class="btn-code" path="Repositories/VisualStudio/csharp_interpolated_string.cs" lan="java">예시 코드 »</button></li>
                <li>Since C# 8 : @$"", $@"" 모두 유효. 이전에는 $@""만 가능</li>
            </ul>

            <li>Boolean</li>
            <table>
                <tr>
                    <td>bool</td>
                    <td>true or false</td>
                    <td>System.Boolean</td>
                </tr>
            </table>

            <li>Boolean 연산 &&, ||는 Short-circuit</li>
        </ul>
    </details>

    <details>
        <summary>배열</summary>
        <ul>
            <li>배열 초기화시 기본값으로 채워진다.</li>
            <li>다차원 배열 [,] : 배열 차원 고정. 메모리 상에서는 일차원 배열처럼 존재.</li>
            <li>Jagged Array [][] : 배열의 차원이 가변적</li>
<pre>int[] arr1 = new int[3];
int[] arr2 = new int[] { 1, 2, 3 };
int[] arr3 = { 1, 2, 3 };
int[,] arr4 = new int[2, 2];
int[,] arr5 = new int[,] { { 1, 2 }, { 3, 4 } };</pre>
        </ul>
    </details>

    <details>
        <summary>형변환</summary>
        <ul>
            <li>암시적 형변환 : 보다 큰 정의의 자료형으로 자동 변환.</li>
            Boxing : Value type 데이터를 Reference type으로 변환. 컴파일러가 묵시적으로 수행.
            <li>명시적 변환 : 괄호 이용.</li>
            Unboxing : Reference type 데이터를 Value type으로 변환. 캐스팅을 통해 명시적으로 수행.
            <li>if (o is Mammal m) { }</li>
            <li>as 연산자를 이용한 명시적 변환은, null을 허용하는 참조 자료형만 가능하다.</li>
        </ul>
    </details>

    <details>
        <summary>구문</summary>
        <ul>
            <li>if ~ else if ~ else</li>
            <li>switch</li>
            정수, bool, char, string, enum에 대해 동작. case문 다음이 빈 문장일 때만 break 생략 가능<br>
            Since C# 7.0 : null이 아닌 모든 표현식 가능
            <li>while, do ~ while</li>
            <li>for(초기식; 조건식; 증감식)</li>
            <li>foreach(var obj in IEnumerable)</li>
            <li>점프</li>
            break, continue, goto(관례상 레이블은 대문자로만), return, throw
            <li>checked/unchecked 블록</li>
            기본적으로는 프로그램 실행 시 오버플로/언더플로를 무시한다.<br>
            checked/unchecked 블록은 이를 각각 명시적인 예외로 처리/비처리 하도록 한다.
            <button class="btn-code" path="Repositories/VisualStudio/CSharp/Basic/CheckedExample.cs" displayRange="[13, 39]" lan="cs">예시 코드 »</button>
            <li>예외 처리</li>
<pre>throw e; // e는 System.Exception 및 파생 클래스의 인스턴스
try {} catch {} finally {}
try {} catch (ExceptionType) {}
try {} catch { throw; }
try {} catch (ExceptionType e) {}
try {} catch () when (!filePath.Contains(".tmp")) {} // when 필터를 사용하는 경우, 같은 타입을 여러 번 catch 가능
try {} finally { iDisposable.Dispose(); } // 다음과 동일 : using(var iDisposable = ~) { }
</pre>
        </ul>
    </details>

    <details>
        <summary>네임스페이스</summary>
<pre>namespace MyProgram.Model { }
using System.Collections.Generic;
using static MyProgram.Model.Constants;</pre>
    </details>
</details>

<hr>

<details>
    <summary>객체지향</summary>
    <details>
        <summary>클래스</summary>
        <ul>
            <li>프로퍼티 → (히든) 필드에 대한 getter/setter 메서드
                <button class="btn-code" path="Repositories/VisualStudio/csharp_property.cs" lan="java">ViewModel에서의 사용 예 »</button></li>

            <li>익명 객체 → new { PropertyName = value } : 생성 후 읽기만 가능</li>

            <li>정적 생성자 → static 클래스이름() { }</li>
            첫 번째 인스턴스가 만들어지거나 정적 멤버가 참조되기 전에 자동으로 호출된다.

            <li>partial class ClassName {} : 프로젝트 내 여러 파일에 걸쳐 클래스 작성 가능</li>

            <li>접근 제한자 → public, protected(파생 클래스까지), private, internal(같은 어셈블리), protected internal</li>

            <li>상속</li>
            <ul>
                <li>class SubClass : BaseClass</li>
                <li>is 연산자로 호환 여부 확인 가능</li>
                <li>this 키워드 : 클래스의 현재 인스턴스<br>
                    base 키워드 : 부모 클래스 메서드 또는 생성자 호출
                    <button class="btn-code" path="Repositories/VisualStudio/csharp_base_keyword.cs" lan="java">예 »</button></li>
                <li>sealed 키워드 → 상속/재정의 불가</li>
                <li>부모 클래스 인스턴스를 자식 클래스로 다운캐스팅 불가.</li>
                <li>모든 자료형의 조상은 System.Object : ToString(), GetType(), Equals(), GetHashCode()<br>
                    모든 값 형식의 조상은 System.ValueType<br>
                    모든 배열의 조상은 System.Array : Sort(), BinarySearch&lt;T&gt;(), IndexOf(), ..., Length, Rank</li>
            </ul>

            <li>다형성</li>
            <ul>
                <li>virtual, override 키워드를 사용해 명시한다. virtual 메서드는 body를 정의해야 한다.</li>
                <li>new : 부모 메서드 숨기기. override와 달리 형 변환을 통해 부모 메서드에 접근 가능.</li>
                <li>abstract class : 인스턴스화 불가능<br>
                    abstract method : 서브 클래스에서 반드시 override</li>
                <li>연산자 오버로딩</li>
                <pre>public static 반환타입 operator 연산자(타입1 변수1, 타입2 변수2) {}</pre>
                <li>형 변환 정의</li>
<pre>public static implicit operator 타입2(타입1 변수1) {};
public static explicit operator 타입2(타입1 변수1) {};</pre>
            </ul>
        </ul>
    </details>

    <details>
        <summary>델리게이트</summary>
        <ul>
            <li>메서드를 참조하는 자료형
                <button class="btn-code" path="Repositories/VisualStudio/CSharp/Basic/DelegateExample.cs" displayRange="[12, 47]" lan="cs">예시 »</button></li>

            <li>델리게이트로 변환될 수 있는 익명 메서드 생성</li>
            <ol>
                <li>delegate 연산자 → delegate (int a, int b) { return a + b; }</li>
                <li>람다 Since C# 3 → (a, b) => a + b;</li>
            </ol>

            <li>델리게이트에는 BeginInvoke 및 EndInvoke 메서드가 자동으로 추가되며, 이를 통해 임의 메서드를 비동기 호출할 수 있다</li>
            <button class="btn-code" path="Repositories/VisualStudio/CSharp/Basic/DelegateExample.cs" displayRange="[12, 22, 49, 64]" lan="cs">비동기 호출 예 »</button>
            <button class="btn-code" path="Repositories/VisualStudio/CSharp/Basic/DelegateExample.cs" displayRange="[12, 22, 66, 86]" lan="cs">비동기 호출 대기 예 »</button>

            <li>델리게이트 체인</li>
            myDelegate += obj.Func;<br>
            myDelegate -= obj.Func;

            <li>Func</li>
            결과를 반환하는 메서드를 참조하는, 미리 정의된 델리게이트. 매개변수 0 ~ 16개, 총 17가지.

            <li>Action</li>
            void 리턴 메서드를 참조하는, 미리 정의된 델리게이트. 매개변수 0 ~ 16개, 총 17가지.

            <li>이벤트</li>
            <ol>
                <li>일반화된 델리게이트. 간단하게 구독/해지 가능. 클래스 밖에서 호출 불가.</li>
                <li>이벤트의 첫 번째 인자는 이벤트 발생 객체. 두 번째 인자는 EventArgs 호환 객체.</li>
                <li>public event EventHandler SomeEvent = delegate { };<button class="btn-code" path="Repositories/VisualStudio/CSharp/Basic/EventExample.cs" lan="cs">예시 코드 »</button></li>
            </ol>
        </ul>
    </details>

    <details>
        <summary>인터페이스</summary>
        <ol>
            <li>인터페이스도 프로퍼티를 가질 수 있다(get/set 지정만 가능). 구현하는 클래스에서 프로퍼티를 구현한다.</li>
            <li>class SubClass : BaseClass, Interface1, Interface2, ...</li>
            <li>interface Interface1 : Interface2</li>
        </ol>
    </details>

    <details>
        <summary>구조체 struct</summary>
        <ol>
            <li>사용자 정의 ValueType.</li>
            <li>ValueType이므로 생성자 호출 없이 선언만으로 초기화가 진행된다. 사용되는 기본 생성자는 컴파일러가 자동으로 추가하며, 재정의할 수 없다.</li>
            <li>모든 타입은 Object의 파생 클래스이므로, 구조체도 new 키워드로 인스턴스를 생성할 수 있다. 인자를 받는 생성자는 모든 필드를 초기화해야 한다.</li>
            <li>ValueType이므로 할당 시 깊은 복사가 이루어진다.</li>
        </ol>
    </details>

    <details>
        <summary>열거형 enum</summary>
        <ol>
            <li>정수형을 상속받아 정의할 수 있는 ValueType. 기본 int</li>
            <li>[Flags] // 열거형을 비트필드로 이용하는 애트리뷰트</li>
<pre>[Flags] enum Authority { READ = 1, WRITE = 2, EXECUTE = 4 }
var authority = READ | WRITE;
Console.WriteLine(authority.HasFlag(WRITE));</pre>
        </ol>
    </details>

    <details>
        <summary>제네릭</summary>
        <ul>
            <li>Generic Method</li>
            public void Write&lt;T&gt;(T value) =&gt; OnWrite(value?.ToString() ?? "");

            <li>Generic Class</li>
            public class List&lt;T&gt; : IList&lt;T&gt;, ICollection&lt;T&gt;, IEnumerable&lt;T&gt;, (생략)

            <li>Type Bound</li>
            <ol>
                <li>where T : struct // 값 형식</li>
                <li>where T : class // 참조 형식</li>
                <li>where T : new() // 기본 생성자 보유</li>
                <li>where T : BaseClassName | InterfaceName | U // 호환 여부 검사. U는 다른 형식 매개 변수</li>
                <li>where T : A[, B[, C[...]]]</li>
                class MyGenereic&lt;T, U&gt; where T : struct where U : class { }
            </ol>

            <li>제네릭 별명</li>
            <pre>using Commands = System.Collections.Generic.Dictionary&lt;string, System.Windows.Input.ICommand&gt;;</pre>
        </ul>
    </details>
</details>

<hr>

<details>
    <summary>추가 기능 ~ C# 8.0 (2019. 02. 12)</summary>
    <details>
        <summary>타입</summary>
        <ol>
            <li>BigInteger : 크기 제한없는 정수. 연산자 오버로딩 덕에 편리</li>
            <li>dynamic : 파이썬처럼 타입 검사를 런타임에 하여 Duck-typing을 가능하게 한다.</li>
            <li>IntPtr : 32/64비트 프로그램에서 각각 4/8바이트. 포인터 외에 운영체제 핸들값을 저장하는 용도로도 사용.</li>
            <li>var : 지역변수 초기화시 사용 가능한 자동형식</li>
            <li>Nullable&lt;T&gt; : null을 허용하는 래퍼 클래스. int?는 Nullable&lt;int&gt;와 동일하다.</li>
        </ol>
        <details>
            <summary>튜플 : System.ValueTuple</summary>
            <ul>
                <li>익명 튜플 : 멤버의 기본 이름은 Item1, Item2, ...</li>
                <pre>var unnamed = ("one", "two");</pre>
                <li>명명 튜플 : 컴파일하면 멤버명은 Item*으로 변경된다</li>
                <pre>var named = (first: "one", second: "two");</pre>
                <li>튜플 프로젝션 이니셜라이저 : 변수명을 자동으로 요소 이름으로 사용</li>
                <pre>var accumulation = (count, sum);</pre>
                <li>Since C# 7.3 ==, != 연산자 지원(short-circuit)</li>
                <ul>
                    <li>Nullable인 튜플이나 멤버에 대해 자동으로 변환을 수행한다</li>
<pre>var left = (a: 5, b: 10);
var right = (a: 5, b: 10);
(int a, int b)? nullableTuple = right;
Console.WriteLine(left == nullableTuple); // true</pre>
<pre>var left = (a: 5, b: 10);
(int? a, int? b) nullableMembers = (5, 10);
Console.WriteLine(left == nullableMembers); // true</pre>
                    <li>튜플 멤버에 대한 암시적 변환을 수행한다</li>
<pre>(long a, int b) longFirst = (5, 10);
(int a, long b) longSecond = (5, 10);
Console.WriteLine(longFirst == longSecond); // true</pre>
                </ul>
                <li>메서드 튜플 반환</li>
<pre>static (int Count, double Sum, double SumOfSquares) ComputeSumAndSumOfSquares(IEnumerable&lt;double&gt; sequence) { }
static (int, double, double) ComputeSumAndSumOfSquares(IEnumerable&lt;double&gt; sequence) { }

(int count, double sum, double sumOfSquares) = ComputeSumAndSumOfSquares(sequence);
(int count, var sum, var sumOfSquares) = ComputeSumAndSumOfSquares(sequence);
var (count, sum, sumOfSquares) = ComputeSumAndSumOfSquares(sequence);
var result = ComputeSumAndSumOfSquares(sequence);</pre>
                <li>메서드 튜플 매개변수</li>
<pre>public void Print((int Count, double Sum, double SumOfSquares) data) { }
public void Print((int, double, double) data) { }</pre>
                <li>out 매개변수 튜플</li>
<pre>var dict = new Dictionary&lt;int, (int, string)&gt;();
dict.TryGetValue(2, out (int num, string place) pair);</pre>
                <li>튜플 분해</li>
<pre>public class Rectangle
{
    public int X { get; set; }
    public int Y { get; set; }
    public int Width { get; set; }
    public int Height { get; set; }
    public void Deconstruct(out int x, out int y, out int width, out int height)
        => (x, y, width, height) = (X, Y, Width, Height);
}

// 또는 다른 형식에 대한 확장 메서드를 작성하여 분해를 지원할 수 있다
public static void Deconstruct(this Rectangle rect, out int x, out int y, out int width, out int height)
    => (x, y, width, height) = (rect.X, rect.Y, rect.Width, rect.Height);

var rect = new Rectangle(1, 2, 3, 4);
var (_, _, w, h) = rect;</pre>
            </ul>
        </details>
    </details>
    <details>
        <summary>연산자</summary>
        <ul>
            <li>await : 피연산자가 나타내는 비동기 작업이 완료될 때까지 바깥쪽 비동기 메서드의 평가를 일시 중단</li>
            <li>default(Type) : 타입에 대한 기본값/인스턴스 반환한다.</li>
            Since C# 7.1 : default 리터럴로 기본값을 표현할 수 있다.
            <li>nameof(Identifier) : 식별자 문자열 반환</li>
            <li>Null 조건부 연산자 ?. 및 ?[]
                <button class="btn-code" path="Repositories/VisualStudio/CSharp/Basic/NullableExample.cs" lan="cs">예 »</button></li>
            <ul>
                <li>피연산자가 null이 아니면 멤버 액세스 ?. 또는 요소 액세스 ?[] 연산을 적용한다.</li>
                <li>null이면 그대로 null 반환</li>
                <li>null 조건부 연산자를 연쇄적으로 이용할 때, 중간에서 null이 반환된 경우, 나머지는 처리되지 않는다.</li>
            </ul>
            <li>stackalloc : 값 형식의 배열을 스택에 할당한다. fixed 문으로 고정하지 않아도 된다. 메서드 반환 시 자동 삭제된다; 임의 해제 불가</li>
<pre>int* numbers = stackalloc int[100]; // 포인터는 unsafe 컨텍스트를 사용해야 한다
Span&lt;int&gt; numbers = stackalloc int[100]; // Since C# 7.2 : Span, ReadOnlySpan에 할당 가능
var idx = numbers.IndexOfAny(stackalloc[] { 1, 2, 3, 4 }); // Since C# 8.0 : 다른 식 내부에서 stackalloc 사용 가능</pre>
            <li>?? 연산자 : 좌측 피연산자가 null이면 우측 피연산자를 반환</li>
            <li>??= 연산자 Since C# 8.0 : 왼쪽 피연산자가 null로 평가되는 경우, 오른쪽 피연산자의 값을 대입</li>
            <li>^ 연산자 Since C# 8.0 : 끝부터 시작하는 인덱스</li>
<pre>// 시퀀스 길이가 length인 경우, ^1은 마지막 요소, ^length는 첫번째 요소, ^n은 length - n번째 요소
int[] xs = new[] { 0, 10, 20, 30, 40 };
int last = xs[^1];</pre>
            <li>범위 연산자 .. Since C# 8.0 : start..end // [start, end)</li>
            <ul>
                <li>a.. == a..^0</li>
                <li>..b == 0..b</li>
                <li>.. == 0..^0</li>
            </ul>
<pre>Console.WriteLine($"The last word is {words[^1]}");
var lazyDog = words[^2..^0];
var allWords = words[..]; // contains "The" through "dog".
var firstPhrase = words[..4]; // contains "The" through "fox"
var lastPhrase = words[6..]; // contains "the, "lazy" and "dog"

Range phrase = 1..4;
var text = words[phrase];</pre>
        </ul>
    </details>
    <details>
        <summary>한정자</summary>
        <ul>
            <li>async : 메서드, 람다식, 익명 메서드(delegate 연산자)를 비동기로 지정.</li>
            <ul>
                <li>void 리턴 : await할 수 없으며, 따라서 예외를 catch할 수 없다<br>
                <li>Task, Task&lt;TResult&gt; : await 가능</li>
                <li>Since C# 7.0 : 액세스 가능한 GetAwaiter() 메서드가 있는 모든 형식 리턴 가능</li>
                System.Threading.Tasks.ValueTask&lt;TResult&gt;은 패키지 System.Threading.Tasks.Extensions가 제공하는 구현
            </ul>
            <li>private protected : 동일 어셈블리 내의 클래스 및 파생 클래스에서 엑세스 가능</li>
            <li>ref 매개변수 : 참조 전달. 호출자 스코프의 변수를 그대로 사용하는 효과. 참조가 존재하기 위해 호출 전에 초기화 필요</li>
            <pre>void Method(ref int refArgument)</pre>
            <li>ref 반환 : 참조 반환<br>
                ref 지역 변수 : ref 반환값으로 초기화되는 지역 변수<br>
                Since C# 7.3 : foreach 반복 변수는 ref 또는 ref readonly 지역 변수일 수 있다<br>
                ref readonly 반환 : 반환된 참조에 대한 쓰기는 비허용</li>
<pre>public ref decimal GetCurrentPrice() {
    // ...
    return ref DecimalArray[0];
}
ref decimal estValue = ref GetCurrentPrice();
ref decimal copyValue = ref estValue;</pre>
            <li>in 매개변수 : 참조 전달. 메서드에서 수정 불가</li>
            <li>out 매개변수 : 참조 전달. 호출 전에 초기화되지 않아도 되지만, 반환 전에 할당돼야 한다</li>
<pre>// 선언과 동시에 out 매개변수로 사용 가능
int.TryParse("12", out var result);
int.TryParse("21", out var _); // 출력 무시</pre>
            <li>ref struct : 스택에 할당되는 struct. 클래스의 멤버가 될 수 없다. 인터페이스를 구현할 수 없다<br>
                readonly struct : 모든 필드가 readonly인 struct</li>
            <li>unsafe : unsafe로 한정한 타입, 메서드, 블록에서는 포인터를 사용할 수 있다.</li>
            컴파일 시 -unsafe 옵션을 지정해야 한다 : 비주얼 스튜디오는 "프로젝트 속성 - 빌드 - 안전하지 않은 코드 허용"<br>
            관련 클래스 : System.Runtime.InteropServices.Marshal
        </ul>
    </details>
    <details>
        <summary>메서드</summary>
        <ol>
            <li>매개변수 명시 : Divide(a: 10, b: 3, q: out q, r: out r);</li>
            <li>선택적 매개변수 : Method(int a = 0, int b = 0) {}</li>
            <li>가변 길이 매개변수 params <button class="btn-code" path="Repositories/VisualStudio/CSharp/Basic/ParamsExample.cs" displayRange="[11, 17]" lan="cs">예 »</button></li>
            <li>확장 메서드 : 기존 클래스에 static method 추가됨.<button class="btn-code" path="Repositories/VisualStudio/CSharp/Basic/ExtensionExample.cs" lan="cs">예 »</button></li>
            <li>람다 식 사용 확장 : 생성자, 소멸자, 이벤트 add/remove, 속성 set, 인덱서 set</li>
            <li>메서드 안에 지역 함수 정의 가능</li>
            static 지역 함수로 선언하면 외부 변수 참조 불가
            <li>extern 메서드 : 메서드의 body가 없어도 컴파일 되도록 한다.</li>
            호출할 메서드가 있는 dll을 [DllImport] Attribute로 지정해주면 해당 메서드를 호출한다. http://www.pinvoke.net/
            <li>Caller information</li>
<pre>
static void Log(string text,
                [CalleMemberName] string memberName = "",
                [CallerFilePath] string filePath = "",
                [CallerLineNumber] int lineNumber = 0) { }</pre>
            <li>Main 메서드에 async 허용</li>
        </ol>
    </details>
    <details>
        <summary>구문</summary>
        <ol>
            <li>인덱서 구문 : 하나 이상의 인수로 참조되는 속성을 반환. string, List&lt;T&gt; 등은 인덱서를 구현함. <button class="btn-code" path="Repositories/VisualStudio/CSharp/Basic/IndexerExample.cs" lan="cs">예 »</button></li>
            <li>switch case 필터 Since C# 7.0</li>
<pre>switch(item) {
    case 100:
    case null:
    case DateTime dt:
    case int i when i &gt; 300:
    case var i when i.어쩌구저쩌구():
}</pre>
            <li>전처리 지시문 #define, #undef, #if, #elif, #else, #endif, ..., #region, #endregion</li>
            <li>fixed 문 : unsafe 컨텍스트에서, GC가 변수를 재배치하지 않도록 하여 포인터의 유효함을 보장한다</li>
        </ol>
        <details>
            <summary>yield 반복기</summary>
<pre>public static IEnumerable&lt;int&gt; InfiniteSeries(int limit) {
    var num = 0;
    if(num &lt;= limit)
        yield return ++start;
    yield break;
}

public class Galaxies
{
    public IEnumerable&lt;Galaxy&gt; NextGalaxy
    {
        get
        {
            yield return new Galaxy { Name = "Tadpole", MegaLightYears = 400 };
            yield return new Galaxy { Name = "Pinwheel", MegaLightYears = 25 };
            yield return new Galaxy { Name = "Milky Way", MegaLightYears = 0 };
            yield return new Galaxy { Name = "Andromeda", MegaLightYears = 3 };
        }
    }
}</pre>
        </details>
        <details>
            <summary>LINQ; Language INtegrated Query</summary>
            <ol>
                <button class="btn-code" path="Repositories/VisualStudio/CSharp/Basic/LinqExample.cs" lan="cs">예시 »</button>
                <li>MoreLinq 패키지에서 추가적인 편의성을 제공한다.</li>
                <li>from : LINQ query는 from으로 시작한다. from의 대상은 IEnumarable&lt;T&gt;</li>
                LINQ query 결과도 IEnumerable&lt;T&gt;
                <li>where + bool 판정식</li>
                <li>orderby + 정렬 기준 [(ascending) | descending]</li>
                <li>select + 결과</li>
<pre>from mQuest in Get&lt;MQuest&gt;()
where mQuest.quest_group_id.Equals(mQuestGroup.quest_group_id)
orderby mQuest.quest_name
select mQuest</pre>
                <li>let : LINQ 내에서의 변수 선언; let x = 10</li>
                <li>중첩 질의</li>
<pre>from student in students
from score in student.Scores</pre>
                <li>Grouping : 결과는 IGrouping&lt;T&gt; 형식</li>
<pre>from p in profiles
group p by p.Height &lt; 160 into lowGroup
select new { Key = lowGroup.Key, Profiles = lowGroup };</pre>
                <li>Inner Join</li>
<pre>from a in A
join b in B on a.X equals b.Y</pre>
                <li>Outer Join : inner join 결과를 임시 컬렉션으로 치환하고, 임시 컬렉션의 빈 항목을 기본 값으로</li>
<pre>from profile in profiles
join product in products on profile.Name equals product.Name into result
from product in result.DefaultIfEmpty( new Product() { Title = "없음” } )
select new { Name = profile.Name, Work = product.Title };</pre>
                <li>Expression Tree : System.Linq.Expressions</li>
<pre>var const1 = Expression.Constant(1);
var param1 = Expression.Parameter(typeof(int), "x");
var exp = Expression.Add(const1, param1);
var lambda = Expression&lt;Func&lt;int, int&gt;&gt;.Lambda&lt;Func&lt;int, int&gt;&gt;(exp, new ParameterExpression[] { (ParameterExpression)param1 });
var compiledFunc = lambda.Compile();
Console.WriteLine(compiledFunc(3));</pre>
            </ol>
        </details>
    </details>
    <details>
        <summary>Attribute</summary>
        <ol>
                <li>자바의 애너테이션처럼 요소를 장식한다.
                    <button class="btn-code" path="Repositories/VisualStudio/CSharp/Basic/AttributeExample.cs" lan="cs">AttributeExample.cs 전체 코드 »</button></li>
                <li>사용자 정의 특성은 System.Attribute를 상속하여 만든다.
                    <button class="btn-code" path="Repositories/VisualStudio/CSharp/Basic/AttributeExample.cs" displayRange="[12, 19]" lan="cs">예 »</button></li>
                <li>명명시 Attribute를 접미하고, 실제 사용할 땐 생략 가능하다.
                    <button class="btn-code" path="Repositories/VisualStudio/CSharp/Basic/AttributeExample.cs" displayRange="[21, 24]" lan="cs">예 »</button></li>
                <li>특성 적용 대상 제한 : System.AttributeUsage 생성자에 AttributeTargets 전달. 생략시 기본값은 AttributeTargets.All
                    <button class="btn-code" path="Repositories/VisualStudio/CSharp/Basic/AttributeExample.cs" displayRange="[12, 13]" lan="cs">예 »</button></li>
                <li>적용 대상 명시 : assembly, module, type, method, property, field, event, param, return, typevar
                    <button class="btn-code" path="Repositories/VisualStudio/CSharp/Basic/AttributeExample.cs" displayRange="[23, 24]" lan="cs">예 »</button></li>
        </ol>
    </details>
    <details>
        <summary>App.config</summary>
        <ol>
            <li>supportedRuntime</li>
            실행에 필요한 닷넷 버전 지정. 비주얼 스튜디오가 자동으로 추가해주는듯
            <button class="btn-code" path="Repositories/VisualStudio/CSharp/Basic/App.config" lan="xml">App.config »</button>
            <li>appSettings</li>
            <button class="btn-code" path="Repositories/VisualStudio/CSharp/Basic/App.config" lan="xml">App.config »</button>
            <button class="btn-code" path="Repositories/VisualStudio/CSharp/Basic/Program.cs" lan="cs">Program.cs »</button>
        </ol>
    </details>
    <details>
        <summary>디버그 모드</summary>
        <ol>
            <li>전처리 상수 #if DEBUG ... #endif</li>
            <li>[Conditional("DEBUG")] 적용된 클래스, 메서드는 릴리스 빌드 시 포함되지 않는다</li>
            <li>System.Diagnostics.Debug.WriteLine() : 디버그 출력</li>
        </ol>
    </details>
    <details>
        <summary>Reflection 리플렉션</summary>
        <ul>
            <li>AppDomain → Assembly ← Module ← Type</li>
            AppDomain : EXE 프로세스 내에서 CLR에 의해 구현된 격리 공간. 최초 실행 시 기본적으로 1개 생성(AppDomain.CurrentDomain).
            static 멤버들은 AppDomain 안에서 유일하다. 프로세스의 여러 AppDomain에서 동일한 클래스를 로드했다면 static 멤버들은 각 도메인마다 하나씩 존재
<pre>var appDomain = AppDomain.CreateDomain("MyDomain");
ObjectHandle handle = appDomain.CreateInstanceFrom(dllPath, "Namespace.ClassName");
...
AppDomain.Unload(appDomain);</pre>
            <li>Object.getType() or typeof 연산자</li>
            <li>Type :: GetConstructors(), GetEvents(), GetFields(), GetMethods(), ...</li>
            <li>동적 생성 : System.Activator.CreateInstance(Type);</li>
            <li>동적 타입 정의 : System.Reflection.Emit</li>
            <ol>
                <li>System.AppDomain.DefineDynamicAssembly()로 AssemblyBuilder 객체 획득</li>
                <li>AssemblyBuilder.DefineDynamicModule()로 ModuleBuilder 획득</li>
                <li>ModuleBuilder.DefineType()으로 클래스 생성(TypeBuilder)</li>
                <li>TypeBuilder.DefineMethod()로 MethodBuilder 획득</li>
                <li>MethodBuilder.GetILGenerator()로 ILGenerator 객체 획득</li>
                <li>ILGenerator.Emit()으로 메서드 내용 추가</li>
                <li>TypeBuilder.CrateType()으로 인스턴스 생성 가능</li>
            </ol>
        </ul>
    </details>
    <details>
        <summary>재귀 패턴 매칭 Since C# 8.0</summary>
<pre>int? x = null;
if (x is int n1)
    Console.WriteLine(n1);
else
    Console.WriteLine("Not a int");

x = 3;
if (x is int n2)
    Console.WriteLine(n2);</pre>
<pre>var (a, b) = (1, 2);
switch(a, b)
{
    case (0, _):
        Console.WriteLine("a is 0");
        break;
    case (1, _):
        Console.WriteLine("a is 1");
        break;
}</pre>
<pre>public static bool IsComplete(int n) =&gt;
    n switch
    {
        6 =&gt; true,
        28 =&gt; true,
        496 =&gt; true,
        8128 =&gt; true,
        33550336 =&gt; true,
        _ =&gt; false
    };</pre>
<pre>public static bool IsComplete(int n) =&gt;
    n switch
    {
        int x when new int[] { 6, 28, 496, 8128, 33550336 }.Contains(x) =&gt; true,
        _ =&gt; false
    };</pre>
<pre>var newState = (GetState(), action, hasKey) switch {
    (DoorState.Closed, Action.Open, _) =&gt; DoorState.Opened,
    (DoorState.Opened, Action.Close, _) =&gt; DoorState.Closed,
    (DoorState.Closed, Action.Lock, true) =&gt; DoorState.Locked,
    (DoorState.Locked, Action.Unlock, true) =&gt; DoorState.Closed,
    (var state, _, _) =&gt; state };</pre>
<pre>var msg = "Hello";
if (msg is string { Length: 5 } five)
    Console.WriteLine($"Right. {msg} is a 5 length string");</pre>
<pre>public static decimal ComputeSalesTax(Address location, decimal salePrice) =&gt;
    location switch {
        { State: "WA" } =&gt; salePrice * 0.06M,
        { State: "MI" } =&gt; salePrice * 0.05M,
        _ =&gt; 0M
    };</pre>
<pre>static Quadrant GetQuadrant(Point point) =&gt; point switch {
        (0, 0) =&gt; Quadrant.Origin,
        var (x, y) when x &gt; 0 && y &gt; 0 =&gt; Quadrant.One,
        var (x, y) when x &lt; 0 && y &gt; 0 =&gt; Quadrant.Two,
        var (x, y) when x &lt; 0 && y &lt; 0 =&gt; Quadrant.Three,
        var (x, y) when x &gt; 0 && y &lt; 0 =&gt; Quadrant.Four,
        var (_, _) =&gt; Quadrant.OnBorder,
        _ =&gt; Quadrant.Unknown
    };</pre>
    </details>
</details>

<hr>

<details>
    <summary>.NET 정규표현식</summary>
    <ul>
        Java와 동일한 부분은 생략
        <li>\nn 또는 \nnn : 8진수 ASCII</li>
        <li>\w : \p{L} | \p{Mn} | \p{Nd} | \p{Pc}</li>
        <li>\Z : \z | (?=\n)</li>
        <li>(?&lt;name&gt;X) == (?'name'X)</li>
        <ul>
            <li>\k'name'역참조 가능. replace에서 ${name}참조 가능, GroupCollection의 인덱서로 참조 가능</li>
            <li>그룹 오버로딩 가능 : (?&lt;1&gt;a)(?&lt;1&gt;\1b) // 스택처럼 정의가 쌓이며 '-name'으로 가장 최근 정의 삭제 가능</li>
        </ul>
        <li>균형 조정 그룹; Balancing group</li>
        <ul>
            <li>(?&lt;name1-name2&gt;X) == (?'name1-name2'X)</li>
            name1은 현재 그룹(Optional)이고, name2는 이전에 정의된 그룹. 균형 조정 그룹은 마지막(백트래킹) name2 정의를 삭제하고, name1에 name2와 name1 사이 간격을 저장한다.
<pre>var html = "&lt;html&gt;&lt;body&gt;Hello&lt;p&gt;World&lt;/p&gt;olleH&lt;/body&gt;&lt;/html&gt;Plain Text&lt;script&gt;console.log('hello world');&lt;/script&gt;Plain Text&lt;yes&gt;Text&lt;/no&gt;";
Console.WriteLine($"All text : {html}");
foreach (Match match in Regex.Matches(html, @"&lt;(?'tag'\w+)&gt;(.(?&lt;!&lt;/\k&lt;tag&gt;&gt;))*(?'-tag'&lt;/\k&lt;tag&gt;&gt;)", RegexOptions.IgnoreCase))
    Console.WriteLine($"HTML part : {match.Groups[0]}");

// All text : &lt;html&gt;&lt;body&gt;Hello&lt;p&gt;World&lt;/p&gt;olleH&lt;/body&gt;&lt;/html&gt;Plain Text&lt;script&gt;console.log('hello world');&lt;/script&gt;Plain Text&lt;yes&gt;Text&lt;/no&gt;
// HTML part : &lt;html&gt;&lt;body&gt;Hello&lt;p&gt;World&lt;/p&gt;olleH&lt;/body&gt;&lt;/html&gt;
// HTML part : &lt;script&gt;console.log('hello world');&lt;/script&gt;
</pre>
        </ul>
        <li>옵션</li>
        <ul>
            <li>(?imnsx-imnsx:X) // X 내에 옵션 적용/비적용. 이 자체는 캡처링 그룹이 아님</li>
            <li>(?imnsx-imnsx) // 이후 식에 옵션 적용/비적용</li>
            <li>System.Text.RegularExpressions.RegexOptions // Regex 생성자 또는 정적 메서드에 전체 옵션 지정</li>
            <table>
                <tr><td>IgnoreCase</td><td>i</td><td>대소문자 구별X</td></tr>
                <tr><td>Multiline</td><td>m</td><td>^, $이 \n에서도 동작</td></tr>
                <tr><td>ExplicitCapture</td><td>n</td><td>명명된 캡처링 그룹만 유효</td></tr>
                <tr><td>Singleline</td><td>s</td><td>.이 \n포함</td></tr>
                <tr><td>IgnorePatternWhitespace</td><td>x</td><td>이스케이프되지 않은 공백을 패턴에서 제거하고 주석을 #으로 표시 가능</td></tr>
                <tr><td>Compiled</td><td></td><td>어셈블리로 컴파일</td></tr>
                <tr><td>RightToLeft</td><td></td><td>우→좌 검색</td></tr>
                <tr><td>ECMAScript</td><td></td><td></td></tr>
                <tr><td>CultureInvariant</td><td></td><td></td></tr>
                <tr><td>None</td><td></td><td>옵션 없음 명시</td></tr>
            </table>
        </ul>
        <li>(?&gt;X) : Non-backtracking</li>
        <li>Replace 구문</li>
        <ul>
            <li>$n, ${name} : 캡처링 그룹</li>
            <li>$&amp; : 전체 매칭 문자열</li>
            <li>$` : 매칭 문자열 앞부분</li>
            <li>$' : 매칭 문자열 뒷부분</li>
            <li>$+ : 마지막 캡처링 그룹</li>
            <li>$_ : 전체 입력 문자열</li>
        </ul>
        <li>인라인 주석 : (?#comment)</li>
    </ul>
    <details>
        <summary>지원 Unicode class : \p{name} ↔ \P{name}</summary>
        <table>
            <tr><th>Category</th><th>Description</th></tr>
            <tr><td>Lu</td><td>Letter, Uppercase</td></tr>
            <tr><td>Ll</td><td>Letter, Lowercase</td></tr>
            <tr><td>Lt</td><td>Letter, Titlecase</td></tr>
            <tr><td>Lm</td><td>Letter, Modifier</td></tr>
            <tr><td>Lo</td><td>Letter, Other</td></tr>
            <tr><td>L</td><td>Lu + Ll + Lt + Lm + Lo</td></tr>
            <tr><td>Mn</td><td>Mark, Nonspacing</td></tr>
            <tr><td>Mc</td><td>Mark, Spacing Combining</td></tr>
            <tr><td>Me</td><td>Mark, Enclosing</td></tr>
            <tr><td>M</td><td>Mn + Mc + Me</td></tr>
            <tr><td>Nd</td><td>Number, Decimal Digit</td></tr>
            <tr><td>Nl</td><td>Number, Letter</td></tr>
            <tr><td>No</td><td>Number, Other</td></tr>
            <tr><td>N</td><td>Nd + Nl + No</td></tr>
            <tr><td>Pc</td><td>Punctuation, Connector</td></tr>
            <tr><td>Pd</td><td>Punctuation, Dash</td></tr>
            <tr><td>Ps</td><td>Punctuation, Start[Open]</td></tr>
            <tr><td>Pe</td><td>Punctuation, End[Close]</td></tr>
            <tr><td>Pi</td><td>Punctuation, Initial quote</td></tr>
            <tr><td>Pf</td><td>Punctuation, Final quote</td></tr>
            <tr><td>Po</td><td>Punctuation, Other</td></tr>
            <tr><td>P</td><td>Pc + Pd + Ps + Pe + Pi + Pf + Po</td></tr>
            <tr><td>Sm</td><td>Symbol, Math</td></tr>
            <tr><td>Sc</td><td>Symbol, Currency</td></tr>
            <tr><td>Sk</td><td>Symbol, Modifier</td></tr>
            <tr><td>So</td><td>Symbol, Other</td></tr>
            <tr><td>S</td><td>Sm + Sc + Sk + So</td></tr>
            <tr><td>Zs</td><td>Separator, Space</td></tr>
            <tr><td>Zl</td><td>Separator, Line</td></tr>
            <tr><td>Zp</td><td>Separator, Paragraph</td></tr>
            <tr><td>Z</td><td>Zs + Zl + Zp</td></tr>
            <tr><td>Cc</td><td>Other, Control</td></tr>
            <tr><td>Cf</td><td>Other, Format</td></tr>
            <tr><td>Cs</td><td>Other, Surrogate</td></tr>
            <tr><td>Co</td><td>Other, Private Use</td></tr>
            <tr><td>Cn</td><td>Other, Not Assigned</td></tr>
            <tr><td>C</td><td>Cc + Cf + Cs + Co + Cn</td></tr>
        </table>
        <table>
            <tr><th>Code point range</th><th>Block name</th></tr>
            <tr><td>0000 - 007F</td><td>IsBasicLatin</td></tr>
            <tr><td>0080 - 00FF</td><td>IsLatin-1Supplement</td></tr>
            <tr><td>0100 - 017F</td><td>IsLatinExtended-A</td></tr>
            <tr><td>0180 - 024F</td><td>IsLatinExtended-B</td></tr>
            <tr><td>0250 - 02AF</td><td>IsIPAExtensions</td></tr>
            <tr><td>02B0 - 02FF</td><td>IsSpacingModifierLetters</td></tr>
            <tr><td>0300 - 036F</td><td>IsCombiningDiacriticalMarks</td></tr>
            <tr><td>0370 - 03FF</td><td>IsGreek or IsGreekandCoptic</td></tr>
            <tr><td>0400 - 04FF</td><td>IsCyrillic</td></tr>
            <tr><td>0500 - 052F</td><td>IsCyrillicSupplement</td></tr>
            <tr><td>0530 - 058F</td><td>IsArmenian</td></tr>
            <tr><td>0590 - 05FF</td><td>IsHebrew</td></tr>
            <tr><td>0600 - 06FF</td><td>IsArabic</td></tr>
            <tr><td>0700 - 074F</td><td>IsSyriac</td></tr>
            <tr><td>0780 - 07BF</td><td>IsThaana</td></tr>
            <tr><td>0900 - 097F</td><td>IsDevanagari</td></tr>
            <tr><td>0980 - 09FF</td><td>IsBengali</td></tr>
            <tr><td>0A00 - 0A7F</td><td>IsGurmukhi</td></tr>
            <tr><td>0A80 - 0AFF</td><td>IsGujarati</td></tr>
            <tr><td>0B00 - 0B7F</td><td>IsOriya</td></tr>
            <tr><td>0B80 - 0BFF</td><td>IsTamil</td></tr>
            <tr><td>0C00 - 0C7F</td><td>IsTelugu</td></tr>
            <tr><td>0C80 - 0CFF</td><td>IsKannada</td></tr>
            <tr><td>0D00 - 0D7F</td><td>IsMalayalam</td></tr>
            <tr><td>0D80 - 0DFF</td><td>IsSinhala</td></tr>
            <tr><td>0E00 - 0E7F</td><td>IsThai</td></tr>
            <tr><td>0E80 - 0EFF</td><td>IsLao</td></tr>
            <tr><td>0F00 - 0FFF</td><td>IsTibetan</td></tr>
            <tr><td>1000 - 109F</td><td>IsMyanmar</td></tr>
            <tr><td>10A0 - 10FF</td><td>IsGeorgian</td></tr>
            <tr><td>1100 - 11FF</td><td>IsHangulJamo</td></tr>
            <tr><td>1200 - 137F</td><td>IsEthiopic</td></tr>
            <tr><td>13A0 - 13FF</td><td>IsCherokee</td></tr>
            <tr><td>1400 - 167F</td><td>IsUnifiedCanadianAboriginalSyllabics</td></tr>
            <tr><td>1680 - 169F</td><td>IsOgham</td></tr>
            <tr><td>16A0 - 16FF</td><td>IsRunic</td></tr>
            <tr><td>1700 - 171F</td><td>IsTagalog</td></tr>
            <tr><td>1720 - 173F</td><td>IsHanunoo</td></tr>
            <tr><td>1740 - 175F</td><td>IsBuhid</td></tr>
            <tr><td>1760 - 177F</td><td>IsTagbanwa</td></tr>
            <tr><td>1780 - 17FF</td><td>IsKhmer</td></tr>
            <tr><td>1800 - 18AF</td><td>IsMongolian</td></tr>
            <tr><td>1900 - 194F</td><td>IsLimbu</td></tr>
            <tr><td>1950 - 197F</td><td>IsTaiLe</td></tr>
            <tr><td>19E0 - 19FF</td><td>IsKhmerSymbols</td></tr>
            <tr><td>1D00 - 1D7F</td><td>IsPhoneticExtensions</td></tr>
            <tr><td>1E00 - 1EFF</td><td>IsLatinExtendedAdditional</td></tr>
            <tr><td>1F00 - 1FFF</td><td>IsGreekExtended</td></tr>
            <tr><td>2000 - 206F</td><td>IsGeneralPunctuation</td></tr>
            <tr><td>2070 - 209F</td><td>IsSuperscriptsandSubscripts</td></tr>
            <tr><td>20A0 - 20CF</td><td>IsCurrencySymbols</td></tr>
            <tr><td>20D0 - 20FF</td><td>IsCombiningDiacriticalMarksforSymbols or IsCombiningMarksforSymbols</td></tr>
            <tr><td>2100 - 214F</td><td>IsLetterlikeSymbols</td></tr>
            <tr><td>2150 - 218F</td><td>IsNumberForms</td></tr>
            <tr><td>2190 - 21FF</td><td>IsArrows</td></tr>
            <tr><td>2200 - 22FF</td><td>IsMathematicalOperators</td></tr>
            <tr><td>2300 - 23FF</td><td>IsMiscellaneousTechnical</td></tr>
            <tr><td>2400 - 243F</td><td>IsControlPictures</td></tr>
            <tr><td>2440 - 245F</td><td>IsOpticalCharacterRecognition</td></tr>
            <tr><td>2460 - 24FF</td><td>IsEnclosedAlphanumerics</td></tr>
            <tr><td>2500 - 257F</td><td>IsBoxDrawing</td></tr>
            <tr><td>2580 - 259F</td><td>IsBlockElements</td></tr>
            <tr><td>25A0 - 25FF</td><td>IsGeometricShapes</td></tr>
            <tr><td>2600 - 26FF</td><td>IsMiscellaneousSymbols</td></tr>
            <tr><td>2700 - 27BF</td><td>IsDingbats</td></tr>
            <tr><td>27C0 - 27EF</td><td>IsMiscellaneousMathematicalSymbols-A</td></tr>
            <tr><td>27F0 - 27FF</td><td>IsSupplementalArrows-A</td></tr>
            <tr><td>2800 - 28FF</td><td>IsBraillePatterns</td></tr>
            <tr><td>2900 - 297F</td><td>IsSupplementalArrows-B</td></tr>
            <tr><td>2980 - 29FF</td><td>IsMiscellaneousMathematicalSymbols-B</td></tr>
            <tr><td>2A00 - 2AFF</td><td>IsSupplementalMathematicalOperators</td></tr>
            <tr><td>2B00 - 2BFF</td><td>IsMiscellaneousSymbolsandArrows</td></tr>
            <tr><td>2E80 - 2EFF</td><td>IsCJKRadicalsSupplement</td></tr>
            <tr><td>2F00 - 2FDF</td><td>IsKangxiRadicals</td></tr>
            <tr><td>2FF0 - 2FFF</td><td>IsIdeographicDescriptionCharacters</td></tr>
            <tr><td>3000 - 303F</td><td>IsCJKSymbolsandPunctuation</td></tr>
            <tr><td>3040 - 309F</td><td>IsHiragana</td></tr>
            <tr><td>30A0 - 30FF</td><td>IsKatakana</td></tr>
            <tr><td>3100 - 312F</td><td>IsBopomofo</td></tr>
            <tr><td>3130 - 318F</td><td>IsHangulCompatibilityJamo</td></tr>
            <tr><td>3190 - 319F</td><td>IsKanbun</td></tr>
            <tr><td>31A0 - 31BF</td><td>IsBopomofoExtended</td></tr>
            <tr><td>31F0 - 31FF</td><td>IsKatakanaPhoneticExtensions</td></tr>
            <tr><td>3200 - 32FF</td><td>IsEnclosedCJKLettersandMonths</td></tr>
            <tr><td>3300 - 33FF</td><td>IsCJKCompatibility</td></tr>
            <tr><td>3400 - 4DBF</td><td>IsCJKUnifiedIdeographsExtensionA</td></tr>
            <tr><td>4DC0 - 4DFF</td><td>IsYijingHexagramSymbols</td></tr>
            <tr><td>4E00 - 9FFF</td><td>IsCJKUnifiedIdeographs</td></tr>
            <tr><td>A000 - A48F</td><td>IsYiSyllables</td></tr>
            <tr><td>A490 - A4CF</td><td>IsYiRadicals</td></tr>
            <tr><td>AC00 - D7AF</td><td>IsHangulSyllables</td></tr>
            <tr><td>D800 - DB7F</td><td>IsHighSurrogates</td></tr>
            <tr><td>DB80 - DBFF</td><td>IsHighPrivateUseSurrogates</td></tr>
            <tr><td>DC00 - DFFF</td><td>IsLowSurrogates</td></tr>
            <tr><td>E000 - F8FF</td><td>IsPrivateUse or IsPrivateUseAreaIsPrivateUse or IsPrivateUseArea</td></tr>
            <tr><td>F900 - FAFF</td><td>IsCJKCompatibilityIdeographs</td></tr>
            <tr><td>FB00 - FB4F</td><td>IsAlphabeticPresentationForms</td></tr>
            <tr><td>FB50 - FDFF</td><td>IsArabicPresentationForms-A</td></tr>
            <tr><td>FE00 - FE0F</td><td>IsVariationSelectors</td></tr>
            <tr><td>FE20 - FE2F</td><td>IsCombiningHalfMarks</td></tr>
            <tr><td>FE30 - FE4F</td><td>IsCJKCompatibilityForms</td></tr>
            <tr><td>FE50 - FE6F</td><td>IsSmallFormVariants</td></tr>
            <tr><td>FE70 - FEFF</td><td>IsArabicPresentationForms-B</td></tr>
            <tr><td>FF00 - FFEF</td><td>IsHalfwidthandFullwidthForms</td></tr>
            <tr><td>FFF0 - FFFF</td><td>IsSpecials</td></tr>
        </table>
    </details>
</details>

<hr>