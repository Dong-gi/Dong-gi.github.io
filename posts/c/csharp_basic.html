<hr>

<details>
    <summary>.NET Framework 개요</summary>
    <ul>
        <li>프레임워크</li>
        제어 역전이 있는 대규모 라이브러리. 프로그램의 초기화부터 종료까지 직접 관리하며, 개발자는 일부분만 작성.

        <li>CLI; Common Language Infrastructure</li>
        닷넷 표준 규약. 자바와 마찬가지로 CLI 사양을 준수한 구현체에서 동작하는 파일은 다른 구현체에서도 실행된다.
        <ul>
            <li>CIL; Common Intermediate Language == IL. 중간 언어</li>
            IL은 자체 문법을 가지며 ILASM.EXE라는 전용 컴파일러도 있다.

            <li>CTS; Common Type System</li>
            닷넷 언어가 지켜야 할 타입의 표준. 전체를 구현하진 않아도 된다.

            <li>CLS; Common Language Specification</li>
            닷넷 언어가 지켜야 하는 최소 사양

            <li>메타데이터</li>
            실행 파일(exe/dll)은 외부에서 리플렉션을 통해 접근할 수 있는 메타데이터를 제공한다.

            <li>어셈블리</li>
            exe/dll 실행파일을 어셈블리라고 부른다.

            <li>모듈</li>
            어셈블리는 1개 이상의 모듈로 구성되며, 하나의 모듈은 하나의 파일에 대응된다.

            <li>매니페스트</li>
            여러 모듈이 하나의 어셈블리를 구성하는 경우, 모듈 중 하나는 모듈의 목록을 관리하는 매니페스트 데이터를 갖는다. 매니페스트를 포함하는 경우 확장자는 exe/dll, 그 외의 모듈은 보통
            netmodule이지만, 일반적으로 모든 어셈블리는 1개의 파일로 구성된다.
        </ul>

        <li>닷넷 구현체</li>
        <ul>
            <li>.NET Framework</li>
            CLR; Common Language Runtime + BCL; Base Class Library<br>
            CLR : CLI를 구현한 가상 머신. 중간 언어를 JIT 컴파일러를 이용해 기계어로 변환하고, GC를 운용한다.

            <li>.NET Core</li>
            CoreCLR + Core Library<br>
            윈도우, macOS, 리눅스에서 실행 가능

            <li>Mono</li>
            현재는 자마린에서 개발 중. 윈도우, macOS, 리눅스, 솔라리스, 안드로이드, 엑스박스 360 등에서 실행 가능
        </ul>
    </ul>
</details>

<hr>

<details>
    <summary>개발 환경</summary>
    <ol>
        <li>윈도우에는 기본적으로 닷넷 프레임워크가 설치돼있다. 또는 비주얼 스튜디오 설치 시 같이 설치된다.</li>
        <li>C# 컴파일러 : C:\Windows\Microsoft.NET\...\csc.exe</li>
        <li>닷넷 역컴파일러 : .NET Reflector(유료), JustDecompile(무료) 등</li>
        <li>IDE : Visual Studio, Visual Studio for Mac, Visual Studio Code, Xamarin Studio, Rider</li>
    </ol>
</details>

<hr>

<details>
    <summary>문법</summary>
    <details>
        <summary>기본 자료형</summary>
        <ul>
            <li>정수형</li>
            <table>
                <tr>
                    <td>sbyte</td>
                    <td>signed byte</td>
                    <td>System.Sbyte</td>
                </tr>
                <tr>
                    <td>byte</td>
                    <td>unsigned byte</td>
                    <td>System.Byte</td>
                </tr>
                <tr>
                    <td>short</td>
                    <td>signed 2bytes</td>
                    <td>System.Int16</td>
                </tr>
                <tr>
                    <td>ushort</td>
                    <td>unsigned short</td>
                    <td>System.UInt16</td>
                </tr>
                <tr>
                    <td>int</td>
                    <td>signed 4bytes</td>
                    <td>System.Int32</td>
                </tr>
                <tr>
                    <td>uint</td>
                    <td>unsigned int</td>
                    <td>System.UInt32</td>
                </tr>
                <tr>
                    <td>long</td>
                    <td>signed 8bytes</td>
                    <td>System.Int64</td>
                </tr>
                <tr>
                    <td>ulong</td>
                    <td>unsigned long</td>
                    <td>System.UInt64</td>
                </tr>
            </table>

            <li>실수형</li>
            <table>
                <tr>
                    <td>float</td>
                    <td>4바이트. 리터럴 접미사 f</td>
                    <td>System.Single</td>
                </tr>
                <tr>
                    <td>double</td>
                    <td>8바이트</td>
                    <td>System.Double</td>
                </tr>
                <tr>
                    <td>decimal</td>
                    <td>16바이트. 리터럴 접미사 m</td>
                    <td>System.Decimal</td>
                </tr>
            </table>

            <li>숫자 리터럴</li>
            16진수 표현 0xFFFF, 2진수 표현 0b1010, 구분 문자 '_' 사용 가능

            <li>문자형</li>
            <table>
                <tr>
                    <td>char</td>
                    <td>2바이트(유니코드)</td>
                    <td>System.Char</td>
                </tr>
                <tr>
                    <td>string</td>
                    <td>동적 크기. Indexer 구현</td>
                    <td>System.String</td>
                </tr>
            </table>

            <li>문자열 리터럴</li>
            <ul>
                <li>@"" : \ 이스케이프를 하지 않는다. ""로 일반 문자열의 \"를 대신할 수 있다</li>
                <li>$"" Since C# 6 : 간편한 포맷 문자열을 제공한다. {<i>표현식</i>[, <i>alignment</i>][: <i>formatString</i>]}
                    <button class="btn-code" path="Repositories/VisualStudio/csharp_interpolated_string.cs" lan="java">예시 코드 »</button></li>
                <li>Since C# 8 : @$"", $@"" 모두 유효. 이전에는 $@""만 가능</li>
            </ul>

            <li>Boolean</li>
            <table>
                <tr>
                    <td>bool</td>
                    <td>true or false</td>
                    <td>System.Boolean</td>
                </tr>
            </table>

            <li>Boolean 연산 &&, ||는 Short-circuit</li>
        </ul>
    </details>

    <details>
        <summary>배열</summary>
        <ul>
            <li>배열 초기화시 기본값으로 채워진다.</li>
            <li>다차원 배열 [,] : 배열 차원 고정. 메모리 상에서는 일차원 배열처럼 존재.</li>
            <li>Jagged Array [][] : 배열의 차원이 가변적</li>
<pre>int[] arr1 = new int[3];
int[] arr2 = new int[] { 1, 2, 3 };
int[] arr3 = { 1, 2, 3 };
int[,] arr4 = new int[2, 2];
int[,] arr5 = new int[,] { { 1, 2 }, { 3, 4 } };</pre>
        </ul>
    </details>

    <details>
        <summary>형변환</summary>
        <ul>
            <li>암시적 형변환 : 보다 큰 정의의 자료형으로 자동 변환.</li>
            Boxing : Value type 데이터를 Reference type으로 변환. 컴파일러가 묵시적으로 수행.
            <li>명시적 변환 : 괄호 이용.</li>
            Unboxing : Reference type 데이터를 Value type으로 변환. 캐스팅을 통해 명시적으로 수행.
            <li>as 연산자를 이용한 명시적 변환은, null을 허용하는 참조 자료형만 가능하다.</li>
        </ul>
    </details>

    <details>
        <summary>구문</summary>
        <ul>
            <li>if ~ else if ~ else</li>
            <li>switch</li>
            정수, bool, char, string, enum에 대해 동작. case문 다음이 빈 문장일 때만 break 생략 가능
            <li>while, do ~ while</li>
            <li>for(초기식; 조건식; 증감식)</li>
            <li>foreach(var obj in IEnumerable)</li>
            <li>점프</li>
            break, continue, goto(관례상 레이블은 대문자로만), return, throw
            <li>checked/unchecked 블록</li>
            기본적으로는 프로그램 실행 시 오버플로/언더플로를 무시한다.<br>
            checked/unchecked 블록은 이를 각각 명시적인 예외로 처리/비처리 하도록 한다.
            <button class="btn-code" path="Repositories/VisualStudio/CSharp/Basic/CheckedExample.cs" displayRange="[13, 39]" lan="cs">예시 코드 »</button>
        </ul>
    </details>

    <details>
        <summary>네임스페이스</summary>
<pre>namespace MyProgram.Model { }
using System.Collections.Generic;
using static MyProgram.Model.Constants;</pre>
    </details>
</details>

<hr>

<details>
    <summary>객체지향</summary>
    <details>
        <summary>클래스</summary>
        <ul>
            <li>프로퍼티 → 히든 필드 + getter/setter
                <button class="btn-code" path="Repositories/VisualStudio/csharp_property.cs" lan="java">ViewModel에서의 사용 예 »</button></li>

            <li>익명 객체 → new { PropertyName = value } : 생성 후 읽기만 가능</li>

            <li>정적 생성자 → static 클래스이름() { }</li>
            첫 번째 인스턴스가 만들어지거나 정적 멤버가 참조되기 전에 자동으로 호출된다.

            <li>partial class ClassName {} : 프로젝트 내 여러 파일에 걸쳐 클래스 작성 가능</li>

            <li>접근 제한자 → public, protected(파생 클래스까지), private, internal(같은 어셈블리), protected internal</li>

            <li>상속</li>
            <ul>
                <li>class SubClass : BaseClass</li>
                <li>is 연산자로 호환 여부 확인 가능</li>
                <li>this 키워드 : 클래스의 현재 인스턴스<br>
                    base 키워드 : 부모 클래스 메서드 또는 생성자 호출
                    <button class="btn-code" path="Repositories/VisualStudio/csharp_base_keyword.cs" lan="java">예 »</button></li>
                <li>sealed 키워드 → 상속/재정의 불가</li>
                <li>부모 클래스 인스턴스를 자식 클래스로 다운캐스팅 불가.</li>
                <li>모든 자료형의 조상은 System.Object : ToString(), GetType(), Equals(), GetHashCode()<br>
                    모든 값 형식의 조상은 System.ValueType<br>
                    모든 배열의 조상은 System.Array : Sort(), BinarySearch&lt;T&gt;(), IndexOf(), ..., Length, Rank</li>
            </ul>

            <li>다형성</li>
            <ul>
                <li>virtual, override 키워드를 사용해 명시한다. virtual 메서드는 body를 정의해야 한다.</li>
                <li>new : 부모 메서드 숨기기. override와 달리 형 변환을 통해 부모 메서드에 접근 가능.</li>
                <li>abstract class : 인스턴스화 불가능<br>
                    abstract method : 서브 클래스에서 반드시 override</li>
                <li>연산자 오버로딩</li>
                <pre>public static 반환타입 operator 연산자(타입1 변수1, 타입2 변수2) {}</pre>
                <li>형 변환 정의</li>
<pre>public static implicit operator 타입2(타입1 변수1) {};
public static explicit operator 타입2(타입1 변수1) {};</pre>
            </ul>
        </ul>
    </details>

    <details>
        <summary>델리게이트</summary>
        <ul>
            <li>메서드를 참조하는 자료형
                <button class="btn-code" path="Repositories/VisualStudio/CSharp/Basic/DelegateExample.cs" displayRange="[12, 47]" lan="cs">예시 »</button></li>

            <li>델리게이트로 변환될 수 있는 익명 메서드 생성</li>
            <ol>
                <li>delegate 연산자 → delegate (int a, int b) { return a + b; }</li>
                <li>람다 Since C# 3 → (a, b) => a + b;</li> 
            </ol>

            <li>델리게이트에는 BeginInvoke 및 EndInvoke 메서드가 자동으로 추가되며, 이를 통해 임의 메서드를 비동기 호출할 수 있다</li>
            <button class="btn-code" path="Repositories/VisualStudio/CSharp/Basic/DelegateExample.cs" displayRange="[12, 22, 49, 64]" lan="cs">비동기 호출 예 »</button>
            <button class="btn-code" path="Repositories/VisualStudio/CSharp/Basic/DelegateExample.cs" displayRange="[12, 22, 66, 86]" lan="cs">비동기 호출 대기 예 »</button>

            <li>델리게이트 체인</li>
            myDelegate += obj.Func;<br>
            myDelegate -= obj.Func;

            <li>Func</li>
            결과를 반환하는 메서드를 참조하는, 미리 정의된 델리게이트. 매개변수 0 ~ 16개, 총 17가지.

            <li>Action</li>
            void 리턴 메서드를 참조하는, 미리 정의된 델리게이트. 매개변수 0 ~ 16개, 총 17가지.

            <li>이벤트</li>
            <ol>
                <li>일반화된 델리게이트. 간단하게 구독/해지 가능. 클래스 밖에서 호출 불가.</li>
                <li>이벤트의 첫 번째 인자는 이벤트 발생 객체. 두 번째 인자는 EventArgs 호환 객체.</li>
                <li>public event EventHandler SomeEvent = delegate { };<button class="btn-code" path="Repositories/VisualStudio/CSharp/Basic/EventExample.cs" lan="cs">예시 코드 »</button></li>
            </ol>
        </ul>
    </details>

    <details>
        <summary>인터페이스</summary>
        <ol>
            <li>인터페이스도 프로퍼티를 가질 수 있다(get/set 지정만 가능). 구현하는 클래스에서 프로퍼티를 구현한다.</li>
            <li>class SubClass : BaseClass, Interface1, Interface2, ...</li>
            <li>interface Interface1 : Interface2</li>
        </ol>
    </details>

    <details>
        <summary>구조체 struct</summary>
        <ol>
            <li>사용자 정의 ValueType.</li>
            <li>ValueType이므로 생성자 호출 없이 선언만으로 초기화가 진행된다. 사용되는 기본 생성자는 컴파일러가 자동으로 추가하며, 재정의할 수 없다.</li>
            <li>모든 타입은 Object의 파생 클래스이므로, 구조체도 new 키워드로 인스턴스를 생성할 수 있다. 인자를 받는 생성자는 모든 필드를 초기화해야 한다.</li>
            <li>ValueType이므로 할당 시 깊은 복사가 이루어진다.</li>
        </ol>
    </details>

    <details>
        <summary>열거형 enum</summary>
        <ol>
            <li>정수형을 상속받아 정의할 수 있는 ValueType. 기본 int</li>
            <li>[Flags] // 열거형을 비트필드로 이용하는 애트리뷰트</li>
<pre>[Flags] enum Authority { READ = 1, WRITE = 2, EXECUTE = 4 }
var authority = READ | WRITE;
Console.WriteLine(authority.HasFlag(WRITE));</pre>
        </ol>
    </details>

    <details>
        <summary>제네릭</summary>
        <ul>
            <li>Generic Method</li>
            public void Write&lt;T&gt;(T value) =&gt; OnWrite(value?.ToString() ?? "");

            <li>Generic Class</li>
            public class List&lt;T&gt; : IList&lt;T&gt;, ICollection&lt;T&gt;, IEnumerable&lt;T&gt;, (생략)

            <li>Type Bound</li>
            <ol>
                <li>where T : struct // 값 형식</li>
                <li>where T : class // 참조 형식</li>
                <li>where T : new() // 기본 생성자 보유</li>
                <li>where T : BaseClassName | InterfaceName | U // 호환 여부 검사. U는 다른 형식 매개 변수</li>
                <li>where T : A[, B[, C[...]]]</li>
                class MyGenereic&lt;T, U&gt; where T : struct where U : class { }
            </ol>
        </ul>
    </details>
</details>

<hr>

<details>
    <summary>C# 버전별 추가 기능</summary>
    <details>
        <summary> ~ C# 6</summary>
        <details>
            <summary>BigInteger</summary>
            자바와 마찬가지로 자리수 제한없는 정수를 지원. 자바와 달리 연산자 오버로딩 덕분에 사용하기는 더 편하다
        </details>

        <details>
            <summary>IntPtr</summary>
            32비트 프로그램에서는 4바이트, 64바이트 프로그램에서는 8바이트. 포인터 외에 운영체제 핸들값을 저장하는 용도로도 사용.
        </details>

        <details>
            <summary>default</summary>
            타입에 대한 기본값/인스턴스를 반환한다. default(Type)
        </details>

        <details>
            <summary>var</summary>
            지역변수 초기화시에만 사용 가능한 자동형식
        </details>

        <details>
            <summary>dynamic</summary>
            동적 언어인 파이썬처럼 타입 검사를 런타임에 하여 Duck-typing을 가능하게 한다.
        </details>

        <details>
            <summary>메서드 매개변수 제어</summary>
            ref : 참조에 의한 호출.<br>
            out : 쓰기 전용 매개변수. 호출 전에 초기화되지 않아도 되며, 종료 전에 할당이 이루어져야 한다.<br>
            매개변수 명시 : Divide(a: 10, b: 3, q: out q, r: out r);<br>
            선택적 매개변수 : Method(int a = 0, int b = 0) {}
        </details>

        <details>
            <summary>readonly</summary>
            읽기 전용 필드 선언<br>
            readonly struct : 모든 필드가 readonly인 struct<br>
            ref readonly : 메서드에서 반환된 참조를 읽기만 가능
        </details>

        <details>
            <summary>가변 길이 매개변수 params</summary>
            <button class="btn-code" path="Repositories/VisualStudio/CSharp/Basic/ParamsExample.cs" displayRange="[11, 17]" lan="cs">예시 코드 »</button>
        </details>

        <details>
            <summary>확장 메서드</summary>
            기존 클래스에 static method 추가.<button class="btn-code" path="Repositories/VisualStudio/CSharp/Basic/ExtensionExample.cs" lan="cs">ExtensionExample.cs »</button>
        </details>

        <details>
            <summary>nameof</summary>
            nameof() : 식별자 문자열 반환
        </details>

        <details>
            <summary>Attribute</summary>
            <ol>
                <button class="btn-code" path="Repositories/VisualStudio/CSharp/Basic/AttributeExample.cs" lan="cs">AttributeExample.cs 전체 코드 »</button>

                <li>사용자 정의 특성은 System.Attribute를 상속하여 만든다.</li>
                <button class="btn-code" path="Repositories/VisualStudio/CSharp/Basic/AttributeExample.cs" displayRange="[12, 19]" lan="cs">AttributeExample.cs »</button>

                <li>명명시 Attribute를 접미하고, 실제 사용시에는 "Attribute"는 생략 가능하다.</li>
                <button class="btn-code" path="Repositories/VisualStudio/CSharp/Basic/AttributeExample.cs" displayRange="[21, 24]" lan="cs">AttributeExample.cs »</button>

                <li>특성을 적용할 수 있는 대상 제한</li>
                System.AttributeUsage 생성자에 AttributeTargets 전달. 생략시 기본값은 AttributeTargets.All. 여러 대상에 적용된다면 "AttributeTargets.Field | AttributeTargets.Method"처럼 |를 이용.

                <li>적용하는 대상 명시</li>
                어셈블리에 적용하는 경우(AttributeTargets.Assembly), 반환값에 적용하는 경우(AttributeTargets.ReturnValue)와 같이, 특성이 적용될 대상을 자동으로 특정해내지 못하는 경우엔 이를 명시해줄 수 있다.<br>
                assembly, module, type, method, property, field, event, param, return, typevar
            </ol>
        </details>

        <details>
            <summary>extern</summary>
            <ol>
                <li>메서드의 body가 없어도 컴파일 되도록 한다.</li>
                <li>호출할 메서드가 있는 dll을 DllImport 특성으로 지정해주면 해당 메서드를 호출한다</li>
                <li>http://www.pinvoke.net/</li>
            </ol>
        </details>

        <details>
            <summary>unsafe</summary>
            <ol>
                <li>unsafe를 지정한 블록, 클래스에서는 포인터를 사용할 수 있다.</li>
                <li>컴파일 시 /unsafe 옵션을 지정해야 한다. 비주얼 스튜디오는 프로젝트 속성 - 빌드 - 안전하지 않은 코드 허용</li>
                <li>System.Runtime.InteropServices.Marshal</li>
            </ol>
        </details>

        <details>
            <summary>fixed</summary>
            <ol>
                <li>unsafe한 코드에 참조 변수(의 일부)를 보내야 하는 경우, 블록이 끝날 때까지 힙 영역에서 해당 객체의 주소를 고정시킨다.</li>
                <li>참조 변수 자체에 fixed를 적용할 수는 없고, 필드의 일부를 "int* pValue = &obj.field"처럼 지정하여 사용</li>
            </ol>
        </details>

        <details>
            <summary>stackalloc</summary>
            값 형식의 배열을 스택에 할당하도록 한다<br>
            int* pArray = stackalloc int[12];
        </details>

        <details>
            <summary>app.config</summary>
            <ol>
                <li>supportedRuntime</li>
                실행에 필요한 닷넷 버전 지정. 비주얼 스튜디오가 자동으로 추가해주는듯
                <button class="btn-code" path="Repositories/VisualStudio/CSharp/Basic/App.config" lan="xml">App.config »</button>

                <li>appSettings</li>
                <button class="btn-code" path="Repositories/VisualStudio/CSharp/Basic/App.config" lan="xml">App.config »</button>
                <button class="btn-code" path="Repositories/VisualStudio/CSharp/Basic/Program.cs" lan="cs">Program.cs »</button>
            </ol>
        </details>

        <details>
            <summary>디버그 모드에서만 실행되는 코드</summary>
            <ol>
                <li>전처리 상수</li>
                #if DEBUG ... #endif

                <li>Conditional 특성</li>
                [Conditional("DEBUG")] : 적용된 클래스, 메서드는 릴리스 빌드 시 포함되지 않는다

                <li>System.Diagnostics.Debug</li>
                Debug.WriteLine() : 디버그 출력 창에 출력된다
            </ol>
        </details>

        <details>
            <summary>서명</summary>
            <ol>
                <li>Strong-named Assembly</li>
                어셈블리 이름 + 버전 + 문화권 + 공개키 토큰

                <li>서명 절차</li>
                비주얼 스튜디오 프로젝트 속성 - 서명
            </ol>
        </details>

        <details>
            <summary>try 구문</summary>
            <ol>
                <li>try {} catch {} finally {}</li>
                <li>try {} catch (ExceptionType) {}</li>
                <li>try {} catch { throw; }</li>
                <li>try {} catch (ExceptionType e) {}</li>
                <li>try {} catch () when (!filePath.Contains(".tmp")) {}</li>
                when 구문을 사용하는 경우, 같은 예외 타입을 여러 번 catch 가능
                <li>try {} finally { iDisposable.Dispose(); } == using(var iDisposable = ~)</li>
                https://docs.microsoft.com/ko-kr/dotnet/api/system.idisposable?view=netframework-4.8
            </ol>
        </details>

        <details>
            <summary>인덱서</summary>
            클래스 인스턴스가 마치 배열인 것처럼 인덱스를 통해 접근할 수 있게 해준다. 인덱스 타입은 정수형 외에도 가능하고, 인덱서 오버로딩 가능.<br>
            선언 : 접근제한자 리턴_타입 this[인덱스_타입 인덱스_식별자] { get {} set {} }<br>
            읽기 전용 : 리턴_타입 this[인덱스_타입 인덱스_식별자] =&gt; {} // set만 설정된다.<br>
            string, List&lt;T&gt; 등은 인덱서를 구현함.<button class="btn-code" path="Repositories/VisualStudio/CSharp/Basic/IndexerExample.cs" lan="cs">IndexerExample.cs »</button>        
        </details>

        <details>
            <summary>전처리 지시문</summary>
            #define, #undef, #if, #elif, #else, #endif..., #region, #endregion...
        </details>

        <details>
            <summary>nullable</summary>
            <ul>
                <li>Nullable&lt;T&gt;</li>
                null을 허용하는 래퍼 클래스를 제공해준다. int?는 Nullable&lt;int&gt;와 동일하다.

                <li>Null 조건부 연산자 ?. 및 ?[]</li>
                피연산자가 null이 아닌 것으로 평가되었을 때만 멤버 액세스 ?., 또는 요소 액세스 ?[] 연산을 피연산자에게 적용. null이면 그대로 null 반환<br>
                null 조건부 연산자를 연쇄적으로 이용할 때, 중간에 한 곳에서 null이 반환된 경우, 나머지는 처리되지 않는다.
                <button class="btn-code" path="Repositories/VisualStudio/CSharp/Basic/NullableExample.cs" lan="cs">NullableExample.cs »</button>

                <li>?? 연산자</li>
                좌측 피연산자가 null이면 우측 피연산자를 반환<br>
                return setsOfNumbers?[indexOfSetToSum]?.Sum() ?? double.NaN;
        </details>

        <details>
            <summary>LINQ</summary>
            <ol>
                <li>LINQ; Language INtegrated Query</li>
                <button class="btn-code" path="Repositories/VisualStudio/CSharp/Basic/LinqExample.cs" lan="cs">에시코드 »</button>

                <li>MoreLinq 패키지에서 추가적인 편의성을 제공한다.</li>

                <li>from : LINQ query는 from으로 시작한다. from의 대상은 IEnumarable&lt;T&gt;</li>

                <li>where + bool 판정식</li>

                <li>orderby + 정렬 기준 [(ascending) | descending]</li>

                <li>select + 결과</li>

                <li>let : LINQ 내에서의 변수 선언. let x = 10</li>

                <li>LINQ query 결과는 IEnumerable&lt;T&gt;</li>

                <li>중첩 질의</li>
                from student in students<br>
                from score in student.Scores

                <li>Grouping</li>
                결과는 IGrouping&lt;T&gt; 형식<br>
                from p in profiles<br>
                group p by p.Height &lt; 160 into lowGroup<br>
                select new { Key = lowGroup.Key, Profiles = lowGroup };

                <li>Inner Join</li>
                from a in A<br>
                join b in B on a.X equals b.Y

                <li>Outer Join</li>
                inner join 결과를 임시 컬렉션으로 치환하고, 임시 컬렉션의 빈 항목을 기본 값으로<br>
                from profile in profiles<br>
                join product in products on profile.Name equals product.Name into result<br>
                from product in result.DefaultIfEmpty( new Product() { Title = "없음” } )<br>
                select new { Name = profile.Name, Work = product.Title };

                <li>Expression Tree</li>
                <ul>
                    <li>System.Linq.Expressions 네임스페이스의 Expression 클래스 및 파생 클래스들</li>
                    var const1 = Expression.Constant(1);<br>
                    var param1 = Expression.Parameter(typeof(int), "x");<br>
                    var exp = Expression.Add(const1, param1);<br>
                    var lambda = Expression&lt;Func&lt;int, int&gt;&gt;.Lambda&lt;Func&lt;int, int&gt;&gt;(exp, new ParameterExpression[] { (ParameterExpression)param1 });<br>
                    var compiledFunc = lambda.Compile();<br>
                    Console.WriteLine(compiledFunc(3));
                </ul>
            </ol>
        </details>

        <details>
            <summary>리플렉션 Reflection</summary>
            <ul>
                <li>AppDomain &gt; Assembly &lt; Module &lt; Type</li>
                AppDomain : EXE 프로세스 내에서 CLR에 의해 구현된 격리 공간. 최초 실행 시 기본적으로 1개 생성(AppDomain.CurrentDomain)<br>
                static 멤버들은 AppDomain 안에서 유일하다. 프로세스의 여러 AppDomain에서 동일한 클래스를 로드했다면 static 멤버들은 각 도메인마다 하나씩 존재<br>
                <br>
                var appDomain = AppDomain.CreateDomain("MyDomain");<br>
                ObjectHandle handle = appDomain.CreateInstanceFrom(dllPath, "Namespace.ClassName");<br>
                ...<br>
                AppDomain.Unload(appDomain);

                <li>Object.getType() or typeof 연산자</li>

                <li>Type :: GetConstructors(), GetEvents(), GetFields(), GetMethods(), ...</li>

                <li>동적 생성 : System.Activator.CreateInstance(Type);</li>

                <li>동적 타입 정의 : System.Reflection.Emit</li>
                <ol>
                    <li>System.AppDomain.DefineDynamicAssembly()로 AssemblyBuilder 객체 획득</li>
                    <li>AssemblyBuilder.DefineDynamicModule()로 ModuleBuilder 획득</li>
                    <li>ModuleBuilder.DefineType()으로 클래스 생성(TypeBuilder)</li>
                    <li>TypeBuilder.DefineMethod()로 MethodBuilder 획득</li>
                    <li>MethodBuilder.GetILGenerator()로 ILGenerator 객체 획득</li>
                    <li>ILGenerator.Emit()으로 메서드 내용 추가</li>
                    <li>TypeBuilder.CrateType()으로 인스턴스 생성 가능</li>
                </ol>
            </ul>
        </details>

        <details>
            <summary>yield</summary>
            public static IEnumerable<int> InfiniteSeries(int limit) {<br>
            　　var num = 0;<br>
            　　if(num &lt;= limit)<br>
            　　　　yield return ++start;<br>
            　　yield break;<br>
            }
        </details>

        <details>
            <summary>Caller information</summary>
            static void Log(string text, [CalleMemberName] string memberName = "", [CallerFilePath] string filePath = "", [CallerLineNumber] int lineNumber = 0) {}
        </details>

        <details>
            <summary>async 한정자, await 연산자</summary>
            async로 한정한 void 리턴 메서드는 await없이 비동기 실행된다.<br>
            async로 한정한 Task 또는 Task&lt;TResult&gt; 반환 메서드/Task/람다식은 await 연산자를 만나는 곳에서 호출자에게 제어를 넘겨주며, await 연산자가 없으면 동기적으로 실행된다.<br>
            await 이후의 코드들은 대기하는 작업이 종료된 이후에 실행되도록 컴파일된다.<br>
            <br>
            private async void Read() {<br>
            　　using(FileStream fs)<br>
            　　　　await fs.ReadAsync(buf, 0, buf.Length);<br>
            　　　　// public Task&lt;int&gt; ReadAsync(byte[] buffer, int offset, int count);
            }
        </details>
    </details>

    <details>
        <summary>C# 7</summary>
        <ol>
            <li>in 매개변수</li>
            참조에 의해 전달되지만 호출된 메서드에서 수정할 수 없음

            <li>선언과 동시에 out 매개변수로 사용 가능</li>
            int.TryParse("12", out var result);<br>
            int.TryParse("21", out var _); // 출력 무시

            <li>readonly struct</li>
            변경 불가능한 구조체. in 매개변수로 전달되야 함

            <li>ref struct</li>
            구조체가 항상 스택에 할당됨. 힙에 할당될 수 없으므로 클래스의 멤버가 될 수 없음<br>
            인터페이스(IDisposable...)를 구현할 수 없으므로, 삭제를 가능해지려면 액세스 가능한 void Dispose()를 가져야 한다.

            <li>private protected</li>
            동일 어셈블리 내의 클래스 및 파생 클래스에서 엑세스 가능

            <li>지역변수, 반환값 ref 사용 가능</li>
            ref readonly 반환 : 반환된 개체에 대한 쓰기는 허용하지 않음<br>
            public ref int Next() =&gt; ref list[idx++]; // 지역 변수의 ref 반환은 불가<br>
            public void Main() {<br>
            　　ref var num = ref Next();<br>
            　　Next() = 0;<br>
            }<br>
            <br>
            ref var r = ref (ref arr?[0] ?? ref otherArr[0]);

            <li>튜플</li>
            ==, != 가능<br>
            public (타입1 [식별자], 타입2 [식별자], ...) MethodName() {}<br>
            public void MethodName((타입1 [식별자], 타입2 [식별자], ...) 식별자) {}<br>
            <br>
            튜플 아이템의 기본 이름 : Item1, Item2, ...<br>
            <br>
            (var 식별자, var 식별자, ...) 식별자 = MethodName();<br>
            (var 식별자, var 식별자, ...) = MethodName();<br>
            (var _, var 식별자, ...) = MethodName();<br>
            <br>
            Deconstruct 메서드로 튜플 분해<br>
            class Rectangle {<br>
            　　public int X, Y, W, H;
            　　public void Deconstruct(out int x, out int y) { x = X; y = Y; }
            　　public void Deconstruct(out int x, out int y, out int w, out int h) { ... }
            }
            (var _, var y) = rectangle;
            (var _, var _, var _, var h) = rectangle;

            <li>람다 식 사용 확장</li>
            생성자, 소멸자, 이벤트 add/remove, 속성 set, 인덱서 set

            <li>메서드 안에 지역 함수 정의 가능</li>

            <li>throw 가능 위치 확장</li>
            name ?? throw new ArgumentNullException(nameof(name));

            <li>is 연산자 기능 확장</li>
            if(obj is List&lt;string&gt; list) { list... }<br>
            if(item is 100) {}<br>
            if(item is null)

            <li>switch case 확장</li>
            switch(item) {<br>
            　　case 100:<br>
            　　case null:<br>
            　　case DateTime dt:<br>
            　　case int i when i &gt; 300:<br>
            　　case var i when i.어쩌구저쩌구():<br>
            }

            <li>Main 메서드에 async 허용</li>

            <li>default 리터럴</li>
            default(Type) 대신 default 리터럴 사용 가능

            <li>튜플 자동 네이밍</li>
            var t = (age, name);<br>
            t.age, t.name;;;

            <li>제네릭 타입 패턴 매칭 가능</li>
            public void MethodName&lt;T&gt;(T item) {<br>
            　　if(item is DateTime time) ...<br>
            }<br>
        </ol>
    </details>

    <details>
        <summary>C# 8(2019. 02. 12)</summary>
        <ol>
            <li>switch 식</li>
            public static RGBColor FromRainbow(Rainbow colorBand) =&gt;<br>
            colorBand switch {<br>
            　　Rainbow.Red    =&gt; new RGBColor(0xFF, 0x00, 0x00),<br>
            　　Rainbow.Orange =&gt; new RGBColor(0xFF, 0x7F, 0x00),<br>
            　　_              =&gt; throw new ArgumentException(message: "invalid enum value", paramName: nameof(colorBand)),<br>
            };

            <li>속성 패턴</li>
            public static decimal ComputeSalesTax(Address location, decimal salePrice) =&gt;<br>
            location switch {<br>
            　　{ State: "WA" } =&gt; salePrice * 0.06M,<br>
            　　{ State: "MI" } =&gt; salePrice * 0.05M,<br>
            　　_ =&gt; 0M<br>
            };

            <li>튜플 패턴</li>
            public static string RockPaperScissors(string first, string second)<br>
            =&gt; (first, second) switch {<br>
            　　("rock", "paper") =&gt; "rock is covered by paper. Paper wins.",<br>
            　　("rock", "scissors") =&gt; "rock breaks scissors. Rock wins.",<br>
            　　("paper", "rock") =&gt; "paper covers rock. Paper wins.",<br>
            　　("paper", "scissors") =&gt; "paper is cut by scissors. Scissors wins.",<br>
            　　("scissors", "rock") =&gt; "scissors is broken by rock. Rock wins.",<br>
            　　("scissors", "paper") =&gt; "scissors cuts paper. Scissors wins.",<br>
            　　(_, _) =&gt; "tie"<br>
            };

            <li>위치 패턴</li>
            static Quadrant GetQuadrant(Point point) =&gt; point switch {<br>
            　　(0, 0) =&gt; Quadrant.Origin,<br>
            　　var (x, y) when x > 0 && y > 0 =&gt; Quadrant.One,<br>
            　　var (x, y) when x < 0 && y > 0 =&gt; Quadrant.Two,<br>
            　　var (x, y) when x < 0 && y < 0 =&gt; Quadrant.Three,<br></0>
            　　var (x, y) when x > 0 && y < 0 =&gt; Quadrant.Four,<br></0>
            　　var (_, _) =&gt; Quadrant.OnBorder,<br>
            　　_ =&gt; Quadrant.Unknown<br>
            };

            <li>using 선언</li>
            블록 종료 시 Dispose 호출<br>
            using var file = new System.IO.StreamWriter("WriteLines2.txt");

            <li>static local 함수</li>
            기존 로컬 함수가 바깥쪽의 변수를 참조할 수 있는 반면, static local 함수는 불가능

            <li>비동기 스트림</li>
            public static async System.Collections.Generic.IAsyncEnumerable&lt;int&gt; GenerateSequence() {<br>
            　　await Task.Delay(100);<br>
            　　yield return i++;<br>
            }<br>
            <br>
            await foreach (var number in GenerateSequence())<br>
            　　Console.WriteLine(number);

            <li>익덱스 및 범위</li>
            끝에서 부터 시작하는 인덱스 : ^<br>
            범위 : start..end // end는 미포함<br>
            <br>
            Console.WriteLine($"The last word is {words[^1]}");<br>
            var lazyDog = words[^2..^0];<br>
            var allWords = words[..]; // contains "The" through "dog".<br>
            var firstPhrase = words[..4]; // contains "The" through "fox"<br>
            var lastPhrase = words[6..]; // contains "the, "lazy" and "dog"<br>
            <br>
            Range phrase = 1..4;<br>
            var text = words[phrase];
        </ol>
    </details>
</details>

<hr>
