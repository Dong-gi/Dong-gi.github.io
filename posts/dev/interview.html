<!DOCTYPE html><html lang="ko-KR"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>개발자 경력 관리</title><link rel="stylesheet" href="/source/default.css"><meta name="google-site-verification" content="aH-DyzdytYQ0NPHNQFcs5dVoiu5YNs6CEEHYgqDmAFM"><meta name="author" content="Donggi Kim &lt;hi.donggi@gmail.com&gt;"><meta name="description" content="개발자 생애를 잘 끝마치기 위한 글"><link rel="icon" href="/imgs/favicon.png"><script id="google-analytics" src="https://www.googletagmanager.com/gtag/js?id=UA-143098403-1" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-143098403-1');</script><script id="highlight-js" src="/source/highlight.pack.js" defer></script><script id="default-js" src="/source/default.min.js" defer></script></head><body><aside class="w3-animate-left" id="sidebar"><hr><div id="marker-list"></div><hr><div id="post-list"></div><hr><details class="w3-small file-list"><summary>LICENSE</summary><table><tr><td>Author</td><td>License</td></tr><tr><td>&copy; <a href="mailto:hi.donggi@gmail.com">Donggi Kim</a></td><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/Dong-gi/Dong-gi.github.io/blob/master/LICENSE">MIT</a></td></tr><tr><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://www.w3schools.com/w3css">w3css</a></td><td>No license</td></tr><tr><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://highlightjs.org/">highlight.js</a></td><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/highlightjs/highlight.js/blob/main/LICENSE">BSD-3-Clause</a></td></tr><tr><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/mathjax/MathJax">MathJax</a></td><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/mathjax/MathJax/blob/master/LICENSE">Apache-2.0</a></td></tr><tr><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/davidshimjs/qrcodejs">QRCode.js</a></td><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/davidshimjs/qrcodejs/blob/master/LICENSE">MIT</a></td></tr><tr><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/terrastruct/d2">D2</a></td><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/terrastruct/d2/blob/master/LICENSE.txt">MPL-2.0</a></td></tr></table></details><hr></aside><main id="main"><nav class="w3-bar w3-blue" id="nav"><button class="w3-bar-item w3-button w3-hover-theme" id="nav-toggle-btn">&#9776;</button><form role="search"><input class="w3-bar-item" id="query" type="search" placeholder="search" style="max-width:35%"></form><a class="w3-bar-item w3-button w3-hover-theme" href="/">Home</a></nav><article id="contents"><h1>참고 도서 정보</h1><div class="w3-row"><div class="w3-col s2 w3-center"><figure class="w3-center w3-margin-bottom"><img class="w3-round" src="https://www.hanbit.co.kr/data/books/B7155705626_l.jpg" alt="Can't load image" loading="lazy" style="max-height:210px;"><figcaption>&lt;도서 이미지></figcaption></figure></div><div class="w3-col s10"><table class="w3-table-all w3-card w3-small"><tr><td>제목</td><td>(JAVA) 프로그래밍 면접 이렇게 준비한다</td></tr><tr><td>저자</td><td>지은이: 노엘 마크엄 옮긴이: 정원천</td></tr><tr><td>ISBN</td><td>978-89-6848-152-9 [93000]</td></tr><tr><td>발행일</td><td>2015년 02월 01일</td></tr><tr><td>발행처</td><td>한빛미디어</td></tr></table></div></div><div><h2 class="no-marker">책의 오류</h2><ul><li>80p 정수 타입 배열에는 final 키워드를 사용할 수 없다</li><p>-> 배열 원소의 타입과 무관하게 final 키워드 사용 가능하며, 해당 변수 초기화 이후 재할당은 불가하다</p></ul></div><div class="w3-row"><div class="w3-col s2 w3-center"><figure class="w3-center w3-margin-bottom"><img class="w3-round" src="https://www.hanbit.co.kr/data/books/B9005920688_l.jpg" alt="Can't load image" loading="lazy" style="max-height:210px;"><figcaption>&lt;도서 이미지></figcaption></figure></div><div class="w3-col s10"><table class="w3-table-all w3-card w3-small"><tr><td>제목</td><td>프로그래밍 면접 이렇게 준비한다</td></tr><tr><td>저자</td><td>존 몽건,노아 킨들러,에릭 기게리 지음 서환수 옮김</td></tr><tr><td>ISBN</td><td>979-11-6224-199-8 [93000]</td></tr><tr><td>발행일</td><td>2019년 07월 04일</td></tr><tr><td>발행처</td><td>한빛미디어</td></tr></table></div></div><div class="w3-row"><div class="w3-col s2 w3-center"><figure class="w3-center w3-margin-bottom"><img class="w3-round" src="https://image.yes24.com/goods/44305533/800x0" alt="Can't load image" loading="lazy" style="max-height:210px;"><figcaption>&lt;도서 이미지></figcaption></figure></div><div class="w3-col s10"><table class="w3-table-all w3-card w3-small"><tr><td>제목</td><td>코딩 인터뷰 완전 분석</td></tr><tr><td>저자</td><td>게일 라크만 맥도웰 지음 이창현 옮김</td></tr><tr><td>ISBN</td><td>978-89-6626-308-0 [13560]</td></tr><tr><td>발행일</td><td>2017년 08월 14일</td></tr><tr><td>발행처</td><td>인사이트</td></tr></table></div></div><h1>경력</h1><ol><li>자신의 경력을 사업으로 생각하자</li><p>구직은 곧 고객을 찾는 것이다</p></ol><h1>이력서</h1><ol><li>전문성과 기술을 어필</li><li>2p 이내로 요약하는 것이 좋다</li><p><strong>↓ text</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text"># 지원 동기와 현재까지 경력을 요약한 첫 문단

# 경력 사항
- 업무 기간, 장소, 수행 역할, 성과
관리자, 숙련 개발자라면 기술 목록보다는 관리 성과가 중점이 되야 한다
- 한 일을 정량적으로 기술하는 것이 좋다 : X를 구현하여 Y를 성취했고, 그 결과 Z를 이루었다
예. MySQL DB 스키마를 설계하고, 자바 멀티스레딩과 JDBC를 이용해 통신하는 프로그램 구현
예. 분산 캐시를 구현하여 렌더링 시간을 75% 줄였고, 그 결과 로그인 시간을 10% 단축했습니다
- 이직 사유를 적는 것은 지양

# 최종 학력

# 기술 역량
개발 가능 언어 : Java, C#, JavaScript, Python
데이터베이스 : MySQL, PostgreSQL, MongoDB
운영체제 : Windows(7↑), Linux, Android
프레임워크 : WPF, Spring Boot, Node Express
템플릿 엔진 : FreeMarker, Pug(구 Jade)

</div></ol><h1>자기소개서</h1><ol><li>팀(회사)에 어울리는 사람임을 어필</li><ul><li>이력서의 내용 중 지원하는 역할과 관련 있는 내용을 강조</li><li>구체적인 지원 동기</li></ul><li>1p 이내로 작성</li><li>이력 사이의 공백에 대해 설명</li></ol><h1>면접</h1><ul><li>할 일을 알아서 찾아 해결하는 사람임을 어필</li><li>인력 풀이 좋은 회사일수록 면접이 까다로워지는 이유는 false positive 오류를 피하려고 하기 때문</li><li>어떤 사업을 하는 회사인지, 무료 상용 서비스가 있다면 직접 체험할 필요도 있다</li><li>스타트업 같은 소규모 회사는 CET, CTO 등의 SNS를 통해 동향 파악 가능</li><li>면접관이 질문이 있는지 물었을 때, 없다고 답하면 부정적으로 보일 수 있음</li><ul><li>순수한 질문 : 실제로 궁금한 사항</li><li>통찰력을 보일 수 있는 질문</li><p>예. X라는 기술을 사용하시는 것 같은데, Y 문제는 어떻게 해결하시나요?</p><li>열정을 보일 수 있는 질문</li><p>예. 회사 내에서 X에 대해 배울 기회가 있나요?</p></ul></ul><h1>면접관의 입장</h1><ul><li>힌트나 조언 하나로 지원자의 성적에 큰 차이를 만들어 낸다면 좋은 면접 문제는 아니다</li><li>알기 어려운 지식이 아닌, 풀기 어려운 문제가 좋다</li><p>컴퓨터공학을 전공했더라도 대부분은 다익스트라 알고리즘, AVL의 동작을 기억하지 못할 것이다</p><li>지원자를 긍정적으로 대하라</li><li>질문의 종류</li><ul><li>Sanity check : 문제 해결 능력의 최소를 평가하기 위한 문제</li><li>Quality check : 치밀하게 설계되고, 생각하게끔 만들어진 어려운 문제</li><li>Specialist questions : 특정 분야의 전문지식과 관련된 문제</li><li>Proxy knowlege : 지원자의 레벨에서 알고 있을법한 지식과 관련된 문제</li></ul></ul><h1>일반 질문</h1><ul><li>입사하여 무엇을 하고 싶은지? / 이 회사에서 일하고 싶은 이유는?</li><li>자신의 단점이 무엇인지?</li><p>→ 자신의 진짜 단점을 설명하고, 극복을 위해 어떻게 하고 있는지 강조</p><li>인생의 목표가 무엇인지?</li><li>희망 연봉은?</li><ul><li>성급하게 부르지 말고 먼저 얼마나 제시할 수 있는지 물어보기</li><li>연봉을 움직이기 어려운 경우, 사이닝 보너스, 성과급, 휴가 등 복지 요구 시도</li></ul></ul><h1>경력 질문</h1><ul><li>경력에 대해 얘기해보세요</li><p>전에 했던 일에 대한 객관적 사실 + 무엇을 배웠는지, 어떤 문제가 있었는지</p><table class="w3-table-all w3-card w3-small"><tr><th>질문</th><th>프로젝트 1</th><th>프로젝트 n</th></tr><tr><td>도전적이었던 것</td><td>?</td><td>?</td></tr><tr><td>실수 또는 실패</td><td>?</td><td>?</td></tr><tr><td>즐거웠던 것</td><td>?</td><td>?</td></tr><tr><td>리더십</td><td>?</td><td>?</td></tr><tr><td>팀원과의 갈등</td><td>?</td><td>?</td></tr><tr><td>남들과 다르게 한 것</td><td>?</td><td>?</td></tr></table><li>이직하는 이유가 무엇인지?</li><li>가장 고치기 어려웠던 버그는 무엇이었는지?</li></ul><h1>알고리즘/코딩 질문</h1><div><h2>big-O 표기법</h2><ul><li>아래 코드의 시간복잡도는?</li><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">void print(int[] arr1, int[] arr2) {
    for (var i = 0; i &lt; arr1.length; ++i) {
        for (var j = 0; j &lt; arr2.length; ++j) {
            if (arr1[i] &lt; arr2[j])
                System.out.print("Found");
        }
    }
}</div><p>↓ if 블록은 상수 시간에 수행되므로,</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">for (var i = 0; i &lt; arr1.length; ++i)
    for (var j = 0; j &lt; arr2.length; ++j)
        /* O(1) 작업 */</div><p>따라서 답은 O(NM)</p><li>문자열 배열이 주어졌을 때, 문자열 각각을 정렬한 뒤, 배열을 정렬하는 시간복잡도는?</li><p>→ 배열 크기를 N, 가장 긴 문자열의 길이를 L이라고 할 때, 각 문자열을 정렬하는 시간은 O(N*LlogL)이면 충분하다. 배열을 정렬하는 데에 O(NlogN) 번의 비교가 필요하고, 각 비교에 O(L) 시간이 소요되므로, 총 소요 시간은 O(N*LlogL + L*NlogN) = O(NL(logL + logN))</p><li>순열을 모두 출력하는 아래 코드의 시간복잡도는?</li><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">void permutation(String str) {
    permutation(str, "");
}
void permutation(String str, String prefix) {
    if (str.length() == 0)
        System.out.println(prefix);
    else {
        for (var i = 0; i &lt; str.length(); ++i) {
            var remain = str.substring(0, i) + str.substring(i+1);
            permutation(remain, prefix + str.charAt(i));
        }
    }
}</div><ol><li>permutation(String, String) 호출 트리를 그려보면, 총 n!개의 단말 노드가 존재한다</li><li>호출 트리의 깊이는 O(n)이므로, 총 노드의 개수는 O(n*n!)</li><li>각 단말 노드는 출력 작업 O(n), 내부 노드들은 문자열 연결 작업 O(n)을 수행한다</li><li>따라서 총 수행 시간은 식[O(n^2 \cdot n!)]식을 넘지 않는다</li></ol></ul><h2>코드 작성 시 유의 사항</h2><ul><li>발생 가능한 예외, 경계조건에서의 동작 확인</li><li>단위 테스트 꼭 작성</li></ul></div><h1>Java 질문</h1><ol><li>Comparable, Comparator 인터페이스의 차이?</li><p>Comparable은 클래스의 자연스러운 정렬 순서를, @FunctionalInterface Comparator는 필요에 따른 임의 정렬 순서를 의미한다</p><li>서로 다른 키 객체의 hashCode() 결과가 동일한데도 HashSet, HashMap이 여전히 잘 작동하는 이유?</li><p>hashCode()에 대응하는 버킷 리스트의 각 버킷은 여전히 키 객체를 저장하고 있으므로 2차적인 비교를 통해 구별이 가능하기 때문</p><li>String interning?</li><p>서로 다른 위치에 존재하는 같은 내용의 String 리터럴이 상수 풀의 단일 String 객체를 참조하는 것</p><li>Vector, Hashtable 클래스가 이미 있는데 ArrayList, HashMap이 추가된 이유?</li><ul><li>Vector, Hashtable은 동기화되어 병렬 처리에 적합하지만, 병렬 처리할 일이 없다면 불필요한 오버헤드만 발생한다</li><li>따라서 스레드-안전할 필요가 없다면 각각 ArrayList, HashMap를 이용하는 것이 좋다</li><li>추가적으로, 높은 병렬성이 요구된다면 ConcurrentHashMap을 이용하는 것이 좋다</li></ul><li>병렬로 실행되는 코드를 테스트하려면?</li><ul><li>방법1. 모든 작업이 테스트 스레드에서 실행되도록 Executor 변경</li><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">@Test
void test() {
    final var executor = new Executor() {
        @Override
        public void execute(final Runnable command) {
            command.run();
        }
    }
    // ...
}</div><li>방법2. 병렬 스레드가 종료되기를 기다림</li><ol><li>모든 작업을 등록한 뒤 ExecutorService의 shutdown()을 호출하여 추가 작업을 받지 않도록 한다</li><li>isTerminated() 또는 awaitTermination()으로 종료 확인</li></ol></ul></ol></article></main></body></html>