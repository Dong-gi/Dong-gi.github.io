<!DOCTYPE html><html lang="ko-KR"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>브라우저 JavaScript</title><link rel="stylesheet" href="/source/default.css"><meta name="google-site-verification" content="aH-DyzdytYQ0NPHNQFcs5dVoiu5YNs6CEEHYgqDmAFM"><meta name="author" content="Donggi Kim &lt;hi.donggi@gmail.com&gt;"><meta name="description" content="브라우저 JavaScript 정리"><link rel="icon" href="/imgs/favicon.png"><script id="google-analytics" src="https://www.googletagmanager.com/gtag/js?id=UA-143098403-1" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-143098403-1');</script><script id="highlight-js" src="/source/highlight.pack.js" defer></script><script id="default-js" src="/source/default.min.js" defer></script></head><body><aside class="w3-animate-left" id="sidebar"><hr><div id="marker-list"></div><hr><div id="post-list"></div><hr><details class="w3-small file-list"><summary>LICENSE</summary><table><tr><td>Author</td><td>License</td></tr><tr><td>&copy; <a href="mailto:hi.donggi@gmail.com">Donggi Kim</a></td><td><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/Dong-gi/Dong-gi.github.io/blob/master/LICENSE">MIT</a></td></tr><tr><td><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="https://www.w3schools.com/w3css">w3css</a></td><td>No license</td></tr><tr><td><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="https://highlightjs.org/">highlight.js</a></td><td><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/highlightjs/highlight.js/blob/main/LICENSE">BSD-3-Clause</a></td></tr><tr><td><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/mathjax/MathJax">MathJax</a></td><td><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/mathjax/MathJax/blob/master/LICENSE">Apache-2.0</a></td></tr><tr><td><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/davidshimjs/qrcodejs">QRCode.js</a></td><td><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/davidshimjs/qrcodejs/blob/master/LICENSE">MIT</a></td></tr><tr><td><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/terrastruct/d2">D2</a></td><td><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/terrastruct/d2/blob/master/LICENSE.txt">MPL-2.0</a></td></tr></table></details><hr></aside><main id="main"><nav class="w3-bar w3-blue" id="nav"><button class="w3-bar-item w3-button w3-hover-theme" id="nav-toggle-btn">&#9776;</button><input class="w3-bar-item" id="query" type="text" placeholder="search" style="max-width:35%"><a class="w3-bar-item w3-button w3-hover-theme" href="/">Home</a></nav><article id="contents"><h1>JavaScript를 이용하여 접근할 수 있는 브라우저 주요 부분</h1><div><h2>BOM; Browser Object Model</h2><p>웹브라우저에서 제공하는 객체들로, window를 최상위 전역 객체로 하여 노출된다. DOM과 다르게 표준 제정이 없으므로, 세부 사항은 브라우저 공급자마다 다를 수 있다</p><ul><li>window : 브라우저 윈도우(탭)를 가리키는 객체</li><li>screen : window.screen과 동일. 표시되는 화면과 연관</li><li>location : window.location과 동일. 현재 페이지 URL과 연관</li><li>history : window.history와 동일. 페이지 기록과 연관</li><li>navigator : window.navigator와 동일. 브라우저 자체(user agent; UA)와 연관</li><li>document : window.document와 동일. 표시되는 페이지 내용과 연관(DOM)</li></ul><h2>DOM; Document Object Model</h2><p>브라우저 탭에 로드된 HTML 문서는 DOM으로 표현된다. 이는 HTML 구조에 쉽게 접근할 수 있도록 설계된 트리 구조의 표현 방식으로, 브라우저는 페이지를 렌더링할 때 올바른 요소에 스타일과 기타 정보를 적용하기 위해 이를 사용하고, 개발자는 페이지가 렌더링된 이후 JavaScript를 통해 DOM을 조작할 수 있다</p><ul><li>요소 선택 : firstChild, children 등의 속성, querySelector(), getElementById() 등의 메서드 이용</li><li>요소 수정 : textContent, style, value 등의 속성, setAttribute() 등의 메서드 이용</li><li>요소 추가/이동 : after(), before(), append() 등의 메서드 이용</li><li>요소 생성 : createElement(), cloneNode() 등의 메서드 이용</li><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Single/202411/11-0956.html" lan="nohighlight">cloneNode() 예</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Single/202411/11-0956.html" lan="HTML">&lt;- 코드</button><li>요소 삭제 : remove(), removeChild() 등의 메서드 이용</li></ul></div><h1>이벤트 모델</h1><div><h2>DOM 이벤트 흐름</h2><p>이벤트 캡처링 → 타깃 → 이벤트 버블링</p><ul><li>이벤트 캡처링 : 최상위 노드로부터 이벤트가 전달되는 과정</li><p>캡처링 단계에서 핸들러를 호출하려면 addEventListener()의 옵션 매개변수를 지정해야 한다 -- 기본적으로는 이벤트 버블링 단계에 등록된다</p><p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">document.body.addEventListener("click", handleClick, { capture: true });</div><li>이벤트 버블링 : 최하위 노드로부터 이벤트가 전달되는 과정</li><p>이를 이용하여 여러 자식요소들에 각각 이벤트 리스너를 등록하는 대신, 부모에만 한 번 등록하여 처리를 위임할 수 있다 (event delegation)</p><li>따라서 이벤트의 target과 currentTarget이 가리키는 요소가 서로 다를 수 있음에 유의해야 한다</li></ul><h2>JavaScript 이벤트 핸들러 설정</h2><ol><li>EventTarget : Element, Document, Window, XMLHttpRequest</li><li>EventTarget.addEventListener() : 이벤트 핸들러 추가</li><li>EventTarget.dispatchEvent() : 처리할 이벤트 추가</li><li>EventTarget.removeEventListener() : 이벤트 핸들러 제거</li><p>또는 핸들러 등록 시 AbortSignal 객체를 같이 전달한 뒤, 객체의 abort()를 호출하면 관련된 모든 핸들러를 제거할 수 있다</p><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Single/202411/05-1432.html" lan="nohighlight">예시</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Single/202411/05-1432.html" lan="HTML">예시 코드</button></ol></div><h1>브라우저 저장소</h1><div><p>클라이언트에 정보를 저장하는 API로, 도메인 별로 격리된다 -- 다른 도메인의 데이터를 JavaScript로 접근할 수 없다</p><h2>쿠키</h2><ul><li>가장 오래된 방법으로, 저장된 키-값 쌍들은 해당 도메인 서버로 보내지는 요청에 헤더로 자동 포함된다</li><li>일반적으로 정보 저장은 서버 응답 헤더(Set-Cookie)를 통해 발생하고, 클라이언트 코드는 이 헤더에 직접적으로 접근할 수 없다</li><li>키/값으로 제어 문자를 제외한 US-ASCII 문자열을 이용할 수 있는데, 값으로는 <a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="https://developer.mozilla.org/en-US/docs/Glossary/Percent-encoding">Percent-encoding</a>이 보통 이용된다 -- 표준 스펙에 정의하는 사항은 아님</li></ul><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Single/202411/11-1344.html" lan="nohighlight">쿠키 예</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Single/202411/11-1344.html" lan="HTML">&lt;- 코드</button><h2>캐시</h2><ul><li>HTTPS 응답 자체를 일시 보관하여 이후 동일 요청 발생 시 사용한다</li><li>캐시를 사용하기에 앞서 먼저 서비스 워커를 설치해야 한다</li><ol><li>서비스 워커가 사용 가능한지 확인하고</li><p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">if ("serviceWorker" in navigator) {}</div><li>서비스 워커를 등록한다</li><p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">navigator.serviceWorker.register('path-to-js')</div><li>페이지를 다시 로드하면 서비스 워커가 페이지를 제어할 수 있다</li><p><strong>↓ 워커 코드</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">self.addEventListener("install", (e) => {})</div><li>CacheStorage는 캐시 집합으로, 키를 이용해 각 캐시들을 구별한다</li><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/offline-service-worker.js" lan="JavaScript">offline-service-worker.js</button></ol></ul><h2>웹 저장소</h2><ul><li>sessionStorage : 브라우저가 열려 있는 동안에만 유지</li><li>localStorage : 브라우저가 종료돼도 유지</li></ul><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Single/202411/11-1453.html" lan="nohighlight">localStorage 예</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Single/202411/11-1453.html" lan="HTML">&lt;- 코드</button><h2>IndexedDB</h2><ul><li>객체 저장소로, JavaScript 기본 자료형뿐만 아니라 Blob(이미지, 비디오 등)과 같은 객체도 저장할 수 있다</li><li>웹 저장소에 비해 제공되는 용량이 훨씬 크다 -- 단, 한계에 도달하면 기존 데이터를 희생한다</li></ul><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Single/202411/11-1505.html" lan="nohighlight">IndexedDB 예</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Single/202411/11-1505.html" lan="HTML">&lt;- 코드</button><ol><li>IDBFactory#open() 메서드로 연결을 시작한다</li><ul><li>연결에 성공한 경우 success 이벤트의 result 속성으로 IDBDatabase 객체가 설정된다</li><li>버전 지정 없이 존재하지 않는 DB에 연결하는 경우, 신규 DB를 버전 1로 생성하여 연결한다</li><li>버전 지정 없이 이미 존재하는 DB에 연결하는 경우, DB 버전을 변경하지 않고 연결한다</li><li>DB가 새로 생성됐거나, 새로운 버전으로 변경된 경우 upgradeneeded 이벤트가 발생한다 -- target.result 속성으로 IDBDatabase 객체가 설정된다</li></ul><li>IDBDatabase#createObjectStore() 메서드로 객체 저장소(RDB의 테이블에 해당)를 생성한다</li><ul><li>객체 저장소 생성 시 키 정의가 필수다</li><li>키를 자동으로 순서대로 생성하기 원한다면 autoIncrement 옵션을 true로 설정한다 -- 기본값 false</li><li>값 객체로부터 키를 자동으로 구성하기 원한다면 or 자동 생성한 키를 값에 설정하려면 유효한 식별자로 keyPath 옵션을 설정한다 -- 기본값 미설정</li><li>keyPath를 지정하지 않으면 out-of-line 키를 사용하게 되며, 레코드 저장 시 값과 별도로 저장된다</li></ul><li>IDBObjectStore 객체를 이용해 연산을 수행한다</li><ul><li>createIndex() 메서드로 레코드의 필드/컬럼을 정의한다</li><li>add() 메서드로 신규 레코드 삽입 -- 이미 키가 존재하면 ConstraintError 이벤트 발생 </li><li>put() 메서드로 upsert 수행</li><li>count(), get(), getAll(), openCursor() 등으로 조회 쿼리 수행</li></ul><li>명시적 트랜잭션을 수행하려면 아래와 같이 작업한다</li><ol><li>IDBDatabase#transaction() 메서드로 새 트랜잭션을 시작한다</li><p>durability 옵션으로 complete 이벤트를 발생할 조건을 지정할수 있다</p><ul><li>strict : 물리적으로 저장됐음을 확인한 후 이벤트 발생</li><li>relaxed : 커밋을 OS에 전달했으면 이벤트 발생</li></ul><li>반환된 IDBTransaction 인스턴스로 객체 저장소에 연산을 수행한다</li><li>commit() 메서드는 사용이 권장되지 않는다 -- 새로운 요청이 없으면 자동으로 커밋된다</li><li>트랜잭션은 생성된 순서대로 반영된다</li></ol></ol></div><h1>웹 워커</h1><ol><li>메인 페이지와 별개의 스코프에서 백그라운드에서 실행되는 작업자</li><p>메인 스레드와 워커 스레드는 서로 메시지를 주고 받음으로써 실행을 조율한다</p><li>웹 워커 내부에서 전역 객체는 worker 자체</li><li>dedicated worker 외의 워커를 디버깅하려면 전용 브라우저 개발 도구를 이용한다</li><p><strong>↓ text</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">chrome://inspect/#workers   // chrome
edge://inspect/#workers     // edge
about:debugging#workers     // firefox</div></ol><div><h2>Dedicated Worker</h2><p>단일 스크립트 인스턴스에서만 사용</p><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Single/202411/08-1725-main.html" lan="nohighlight">메인 HTML</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Single/202411/08-1725-main.html" lan="HTML">메인 코드</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Single/202411/08-1725-worker.js" lan="JavaScript">워커 코드</button><h2>Shared Worker</h2><ul><li>동일 출처의 스크립트들에 한하여, 서로 다른 창에서 실행되는 스크립트들이 공유 가능</li><li>공유 워커는 자신을 참조하는 활성 페이지가 존재하는 동안 계속 실행</li><li>지원하지 않는 브라우저가 많음 (2024-11-08 기준)</li></ul><h2>Service Worker</h2><p>프록시 서버처럼 작동하여, 웹 앱이 오프라인 상태에서 작동할 수 있도록 리소스를 캐싱</p></div><h1>웹 소켓</h1><ol><li>오래 지속되는 하나의 연결을 이용해 완전한 양방향 통신을 제공한다</li><li>프로토콜은 ws(비보안), wss(보안)</li><li>웹 소켓은 동일 소스 정책이 적용되지 않으므로, 연결을 수락할지는 완전히 서버의 권한</li><li>이벤트 종류 : open, message, error, close</li><li>연결 유효성 확인을 위해 주기적으로 ping-pong을 주고받는 것이 권장된다</li></ol><p><strong>↓ javascript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="javascript">let connection = new WebSocket("ws://host-address/page_or_function_name");
// new WebSocket("wss://secure.example.com/chat", {"chat.v1", "chat.v2"});
// connection.readyState === WebSocket.OPEN // CONNECTING, OPEN, CLOSING, CLOSED
// connection.bufferedAmount : 전송 대기중인 크기

connection.send("Hello World");
connection.onmessage = function(event) { event.data ... }
// onopen, onclose, onerror
// onclose 이벤트 종료코드 1000외는 모두 비정상 종료 : http://tools.ietf.org/html/rfc6455#section-7.4
// onmessage 이벤트 data 프로퍼티 : 메시지가 텍스트면 문자열, 메시지가 바이너리고 connection.binaryType이 "blob"(기본)이면 Blob, 메시지가 바이너리고 connection.binaryType이 "arraybuffer"면 ArrayBuffer

connection.close(); // close 이벤트 객체는 wasClean, code, reason 프로퍼티 존재
</div><h1>함수 감속</h1><p>윈도우 resize, scroll 이벤트처럼 연속적으로 발생하지만 연속적으로 처리할 필요가 없는 경우, 타이머를 등록한 뒤 로직이 실행되도록 하고, 로직이 실행되기 전에 재호출되면 기존 타이머를 제거하고 타이머를 재등록하는 기법</p><p><strong>↓ javascript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="javascript">function throttle(f, t, opt) {
    return function (args) {
        let previousCall = this.lastCall;
        this.lastCall = Date.now();
        if (!previousCall || (!!opt && !!opt.fast) || (this.lastCall - previousCall) > t) {
            f(args);
        }
    }
}
function debounce(f, t, opt) {
    return function (args) {
        let previousCall = this.lastCall;
        this.lastCall = Date.now();
        if (previousCall && ((this.lastCall - previousCall) &lt;= t)) {
            if (!opt || !opt.fast)
                clearTimeout(this.lastCallTimer);
        }
        this.lastCallTimer = setTimeout(() => f(args), t);
    }
}
</div><h1>AJAX; Asynchronous JavaScript and XML + JSONP</h1><ol><li>핵심 기술은 XMLHttpRequest; XHR</li><li>Ajax 이벤트</li><ul><li>loadstart : 응답의 첫 번째 바이트를 수신</li><li>progress : 응답 수신 중 계속 발생</li><li>error : 요청에 에러가 있을 때</li><li>abort : abort() 호출해 연결을 종료했을 때</li><li>load : 응답을 완전히 받았을 때</li><li>loadend : 통신 종료. error, abort, load보다 나중에 발생</li></ul><li>JSONP : JSON with Padding</li><p>Cross origin 제약이 적용되지 않는다. &lt;script src="~.js">&lt;/script>, &lt;script src="~.json">&lt;/script>도 JSONP 통신의 일종</p></ol><p><strong>↓ javascript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="javascript">// XMLHttpRequest 예
let request = new XMLHttpRequest();
// XMLHttpRequest.open(method, url, async, user, password)
request.open('GET', './index.html', false);
request.send();
console.log(request.responseText);

// FormData를 보낼 수 있다
let data = new FormData();
data.append("key", "value");
let data = new FormData(document.forms[0]);
request.send(data);
// Blob, BufferSource, FormData, URLSearchParams, ReadableStream, USVString 전송 가능

// jQuery Ajax 구문
//     Ajax 간편 표기 : $.get(), $.post(), $.getJSON(), $.getScript(), $(selector).load()
$.ajax({ type: 'get', url: './index.html', success: (data) => console.log(data) });
$.ajax({
    type: 'post',
    dataType: 'json',
    url: 'http://donggi.dothome.co.kr/add_comment.php',
    data: { path: path, comment: comment },
    success: (data) => {
        if (data === "OK") {
            showSnackbar("등록 성공", $('body'));
            $(posts.contents[id]).find('input.form-control').val('');
            getComment(path);
        } else {
            showSnackbar("60초당 1번씩 등록 가능", $('body'));
        }
    },
    error: (request, status, error) => {
        showSnackbar("등록 실패.", $('body'));
    }
});
// jQuery Ajax 옵션
//     async, complete(xhr, status), data, error(xhr, status, error), jsonp, jsonpCallback, success(data, status, xhr), timeout, type, url
</div><h1>파일 API</h1><ol><li>이전에는 자바스크립트에서 로컬 파일에 접근하는 것이 불가능했지만, 사용자가 입력 태그에 직접 설정한 파일에 대해 읽기가 가능해졌다</li><p>로컬 파일 접근을 허용하는 브라우저에서 &lt;input type="file"> 요소의 files 프로퍼티는 FileList 객체다FileList는 길이 0 이상의 File 객체 목록이며, File 객체는 name과 lastModifiedDate 프로퍼티가 있는 Blob 객체다</p><li>아래 입력 필드에 아무 파일이나(이왕이면 이미지로) 드롭해보세요</li><p><input id="basic2-input-files1" type="file" multiple><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/JavaScript/Browser/file_example.js" lan="javascript">file_example.js</button></p><li>File, Blob 객체를 slice하면 Blob 객체가 반환된다</li><li>BLOB; BInary Large Object</li><ul><li>postMessage()로 웹 워커에 blob을 보낼 수 있다</li><li>XMLHttpRequest.send()로 blob을 보낼 수 있다</li><li>URL.createObjectURL()로 blob:// 주소를 가져올 수 있으며, 이 url은 DOM이나 CSS를 활용할 수 있다</li><p>Blob URL 삭제 : URL.revokeObjectURL()<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/JavaScript/Browser/blob_example.js" lan="javascript">blob_example.js</button></p><li>FileReader 객체를 사용하면 Blob 내용을 비동기적으로 문자열이나 ArrayBuffer로 추출할 수 있다</li></ul><li>FileReader</li><p><strong>↓ javascript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="javascript">readAsText(file, encoding), readAsDataURL(file), readAsBinaryString(file), readAsArrayBuffer(file)</div></ol><h1>유용한 스크립트</h1><ul><li><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js">CryptoJS</a></li><p>연관 포스트로 이동 : <a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black goto" href="node.html#pos-1823460886" target="_blank">CryptoJS</a></p></ul><h1>잡다한 코드</h1><ul><li>특정 노드로 스크롤 이동</li><p><strong>↓ javascript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="javascript">node.scrollIntoView()</div><li>특정 위치로 스크롤 이동</li><p><strong>↓ javascript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="javascript">window.scrollTo({ top: 123 })</div><li>페이지 갱신없이 히스토리 변경</li><p><strong>↓ javascript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="javascript">// 이동
window.history.pushState({ html: path, pageTitle: document.title }, document.title, `${location.origin}${path}`);
// 뒤로가기 이벤트 리슨
window.onpopstate = function(e) {
    let postQuery = e.state.html.match(/[?&]post=([^&]+)/);
    if (!!postQuery) {
        document.title = e.state.pageTitle;
        scrollToPost(postQuery[1]);
    }
};</div></ul></article></main></body></html>