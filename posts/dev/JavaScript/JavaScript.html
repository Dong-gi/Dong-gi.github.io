<!DOCTYPE html><html lang="ko-KR"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes"><title>JavaScript</title><link rel="stylesheet" href="/source/default.css"><meta name="google-site-verification" content="aH-DyzdytYQ0NPHNQFcs5dVoiu5YNs6CEEHYgqDmAFM"><meta name="author" content="Donggi Kim &lt;hi.donggi@gmail.com&gt;"><meta name="description" content="JavaScript(ECMAScript) 정리"><link rel="icon" href="/imgs/favicon.png"><script id="highlight-js" src="/source/highlight.pack.js" async></script><script id="default-js" src="/source/default.min.js" defer></script><script id="google-analytics" src="https://www.googletagmanager.com/gtag/js?id=UA-143098403-1" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-143098403-1');
</script></head><body><aside class="w3-animate-left" id="sidebar"><hr><div id="marker-list"></div><hr><div id="post-list"></div><hr><details class="w3-small"><summary>LICENSE</summary><table class="w3-table-all w3-card w3-small"><tr><td>Author</td><td>License</td></tr><tr><td>&copy; <a href="mailto:hi.donggi@gmail.com">Donggi Kim</a></td><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/Dong-gi/Dong-gi.github.io/blob/master/LICENSE">MIT</a></td></tr><tr><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://www.w3schools.com/w3css">w3css</a></td><td>No license</td></tr><tr><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://highlightjs.org/">highlight.js</a></td><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/highlightjs/highlight.js/blob/main/LICENSE">BSD-3-Clause</a></td></tr><tr><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/mathjax/MathJax">MathJax</a></td><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/mathjax/MathJax/blob/master/LICENSE">Apache-2.0</a></td></tr><tr><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/davidshimjs/qrcodejs">QRCode.js</a></td><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/davidshimjs/qrcodejs/blob/master/LICENSE">MIT</a></td></tr><tr><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/terrastruct/d2">D2</a></td><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/terrastruct/d2/blob/master/LICENSE.txt">MPL-2.0</a></td></tr></table></details><hr></aside><main id="main"><nav class="w3-bar w3-blue" id="nav"><button class="w3-bar-item w3-button w3-hover-theme" id="nav-toggle-btn" type="button" aria-label="Toggle navigation menu" title="Toggle navigation menu">&#9776;</button><form role="search"><input class="w3-bar-item" id="query" type="search" placeholder="search" style="max-width:35%"></form><a class="w3-bar-item w3-button w3-hover-theme" href="/">Home</a></nav><article id="contents"><h1>자료</h1><ul><li><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript">MDN &gt; JavaScript 배우기</a></li><li><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://web.dev/learn/javascript">web.dev &gt; JavaScript 배우기</a></li><li><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://exploringjs.com/">Exploring JavaScript</a></li></ul><h1>JavaScript 역사</h1><div><h2>참고자료</h2><ul><li><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://dzone.com/articles/a-brief-history-of-javascript">a-brief-history-of-javascript</a></li><li><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://en.wikipedia.org/wiki/JavaScript">JavaScript</a></li></ul><h2>현재</h2><p>JavaScript는 ECMAScript 표준을 준수하는 고급 프로그래밍 언어로, JIT 컴파일로 실행되는 스크립트 언어</p><h2>넷스케이프의 창조</h2><ul><li>1995년. 동적 웹 콘텐츠 개발을 위해 DOM과 상호작용할 수 있는 프로그래밍 언어를 추가하기 위한 결정이 이루어졌다</li><li>넷스케이프의 "브라우저를 위한 Scheme" 개발 프로젝트에 JavaScript의 아버지 Brendan Eich도 있었다</li><p>Scheme은 Lisp의 방언 중 하나</p><ul><li>당시 이미 넷스케이프와 썬 마이크로시스템즈는 브라우저에서 Java를 사용(자바 애플릿)할 수 있도록 계약을 체결하려는 시점이었다</li><li>따라서 새로운 언어(개발명 Mocha)를 추가하는 목적은 프로그램 개발이 아니라, HTML 안에서 동적으로 애니메이션 추가, 디자인 변경 등을 수행하는 것(작은 스크립팅 작업)이었으며, 전문 개발자가 아닌 HTML을 작성할 줄 아는 디자이너와 같은 사람들이 타깃 유저층이었다</li><li>즉, Mocha는 Java의 스크립팅 동반자가 되어야 했다. 이를 위해 Java와 유사한 구문들이 채택되었고, Scheme으로부터 멀어진 모습을 갖게 되었다</li></ul><li>1995년 9월 베타 출시하면서 LiveScript로 이름 변경</li><li>1995년 12월 정식 출시하면서 JavaScript로 이름 변경 (썬 마이크로시스템즈와 합의)</li></ul><h2>마이크로소프트의 채택</h2><ul><li>1995년 인터넷 익스플로러(IE)를 출시한 뒤 넷스케이프와 브라우저 전쟁을 벌였다</li><li>1996년 8월 넷스케이프의 스크립트 인터프리터를 리버스 엔지니어링하여 자체 인터프리터 JScript를 출시</li><p>상표권 문제가 될 수 있기 때문에 "Java"를 그대로 사용하지 않았다</p><li>두 브라우저의 스크립트 엔진 구현이 달랐기 때문에, 같은 코드가 서로 다르게 보이는 일이 잦았다</li><p>불행히도 IE가 독점적인 위치를 차지하는 동안, 개발자는 IE를 위한 특별한 처리를 해줘야 했다</p></ul><h2>표준화 시도</h2><ul><li>1996년 11월 넷스케이프는 브라우저 공급업체가 준수할 수 있는 표준 사양의 출발점으로 JavaScript를 ECMA International에 제출</li><li>1997년 6월 첫 번째 ECMAScript 발표</li><p>마찬가지로 상표권 문제가 있으므로 "Java"를 그대로 사용하지 않음. 이제 JavaScript는 상업적 이름일 뿐</p><li>1998년 6월 ECMAScript 2 발표</li><p>ECMAScript와 JavaScript용 ISO 표준(ISO/IEC 16262) 사이의 불일치를 수정</p><li>1999년 12월 ECMAScript 3 발표</li><p>정규식, try/catch 블록, in 및 instanceof 연산자 등 추가</p></ul><h2>ECMAScript 3.1과 4</h2><div><p>ECMAScript 4에 대한 작업은 버전 3이 출시되자마자 시작되었는데, 위원회에 강한 의견 차이가 대두되었다</p><ul><li>JavaScript가 대규모 애플리케이션을 개발할 수 있는 강력한 언어가 되기 위해 새로운 기능이 필요하다</li><p>vs</p><li>그러한 변경 사항은 JavaScript에 적합하지 않다</li></ul><p>버전 4에 대한 작업은 2003년 잠시 중단되었다가, 2005년 AJAX와 XMLHttpRequest의 영향으로 새 버전에 대한 관심이 높아지면서 작업이 재개되었다. 개발이 절정에 달했을 때 버전 4에는 다음과 같은 기능들이 포함되었다</p><ul><li>클래스, 인터페이스, 구조체, 사용자 정의 타입, 파라미터화된 타입</li><li>패키지, 네임스페이스</li><li>반복자, 생성자</li><li>선택적 타입 주석, 선택적 정적 타입 체크</li><li>...</li></ul><p>버전 4를 개발하는 위원회는 Adobe, Mozilla, Opera(비공식 자격), Microsoft로 구성되었는데, 대부분의 표준이 결정된 상태에서 Yahoo가 참여했다. 영향력 있는 JavaScript 개발자 Doug Crockford이 Yahoo에서 보낸 사람이었는데, 그는 버전 4의 많은 변경 사항에 대해 강력히 반대 의사를 표명했고 Microsoft로부터 강력한 지지를 받았다. 결국 버전 4 개발은 지지부진해졌고, Crockford는 모두가 동의할 수 있는 -- 구문 변경 없는 실용적인 개선사항만 담은 새로운 표준을 추진했고, 이것이 ECMAScript 3.1이다</p><p>2008년 오슬로에서 열린 회의에서 ECMAScript 3.1과 4의 미래가 결정되었다</p><ul><li>모든 구성원의 협력으로 ES3.1 완성에 집중</li><li>이후 ES4보다는 완화된 의미론적 및 구문론적 혁신에 대해 협력</li><li>패키지, 네임스페이스 등 웹에 적합하지 않은 제안은 제외</li></ul><h3>ActionScript</h3><ul><li>ActionScript는 ECMAScript 4 초안을 기반으로 하는 언어로, Adobe는 이를 Flash 제품군의 일부로 구현해 출시했다</li><li>때문에 Adobe는 ECMAScript 4를 강력히 지지했고, 채택을 위해 엔진을 오픈 소스(Tamarin)로 출시하기도 했다</li></ul></div><h2>ECMAScript 5</h2><ul><li>ECMAScript 4는 이미 8년의 개발을 거쳐 특정 변형으로 인식되었으므로, 혼동을 피하기 위해 ECMAScript 3.1의 이름은 ECMAScript 5로 변경되었다</li><li>2009년 출시된 ES5는 가장 많이 지원되는 JavaScript 버전 중 하나가 되었고, 많은 트랜스파일러의 기본 컴파일 대상이 되었다</li><p>Firefox 4 (2011), Chrome 19 (2012), Safari 6 (2012), Opera 12.10 (2012) 및 Internet Explorer 10 (2012)에서 전적으로 지원</p><li>수정사항</li><ul><li>Getter/setter</li><li>배열 및 객체 리터럴에서 후행 쉼표</li><li>예약어를 프로퍼티 이름으로 허용</li><li>신규 Object 메서드 : create, defineProperty, keys, seal, freeze, ...</li><li>신규 Array 메서드 : isArray, indexOf, every, some, map, filter, reduce, ...</li><li>신규 Date 메서드 : toISOString, now, toJSON</li><li>String.prototype.trim 추가</li><li>JSON</li><li>불변 전역 객체 : undefined, NaN, Infinity</li><li>Strict 모드</li><li>...</li></ul></ul><h2>ECMAScript 6 (2015) : 범용 언어</h2><ul><li>ECMAScript 4에서 폐기되지 않은 아이디어는 ECMAScript Harmony에서 새롭게 제안되었고, ECMAScript 2015로 이름이 바뀐 ECMAScript 6는 이러한 구문 변경이 필요한 업데이트를 담고 있다</li><p>이러한 구문 변경들은 브라우저 공급업체들이 모두 지원하기까지 상당한 시간이 소요됐고, 이로 인해 ECMAScript 2015 출시 이후 트랜스파일러의 사용이 크게 증가했다</p><li>ECMAScript 2015 수정사항</li><ul><li>let, const 변수 선언</li><li>화살표 함수와 this 키워드</li><li>클래스</li><li>객체 리터럴 개선 : 계산된 키 사용, 더 짧은 메서드 정의 등</li><li>템플릿 문자열</li><li>Promise</li><li>생성자, iterable, 반복자, for..of 구문</li><li>신규 컬렉션 : Set, Map, WeakSet, WeakMap</li><li>배열 해체 할당</li><li>...</li></ul></ul></div><h1>식별자</h1><ol><li>식별자 : '_', '$' 허용<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" type="button" title="/Repositories/JavaScript/Basic/type.js" displayRange="[1,1]" lan="javascript">type.js</button></li><li>변수 선언</li><ul><li>let 식별자;</li><p>일반적인 지역변수와 동일. 선언된 순간부터 해당 코드 블록이 끝날때까지 유효. 중첩된 코드 블록에서 같은 식별자의 변수를 선언하여 밖의 변수를 가릴 수 있다<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" type="button" title="/Repositories/JavaScript/Basic/type.js" displayRange="[2,2]" lan="javascript">type.js</button></p><li>var 식별자;</li><p>선언 전에 참조하는 경우, 선언을 끌어올려 undefined를 할당해준다. 함수 스코프에서 동작하지만, 중첩된 코드 블록에서 재정의하여 가릴 수 없다</p></ul><li>상수 선언 : const 식별자;<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" type="button" title="/Repositories/JavaScript/Basic/type.js" displayRange="[4,4]" lan="javascript">type.js</button></li></ol><h1>자료형</h1><ul><li>Object</li><ol><li>객체 리터럴 : {}</li><li>delete 키워드로 프로퍼티 제거 가능</li><li>JSON.stringify(), JSON.parse(), Object.keys()<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" type="button" title="/Repositories/JavaScript/Basic/type.js" displayRange="[11,15]" lan="javascript">type.js</button></li></ol><li>String</li><ol><li>문자 리터럴 : \xFF, \uFFFF</li><li>문자열 리터럴 : '', "", ``(문자열 템플릿)<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" type="button" title="/Repositories/JavaScript/Basic/type.js" displayRange="[4,5,17,17]" lan="javascript">type.js</button></li><li>slice()는 code unit 단위로 자르기를 수행하므로, code point 단위의 자르기를 원한다면 [...str].slice()를 이용</li></ol><li>Number</li><ol><li>IEEE-764 double-precision 부동소수</li><li>숫자 리터럴 : 999, 0o777, 0xFFF, 0.999, 0.999E-9</li><li>숫자 상수 : Infinity, -Infinity, NaN, Number.EPSILON, Number.MAX_VALUE, Number.MAX_SAFE_INTEGER</li><li>Number(), parseInt(), parseFloat(), number.toString(radix)</li></ol><li>Boolean</li><p>Boolean() : "", 0, NaN, null, undefined == false, 그 외 == true</p><li>Undefined</li><li>Null</li><li>Symbol</li><p>ES6부터 도입된 타입. 그 무엇과도 같지 않은 유일한 토큰을 나타낸다<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" type="button" title="/Repositories/JavaScript/Basic/type.js" displayRange="[7,9]" lan="javascript">type.js</button></p><li>배열 : []</li><p>자바스크립트의 배열은 모두 동적 배열. 변수와 마찬가지로 타입을 가리지 않는다<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" type="button" title="/Repositories/JavaScript/Basic/array.js" lan="javascript">array.js</button></p><li>Map</li><p><strong>↓ javascript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="javascript">new Map(iterable: Iterable&lt;readonly [K, V]>)
new Map(entries?: readonly (readonly [K, V])[])
set(key, value), get(key), has(key)
delete(key), clear()
size, keys(), values(), entries()</div><li>WeakMap</li><p>키는 반드시 객체여야 하며, 키는 GC 대상이 된다. 따라서 객체가 살아있는 동안에 참조해야 하는 고유값들을 저장하기에 좋다</p><li>Set</li><p><strong>↓ javascript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="javascript">new Set(iterable?: Iterable&lt;any>)
new Set(values?: readonly T[])
add(value), has(value), ...</div><li>WeakSet</li><p>값은 반드시 객체여야 하며, GC 대상이 된다</p></ul><h1>연산자</h1><ol><li>Boolean 연산자 : !, &&, ||</li><p>&&, ||는 short circuit 연산</p><li>비트 연산자 : ~, &, |, ^, &lt;&lt;, >>, >>></li><li>,연산자 : 순서대로 평가하여 마지막 표현식의 결과가 할당됨<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" type="button" title="/Repositories/JavaScript/Basic/syntax.js" displayRange="[9,10]" lan="javascript">syntax.js</button></li><li>in 연산자 : 객체에 해당 프로퍼티가 존재하는지 여부 반환<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" type="button" title="/Repositories/JavaScript/Basic/syntax.js" displayRange="[12,12]" lan="javascript">syntax.js</button></li><p>객체에 직접 정의된 프로퍼티는 hasOwnProperty() 메서드 이용</p><li>instanceof 연산자 : 객체 호환 여부 반환</li><li>해체 할당; Destructuring Assignment</li><p><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" type="button" title="/Repositories/JavaScript/Basic/syntax.js" displayRange="[15,22]" lan="javascript">배열 해체 할당 »</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" type="button" title="/Repositories/JavaScript/Basic/syntax.js" displayRange="[26,29]" lan="javascript">배열 연속 해체 »</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" type="button" title="/Repositories/JavaScript/Basic/syntax.js" displayRange="[33,36]" lan="javascript">다차원 배열 해체 »</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" type="button" title="/Repositories/JavaScript/Basic/syntax.js" displayRange="[40,47]" lan="javascript">확산 연산자 »</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" type="button" title="/Repositories/JavaScript/Basic/syntax.js" displayRange="[51,65]" lan="javascript">객체 해체 할당 »</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" type="button" title="/Repositories/JavaScript/Basic/syntax.js" displayRange="[69,71]" lan="javascript">객체 메서드 해체 할당 »</button></p></ol><h1>Syntax</h1><ol><li>if...[else if...][else...]</li><li>while, do...while</li><li>for<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" type="button" title="/Repositories/JavaScript/Basic/syntax.js" displayRange="[1,7]" lan="javascript">syntax.js</button></li><li>switch : 조건으로 변수가 아닌 일반 표현식도 가능</li><li>for(let attr in obj) {} : 객체 프로퍼티 순회</li><li>for(let name of iterable) {} : 배열, Iterable 객체 순회</li><li>with(obj) : 스코프 고정</li><li>try ~ catch ~ finally</li><p>예외 처리. throw는 임의의 타입을 던질 수 있다. try 뒤에 catch 또는 finally가 하나라도 있어야 한다</p></ol><h1>Function</h1><ol><li>오버로딩 불가. 함수 호출 시 매개변수 길이 불일치해도 됨</li><li>arguments 객체를 통해 매개변수에 접근.(람다는 불가능)</li><li>매개변수에 기본값 설정 가능</li><li>매개변수도 해체, 확산 연산자 사용 가능</li><li>명시하지 않은 경우, 함수의 기본 반환값은 undefined</li><li>함수가 호출하는 지점보다 나중에 정의되어 있는 경우, 함수 선언이 위로 끌어올려진다</li><li>함수의 컨텍스트(this) 지정</li><p><strong>↓ javascript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="javascript">hello.apply({name: "Donggi"}, ["2018-08-08"]); // apply(호출자, 매개변수 배열)
hello.call({name: "Donggi"}, "2018-08-08");    // call(호출자, 매개변수)
// 확산 연산자 ...을 이용하면 call로 apply와 같은 효과를 낼 수 있다
let helloKim = hello.bind({name: "Kim"});      // 함수 호출자 영구 고정</div><li>함수 표현식 let f = function functionName() {}</li><li>익명 함수 let f = function () {}</li><li>화살표 표기법 let f = () => {}</li><li>클로저 Closure</li><p>함수 할당에 의해 접근할 수 있는 스코프가 늘어나는 것<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" type="button" title="/Repositories/JavaScript/Basic/function.js" displayRange="[2,8]" lan="javascript">function.js</button></p><li>즉시 실행 함수 표현 IIFE; Immediately Invoked Function Expression<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" type="button" title="/Repositories/JavaScript/Basic/function.js" displayRange="[12,17]" lan="javascript">function.js</button></li></ol><h1>Class</h1><ol><li>클래스는 본질적으로 함수다. 단순히 문법적 편의성이 더해졌을 뿐</li><p><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" type="button" title="/Repositories/JavaScript/Basic/class.js" displayRange="[1,15]" lan="javascript">클래스 정의 예 »</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" type="button" title="/Repositories/JavaScript/Basic/class.js" displayRange="[18,19]" lan="javascript">상속 예 »</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" type="button" title="/Repositories/JavaScript/Basic/class.js" displayRange="[22,39]" lan="javascript">믹스인 예 »</button></p><li>전역 객체</li><p>Object, Array, String, Global, Math<br>Global 객체를 직접 획득하는 건 불가능 : isNaN(), isFinite(), parseInt(), parseFloat(), encodeURI(), encodeURIComponent(), eval()</p><li>Private 멤버</li><p>#으로 시작되는 프로퍼티, 메서드는 객체 외부에서 접근할 수 없다</p><li>객체 보호</li><p><strong>↓ javascript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="javascript">Object.freeze()            // 객체 동결. 읽기만 가능
Object.seal()              // 객체 봉인. 기존 프로퍼티 값은 수정 가능
Object.preventExtensions() // 객체 확장 금지. 새 프로퍼티 추가만 금지</div><p><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" type="button" title="/Repositories/JavaScript/Basic/class.js" displayRange="[42,70]" lan="javascript">접근자 프로퍼티 + 객체 보호 예 »</button></p></ol><div><h2>프록시</h2><p><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler#Methods">참고자료</a><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" type="button" title="/Repositories/JavaScript/Basic/class.js" displayRange="[73,85]" lan="javascript">프록시 예 »</button></p><table class="w3-table-all w3-card w3-small"><tr><th>getPrototypeOf()</th><td>A trap for Object.getPrototypeOf</td></tr><tr><th>setPrototypeOf()</th><td>A trap for Object.setPrototypeOf</td></tr><tr><th>isExtensible()</th><td>A trap for Object.isExtensible</td></tr><tr><th>preventExtensions()</th><td>A trap for Object.preventExtensions</td></tr><tr><th>getOwnPropertyDescriptor()</th><td>A trap for Object.getOwnPropertyDescriptor</td></tr><tr><th>defineProperty()</th><td>A trap for Object.defineProperty</td></tr><tr><th>has()</th><td>A trap for the in operator</td></tr><tr><th>get()</th><td>A trap for getting property values</td></tr><tr><th>set()</th><td>A trap for setting property values</td></tr><tr><th>deleteProperty()</th><td>A trap for the delete operator</td></tr><tr><th>ownKeys()</th><td>A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols</td></tr><tr><th>apply()</th><td>A trap for a function call</td></tr><tr><th>construct()</th><td>A trap for the new operator</td></tr></table></div><h1>Iterator, Generator</h1><p>해체 할당과 마찬가지로 파이썬에서 가져온 아이디어들 중 하나<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" type="button" title="/Repositories/JavaScript/Basic/iterator.js" lan="javascript">이터레이션 프로토콜 예 »</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" type="button" title="/Repositories/JavaScript/Basic/generator.js" lan="javascript">제너레이터 예 »</button></p><ul><li>파이썬과 마찬가지로 제어권을 주고받는 데 제너레이터를 사용한다</li><li>yield 키워드를 사용하는 모든 함수는 제너레이터 함수다</li><li>제너레이터 함수를 호출하면 제너레이터 객체를 받는다</li><li>제너레이터의 실행을 재개하는 3가지 메서드 : next(), send(), throw()</li></ul><h1>비동기 처리</h1><ol><li>전통적 방식 : 콜백</li><p>setTimeout(), setInterval(), clearInterval()<br>Error-first Callback : 콜백 첫번째 매개변수를 err로 사용하는 것<br>Callback Hell : 연속적으로 콜백이 다른 콜백을 호출하여 관리하기 어려워지는 상황</p><li>Promise</li><p>실행의 종료를 보장. 실행 상태(성공, 실패)에 따라 다른 콜백을 적절히 호출. 적절한 예외 처리도 지원 가능<br>Promise의 생성은 resolve, reject 콜백을 매개변수로 받는 함수를 작성하기만 하면 된다<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" type="button" title="/Repositories/JavaScript/Basic/promise.js" lan="javascript">promise.js »</button><br>Promise.all(), Promise.race(), ...</p><li>async, await</li><p>함수 정의 앞에 async 키워드를 사용하면 함수 내에서 await를 사용할 수 있다. 이때, 함수는 Promise가 결정될 때까지 일시 중지<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" type="button" title="/Repositories/JavaScript/Basic/async.js" lan="javascript">async.js »</button></p></ol><h1>정규표현식</h1><ul><li>정규표현식(RegExp) 리터럴 /X/</li><p>/123/gm과 new RegExp('123', 'gm')는 의미적으로 동일하다</p><li>Flag : g(global), i(ignoreCase), m(multiline), s(.이 newline도 매칭 Since ES2018)</li><p>global 플래그를 이용하는 경우, RegExp.lastIndex로 검색 위치를 기록하며, 해당 위치부터 재탐색한다따라서 global RegExp에 동일 문자열을 반복적으로 test()하는 경우 true, false가 토글되는 현상을 경험할 수도 있다</p><p>↓ 자바와 동일한 부분은 생략했음</p><li>Greedy 수량사</li><p>?, *, +, {n}, {n, }, {n, m}</p><li>replace()에서의 backreference</li><ul><li>$& 일치 문자열</li><p><strong>↓ javascript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="javascript">'1 12 123 1234'.replace(/1/gm, '[$&]') // "[1] [1]2 [1]23 [1]234"</div><li>$` 앞부분</li><p><strong>↓ javascript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="javascript">'1 12 123 1234'.replace(/1/gm, '[$`]') // "[] [1 ]2 [1 12 ]23 [1 12 123 ]234"</div><li>$' 뒷부분</li><p><strong>↓ javascript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="javascript">'1 12 123 1234'.replace(/1/gm, "[$']") // "[ 12 123 1234] [2 123 1234]2 [23 1234]23 [234]234"</div></ul><li>관련 메서드</li><ul><li>RegExp#test() : 패턴이 검색되는지 여부</li><li>RegExp#exec() : 매칭되는 인덱스들을 배열로 반환매칭 시작 index, 검색 텍스트 input 프로퍼티를 가진다. [i] 접근으로 캡처 그룹을 가져올 수 있다</li><p><strong>↓ javascript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="javascript">/1/gm.exec('1 12 123') // ["1", index: 0, input: "1 12 123", groups: undefined]</div><li>String#search(regexp) : 처음 매칭된 인덱스 반환</li><li>String#match(regexp) : 매칭되는 모든 부분문자열 반환</li><li>String#replace(regexp, replaceValue) : 매칭된 부분문자열을 replaceValue로 치환</li><li>String#split(regexp, limit) : 매칭된 문자열을 분리</li></ul></ul><h1>버전별 신규 기능</h1><div><h2>참고자료</h2><ul><li><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://ecma-international.org/publications-and-standards/standards/ecma-262/">ecma-262</a></li></ul><h2>ES2015, ES6</h2><div><h3>Tagged template literal</h3><div><p>Tag function을 이용하여 문자열 보간 작업을 사용자 정의할 수 있다<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" type="button" title="/Repositories/JavaScript/snippet/240314-162705.js" lan="javascript">예시 코드</button></p><p>문자열이 아닌 걸 반환해도 된다<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" type="button" title="/Repositories/JavaScript/snippet/240314-165131.js" lan="javascript">예시 코드</button></p><p>언어 자체에 내장된 tag function도 있다</p><p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">String.raw`C:\Development\profile\about.html`</div></div></div><h2>ES2016</h2><ul><li>지수 연산자 **</li><li>Array.prototype.includes() : 배열이 특정 원소를 포함하는지 여부 반환</li></ul><h2>ES2017</h2><ul><li>async function 정의, await 비동기 호출 지원</li><li>Object.values() : 객체의 순회 가능한 모든 값을 배열로 반환</li><li>Object.entries() : 객체의 순회 가능한 모든 [키, 값]쌍을 배열로 반환</li><li>Object.getOwnPropertyDescriptors() : 객체의 모든 프로퍼티 반환<p>예. Object.assign()이 순회 가능한 프로퍼티만 복사하는 반면, 아래 코드는 모든 프로퍼티를 얕게 복사한다</p><p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">Object.create(
    Object.getPrototypeOf(obj),
    Object.getOwnPropertyDescriptors(obj),
)</div></li><li>String.prototype.padStart(), padEnd() 추가</li></ul><div><h3>Shared Memory, Atomics</h3><ul><li>Atomics는 원자적 연산을 위한 함수들을, Shared Memory는 이를 위한 공유 메모리를 정의한다</li><li>원자적 연산은 Java의 volatile 변수처럼, CPU 코어 수준으로 병렬 실행을 동기화한다</li><li>공유 메모리 구현체는 SharedArrayBuffer인데, 브라우저에서는 기본적으로 비활성화되어 있으므로 사용하기 위해선 명시적인 설정이 필요하다</li></ul><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" type="button" title="/Repositories/Single/202506/09-1435.js" lan="JavaScript">예시 코드</button></div><h2>ES2018</h2><ul><li>Promise.prototype.finally() : Promise 상태가 무엇으로 천이되든 무관하게 실행되는 블록</li></ul><div><h3>비동기 반복자</h3><p>비동기 반복자는 Promise를 반환하는 반복자</p><p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">const asyncIterator = (async function* () {
  yield 1;
  yield 2;
  yield 3;
})();
(async () => {
  for await (const value of asyncIterator) {
    console.log(value);
  }
})();
</div><h3>객체 해체 할당 + 나머지 속성</h3><p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">const obj = {
    x: [1, 2, 3],
    y: { a: 4, b: 5, c: 6 },
    z: [7, 8, 9]
}
const {
    x: [x1, ...xRest],
    y: { a: y1, ...yRest },
    ...objRest
} = obj
console.info(x1)        // 1
console.info(xRest)     // [2, 3]
console.info(y1)        // 4
console.info(yRest)     // {b: 5, c: 6}
console.info(objRest)   // {"z": [7, 8, 9]}
</div><h3>정규표현식 기능 추가</h3><ul><li>RegExp.prototype.dotAll<p>s 플래그를 이용해 생성한 정규표현식은 이 속성이 true로 설정된다. 특수 문자 .이 line terminator에도 매칭된다 (U+000A, U+000D, U+2028, U+2029)</p><p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">/.+/.exec('abc\ndef')[0]    // 'abc'
/.+/s.exec('abc\ndef')[0]   // 'abc\ndef'</div></li><li>Named capture groups<p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">/^(?&lt;id&gt;[a-zA-Z0-9._%+-]+)@(?&lt;domain&gt;[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})$/.exec('test-id@example.com').groups
    // {id: 'test-id', domain: 'example.com'}</div></li><li>RegExp.prototype.unicode<ul><li>u 플래그를 이용해 생성한 정규표현식은 이 속성이 true로 설정된다</li><li>\u{1234}, \p{UnicodePropertyValue}를 이용해 유니코드 문자를 매칭할 수 있다</li><li>Surrogate pair를 한 문자로 취급한다<p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">/[😄]/.test(String.fromCodePoint('😄'.codePointAt(0)))  // true
/[😄]/.test(String.fromCodePoint('😄'.codePointAt(1)))  // true
/[😄]/u.test(String.fromCodePoint('😄'.codePointAt(0))) // true
/[😄]/u.test(String.fromCodePoint('😄'.codePointAt(1))) // false</div></li></ul></li><li>Look-behind assertions<ul><li>(?&lt;=y)x : positive lookbehind</li><li>(?&lt;!y)x : negative lookbehind</li></ul></li></ul></div><h2>ES2019</h2><ul><li>Array.prototype.flat() : 배열 차원 평탄화</li><li>Array.prototype.flatMap() : map()과 flat()을 순서대로 적용한 것과 같은 결과</li><li>Object.fromEntries() : Iterable&lt;[key, value]&gt;로부터 객체 생성 -- Array, Map, 또는 사용자 정의 iterable</li><li>String.prototype.trimStart(), trimEnd() 추가</li><li>배열 정렬 메서드 -- sort()는 이제 stable (정렬 키가 동일한 두 요소의 순서는 정렬 후에도 유지)</li><li>JSON.stringify()는 입력과 무관하게 well-formed UTF-8 문자열을 반환</li><li>필요 없다면 catch 블록 파라미터 생략 가능</li><li>Symbol.prototype.description getter 추가</li><li>Function.prototype.toString() : 함수가 ECMAScript로 정의된 경우, 함수 본문 반환</li></ul><h2>ES2020</h2><ul><li>import() : import .. from ... 구문과 다르게, 런타임에 동적으로 모듈 로드</li><li>import.meta : ES 모듈을 이용하는 경우, <span class="as-code code-span" lan="javascript">import.meta.url</span>를 이용해 모듈 URL 획득 가능</li><li>export * as newName from 'module' : 모듈의 defaults를 다시 노출하기만 할 때 편의 제공</li><li>BigInt : <span class="as-code code-span" lan="javascript">Number.MAX_SAFE_INTEGER</span>보다 큰 정수도 정확히 보존하는 정수 자료형</li><li>String.prototype.matchAll() : g 플래그를 켠 정규표현식의 모든 매치 결과를 순회할 수 있는 iterator 반환 -- 기존엔 전문검색을 위해 루프를 실행해야 했다</li><li>globalThis : 실행 환경(브라우저, Node, Deno, ...)과 무관하게 전역 컨텍스트를 통한 변수 접근 방법 제공</li></ul><div><h3>Optional chaining (?.)</h3><ul><li>?. 연산자를 이용하여 객체의 속성을 접근하거나 메서드를 호출할 수 있다</li><li>이 연산자로 접근하려는 객체나 호출하려는 함수가 undefined나 null인 경우, 연산은 단락되고 undefined를 반환한다</li></ul><h3>Nullish coalescing operator (??)</h3><p>연산자 좌변이 null 또는 undefined인 경우, 연산자 우변을 반환한다</p><h3>Promise.allSettled()</h3><p>Promise.all()은 일부가 실패한 경우 아래 2가지가 불가능했는데, allSettled()는 모두 가능하다<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" type="button" title="/Repositories/JavaScript/snippet/240314-190540.js" lan="javascript">예시 코드</button></p><ul><li>성공한 Promise의 반환값 획득</li><li>2번째 이후로 실패한 Promise의 에러 획득</li></ul></div><h2>ES2021</h2><ul><li>String.prototype.replaceAll() : 정규표현식 모든 매칭에 대해 치환</li><li>Promise.any() : 여러 Promise 중 하나라도 완료되면 반환</li><li>AggregateError : 여러 에러를 한 번에 표현</li><li>??=, &amp;&amp;=, ||= 논리 연산자 추가</li><li>WeakRef : 약한 참조 생성 ~ GC 수집 후 커스텀 finalizer 실행<p>FinalizationRegistry : 지정한 객체가 GC로 정리된 경우 호출. <a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry#notes_on_cleanup_callbacks">단, 이에 의존하면 안 됨</a></p></li><li>1_000처럼 리터럴 자리 구분 가능</li></ul><h2>ES2022</h2><ul><li>에러 원인을 cause 프로퍼티에 설정 가능</li><li>Array.prototype.at(), String.prototype.at() : 음수 인덱스도 지원하는 원소 접근 메서드</li><li>Object.hasOwn(obj, propKey) : Object.prototype.hasOwnProperty()의 안전한 버전</li></ul><div><h3>모듈 최상위 레벨 await 가능</h3><p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">import ...

await loadSecrets()
await readyDB()
</div><h3>클래스 정의 관련</h3><ul><li>static 프로퍼티, 메서드, 초기화 블록 정의 가능</li><li>constructor() 바깥의 클래스 body에서 프로퍼티 정의 가능</li><li>프로퍼티 또는 accessor 식별자를 #으로 시작하면 private</li></ul><h3>정규표현식 d 플래그 추가</h3><p>패턴 전체 및 각 캡처링 그룹에 대한 시작/끝 위치를 indices 속성에 제공</p><p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">/(aa)(bb)/d.exec('aaabbbccc').indices
/*
[
    [1, 5],
    [1, 3],
    [3, 5]
]
*/
</div></div><h2>WHATWG 2022</h2><div><h3><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/structuredClone">structuredClone(value[, options])</a></h3><p>객체 깊은 복사 지원</p></div><h2>ES2023</h2><ul><li>배열에 findLast(), findLastIndex() 추가</li><li>스크립트 첫 줄에 #!(Hashbang; Shebang) 지원</li><li>WeakMap 키로 non-registered symbol 사용 가능 -- Symbol.for()로 생성한 건 불가능</li></ul><div><h3>원본 수정 없이 사본을 반환하는 배열 메서드</h3><ul><li>with(index, value) : 지정한 index 원소로 value를 갖는 사본 반환</li><li>toSorted(compareFn?) : 정렬된 사본 반환</li><li>toReversed() : 원소가 역순인 사본 반환</li><li>toSpliced(...) : splice(...)를 수행한 사본 반환</li></ul></div><h2>ES2024</h2><ul><li>Object.groupBy(), Map.groupBy()를 이용한 집계 결과 생성</li><li>String.prototype.isWellFormed, toWellFormed 추가</li></ul><div><h3>Promise.withResolvers()</h3><p>Promise 객체의 상태 천이를 Promise 정의 바깥에서 하고 싶을 때</p><p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">let resolver, rejector
const promise = new Promise((resolve, reject) => {
    resolver = resolve
    rejector = reject
})</div><p>위와 같은 코드를 아래와 같이 축약할 수 있다</p><p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">const { promise, resolve, reject } = Promise.withResolvers()</div><h3>RegExp.prototype.unicodeSets</h3><ul><li>v 플래그를 이용해 생성한 정규표현식은 이 속성이 true로 설정된다</li><li>v 플래그는 유니코드 관련 기능을 활성화하는 u 플래그의 업그레이드 버전인데, 구문 해석 방식이 다르기 때문에 두 플래그를 모두 설정하면 SyntaxError가 발생한다</li><li>u 플래그에 비해 character class [...], [^...] 에 다음의 기능들이 추가된다<ul><li>추가적인 집합 연산 사용 가능<ul><li>[operand1&amp;&amp;operand2] : 교집합</li><li>[operand1--operand2] : 차집합</li><li>연산자를 한 번에 2개 이상 적용하는 것은 불가능하지만, nested 표기를 이용하면 쉽게 달성할 수 있다<p>한편, 단순 나열은 합집합 연산을 의미하므로 [AB--C]도 유효하지 않으며, [A[B--C]]와 같이 사용해야 한다</p></li></ul></li><li>[\q{substring}]으로 유니코드 리터럴 지정 가능. 내부에선 | 연산자만 이용 가능</li><li>\p 이스케이프로 RGI_Emoji와 같은 더 다양한 유니코드 클래스 집합 지정 가능</li></ul></li><li>i 플래그에서 \P{property} 평가가 달라진다<ul><li><span class="as-code code-span" lan="JavaScript">/P{Lowercase_Letter}/iu.test('a') === true</span><p>u 모드에서는 case-folding이 여집합 구성 후에 발생한다</p><ol><li>Lowercase_Letter에 대한 여집합이 생성된다 : uppercase + caseless</li><li>i 플래그를 위해 집합의 소문자 버전이 생성된다 : lowercase + caseless</li><li>입력 문자열은 패턴 매칭 전에 소문자 버전으로 변환된다</li><li>'a'는 패턴을 만족하므로 true 반환</li></ol></li><li><span class="as-code code-span" lan="JavaScript">/P{Lowercase_Letter}/iv.test('a') === false</span><p>v 모드에서는 case-folding이 여집합 구성 전에 발생한다</p><ol><li>Lowercase_Letter에 대한 소문자 버전 집합이 생성된다 : lowercase</li><li>대문자를 포함하지 않는 여집합이 생성된다 : caseless</li><li>입력 문자열은 패턴 매칭 전에 소문자 버전으로 변환된다</li><li>'a'는 패턴을 만족하지 않으므로 false 반환</li></ol></li></ul></li><li>i 플래그에서 character class complement syntax [^...] 에 대한 해석이 달라진다<ul><li><span class="as-code code-span" lan="JavaScript">/[^P{Lowercase_Letter}]/iu.test('A') === false</span><p>u 모드에서는 패턴을 반대로 평가한다</p><ol><li>Lowercase_Letter에 대한 여집합이 생성된다 : uppercase + caseless</li><li>i 플래그를 위해 집합의 소문자 버전이 생성된다 : lowercase + caseless</li><li>입력 문자열은 패턴 매칭 전에 소문자 버전으로 변환된다</li><li>'a'는 패턴을 만족하므로 false -- [^...]는 패턴을 매치 결과를 뒤집는다</li></ol></li><li><span class="as-code code-span" lan="JavaScript">/[^P{Lowercase_Letter}]/iv.test('A') === true</span><p>v 모드에서는 패턴을 반대로 평가하는 대신 여집합을 구성한다</p><ol><li>Lowercase_Letter에 대한 소문자 버전 집합이 생성된다 : lowercase</li><li>대문자를 포함하지 않는 여집합이 생성된다 : caseless</li><li>대문자를 포함하지 않는 여집합이 생성된다 : lowercase -- \P와 [^...]는 서로 상쇄된다</li><li>입력 문자열은 패턴 매칭 전에 소문자 버전으로 변환된다</li><li>'a'는 패턴을 만족하므로 true</li></ol></li></ul></li><li>v 모드가 grapheme cluster를 한 문자로 취급하지는 않는다. 여전히 코드 포인트의 모음으로 취급한다<p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">/😵‍💫/.test('😵‍💫')     // true
/😵‍💫/v.test('😵‍💫')    // true

/[😄-😛]/.test("😑")    // SyntaxError: Invalid regular expression: /[😄-😛]/: Range out of order in character class
/[😄-😛]/v.test("😑")   // true

/[😵‍💫]/.test('😵‍💫'.charAt(3))                             // true
/[😵‍💫]/v.test('😵‍💫'.charAt(3))                            // false
/[😵‍💫]/v.test(String.fromCodePoint('😵‍💫'.codePointAt(3))) // true
</div></li></ul><h3>가변 길이 ArrayBuffer 지원</h3><ul><li>처음부터 변경 가능하도록 생성<p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">buf = new ArrayBuffer(4, { maxByteLength: 8 })
console.log(buf.byteLength) // 4

buf.resize(8)
console.log(buf.byteLength) // 8</div></li><li>사용 도중 1회적으로 변경<p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">buf = new ArrayBuffer(4)
console.log(buf.byteLength)     // 4

newBuf = buf.transfer(8)
console.log(buf.detached)       // true
console.log(newBuf.byteLength)  // 8
</div></li></ul></div><h2>ES2025</h2><div><h3><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import/with">import 속성 지정</a></h3><p>예를 들어, 클라이언트는 아래와 같이 JSON을 기대했지만</p><p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">import config from 'https://xxx/config.json'</div><p>서버가 JSON이 아닌 실행 가능한 JavaScript 코드를 응답하면 의도치 않게 해당 코드가 실행되는 문제가 있었다. 이제는 속성을 지정하여 이러한 경우 명시적으로 오류를 발생할 수 있다</p><p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">import styles from "https://example.com/styles.css" with { type: "css" };
import data from "https://example.com/data.json" with { type: "json" };
</div><h3><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Iterator#iterator_helper_methods">Iterator#iterator_helper_methods</a></h3><p>Iterator helper method는 기존 iterator를 이용하는 새로운 iterator helper object를 반환한다. 두 iterator의 진행도는 동기화되며, 독립적으로 진행되지 않는다</p><ul><li>drop(limit) : 최초 limit개의 요소 순회 생략</li><li>every(callbackFn) : 모든 요소가 조건을 만족하면 true</li><li>filter(callbackFn) : 조건에 맞는 요소만 순회</li><li>find(callbackFn) : 조건에 맞는 첫 번째 요소를 반환</li><li>flatMap(callbackFn) : iterator 또는 iterable을 반환하여 차원 평탄화</li><li>forEach(callbackFn) : 모든 요소 소비</li><li>map(callbackFn) : 요소를 변환하여 순회</li><li>reduce(callbackFn[, initialValue]) : 모든 요소를 소비하여 결과값 축약</li><li>some(callbackFn) : 일부 요소가 조건을 만족하면 true</li><li>take(limit) : 최초 limit개의 요소만 순회</li></ul><h3>Iterator 유틸리티 추가</h3><ul><li>Iterator.prototype.toArray() : 하는 일은 Array.from(iterator), [...iterator]와 동일</li><li>Iterator.from(object)<ul><li>object가 iterable인 경우 : 해당 객체의 [Symbol.iterator]()를 순회에 이용하는 새로운 iterator 반환</li><li>object가 iterator인 경우 : 해당 객체 그대로 반환</li><li>그 외의 경우 : 해당 객체(iterator로 간주)를 감싼 새 Iterator 객체 반환 -- 사용시 런타임 에러 발생 가능</li></ul></li><li>new Iterator() : Iterator를 상속하여 순회 알고리즘 직접 구현 가능. Generator를 이용하는 구현과 다르게, Iterator의 모든 헬퍼 메서드 이용 가능</li></ul><h3>집합 연산 추가</h3><ul><li>difference(other) : 차집합 반환</li><li>intersection(other) : 교집합 반환</li><li>isDisjointFrom(other) : 교집합이 0인지 검사</li><li>isSubsetOf(other) : 부분집합인지 검사</li><li>isSupersetOf(other) : other를 모두 포함하는지 검사</li><li>symmetricDifference(other) : 대칭차집합 반환</li><li>union(other) : 합집합 반환</li></ul><h3>정규식 업데이트</h3><ul><li>RegExp.escape()<p>RegExp 생성자에 그대로 사용할 수 있는 문자열 반환</p><p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">txt = `abc!@#$%^&*(){}[]'";`
new RegExp(RegExp.escape(txt)).test(txt)    // true
</div></li><li>Flag modifier<p>정규식 특정 파트에 대해서만 추가로 플래그를 켜거나 끄는 게 가능</p><ul><li>(?flags1:pattern) : flags1에 지정한 플래그들을 추가로 적용</li><li>(?flags1-flags2:pattern) : flags1에 지정한 플래그들을 추가로 적용 + flags2에 지정한 플래그들은 적용하지 않음</li></ul></li><li>중복 명명된 캡처링 그룹 허용<p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">txt = 'aabbbcccc'
regex = /(?&lt;chars>a+)|(?&lt;chars>b+)/g
console.log(regex.exec(txt), regex.exec(txt))</div><figure class="w3-margin-bottom"><picture><source srcset="/imgs-generated/202507/Screenshot 2025-07-23 at 6.19.03 PM-500.avif 500w, /imgs-generated/202507/Screenshot 2025-07-23 at 6.19.03 PM-1200.avif 1200w, /imgs-generated/202507/Screenshot 2025-07-23 at 6.19.03 PM-2000.avif 2000w" type="image/avif"/><source srcset="/imgs-generated/202507/Screenshot 2025-07-23 at 6.19.03 PM-500.webp 500w, /imgs-generated/202507/Screenshot 2025-07-23 at 6.19.03 PM-1200.webp 1200w, /imgs-generated/202507/Screenshot 2025-07-23 at 6.19.03 PM-2000.webp 2000w" type="image/webp"/><source srcset="/imgs-generated/202507/Screenshot 2025-07-23 at 6.19.03 PM-500.jpeg 500w, /imgs-generated/202507/Screenshot 2025-07-23 at 6.19.03 PM-1200.jpeg 1200w, /imgs-generated/202507/Screenshot 2025-07-23 at 6.19.03 PM-2000.jpeg 2000w" type="image/jpeg"/><img class="w3-round" src="/imgs-generated/202507/Screenshot 2025-07-23 at 6.19.03 PM-2000.jpeg" alt="Screenshot 2025-07-23 at 6.19.03 PM.png" loading="lazy" sizes="auto" width="2066" height="298"/></picture><figcaption class="w3-padding">&lt;Screenshot 2025-07-23 at 6.19.03 PM.png&gt;<a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="/imgs/202507/Screenshot 2025-07-23 at 6.19.03 PM.png" target="_blank">[원본 보기]</a></figcaption></figure></li></ul><h3>Promise.try()</h3><p>가능한 모든 형태의 함수 호출을 Promise로 변환</p><p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">Promise.try(func)
Promise.try(func, arg1)
Promise.try(func, arg1, arg2)
Promise.try(func, arg1, arg2, /* …, */ argN)
</div><h3>Float16 지원</h3><p>16비트 float 사용으로 오히려 연산 성능 저하를 경험할 수 있다. 16비트 연산에 최적화된 플랫폼에서 사용하는 것이 권장된다</p><ul><li>Math.f16round()</li><li>Float16Array</li><li>DataView.prototype.getFloat16(), setFloat16()</li></ul></div></div></article></main></body></html>