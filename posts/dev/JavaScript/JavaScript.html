<!DOCTYPE html><html lang="ko-KR"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes"><title>JavaScript</title><link rel="stylesheet" href="/source/default.css"><meta name="google-site-verification" content="aH-DyzdytYQ0NPHNQFcs5dVoiu5YNs6CEEHYgqDmAFM"><meta name="author" content="Donggi Kim &lt;hi.donggi@gmail.com&gt;"><meta name="description" content="JavaScript(ECMAScript) 정리"><link rel="icon" href="/imgs/favicon.png"><script id="highlight-js" src="/source/highlight.pack.js" async></script><script id="default-js" src="/source/default.min.js" defer></script><script id="google-analytics" src="https://www.googletagmanager.com/gtag/js?id=UA-143098403-1" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-143098403-1');
</script></head><body><aside class="w3-animate-left" id="sidebar"><hr><div id="marker-list"></div><hr><div id="post-list"></div><hr><details class="w3-small"><summary>LICENSE</summary><table class="w3-table-all w3-card w3-small"><tr><td>Author</td><td>License</td></tr><tr><td>&copy; <a href="mailto:hi.donggi@gmail.com">Donggi Kim</a></td><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/Dong-gi/Dong-gi.github.io/blob/master/LICENSE">MIT</a></td></tr><tr><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://www.w3schools.com/w3css">w3css</a></td><td>No license</td></tr><tr><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://highlightjs.org/">highlight.js</a></td><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/highlightjs/highlight.js/blob/main/LICENSE">BSD-3-Clause</a></td></tr><tr><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/mathjax/MathJax">MathJax</a></td><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/mathjax/MathJax/blob/master/LICENSE">Apache-2.0</a></td></tr><tr><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/davidshimjs/qrcodejs">QRCode.js</a></td><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/davidshimjs/qrcodejs/blob/master/LICENSE">MIT</a></td></tr><tr><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/terrastruct/d2">D2</a></td><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/terrastruct/d2/blob/master/LICENSE.txt">MPL-2.0</a></td></tr></table></details><hr></aside><main id="main"><nav class="w3-bar w3-blue" id="nav"><button class="w3-bar-item w3-button w3-hover-theme" id="nav-toggle-btn" type="button" aria-label="Toggle navigation menu" title="Toggle navigation menu">&#9776;</button><form role="search"><input class="w3-bar-item" id="query" type="search" placeholder="search" style="max-width:35%"></form><a class="w3-bar-item w3-button w3-hover-theme" href="/">Home</a></nav><article id="contents"><h1>자료</h1><ul><li><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript">MDN &gt; JavaScript 배우기</a></li><li><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://web.dev/learn/javascript">web.dev &gt; JavaScript 배우기</a></li><li><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://exploringjs.com/">Exploring JavaScript</a></li></ul><h1>JavaScript 역사</h1><div><h2>참고자료</h2><ul><li><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://dzone.com/articles/a-brief-history-of-javascript">a-brief-history-of-javascript</a></li><li><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://en.wikipedia.org/wiki/JavaScript">JavaScript</a></li></ul><h2>현재</h2><p>JavaScript는 ECMAScript 표준을 준수하는 고급 프로그래밍 언어로, JIT 컴파일로 실행되는 스크립트 언어</p><h2>넷스케이프의 창조</h2><ul><li>1995년. 동적 웹 콘텐츠 개발을 위해 DOM과 상호작용할 수 있는 프로그래밍 언어를 추가하기 위한 결정이 이루어졌다</li><li>넷스케이프의 "브라우저를 위한 Scheme" 개발 프로젝트에 JavaScript의 아버지 Brendan Eich도 있었다</li><p>Scheme은 Lisp의 방언 중 하나</p><ul><li>당시 이미 넷스케이프와 썬 마이크로시스템즈는 브라우저에서 Java를 사용(자바 애플릿)할 수 있도록 계약을 체결하려는 시점이었다</li><li>따라서 새로운 언어(개발명 Mocha)를 추가하는 목적은 프로그램 개발이 아니라, HTML 안에서 동적으로 애니메이션 추가, 디자인 변경 등을 수행하는 것(작은 스크립팅 작업)이었으며, 전문 개발자가 아닌 HTML을 작성할 줄 아는 디자이너와 같은 사람들이 타깃 유저층이었다</li><li>즉, Mocha는 Java의 스크립팅 동반자가 되어야 했다. 이를 위해 Java와 유사한 구문들이 채택되었고, Scheme으로부터 멀어진 모습을 갖게 되었다</li></ul><li>1995년 9월 베타 출시하면서 LiveScript로 이름 변경</li><li>1995년 12월 정식 출시하면서 JavaScript로 이름 변경 (썬 마이크로시스템즈와 합의)</li></ul><h2>마이크로소프트의 채택</h2><ul><li>1995년 인터넷 익스플로러(IE)를 출시한 뒤 넷스케이프와 브라우저 전쟁을 벌였다</li><li>1996년 8월 넷스케이프의 스크립트 인터프리터를 리버스 엔지니어링하여 자체 인터프리터 JScript를 출시</li><p>상표권 문제가 될 수 있기 때문에 "Java"를 그대로 사용하지 않았다</p><li>두 브라우저의 스크립트 엔진 구현이 달랐기 때문에, 같은 코드가 서로 다르게 보이는 일이 잦았다</li><p>불행히도 IE가 독점적인 위치를 차지하는 동안, 개발자는 IE를 위한 특별한 처리를 해줘야 했다</p></ul><h2>표준화 시도</h2><ul><li>1996년 11월 넷스케이프는 브라우저 공급업체가 준수할 수 있는 표준 사양의 출발점으로 JavaScript를 ECMA International에 제출</li><li>1997년 6월 첫 번째 ECMAScript 발표</li><p>마찬가지로 상표권 문제가 있으므로 "Java"를 그대로 사용하지 않음. 이제 JavaScript는 상업적 이름일 뿐</p><li>1998년 6월 ECMAScript 2 발표</li><p>ECMAScript와 JavaScript용 ISO 표준(ISO/IEC 16262) 사이의 불일치를 수정</p><li>1999년 12월 ECMAScript 3 발표</li><p>정규식, try/catch 블록, in 및 instanceof 연산자 등 추가</p></ul><h2>ECMAScript 3.1과 4</h2><div><p>ECMAScript 4에 대한 작업은 버전 3이 출시되자마자 시작되었는데, 위원회에 강한 의견 차이가 대두되었다</p><ul><li>JavaScript가 대규모 애플리케이션을 개발할 수 있는 강력한 언어가 되기 위해 새로운 기능이 필요하다</li><p>vs</p><li>그러한 변경 사항은 JavaScript에 적합하지 않다</li></ul><p>버전 4에 대한 작업은 2003년 잠시 중단되었다가, 2005년 AJAX와 XMLHttpRequest의 영향으로 새 버전에 대한 관심이 높아지면서 작업이 재개되었다. 개발이 절정에 달했을 때 버전 4에는 다음과 같은 기능들이 포함되었다</p><ul><li>클래스, 인터페이스, 구조체, 사용자 정의 타입, 파라미터화된 타입</li><li>패키지, 네임스페이스</li><li>반복자, 생성자</li><li>선택적 타입 주석, 선택적 정적 타입 체크</li><li>...</li></ul><p>버전 4를 개발하는 위원회는 Adobe, Mozilla, Opera(비공식 자격), Microsoft로 구성되었는데, 대부분의 표준이 결정된 상태에서 Yahoo가 참여했다. 영향력 있는 JavaScript 개발자 Doug Crockford이 Yahoo에서 보낸 사람이었는데, 그는 버전 4의 많은 변경 사항에 대해 강력히 반대 의사를 표명했고 Microsoft로부터 강력한 지지를 받았다. 결국 버전 4 개발은 지지부진해졌고, Crockford는 모두가 동의할 수 있는 -- 구문 변경 없는 실용적인 개선사항만 담은 새로운 표준을 추진했고, 이것이 ECMAScript 3.1이다</p><p>2008년 오슬로에서 열린 회의에서 ECMAScript 3.1과 4의 미래가 결정되었다</p><ul><li>모든 구성원의 협력으로 ES3.1 완성에 집중</li><li>이후 ES4보다는 완화된 의미론적 및 구문론적 혁신에 대해 협력</li><li>패키지, 네임스페이스 등 웹에 적합하지 않은 제안은 제외</li></ul><h3>ActionScript</h3><ul><li>ActionScript는 ECMAScript 4 초안을 기반으로 하는 언어로, Adobe는 이를 Flash 제품군의 일부로 구현해 출시했다</li><li>때문에 Adobe는 ECMAScript 4를 강력히 지지했고, 채택을 위해 엔진을 오픈 소스(Tamarin)로 출시하기도 했다</li></ul></div><h2>ECMAScript 5</h2><ul><li>ECMAScript 4는 이미 8년의 개발을 거쳐 특정 변형으로 인식되었으므로, 혼동을 피하기 위해 ECMAScript 3.1의 이름은 ECMAScript 5로 변경되었다</li><li>2009년 출시된 ES5는 가장 많이 지원되는 JavaScript 버전 중 하나가 되었고, 많은 트랜스파일러의 기본 컴파일 대상이 되었다</li><p>Firefox 4 (2011), Chrome 19 (2012), Safari 6 (2012), Opera 12.10 (2012) 및 Internet Explorer 10 (2012)에서 전적으로 지원</p><li>수정사항</li><ul><li>Getter/setter</li><li>배열 및 객체 리터럴에서 후행 쉼표</li><li>예약어를 프로퍼티 이름으로 허용</li><li>신규 Object 메서드 : create, defineProperty, keys, seal, freeze, ...</li><li>신규 Array 메서드 : isArray, indexOf, every, some, map, filter, reduce, ...</li><li>신규 Date 메서드 : toISOString, now, toJSON</li><li>String.prototype.trim 추가</li><li>JSON</li><li>불변 전역 객체 : undefined, NaN, Infinity</li><li>Strict 모드</li><li>...</li></ul></ul><h2>ECMAScript 6 (2015) : 범용 언어</h2><ul><li>ECMAScript 4에서 폐기되지 않은 아이디어는 ECMAScript Harmony에서 새롭게 제안되었고, ECMAScript 2015로 이름이 바뀐 ECMAScript 6는 이러한 구문 변경이 필요한 업데이트를 담고 있다</li><p>이러한 구문 변경들은 브라우저 공급업체들이 모두 지원하기까지 상당한 시간이 소요됐고, 이로 인해 ECMAScript 2015 출시 이후 트랜스파일러의 사용이 크게 증가했다</p><li>ECMAScript 2015 수정사항</li><ul><li>let, const 변수 선언</li><li>화살표 함수와 this 키워드</li><li>클래스</li><li>객체 리터럴 개선 : 계산된 키 사용, 더 짧은 메서드 정의 등</li><li>템플릿 문자열</li><li>Promise</li><li>생성자, iterable, 반복자, for..of 구문</li><li>신규 컬렉션 : Set, Map, WeakSet, WeakMap</li><li>배열 해체 할당</li><li>...</li></ul></ul></div><h1>변수와 식별자</h1><ol><li>식별자<ul><li>'_', '$'를 식별자로 이용할 수 있다<p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">const _ = 123</div></li><li>다른 프로그래밍 언어들과 마찬가지로 예약어를 변수 식별자로 사용할 수 없다 -- 하지만 객체 속성으로는 사용할 수 있다<p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">const o = { if: 123, default: 456 }</div></li></ul></li><li>var 변수<ul><li>let, const가 도입되기 전까진 유일한 변수 선언 구문이었다. 현대 개발에선 const &gt; let 사용이 권장된다</li><li>var 변수는 선언된 함수 스코프 내에서 유효하다</li><li>호이스팅 : 선언한 위치 전에도 변수를 참조할 수 있다(값은 undefined)</li></ul></li><li>let 변수<ul><li>var 대신 일반적인 지역변수 키워드로 이용된다</li><li>var 변수와 달리 선언 이전에 참조할 수 없고, 변수는 선언된 블록 스코프 내에서 유효하다</li></ul></li><li>const 변수<ul><li>선언과 동시에 값을 초기화하고, 이후 다른 값으로 덮어쓸 수 없다. 따라서 상수라고 한다</li><li>let과 마찬가지로 선언된 블록 스코프 내에서 유효하다</li></ul></li></ol><h1>자료형(type)</h1><div><h2>원시 타입</h2><ul><li>원시 타입의 가장 큰 특징은 값의 불변성이다. 123, 'abc', true 등의 값 자체를 다른 것으로 변경할 수 없다.</li><li>변수로 원시 타입 내용을 전달할 때는 값 자체가 복사된다</li><li>JavaScript는 원시 타입도 객체와 동등한 1급 시민이다<ul><li>Object 타입 변수로 모든 객체를 참조할 수 있지만 원시 타입 값을 직접 저장할 수 없는 Java와 달리, JavaScript 변수는 (구별 없이) 모든 타입을 직접 지원한다</li><li>Wrapper 클래스로 변환해 메서드를 호출하는 Java와 다르게, 원시 타입 변수로부터 직접 전용 메서드 호출 가능</li></ul></li></ul><div><h3>undefined</h3><ul><li>변수에 값이 할당되지 않았음 또는 객체에 속성이 존재하지 않음을 의미한다</li><li>Java의 경우 변수는 그 타입에 따라 정해진 기본값을 갖는다 -- 객체는 null, 정수는 0, ...<p>JavaScript 변수는 정의할 때 타입을 지정하지 않으므로, 원시 타입도 객체도 아닌, 아무것도 할당되지 않은 상태를 표현하기 위해 undefined를 도입했다</p></li></ul><h3>null</h3><p>객체가 에상되는 변수/속성에 의도적으로 값이 할당되지 않았음을 의미한다</p><h3>Boolean</h3><ul><li>논리값 표현을 위한 타입으로, true/false 2가지가 있다</li><li>Boolean()를 이용해 모든 변수를 boolean 값으로 변환할 수 있다</li></ul><h3>Number</h3><ul><li>IEEE-754 부동소수(double) 표현을 위한 타입으로, bigint 도입 전에는 유일한 숫자 타입이었다</li><li>주요 JavaScript 엔진들은 최적화를 위해 작은 정수들을 내부적으로 별도 타입으로 취급한다</li><li>숫자 리터럴 표현 시 읽기 편하도록 중간에 '_'를 추가할 수 있다. 예. 1_234_00</li><li>숫자 리터럴로 과학적 표기법을 지원한다. 예. 1.5e11</li><li>정수 리터럴 표현에서는 다양한 진법을 지원한다<ul><li>0b101 : 2진법</li><li>0o77 : 8진법</li><li>0xff : 16진법</li></ul></li></ul><h3>Bigint</h3><ul><li>정밀도 제한 없이 정수를 표현한다</li><li>하나의 산술 연산자로 Bigint와 Number 모두를 처리할 순 없다<p>연산 결과로 Bigint, Number 중 어떤 게 반환돼야 하는지에 대한 설득력 있는 규칙이 없으므로, 개발자가 의도에 맞게 직접 형 변환을 해야한다</p></li></ul><h3>String</h3><ul><li>JavaScript는 단일 문자를 위한 전용 타입 없이 모두 UTF-16 포맷 문자열로 취급한다<ul><li>Code point : 각 유니코드 문자마다 주어진 ID (21비트)</li><li>Code unit : code point를 표현하기 위한 개별 UTF-16 값 (16비트)<ul><li>현재 유니코드는 2^16개 문자씩 구별된 총 17개 평면으로 구성</li><li>다국어 기본 평면(0번) 문자에 대해 UTF-16은 하나의 code unit만 사용</li><li>그 외 문자에 대해 UTF-16은 2개의 code unit을 사용 (high/low surrogate들이 각각 10비트씩 표현)</li></ul></li><li>Grapheme cluster : 여러 code point가 모여 하나의 활자를 표현하는 경우가 있다<p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">[...'😵‍💫'] // ['😵', '‍', '💫']</div></li></ul></li><li>문자 리터럴 : 'a', '\x61', '\u0061'</li><li>문자열 리터럴 : 'abc', "abc", `abc`(문자열 템플릿)</li><li>split(''), slice()는 code unit 단위로 동작,<br>[...str]은 -- <a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/Symbol.iterator">Symbol.iterator</a>를 이용하여 code point 단위로 동작<p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">'😵‍💫'.split('')  // ['\uD83D', '\uDE35', '‍', '\uD83D', '\uDCAB']
[...'😵‍💫']       // ['😵', '‍', '💫']
</div></li></ul><h3>Symbol</h3><ul><li>ES6부터 도입된 타입. 그 무엇과도 같지 않은 유일한 토큰을 나타낸다<p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">Symbol('xxx') !== Symbol('xxx')</div></li><li>단, Symbol.for()를 이용해 전역적으로 재사용할 수도 있다<p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">Symbol.for('xxx') === Symbol.for('xxx')</div></li></ul></div><h2>객체 타입</h2><ul><li>객체 타입은 값 자체를 변경할 수 있다. 자유롭게 속성을 추가/변경/삭제할 수 있다.</li><li>변수로 객체를 전달할 때는 참조가 복사된다</li></ul><div><h3>Object</h3><p>보통 객체 리터럴 표현 {} 을 이용해 생성한다</p><h3>Array</h3><ul><li>배열 리터럴 표현 [] 또는 Array 생성자를 이용해 생성한다</li><li>Java와 다르게 원소 타입을 강제하지 않고, 배열 길이도 가변적이다</li></ul><h3>Map</h3><p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">new Map(iterable: Iterable&lt;readonly [K, V]>)
new Map(entries?: readonly (readonly [K, V])[])
set(key, value), get(key), has(key)
delete(key), clear()
size, keys(), values(), entries()
</div><h3>WeakMap</h3><p>키는 반드시 객체여야 하며, 키는 GC 대상이 된다. 따라서 객체가 살아있는 동안에 참조해야 하는 고유값들을 저장하기에 좋다</p><h3>Set</h3><p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">new Set(iterable?: Iterable&lt;any>)
new Set(values?: readonly T[])
add(value), has(value), ...
</div><h3>WeakSet</h3><p>값은 반드시 객체여야 하며, GC 대상이 된다</p></div></div><h1>연산자</h1><ol><li>Boolean 연산자 : !, &amp;&amp;, ||</li><p>&amp;&amp;, ||는 short circuit 연산</p><li>비트 연산자 : ~, &amp;, |, ^, &lt;&lt;, >>, >>></li><li>,연산자 : 순서대로 평가하여 마지막 표현식의 결과가 할당됨<p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">const n = (1, 2, 3, 4, 5)
console.log(n === 5)</div></li><li>in 연산자 : 객체에 해당 프로퍼티가 존재하는지 여부 반환 -- 프로토타입 체인도 검사<p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">console.log('alert' in globalThis) // true
console.log('a' in { __proto__: { __proto__: { a: 1 } } }) // true</div><p>프로토타입으로 상속하지 않고 객체에 직접 정의된 프로퍼티를 검사하는 방법<ul><li>Object.keys() : enumerable 설정된 string 속성 키 목록 반환</li><li>Object.getOwnPropertyNames() : enumerable 설정과 무관하게 string 속성 키 목록 반환</li><li>Object.getOwnPropertySymbols() : enumerable 설정과 무관하게 symbol 속성 키 목록 반환</li><li>Reflect.ownKeys() : enumerable 설정과 무관하게 string + symbol 속성 키 목록 반환</li></ul></p></li><li>instanceof 연산자 : 객체 호환 여부 반환</li></ol><h1>제어 구문</h1><ol><li>if...[else if...][else...]</li><li>while, do...while</li><li>for(초기식; 조건식; 증감식)</li><li>switch : 분기 조건으로 변수가 아닌 일반 표현식도 가능</li><li>for(let attr in obj) {} : 객체 프로퍼티 순회</li><li>for(const name of iterable) {} : Iterable 객체 순회</li><li>with(obj) : 스코프 고정</li><li>try ~ [catch] ~ [finally] : catch, finally 중 적어도 하나는 있어야 한다</li><li>break with label : 임의 블록을 탈출할 수 있다<p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">someLabel: {
    let a = Math.random()
    if (a < 0.5) {
        break someLabel
    }
    console.log(a)
}
</div></li></ol><h1>함수</h1><ul><li>ES6 전에는 function 키워드로 정의하는 함수만 존재했지만, ES6부터는 기능별로 전용 구문이 추가되었으므로 이를 이용함이 권장된다</li><li>명시하지 않은 경우, 함수 반환값은 undefined</li><li>매개변수에 기본값 설정 가능 + 해체, 확산 연산자 사용 가능<p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">function avg(...numArr) {
    let sum = 0
    numArr.forEach(x => sum += x)
    return sum / numArr.length
}
console.log(avg(1, 2, 3, 4))

function xxxx({ a = 1, b = 2 } = {}) {
    console.log({a, b})
}
xxxx()</div></li><li>함수 컨텍스트(this) 지정<p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">function hello(today) {
    console.log(`Hello ${this.name}! Today is ${today}`)
}
hello.apply({name: "Donggi"}, ["2018-08-08"])   // apply(호출자, 매개변수 배열)
hello.call({name: "Donggi"}, "2018-08-08")      // call(호출자, 매개변수1, ...)
hello.bind({name: "Donggi"})("2018-08-08")      // 함수 호출자 및 매개변수 고정</div></li><li>코드 동적 실행<p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">const sum = new Function("a", "b", "return a + b")
console.log(sum(2, 6))
</div></li></ul><div><h2>일반 함수</h2><p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">// ES6 전
function add(x, y) {
    return x + y
}
// ES6
const add = (x, y) => x + y
</div><h2>메서드</h2><p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">// ES6 전
const o = {
    name: 'Bob',
    print: function() {
        console.log(`I'm ${this.name}`)
    }
}
// ES6
const o = {
    name: 'Bob',
    print() {
        console.log(`I'm ${this.name}`)
    }
}

o.print()
</div><h2>생성자</h2><p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">// ES6 전
function Animal(name) {
    this.name = name
}
// ES6
class Animal {
    constructor(name) {
        this.name = name
    }
}

const alice = new Animal('Alice')
console.log(alice instanceof Animal)    // true
</div></div><h1>모듈</h1><ul><li>ES6에서 실행 환경 -- 브라우저, 서버 -- 에 관계없이 사용 가능한 내장 모듈 사양이 도입되었으므로, 이를 사용하는 것이 권장된다</li><li>보통 모듈은 소스 코드 파일에 작성되고<ul><li>export를 통해 외부에서 이용할 모듈 내 구성 요소를 지정한다</li><li>import를 통해 외부에서 가져올 모듈 내 구성 요소를 지정한다</li><li>한 모듈이 여러 모듈에서 참조되더라도, 해당 모듈은 한 번만 평가된다 -- 싱글톤이다</li></ul></li><li>모듈 로드는 다음과 같이 2단계로 나뉘므로, 모듈 간 순환 의존성 있더라도 문제 없다<ol><li>모듈 간 의존성을 따라가면서 export ~ import 관계를 평가</li><li>로드된 모듈들의 body 실행</li></ol><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" type="button" title="/Repositories/Node/module-251113/a.js" lan="JavaScript">a.js</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" type="button" title="/Repositories/Node/module-251113/b.js" lan="JavaScript">b.js</button><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ node a.js
b.js body start
a() called
a.js body start
b() called

$ node b.js
a.js body start
b() called
b.js body start
a() called</div><p>단, 초기화되지 않은 요소를 참조하면 런타임 에러가 발생한다<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" type="button" title="/Repositories/Node/module-251113/a2.js" lan="JavaScript">a2.js</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" type="button" title="/Repositories/Node/module-251113/b2.js" lan="JavaScript">b2.js</button></p><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ node a2.js
b2.js body start
a2() called
a2.js body start
b2() called#0
b2() called#1

$ node b2.js
a2.js body start
file://xxx/b2.js:8
    console.log(`b2() called#${count++}`);
                ^

ReferenceError: Cannot access 'count' before initialization
    at b2 (file://xxx/b2.js:8:17)
    at file://xxx/a2.js:4:1
    at ModuleJob.run (node:internal/modules/esm/module_job:271:25)
    at async onImport.tracePromise.__proto__ (node:internal/modules/esm/loader:547:26)
    at async asyncRunEntryPointWithESMLoader (node:internal/modules/run_main:116:5)</div></li><li>import() 연산자를 통해 필요에 따라 동적으로 모듈을 가져올 수도 있다<p>연산자와 다르게 import()가 함수라면, 상대 경로를 이용하기 위해 호출자 모듈의 URL을 명시적으로 전달해야 한다</p></li></ul><h1>클래스</h1><ol><li>클래스는 본질적으로 함수다. 단순히 문법적 편의성이 더해졌을 뿐</li><li>한편, private slot의 도입으로 클래스는 함수 이상의 것이 되었다 -- 함수에서는 private slot 사용 불가능</li></ol><div><h2>Private slot</h2><ul><li>#으로 시작되는 멤버는 이를 정의한 클래스 내부에서, 오로지 . 연산자를 이용해서만 접근 가능하다</li><li>생성자 말고는 모두 private 설정 가능</li><li>선언과 동시에 초기화하거나, 초기화하기 전에 미리 선언해야 한다</li><li>문자열로 평가되는 public slot 이름과 다르게, private slot 이름은 symbol과 같은 유일성을 갖는다 -- 이 성질을 이용해 타입 검사를 할 수도 있다<p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">class Class1 {
  #field1 = 'Defined in Class1'
  static print(x) {
    return console.log(x.#field1)
  }
}

class Class2 extends Class1 {
  #field1 = 'Defined in Class2'
  static print(x) {
    return console.log(x.#field1)
  }
}

Class1.print(new Class1()) // Defined in Class1
Class1.print(new Class2()) // Defined in Class1

Class2.print(new Class1()) // TypeError: Cannot read private member #field1 from an object whose class did not declare it
Class2.print(new Class2()) // Defined in Class2
</div></li></ul><h2>객체 보호</h2><p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">Object.preventExtensions() // 객체 확장 방지. 새 프로퍼티를 추가하거나 프로토타입을 변경할 수 없음
Object.seal()              // 객체 봉인. 확장 방지 + 모든 프로퍼티의 configurable 값을 false로 설정
Object.freeze()            // 객체 동결. 봉인 + 모든 프로퍼티의 writable 값을 false로 설정</div><p><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" type="button" title="/Repositories/JavaScript/Basic/class.js" displayRange="[42,70]" lan="JavaScript">접근자 프로퍼티 + 객체 보호 예 »</button></p><h3>Mixin class</h3><p>extends 키워드의 operand가 표현식이라는 점을 이용하여, 다음과 같은 방법으로 다중 상속과 유사한 기능을 구현할 수 있다</p><p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">const CanDoX = (Sup) => class extends Sup { x() { console.log('x') } }
const CanDoY = (Sup) => class extends Sup { y() { console.log('y') } }
class C extends CanDoX(CanDoY(Object)) {}
</div></div><h1>프록시</h1><div><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler#Methods">참고자료</a><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" type="button" title="/Repositories/JavaScript/Basic/class.js" displayRange="[73,85]" lan="JavaScript">프록시 예 »</button></div><table class="w3-table-all w3-card w3-small"><tr><th>getPrototypeOf()</th><td>A trap for Object.getPrototypeOf</td></tr><tr><th>setPrototypeOf()</th><td>A trap for Object.setPrototypeOf</td></tr><tr><th>isExtensible()</th><td>A trap for Object.isExtensible</td></tr><tr><th>preventExtensions()</th><td>A trap for Object.preventExtensions</td></tr><tr><th>getOwnPropertyDescriptor()</th><td>A trap for Object.getOwnPropertyDescriptor</td></tr><tr><th>defineProperty()</th><td>A trap for Object.defineProperty</td></tr><tr><th>has()</th><td>A trap for the in operator</td></tr><tr><th>get()</th><td>A trap for getting property values</td></tr><tr><th>set()</th><td>A trap for setting property values</td></tr><tr><th>deleteProperty()</th><td>A trap for the delete operator</td></tr><tr><th>ownKeys()</th><td>A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols</td></tr><tr><th>apply()</th><td>A trap for a function call</td></tr><tr><th>construct()</th><td>A trap for the new operator</td></tr></table><h1>Sync Iteration</h1><p><strong>↓ TypeScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="TypeScript">interface Iterable&lt;T&gt; {
  [Symbol.iterator]() : Iterator&lt;T&gt;;
}

abstract class Iterator&lt;T&gt; {
  abstract next() : IteratorResult&lt;T&gt;;
}

interface IteratorResult&lt;T&gt; {
  value: T;
  done: boolean;
}</div><ul><li>Iteration 프로토콜 : 데이터 소비자가 데이터 소스의 원소들을 하나씩 소비하는 절차</li><li>Iterable : iteration 프로토콜을 구현한 객체<p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">const [a, b] = new Set([1, 2])
for (const [k, v] of new Map([['k1', 'v1'], ['k2', 'v2']])) {
    console.log(k, v)
}
console.log(...new Set([1, 2]))</div></li><li>Iterator : 순회에 이용되는 객체</li><li>Generator : 함수가 생성하는 값을 순회하는 iterator. 호출자와 양방향 통신이 가능하다는 특징이 있다<p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">function* numbers(from, to, diff) {
    for (let n = from; n <= to; n += diff) {
        try {
            if (Math.random() < 0.5) {
                yield n
            }
        } catch (e) {
            console.log(`Error?? ${e.message}`)
        }
    }
}
function* pickSomeNumbers() {
    const a = yield 'Enter number a : '
    const b = yield 'Enter number b : '
    yield* numbers(a, b, 1)
}
const g = pickSomeNumbers()
console.log(g.next())               // {value: 'Enter number a : ', done: false}
console.log(g.next(10))             // {value: 'Enter number b : ', done: false}
console.log(g.next(20))             // {value: 11, done: false}
g.throw(new Error('Test Error'))    // Error?? Test Error
console.log(g.next())               // {value: 13, done: false}
console.log(g.return(0))            // {value: 0, done: true}
console.log(g.return(1))            // {value: 1, done: true}
console.log(g.next())               // {value: undefined, done: true}
</div></li></ul><h1>바이너리 데이터 취급</h1><ul><li>ArrayBuffer : 바이너리 데이터 저장소. ES2024부터 크기 변경 가능</li><li>TypedArray : ArrayBuffer 조작을 위한 고수준 래퍼. UInt32Array, Float64Array 등 미리 정의된 클래스를 이용하며, 원소 크기는 클래스에 따라 고정된다</li><li>DataView : ArrayBuffer 조작을 위한 저수준 래퍼. 바이트 단위로 조작 가능하다</li></ul><h1>비동기 처리</h1><div><h2>전통적 방식 : 콜백</h2><p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">const callback = (error, result) => {
    // Error-first Callback : 콜백 첫번째 매개변수를 에러로 사용하는 것
    if (error != null) { }
}
someFunction(args, callback)

func1(args1, (err1, result1) => {
    func2(args2, (err2, result2) => {
        func3(args3, (err3, result3) => {
            // Callback Hell : 콜백이 다른 콜백을 호출하는 게 깊이 이어져 관리하기 어려워지는 상황
        })
    })
})
</div><h2>Promise</h2><div><p>비동기 실행 결과를 효율적으로 전달하기 위한 자료형. 실행 상태(성공, 실패)에 따라 다른 콜백을 적절히 호출. 적절한 예외 처리도 지원</p><p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">new Promise((resolve, reject) => {
    // ...
    if (success) {
        return resolve(result)
    }
    return reject(new Error('reason'))
})
// Promise 체인은 promise의 상태와 무관하게 언제든 추가 가능
.then(result => {})
.catch(error => {})
.finally(() => {})</div><h3>Promise의 상태</h3><ul><li>pending : 초기 상태<p>settled = not(pending) = fulfilled or rejected</p></li><li>fulfilled : 연산 성공</li><li>rejected : 연산 실패</li></ul><h3>Iterable&lt;Promise&gt;를 다루는 유틸리티</h3><table class="w3-table-all w3-card w3-small"><tr><th>반환된 Promise 객체의 &gt; </th><th>fulfill 조건</th><th>reject 조건</th></tr><tr><td>Promise.all()</td><td>모든 입력 promise가 fulfilled로 천이</td><td>입력 promise 중 하나라도 rejected로 천이</td></tr><tr><td>Promise.allSettled()</td><td>모든 입력 promise가 fulfilled 또는 rejected로 천이</td><td>-</td></tr><tr><td>Promise.any()</td><td>입력 promise 중 하나라도 fulfilled로 천이</td><td>모든 입력 promise가 rejected로 천이</td></tr><tr><td>Promise.race()</td><td>입력 promise 중 하나라도 fulfilled로 천이</td><td>입력 promise 중 하나라도 rejected로 천이</td></tr></table></div><h2>async, await</h2><p>함수 정의 앞에 async 키워드를 사용하면 함수 내에서 await를 사용할 수 있다. 이때, 함수는 Promise가 결정될 때까지 일시 중지<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" type="button" title="/Repositories/JavaScript/Basic/async.js" lan="JavaScript">async.js »</button></p></div><h1>정규표현식</h1><ul><li>정규표현식(RegExp) 리터럴 /X/</li><p>/123/gm과 new RegExp('123', 'gm')는 의미적으로 동일하다</p><li>Flag : g(global), i(ignoreCase), m(multiline), s(.이 newline도 매칭 Since ES2018)</li><p>global 플래그를 이용하는 경우, RegExp.lastIndex로 검색 위치를 기록하며, 해당 위치부터 재탐색한다따라서 global RegExp에 동일 문자열을 반복적으로 test()하는 경우 true, false가 토글되는 현상을 경험할 수도 있다</p><p>↓ 자바와 동일한 부분은 생략했음</p><li>Greedy 수량사</li><p>?, *, +, {n}, {n, }, {n, m}</p><li>replace()에서의 backreference</li><ul><li>$& 일치 문자열</li><p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">'1 12 123 1234'.replace(/1/gm, '[$&]') // "[1] [1]2 [1]23 [1]234"</div><li>$` 앞부분</li><p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">'1 12 123 1234'.replace(/1/gm, '[$`]') // "[] [1 ]2 [1 12 ]23 [1 12 123 ]234"</div><li>$' 뒷부분</li><p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">'1 12 123 1234'.replace(/1/gm, "[$']") // "[ 12 123 1234] [2 123 1234]2 [23 1234]23 [234]234"</div></ul><li>관련 메서드</li><ul><li>RegExp#test() : 패턴이 검색되는지 여부</li><li>RegExp#exec() : 매칭되는 인덱스들을 배열로 반환매칭 시작 index, 검색 텍스트 input 프로퍼티를 가진다. [i] 접근으로 캡처 그룹을 가져올 수 있다</li><p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">/1/gm.exec('1 12 123') // ["1", index: 0, input: "1 12 123", groups: undefined]</div><li>String#search(regexp) : 처음 매칭된 인덱스 반환</li><li>String#match(regexp) : 매칭되는 모든 부분문자열 반환</li><li>String#replace(regexp, replaceValue) : 매칭된 부분문자열을 replaceValue로 치환</li><li>String#split(regexp, limit) : 매칭된 문자열을 분리</li></ul></ul><h1>버전별 신규 기능</h1><div><h2>참고자료</h2><ul><li><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://ecma-international.org/publications-and-standards/standards/ecma-262/">ecma-262</a></li></ul><h2>ES2015, ES6</h2><div><h3>Tagged template literal</h3><div><p>Tag function을 이용하여 문자열 보간 작업을 사용자 정의할 수 있다<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" type="button" title="/Repositories/JavaScript/snippet/240314-162705.js" lan="JavaScript">예시 코드</button></p><p>문자열이 아닌 걸 반환해도 된다<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" type="button" title="/Repositories/JavaScript/snippet/240314-165131.js" lan="JavaScript">예시 코드</button></p><p>언어 자체에 내장된 tag function도 있다</p><p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">String.raw`C:\Development\profile\about.html`</div></div></div><h2>ES2016</h2><ul><li>지수 연산자 **</li><li>Array.prototype.includes() : 배열이 특정 원소를 포함하는지 여부 반환</li></ul><h2>ES2017</h2><ul><li>async function 정의, await 비동기 호출 지원</li><li>Object.values() : 객체의 순회 가능한 모든 값을 배열로 반환</li><li>Object.entries() : 객체의 순회 가능한 모든 [키, 값]쌍을 배열로 반환</li><li>Object.getOwnPropertyDescriptors() : 객체의 모든 프로퍼티 반환<p>예. Object.assign()이 순회 가능한 프로퍼티만 복사하는 반면, 아래 코드는 모든 프로퍼티를 얕게 복사한다</p><p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">Object.create(
    Object.getPrototypeOf(obj),
    Object.getOwnPropertyDescriptors(obj),
)</div></li><li>String.prototype.padStart(), padEnd() 추가</li></ul><div><h3>Shared Memory, Atomics</h3><ul><li>Atomics는 원자적 연산을 위한 함수들을, Shared Memory는 이를 위한 공유 메모리를 정의한다</li><li>원자적 연산은 Java의 volatile 변수처럼, CPU 코어 수준으로 병렬 실행을 동기화한다</li><li>공유 메모리 구현체는 SharedArrayBuffer인데, 브라우저에서는 기본적으로 비활성화되어 있으므로 사용하기 위해선 명시적인 설정이 필요하다</li></ul><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" type="button" title="/Repositories/Single/202506/09-1435.js" lan="JavaScript">예시 코드</button></div><h2>ES2018</h2><ul><li>Promise.prototype.finally() : Promise 상태가 무엇으로 천이되든 무관하게 실행되는 블록</li></ul><div><h3>비동기 반복자</h3><p>비동기 반복자는 Promise를 반환하는 반복자</p><p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">const asyncIterator = (async function* () {
  yield 1;
  yield 2;
  yield 3;
})();
(async () => {
  for await (const value of asyncIterator) {
    console.log(value);
  }
})();
</div><h3>객체 해체 할당 + 나머지 속성</h3><p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">const {
    x: [x1, ...xRest],
    y: { a: y1, ...yRest },
    ...objRest
} = {
    x: [1, 2, 3],
    y: { a: 4, b: 5, c: 6 },
    z: [7, 8, 9]
}
console.log(x1)         // 1
console.log(xRest)      // [2, 3]
console.log(y1)         // 4
console.log(yRest)      // {b: 5, c: 6}
console.log(objRest)    // {"z": [7, 8, 9]}

let r, g, b, a
({ r, g, b, a = 255 } = { r: 12, g: 34, b: 56 })
console.log(r, g, b, a) // 12, 34, 56, 255
</div><h3>정규표현식 기능 추가</h3><ul><li>RegExp.prototype.dotAll<p>s 플래그를 이용해 생성한 정규표현식은 이 속성이 true로 설정된다. 특수 문자 .이 line terminator에도 매칭된다 (U+000A, U+000D, U+2028, U+2029)</p><p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">/.+/.exec('abc\ndef')[0]    // 'abc'
/.+/s.exec('abc\ndef')[0]   // 'abc\ndef'</div></li><li>Named capture groups<p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">/^(?&lt;id&gt;[a-zA-Z0-9._%+-]+)@(?&lt;domain&gt;[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})$/.exec('test-id@example.com').groups
    // {id: 'test-id', domain: 'example.com'}</div></li><li>RegExp.prototype.unicode<ul><li>u 플래그를 이용해 생성한 정규표현식은 이 속성이 true로 설정된다</li><li>\u{1234}, \p{UnicodePropertyValue}를 이용해 유니코드 문자를 매칭할 수 있다</li><li>Surrogate pair를 한 문자로 취급한다<p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">/[😄]/.test(String.fromCodePoint('😄'.codePointAt(0)))  // true
/[😄]/.test(String.fromCodePoint('😄'.codePointAt(1)))  // true
/[😄]/u.test(String.fromCodePoint('😄'.codePointAt(0))) // true
/[😄]/u.test(String.fromCodePoint('😄'.codePointAt(1))) // false</div></li></ul></li><li>Look-behind assertions<ul><li>(?&lt;=y)x : positive lookbehind</li><li>(?&lt;!y)x : negative lookbehind</li></ul></li></ul></div><h2>ES2019</h2><ul><li>Array.prototype.flat() : 배열 차원 평탄화</li><li>Array.prototype.flatMap() : map()과 flat()을 순서대로 적용한 것과 같은 결과</li><li>Object.fromEntries() : Iterable&lt;[key, value]&gt;로부터 객체 생성 -- Array, Map, 또는 사용자 정의 iterable</li><li>String.prototype.trimStart(), trimEnd() 추가</li><li>배열 정렬 메서드 -- sort()는 이제 stable (정렬 키가 동일한 두 요소의 순서는 정렬 후에도 유지)</li><li>JSON.stringify()는 입력과 무관하게 well-formed UTF-8 문자열을 반환</li><li>필요 없다면 catch 블록 파라미터 생략 가능</li><li>Symbol.prototype.description getter 추가</li><li>Function.prototype.toString() : 함수가 ECMAScript로 정의된 경우, 함수 본문 반환</li></ul><h2>ES2020</h2><ul><li>import() : import .. from ... 구문과 다르게, 런타임에 동적으로 모듈 로드</li><li>import.meta : ES 모듈을 이용하는 경우, <span class="as-code code-span" lan="JavaScript">import.meta.url</span>를 이용해 모듈 URL 획득 가능</li><li>export * as newName from 'module' : 모듈의 defaults를 다시 노출하기만 할 때 편의 제공</li><li>BigInt : <span class="as-code code-span" lan="JavaScript">Number.MAX_SAFE_INTEGER</span>보다 큰 정수도 정확히 보존하는 정수 자료형</li><li>String.prototype.matchAll() : g 플래그를 켠 정규표현식의 모든 매치 결과를 순회할 수 있는 iterator 반환 -- 기존엔 전문검색을 위해 루프를 실행해야 했다</li><li>globalThis : 실행 환경(브라우저, Node, Deno, ...)과 무관하게 전역 컨텍스트를 통한 변수 접근 방법 제공</li></ul><div><h3>Optional chaining (?.)</h3><ul><li>?. 연산자를 이용하여 객체의 속성을 접근하거나 메서드를 호출할 수 있다</li><li>이 연산자로 접근하려는 객체나 호출하려는 함수가 undefined나 null인 경우, 연산은 단락되고 undefined를 반환한다</li></ul><h3>Nullish coalescing operator (??)</h3><p>연산자 좌변이 null 또는 undefined인 경우, 연산자 우변을 반환한다</p><h3>Promise.allSettled()</h3><p>Promise.all()은 일부가 실패한 경우 아래 2가지가 불가능했는데, allSettled()는 모두 가능하다<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" type="button" title="/Repositories/JavaScript/snippet/240314-190540.js" lan="JavaScript">예시 코드</button></p><ul><li>성공한 Promise의 반환값 획득</li><li>2번째 이후로 실패한 Promise의 에러 획득</li></ul></div><h2>ES2021</h2><ul><li>String.prototype.replaceAll() : 정규표현식 모든 매칭에 대해 치환</li><li>Promise.any() : 여러 Promise 중 하나라도 완료되면 반환</li><li>AggregateError : 여러 에러를 한 번에 표현</li><li>??=, &amp;&amp;=, ||= 논리 연산자 추가</li><li>WeakRef : 약한 참조 생성 ~ GC 수집 후 커스텀 finalizer 실행<p>FinalizationRegistry : 지정한 객체가 GC로 정리된 경우 호출. <a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry#notes_on_cleanup_callbacks">단, 이에 의존하면 안 됨</a></p></li><li>1_000처럼 리터럴 자리 구분 가능</li></ul><h2>ES2022</h2><ul><li>에러 원인을 cause 프로퍼티에 설정 가능</li><li>Array.prototype.at(), String.prototype.at() : 음수 인덱스도 지원하는 원소 접근 메서드</li><li>Object.hasOwn(obj, propKey) : Object.prototype.hasOwnProperty()의 안전한 버전</li></ul><div><h3>모듈 최상위 레벨 await 가능</h3><p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">import ...

await loadSecrets()
await readyDB()
</div><h3>클래스 정의 관련</h3><ul><li>static 프로퍼티, 메서드, 초기화 블록 정의 가능</li><li>constructor() 바깥의 클래스 body에서 프로퍼티 정의 가능</li><li>프로퍼티 또는 accessor 식별자를 #으로 시작하면 private</li></ul><h3>정규표현식 d 플래그 추가</h3><p>패턴 전체 및 각 캡처링 그룹에 대한 시작/끝 위치를 indices 속성에 제공</p><p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">/(aa)(bb)/d.exec('aaabbbccc').indices
/*
[
    [1, 5],
    [1, 3],
    [3, 5]
]
*/
</div></div><h2>WHATWG 2022</h2><div><h3><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/structuredClone">structuredClone(value[, options])</a></h3><p>객체 깊은 복사 지원</p></div><h2>ES2023</h2><ul><li>배열에 findLast(), findLastIndex() 추가</li><li>스크립트 첫 줄에 #!(Hashbang; Shebang) 지원</li><li>WeakMap 키로 non-registered symbol 사용 가능 -- Symbol.for()로 생성한 건 불가능</li></ul><div><h3>원본 수정 없이 사본을 반환하는 배열 메서드</h3><ul><li>with(index, value) : 지정한 index 원소로 value를 갖는 사본 반환</li><li>toSorted(compareFn?) : 정렬된 사본 반환</li><li>toReversed() : 원소가 역순인 사본 반환</li><li>toSpliced(...) : splice(...)를 수행한 사본 반환</li></ul></div><h2>ES2024</h2><ul><li>Object.groupBy(), Map.groupBy()를 이용한 집계 결과 생성</li><li>String.prototype.isWellFormed, toWellFormed 추가</li></ul><div><h3>Promise.withResolvers()</h3><p>Promise 객체의 상태 천이를 Promise 정의 바깥에서 하고 싶을 때</p><p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">let resolver, rejector
const promise = new Promise((resolve, reject) => {
    resolver = resolve
    rejector = reject
})</div><p>위와 같은 코드를 아래와 같이 축약할 수 있다</p><p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">const { promise, resolve, reject } = Promise.withResolvers()</div><h3>RegExp.prototype.unicodeSets</h3><ul><li>v 플래그를 이용해 생성한 정규표현식은 이 속성이 true로 설정된다</li><li>v 플래그는 유니코드 관련 기능을 활성화하는 u 플래그의 업그레이드 버전인데, 구문 해석 방식이 다르기 때문에 두 플래그를 모두 설정하면 SyntaxError가 발생한다</li><li>u 플래그에 비해 character class [...], [^...] 에 다음의 기능들이 추가된다<ul><li>추가적인 집합 연산 사용 가능<ul><li>[operand1&amp;&amp;operand2] : 교집합</li><li>[operand1--operand2] : 차집합</li><li>연산자를 한 번에 2개 이상 적용하는 것은 불가능하지만, nested 표기를 이용하면 쉽게 달성할 수 있다<p>한편, 단순 나열은 합집합 연산을 의미하므로 [AB--C]도 유효하지 않으며, [A[B--C]]와 같이 사용해야 한다</p></li></ul></li><li>[\q{substring}]으로 유니코드 리터럴 지정 가능. 내부에선 | 연산자만 이용 가능</li><li>\p 이스케이프로 RGI_Emoji와 같은 더 다양한 유니코드 클래스 집합 지정 가능</li></ul></li><li>i 플래그에서 \P{property} 평가가 달라진다<ul><li><span class="as-code code-span" lan="JavaScript">/P{Lowercase_Letter}/iu.test('a') === true</span><p>u 모드에서는 case-folding이 여집합 구성 후에 발생한다</p><ol><li>Lowercase_Letter에 대한 여집합이 생성된다 : uppercase + caseless</li><li>i 플래그를 위해 집합의 소문자 버전이 생성된다 : lowercase + caseless</li><li>입력 문자열은 패턴 매칭 전에 소문자 버전으로 변환된다</li><li>'a'는 패턴을 만족하므로 true 반환</li></ol></li><li><span class="as-code code-span" lan="JavaScript">/P{Lowercase_Letter}/iv.test('a') === false</span><p>v 모드에서는 case-folding이 여집합 구성 전에 발생한다</p><ol><li>Lowercase_Letter에 대한 소문자 버전 집합이 생성된다 : lowercase</li><li>대문자를 포함하지 않는 여집합이 생성된다 : caseless</li><li>입력 문자열은 패턴 매칭 전에 소문자 버전으로 변환된다</li><li>'a'는 패턴을 만족하지 않으므로 false 반환</li></ol></li></ul></li><li>i 플래그에서 character class complement syntax [^...] 에 대한 해석이 달라진다<ul><li><span class="as-code code-span" lan="JavaScript">/[^P{Lowercase_Letter}]/iu.test('A') === false</span><p>u 모드에서는 패턴을 반대로 평가한다</p><ol><li>Lowercase_Letter에 대한 여집합이 생성된다 : uppercase + caseless</li><li>i 플래그를 위해 집합의 소문자 버전이 생성된다 : lowercase + caseless</li><li>입력 문자열은 패턴 매칭 전에 소문자 버전으로 변환된다</li><li>'a'는 패턴을 만족하므로 false -- [^...]는 패턴을 매치 결과를 뒤집는다</li></ol></li><li><span class="as-code code-span" lan="JavaScript">/[^P{Lowercase_Letter}]/iv.test('A') === true</span><p>v 모드에서는 패턴을 반대로 평가하는 대신 여집합을 구성한다</p><ol><li>Lowercase_Letter에 대한 소문자 버전 집합이 생성된다 : lowercase</li><li>대문자를 포함하지 않는 여집합이 생성된다 : caseless</li><li>대문자를 포함하지 않는 여집합이 생성된다 : lowercase -- \P와 [^...]는 서로 상쇄된다</li><li>입력 문자열은 패턴 매칭 전에 소문자 버전으로 변환된다</li><li>'a'는 패턴을 만족하므로 true</li></ol></li></ul></li><li>v 모드가 grapheme cluster를 한 문자로 취급하지는 않는다. 여전히 코드 포인트의 모음으로 취급한다<p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">/😵‍💫/.test('😵‍💫')     // true
/😵‍💫/v.test('😵‍💫')    // true

/[😄-😛]/.test("😑")    // SyntaxError: Invalid regular expression: /[😄-😛]/: Range out of order in character class
/[😄-😛]/v.test("😑")   // true

/[😵‍💫]/.test('😵‍💫'.charAt(3))                             // true
/[😵‍💫]/v.test('😵‍💫'.charAt(3))                            // false
/[😵‍💫]/v.test(String.fromCodePoint('😵‍💫'.codePointAt(3))) // true
</div></li></ul><h3>가변 길이 ArrayBuffer 지원</h3><ul><li>ArrayBuffer의 크기가 줄어들어 래퍼 크기보다 작아지는 경우, 해당 래퍼에서 버퍼가 분리된 것으로 처리된다<p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">buf = new ArrayBuffer(7, { maxByteLength: 17 })
arr = new Uint16Array(buf, 2)

console.log(arr.length, arr.byteLength, arr.byteOffset) // 2 4 2
buf.resize(2)
console.log(arr.length, arr.byteLength, arr.byteOffset) // 0 0 2
    // length, byteLength는 즉시 0으로 변경
buf.resize(1)
console.log(arr.length, arr.byteLength, arr.byteOffset) // 0 0 0
    // V8 엔진에서, byteOffset은 버퍼의 실제 크기가 래퍼가 참조하는 영역에서 완전히 벗어나는 경우 0으로 변경

arr[1] = 123            // 무시됨
console.log(arr[1])     // undefined
console.log(arr.at(1))  // TypeError: Cannot perform %TypedArray%.prototype.at on a detached ArrayBuffer
</div></li><li>처음부터 변경 가능하도록 생성<p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">buf = new ArrayBuffer(4, { maxByteLength: 8 })
console.log(buf.byteLength) // 4

buf.resize(8)
console.log(buf.byteLength) // 8
</div></li><li>사용 도중 1회적으로 변경<p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">buf = new ArrayBuffer(4)
console.log(buf.byteLength)     // 4

newBuf = buf.transfer(8)
console.log(buf.detached)       // true
console.log(newBuf.byteLength)  // 8
</div></li></ul></div><h2>ES2025</h2><div><h3><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import/with">import 속성 지정</a></h3><p>예를 들어, 클라이언트는 아래와 같이 JSON을 기대했지만</p><p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">import config from 'https://xxx/config.json'</div><p>서버가 JSON이 아닌 실행 가능한 JavaScript 코드를 응답하면 의도치 않게 해당 코드가 실행되는 문제가 있었다. 이제는 속성을 지정하여 이러한 경우 명시적으로 오류를 발생할 수 있다</p><p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">import styles from "https://example.com/styles.css" with { type: "css" }
import("https://example.com/data.json", { with { type: "json" } })
</div><h3><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Iterator#iterator_helper_methods">Iterator#iterator_helper_methods</a></h3><p>Iterator helper method는 기존 iterator를 이용하는 새로운 iterator helper object를 반환한다. 두 iterator의 진행도는 동기화되며, 독립적으로 진행되지 않는다</p><ul><li>drop(limit) : 최초 limit개의 요소 순회 생략</li><li>every(callbackFn) : 모든 요소가 조건을 만족하면 true</li><li>filter(callbackFn) : 조건에 맞는 요소만 순회</li><li>find(callbackFn) : 조건에 맞는 첫 번째 요소를 반환</li><li>flatMap(callbackFn) : iterator 또는 iterable을 반환하여 차원 평탄화</li><li>forEach(callbackFn) : 모든 요소 소비</li><li>map(callbackFn) : 요소를 변환하여 순회</li><li>reduce(callbackFn[, initialValue]) : 모든 요소를 소비하여 결과값 축약</li><li>some(callbackFn) : 일부 요소가 조건을 만족하면 true</li><li>take(limit) : 최초 limit개의 요소만 순회</li></ul><h3>Iterator 유틸리티 추가</h3><ul><li>Iterator.prototype.toArray() : 하는 일은 Array.from(iterator), [...iterator]와 동일</li><li>Iterator.from(object)<ul><li>object가 iterable인 경우 : 해당 객체의 [Symbol.iterator]()를 순회에 이용하는 새로운 iterator 반환</li><li>object가 iterator인 경우 : 해당 객체 그대로 반환</li><li>그 외의 경우 : 해당 객체(iterator로 간주)를 감싼 새 Iterator 객체 반환 -- 사용시 런타임 에러 발생 가능</li></ul></li><li>new Iterator() : Iterator를 상속하여 순회 알고리즘 직접 구현 가능. Generator를 이용하는 구현과 다르게, Iterator의 모든 헬퍼 메서드 이용 가능</li></ul><h3>집합 연산 추가</h3><ul><li>difference(other) : 차집합 반환</li><li>intersection(other) : 교집합 반환</li><li>isDisjointFrom(other) : 교집합이 0인지 검사</li><li>isSubsetOf(other) : 부분집합인지 검사</li><li>isSupersetOf(other) : other를 모두 포함하는지 검사</li><li>symmetricDifference(other) : 대칭차집합 반환</li><li>union(other) : 합집합 반환</li></ul><h3>정규식 업데이트</h3><ul><li>RegExp.escape()<p>RegExp 생성자에 그대로 사용할 수 있는 문자열 반환</p><p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">txt = `abc!@#$%^&*(){}[]'";`
new RegExp(RegExp.escape(txt)).test(txt)    // true
</div></li><li>Flag modifier<p>정규식 특정 파트에 대해서만 추가로 플래그를 켜거나 끄는 게 가능</p><ul><li>(?flags1:pattern) : flags1에 지정한 플래그들을 추가로 적용</li><li>(?flags1-flags2:pattern) : flags1에 지정한 플래그들을 추가로 적용 + flags2에 지정한 플래그들은 적용하지 않음</li></ul></li><li>중복 명명된 캡처링 그룹 허용<p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">txt = 'aabbbcccc'
regex = /(?&lt;chars>a+)|(?&lt;chars>b+)/g
console.log(regex.exec(txt), regex.exec(txt))</div><figure class="w3-margin-bottom"><picture><source srcset="/imgs-generated/202507/Screenshot 2025-07-23 at 6.19.03 PM-500.avif 500w, /imgs-generated/202507/Screenshot 2025-07-23 at 6.19.03 PM-1200.avif 1200w, /imgs-generated/202507/Screenshot 2025-07-23 at 6.19.03 PM-2000.avif 2000w" type="image/avif"/><source srcset="/imgs-generated/202507/Screenshot 2025-07-23 at 6.19.03 PM-500.webp 500w, /imgs-generated/202507/Screenshot 2025-07-23 at 6.19.03 PM-1200.webp 1200w, /imgs-generated/202507/Screenshot 2025-07-23 at 6.19.03 PM-2000.webp 2000w" type="image/webp"/><source srcset="/imgs-generated/202507/Screenshot 2025-07-23 at 6.19.03 PM-500.jpeg 500w, /imgs-generated/202507/Screenshot 2025-07-23 at 6.19.03 PM-1200.jpeg 1200w, /imgs-generated/202507/Screenshot 2025-07-23 at 6.19.03 PM-2000.jpeg 2000w" type="image/jpeg"/><img class="w3-round" src="/imgs-generated/202507/Screenshot 2025-07-23 at 6.19.03 PM-2000.jpeg" alt="Screenshot 2025-07-23 at 6.19.03 PM.png" loading="lazy" sizes="auto" width="2066" height="298"/></picture><figcaption class="w3-padding">&lt;Screenshot 2025-07-23 at 6.19.03 PM.png&gt;<a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="/imgs/202507/Screenshot 2025-07-23 at 6.19.03 PM.png" target="_blank">[원본 보기]</a></figcaption></figure></li></ul><h3>Promise.try()</h3><p>가능한 모든 형태의 함수 호출을 Promise로 변환</p><p><strong>↓ JavaScript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="JavaScript">Promise.try(func)
Promise.try(func, arg1)
Promise.try(func, arg1, arg2)
Promise.try(func, arg1, arg2, /* …, */ argN)
</div><h3>Float16 지원</h3><p>16비트 float 사용으로 오히려 연산 성능 저하를 경험할 수 있다. 16비트 연산에 최적화된 플랫폼에서 사용하는 것이 권장된다</p><ul><li>Math.f16round()</li><li>Float16Array</li><li>DataView.prototype.getFloat16(), setFloat16()</li></ul></div></div></article></main></body></html>