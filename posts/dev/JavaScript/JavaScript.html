<!DOCTYPE html><html lang="ko-KR"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>JavaScript</title><link rel="stylesheet" href="/source/default.css"><meta name="google-site-verification" content="aH-DyzdytYQ0NPHNQFcs5dVoiu5YNs6CEEHYgqDmAFM"><meta name="author" content="Donggi Kim &lt;hi.donggi@gmail.com&gt;"><meta name="description" content="JavaScript(ECMAScript) 정리"><link rel="icon" href="/imgs/favicon.png"><script id="google-analytics" src="https://www.googletagmanager.com/gtag/js?id=UA-143098403-1" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-143098403-1');</script><script id="highlight-js" src="/source/highlight.pack.js" defer></script><script id="default-js" src="/source/default.min.js" defer></script></head><body><aside class="w3-animate-left" id="sidebar"><hr><div id="marker-list"></div><hr><div id="post-list"></div><hr><details class="w3-small file-list"><summary>LICENSE</summary><table class="w3-table-all w3-card w3-small"><tr><td>Author</td><td>License</td></tr><tr><td>&copy; <a href="mailto:hi.donggi@gmail.com">Donggi Kim</a></td><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/Dong-gi/Dong-gi.github.io/blob/master/LICENSE">MIT</a></td></tr><tr><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://www.w3schools.com/w3css">w3css</a></td><td>No license</td></tr><tr><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://highlightjs.org/">highlight.js</a></td><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/highlightjs/highlight.js/blob/main/LICENSE">BSD-3-Clause</a></td></tr><tr><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/mathjax/MathJax">MathJax</a></td><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/mathjax/MathJax/blob/master/LICENSE">Apache-2.0</a></td></tr><tr><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/davidshimjs/qrcodejs">QRCode.js</a></td><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/davidshimjs/qrcodejs/blob/master/LICENSE">MIT</a></td></tr><tr><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/terrastruct/d2">D2</a></td><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/terrastruct/d2/blob/master/LICENSE.txt">MPL-2.0</a></td></tr></table></details><hr></aside><main id="main"><nav class="w3-bar w3-blue" id="nav"><button class="w3-bar-item w3-button w3-hover-theme" id="nav-toggle-btn">&#9776;</button><form role="search"><input class="w3-bar-item" id="query" type="search" placeholder="search" style="max-width:35%"></form><a class="w3-bar-item w3-button w3-hover-theme" href="/">Home</a></nav><article id="contents"><h1>자료</h1><ul><li><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript">MDN &gt; JavaScript 배우기</a></li><li><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://web.dev/learn/javascript">web.dev &gt; JavaScript 배우기</a></li></ul><h1>JavaScript 역사</h1><div><h2>참고자료</h2><ul><li><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://dzone.com/articles/a-brief-history-of-javascript">a-brief-history-of-javascript</a></li><li><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://en.wikipedia.org/wiki/JavaScript">JavaScript</a></li></ul><h2>현재</h2><p>JavaScript는 ECMAScript 표준을 준수하는 고급 프로그래밍 언어로, JIT 컴파일로 실행되는 스크립트 언어</p><h2>넷스케이프의 창조</h2><ul><li>1995년. 동적 웹 콘텐츠 개발을 위해 DOM과 상호작용할 수 있는 프로그래밍 언어를 추가하기 위한 결정이 이루어졌다</li><li>넷스케이프의 "브라우저를 위한 Scheme" 개발 프로젝트에 JavaScript의 아버지 Brendan Eich도 있었다</li><p>Scheme은 Lisp의 방언 중 하나</p><ul><li>당시 이미 넷스케이프와 썬 마이크로시스템즈는 브라우저에서 Java를 사용(자바 애플릿)할 수 있도록 계약을 체결하려는 시점이었다</li><li>따라서 새로운 언어(개발명 Mocha)를 추가하는 목적은 프로그램 개발이 아니라, HTML 안에서 동적으로 애니메이션 추가, 디자인 변경 등을 수행하는 것(작은 스크립팅 작업)이었으며, 전문 개발자가 아닌 HTML을 작성할 줄 아는 디자이너와 같은 사람들이 타깃 유저층이었다</li><li>즉, Mocha는 Java의 스크립팅 동반자가 되어야 했다. 이를 위해 Java와 유사한 구문들이 채택되었고, Scheme으로부터 멀어진 모습을 갖게 되었다</li></ul><li>1995년 9월 베타 출시하면서 LiveScript로 이름 변경</li><li>1995년 12월 정식 출시하면서 JavaScript로 이름 변경 (썬 마이크로시스템즈와 합의)</li></ul><h2>마이크로소프트의 채택</h2><ul><li>1995년 인터넷 익스플로러(IE)를 출시한 뒤 넷스케이프와 브라우저 전쟁을 벌였다</li><li>1996년 8월 넷스케이프의 스크립트 인터프리터를 리버스 엔지니어링하여 자체 인터프리터 JScript를 출시</li><p>상표권 문제가 될 수 있기 때문에 "Java"를 그대로 사용하지 않았다</p><li>두 브라우저의 스크립트 엔진 구현이 달랐기 때문에, 같은 코드가 서로 다르게 보이는 일이 잦았다</li><p>불행히도 IE가 독점적인 위치를 차지하는 동안, 개발자는 IE를 위한 특별한 처리를 해줘야 했다</p></ul><h2>표준화 시도</h2><ul><li>1996년 11월 넷스케이프는 브라우저 공급업체가 준수할 수 있는 표준 사양의 출발점으로 JavaScript를 ECMA International에 제출</li><li>1997년 6월 첫 번째 ECMAScript 발표</li><p>마찬가지로 상표권 문제가 있으므로 "Java"를 그대로 사용하지 않음. 이제 JavaScript는 상업적 이름일 뿐</p><li>1998년 6월 ECMAScript 2 발표</li><p>ECMAScript와 JavaScript용 ISO 표준(ISO/IEC 16262) 사이의 불일치를 수정</p><li>1999년 12월 ECMAScript 3 발표</li><p>정규식, try/catch 블록, in 및 instanceof 연산자 등 추가</p></ul><h2>ECMAScript 3.1과 4</h2><div><p>ECMAScript 4에 대한 작업은 버전 3이 출시되자마자 시작되었는데, 위원회에 강한 의견 차이가 대두되었다</p><ul><li>JavaScript가 대규모 애플리케이션을 개발할 수 있는 강력한 언어가 되기 위해 새로운 기능이 필요하다</li><p>vs</p><li>그러한 변경 사항은 JavaScript에 적합하지 않다</li></ul><p>버전 4에 대한 작업은 2003년 잠시 중단되었다가, 2005년 AJAX와 XMLHttpRequest의 영향으로 새 버전에 대한 관심이 높아지면서 작업이 재개되었다. 개발이 절정에 달했을 때 버전 4에는 다음과 같은 기능들이 포함되었다</p><ul><li>클래스, 인터페이스, 구조체, 사용자 정의 타입, 파라미터화된 타입</li><li>패키지, 네임스페이스</li><li>반복자, 생성자</li><li>선택적 타입 주석, 선택적 정적 타입 체크</li><li>...</li></ul><p>버전 4를 개발하는 위원회는 Adobe, Mozilla, Opera(비공식 자격), Microsoft로 구성되었는데, 대부분의 표준이 결정된 상태에서 Yahoo가 참여했다. 영향력 있는 JavaScript 개발자 Doug Crockford이 Yahoo에서 보낸 사람이었는데, 그는 버전 4의 많은 변경 사항에 대해 강력히 반대 의사를 표명했고 Microsoft로부터 강력한 지지를 받았다. 결국 버전 4 개발은 지지부진해졌고, Crockford는 모두가 동의할 수 있는 -- 구문 변경 없는 실용적인 개선사항만 담은 새로운 표준을 추진했고, 이것이 ECMAScript 3.1이다</p><p>2008년 오슬로에서 열린 회의에서 ECMAScript 3.1과 4의 미래가 결정되었다</p><ul><li>모든 구성원의 협력으로 ES3.1 완성에 집중</li><li>이후 ES4보다는 완화된 의미론적 및 구문론적 혁신에 대해 협력</li><li>패키지, 네임스페이스 등 웹에 적합하지 않은 제안은 제외</li></ul><h3>ActionScript</h3><ul><li>ActionScript는 ECMAScript 4 초안을 기반으로 하는 언어로, Adobe는 이를 Flash 제품군의 일부로 구현해 출시했다</li><li>때문에 Adobe는 ECMAScript 4를 강력히 지지했고, 채택을 위해 엔진을 오픈 소스(Tamarin)로 출시하기도 했다</li></ul></div><h2>ECMAScript 5</h2><ul><li>ECMAScript 4는 이미 8년의 개발을 거쳐 특정 변형으로 인식되었으므로, 혼동을 피하기 위해 ECMAScript 3.1의 이름은 ECMAScript 5로 변경되었다</li><li>2009년 출시된 ES5는 가장 많이 지원되는 JavaScript 버전 중 하나가 되었고, 많은 트랜스파일러의 기본 컴파일 대상이 되었다</li><p>Firefox 4 (2011), Chrome 19 (2012), Safari 6 (2012), Opera 12.10 (2012) 및 Internet Explorer 10 (2012)에서 전적으로 지원</p><li>수정사항</li><ul><li>Getter/setter</li><li>배열 및 객체 리터럴에서 후행 쉼표</li><li>예약어를 프로퍼티 이름으로 허용</li><li>신규 Object 메서드 : create, defineProperty, keys, seal, freeze, ...</li><li>신규 Array 메서드 : isArray, indexOf, every, some, map, filter, reduce, ...</li><li>신규 Date 메서드 : toISOString, now, toJSON</li><li>String.prototype.trim 추가</li><li>JSON</li><li>불변 전역 객체 : undefined, NaN, Infinity</li><li>Strict 모드</li><li>...</li></ul></ul><h2>ECMAScript 6 (2015) : 범용 언어</h2><ul><li>ECMAScript 4에서 폐기되지 않은 아이디어는 ECMAScript Harmony에서 새롭게 제안되었고, ECMAScript 2015로 이름이 바뀐 ECMAScript 6는 이러한 구문 변경이 필요한 업데이트를 담고 있다</li><p>이러한 구문 변경들은 브라우저 공급업체들이 모두 지원하기까지 상당한 시간이 소요됐고, 이로 인해 ECMAScript 2015 출시 이후 트랜스파일러의 사용이 크게 증가했다</p><li>ECMAScript 2015 수정사항</li><ul><li>let, const 변수 선언</li><li>화살표 함수와 this 키워드</li><li>클래스</li><li>객체 리터럴 개선 : 계산된 키 사용, 더 짧은 메서드 정의 등</li><li>템플릿 문자열</li><li>Promise</li><li>생성자, iterable, 반복자, for..of 구문</li><li>신규 컬렉션 : Set, Map, WeakSet, WeakMap</li><li>해체 할당</li><li>...</li></ul></ul><h2>ECMAScript 2016</h2><ul><li>지수 연산자 **</li><li>Array.prototype.includes</li></ul></div><h1>식별자</h1><ol><li>식별자 : '_', '$' 허용<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/JavaScript/Basic/type.js" displayRange="[1,1]" lan="javascript">type.js</button></li><li>변수 선언</li><ul><li>let 식별자;</li><p>일반적인 지역변수와 동일. 선언된 순간부터 해당 코드 블록이 끝날때까지 유효. 중첩된 코드 블록에서 같은 식별자의 변수를 선언하여 밖의 변수를 가릴 수 있다<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/JavaScript/Basic/type.js" displayRange="[2,2]" lan="javascript">type.js</button></p><li>var 식별자;</li><p>선언 전에 참조하는 경우, 선언을 끌어올려 undefined를 할당해준다. 함수 스코프에서 동작하지만, 중첩된 코드 블록에서 재정의하여 가릴 수 없다</p></ul><li>상수 선언 : const 식별자;<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/JavaScript/Basic/type.js" displayRange="[4,4]" lan="javascript">type.js</button></li></ol><h1>자료형</h1><ul><li>Object</li><ol><li>객체 리터럴 : {}</li><li>delete 키워드로 프로퍼티 제거 가능</li><li>JSON.stringify(), JSON.parse(), Object.keys()<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/JavaScript/Basic/type.js" displayRange="[11,15]" lan="javascript">type.js</button></li></ol><li>String</li><ol><li>문자 리터럴 : \xFF, \uFFFF</li><li>문자열 리터럴 : '', "", ``(문자열 템플릿)<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/JavaScript/Basic/type.js" displayRange="[4,5,17,17]" lan="javascript">type.js</button></li></ol><li>Number</li><ol><li>IEEE-764 double-precision 부동소수</li><li>숫자 리터럴 : 999, 0o777, 0xFFF, 0.999, 0.999E-9</li><li>숫자 상수 : Infinity, -Infinity, NaN, Number.EPSILON, Number.MAX_VALUE, Number.MAX_SAFE_INTEGER</li><li>Number(), parseInt(), parseFloat(), number.toString(radix)</li></ol><li>Boolean</li><p>Boolean() : "", 0, NaN, null, undefined == false, 그 외 == true</p><li>Undefined</li><li>Null</li><li>Symbol</li><p>ES6부터 도입된 타입. 그 무엇과도 같지 않은 유일한 토큰을 나타낸다<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/JavaScript/Basic/type.js" displayRange="[7,9]" lan="javascript">type.js</button></p><li>배열 : []</li><p>자바스크립트의 배열은 모두 동적 배열. 변수와 마찬가지로 타입을 가리지 않는다<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/JavaScript/Basic/array.js" lan="javascript">array.js</button></p><li>Map</li><p><strong>↓ javascript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="javascript">new Map(iterable: Iterable&lt;readonly [K, V]>)
new Map(entries?: readonly (readonly [K, V])[])
set(key, value), get(key), has(key)
delete(key), clear()
size, keys(), values(), entries()</div><li>WeakMap</li><p>키는 반드시 객체여야 하며, 키는 GC 대상이 된다. 따라서 객체가 살아있는 동안에 참조해야 하는 고유값들을 저장하기에 좋다</p><li>Set</li><p><strong>↓ javascript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="javascript">new Set(iterable?: Iterable&lt;any>)
new Set(values?: readonly T[])
add(value), has(value), ...</div><li>WeakSet</li><p>값은 반드시 객체여야 하며, GC 대상이 된다</p></ul><h1>연산자</h1><ol><li>Boolean 연산자 : !, &&, ||</li><p>&&, ||는 short circuit 연산</p><li>비트 연산자 : ~, &, |, ^, &lt;&lt;, >>, >>></li><li>,연산자 : 순서대로 평가하여 마지막 표현식의 결과가 할당됨<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/JavaScript/Basic/syntax.js" displayRange="[9,10]" lan="javascript">syntax.js</button></li><li>in 연산자 : 객체에 해당 프로퍼티가 존재하는지 여부 반환<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/JavaScript/Basic/syntax.js" displayRange="[12,12]" lan="javascript">syntax.js</button></li><p>객체에 직접 정의된 프로퍼티는 hasOwnProperty() 메서드 이용</p><li>instanceof 연산자 : 객체 호환 여부 반환</li><li>해체 할당; Destructuring Assignment</li><p><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/JavaScript/Basic/syntax.js" displayRange="[15,22]" lan="javascript">배열 해체 할당 »</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/JavaScript/Basic/syntax.js" displayRange="[26,29]" lan="javascript">배열 연속 해체 »</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/JavaScript/Basic/syntax.js" displayRange="[33,36]" lan="javascript">다차원 배열 해체 »</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/JavaScript/Basic/syntax.js" displayRange="[40,47]" lan="javascript">확산 연산자 »</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/JavaScript/Basic/syntax.js" displayRange="[51,65]" lan="javascript">객체 해체 할당 »</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/JavaScript/Basic/syntax.js" displayRange="[69,71]" lan="javascript">객체 메서드 해체 할당 »</button></p></ol><h1>Syntax</h1><ol><li>if...[else if...][else...]</li><li>while, do...while</li><li>for<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/JavaScript/Basic/syntax.js" displayRange="[1,7]" lan="javascript">syntax.js</button></li><li>switch : 조건으로 변수가 아닌 일반 표현식도 가능</li><li>for(let attr in obj) {} : 객체 프로퍼티 순회</li><li>for(let name of iterable) {} : 배열, Iterable 객체 순회</li><li>with(obj) : 스코프 고정</li><li>try ~ catch ~ finally</li><p>예외 처리. throw는 임의의 타입을 던질 수 있다. try 뒤에 catch 또는 finally가 하나라도 있어야 한다</p></ol><h1>Function</h1><ol><li>오버로딩 불가. 함수 호출 시 매개변수 길이 불일치해도 됨</li><li>arguments 객체를 통해 매개변수에 접근.(람다는 불가능)</li><li>매개변수에 기본값 설정 가능</li><li>매개변수도 해체, 확산 연산자 사용 가능</li><li>명시하지 않은 경우, 함수의 기본 반환값은 undefined</li><li>함수가 호출하는 지점보다 나중에 정의되어 있는 경우, 함수 선언이 위로 끌어올려진다</li><li>함수의 컨텍스트(this) 지정</li><p><strong>↓ javascript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="javascript">hello.apply({name: "Donggi"}, ["2018-08-08"]); // apply(호출자, 매개변수 배열)
hello.call({name: "Donggi"}, "2018-08-08");    // call(호출자, 매개변수)
// 확산 연산자 ...을 이용하면 call로 apply와 같은 효과를 낼 수 있다
let helloKim = hello.bind({name: "Kim"});      // 함수 호출자 영구 고정</div><li>함수 표현식 let f = function functionName() {}</li><li>익명 함수 let f = function () {}</li><li>화살표 표기법 let f = () => {}</li><li>클로저 Closure</li><p>함수 할당에 의해 접근할 수 있는 스코프가 늘어나는 것<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/JavaScript/Basic/function.js" displayRange="[2,8]" lan="javascript">function.js</button></p><li>즉시 실행 함수 표현 IIFE; Immediately Invoked Function Expression<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/JavaScript/Basic/function.js" displayRange="[12,17]" lan="javascript">function.js</button></li></ol><h1>Class</h1><ol><li>클래스는 본질적으로 함수다. 단순히 문법적 편의성이 더해졌을 뿐</li><p><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/JavaScript/Basic/class.js" displayRange="[1,15]" lan="javascript">클래스 정의 예 »</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/JavaScript/Basic/class.js" displayRange="[18,19]" lan="javascript">상속 예 »</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/JavaScript/Basic/class.js" displayRange="[22,39]" lan="javascript">믹스인 예 »</button></p><li>전역 객체</li><p>Object, Array, String, Global, Math<br>Global 객체를 직접 획득하는 건 불가능 : isNaN(), isFinite(), parseInt(), parseFloat(), encodeURI(), encodeURIComponent(), eval()</p><li>Private 멤버</li><p>#으로 시작되는 프로퍼티, 메서드는 객체 외부에서 접근할 수 없다</p><li>객체 보호</li><p><strong>↓ javascript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="javascript">Object.freeze()            // 객체 동결. 읽기만 가능
Object.seal()              // 객체 봉인. 기존 프로퍼티 값은 수정 가능
Object.preventExtensions() // 객체 확장 금지. 새 프로퍼티 추가만 금지</div><p><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/JavaScript/Basic/class.js" displayRange="[42,70]" lan="javascript">접근자 프로퍼티 + 객체 보호 예 »</button></p></ol><div><h2>프록시</h2><p><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler#Methods">참고자료</a><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/JavaScript/Basic/class.js" displayRange="[73,85]" lan="javascript">프록시 예 »</button></p><table class="w3-table-all w3-card w3-small"><tr><th>getPrototypeOf()</th><td>A trap for Object.getPrototypeOf</td></tr><tr><th>setPrototypeOf()</th><td>A trap for Object.setPrototypeOf</td></tr><tr><th>isExtensible()</th><td>A trap for Object.isExtensible</td></tr><tr><th>preventExtensions()</th><td>A trap for Object.preventExtensions</td></tr><tr><th>getOwnPropertyDescriptor()</th><td>A trap for Object.getOwnPropertyDescriptor</td></tr><tr><th>defineProperty()</th><td>A trap for Object.defineProperty</td></tr><tr><th>has()</th><td>A trap for the in operator</td></tr><tr><th>get()</th><td>A trap for getting property values</td></tr><tr><th>set()</th><td>A trap for setting property values</td></tr><tr><th>deleteProperty()</th><td>A trap for the delete operator</td></tr><tr><th>ownKeys()</th><td>A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols</td></tr><tr><th>apply()</th><td>A trap for a function call</td></tr><tr><th>construct()</th><td>A trap for the new operator</td></tr></table></div><h1>Iterator, Generator</h1><p>해체 할당과 마찬가지로 파이썬에서 가져온 아이디어들 중 하나<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/JavaScript/Basic/iterator.js" lan="javascript">이터레이션 프로토콜 예 »</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/JavaScript/Basic/generator.js" lan="javascript">제너레이터 예 »</button></p><ul><li>파이썬과 마찬가지로 제어권을 주고받는 데 제너레이터를 사용한다</li><li>yield 키워드를 사용하는 모든 함수는 제너레이터 함수다</li><li>제너레이터 함수를 호출하면 제너레이터 객체를 받는다</li><li>제너레이터의 실행을 재개하는 3가지 메서드 : next(), send(), throw()</li></ul><h1>비동기 처리</h1><ol><li>전통적 방식 : 콜백</li><p>setTimeout(), setInterval(), clearInterval()<br>Error-first Callback : 콜백 첫번째 매개변수를 err로 사용하는 것<br>Callback Hell : 연속적으로 콜백이 다른 콜백을 호출하여 관리하기 어려워지는 상황</p><li>Promise</li><p>실행의 종료를 보장. 실행 상태(성공, 실패)에 따라 다른 콜백을 적절히 호출. 적절한 예외 처리도 지원 가능<br>Promise의 생성은 resolve, reject 콜백을 매개변수로 받는 함수를 작성하기만 하면 된다<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/JavaScript/Basic/promise.js" lan="javascript">promise.js »</button><br>Promise.all(), Promise.race(), ...</p><li>async, await</li><p>함수 정의 앞에 async 키워드를 사용하면 함수 내에서 await를 사용할 수 있다. 이때, 함수는 Promise가 결정될 때까지 일시 중지<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/JavaScript/Basic/async.js" lan="javascript">async.js »</button></p></ol><h1>정규표현식</h1><ul><li>정규표현식(RegExp) 리터럴 /X/</li><p>/123/gm과 new RegExp('123', 'gm')는 의미적으로 동일하다</p><li>Flag : g(global), i(ignoreCase), m(multiline), s(.이 newline도 매칭 Since ES2018)</li><p>global 플래그를 이용하는 경우, RegExp.lastIndex로 검색 위치를 기록하며, 해당 위치부터 재탐색한다따라서 global RegExp에 동일 문자열을 반복적으로 test()하는 경우 true, false가 토글되는 현상을 경험할 수도 있다</p><p>↓ 자바와 동일한 부분은 생략했음</p><li>Greedy 수량사</li><p>?, *, +, {n}, {n, }, {n, m}</p><li>replace()에서의 backreference</li><ul><li>$& 일치 문자열</li><p><strong>↓ javascript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="javascript">'1 12 123 1234'.replace(/1/gm, '[$&]') // "[1] [1]2 [1]23 [1]234"</div><li>$` 앞부분</li><p><strong>↓ javascript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="javascript">'1 12 123 1234'.replace(/1/gm, '[$`]') // "[] [1 ]2 [1 12 ]23 [1 12 123 ]234"</div><li>$' 뒷부분</li><p><strong>↓ javascript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="javascript">'1 12 123 1234'.replace(/1/gm, "[$']") // "[ 12 123 1234] [2 123 1234]2 [23 1234]23 [234]234"</div></ul><li>관련 메서드</li><ul><li>RegExp#test() : 패턴이 검색되는지 여부</li><li>RegExp#exec() : 매칭되는 인덱스들을 배열로 반환매칭 시작 index, 검색 텍스트 input 프로퍼티를 가진다. [i] 접근으로 캡처 그룹을 가져올 수 있다</li><p><strong>↓ javascript</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="javascript">/1/gm.exec('1 12 123') // ["1", index: 0, input: "1 12 123", groups: undefined]</div><li>String#search(regexp) : 처음 매칭된 인덱스 반환</li><li>String#match(regexp) : 매칭되는 모든 부분문자열 반환</li><li>String#replace(regexp, replaceValue) : 매칭된 부분문자열을 replaceValue로 치환</li><li>String#split(regexp, limit) : 매칭된 문자열을 분리</li></ul></ul><h1>버전별 신규 기능</h1><div><h2>ES6</h2><div><h3>Tagged template literal</h3><div><p>Tag function을 이용하여 문자열 보간 작업을 사용자 정의할 수 있다<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/JavaScript/snippet/240314-162705.js" lan="javascript">예시 코드</button></p><p>문자열이 아닌 걸 반환해도 된다<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/JavaScript/snippet/240314-165131.js" lan="javascript">예시 코드</button></p></div></div><h2>ES2020</h2><div><h3>Optional chaining (?.)</h3><ul><li>?. 연산자를 이용하여 객체의 속성을 접근하거나 함수를 호출할 수 있다</li><li>이 연산자로 접근하려는 객체나 호출하려는 함수가 undefined나 null인 경우, 연산은 단락되고 undefined를 반환한다</li></ul><h3>Nullish coalescing operator (??)</h3><p>연산자 좌변이 null 또는 undefined인 경우, 연산자 우변을 반환한다</p><h3>import()</h3><p>import .. from ... 구문과 다르게, 런타임에 변수를 이용해 모듈을 로드한다</p><h3>String.matchAll()</h3><p>전체 문자열에서 정규표현식 매칭을 수행한 결과를 반환한다 -- 기존엔 전문검색을 위해 루프를 실행해야 했다</p><h3>Promise.allSettled()</h3><p>Promise.all()은 일부가 실패한 경우 아래 2가지가 불가능했는데, allSettled()는 모두 가능하다<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/JavaScript/snippet/240314-190540.js" lan="javascript">예시 코드</button></p><ul><li>성공한 Promise의 반환값 획득</li><li>2번째 이후로 실패한 Promise의 에러 획득</li></ul><h3>BigInt</h3><p><span class="as-code code-span" lan="javascript">Number.MAX_SAFE_INTEGER</span>보다 큰 정수도 정확히 보존하는 정수 자료형</p><h3>globalThis</h3><p>실행 환경(브라우저, Node, Deno, ...)과 무관하게 전역 컨텍스트를 통한 변수 접근 방법 제공</p><h3>import.meta</h3><p>ES 모듈을 이용하는 경우, <span class="as-code code-span" lan="javascript">import.meta.url</span>를 이용해 모듈 URL 획득 가능</p><h3>export * as newName from 'module'</h3><p>모듈의 defaults를 다시 노출하기만 할 때 편의 제공</p></div></div></article></main></body></html>