<!DOCTYPE html><html lang="ko-KR"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Python 표준 라이브러리</title><link rel="stylesheet" href="/source/default.css"><meta name="google-site-verification" content="aH-DyzdytYQ0NPHNQFcs5dVoiu5YNs6CEEHYgqDmAFM"><meta name="author" content="Donggi Kim &lt;hi.donggi@gmail.com&gt;"><meta name="description" content="Python 표준 라이브러리 정리"><link rel="icon" href="/imgs/favicon.png"></head><body><div class="w3-bar-block w3-sidebar w3-animate-left" id="sidebar"><hr><div id="marker-list"></div><hr><div id="post-list"></div><hr><details class="w3-small file-list"><summary>LICENSE</summary><table><tr><td>Author</td><td>License</td></tr><tr><td>&copy; <a href="mailto:hi.donggi@gmail.com">Donggi Kim</a></td><td><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/Dong-gi/Dong-gi.github.io/blob/master/LICENSE">MIT</a></td></tr><tr><td><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="https://www.w3schools.com/w3css">w3css</a></td><td>No license</td></tr><tr><td><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="https://highlightjs.org/">highlight.js</a></td><td><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/highlightjs/highlight.js/blob/main/LICENSE">BSD-3-Clause</a></td></tr><tr><td><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/mathjax/MathJax">MathJax</a></td><td><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/mathjax/MathJax/blob/master/LICENSE">Apache-2.0</a></td></tr><tr><td><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/davidshimjs/qrcodejs">QRCode.js</a></td><td><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/davidshimjs/qrcodejs/blob/master/LICENSE">MIT</a></td></tr><tr><td><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/terrastruct/d2">D2</a></td><td><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/terrastruct/d2/blob/master/LICENSE.txt">MPL-2.0</a></td></tr></table></details><hr></div><article id="main"><div class="w3-bar w3-blue w3-large" id="nav" style="position:-webkit-sticky;position:sticky;top:0px;vertical-align:middle"><button class="w3-bar-item w3-button w3-hover-theme" onclick="toggleSidebar()">&#9776;</button><input class="w3-bar-item" id="query" type="text" placeholder="search" style="max-width:35%"><a class="w3-bar-item w3-button w3-hover-theme" href="/">Home</a></div><div class="w3-padding" id="contents"><h1>string : 문자열 공통 연산</h1><div><h2>Constants</h2><p><strong>↓python</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="python">string.ascii_letters   # ascii_lowercase + ascii_uppercase
string.ascii_lowercase # 'abcdefghijklmnopqrstuvwxyz'
string.ascii_uppercase # 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
string.digits          # '0123456789'
string.hexdigits       # '0123456789abcdefABCDEF'
string.octdigits       # '01234567'
string.punctuation     # '!"#$%&\'()*+,-./:;&lt;=>?@[\\]^_`{|}~'
string.whitespace      # ' \t\n\r\x0b\x0c'
string.printable       # digits + ascii_letters + punctuation + whitespace
</div><h2>Format String Syntax</h2><ul><li>replacement_field ::= "{" [field_name] ["!" conversion] [":" format_spec] "}"</li><li>field_name ::= arg_name ("." attribute_name | "[" element_index "]")*</li><p>.attribute_name → getattr(), [element_index] → __getitem__()</p><li>arg_name ::= [identifier | digit+]</li><p>identifier → 키워드 인자 참조, digit → positional 인자 참조</p><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Python/Basic/format_example.py" displayRange="[1,7]" lan="python">format_example.py</button><li>attribute_name ::= identifier</li><li>element_index ::= digit+ | index_string</li><li>index_string ::= &lt;any source character except "]"> +</li><li>conversion ::= "r" | "s" | "a" # 각각 repr(), str(), ascii() 호출</li><li>format_spec ::= [[fill]align][sign][#][0][width][grouping_option][.precision][type]</li><li>fill ::= &lt;any character></li><li>align ::= "&lt;" | ">" | "=" | "^"</li><li>sign ::= "+" | "-" | " "</li><li>'#' 옵션이 있으면 2, 8, 16진수 앞에 '0b', '0o', '0x'를 각각 붙인다</li><li>width ::= digit+</li><li>grouping_option "_" Since 3.6 | "," Since 3.1 // 십진수 1000단위 구분, 그외 4자리 구분</li><li>precision ::= digit+</li><li>type ::= "b" | "c" | "d" | "e" | "E" | "f" | "F" | "g" | "G" | "n" | "o" | "s" | "x" | "X" | "%"</li><p>type이 주어지지 않은(None) 경우 문자열은 's', 정수는 'd', 실수는 'g'로 간주</p></ul><h2>class string.Template(template)</h2><p><strong>↓python</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="python">from string import Template
s = Template('$who likes $what')
s.substitute(who='tim', what='kung pao')    # 'tim likes kung pao'
Template('Give $who $100').substitute(dict(who='tim'))
# ValueError: Invalid placeholder in string: line 1, col 11
# $를 출력하고 싶을 땐 $$를 이용하면 된다
Template('$who likes $what').substitute(dict(who='tim'))        # KeyError: 'what'
Template('$who likes $what').safe_substitute(dict(who='tim'))   # 'tim likes $what'
</div><h2>Helper functions</h2><ul><li>string.capwords(s, sep=None)</li><p><strong>↓python</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="python">if sep is None:
    sep = ' '
sep.join([word.capitalize() for word in s.split(sep=sep)])
</div></ul></div><h1>re : 정규표현식</h1><div><h2>Regular Expression Syntax</h2><ul><li>str과 bytes모두 지원하지만, 찾는 패턴과 대상의 타입은 일치해야 한다</li><li>이스케이프하지 않는 raw string(r'')을 이용하면 편리하다</li><p>↓ 자바 정규표현식과 동일한 부분은 생략했음</p><li>[] : 문자 집합</li><ul><li>문자열 리터럴 표준 이스케이프 \a, \b, \f, \n, \r, \t, \u Since 3.3, \U Since 3.3, \v, \x, \\를 이용할 수 있다</li><li>\w, \S 등의 character class는 의미를 그대로 갖는다</li></ul><li class="marker">(?...) : 확장 표현</li><ul><li>(?#...) : 주석</li><li>(?aiLmsux)</li><p>'a', 'i', 'L', 'm', 's', 'u', 'x'중 하나 이상 사용. 각각 re.A, re.I, re.L, re.M, re.S, re.U, re.X 플래그를 설정한다</p><li>(?aiLmsux-imsx:...) Since 3.7</li><p>'-' 이후의 옵션들은 관계된 플래그를 해제한다는 의미</p><li>(?P&lt;name>...)</li><p>Named capturing group. name은 Python 식별자 규칙을 따라야 한다</p><li>(?P=name) : Named capturing group에 대한 backreference</li><li>(?&lt;=...)</li><p>Positive lookbehind. (...)이 매칭하는 문자열은 고정 길이여야 한다. group 참조 가능(Since 3.5)</p><li>(?&lt;!...)</li><p>Negative lookbehind. (...)이 매칭하는 문자열은 고정 길이여야 한다</p><li>(?(id/name)yes-pattern|no-pattern)</li><p>id or name의 그룹이 매칭되면 yes-pattern을, 아니면 no-pattern을 매칭. no-pattern은 없어도 된다</p></ul><li>\number # 해당 순번의 그룹에 대한 backreference. 그룹 번호는 [1, 99]</li><li>\A ↔ \Z # 문자열 시작 경계 매칭</li><li>\b ↔ \B # Word의 시작 또는 끝 경계 매칭. \w와 \W 사이의 경계로 정의된다</li><li>\d ↔ \D # 십진 숫자 매칭. 바이트 패턴에서는 [0-9]만 매칭</li><li>\s ↔ \S # 공백 문자 매칭. 바이트 패턴에서는 [ \t\n\r\f\v]만 매칭</li><li>\w ↔ \W # Word 문자 매칭. 바이트 패턴에서는 [a-zA-Z0-9_]만 매칭</li><li>Since 3.3 # \uXXXX, \UXXXX 가능</li><li>Since 3.8 # \N{name} 가능</li></ul><h2>Module Contents</h2><ul><li>Since 3.6 # Flag 상수들은 이제 RegexFlag(enum.IntFlag)의 인스턴스다</li><li>re.compile(pattern, flags=0)</li><ul><li>re.I, re.IGNORECASE</li><li>re.M, re.MULTILINE</li><li>re.S, re.DOTALL # '.'이 newline 문자 포함하여 매칭</li><li>re.X, re.VERBOSE # 주석을 달아 이해하기 쉬운 패턴 작성 가능</li><li>re.A, re.ASCII # 유니코드 패턴에서 \w, \W, \b, \B, \d, \D, \s, \S가 아스키코드만 매칭</li><li>re.DEBUG # 디버그 정보 출력</li></ul></ul><p><strong>↓python</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="python">re.search(pattern, string, flags=0)
    # 처음 매칭되는 부분 문자열에 대해 match 객체 반환. 없으면 None

re.match(pattern, string, flags=0)
    # 문자열 시작 위치에서 매칭되면 match 객체 반환. 없으면 None
re.fullmatch(pattern, string, flags=0)
    # Since 3.4 문자열 전체가 매칭되면 match 객체 반환. 없으면 None

re.split(pattern, string, maxsplit=0, flags=0)
    # 매칭된 패턴들로 분리. pattern에 그룹이 있으면 매칭된 문자열들도 결과에 포함된다. 결과의 빈 문자열에 유의
    re.split(r'(.*)', '')

re.findall(pattern, string, flags=0)
    # 문자열을 좌에서 우로 스캔하며 매칭된, 겹치지 않는 부분 문자열들을 리스트로 반환한다. 패턴에 그룹이 있는 경우 튜플로 표현된다
re.finditer(pattern, string, flags=0)
    # findall과 동일한 방식으로 매칭하면서 match 객체를 하나씩 yield

re.sub(pattern, repl, string, count=0, flags=0)
    # string에서 pattern에 매칭된, 겹치지 않는 부분 문자열들을 repl로 변경하여 반환. repl은 문자열이거나 함수일 수 있다
    # 문자열의 경우 backreference, \g&lt;name>, \g&lt;number> 가능. 함수의 경우 match 객체 하나를 먹고 문자열을 반환
re.subn(pattern, repl, string, count=0, flags=0)
    # re.sub()와 같은 작업을 하고, (new_string, number_of_subs_made) 반환

re.escape(pattern)
    # 패턴 문자열을 이스케이프. 이 결과를 패턴으로 이용하면 단 하나의 문자열만 매칭된다

re.purge()
    # RE 캐시 삭제
</div><h2>Regular Expression Objects</h2><p>컴파일된 RE 객체는 아래의 메서드와 속성을 지원한다. 각 메서드는 re 모듈의 함수와 유사하다</p><p><strong>↓python</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="python">regex.search(string[, pos[, endpos]])
    # pos가 지정되더라도 '^'는 실제 문자열 시작에만 매칭된다
    # endpos가 지정된 호출과 rx.search(string[:endpos], pos)는 동등하다

regex.match(string[, pos[, endpos]])
regex.fullmatch(string[, pos[, endpos]])
    # Since 3.4

regex.split(string, maxsplit=0)

regex.findall(string[, pos[, endpos]])
regex.finditer(string[, pos[, endpos]])

regex.sub(repl, string, count=0)
regex.subn(repl, string, count=0)

regex.flags
    # compile()에서 전달받은 플래그들과 (?...) 인라인 플래그들

regex.groups
    # 패턴 내부 capturing group 수

regex.groupindex
    # (?P&lt;name>)로 정의된 symbolic group 이름으로부터 그룹 숫자로의 dictionary 매핑

regex.pattern
    # 패턴 문자열

# Since 3.7 컴파일된 정규표현식 객체는 원자적이다
copy.copy()
copy.deepcopy()
</div><h2>Match Objects</h2><p>매칭이 없다면 None을 반환하므로, match 객체는 항상 True로 간주된다</p><p><strong>↓python</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="python">match.expand(template)
    # sub() 메서드가 하듯이, template 내부의 \ 대체 문자열을 알맞게 변경한다. \1, \g&lt;1>, \g&lt;name>와 같은 backreference들은 각각 연관된 그룹의 내용으로 대체된다

match.group([group1, ...])
    # 매칭된 그룹(들)을 반환한다. 여러 번 매칭된 경우 마지막 문자열이 반환된다. 지정되지 않은 경우 group1은 0(전체 매칭 문자열). (?P&lt;name>...) 그룹이 패턴에 존재하면 groupN 인자로 문자열도 가능

match.__getitem__(g)
    # Since 3.6, == m.group(g). m[0], m[1], ...

match.groups(default=None)
    # 각 그룹들의 매칭 문자열(없으면 default)들을 튜플로 반환한다

match.groupdict(default=None)
    # groups()를 dictoinary로 표현

match.start([group])
    # 그룹 시작 인덱스
match.end([group])
    # 그룹 종료 인덱스

match.span([group])
    # (m.start(group), m.end(group)) 반환

match.pos
    # search(), match()에서 전달받은 탐색 시작 위치
match.endpos
    # search(), match()에서 전달받은 탐색 종료 위치
match.string
    # match(), search()에서 전달받은 탐색 대상 문자열

match.lastindex
    # 마지막으로 매칭된 그룹 index. 없으면 None
match.lastgroup
    # 마지막으로 매칭된 그룹 이름. 없으면 None
match.re
    # RE 객체
</div></div><h1>textwrap : 텍스트 정돈</h1><p><strong>↓python</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="python">textwrap.wrap(text, width=70, **kwargs)
    # text의 모든 라인이 최대 width 길이가 되도록 조정한다. 라인들의 리스트를 반환한다. kwargs는 TextWrapper 속성 참고

textwrap.fill(text, width=70, **kwargs)
    # "\n".join(wrap(text, width, kwargs))와 동일하다

textwrap.shorten(text, width, **kwargs)
    # Since 3.4, text의 모든 공백들을 단일 스페이스로 변경하고, width길이에 맞게 자른다
    # width를 넘는 경우, 자른 자리에 placeholder를 넣은 길이가 width가 된다

textwrap.dedent(text)
    # text 각 라인이 공통 공백으로 시작되는 경우, 이를 제거한다. ''', """리터럴 정렬에 유용

textwrap.indent(text, prefix, predicate=None)
    # Since 3.3, 공백 이외의 문자를 포함한 모든 라인 앞에 prefix를 붙인다. predicate 함수는 각 라인을 인자로 받아 prefix를 붙일지 여부를 반환한다</div><div><h2>class textwrap.TextWrapper(**kwargs)</h2><p><strong>↓python</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="python">width(default 70)
    # 라인 최대 길아

# Since 3.3, \t를 몇 개의 ' '로 교체할 지
expand_tabs(default True)
tabsize(default 8)

replace_whitespace(default True)
    # \t 교체 후, wrap() 수행 전에 \s를 ' '로 교체

drop_whitespace(default True)
    # wrap() 수행 후, indent() 수행 전에 각 라인을 trim; 단 문단 첫 공백은 예외

initial_indent(default '')
    # 문단 첫째 줄 앞에 삽입

subsequent_indent(default '')
    # 문단 둘째 줄부터 앞에 삽입

break_long_words(default True)
    # False면 width보다 큰 단어는 그대로 남는다

max_lines(default None)
    # Since 3.4

placeholder(default '[...]')
    # Since 3.4

wrap(text)
fill(text)

</div></div><h1>unicodedata : 유니코드 database 표준</h1><p><strong>↓python</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="python">unicodedata.lookup(name)
    # 유니코드 이름에 해당하는 문자 반환. 없으면 KeyError
    # ↔ name(chr[, default])

unicodedata.decimal(chr[, default])
    # 문자에 해당하는 integer 반환
unicodedata.digit(chr[, default])
    # 문자에 해당하는 integer 반환
unicodedata.numeric(chr[, default])
    # 문자에 해당하는 float 반환

unicodedata.category(chr)
unicodedata.bidirectional(chr)
unicodedata.mirrored(chr) # ...

unicodedata.normalize(form, unistr)
unicodedata.is_normalized
    # Since 3.8</div><div><h2>유니코드 정규화</h2><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="https://ko.wikipedia.org/wiki/%EC%9C%A0%EB%8B%88%EC%BD%94%EB%93%9C_%EC%A0%95%EA%B7%9C%ED%99%94">참고 자료</a><ul><li>NFC : 코드 포인트를 조합해서 가장 짧은 동일 문자열 생성; Normalization Form: Composition</li><li>NFD : 조합된 문자를 기본 문자와 결합 문자로 분리; Normalization Form: Decomposition</li><p><strong>↓python</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="python"># 출처 : https://github.com/AllenDowney/fluent-python-notebooks/blob/master/04-text-byte/sanitize.py
import unicodedata
import string
def shave_marks(txt):
    '''라틴 기반 문자에서 발음 구별 기호 제거'''
    norm_txt = unicodedata.normalize('NFD', txt)
    latin_base = False
    keepers = []
    for c in norm_txt:
        if unicodedata.combining(c) and latin_base:
            continue
        keepers.append(c)
        if not unicodedata.combining(c):
            latin_base = c in string.ascii_letters
    return unicodedata.normalize('NFC', ''.join(keepers))</div><li>NFKC : Normalization Form: Compatibility (K) Composition</li><li>NFKD : Normalization Form: Compatibility (K) Decomposition</li><p>호환 분해 예 : ½(U+00BD) → '1/2', 마이크로(U+00B5) → 뮤(U+03BC)</p></ul></div><h1>struct : 이진 데이터 패킹/언패킹</h1><p>struct는 bytes 객체로 표현된 C 구조체와 Python 값 사이의 변환을 지원한다</p><p><strong>↓python</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="python">struct.pack(fmt, v1, v2, ...)
    # 포맷 문자열 fmt에 따라 v1, v2, ... 들을 포장한 bytes 객체 반환
struct.pack_into(fmt, buffer, offset, v1, v2, ...)
    # pack의 결과를 쓰기 가능한 buffer의 offset 위치에 쓴다

struct.unpack(fmt, buffer)
    # 포맷 문자열 fmt에 따라 포장된 buffer를 풀어 값의 튜플로 반환
struct.unpack_from(fmt, buffer, offset=0)
struct.iter_unpack(fmt, buffer
    # Since 3.4, unpack 순회하는 iterator 반환. buffer 크기는 반드시 fmt의 정수배 == calcsize(fmt)

struct.calcsize(fmt)
    # format 표현에 필요한 바이트 크기</div><div><h2>Format String</h2><li>Byte Order, Size, and Alignment</li><table><tr><th>Char</th><th>Byte order</th><th>Size</th><th>Alignment</th></tr><tr><td>@(default)</td><td>native</td><td>native</td><td>native</td></tr><tr><td>=</td><td>native</td><td>standard</td><td>none</td></tr><tr><td>&lt;</td><td>little-endian</td><td>standard</td><td>none</td></tr><tr><td>></td><td>big-endian</td><td>standard</td><td>none</td></tr><tr><td>!</td><td>network(=big-endian)</td><td>standard</td><td>none</td></tr></table><ul><li>Native byte order : 호스트 시스템으로 결정</li><li>Native size, alignment : C 컴파일러의 sizeof로 결정</li><p>정렬을 위해 패딩 바이트(0)들이 첨가될 수 있다</p></ul><li>Format Character</li><table><tr><th>Char</th><th>C type</th><th>Python type</th><th>Standard size</th></tr><tr><td>x</td><td>pad byte</td><td>no value</td><td></td></tr><tr><td>c</td><td>char</td><td>bytes of length 1</td><td>1</td></tr><tr><td>b</td><td>signed char</td><td>integer</td><td>1</td></tr><tr><td>B</td><td>unsigned char</td><td>integer</td><td>1</td></tr><tr><td>?</td><td>_Bool</td><td>bool</td><td>1</td></tr><tr><td>h</td><td>short</td><td>integer</td><td>2</td></tr><tr><td>H</td><td>unsigned short</td><td>integer</td><td>2</td></tr><tr><td>i</td><td>int</td><td>integer</td><td>4</td></tr><tr><td>I</td><td>unsigned int</td><td>integer</td><td>4</td></tr><tr><td>l</td><td>long</td><td>integer</td><td>4</td></tr><tr><td>L</td><td>unsigned long</td><td>integer</td><td>4</td></tr><tr><td>q</td><td>long long</td><td>integer</td><td>8</td></tr><tr><td>Q</td><td>unsigned long long</td><td>integer</td><td>8</td></tr><tr><td>n Since 3.3</td><td>ssize_t</td><td>integer</td><td>@에서만 가능</td></tr><tr><td>N Since 3.3</td><td>size_t</td><td>integer</td><td>@에서만 가능</td></tr><tr><td>e Since 3.6</td><td>반배 정밀도 부동소수</td><td>float</td><td>2</td></tr><tr><td>f</td><td>float</td><td>float</td><td>4</td></tr><tr><td>d</td><td>double</td><td>float</td><td>8</td></tr><tr><td>s</td><td>char[]</td><td>bytes</td><td></td></tr><tr><td>p</td><td>char[]</td><td>bytes</td><td></td></tr><tr><td>P</td><td>void*</td><td>integer</td><td>@,=에서만 가능</td></tr></table><ul><li>포맷 문자 앞에 정수가 오면 반복을 의미한다. 예. '4h'는 'hhhh'와 동일하다</li><li>포맷 문자 사이의 공백은 무시한다. 단, 반복을 나타내는 정수와 포맷 문자 사이에는 공백이 허용되지 않는다</li><li>s의 경우 앞에 오는 정수는 반복이 아닌 바이트 크기다(없으면 1로 간주). 패킹 과정에서 크기를 맞추기 위해 문자열이 잘리거나 null 바이트가 포함될 수 있다. 0s는 빈 문자열 하나를 의미한다</li><li>p는 파스칼 문자열로, 첫 바이트는 문자열의 길이(~255)를 나타낸다</li></ul></div><div><h2>class struct.Struct(format)</h2><p>이 클래스 인스턴스를 생성하든, 모듈 함수를 호출하든 최근 사용된 포맷 문자열 일부는 캐시된다</p><p><strong>↓python</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="python">pack(v1, v2, ...)
pack_into(buffer, offset, v1, v2, ...)

unpack(buffer)
unpack_from(buffer, offset=0)

iter_unpack(buffer) # Since 3.4
format, size

</div></div><h1>datetime : 단순 시간 표현</h1><p><strong>↓python</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="python">datetime.MINYEAR == 1
datetime.MAXYEAR == 9999</div><div><h2>class datetime.date : year, month, day</h2><ul><li>class datetime.date(year, month, day)</li><p>인스턴스는 변경 불가능 + 해시 가능하다</p><li>클래스 메서드</li><p><strong>↓python</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="python">date.today()
    #date.fromtimestamp(time.time())와 동일
date.fromtimestamp(timestamp)
    # 1970 ~ 2038년 외의 경우 에러발생 가능
date.fromordinal(ordinal)
    # ordinal[1, date.max.toordinal()]. 1년 1월 ordinal == 1
date.fromisoformat(date_string)
    # Since 3.7, 'YYYY-MM-DD'
date.fromisocalendar(year, week, day)
    # Since 3.8</div><li>클래스 속성</li><p><strong>↓python</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="python">date.min == date(MINYEAR, 1, 1)
date.max == date(MAXYEAR, 12, 31)
date.resolution == timedelta(days=1)</div><li>인스턴스 속성(읽기 전용)</li><p><strong>↓python</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="python">year    # [MINYEAR, MAXYEAR]
month   # [1, 12]
day     # [1, 해당 연월의 일수]</div><li>지원 연산</li><p><strong>↓python</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="python">date2 = date1 + timedelta
date2 = date1 - timedelta
timedelta = date1 - date2
# 산술 비교</div><li>인스턴스 메서드</li><p><strong>↓python</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="python">replace(year=self.year, month=self.month, day=self.day)
timetuple()
    # time.struct_time을 반환한다
toordinal()
    # ordinal 반환
weekday()
    # 월요일(0) ~ 일요일(6)
isoweekday()
    # 월요일(1) ~ 일요일(7)
isocalendar()
    # (ISO year, ISO week number, ISO weekday) 튜플 반환
isoformat()
    # 'YYYY-MM-DD' 반환
__str__()
    # str(d) == d.isoformat()
__format__(format)
    # == strftime(format) : 문자열 format에 따라 변환</div></ul><h2>class datetime.time : hour, minute, second, microsecond, tzinfo</h2><ul><li>class datetime.time(hour=0, minute=0, second=0, microsecond=0, tzinfo=None, *, fold=0)</li><ul><li>인스턴스는 변경 불가능 + 해시 가능하다</li><li>fold Since 3.6 : 0 or 1</li><p>서머 타임이나 윤초 적용처럼, 특정 시각이 2가지로 해석되는 경우의 선후 관계를 나타낸다. 예를 들어 0은 서머 타임 적용 전 8시, 1은 서머 타임 적용 후 8시를 나타낼 수 있다</p></ul><li>클래스 메서드</li><ul><li>classmethod time.fromisoformat(time_string) Since 3.7</li><ul><li>HH[:MM[:SS[.fff[fff]]]][+HH:MM[:SS[.ffffff]]]</li><li>time.isoformat()의 역함수로 설계되었기에 모든 ISO 8601 포맷을 인식하지는 못한다</li></ul></ul><li>클래스 속성</li><p><strong>↓python</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="python">min == time(0, 0, 0, 0)
max == time(23, 59, 59, 999999)
resolution == timedelta(microseconds=1)</div><li>인스턴스 속성(읽기 전용)</li><p>hour, minute, second, microsecond, tzinfo, fold(의미는 ↑ 생성자 참고) Since 3.6</p><li>지원 연산 : 산술 비교</li><ul><li>naive한 객체는 동등 비교에서 True를 반환하지 않는다</li><li>Boolean 평가 시 항상 True로 간주된다; 3.5 이전에는 UTC 자정을 false로 간주했다</li></ul><li>인스턴스 메서드</li><ul><li>replace(hour=self.hour, minute=self.minute, second=self.second, microsecond=self.microsecond, tzinfo=self.tzinfo, *, fold=0)</li><li>time.isoformat(timespec='auto')</li><table><tr><td>Format</td><td>Case</td></tr><tr><td>HH:MM:SS.ffffff</td><td>microsecond > 0</td></tr><tr><td>HH:MM:SS</td><td>microsecond == 0</td></tr><tr><td>HH:MM:SS.ffffff+HH:MM[:SS[.ffffff]]</td><td>utcoffset() != None</td></tr><tr><td>HH:MM:SS+HH:MM[:SS[.ffffff]]</td><td>microsecond == 0 and utcoffset() != None</td></tr></table><table><tr><td>Format</td><td>timespec</td></tr><tr><td>'seconds' # microsecond == 0<br>'microseconds' # microsecond > 0</td><td>'auto'</td></tr><tr><td>HH</td><td>'hours'</td></tr><tr><td>HH:MM</td><td>'minutes'</td></tr><tr><td>HH:MM:SS</td><td>'seconds'</td></tr><tr><td>HH:MM:SS.sss</td><td>'milliseconds'</td></tr><tr><td>HH:MM:SS.ffffff</td><td>'microseconds'</td></tr></table></ul><p><strong>↓python</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="python">__str__() == isoformat()
strftime(format)
__format__(format) == strftime(format)</div></ul><h2>class datetime.datetime : date + time</h2><ul><li>datetime은 date를 상속</li><li>class datetime.datetime(year, month, day, hour=0, minute=0, second=0, microsecond=0, tzinfo=None, *, fold=0)</li><ul><li>인스턴스는 변경 불가능 + 해시 가능하다</li><li>fold Since 3.6 : 0 or 1</li><p>서머 타임이나 윤초 적용처럼, 특정 시각이 2가지로 해석되는 경우의 선후 관계를 나타낸다. 예를 들어 0은 서머 타임 적용 전 8시, 1은 서머 타임 적용 후 8시를 나타낼 수 있다</p></ul><li>클래스 메서드</li><p><strong>↓python</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="python">datetime.now(tz=None)
datetime.combine(date, time, tzinfo=self.tzinfo)
    # tzinfo Since 3.6 : 지정되지 않은 경우, time.tzinfo가 사용된다
datetime.fromisoformat(date_string) Since 3.7</div><ul><li>YYYY-MM-DD[*HH[:MM[:SS[.fff[fff]]]][+HH:MM[:SS[.ffffff]]]] // *는 임의 1글자</li><li>datetime.isoformat()의 역함수로 설계되었기에 모든 ISO 8601 포맷을 인식하지는 못한다</li></ul><p><strong>↓python</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="python">datetime.strptime(date_string, format)
    # == datetime(*(time.strptime(date_string, format)[0:6]))</div><li>클래스 속성</li><p><strong>↓python</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="python">min == datetime(MINYEAR, 1, 1, tzinfo=None)
max == datetime(MAXYEAR, 12, 31, 23, 59, 59, 999999, tzinfo=None)
resolution == timedelta(microseconds=1)</div><li>인스턴스 속성(읽기 전용)</li><p>year, month, day, hour, minute, second, microsecond, tzinfo, fold(의미는 ↑ 생성자 참고) Since 3.6</p><li>지원 연산</li><p><strong>↓python</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="python">datetime2 = datetime1 + timedelta
datetime2 = datetime1 - timedelta
timedelta = datetime1 - datetime2
# 산술비교</div><li>인스턴스 메서드</li><ul><li>tzinfo가 설정되지 않은 naive한 datetime이 UTC로 잘 작동하기 위해서는 timezone.utc로 설정해야 한다</li><li>date() + time, timetz</li><li>astimezone(tz=None)</li><p>동일한 UTC 시각을 다른 시간대로 변환하여 반환한다</p></ul></ul><h2>class datetime.timedelta : date, time, datetime 사이의 microsecond 차이</h2><ul><li>class datetime.timedelta(days=0, seconds=0, microseconds=0, milliseconds=0, minutes=0, hours=0, weeks=0)</li><li>차분 대상의 타임존 유무 여부는 timedelta 값에 영향을 끼치지 않는다</li><li>클래스 속성</li><p><strong>↓python</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="python">timedelta.min == timedelta(-999999999)
timedelta.max == timedelta(days=999999999, seconds=86399, microseconds=999999)
timedelta.resolution == timedelta(microseconds=1)</div><li>인스턴스 속성(읽기 전용)</li><p><strong>↓python</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="python">days         # [-999999999, 999999999]
seconds      # [0, 86400)
microseconds # [0, 1000000)</div><li>지원 연산</li><p><strong>↓python</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="python">t1 + t2
t1 - t2
t1 * num # round even
t1 / t2

t1 / num # round even
t1 // int
t1 // t2
t1 % t2

divmod(t1, t2)
+t1
-t1
abs(t)

str(t)
repr(t)
# 산술 비교
# 동등 비교</div><li>인스턴스 메서드</li><p><strong>↓python</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="python">timedelta.total_seconds()
    # Since 3.2, td / timedelta(seconds=1)과 동일</div></ul><h2>class datetime.tzinfo : 타임존 ABC</h2><ul><li>dt : datetime | time</li><li>utcoffset(dt)</li><ul><li>UTC와 현지 시각의 차이(timedelta) 반환</li><li>DST(daylight saving time) 값이 있다면 합산하여 반환함이 바람직하다</li><li>utcoffset()이 None을 반환하지 않으면 dst()도 그러해야 한다</li></ul><li>dst(dt)</li><p>timedelta로 반환. 모르면 None. 비활성화면 timedelta(0) 반환</p><li>tzname(dt)</li><li>fromutc(dt)</li><p>datetime.astimezone()에서 호출한다. 이때 dt.tzinfo == slef이고 dt의 시각은 UTC므로, 오차를 더해 반환(dt + dt.utcoffset())하면 된다</p></ul><h2>class datetime.timezone Since 3.2 : tzinfo 구현체</h2><ul><li>class datetime.timezone(offset, name=None)</li><ul><li>인스턴스는 변경 불가능 + 해시 가능하다</li><li>timezone 클래스는 tzinfo의 서브클래스</li><li>고정된 UTC offset을 표현하며, 변경 불가능하다</li></ul></ul><h2>strftime(), strptime() 사양</h2><table><tr><th>Directive</th><th>의미</th></tr><tr><td>%a</td><td>요일명 - 약어 - 로캐일 적용</td></tr><tr><td>%A</td><td>요일명 - 풀네임 - 로캐일 적용</td></tr><tr><td>%w</td><td>요일 - 0(일요일) ~ 6(토요일)</td></tr><tr><td>%d</td><td>일 - zero-pad : 01 ~ 31</td></tr><tr><td>%b</td><td>월 - 약어 - 로캐일 적용</td></tr><tr><td>%B</td><td>월 - 풀네임 - 로캐일 적용</td></tr><tr><td>%m</td><td>월 - zero-pad : 01 ~ 12</td></tr><tr><td>%y</td><td>년 - 세기 제외, zero-pad : 00 ~ 99</td></tr><tr><td>%Y</td><td>년 - 세기 포함, zero-pad : 0001 ~ 9999</td></tr><tr><td>%H</td><td>시(24h) - zero-pad : 00 ~ 23</td></tr><tr><td>%I</td><td>시(12h) - zero-pad : 01 ~ 12</td></tr><tr><td>%p</td><td>AM or PM - 로캐일 적용</td></tr><tr><td>%M</td><td>분 - zero-pad : 00 ~ 59</td></tr><tr><td>%S</td><td>초 - zero-pad : 00 ~ 59</td></tr><tr><td>%f</td><td>마이크로초 - zero-pad : 000000 ~ 999999</td></tr><tr><td>%z</td><td>UTC 차이 : +HHMM or -HHMM</td></tr><tr><td>%Z</td><td>Timezone 이름</td></tr><tr><td>%j</td><td>일 - 연중 n번째, zero-pad : 001 ~ 366</td></tr><tr><td>%U</td><td>주(일요일 기준) - 연중 n번째, zero-pad : 00 ~ 53</td></tr><tr><td>%W</td><td>주(월요일 기준) - 연중 n번째, zero-pad : 00 ~ 53</td></tr><tr><td>%c</td><td>날짜와 시각 표현 - 로캐일 적용</td></tr><tr><td>%x</td><td>날짜 표현 - 로캐일 적용</td></tr><tr><td>%X</td><td>시각 표현 - 로캐일 적용</td></tr><tr><td>%%</td><td>리터럴 '%'</td></tr><tr><td>%G</td><td>년 - 세기 포함, ISO 8601 : 0001 ~ 9999</td></tr><tr><td>%u</td><td>요일 - 1(월요일) ~ 7(일요일), ISO 8601</td></tr><tr><td>%V</td><td>주(월요일 기준) - 연중 n번째, ISO 8601 : 01 ~ 53<br>01번째 주는 1월 4일을 포함</td></tr></table></div><h1>calendar : 달력 연산</h1><div><h2>calendar</h2><ul><li>모듈 함수</li><p><strong>↓python</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="python">calendar.setfirstweekday(weekday) + firstweekday()
    # 0 = calendar.MONDAY ~ 6 = calendar.SUNDAY
calendar.isleap(year)
    # 윤년인지 여부 반환
calendar.leapdays(y1, y2)
    # [y1, y2) 중 윤년의 수 반환
calendar.weekday(year, month, day)
    # 0 ~ 6 반환. 1970년 이전은 부정확
calendar.weekheader(n)
    # 주의 요일명들을 n글자씩 자른 헤더를 반환
calendar.monthrange(year, month)
    # 해당 년월의 첫번째 요일(0~6)과 일수를 반환. 1970년 이전은 부정확
calendar.timegm(tuple)
    # calendar와 관계있지는 않다. time.gmtime()의 역함수로, time.gmtime()을 인자로 넘기면 POSIX 인코딩된 Unix timestamp 값이 반환된다</div><li>모듈 속성</li><p><strong>↓python</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="python">calendar.day_name
    # 현재 로캐일의 요일명 배열
calendar.day_abbr
    # 현재 로캐일의 축약 요일명 배열
calendar.month_name
    # 현재 로캐일의 월명 배열. 길이 13이며, 1부터 12까지 이용
calendar.month_abbr
    # 현재 로캐일의 축약 월명 배열. 길이 13이며, 1부터 12까지 이용</div></ul><h2>class calendar.Calendar</h2><ul><li>class calendar.Calendar(firstweekday=0)</li><p>월요일(0)이 첫번째. setfirstweekday()로 변경 가능</p><li>인스턴스 메서드</li><p><strong>↓python</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="python">iterweekdays()
     # 요일에 대한 iterator 반환
itermonthdates(year, month)
     # 해당 월의 1일과 말일을 포함하는 전체 주를 하루씩(datetime.date) 순회하는 iterator 반환
itermonthdays(year, month)
     # 해당 월의 1일과 말일을 포함하는 전체 주를 하루씩(day) 순회하는 iterator 반환. 해당 월에 포함되지 않는 날짜들은 0
itermonthdays2(year, month)
     # 해당 월의 1일과 말일을 포함하는 전체 주를 하루씩(day, weekday) 순회하는 iterator 반환. 해당 월에 포함되지 않는 day는 0
itermonthdays3(year, month) Since 3.7
     # 해당 월의 1일과 말일을 포함하는 전체 주를 하루씩(year, month, day) 순회하는 iterator 반환
itermonthdays4(year, month) Since 3.7
     # 해당 월의 1일과 말일을 포함하는 전체 주를 하루씩(year, month, day, weekday) 순회하는 iterator 반환
monthdatescalendar(year, month)
     # 해당 월의 1일과 말일을 포함하는 전체 주를 리스트로 반환. 리스트 각 요소는 datetime.date 7개를 갖는 리스트
monthdayscalendar(year, month)
     # 해당 월의 1일과 말일을 포함하는 전체 주를 리스트로 반환. 리스트 각 요소는 날짜 7개를 갖는 리스트. 해당 월에 포함되지 않는 날짜들은 0
monthdays2calendar(year, month)
     # 해당 월의 1일과 말일을 포함하는 전체 주를 리스트로 반환. 리스트 각 요소는 (day, weekday) 7개를 갖는 리스트. 해당 월에 포함되지 않는 day는 0
yeardatescalendar(year, width=3)
     # 가공하기 쉬운 형태로 1년을 반환한다. 예를 들어 yeardatescalendar(2017)은 4(=12/width) x 3(=width) x ? x 7의 리스트로 반환된다
     # 전체 12개월을 4행 3열로 표현한 것으로, 각 월은 ?개 주로 구성되고, 각 주는 7개의 datetime.date 객체 리스트로 구성된다
yeardayscalendar(year, width=3)
     # yeardatescalendar()와 비슷. 각 주는 날짜들의 리스트. 각 월에 포함되지 않는 날짜들은 0
yeardays2calendar(year, width=3)
     # yeardatescalendar()와 비슷. 각 주는 (day, weekday)의 리스트. 각 월에 포함되지 않는 day는 0</div></ul><h2>class calendar.TextCalendar</h2><ul><li>class calendar.TextCalendar(firstweekday=0)</li><p>calendar.Calendar를 상속한다</p><li>class calendar.LocaleTextCalendar(firstweekday=0, locale=None)</li><p>formatweekday(), formatmonthname()은 현재 로캐일을 지정된 로캐일로 잠시 변경한다. 이는 전체 프로세스가 공유하므로, 스레드-안전하지 않다</p><li>인스턴스 메서드</li><p><strong>↓python</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="python">formatmonth(theyear, themonth, w=0, l=0)
    # 해당 년월의 문자열 달력 반환. w는 각 일의 너비(가운데 정렬), l은 각 주의 라인 수
formatyear(theyear, w=2, l=1, c=6, m=3)
    # m열의 달력을 반환한다. w는 각 일의 너비(가운데 정렬), l은 각 주의 라인 수, c는 month column 사이의 공백 수</div></ul><h2>class calendar.HTMLCalendar</h2><ul><li>class calendar.HTMLCalendar(firstweekday=0)</li><p>calendar.Calendar를 상속한다</p><li>class calendar.LocaleHTMLCalendar(firstweekday=0, locale=None)</li><p>formatweekday(), formatmonthname()은 현재 로캐일을 지정된 로캐일로 잠시 변경한다. 이는 전체 프로세스가 공유하므로, 스레드-안전하지 않다</p><li>클래스 속성</li><ul><li>여러 클래스를 지정하기 위해 'mon day w3-blue'와 같은 할당 가능</li><li>cssclasses</li><p>각 요일에 추가되는 클래스. 기본값 ["mon", "tue", "wed", "thu", "fri", "sat", "sun"]</p><li>cssclass_noday Since 3.7</li><p>각 월의 시작과 끝에 존재할 수 있는 빈칸들에 추가되는 클래스. 기본값 'noday'</p><li>cssclasses_weekday_head Since 3.7</li><p>테이블 헤더 행에 사용할 요일 클래스. 기본값 cssclasses</p><li>cssclass_month_head Since 3.7</li><p>기본값 'month'</p><li>cssclass_month Since 3.7</li><p>각 월의 테이블에 추가될 클래스. 기본값 'month'</p><li>cssclass_year, cssclass_year_head Since 3.7</li><p>기본값 'year'</p></ul><li>인스턴스 메서드</li><ul><li>formatmonth(theyear, themonth, withyear=True)</li><p>해당 년월의 달력을 HTML table로 반환. withyear가 True면 헤더에 포함</p><li>formatyear(theyear, width=3)</li><p>해당 년의 달력을 HTML table로 반환. width는 각 행의 월 수</p><li>formatyearpage(theyear, width=3, css='calendar.css', encoding=None)</li></ul></ul></div><h1>collections : 컨테이너</h1><div><h2>class ChainMap(_collections_abc.MutableMapping) Since 3.3</h2><ul><li>class collections.ChainMap(*maps)</li><ul><li>여러 dict, 매핑을 한데 모아 갱신 가능한 view를 만든다</li><li>maps : 뷰 내부의 리스트로 저장된다. ─ self.maps = list(maps) or [{}]</li><li>__setitem__, __delitem__, popitem(), pop(), clear()는 self.maps[0]에만 적용된다</li></ul><li>maps : __getitem__에서 리스트 순서대로 탐색하며, 변경 가능하다</li><li>new_child(m=None)</li><p>x.new_child(m) == ChainMap(m if m != None else {}, *x.maps)</p><li>parents</li><p>x.super() == ChainMap(*x.maps[1:])</p></ul><h2>class Counter(dict) Since 3.1</h2><ul><li>class collections.Counter([iterable-or-mapping])</li><ul><li>def __init__(self, iterable=None, /, **kwds)</li><p>self.update(iterable, **kwds)</p><li>Counter는 없는 키에 대하여 KeyError를 발생하지 않고, 새로운 키를 추가하고 0을 반환한다</li></ul><li>elements()</li><p>각 원소들을 각 카운트만큼 반복하는 iterator를 반환한다</p><li>most_common([n])</li><p>가장 많은 n개의 원소들을 개수와 함께 반환한다</p><li>update([iterable-or-mapping]) ↔ subtract()</li><ul><li>('gallahad') # iterable 각 요소 1씩 카운트</li><li>({'red': 4, 'blue': 2}) # 각 value만큼 카운트</li><li>(cats=4, dogs=8) # 각 value만큼 카운트</li></ul></ul><h2>deque</h2><ul><li>class collections.deque([iterable[, maxlen]])</li><ul><li>iterable이 존재하면 좌→우 순서대로 append()</li><li>스레드-안전, 메모리 효율적인 O(1)에 근접한 기능을 제공</li><li>list도 비슷한 기능을 제공하나, 고정 길이 연산에 적합하며, 길이가 바뀌는 연산은 O(n) 메모리 이동이 발생</li><li>maxlen이 주어졌다면 추가적인 삽입은 반대쪽 원소의 제거와 동시에 일어난다. 최근 n개만 관심 있는 경우 등에 유용</li></ul><li>삽입</li><ul><li>append(x) + appendleft</li><li>extend(iterable) + extendleft</li><li>insert(i, x) Since 3.5</li></ul><li>삭제</li><ul><li>clear()</li><li>pop() + popleft</li><li>remove(value)</li></ul><li>copy() Since 3.5 : 얕은 복사</li><li>count(x) Since 3.2</li><li>index(x[, start[, stop]]) Since 3.5</li><li>reverse() Since 3.2 : 제자리에서 순서를 변경하고 None 반환</li><li>rotate(n=1) : n번 우로 이동(d.appendleft(d.pop())). 음수면 좌로 이동</li><li>maxlen Since 3.1 : 없으면 None</li><p>이외에 iteration, pickling(Python 객체 직렬화), len(d), reversed(d), copy.copy(d), copy.deepcopy(d), in 연산자, index 접근(느림) 지원</p><li>Since 3.5 : __add__(), __mul__(), __imul__() 지원</li></ul><h2>defaultdict</h2><ul><li>class collections.defaultdict([default_factory[, ...]])</li><ul><li>dict을 상속한다</li><li>무인자 함수 default_factory(기본값 None)로 기본값을 제공한다</li><p>예. 기본값으로 리스트 사용 → defaultdict(list)</p><li>나머지 인자는 dict의 생성자에서 받아들이는 것과 동일하다</li></ul><li>__missing__(key)</li><p>default_factory가 None이면 KeyError, 아니면 default_factory 호출</p><li>default_factory</li></ul><h2>namedtuple</h2><ul><li>collections.namedtuple(typename, field_names, *, rename=False, defaults=None, module=None)</li><ul><li>이름이 typename인 tuple의 서브클래스를 반환. 인스턴스들은 유용한 docstring과 __repr__()을 갖는다</li><li>filed_names</li><p>_fields 속성. 문자열의 시퀀스거나, 'x y'또는 'x, y'처럼 분리한 단일 문자열일 수 있다</p><li>rename Since 3.1</li><p>True면 유효하지 않은 필드명은 '_1'처럼 인덱스 이름으로 설정된다</p><li>defaults Since 3.7</li><p>_field_defaults 속성. None 아니면 iterable을 제공. 기본값의 수는 필드보다 적어도 되지만, 기본값을 갖는 필드들은 우측부터임에 유의</p><li>module Since 3.6</li><p>__module__ 속성</p></ul><li>classmethod somenamedtuple._make(iterable)</li><li>somenamedtuple._asdict() : OrderedDict 반환</li><li>somenamedtuple._replace(**kwargs)</li><p>값을 변경한 새 튜플 반환</p><li>getattr(somenamedtuple, 'attr_name') 가능</li><li>somenamedtuple(**somedict) 가능</li><li>class Sub(somenamedtuple): 가능</li><li>Since 3.5 : 생성된 클래스의 __doc__ 속성 쓰기 가능</li></ul><h2>class OrderedDict(dict) Since 3.1</h2><ul><li>class collections.OrderedDict([items])</li><li>popitem(last=True)</li><li>move_to_end(key, last=True) Since 3.2</li><p>last=True면 우측 끝으로, 아니면 왼쪽 끝으로</p><li>OrderedDict 객체끼리의 비교는 순서가 중요하지만, 다른 Mapping 객체와의 비교에서는 순서 상관없다</li><li>Since 3.5 : OrderedDict의 items, keys, values view들이 reversed() 지원</li></ul><h2>class UserDict(_collections_abc.MutableMapping)</h2><p>dict를 상속하기 쉽게 만든 래퍼 클래스. self.data에 실제 dict가 존재</p><h2>class UserList(_collections_abc.MutableSequence)</h2><p>list를 상속하기 쉽게 만든 래퍼 클래스. self.data에 실제 list가 존재</p><h2>class UserString(_collections_abc.Sequence)</h2><p>str을 상속하기 쉽게 만든 래퍼 클래스. self.data에 실제 str이 존재</p></div><h1>collections.abc : 컨테이너 ABC</h1><table><tr><th>ABC</th><th>상속</th><th>Abstract Methods</th><th>Mixin Methods(재정의 안 해도 괜찮)</th></tr><tr><td>Container</td><td></td><td><span class="hover-content" template-id="template-python-collections-abc-contains">__contains__</span></td><td></td></tr><tr><td>Hashable</td><td></td><td><span class="hover-content" template-id="template-python-collections-abc-hash">__hash__</span></td><td></td></tr><tr><td><span class="hover-content" template-id="template-python-collections-abc-iterable">Iterable</span></td><td></td><td><span class="hover-content" template-id="template-python-collections-abc-iter">__iter__</span></td><td></td></tr><tr><td>Iterator</td><td>Iterable</td><td><span class="hover-content" template-id="template-python-collections-abc-next">__next__</span></td><td><span class="hover-content" template-id="template-python-collections-abc-iter">__iter__</span></td></tr><tr><td>Reversible</td><td>Iterable</td><td><span class="hover-content" template-id="template-python-collections-abc-reversed">__reversed__</span></td><td></td></tr><tr><td>Generator</td><td>Iterator</td><td><span class="hover-content" template-id="template-python-collections-abc-send">send</span>,<span class="hover-content" template-id="template-python-collections-abc-throw">throw</span></td><td><span class="hover-content" template-id="template-python-collections-abc-close">close</span>,<span class="hover-content" template-id="template-python-collections-abc-iter">__iter__</span>,<span class="hover-content" template-id="template-python-collections-abc-next">__next__</span></td></tr><tr><td>Sized</td><td></td><td><span class="hover-content" template-id="template-python-collections-abc-len">__len__</span></td><td></td></tr><tr><td>Callable</td><td></td><td><span class="hover-content" template-id="template-python-collections-abc-call">__call__</span></td><td></td></tr><tr><td>Collection Since 3.6</td><td>Sized, Iterable, Container</td><td><span class="hover-content" template-id="template-python-collections-abc-contains">__contains__</span>,<span class="hover-content" template-id="template-python-collections-abc-iter">__iter__</span>,<span class="hover-content" template-id="template-python-collections-abc-len">__len__</span></td><td></td></tr><tr><td>Sequence</td><td>Reversible, Collection</td><td><span class="hover-content" template-id="template-python-collections-abc-getitem">__getitem__</span>,<span class="hover-content" template-id="template-python-collections-abc-len">__len__</span></td><td><span class="hover-content" template-id="template-python-collections-abc-contains">__contains__</span>,<span class="hover-content" template-id="template-python-collections-abc-iter">__iter__</span>,<span class="hover-content" template-id="template-python-collections-abc-reversed">__reversed__</span>, index, count</td></tr><tr><td>MutableSequence</td><td>Sequence</td><td><span class="hover-content" template-id="template-python-collections-abc-getitem">__getitem__</span>,<span class="hover-content" template-id="template-python-collections-abc-setitem">__setitem__</span>,<span class="hover-content" template-id="template-python-collections-abc-delitem">__delitem__</span>,<span class="hover-content" template-id="template-python-collections-abc-len">__len__</span>, insert</td><td>Sequence 상속 메서드, append, reverse, extend, pop, remove, and __iadd__</td></tr><tr><td>ByteString</td><td>Sequence</td><td><span class="hover-content" template-id="template-python-collections-abc-getitem">__getitem__</span>,<span class="hover-content" template-id="template-python-collections-abc-len">__len__</span></td><td>Sequence 상속 메서드</td></tr><tr><td>Set</td><td>Collection</td><td><span class="hover-content" template-id="template-python-collections-abc-contains">__contains__</span>,<span class="hover-content" template-id="template-python-collections-abc-iter">__iter__</span>,<span class="hover-content" template-id="template-python-collections-abc-len">__len__</span></td><td>__le__, __lt__, __eq__,__ne__, __gt__, __ge__,__and__, __or__, __sub__, __xor__, isdisjoint</td></tr><tr><td>MutableSet</td><td>Set</td><td><span class="hover-content" template-id="template-python-collections-abc-contains">__contains__</span>,<span class="hover-content" template-id="template-python-collections-abc-iter">__iter__</span>,<span class="hover-content" template-id="template-python-collections-abc-len">__len__</span>, add, discard</td><td>Set 상속 메서드, clear, pop, remove,__ior__, __iand__, __ixor__, __isub__</td></tr><tr><td>Mapping</td><td>Collection</td><td><span class="hover-content" template-id="template-python-collections-abc-getitem">__getitem__</span>,<span class="hover-content" template-id="template-python-collections-abc-iter">__iter__</span>,<span class="hover-content" template-id="template-python-collections-abc-len">__len__</span></td><td><span class="hover-content" template-id="template-python-collections-abc-contains">__contains__</span>, keys, items,values, get, __eq__, __ne__</td></tr><tr><td>MutableMapping</td><td>Mapping</td><td><span class="hover-content" template-id="template-python-collections-abc-getitem">__getitem__</span>,<span class="hover-content" template-id="template-python-collections-abc-setitem">__setitem__</span>,<span class="hover-content" template-id="template-python-collections-abc-delitem">__delitem__</span>,<span class="hover-content" template-id="template-python-collections-abc-iter">__iter__</span>,<span class="hover-content" template-id="template-python-collections-abc-len">__len__</span></td><td>Mapping 상속 메서드, pop, popitem, clear, update, setdefault</td></tr><tr><td>MappingView</td><td>Sized</td><td></td><td><span class="hover-content" template-id="template-python-collections-abc-len">__len__</span></td></tr><tr><td>ItemsView</td><td>MappingView, Set</td><td></td><td><span class="hover-content" template-id="template-python-collections-abc-contains">__contains__</span>,<span class="hover-content" template-id="template-python-collections-abc-iter">__iter__</span></td></tr><tr><td>KeysView</td><td>MappingView, Set</td><td></td><td><span class="hover-content" template-id="template-python-collections-abc-contains">__contains__</span>,<span class="hover-content" template-id="template-python-collections-abc-iter">__iter__</span></td></tr><tr><td>ValuesView</td><td>MappingView, Collection</td><td></td><td><span class="hover-content" template-id="template-python-collections-abc-contains">__contains__</span>,<span class="hover-content" template-id="template-python-collections-abc-iter">__iter__</span></td></tr><tr><td>Awaitable</td><td></td><td>__await__</td><td></td></tr><tr><td>Coroutine</td><td>Awaitable</td><td>send, throw</td><td>close</td></tr><tr><td>AsyncIterable</td><td></td><td>__aiter__</td><td></td></tr><tr><td>AsyncIterator</td><td>AsyncIterable</td><td>__anext__</td><td>__aiter__</td></tr><tr><td>AsyncGenerator</td><td>AsyncIterator</td><td>asend, athrow</td><td>aclose, __aiter__, __anext__</td></tr></table><p>Set, MutableSet 믹스인 사용 시 유의사항</p><ol><li>몇몇 함수들은 iterable로부터 새로운 집합을 만들 필요가 있다. 이에 ClassName(iterable) 또는 @classmethod _from_iterable()이 필요</li><li>집합 비교 연산을 재정의하려는 경우, __le__(), __ge__()만 재정의하면 된다</li><li>Set 믹스인은 집합에 대한 해시를 반환하는 _hash()를 기본 제공한다. 만약 집합이 해시-가능하고 불변하다면 Hashable도 상속하여 __hash__ = Set._hash 설정하면 된다</li></ol><div class="w3-container w3-leftbar w3-border-green w3-white hover-template" id="template-python-collections-abc-contains">object.__contains__(self, item) : item을 포함하는지 여부</div><div class="w3-container w3-leftbar w3-border-green w3-white hover-template" id="template-python-collections-abc-hash">object.__hash__(self) : 해시값(int)</div><div class="w3-container w3-leftbar w3-border-green w3-white hover-template" id="template-python-collections-abc-len">object.__len__(self) : 아이템 개수</div><div class="w3-container w3-leftbar w3-border-green w3-white hover-template" id="template-python-collections-abc-call">object.__call__(self[, args...])</div><div class="w3-container w3-leftbar w3-border-green w3-white hover-template" id="template-python-collections-abc-iterable"><ul><li>isinstance(obj, Iterable) : Iterable로 등록되었거나 __iter__()를 가지면 True</li><li>iter(obj) :<span class="hover-content" template-id="template-python-collections-abc-getitem">__getitem__</span>()으로 순회하는 클래스도 감지 가능. 순회 가능하지 않으면 예외 발생</li></ul></div><div class="w3-container w3-leftbar w3-border-green w3-white hover-template" id="template-python-collections-abc-iter">object.__iter__(self) : 컨테이너 순회를 위한 새 Iterator 인스턴스를 반환한다. Iterator 서브클래스는 self를 반환하면 된다</div><div class="w3-container w3-leftbar w3-border-green w3-white hover-template" id="template-python-collections-abc-reversed">object.__reversed__(self) : 반대 순서의 iterable 객체 반환</div><div class="w3-container w3-leftbar w3-border-green w3-white hover-template" id="template-python-collections-abc-next"><ul><li>iterator.__next__() : 다음 아이템 반환. 없으면 raise StopIteration</li><li>generator.__next__() : 제너레이터 함수 실행 시작/재개. yield문의 판정값은 항상 None. yield 없이 종료되면 자동으로 raise StopIteration</li><li>보통 __next__()는 직접 호출하기보다는 for 루프, 내장 함수 next()의 호출로 암시적으로 호출된다</li></ul></div><div class="w3-container w3-leftbar w3-border-green w3-white hover-template" id="template-python-collections-abc-send">generator.send(value) : 제너레이터 함수 실행 시작/재개<ul><li>send()로 제너레이터 함수를 최초 실행하는 경우 value는 반드시 None이어야 한다. ← 대기중인 yield문이 없기 때문</li><li>value는 yield문의 판정값이 된다</li><li>다음 yield 값은 send()의 리턴값이 된다</li></ul></div><div class="w3-container w3-leftbar w3-border-green w3-white hover-template" id="template-python-collections-abc-throw">generator.throw(type[, value[, traceback]])<ul><li>현재 대기중인 yield 문의 위치에서 예외를 던진다</li><li>예외를 잡은 다음의 yield값은 throw()의 리턴값이 된다</li><li>더 이상의 yield 없이 종료되면 자동으로 raise StopIteration</li><li>제너레이터에서 전달한 예외를 잡지 않거나 다른 예외를 던진 경우, 호출자에게 전달된다</li></ul></div><div class="w3-container w3-leftbar w3-border-green w3-white hover-template" id="template-python-collections-abc-close">generator.close()<ul><li>현재 대기중인 yield 문의 위치에서 GeneratorExit 예외를 던진다</li><li>예외를 잡고 종료하거나, 이미 종료됐거나, 예외를 잡지 않고 GeneratorExit를 던진 경우 close()는 종료된다</li><li>제너레이터가 값을 yield하는 경우, RuntimeError가 발생한다</li><li>제너레이터가 다른 예외를 던지는 경우, 호출자에게 전달된다</li></ul></div><div class="w3-container w3-leftbar w3-border-green w3-white hover-template" id="template-python-collections-abc-getitem">object.__getitem__(self, key)<ul><li>식 self[key] 평가 시 호출된다</li><li>Sequence 타입의 경우 key는 정수 또는 slice 인스턴스여야 한다</li><li>__getitem__()을 이용하는 믹스인들은 그 성능이 종속됨에 유의</li></ul></div><div class="w3-container w3-leftbar w3-border-green w3-white hover-template" id="template-python-collections-abc-setitem">object.__setitem__(self, key)<ul><li>self[key]로 대입 시 호출된다</li><li>유의사항은 __getitem__()과 동일</li><li>값의 추가/변경이 필요한 경우에만 구현함이 바람직하다</li></ul></div><div class="w3-container w3-leftbar w3-border-green w3-white hover-template" id="template-python-collections-abc-delitem">object.__delitem__(self, key)<ul><li>self[del] 삭제 시 호출된다</li><li>유의사항은 __getitem__()과 동일</li><li>값의 제거가 필요한 경우에만 구현함이 바람직하다</li></ul></div><h1>heapq : 우선순위 큐</h1><ul><li>부모 노드 &lt; 자식 노드인 힙을 이용한 큐</li><li>인덱스 접근 heap[i] 가능</li><p><strong>heapq 모듈은 명시적인 클래스를 제공하지 않음에 유의</strong> → 리스트 자체를 힙처럼 이용한다</p><li>우선순위 큐 구현 시 유의사항</li><ol><li>우선순위가 동일할 때, 힙에 들어온 순서가 영향을 끼치는 지 여부</li><p>예. 노드 속성에 삽입 순서를 추가</p><li>이미 삽입된 노드의 우선순위가 도중에 변경된 경우 위치를 어떻게 옮길 것인지</li><p>예. 기존 노드는 비활성화 처리하고, 새로 힙에 추가</p></ol></ul><p><strong>↓python</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="python">heapq.heapify(x)
    # 리스트 x를 힙으로 제자리(in-place) 변환
heapq.heappush(heap, item)
heapq.heappop(heap)
    # heap[0] 노드를 제거하고 반환한다
heapq.heappushpop(heap, item)
    # push 후 pop
heapq.heapreplace(heap, item)
    # pop 후 push
heapq.merge(*iterables, key=None, reverse=False)
    # 미리 오름차순 정렬된 여러 Iterable에 대해, 크기순으로 하나씩 순회하는 새 Iterable을 반환한다. reverse=True인 경우, 입력 Iterable들은 내림차순 정렬돼있어야 한다

heapq.nsmallest(n, iterable, key=None) == sorted(iterable, key=key)[:n]
heapq.nlargest(n, iterable, key=None) == sorted(iterable, key=key, reverseTrue)[:n]

</div><h1>bisect : 리스트 정렬 유지 삽입</h1><p>이분법을 이용하여, 리스트 정렬 순서를 유지한 채 삽입할 수 있도록 도와준다</p><p><strong>↓python</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="python">bisect.bisect_left(a, x, lo=0, hi=len(a))
    # x를 삽입하기 적절한 위치 i를 반환한다
    #    all(val &lt; x for val in a[lo:i]), all(val >= x for val in a[i:hi]) 모두 성립한다
    # a : 대상 리스트
    # x : 삽입할 값
    # lo, hi : 검색 구간

bisect.bisect_right(a, x, lo=0, hi=len(a))
    # all(val &lt;= x for val in a[lo:i]), all(val > x for val in a[i:hi])
    # == bisect.bisect

bisect.insort_left(a, x, lo=0; hi=len(a))
    # == a.insert(bisect.bisect_left(a, x, lo, hi), x)
bisect.insort_right(a, x, lo=0, hi=len(a))
    # == bisect.insort

</div><h1>array : 고효율 숫자 배열</h1><ul><li>list와 유사하게 동작하지만, 원소의 타입은 하나로 제한된다</li><li>배열 생성 시 타입을 지정한다</li></ul><table><tr><th>Code</th><th>C type</th><th>Python type</th><th>Size</th></tr><tr><td>'b'</td><td>signed char</td><td>int</td><td>1</td></tr><tr><td>'B'</td><td>unsigned char</td><td>int</td><td>1</td></tr><tr><td>'h'</td><td>signed short</td><td>int</td><td>2</td></tr><tr><td>'H'</td><td>unsigned short</td><td>int</td><td>2</td></tr><tr><td>'i'</td><td>signed int</td><td>int</td><td>2</td></tr><tr><td>'I'</td><td>unsigned int</td><td>int</td><td>2</td></tr><tr><td>'l'</td><td>signed long</td><td>int</td><td>4</td></tr><tr><td>'L'</td><td>unsigned long</td><td>int</td><td>4</td></tr><tr><td>'q'</td><td>signed long long</td><td>int</td><td>8</td></tr><tr><td>'Q'</td><td>unsigned long long</td><td>int</td><td>8</td></tr><tr><td>'f'</td><td>float</td><td>float</td><td>4</td></tr><tr><td>'d'</td><td>double</td><td>float</td><td>8</td></tr></table><div><h2>class array.array</h2><ul><li>class array.array(typecode[, initializer])</li><p>initializer : list, bytes-like object, iterable 중 하나를 보내면 fromlist(), frombytes() 등으로 초기화된다</p><li>모듈 속성</li><ol><li>array.typecodes</li><p>유효 타입 코드들로 구성된 문자열</p></ol><li>인스턴스 속성(읽기 전용)</li><ol><li>array.typecode</li><li>array.itemsize : 요소 하나의 바이트 크기</li></ol><li>인스턴스 메서드</li><p><strong>↓python</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="python">array.buffer_info()
    # (address, length) 반환. 반환된 값은 배열이 삭제되지 않고, 길이가 변경되지 않은 동안 유효
array.byteswap()
    # 배열 각 요소들의 바이트 순서를 뒤집는다. array.itemsize가 1, 2, 4, 8인 경우만 작동
array.extend(iterable)
    # 배열 끝에 순서대로 추가. 인자가 배열인 경우, 타입이 동일해야만 작동한다
array.fromfile(f, n)
    # ↔ tofile(f)
    # file 인스턴스 f로부터 n개의 machine value를 읽어 배열의 끝에 순서대로 추가. 요소가 n개보다 적은 경우 배열에 추가는 되지만 EOFError 발생
array.frombytes(s)
    # Since 3.2 ↔ tobytes()
    # 문자열을 machine value로 읽어 배열 끝에 순서대로 추가
array.fromlist(list) ↔ tolist()
    # list 전체 요소의 타입이 삽입 가능하다면, 순서대로 배열 끝에 추가
array.index(x)
array.count(x)
array.remove(x)
array.insert(i, x)
array.pop([i])
array.reverse()

</div></ul></div><h1>weakref : 약한 참조</h1><ul><li>직접적인 약한 참조 생성이 불가능한 list, dict 등의 내장 자료형은 상속함으로써 약한 참조 가능하게 만들 수 있다</li><li>CPython : tuple, int 등은 상속해도 약한 참조 불가능하다</li><li>referent ::= 약한 참조가 참조하는 객체</li></ul><div><h2>class weakref.ref</h2><ul><li>class weakref.ref(object[, callback])</li><ol><li>object에 대한 약한 참조를 반환한다</li><li>object가 무효하게 되면 약한 참조는 None을 반환한다</li><li>callback이 제공된 경우, object가 해제될 때 호출된다</li><li>동일 객체에 대해 여러 약한 참조가 만들어진 경우, callback은 최신 것부터 순서대로 호출된다</li><li>object가 해시 가능하면 약한 참조도 그러하다</li><p>object가 유효한 동안 약한 참조에 대해 hash()가 호출된 경우, 반환된 값은 object가 해제되도 유지된다</p><li>약한 참조 사이의 동등 비교가 가능하다</li><p>referent가 해제된 경우엔 두 약한 참조의 referent가 동일한 경우에만 True</p><li>이 클래스는 상속 가능하다</li></ol><li>__callback__ Since 3.4</li><p>읽기 전용 속성</p></ul><h2>class weakref.WeakKeyDictionary + WeakValueDictionary</h2><ul><li>class weakref.WeakKeyDictionary([dict])</li><ol><li>key를 약하게 참조하는 Mapping 클래스</li><li>key가 무효하게 되면 해당 entry는 제거된다</li><li>WeakKeyDictionary 순회 중 매핑 크기가 변경되는 경우 엔트리가 사라지는 마법이 발생할 수 있다</li></ol><li>WeakKeyDictionary.keyrefs()</li><li>WeakValueDictionary.valuerefs()</li></ul><h2>class weakref.WeakSet</h2><ul><li>class weakref.WeakSet([elements])</li><ol><li>원소를 약하게 참조하는 Set 클래스</li><li>원소가 무효하게 되면 집합에서 제거된다</li></ol></ul><h2>class weakref.WeakMethod Since 3.4</h2><ul><li>class weakref.WeakMethod(method)</li><ol><li>인스턴스 메서드를 위한 weakref.ref 서브클래스</li><li>반환된 약한 참조를 호출하면 method가 반환된다</li></ol></ul><h2>class weakref.finalize</h2><ul><li>class weakref.finalize(obj, func, *args, **kwargs)</li><ol><li>obj가 쓰레기 수집되면 호출될 소멸자를 반환한다</li><p>따라서 func, args, kwargs는 obj의 참조를 갖지 않아야 한다</p><li>소멸자는 단 한번만 호출 가능하며, 결과로 func(*args, **kwargs)를 반환한다. 그 외엔 None</li></ol><li>alive</li><p>소멸자의 유효 여부</p><li>__call__()</li><p>수동 호출. alive가 True면 False로 설정하고 func(*args, **kwargs) 반환. 그 외엔 None</p><li>detach()</li><p>alive가 True면 False로 설정하고 (obj, func, args, kwargs) 반환. 그 외엔 None</p><li>peek()</li><p>alive가 True면 (obj, func, args, kwargs) 반환. 그 외엔 None</p><li>atexit Since 3.4</li><p>쓰기 가능 boolean 속성. true인 경우 프로그램 정상 종료 시 호출된다</p></ul><h2>모듈 속성, 함수</h2><ul><li>weakref.proxy(object[, callback])</li><ol><li>object에 대한 프록시를 반환한다. callback은 weakref.ref의 것과 동일한 의미다</li><li>참조 시마다 object를 가져오는 weakref.ref와 다르게, 프록시는 그 자체로써 취급되며, 따라서 확장이 용이하다</li><li>object가 callable인지 여부에 따라 반환되는 프록시의 타입은 CallableProxyType, ProxyType 둘 중 하나가 된다</li></ol><li>weakref.getweakrefcount(object)</li><p>object에 대한 약한 참조, 프록시의 개수를 반환</p><li>weakref.getweakrefs(object)</li><p>object에 대한 약한 참조, 프록시들을 list로 반환</p><li>weakref.ReferenceType : 약한 참조 객체임을 나타내는 타입</li><li>weakref.ProxyType : Non callable 객체에 대한 프록시 객체임을 나타내는 타입</li><li>weakref.CallableProxyType : Callable 객체에 대한 프록시 객체임을 나타내는 타입</li><li>weakref.ProxyTypes : 가능한 모든 프록시 타입을 포함한 Sequence</li></ul></div><h1>types : 동적 타입 생성</h1><div><h2>Coroutine Utility Functions</h2><p>types.coroutine(gen_func) : generator 함수를 기반으로 한 coroutine 함수 반환</p></div><h1>copy</h1><ol><li>copy.copy(x) : 얕은 복사</li><li>copy.deepcopy(x[, memo])</li><p>memo 딕셔너리에 등록된 객체들은 복사 시 건너뛴다</p></ol><h1>enum</h1><ul><li>enum 클래스는 그 자체로 순회 가능하다</li><li>enum 클래스 멤버는 해시 가능하다</li></ul><ol><li>class enum.Enum : 베이스 클래스</li><p><strong>↓python</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="python">class RGB(enum.Enum):
    R = enum.auto()
    G = enum.auto()
    B = enum.auto()
print(RGB(2) == RGB.B)
print(RGB['B'] == RGB.B)
print(RGB.B.name == 'B')
print(RGB.B.value == 2)</div><ul><li>Enum 클래스 자체도 callable이다</li><p><strong>↓python</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="python">Animal = Enum('Animal', 'ANT BEE CAT DOG')
# 이렇게 생성한 enum 클래스의 모듈을 특정할 수 없는 경우, pickling/unpickling 불가</div></ul><li>class enum.IntEnum : int 상속</li><li>class enum.IntFlag Since 3.6 : int 상속 + 비트 연산 가능</li><li>class enum.Flag Since 3.6 : 비트 연산 가능</li><li>class enum.auto Since 3.6 : 자동 할당</li><p>auto의 동작은 _generate_next_value_(name, start, count, last_values)를 재정의하여 변경할 수 있다</p><li>enum.unique() : 일대일 대응 검증 클래스 데커레이터</li></ol><h1>math, cmath</h1><div><h2>math : 실함수</h2><table><tr><th>함수</th><th>기능</th></tr><tr><td>ceil(x)</td><td>x보다 작지 않은 최소 정수. 식[\lceil{x}\rceil]식</td></tr><tr><td>floor(x)</td><td>x보다 크지 않은 최대 정수. 식[\lfloor{x}\rfloor]식</td></tr><tr><td>trunc(x)</td><td>정수부 반환</td></tr><tr><td>modf(x)</td><td>x의 (소수부, 정수부) 반환</td></tr><tr><td>comb(n, k)</td><td>조합. 식[\begin{pmatrix}n \\ r\end{pmatrix}={n! \over r!(n-r)!}]식</td></tr><tr><td>perm(n, k=None)</td><td>순열. 식[{}_n P_{k}={n! \over (n-k)!}]식</td></tr><tr><td>copysign(x, y)</td><td>식[|x| {y \over |y|}]식</td></tr><tr><td>fabs(x)</td><td>|x|</td></tr><tr><td>factorial(x)</td><td>x가 음이 아닌 정수일 때만 x!</td></tr><tr><td>fmod(x, y)</td><td>C 라이브러리대로 동작<br>|x - n*y| &lt; |y|를 만족하는 정수 n을 찾고 그 나머지(부호는 x와 동일)를 반환</td></tr><tr><td>remainder(x, y) Since 3.7</td><td>x / y 값을 half-even으로 반올림한 정수 n에 대하여, x - n*y 반환. 정밀도는 IEEE-754</td></tr><tr><td>frexp(x)</td><td>식[x = m2^e]식를 만족하는 실수 m, 정수 e의 튜플 반환. x != 0이면 식[0.5 \le |m| &lt; 1]식</td></tr><tr><td>ldexp(x, i)</td><td>Inverse of frexp(), 식[x2^i]식</td></tr><tr><td>fsum(iterable)</td><td>정밀도는 IEEE-754, 반올림 모드는 half-even</td></tr><tr><td>prod(iterable, *, start=1) Since 3.8</td><td>iterable 모두 곱하여 반환</td></tr><tr><td>gcd(a, b) Since 3.5</td><td>0이 아닌 정수 a, b에 대해, 양의 최대공약수 반환</td></tr><tr><td>isclose(a, b, *, rel_tol=1e-09, abs_tol=0.0) Since 3.5</td><td>a, b가 충분히 가까운지 여부<br>rel_tol는 절대값이 더 큰쪽에 적용될 최대 허용 오차 비율</td></tr><tr><td>isfinite(x)</td><td>NaN, infinity가 아닌지 여부</td></tr><tr><td>isinf(x)</td><td>infinity인지 여부</td></tr><tr><td>isnan(x)</td><td>NaN인지 여부</td></tr><tr><td>exp(x)</td><td>식[e^x]식, math.e ** x보다 정확</td></tr><tr><td>expm1(x) Since 3.2</td><td>exp(x)-1보다 정확한 식[e^x-1]식</td></tr><tr><td>log(x[, base])</td><td>base 기본값은 e</td></tr><tr><td>log1p(x)</td><td>식[\operatorname{ln}(1+x)]식</td></tr><tr><td>log2(x) Since 3.3</td><td>log(x, 2)보다 정확한 식[\log_{2}x]식</td></tr><tr><td>log10(x)</td><td>log(x, 10)보다 정확한 식[\log_{10}x]식</td></tr><tr><td>pow(x, y)</td><td>정수 거듭제곱엔 **가 정확</td></tr><tr><td>sqrt(x)</td><td>식[\sqrt{x}]식</td></tr><tr><td>isqrt(x) Since 3.8</td><td>식[\lfloor \sqrt{n} \rfloor]식. 식[\lceil \sqrt{n} \rceil]식를 원한다면 1 + isqrt(n-1)</td></tr><tr><td>dist(p, q) Since 3.8</td><td>같은 차원의 두 점 p, q 사이의 거리 반환</td></tr><tr><td>sin(x), cos(x), tan(x), asin(x), acos(x), atan(x)</td><td>삼각함수 및 역삼각함수</td></tr><tr><td>atan2(y, x)</td><td>atan(y / x)</td></tr><tr><td>sinh(x), cosh(x), tanh(x), asinh(x), acosh(x), atanh(x)</td><td>쌍곡선함수 및 역쌍곡선함수</td></tr><tr><td>degrees(x)</td><td>라디안 x를 육십분법으로</td></tr><tr><td>radians(x)</td><td>육십분법 x를 라디안으로</td></tr><tr><td>hypot(*coordinates)</td><td>Euclidean norm; sqrt(sum(x**2 for x in coordinates))</td></tr><tr><td>이하 생략</td><td></td></tr></table><h2>cmath : 복소함수</h2><p>int, float, complex 및 __complex__() 소지 객체, __float__() 소지 객체들이 인자로 가능하다</p><table><tr><th>함수</th><th>기능</th></tr><tr><td>phase(x)</td><td>== atan2(x.imag, x.real)</td></tr><tr><td>polar(x)</td><td>== (abs(x), phase(x))</td></tr><tr><td>rect(r, phi)</td><td>polar의 역함수. == r * (math.cos(phi)) + math.sin(phi) * 1j</td></tr><tr><td>이하 생략</td><td></td></tr></table></div><h1>decimal : 정확한 10진수 연산</h1><ul><li>유효숫자 개념을 고려한다. 기본 유효숫자는 28자리며, 변경 가능하다. decimal.getcontext().prec = 999999</li><li>반올림 모드 : decimal.ROUND_DOWN, ROUND_05UP, ROUND_UP, ROUND_HALF_DOWN, ROUND_HALF_EVEN, ROUND_HALF_UP, ROUND_FLOOR, ROUND_CEILING</li><li>생성자에서는 유효숫자의 제한이 없으며, 따라서 반올림도 수행되지 않는다</li><li>(-7) % 4 == 1, Decimal(-7) % Decimal(4) == Decimal(-3)</li><li>-7 // 4 == -2, Decimal(-7) // Decimal(4) == Decimal(-1)</li></ul><div><h2>class decimal.Decimal</h2><ul><li>Decimal 인스턴스는 불변 객체다. 각 연산마다 새 Decimal 인스턴스가 생성된다</li><li>class decimal.Decimal(value="0", context=None)</li><p>문자열, 튜플(sign_number, tuple_of_digits, int_exponent)로도 생성 가능</p><li>인스턴스 메서드</li><ul><li>adjusted() : 최고 자리수(10^n)의 자리값(n)을 반환</li><li>as_integer_ratio() Since 3.6 : 기약분수의 (분자, 분모) 반환</li><li>as_tuple() : (sign, digits, exponent)</li><li>copy_abs(), copy_negate(), copy_sign(other, context=None)</li><li>quantize(exp, rounding=None, context=None)</li><p>Decimal('7.325').quantize(Decimal('.01'), rounding=ROUND_DOWN) == Decimal('7.32')</p><li>이하 생략</li></ul></ul></div><h1>random, secrets : 난수</h1><div><h2>random : 암호적으로 안전하지 않은 의사 난수 생성기</h2><ul><li>Bookkeeping functions</li><ul><li>seed(a=None, version=2) : 시드 설정. a를 지정하지 않은 경우 시스템 시각 사용</li><li>getrandbits(k) : k개 비트로 구성된 int 반환</li></ul><li>Functions for integers</li><ul><li>randrange(stop), randrange(start, stop[, step])</li><li>randint(a, b)</li></ul><li>Functions for sequences</li><ul><li>choice(seq)</li><li>choices(population, weights=None, *, cum_weights=None, k=1) Since 3.6</li><ul><li>weights : population 각 요소별 가중치</li><li>cum_weights : population 각 요소별 누적 가중치</li><li>k : 뽑을 요소 수. 복원 추출</li></ul><li>shuffle(x[, random])</li><p>x를 제자리에서 섞는다. random은 [0.0, 1.0)을 반환하는 무인자 함수</p><li>sample(population, k) : 비복원 추출</li></ul><li>Real-valued distributions</li><ul><li>random() : [0.0, 1.0)</li><li>uniform(a, b) : [a, b]</li><li>gauss(mu, sigma)</li><li>gammavariate(alpha, beta)</li><li>betavariable(alpha, beta)</li><li>이하 생략</li></ul></ul><h2>secrets Since 3.6 : 암호적으로 안전한 난수 생성기</h2><ul><li>randbits(k)</li><li>randbelow(n) : [0, n)</li><li>choice(sequence)</li><li>token_bytes([nbytes=None]), token_hex([nbytes=None]), token_urlsafe([nbytes=None])</li></ul></div><h1>statistics : 통계</h1><ul><li>별다른 표시가 없다면 각 함수들은 int, float, Decimal, Fraction 모두 인자로 지원</li><p>다른 타입들을 인자로 이용하려는 경우 map() 따위로 조정 필요</p><li>대표값</li><ul><li>mean(data) : 산술 평균. data는 Iterable</li><li>fmean(data) : 빠른 float 산술 평균. data는 Iterable</li><li>geometric_mean(data) Since 3.8 : 기하 평균. data는 Iterable</li><li>harmonic_mean(data) Since 3.6 : 조화 평균. data는 Iterable</li><li>median(data) : 중앙값. data는 Iterable</li><p><strong>↓python</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="python">median([1, 3, 5, 7]) == 4.0
median_low([1, 3, 5, 7]) == 3
median_high([1, 3, 5, 7]) == 5</div><li>median_grouped(data, interval=1)</li><p><strong>↓python</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="python">median = L + interval*(N/2 - CF)/F
# L = the lower limit of the median interval
# N = the total number of data points
# CF = the number of data points below the median interval
# F = the number of data points in the median interval</div><li>mode(data) : 최빈값. data는 이산하다고 가정되는 Iterable. data 요소의 타입은 제한되지 않는다</li><li>multimode(data) Since 3.8 : 최빈값 리스트 반환</li><li>quantiles(data, *, n=4, method='exclusive') Since 3.8</li><p>data를 n개 구간으로 나누어, 각 구간이 모두 같은 개수의 표본을 갖도록 하는 구분점들의 리스트를 반환한다</p></ul><li>분산</li><ul><li>pstdev(data, mu=None) : 표준편차</li><li>pvariance(data, mu=None) : 분산</li><li>stdev(data, xbar=None) : 표본표준편차</li><li>variance(data, xbar=None) : 표본분산</li></ul><h2>class statistics.NormalDist</h2><ul><li>statistics.NormalDist(mu=0.0, sigma=1.0)</li><li>classmethod from_samples(data)</li><li>이하 생략</li></ul></ul><h1>itertools</h1><ul><li>starmap(function, iterable)</li><p>(function(*args) for args in iterable)과 의미상 동일</p><li>accumulate(iterable[, func, *, initial=None]) Since 3.2</li><p>연산을 누적하여 최종 결과를 반환한다. 기본 연산은 +</p><li>chain(*iterables)</li><p>전체 iterables를 순서대로 순회하는 Iterator 반환</p><li>chain.from_iterable(iterable)</li><p>iterable은 Iterable로 구성된 Iterable. 기능은 chain()과 동일</p><li>tee(iterable, n=2)</li><p>iterable의 요소를 순회하는 n개의 독립적인 Iterator 반환</p><li>zip_longest(*iterables, fillvalue=None)</li><p>내장함수 zip()과 다르게 모든 iterables의 순회가 끝날때까지 순회. 값이 없는 경우 fillvalue 사용</p><li>combinations(iterable, r)</li><p>iterable 요소로 구성할 수 있는 크기 r의 조합(비복원 추출)을 순회하는 Iterator 반환. 실제 값이 같지만 위치가 다른 두 요소를 다르다고 간주함에 유의</p><li>combinations_with_replacement(iterable, r)</li><p>iterable 요소로 구성할 수 있는 크기 r의 조합(복원 추출)을 순회하는 Iterator 반환. 실제 값이 같지만 위치가 다른 두 요소를 다르다고 간주함에 유의</p><li>permutations(iterable, r=None)</li><p>iterable 요소로 구성할 수 있는 크기 r(기본값 len(iterable))의 순열(비복원 추출). 실제 값이 같지만 위치가 다른 두 요소를 다르다고 간주함에 유의</p><li>count(start=0, step=1)</li><p>step씩 증가하는 무한 등차수열</p><li>cycle(iterable)</li><p>iterable 요소를 무한히 반복하는 Iterator 반환</p><li>repeat(object[, times])</li><p>object를 times번 순회하는 Iterator 반환. times가 지정되지 않은 경우 무한 반복. 불필요한 동일 객체를 여러번 만들지 않게 해준다</p><li>product(*iterables, repeat=1)</li><p>순서쌍을 순회하는 Iterator 반환. 예를 들어 product(i1, i2) == ((x, y) for x in i1 for y in i2)</p><li>islice(iterable, stop)<br>islice(iterable, start, stop[, step])</li><ol><li>지정된 범위에 속하는 요소들만 순회하는 Iterator 반환</li><li>일반적인 슬라이스와 달리 음수 인덱싱을 지원하지 않는다</li><li>stop이 None이면 iterable 끝까지 평가</li></ol><li>dropwhile(predicate, iterable)</li><p>predicate을 만족하지 않는 선두 요소들은 순회 생략</p><li>takewhile(predicate, iterable)</li><p>predicate을 만족하는 선두 요소들만 순회</p><li>filterfalse(predicate, iterable)</li><p>predicate을 만족하지 않는 요소들만 순회</p><li>compress(data, selectors)</li><p>의미상 (d for d, s in zip(data, selectors) if s)과 동일</p><li>groupby(iterable, key=None)</li><ul><li>key : 각 요소에 대해 그루핑 키를 계산하는 함수. 없으면 lambda x: x가 이용된다</li><li>iterable이 key에 대해 정렬되어 있다면, SQL의 group by와 같은 효과를 얻을 수 있다</li><li>groupby로 반환되는 객체는 (group_key, group_iterable)을 순회하는 Iterator</li></ul><p><strong>↓python</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="python">[(x[0], [y for y in x[1]]) for x in itertools.groupby([1, 2, 2, 3, 3, 3, 1, 1, 1, 1])]
    # [(1, [1]), (2, [2, 2]), (3, [3, 3, 3]), (1, [1, 1, 1, 1])]

[(x[0], [y for y in x[1]]) for x in itertools.groupby([1, 2, 2, 3, 3, 3, 1, 1, 1, 1], key=lambda x: x%2)]
    # [(1, [1]), (0, [2, 2]), (1, [3, 3, 3, 1, 1, 1, 1])]

</div></ul><h1>functools : 고계함수</h1><ul><li>@cached_property(func) Since 3.8</li><ul><li>인스턴스 메서드를 동일한 이름의 프로퍼티로 만든다</li><p>따라서 인스턴스의 __dict__에 접근할 수 있어야 한다</p><li>최초 프로퍼티 접근 시 실행된 반환값이 프로퍼티의 값으로 고정된다</li></ul><li>cmp_to_key(func) Since 3.2</li><p>인자 2개를 먹고 int를 반환하는 비교 함수를 인자 1개를 먹고 정렬키를 반환하는 함수로 변환해 반환한다</p><li>@lru_cache(user_function)<br>@lru_cache(maxsize=128, typed=False)</li><ul><li>메서드 인자에 대한 리턴값을 캐시해준다</li><p>메서드 모든 인자는 해시 가능해야 한다</p><li>메서드 인자의 순서에 유의</li><p>f(a=1, b=2)와 f(b=2, a=1)의 호출을 서로 다르다고 간주할 수 있다</p><li>maxsize는 2의 거듭제곱일 때 최고 성능으로 작동된다. None이면 무제한</li><li>typed가 True인 경우, f(3)과 f(3.0)은 서로 다른 캐시 아이템이 된다</li><li>래핑된 함수는 cache_info() 메서드를 가지며, 이는 캐시 적중률, 실패율 등을 반환한다</li><li>래핑된 함수는 cache_clear() 메서드를 가지며, 이는 캐시 상태를 초기화한다</li><li>래핑된 함수는 __wrapped__ 속성으로 기존 함수를 보존한다</li><p>따라서 같은 함수에 대해 여러 캐시를 두게 할 수도 있다</p></ul><li>@total_ordering Since 3.2</li><ul><li>클래스에 비교연산을 일부만 정의하면 나머지는 자동으로 채워준다</li><p>__lt__(), __le__(), __gt__(), __ge__() 중 하나는 필수, __eq__()가 필요할 수도</p></ul><li>partial(func, /, *args, **keywords)</li><ul><li>인자 일부를 고정시킨 부분 함수를 반환한다</li><li>func, args, keywords 각각은 반환된 객체의 속성이 된다</li><li>부분 함수 호출에 제공된 positional 인자들은 args 뒤에 순서대로 붙고, keyword 인자들은 keywords를 override한다</li></ul><li>class partialmethod(func, /, *args, **keywords) Since 3.4</li><p>메서드의 인자 일부를 고정시켜 반환한다. func는 descriptor 또는 callable</p><li>reduce(function, iterable[, initializer])</li><li>@singledispatch</li><p>함수의 오버로딩을 가능하게 해준다. 최소 한 개의 positional 인자가 필요하며, 이 인자의 타입을 기준으로 호출을 나눈다<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Python/Library/functools_singledispatch.py" lan="python">예시 코드 »</button></p><li>class singledispatchmethod(func) Since 3.8</li><p>메서드의 오버로딩을 가능하게 해준다. @singledispatch 참고</p><li>update_wrapper(wrapper, wrapped, assigned=WRAPPER_ASSIGNMENTS, updated=WRAPPER_UPDATES)<br>@wraps(wrapped, assigned=WRAPPER_ASSIGNMENTS, updated=WRAPPER_UPDATES)</li><p>래핑된 함수를 래핑 전 함수처럼 보이도록 변경한다<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Python/Library/functools_wraps.py" lan="python">예시 코드 »</button></p></ul><h1>operator : 표준 연산</h1><ul><li>파이썬 표준 연산자들에 대응하는 함수들을 제공한다</li><p>많은 경우 lt(a, b), __lt__(a, b)처럼 '__'가 붙은 것과 붙지 않은 것 모두 제공한다</p><li>비교 연산</li><p>lt(a, b), le(a, b), eq(a, b), ne(a, b), ge(a, b), gt(a, b)</p><li>논리 연산</li><p>not(obj), truth(obj), is_(a, b) # a is b, is_not(a, b) # a is not b</p><li>산수 연산</li><p>abs(obj), add(a, b), and_(a, b), fllordiv(a, b), index(a), inv(obj) == invert(obj), lshift(a, b), mod(a, b), mul(a, b), matmul(a, b) # a @ b, neg(obj), or_(a, b), pos(obj), pow(a, b), rshift(a, b), sub(a, b), truediv(a, b), xor(a, b)</p><li>Sequence 연산</li><p>concat(a, b), contains(a, b), countOf(a, b), delitem(a, b), getitem(a, b), indexOf(a, b), setitem(a, b, c), length_hint(obj, default=0)</p><li>Lookup</li><p>attrgetter(attr), attrgetter(*attrs), itemgetter(item), itemgetter(*items), methodcaller(name, /, *args, **kwargs)</p><li>복합 연산</li><p>iadd, iand, iconcat, ifllordiv, ilshift, imod, imul, imatmul, ior, ipow, irshift, isub, itruediv, ixor</p></ul><table><tr><th>Operation</th><th>Syntax</th><th>Function</th></tr><tr><td>Addition</td><td>a + b</td><td>add(a, b)</td></tr><tr><td>Concatenation</td><td>seq1 + seq2</td><td>concat(seq1, seq2)</td></tr><tr><td>Containment Test</td><td>obj in seq</td><td>contains(seq, obj)</td></tr><tr><td>Division</td><td>a / b</td><td>truediv(a, b)</td></tr><tr><td>Division</td><td>a // b</td><td>floordiv(a, b)</td></tr><tr><td>Bitwise And</td><td>a & b</td><td>and_(a, b)</td></tr><tr><td>Bitwise Exclusive Or</td><td>a ^ b</td><td>xor(a, b)</td></tr><tr><td>Bitwise Inversion</td><td>~ a</td><td>invert(a)</td></tr><tr><td>Bitwise Or</td><td>a | b</td><td>or_(a, b)</td></tr><tr><td>Exponentiation</td><td>a ** b</td><td>pow(a, b)</td></tr><tr><td>Identity</td><td>a is b</td><td>is_(a, b)</td></tr><tr><td>Identity</td><td>a is not b</td><td>is_not(a, b)</td></tr><tr><td>Indexed Assignment</td><td>obj[k] = v</td><td>setitem(obj, k, v)</td></tr><tr><td>Indexed Deletion</td><td>del obj[k]</td><td>delitem(obj, k)</td></tr><tr><td>Indexing</td><td>obj[k]</td><td>getitem(obj, k)</td></tr><tr><td>Left Shift</td><td>a &lt;&lt; b</td><td>lshift(a, b)</td></tr><tr><td>Modulo</td><td>a % b</td><td>mod(a, b)</td></tr><tr><td>Multiplication</td><td>a * b</td><td>mul(a, b)</td></tr><tr><td>Matrix Multiplication</td><td>a @ b</td><td>matmul(a, b)</td></tr><tr><td>Negation (Arithmetic)</td><td>- a</td><td>neg(a)</td></tr><tr><td>Negation (Logical)</td><td>not a</td><td>not_(a)</td></tr><tr><td>Positive</td><td>+ a</td><td>pos(a)</td></tr><tr><td>Right Shift</td><td>a >> b</td><td>rshift(a, b)</td></tr><tr><td>Slice Assignment</td><td>seq[i:j] = values</td><td>setitem(seq, slice(i, j), values)</td></tr><tr><td>Slice Deletion</td><td>del seq[i:j]</td><td>delitem(seq, slice(i, j))</td></tr><tr><td>Slicing</td><td>seq[i:j]</td><td>getitem(seq, slice(i, j))</td></tr><tr><td>String Formatting</td><td>s % obj</td><td>mod(s, obj)</td></tr><tr><td>Subtraction</td><td>a - b</td><td>sub(a, b)</td></tr><tr><td>Truth Test</td><td>obj</td><td>truth(obj)</td></tr><tr><td>Ordering</td><td>a &lt; b</td><td>lt(a, b)</td></tr><tr><td>Ordering</td><td>a &lt;= b</td><td>le(a, b)</td></tr><tr><td>Equality</td><td>a == b</td><td>eq(a, b)</td></tr><tr><td>Difference</td><td>a != b</td><td>ne(a, b)</td></tr><tr><td>Ordering</td><td>a >= b</td><td>ge(a, b)</td></tr><tr><td>Ordering</td><td>a > b</td><td>gt(a, b)</td></tr></table><h1>shutil : 고수준 파일 연산</h1><ul><li>make_archive(base_name, format[, root_dir[, base_dir[, verbose[, dry_run[, owner[, group[, logger]]]]]]])</li><ul><li>base_name : 확장자 미포함 압축 파일 path</li><li>format : 'zip', 'tar', 'gztar', 'bztar', 'xztar'</li><li>root_dir : 압축 파일의 최상위 디렉터리. 기본값은 현재 디렉터리</li><li>base_dir : 압축 시작 디렉터리. 기본값은 현재 디렉터리</li><li>shutil.make_archive 이벤트 발생</li></ul><li>get_archive_formats()</li><p>가능한 압축 포맷 반환</p><li>unpack_archive(filename[, extract_dir[, format]])</li><li>get_unpack_formats()</li><li>copyfileobj(fsrc, fdst[, length])</li><ul><li>fsrc : file-like source</li><p>주의. fsrc의 현재 위치부터 복사를 시작함</p><li>fdst : file-like destination</li><li>length : buffer size</li></ul><li>copyfile(src, dst, *, follow_symlinks=True)</li><ul><li>src : path-like source</li><li>dst : path-like destination</li><p>붙여넣을 파일명을 정확히 포함해야 한다</p><li>shutil.copyfile 이벤트 발생</li></ul><li>copymode(src, dst, *, follow_symlinks=True)</li><ul><li>파일 권한 비트 복사</li><li>src : path-like source</li><li>dst : path-like destination</li><li>shutil.copymode 이벤트 발생</li></ul><li>copystat(src, dst, *, follow_symlinks=True)</li><ul><li>파일 권한 비트, 마지막 접근 시각, 마지막 수정 시각 등 복사</li><li>src : path-like source</li><li>dst : path-like destination</li><li>shutil.copystat 이벤트 발생</li></ul><li>copy(src, dst, *, follow_symlinks=True)</li><ul><li>copyfile + copymode</li><p>copyfile과 다르게 dst는 디렉터리를 가리켜도 된다</p><li>shutil.copyfile, shutil.copymode 이벤트 발생</li></ul><li>copy2(src, dst, *, follow_symlinks=True)</li><ul><li>copyfile + copystat</li><p>copyfile과 다르게 dst는 디렉터리를 가리켜도 된다</p><li>shutil.copyfile, shutil.copystat 이벤트 발생</li></ul><li>copytree(src, dst, symlinks=False, ignore=None, copy_function=copy2, ignore_cangling_symlinks=False, dirs_exist_ok=False)</li><ul><li>dirs_exist_ok : 붙여넣을 디렉터리의 일부가 이미 존재해도 괜찮은지</li><li>ignore : 디렉터리, os.listdir()를 인자로 받아 생략할 이름들의 집합을 반환하는 함수</li><li>shutil.copytree 이벤트 발생</li></ul><li>ignore_patterns(*patterns)</li><p>glob-style 패턴들을 인자로 받아 copytree()의 ignore에 사용할만한 함수를 반환</p><li>rmtree(path, ignore_errors=False, onerror=None)</li><p>shutil.rmtree 이벤트 발생</p><li>move(src, dst, copy_function=copy2)</li><p>파일 또는 디렉터리를 옮긴다. shutil.move 이벤트 발생</p><li>chown(path, user=None, group=None)</li><p>shutil.chown 이벤트 발생</p><li>which(cmd, mode=os.F_OK | os.X_OK, path=None)</li><p>cmd를 실행하게 될 실행 파일의 path 반환. 없으면 None</p></ul></div></article><hr><script id="google-analytics" src="https://www.googletagmanager.com/gtag/js?id=UA-143098403-1" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-143098403-1');</script><script id="MathJax-script" src="/source/tex-chtml.js" async></script><script>MathJax={tex:{tags:'ams',inlineMath:[['식[', ']식']]}};</script><script id="highlight-js" src="/source/highlight.pack.js" defer></script><script id="default-js" src="/source/default.min.js" defer></script></body></html>