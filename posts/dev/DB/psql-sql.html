<!DOCTYPE html><html lang="ko-KR"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="google-site-verification" content="aH-DyzdytYQ0NPHNQFcs5dVoiu5YNs6CEEHYgqDmAFM"><meta name="author" content="Donggi Kim &lt;hi.donggi@gmail.com&gt;"><meta name="description" content="PostgreSQL에서 사용하는 SQL 정리"><title>PostgreSQL SQL</title><link rel="icon" href="/imgs/favicon.png"><link rel="stylesheet" href="/source/default.css"><script>window.wizFuncQueue = [];</script></head><body><div class="w3-bar-block w3-sidebar w3-animate-left" id="sidebar"><hr><div id="marker-list"></div><hr><div id="post-list"></div><hr><details class="w3-small file-list"><summary>LICENSE</summary><table><tr><td>Author</td><td>License</td></tr><tr><td>&copy; <a href="mailto:hi.donggi@gmail.com">Donggi Kim</a></td><td><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/Dong-gi/Dong-gi.github.io/blob/master/LICENSE">MIT</a></td></tr><tr><td><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="https://www.w3schools.com/w3css">w3css</a></td><td>No license</td></tr><tr><td><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="https://highlightjs.org/">highlight.js</a></td><td><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/highlightjs/highlight.js/blob/main/LICENSE">BSD-3-Clause</a></td></tr><tr><td><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/mathjax/MathJax">MathJax</a></td><td><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/mathjax/MathJax/blob/master/LICENSE">Apache-2.0</a></td></tr><tr><td><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/davidshimjs/qrcodejs">QRCode.js</a></td><td><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/davidshimjs/qrcodejs/blob/master/LICENSE">MIT</a></td></tr><tr><td><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/terrastruct/d2">D2</a></td><td><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/terrastruct/d2/blob/master/LICENSE.txt">MPL-2.0</a></td></tr></table></details><hr></div><article id="main"><div class="w3-bar w3-blue w3-large" id="nav" style="position:-webkit-sticky;position:sticky;top:0px;vertical-align:middle"><button class="w3-bar-item w3-button w3-hover-theme" onclick="toggleSidebar()">&#9776;</button><input class="w3-bar-item" id="query" type="text" placeholder="search" style="max-width:35%"><a class="w3-bar-item w3-button w3-hover-theme" href="/">Home</a></div><div class="w3-padding" id="contents"><h1>SQL Syntax</h1><div><h2>Lexical Structure</h2><ul><li class="marker">식별자와 키워드</li><ol><li>select, from : 키워드</li><li>"select" : ""로 감싼 식별자. U&"d\0061t\+000061"처럼 유니코드 코드 포인트를 이용할 수 있다</li><li>table_name : Unquoted 식별자. 대소문자를 구별하지 않는다</li><p>select라는 이름의 컬럼을 가져오려면 select "select" from table_name;처럼 이용한다. 그로지 말자...</p></ol><li class="marker">상수</li><ol><li>문자열 상수 : '문자열'</li><li>달러 인용 문자열 상수 : 달러 인용 문자열은 이스케이프되지 않는다</li><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">$$Dianne's horse$$, $SomeTag$Dianne's horse$SomeTag$
CREATE OR REPLACE FUNCTION change_inaba_name() RETURNS TRIGGER AS $$
BEGIN
    NEW.status_text = REPLACE(NEW.status_text, 'イナバ', '이나바');
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
</div></ol></ul><h2>Value Expressions</h2><div><h3>열 참조</h3><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">-- correlation은 테이블 이름이나 alias
correlation.columnname</div><h3>위치 매개변수 : 함수 정의의 매개변수 위치를 이용해 변수 참조</h3><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">-- 문자열을 2번 반복해서 반환하는 함수
CREATE OR REPLACE FUNCTION test(text) RETURNS text AS $body$ SELECT $1 || $1 $body$ LANGUAGE sql;</div><h3>배열 요소 참조</h3><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">-- subscript는 integer 값을 내는 표현식
expression[subscript]
expression[lower_subscript:upper_subscript]</div><h3>필드 선택</h3><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">-- 특정 행의 열 참조. expression은 row type 또는 열집합
expression.fieldname
-- 일반적으로 expression은 괄호로 감싸져야 하지만, 테이블이나 위치 매개변수의 경우 생략할 수 있다
-- .*로 모든 필드를 얻을 수 있다</div><h3>집계 함수 호출</h3><ol><li>집계 함수(aggregate function)란 여러 입력 행들을 하나의 결과행으로 줄이는 함수</li><li>집계 함수 호출 형태</li><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">aggregate_name (expression [ , ... ] [ order_by_clause ] ) [ FILTER ( WHERE filter_clause ) ]
-- default로 ALL이므로 아래와 동일
aggregate_name (ALL expression [ , ... ] [ order_by_clause ] ) [ FILTER ( WHERE filter_clause ) ]

aggregate_name (DISTINCT expression [ , ... ] [ order_by_clause ] ) [ FILTER ( WHERE filter_clause ) ]

-- ↓ 보통 count에서만 사용되는 형태
aggregate_name ( * ) [ FILTER ( WHERE filter_clause ) ]

-- expression은 집계 함수나 윈도우 함수 호출을 포함하지 않아야 한다
aggregate_name ( [ expression [ , ... ] ] ) WITHIN GROUP ( order_by_clause ) [ FILTER ( WHERE filter_clause ) ]

-- 복수의 인자를 받는 집계 함수에서는 ORDER BY 절이 전체 인자가 끝나고 등장해야 한다
SELECT string_agg(str, ',' ORDER BY str) FROM table;

-- 실제 호출 예
SELECT count(*) AS unfiltered, count(*) FILTER (WHERE num &lt; 5) AS filtered FROM generate_series(1,10) AS num;</div><li><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="http://postgresql.kr/docs/9.6/functions-aggregate.html">내장 집계 함수 목록</a></li></ol><h3>윈도우 함수 호출</h3><ol><li>윈도우 함수는 집계 함수와 비슷하지만, 입력 행들이 결과에 그대로 나타난다</li><li>윈도우 함수 호출 형태</li><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">function_name ([expression [, expression ... ]]) [ FILTER ( WHERE filter_clause ) ] OVER window_name
function_name ([expression [, expression ... ]]) [ FILTER ( WHERE filter_clause ) ] OVER ( window_definition )
function_name ( * ) [ FILTER ( WHERE filter_clause ) ] OVER window_name
function_name ( * ) [ FILTER ( WHERE filter_clause ) ] OVER ( window_definition )</div><li>window_name ::= WINDOW 절로 정의된 윈도우 이름</li><p>OVER window_name과 OVER (window_name)은 다르다. 후자의 경우 윈도우 정의를 복사하여 적용하며, frame 절을 포함하는 경우 수행되지 않는다</p><li>window_definition ::=</li><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">[ existing_window_name ]
-- PARTITION BY 옵션은 행 그룹을 만든다. GROUP BY와 달리 출력-열이나 숫자를 지정할 수 없다
[ PARTITION BY expression [, ...] ]
-- ORDER BY 절도 마찬가지로 출력-열이나 숫자를 지정할 수 없다
[ ORDER BY expression [ ASC | DESC | USING operator ] [ NULLS { FIRST | LAST } ] [, ...] ]
[ frame_clause ]</div><li>frame_clause</li><ol><p>frame_clause는 윈도우 함수가 전체 파티션이 아닌, 현재까지의 파티션을 대상으로 계산을 수행하게 한다</p><li>{ RANGE | ROWS } frame_start -- default로 frame_end는 CURRENT ROW</li><li>{ RANGE | ROWS } BETWEEN frame_start AND frame_end</li><p>↑ UNBOUNDED PRECEDING으로 지정된 frame_start는 파티션의 첫 행, UNBOUNDED FOLLOWING으로 지정된 frame_end는 파티션 마지막 행을 의미한다</p></ol><li>frame_start, frame_end</li><ol><li>UNBOUNDED PRECEDING</li><li>CURRENT ROW</li><li>UNBOUNDED FOLLOWING</li><p>↓ value PRECEDING, FOLLOWING은 ROWS 모드에서만 사용 가능하고, 현재 행을 전후로 하여 프레임 크기를 설정한다</p><li>value PRECEDING</li><li>value FOLLOWING</li></ol><li>frame_exclusion</li><ol><li>EXCLUDE CURRENT ROW</li><li>EXCLUDE GROUP</li><li>EXCLUDE TIES</li><li>EXCLUDE NO OTHERS</li></ol><li>expression은 윈도우 함수 호출을 포함하지 않아야 한다</li><li><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="http://postgresql.kr/docs/9.6/functions-window.html#FUNCTIONS-WINDOW-TABLE">내장 윈도우 함수 목록</a></li></ol><h3>Collation Expressions</h3><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">-- 로캐일에 따른 정렬
SELECT * FROM tbl WHERE ... ORDER BY a COLLATE "C"; -- 결과 정렬
SELECT * FROM tbl WHERE a > 'foo' COLLATE "C";   -- 입력 정렬
SELECT * FROM tbl WHERE a COLLATE "C" > 'foo';   -- 입력 정렬
SELECT * FROM tbl WHERE (a > 'foo') COLLATE "C"; -- 에러. 연산 결과인 boolean은 non-collatable</div><ol><p>LC_COLLATE를 설정하여 기본 로캐일에 따른 정렬을 수행하게 할 수 있다</p><li>데이터베이스 최초 생성 시 LC_COLLATE 변수 값을 'C'로 설정</li><li>기존 데이터베이스를 dump하고, LC_COLLATE를 'C'로 설정한 데이터베이스를 만들어 복구</li><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">db_name=# DROP DATABASE [db_name];
db_name=# CREATE DATABASE [db_name] LC_COLLATE 'C';
-- 데이터베이스는 생성될 때 기본적으로 template1 데이터베이스를 복제하여 생성된다. 하지만 이는 로캐일이 이미 설정되어 충돌하여 에러가 발생할 수 있다
db_name=# CREATE DATABASE [db_name] TEMPLATE template0 LC_COLLATE 'C';</div></ol><h3>Scalar Subqueries : 한 행 또는 한 컬럼을 반환하는, 괄호에 감싸인 SELECT 쿼리</h3><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">SELECT name, (SELECT max(pop) FROM cities WHERE cities.state = states.name) FROM states;</div><h3>배열 생성자</h3><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">SELECT ARRAY[1,2,3+4];
SELECT ARRAY[1,2,22.7]::integer[];
-- 빈 배열도 형식은 필요
SELECT ARRAY[]::integer[];
SELECT ARRAY[ARRAY[1,2], ARRAY[3,4]];
SELECT ARRAY(SELECT oid FROM pg_proc WHERE proname LIKE 'bytea%');
CREATE TABLE arr(f1 int[], f2 int[]);
INSERT INTO arr VALUES (ARRAY[[1,2],[3,4]], ARRAY[[5,6],[7,8]]);</div><h3>행 생성자</h3><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">SELECT ROW(1,2.5,'this is a test');
SELECT ROW(t.*, 42) FROM t; -- t는 행 값
SELECT ROW(t.*, 42) FROM (SELECT ROW(1,2.5,'this is a test')) as t;
CREATE TABLE mytable(f1 int, f2 float, f3 text);
CREATE OR REPLACE FUNCTION getf1(mytable) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;
-- No cast needed since only one getf1() exists
SELECT getf1(ROW(1,2.5,'this is a test'));
CREATE TYPE myrowtype AS (f1 int, f2 text, f3 numeric);
CREATE OR REPLACE FUNCTION getf1(myrowtype) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;
-- Now we need a cast to indicate which function to call:
SELECT getf1(ROW(1,2.5,'this is a test')::mytable);
SELECT getf1(CAST(ROW(11,'this is a test',2.5) AS myrowtype));</div><h3>Expression Evaluation Rules</h3><ol><li>SELECT true OR somefunc();와 SELECT somefunc() OR ture; 모두 somefunc()가 호출되지 않는다. short-circuit 연산과는 다르다</li><li>SELECT ... WHERE CASE WHEN x > 0 THEN y/x > 1.5 ELSE false END;</li><li>SELECT CASE WHEN x > 0 THEN x ELSE 1/0 END FROM tab;</li><p>주의. IMMUTABLE 함수는 값이 먼저 평가되기 때문에, 실제로 x가 항상 0보다 크더라도 1/0이 미리 평가되어 에러가 발생한다<a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="http://postgresql.kr/docs/current/xfunc-volatility.html">xfunc-volatility</a></p></ol></div><h2>함수 호출</h2><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">-- PostgreSQL의 함수의 인자는 이름과 위치 둘 다로 참조할 수 있다
CREATE FUNCTION concat_lower_or_upper(a text, b text, uppercase boolean DEFAULT false) RETURNS text AS $$
    SELECT CASE
        WHEN $3 THEN UPPER($1 || ' ' || $2)
        ELSE LOWER($1 || ' ' || $2)
    END;
$$ LANGUAGE SQL IMMUTABLE STRICT;</div><ol><li>Using Positional Notation</li><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">SELECT concat_lower_or_upper('Hello', 'World');</div><li>Using Named Notation</li><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">SELECT concat_lower_or_upper(a => 'Hello', b => 'World');</div><li>Using Mixed Notation</li><p>키워드 인자는 나머지보다 뒤에 위치해야 한다</p><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">SELECT concat_lower_or_upper('Hello', 'World', uppercase => true);</div></ol></div><h1>Data Definition</h1><div><h2>Default Values</h2><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">-- 기본값에 표현식을 사용할 수 있다. 가장 흔히 쓰이는 것은 timestamp 열이 CURRENT_TIMESTAMP 값을 갖게 하는 것
CREATE TABLE products (
    product_no integer DEFAULT nextval('products_product_no_seq'),
    ...
);</div><h2>Constraints</h2><ol><li class="marker">Check Constraints</li><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">CREATE TABLE products ( product_no integer, price numeric CHECK (price > 0) );

-- 식별자를 줄 수 있다
CREATE TABLE products ( product_no integer, price numeric CONSTRAINT positive_price CHECK (price > 0) );

-- 여러 열을 체크할 수 있다
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CHECK (price > 0),
    discounted_price numeric CHECK (discounted_price > 0), CHECK (price > discounted_price)
);

-- 열 삽입 제약 조건을 테이블 제약 조건으로 사용할 수 있다
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CHECK (price > 0),
    discounted_price numeric,
    CHECK (discounted_price > 0 AND price > discounted_price)
);</div><li class="marker">Not-Null Constraints</li><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">CREATE TABLE products ( product_no integer NOT NULL, price numeric );</div><li class="marker">Unique Constraints</li><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">CREATE TABLE products ( product_no integer UNIQUE, price numeric );
CREATE TABLE products ( product_no integer, price numeric, UNIQUE (product_no) );
CREATE TABLE example ( a integer, b integer, c integer, UNIQUE (a, c) );
-- 식별자를 부여할 수 있다
CREATE TABLE products ( product_no integer CONSTRAINT must_be_different UNIQUE, price numeric );</div><li class="marker">Primary Keys</li><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">CREATE TABLE example ( a integer, b integer, c integer, PRIMARY KEY (a, c) );</div><li class="marker">Foreign Keys</li><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    product_no integer REFERENCES products (product_no),
    quantity integer
);
CREATE TABLE t1 (
    a integer PRIMARY KEY,
    b integer,
    c integer,
    FOREIGN KEY (b, c) REFERENCES other_table (c1, c2)
);
-- 외래키와 기본키 혼용
CREATE TABLE order_items (
    product_no integer REFERENCES products,
    order_id integer REFERENCES orders,
    quantity integer,
    PRIMARY KEY (product_no, order_id)
);</div><li class="marker">무결성 제약 : ON DELETE, ON UPDATE에 사용</li><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">CREATE TABLE order_items (
    product_no integer REFERENCES products ON DELETE RESTRICT, -- 참조하는 행이 삭제되지 않음
    order_id integer REFERENCES orders ON DELETE CASCADE, -- 참조하는 행이 삭제되면 같이 삭제됨
    quantity integer,
    PRIMARY KEY (product_no, order_id)
);</div></ol><h2>System Columns</h2><p>oid : object_id. 테이블을 WITH OIDS로 생성하거나, default with oids이 설정된 경우 생성되는 열. 타입 이름도 oid<a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="http://postgresql.kr/docs/9.6/ddl-system-columns.html">ddl-system-columns</a></p><h2>Modifying Tables</h2><ol><li class="marker">Adding a Column</li><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">ALTER TABLE products ADD COLUMN description text;
ALTER TABLE products ADD COLUMN description text CHECK (description != '');</div><li class="marker">Removing a Column</li><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">ALTER TABLE products DROP COLUMN description;
-- 외래키로 참조중인 경우, 제약을 명시해줘야 반영된다
ALTER TABLE products DROP COLUMN description CASCADE;</div><li class="marker">Adding a Constraint</li><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">ALTER TABLE products ADD CHECK (name != '');
ALTER TABLE products ADD CONSTRAINT some_name UNIQUE (product_no);
ALTER TABLE products ADD FOREIGN KEY (product_group_id) REFERENCES product_groups;
ALTER TABLE products ALTER COLUMN product_no SET NOT NULL;</div><li class="marker">Removing a Constraint</li><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">ALTER TABLE products DROP CONSTRAINT some_name;
ALTER TABLE products ALTER COLUMN product_no DROP NOT NULL;</div><li class="marker">Changing a Column's Default Value</li><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">ALTER TABLE products ALTER COLUMN price SET DEFAULT 7.77;
ALTER TABLE products ALTER COLUMN price DROP DEFAULT;</div><li class="marker">Changing a Column's Data Type</li><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">ALTER TABLE products ALTER COLUMN price TYPE numeric(10,2);
-- 기존 값이 새로운 타입으로 암묵적으로 변환된다면 위의 것으로 충분. 복잡한 변환을 명시하려면 USING 절을 추가 사용</div><li class="marker">Renaming a Column</li><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">ALTER TABLE products RENAME COLUMN product_no TO product_number;</div><li class="marker">Renaming a Table</li><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">ALTER TABLE products RENAME TO items;</div></ol><h2>Privileges</h2><p>권한 : SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER, CREATE, CONNECT, TEMPORARY, EXECUTE, USAGE &lt;&lt; ALL</p><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">GRANT UPDATE ON table_name TO username;
REVOKE ALL ON table_name FROM username;
GRANT SELECT ON ALL TABLES IN SCHEMA public TO user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO user;</div><h2>Row Security Policies<a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="http://postgresql.kr/docs/current/ddl-rowsecurity.html">ddl-rowsecurity</a></h2><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">-- 관리자 그룹에 속한 사용자가, 자신과 관련한 행만 접근
CREATE TABLE accounts (manager text, company text, contact_email text);
ALTER TABLE accounts ENABLE ROW LEVEL SECURITY;
CREATE POLICY account_managers ON accounts TO managers USING (manager = current_user);</div><h2>Schemas</h2><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">CREATE SCHEMA myschema; -- Schema의 테이블은 schema.table 또는 database.schema.table로 접근
CREATE TABLE myschema.mytable ( ... );
DROP SCHEMA myschema;
DROP SCHEMA myschema CASCADE; -- 포함된 내용도 삭제
-- 모든 새 데이터베이스는 public이라는 스키마를 갖고 있다. 따라서 아래 두 문장은 서로 같다
CREATE TABLE products ( ... );
CREATE TABLE public.products ( ... );</div><h2>Table Partitioning</h2><ul><li>개요</li><ol><li>Table partitioning : 논리적으로 하나인 거대한 테이블을 물리적으로 여러 개로 쪼개 저장하는 것</li><li>Range partitioning : 중복되지 않는 열 집합의 구간들로 분할</li><li>List partitioning : 명시적인 키값 리스트로 분할</li><li>Hash partitioning : 모듈로 n 공간에서 키값의 나머지가 같은 것들로 분할</li><li>상속을 이용한 파티셔닝 : 자식 테이블은 추가적인 컬럼을 가질 수 있으며, 다중 상속도 가능하다</li></ol><li>파티셔닝</li><p>CHECK, NOT NULL 제약 조건은 파티션 테이블에 상속된다. NO INHERIT 마킹된 CHECK 제약조건은 제외</p><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">create table api_access_log ( account_id int, access_time datetime, request_uri text ) partition by range(access_time);
create table api_access_log_201901 partition of api_access_log for values from ('2019-01-01') to ('2019-02-01');
-- 파티션 테이블을 파티셔닝할 수 있다
create table api_access_log_201901 partition of api_access_log for values from ('2019-01-01') to ('2019-02-01') partition by range(account_id % 100);</div><li class="marker">주의</li><ol><li>값 변경으로 인해 행이 한 파티션에서 다른 파티션으로 이동되는 경우, 예약된 UPDATE, DELETE 작업이 실패할 수 있다</li><li>BEFORE ROW 트리거는 각 파티션 테이블에 따로 정의해야 한다</li></ol><li class="marker">Partition Pruning</li><ol><li>SET enable_partition_pruning = on;로 옵션을 켤 수 있다. 켜 있는 게 디폴트</li><li>가지치기 옵션이 켜있는 경우, 파티셔닝된 테이블의 정의(인덱스의 정의가 아니라)를 살펴, 스캔하지 않아도 되는 테이블들은 제외한다</li><li>가지치기 시점 : 쿼리 플랜 초기화 시, 쿼리 플랜 실행 중(Append 노드 타입에 한하여)</li></ol></ul></div><h1>Data Manipulation</h1><ol><li>Inserting Data, Updating Data, Deleting Data</li><p>DB - PostgreSQL 시작하기 - SQL 언어 참고</p><li>Returning Data From Modified Rows</li><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">INSERT INTO users (firstname, lastname) VALUES ('Joe', 'Cool') RETURNING id;
UPDATE products SET price = price * 1.10 WHERE price &lt;= 99.99 RETURNING name, price AS new_price;
DELETE FROM products WHERE obsoletion_date = 'today' RETURNING *;
</div></ol><h1>Queries</h1><div><h2>Table Expressions</h2><div><h3>FROM 절</h3><ul><li>일반</li><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">FROM table_reference [, table_reference [, ...]]</div><li class="marker">Cartesian product(Cross join)</li><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">FROM T1 CROSS JOIN T2</div><p>또는 콤마로 구분</p><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">FROM T1, T2</div><li class="marker">판별식을 이용한 조인</li><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">FROM T1 { [INNER] | { LEFT | RIGHT | FULL } [OUTER] } JOIN T2 ON boolean_expression</div><p>두 테이블에 대해 판별식이 참일 경우에만 결과 행으로 반환된다</p><li class="marker">컬럼 셋을 이용한 조인</li><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">FROM T1 { [INNER] | { LEFT | RIGHT | FULL } [OUTER] } JOIN T2 USING ( join column list )</div><p>두 테이블의 컬럼 셋이 일치하는 경우에만 결과 행으로 반환된다</p><li class="marker">자연 조인</li><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">FROM T1 NATURAL { [INNER] | { LEFT | RIGHT | FULL } [OUTER] } JOIN T2</div><p>두 테이블의 공통된 컬럼 리스트를 USING한 것과 동일한 결과를 산출한다</p><li>테이블 별명</li><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">FROM table_reference [AS] alias</div><p>셀프 조인을 위해선 필수적으로 사용된다. 모호함을 피하기 위해 괄호를 이용할 수도 있다</p><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">SELECT * FROM (my_table AS a CROSS JOIN my_table) AS b ...</div><p>컬럼에도 별명을 붙일 수 있다</p><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">FROM table_reference [AS] alias ( column1 [, column2 [, ...]] )</div><li>서브쿼리 사용을 위한 별명</li><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">FROM (SELECT * FROM table1) AS alias</div><li>Table function에 별명 사용</li><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">-- Table function : 행 집합을 반환하는 함수
CREATE TABLE foo (fooid int, foosubid int, fooname text);
CREATE FUNCTION getfoo(int) RETURNS SETOF foo AS $$ SELECT * FROM foo WHERE fooid = $1; $$ LANGUAGE SQL;
SELECT * FROM getfoo(1) AS t1;</div><li>LATERAL 서브쿼리</li><p>키워드 좌측의 테이블들을 참조할 수 있다</p><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">-- unknown_log 테이블로부터 각 로그의 첫 30글자, 삽입 시각, 로그 길이를 가져오기
SELECT substring(log.log, 1, 30), log.insert_datetime, len FROM unknown_log log LEFT JOIN LATERAL LENGTH(log.log) len ON true;
-- LEFT JOIN ON true == CROSS JOIN. 사실 LATERAL 빼도 잘 동작하며, 실제로 사용할 일이 있을진 모르겠음...</div></ul><h3>WHERE 절</h3><ol><li class="marker">GROUPING SETS</li><p>한 테이블에 대해 같은 조건으로 여러 그룹에 대해 SELECT해야하는 경우, 이를 한 번에 질의할 수 있다</p><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">-- 브랜드별 판매량, 사이즈별 판매량, 전체 판매량 각각이 한 테이블에 모두 표시된다
SELECT brand, size, sum(sales) FROM items_sold GROUP BY GROUPING SETS ((brand), (size), ());</div><li class="marker">GROUP BY CUBE ( a, b )</li><p>a, b의 파워 셋에 대해 질의한 것과 같다. ((), (a), (b), (a, b))</p><li class="marker">GROUP BY ROLLUP ( a, b )</li><p>공집합부터 a, b를 순서대로 추가한 집합들에 대해 질의한 것과 같다. ((), (a), (a, b))</p><li>CUBE, ROLLUP의 요소로 리스트가 올 수 있다</li><p>ROLLUP(a, (b, c)) == ((), (a), (a, b, c))</p><li>여러 그루핑 조건을 같이 쓰는 경우, 마지막 조건에 대해 cross product가 이루어진다</li><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">GROUP BY a, CUBE (b, c), GROUPING SETS (d, e)
-- ((a, d), (a, e), (a, b, d), (a, b, e), ..., (a, b, c, e))</div><li>GROUP BY 절에서 행 생성자의 이용은 ROW(a, b)를 통해 할 수 있다</li></ol></div><h2>Select Lists</h2><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">SELECT DISTINCT select_list ...</div><p>각 열집합에 대해 고유한 행들만 선택한다</p><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">SELECT DISTINCT ON (expression [, expression ...]) select_list ...</div><p>모든 행에 대해 expression이 평가된다. 두 행의 모든 평가값이 같은 경우 두 행은 같다고 간주한다</p><h2>Combining Queries</h2><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">query1 UNION [ALL] query2
query1 INTERSECT [ALL] query2
query1 EXCEPT [ALL] query2
</div><h2>Sorting Rows</h2><ul><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">ORDER BY sort_expression1 [ASC | DESC] [NULLS { FIRST | LAST }] [, sort_expression2 ...]</div><li>ASC, DESC : 기본값은 ASC</li><li>NULLS FIRST, NULLS LAST</li><p>null값에 대한 정렬 순서를 의미하며, 기본값은 ASC의 경우 NULLS LAST, DESC의 경우 NULLS FIRST</p></ul><h2>LIMIT and OFFSET</h2><ul><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">SELECT select_list FROM table_expression [ ORDER BY ... ] [ LIMIT { number | ALL } ] [ OFFSET number ]</div><li>LIMIT : 출력 행의 개수 제한</li><li>OFFSET : 산출된 순서대로 n개 행을 출력하지 않고 무시</li></ul><h2>VALUES Lists</h2><ul><li>VALUES ( expression [, ...] ) [, ...]</li><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">SELECT * FROM (VALUES (1, 'one'), (2, 'two'), (3, 'three')) AS t (num,letter);</div><li>실제 디스크 상에 테이블을 만들지 않으면서 상수 테이블을 만드는 방법</li><li>문법적으로 "SELECT select_list FROM table_expression"과 동일하게 취급된다</li></ul><h2>WITH Queries</h2><div><h3>SELECT in WITH</h3><ul><li>여러 개의 SELECT 서브 쿼리를 날리는 대신 WITH을 이용하여 분리할 수 있다</li><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">with tmp1 AS (SELECT ...), tmp2 AS (SELECT ...) SELECT ... WHERE tmp1...</div><li>RECURSIVE를 이용하여 iteration 연산이 가능하다</li><ol><p class="marker">연산 순서</p><li>non-recursive 부분을 계산한다. UNION을 위해 (not UNION ALL) 중복되는 행을 제거한다. 남은 행들을 결과에 포함시키고, 임시 작업 테이블로 설정한다</li><li>작업 테이블이 빌 때까지 아래를 반복한다</li><ol><li>recursive 부분을 계산하고, 작업 테이블 내용을 덮어쓴다. UNION을 위해 (not UNION ALL) 중복된 행(이전 결과와도 비교)들을 제거한다. 남은 행들을 결과에 포함시키고, 임시 중간 테이블로 설정한다</li><li>작업 테이블의 내용을 중간 테이블 내용으로 대체한다. 중간 테이블은 비운다</li></ol><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">-- 10~100의 합계
WITH RECURSIVE t(n) AS ( VALUES (10) UNION SELECT n+1 FROM t WHERE n &lt; 100 )
SELECT sum(n) FROM t;</div><table class="no-sort"><tr><th>t</th><th>working_table</th></tr><tr><td>empty</td><td>empty</td></tr><tr><td>10</td><td>10</td></tr><tr><td>10, 11</td><td>11</td></tr><tr><td>10, 11, 12</td><td>12</td></tr><tr><td>...</td><td>...</td></tr><tr><td>10, 11, 12, 13, ..., 100</td><td>100</td></tr><tr><td>10, 11, 12, 13, ..., 100</td><td>empty</td></tr></table></ol><li>RECURSIVE 연산은 계층 구조나 트리 형태의 데이터에 유용하다</li><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">WITH RECURSIVE search_graph(id, link, data, depth) AS (
    SELECT g.id, g.link, g.data, 1 FROM graph g
UNION ALL
    SELECT g.id, g.link, g.data, sg.depth + 1 FROM graph g, search_graph sg WHERE g.id = sg.link
) SELECT * FROM search_graph;
</div></ul><h3>Data-Modifying Statements in WITH</h3><p>INSERT, UPDATE, DELETE를 WITH과 함께 사용할 수 있다</p><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">WITH moved_rows AS ( DELETE FROM products WHERE isnert_datetime &lt; '2010-11-01' RETURNING * )
INSERT INTO products_log SELECT * FROM moved_rows;
</div></div></div><h1>Data Types</h1><div><h2>Numeric Types</h2><table class="no-sort"><tr><th>Name</th><th>Size</th><th>Description</th></tr><tr><td>smallint, int2</td><td>2 bytes</td><td>signed integer</td></tr><tr><td>integer, int, int4</td><td>4 bytes</td><td>signed integer</td></tr><tr><td>bigint, int8</td><td>8 bytes</td><td>signed integer</td></tr><tr><td>decimal(p, s), numeric(p, s)</td><td>variable</td><td>임의 개수의 유효숫자와 소수 정밀도를 가진 10진수</td></tr><tr><td>real, float4</td><td>4 bytes</td><td>IEEE 754 단일 정밀도 부동소수(최소 유효숫자 6자리)</td></tr><tr><td>double precision, float8</td><td>8 bytes</td><td>IEEE 754 배 정밀도 부동소수(최소 유효숫자 15자리)</td></tr><tr><td>smallserial, serial2</td><td>2 bytes</td><td>자동 증가 정수</td></tr><tr><td>serial, serial4</td><td>4 bytes</td><td>자동 증가 정수</td></tr><tr><td>bigserial, serial8</td><td>8 bytes</td><td>자동 증가 정수</td></tr></table><ul><li>decimal, numeric</li><ol><li>p(precision) : 유효숫자 수</li><li>s(scale) : 소수 정밀도</li><p>예. 3.141592의 precision = 7, scale = 6<br>정수는 scale = 0인 numeric으로 간주해도 무방</p><li>NUMERIC(precision) : scale = 0</li><li>NUMERIC : 임의 유효숫자, 소수 정밀도의 10진수 모두 저장 가능</li><p>무한히 큰 수를 지원하진 않는다. 소수점 전 131072 자리, 소수점 후 16383 자리까지 지원</p><li>'NaN' 상수 지원</li><p>'NaN'에 대한 연산 결과는 'NaN'</p><li>Rounding mode</li><p>numeric 타입의 반올림은 0에서 멀어지는 방향으로 이루어진다</p></ol><li>real, double precision</li><p>'NaN', 'Infinity', '-Infinity' 상수 지원</p><li>serial</li><p>serial 타입은 1부터 시작하여 자동으로 1씩 증가하는 정수에 대한 표현 편의를 제공한다. 9.6 버전에서는 sequence를 이용함으로써 구현한다</p></ul><h2>Character Types</h2><table class="no-sort"><tr><th>Name</th><th>Description</th></tr><tr><td>character [ (n) ], char [ (n) ]</td><td>고정 길이(n) 문자열. 스페이스가 덧붙여진다</td></tr><tr><td>character varying [ (n) ], varchar [ (n) ]</td><td>가변 길이(최대 n) 문자열</td></tr><tr><td>text</td><td>가변 길이 문자열</td></tr></table><h2>Binary Data Type : bytea</h2><ol><li>로캐일에 의존하지 않는 이진 문자열을 표현한다</li><li>bytea의 출력에는 'hex', 'escape' 두 가지 방식(bytea_output)이 있으며, 기본값은 'hex'로 설정되어 있다</li><ul><li>hex : 각 바이트를 16진수 2자리로 표현. 예. '\xDEADBEEF'</li><li>escape : 출력 가능 아스키 문자(32 ~ 126)는 있는 그대로, 백슬래시는 \\, 그 외는 \xxx로 표현한다. 예. 'abc klm *\251T'</li></ul></ol><h2>Date/Time Types</h2><table class="no-sort"><tr><th>Name</th><th>Size</th><th>Description</th><td>Range</td><td>Resolution</td></tr><tr><td>timestamp [ (p) ] [ without time zone ]</td><td>8 bytes</td><td>date and time (no time zone)</td><td>4713 BC ~ 294276 AD</td><td>1μs</td></tr><tr><td>timestamp [ (p) ] with time zone, timestamptz</td><td>8 bytes</td><td>date and time, including time zone</td><td>4713 BC ~ 294276 AD</td><td>1μs</td></tr><tr><td>date</td><td>4 bytes</td><td>date</td><td>4713 BC ~ 5874897 AD</td><td>1 day</td></tr><tr><td>interval [ fields ] [ (p) ]</td><td>16 bytes</td><td>time span</td><td>-178000000 years ~ 178000000 years</td><td>1μs</td></tr><tr><td>time [ (p) ] [ without time zone ]</td><td>8 bytes</td><td>time of day (no time zone)</td><td>00:00:00 ~ 24:00:00</td><td>1μs</td></tr><tr><td>time [ (p) ] with time zone, timetz</td><td>12 bytes</td><td>time of day, with time zone</td><td>00:00:00+1459 ~ 24:00:00-1459</td><td>1μs</td></tr></table><ul><li>p</li><p>초 단위 소수 precision. 0 ~ 6까지 가능하며, 기본값은 없다(설정되지 않은 상태).</p><li>interval field</li><p>YEAR, MONTH, DAY, HOUR, MINUTE, SECOND, YEAR TO MONTH, DAY TO HOUR, DAY TO MINUTE, DAY TO SECOND, HOUR TO MINUTE, HOUR TO SECOND, MINUTE TO SECOND</p><li class="marker">Special Date/Time Input String</li><table class="no-sort"><tr><th>String</th><th>Valid Types</th><th>Description</th></tr><tr><td>epoch</td><td>date, timestamp</td><td>1970-01-01 00:00:00+00 (Unix system time zero)</td></tr><tr><td>infinity</td><td>date, timestamp</td><td>later than all other time stamps</td></tr><tr><td>-infinity</td><td>date, timestamp</td><td>earlier than all other time stamps</td></tr><tr><td>now</td><td>date, time, timestamp</td><td>current transaction's start time</td></tr><tr><td>today</td><td>date, timestamp</td><td>midnight today</td></tr><tr><td>tomorrow</td><td>date, timestamp</td><td>midnight tomorrow</td></tr><tr><td>yesterday</td><td>date, timestamp</td><td>midnight yesterday</td></tr><tr><td>allballs</td><td>time</td><td>00:00:00.00 UTC</td></tr></table></ul><h2>boolean, bool</h2><ol><li>TRUE, 't', 'true', 'y', 'yes', 'on', '1'</li><li>FALSE, 'f', 'false', 'n', 'no', 'off', '0'</li></ol><h2>Enumerated Types</h2><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy'); -- 대소문자 구분한다</div><h2>Geometric Types</h2><table class="no-sort"><tr><th>Name</th><th>Size</th><th>Description</th><th>Representation</th></tr><tr><td>point</td><td>16 bytes</td><td>xy 좌표계 상의 점</td><td>(x, y)</td></tr><tr><td>line</td><td>32 bytes</td><td>직선</td><td>{A, B, C} // Ax + By + C = 0또는 직선 상의 두 점을 콤마로 구분하여 제공</td></tr><tr><td>lseg</td><td>32 bytes</td><td>선분</td><td>((x1, y1), (x2, y2))</td></tr><tr><td>box</td><td>32 bytes</td><td>모든 변이 축과 평행한 직사각형</td><td>((x1, y1), (x2, y2))</td></tr><tr><td>path</td><td>16n bytes</td><td>Closed path</td><td>((x1, y1), ...)</td></tr><tr><td>path</td><td>16n bytes</td><td>Open path</td><td>[(x1, y1), ...]</td></tr><tr><td>polygon</td><td>40+16n bytes</td><td>Polygon</td><td>((x1, y1), ...)</td></tr><tr><td>circle</td><td>24 bytes</td><td>Circle</td><td>&lt;(x, y), r></td></tr></table><h2>JSON Types : json, jsonb</h2><ul><li>jsonb : 이진 포맷으로 저장하여 입력 시 조금 느리지만, 처리는 json보다 빠르다</li><li>배열 포함 여부 확인 예. SELECT '[1, 2, 3]'::jsonb @> '[3, 1]'::jsonb;</li><li>배열 원소 존재 유무 확인 예. SELECT '["foo", "bar", "baz"]'::jsonb ? 'bar';</li><li>key의 존재 유무 확인 예. SELECT '{"foo": "bar"}'::jsonb ? 'foo';</li><li>key로 접근 예. select '{"key":"value"}'::jsonb -> 'key';</li></ul><h2>Array</h2><ul><li>배열 타입 정의</li><p>PostgreSQL은 배열 크기를 제한하지 않는다</p><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">create table test( nums integer[] );
create table test( nums integer ARRAY );
create table test( matrix integer[][] );</div><li>배열 표현</li><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">insert into test values( '{1, 2, 3, 4}'::int[] ); -- insert시엔 ::int[]같은 캐스팅 생략 가능
insert into test values( ARRAY[[1, 2], [3, 4]] ); -- 배열 생성자는 애초에 배열을 반환하므로 캐스팅 불필요</div><li class="marker">배열 참조</li><ol><li>원소 참조 arr[idx]</li><li>슬라이스 arr[start : end]</li><p>모든 차원을 슬라이스한다고 간주된다. arr[1:2][2]는 arr[1:2][1:2]와 같다</p><li>배열 차원 반환 array_dims()</li><li>지정된 차원에 대해 배열 크기 반환 array_length()</li><li>전체 원소 수 반환 cardinality()</li><li>현재 배열 크기보다 큰 인덱스에 값을 할당하는 경우, 중간은 null로 채워진다</li><li>배열 연결</li><ul><li>연산자 || : n차원 배열과 n차원 배열의 연결 또는 n차원 배열에 n-1차원 배열(값)을 추가해준다</li><li>array_prepend() : 1차원 배열 앞에 원소를 추가한다</li><li>array_append() : 1차원 배열 뒤에 원소를 추가한다</li><li>array_cat() : 다차원 배열들에 대해 || 연산과 같은 작업을 한다. 단, 배열만 인자로 사용 가능하다. 0차원 값은 안 된다</li></ul></ol><li class="marker">배열 검색</li><ul><li>배열의 원소 중 하나라도 100</li><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">SELECT ... WHERE 100 = ANY(arr);</div><li>배열의 원소 모두가 100</li><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">SELECT ... WHERE 100 = ALL(arr);</div><li>generate_subscripts() : 주어진 배열과 차원에 대해 subscript의 집합을 반환한다</li><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">SELECT generate_subscripts('{{"1,1","1,2"},{"2,1","2,2"},{"3,1","3,2"}}'::text[][], 1) AS s;
-- 1차원 subscripts → 1, 2, 3
SELECT generate_subscripts('{{"1,1","1,2"},{"2,1","2,2"},{"3,1","3,2"}}'::text[][], 2) AS s;
-- 2차원 subscripts → 1, 2
-- 배열 펼치기
WITH arr AS (SELECT '{{"1,1","1,2"},{"2,1","2,2"},{"3,1","3,2"}}'::text[][] AS arr),
    dims AS (SELECT arr, s1, s2, arr[s1][s2] FROM arr, generate_subscripts(arr, 1) AS s1, generate_subscripts(arr, 2) AS s2)
SELECT * FROM dims;</div></ul><li><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="http://postgresql.kr/docs/current/functions-array.html">functions-array.html</a></li></ul><h2>Composite Types</h2><ol><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">CREATE TYPE complex AS ( r float4, i float4 );</div><li>테이블을 만들면 그와 동일한 이름의 타입이 생성된다</li><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">CREATE TABLE m_item ( item_id int, name text );
CREATE TABLE t_user_item ( user_id bigint, item m_item, count int );</div><li>Literal composite value</li><p>포맷 : '( val1 , val2 , ... )'</p><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">INSERT INTO table_name (complex_column_name) VALUES((1.1,2.2));</div><li>SET 바로 다음엔 괄호가 없어도 되지만, 등호 다음엔 필요하다</li><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">UPDATE table_name SET complex_column.r = (complex_column).r + 1 WHERE ...;</div></ol><h2>Range Types</h2><ol><li>int4range — Range of integer</li><li>int8range — Range of bigint</li><li>numrange — Range of numeric</li><li>tsrange — Range of timestamp without time zone</li><li>tstzrange — Range of timestamp with time zone</li><li>daterange — Range of date</li><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="http://postgresql.kr/docs/current/functions-range.html#RANGE-OPERATORS-TABLE">RANGE-OPERATORS-TABLE</a><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="http://postgresql.kr/docs/current/functions-range.html#RANGE-FUNCTIONS-TABLE">RANGE-FUNCTIONS-TABLE</a></ol><h2>Domain Types</h2><p>기저 타입을 토대로 제약을 추가하여 새로 정의하는 타입</p><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">CREATE DOMAIN non_negative_int AS integer CHECK (VALUE >= 0);</div></div><h1>Functions and Operations</h1><div><h2>Logical Operators</h2><ol><li>AND, OR, NOT</li><li>NULL도 논리 상태로 이용한다</li><ul><li>TRUE AND NULL == NULL</li><li>FALSE AND NULL == FALSE</li><li>TRUE OR NULL == TRUE</li><li>FALSE OR NULL == NULL</li><li>NULL AND NULL == NULL OR NULL == NOT NULL == NULL</li></ul></ol><h2>Comparison Functions and Operators</h2><ol><li>&lt;, >, &lt;=, >=, =, &lt;> or !=</li><li>a [NOT] BETWEEN x AND y</li><p>a [NOT] BETWEEN SYMMETRIC x AND y : x, y 대소관계를 판별하여 적절히 비교한다</p><li>a IS DISTINCT FROM b</li><p>a != b과 같지만 null을 일반적인 값으로 취급한다는 차이가 있다</p><li>expression IS [NOT] NULL</li><li>boolean_expression IS [NOT] TRUE // FALSE, UNKNOWN</li></ol><h2>Mathematical Functions and Operators</h2><ol><li>+, -, *, /, %, @(절댓값)</li><li>^(거듭제곱), |/(제곱근), ||/(삼중근), !(팩토리얼, 후위), !!(팩토리얼, 전위)</li><li>비트 연산자 &, |, #(XOR), ~, &lt;&lt;, >></li><li>abs(x), sqrt(x), cbrt(x), ceil(x), floor(x), exp(x), div(x, y), round(x, y), ...</li><li>random() : x ∈ [0.0, 1.0), setseed(dp) : dp ∈ [-1.0, 1.0]</li></ol><h2>String Functions and Operators</h2><div><h3>문자열 변형</h3><ul><li>문자열 연결 연산자 ||</li><p>비문자열도 피연산자 중 한쪽이 될 수 있다</p><li>lower(string) : 소문자 문자열로 변환</li><li>upper(string) : 대문자 문자열로 변환</li><li>initcap(string) : 각 단어의 첫 글자만 대문자가 되도록 변환</li><li>split_part(string, delimiter, n) : 구분자로 문자열을 분할하여 n번째 문자열 반환</li><li>concat(param1 [, param2 [,...]]) : 각 인자들을 한 문자열로 합쳐 반환한다. null은 무시한다</li><li>concat_ws(sep, param1 [, param2 [,...]]) : sep를 구분자로 하여 접합한다</li><li>format(formatstr [, formatarg [,...]]) : C의 printf와 유사</li><li>left(string, n), right(string, n)</li><li>lpad(string, length [, fill_string]), rpad(string, length [, fill_string])</li><p>fill_string 기본값은 스페이스</p><li>quote_ident(string) : ""로 감싼 문자열 표현 반환</li><li>quote_literal(param), quote_nullable(param) : ''로 감싼 문자열 표현 반환</li><li>repeat(string, number)</li><li>reverse(string)</li></ul><h3>문자열 길이 관련</h3><ul><li>bit_length(string) : 문자열 비트 수</li><li>octet_length(string) : 문자열 바이트 수</li><li>char_length(string) : 문자열 문자 수</li><li>character_length(string) : 문자열 문자 수</li><li>length(string) : 문자열 문자 수</li><li>length(string | bytea, encoding) : 문자열 문자 수</li></ul><h3>검색</h3><ol><li>replace(src_string, target_string, dest_string)</li><li>position(substring in string) : substring의 위치 반환</li><li>substring(string [from int] [for int])</li><li>substring(string from pattern) : POSIX 정규표현식</li><li>substring(string from pattern for escape) : SQL 정규표현식</li><li>trim([leading | trailing | both] [characters] from string)</li><li>regexp_match(string, pattern[, flags]) Since PostgreSQL 10</li><p>POSIX 정규표현식. 첫 번째 매칭 문자열 배열 반환. 패턴에 그룹이 없으면 전체 매칭 문자열이, 그룹이 있으면 각 그룹에 매칭되는 부분 문자열들이 배열의 원소가 된다</p><li>regexp_matches(string, pattern[, flags])</li><p>POSIX 정규표현식. 매칭 문자열 배열로 이루어진 행집합을 반환한다. 전체 문자열 매칭을 위해 'g' 플래그를 이용해야 한다</p><p>PostgreSQL 10 이전 버전에서 regexp_match와 같은 결과를 얻기 위한 서브쿼리 트릭</p><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">SELECT ..., (SELECT regexp_matches(str, pattern)) FROM table...</div><li>regexp_split_to_array(string, pattern[, flags])</li><p>POSIX 정규표현식. 매칭 문자열을 구분자로 하여 분리한 부분 문자열들로 구성된 배열 반환. 문자열 시작, 끝의 길이 0 매칭 문자열은 무시된다</p><li>regexp_split_to_table(string, pattern[, flags])</li><p>POSIX 정규표현식. 매칭 문자열을 구분자로 하여 분리한 부분 문자열들로 구성된 테이블 반환. 문자열 시작, 끝의 길이 0 매칭 문자열은 무시된다</p><li>regexp_replace(string, pattern, replacement[, flags]) : POSIX 정규표현식</li><li>starts_with(string, prefix)</li><li>translate(string, from, to)</li><p>문자열 각 문자에 대하여, from[i]에 일치하는 문자를 to[i]로 교체한다</p></ol><h3>인코딩 관련</h3><ol><li>pg_client_encoding() : 현재 인코딩 이름 반환</li><li>ascii(string)</li><p>첫 글자의 아스키 코드값을 반환한다. UTF8 문자열의 경우 유니코드 코드 포인트를 반환한다</p><li>chr(int)</li><p>주어진 코드값에 대한 문자를 반환한다. UTF8 문자에 대해서는 유니코드 코드 포인트를 인자로 전달하고, 그 외의 경우엔 아스키 코드를 인자로 전달해야 한다. 0은 입력으로 허용되지 않는다</p><li>convert(string | bytea, src_encoding, dest_encoding)</li><p>가능한 빌트인 변환 목록 :<a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="http://postgresql.kr/docs/current/functions-string.html#CONVERSION-NAMES">#CONVERSION-NAMES</a></p><li>convert_from(string | bytea, src_encoding) : dest_encoding = DB 인코딩</li><li>convert_to(string | bytea, dest_encoding) : src_encoding = DB 인코딩</li><li>to_ascii(string [, encoding]</li><p>LATIN1, LATIN2, LATIN9, WIN1250문자열을 아스키 문자열로 변환</p><li>to_hex(number) : 16진수 표현 문자열 반환</li><li>decode(string, format), encode(string, format)</li><p>지원 format : base64, hex, escape</p><p>Data Types - Binary Data Types - escape 참고</p><li>set_bit(string, offset, newvalue), set_byte(string, offset, newvalue)</li><li>md5(string), sha256(bytea), sha512(bytea)</li></ol></div><h2>Bit String Operators</h2><table class="no-sort"><tr><th>Operator</th><th>Description</th><th>Example</th><th>Result</th></tr><tr><td>||</td><td>concatenation</td><td>B'10001' || B'011'</td><td>10001011</td></tr><tr><td>&</td><td>bitwise AND</td><td>B'10001' & B'01101'</td><td>00001</td></tr><tr><td>|</td><td>bitwise OR</td><td>B'10001' | B'01101'</td><td>11101</td></tr><tr><td>#</td><td>bitwise XOR</td><td>B'10001' # B'01101'</td><td>11100</td></tr><tr><td>~</td><td>bitwise NOT</td><td>~ B'10001'</td><td>01110</td></tr><tr><td>&lt;&lt;</td><td>bitwise shift left</td><td>B'10001' &lt;&lt; 3</td><td>01000</td></tr><tr><td>>></td><td>bitwise shift right</td><td>B'10001' >> 2</td><td>00100</td></tr></table><h2>Pattern matching</h2><div><h3>LIKE</h3><ol><li>전체 문자열이 패턴과 일치하는지 여부를 판별한다</li><li>Syntax</li><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">string [NOT] LIKE pattern [ESCAPE escape-character]</div><li>pattern</li><ul><li>'_' : 임의의 1글자</li><li>'%' : 연속적인 임의의 0개 이상 글자</li><li>'string' : 'string' 자체</li></ul><li>ESCAPE</li><p>'%', '_'의 이스케이핑을 끄고 싶을 때 : ESCAPE ''</p><li>기타</li><p>PostgreSQL 고유의 ILIKE : 대소문자 구별없는 LIKE</p><p>LIKE = ~~, ILIKE = ~~*, NOT LIKE = !~~, NOT ILIKE = !~~*</p></ol><h3>SIMILAR TO 정규표현식</h3><ol><li>LIKE와 비슷하나, 패턴으로 SQL 표준 정규표현식을 이용한다</li><p>LIKE와 마찬가지로 전체 문자열이 패턴과 일치해야 한다</p><li>Syntax</li><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">string [NOT] SIMILAR TO pattern [ESCAPE escape-character]</div><li>pattern</li><ol><li>'_'와 '%'는 LIKE와 같은 의미를 지닌다</li><li>sub1 | sub2 : sub1 또는 sub2</li><li>* : 0 or more</li><li>+ : 1 or more</li><li>? : 0 or 1</li><li>{m} : exactly m times</li><li>{m, } : m or more</li><li>{m, n} : m~n times</li><li>() : 그루핑</li><li>[] : 글자 집합</li></ol></ol><h3>POSIX 정규표현식</h3><div><h4>용어</h4><ol><li>RE; 정규표현식 : 정규표현식은 |로 구분되는 브랜치들로 구성된다. 임의의 브랜치와 일치하는 부분 문자열은 매칭 결과가 된다</li><li>Branch : 브랜치는 quantified atom 또는 constraint들로 구성된다. 구성요소 순서대로 매칭을 시도하며, 빈 브랜치는 빈 문자열과 매칭된다</li><li>Quantified atom : quantifier가 붙은 atom</li><li>Constraint : 길이 0인 문자열이 매칭되지만, 특별한 위치와 의미를 지닌다</li></ol><h4>연산자</h4><ol><li>~ : case sensitive match</li><li>~* : case insensitive match</li><li>!~ : case sensitive 'not' match</li><li>!~* : case insensitive 'not' match</li></ol><h4>Atom</h4><ol><li>(re) : 정규표현식 re를 매칭하며, 그루핑 번호가 붙는다</li><li>(?:re) : re에 대해 매칭은 하지만, 그루핑 번호는 붙지 않는다(non-capturing set)</li><li>. : 임의의 문자에 매칭</li><li>[chars] : 문자 집합 임의의 문자에 매칭</li><li>\k : k는 non-alphanumeric 문자. 예. \\는 백슬래시 문자 자체에 매칭된다</li><li>\c : c는 alphanumeric 문자. 이스케이핑된다</li><li>{ : 뒤에 숫자가 오는 경우 정규표현식 quantifier가 된다</li><li>x : 문자 x 자체에 매칭된다</li></ol><h4>Quantifier</h4><ol><li>* : 0 or more</li><li>+ : 1 or more</li><li>? : 0 or 1</li><li>{m} : exactly m times</li><li>{m, } : m or more</li><li>{m, n} : m~n times</li><li>*? : non-greedy version of *</li><li>+? : non-greedy version of +</li><li>?? : non-greedy version of ?</li><li>{m}? : non-greedy version of {m}</li><li>{m,}? : non-greedy version of {m,}</li><li>{m,n}? : non-greedy version of {m,n}</li></ol><h4>Constraint</h4><ol><li>^ : 문자열의 시작에 매칭된다</li><li>$ : 문자열의 끝에 매칭된다</li><li>(?=re) : positive lookahead. 매칭된 부분문자열의 시작부터 재탐색한다</li><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">-- 예. 아이디는 영문 대소문자와 숫자로만 구성할 수 있으며, 첫 글자는 숫자가 될 수 없다
SELECT 'awef79' ~ '(?=^[a-zA-Z])(?=^[a-zA-Z0-9]+$)'; -- t
SELECT '79awef' ~ '(?=^[a-zA-Z])(?=^[a-zA-Z0-9]+$)'; -- f</div><li>(?!re) : negative lookahead. 매칭된 부분문자열의 시작이 아닌 위치부터 재탐색한다</li><li>(?&lt;=re) : positive lookahead. 매칭된 부분문자열의 끝부터 재탐색한다</li><li>(?&lt;!re) : negative lookahead. 매칭된 부분문자열의 끝이 아닌 위치부터 재탐색한다</li><p>Lookahead와 lookbehind는 back reference를 포함할 수 없으며, 모든 괄호는 non-capturing으로 간주된다</p></ol><h4>문자 이스케이프</h4><ol><li>\a(alert character), \b(backspace), \f, \n, \r, \t, \v(수직 탭), \0</li><li>\B : \\</li><li>\cX : X는 임의 문자. 하위 5개 비트가 같고 나머지 비트가 모두 0</li><li>\uFFFF, \UFFFFFFFF : 유니코드 코드포인트. DB 인코딩에 따라 달라진다...</li><li>\xFFF, \xy(8진수 2개), \xyz(8진수 3개)</li></ol><h4>클래스 약어 이스케이프</h4><p>alnum, alpha, blank, cntrl, digit, graph, lower, print, punct, space, upper, xdigit</p><ol><li>\d : [[:digit:]]</li><li>\s : [[:space:]]</li><li>\w : [[:alnum:]_] // underscore included</li><li>\D : [^[:digit:]]</li><li>\S : [^[:space:]]</li><li>\W : [^[alnum:]_] // underscore included</li></ol><h4>Constraint 이스케이프</h4><ol><li>\A : 문자열 시작, \Z : 문자열 끝</li><p>^, $와 다르게 멀티 라인 처리 지원 x</p><li>\m : 단어 시작</li><li>\M : 단어 끝</li><li>\y : 단어 시작 또는 끝</li><li>\Y : not \y</li></ol><h4>Back reference</h4><p>\m[nn] : m은 nonzero digit. n은 추가적인 자릿수</p><h4>Option letter</h4><p>정규표현식 플래그에 사용되는 문자들은 아래와 같다</p><ol><li>c : 대소문자 구분 (overrides operator type)</li><li>i : 대소문자 구분 x (overrides operator type)</li><li>s : 멀티 라인 처리 x. (default)</li><li>n, m : 멀티 라인 처리</li><li>p : 부분적 멀티 라인 처리. ^와 $는 멀티 라인 처리 x</li><li>w : 부분적 멀티 라인 처리. ^와 $는 멀티 라인 처리 o</li></ol></div></div><h2>Formatting Functions</h2><ol><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="http://postgresql.kr/docs/current/functions-formatting.html">functions-formatting.html</a><li>to_char()</li><li>to_date()</li><li>to_number()</li><li>to_timestamp()</li></ol><h2>Date/Time Functions and Operators</h2><div><h3>Date/Time Operators</h3><table class="no-sort"><tr><th>Operator</th><th>Example</th><th>Result</th></tr><tr><td>+</td><td>date '2001-09-28' + integer '7'</td><td>date '2001-10-05'</td></tr><tr><td>+</td><td>date '2001-09-28' + interval '1 hour'</td><td>timestamp '2001-09-28 01:00:00'</td></tr><tr><td>+</td><td>date '2001-09-28' + time '03:00'</td><td>timestamp '2001-09-28 03:00:00'</td></tr><tr><td>+</td><td>interval '1 day' + interval '1 hour'</td><td>interval '1 day 01:00:00'</td></tr><tr><td>+</td><td>timestamp '2001-09-28 01:00' + interval '23 hours'</td><td>timestamp '2001-09-29 00:00:00'</td></tr><tr><td>+</td><td>time '01:00' + interval '3 hours'</td><td>time '04:00:00'</td></tr><tr><td>-</td><td>- interval '23 hours'</td><td>interval '-23:00:00'</td></tr><tr><td>-</td><td>date '2001-10-01' - date '2001-09-28'</td><td>integer 3</td></tr><tr><td>-</td><td>date '2001-10-01' - integer '7'</td><td>date '2001-09-24'</td></tr><tr><td>-</td><td>date '2001-09-28' - interval '1 hour'</td><td>timestamp '2001-09-27 23:00:00'</td></tr><tr><td>-</td><td>time '05:00' - time '03:00'</td><td>interval '02:00:00'</td></tr><tr><td>-</td><td>time '05:00' - interval '2 hours'</td><td>time '03:00:00'</td></tr><tr><td>-</td><td>timestamp '2001-09-28 23:00' - interval '23 hours'</td><td>timestamp '2001-09-28 00:00:00'</td></tr><tr><td>-</td><td>interval '1 day' - interval '1 hour'</td><td>interval '1 day -01:00:00'</td></tr><tr><td>-</td><td>timestamp '2001-09-29 03:00' - timestamp '2001-09-27 12:00'</td><td>interval '1 day 15:00:00'</td></tr><tr><td>*</td><td>900 * interval '1 second'</td><td>interval '00:15:00'</td></tr><tr><td>*</td><td>21 * interval '1 day'</td><td>interval '21 days'</td></tr><tr><td>*</td><td>double precision '3.5' * interval '1 hour'</td><td>interval '03:30:00'</td></tr><tr><td>/</td><td>interval '1 hour' / double precision '1.5'</td><td>interval '00:40:00'</td></tr><tr><td>overlaps</td><td>(date '2000-01-01', date '2000-12-31') overlaps (date '2000-07-07', date '2000-08-08')</td><td>t</td></tr><tr><td>overlaps</td><td>(date '2000-01-01', make_interval(years => 1)) overlaps (date '2000-07-07', date '2000-08-08')</td><td>t</td></tr></table><h3>Date/Time Functions</h3><table class="no-sort"><tr><th>Function</th><th>Return Type</th><th>Description</th><th>Example</th><th>Result</th></tr><tr><td>clock_timestamp()</td><td>timestamptz</td><td colspan="3">현재 timestamp. 클록 기준</td></tr><tr><td>timeofday()</td><td>text</td><td colspan="3">현재 시각(clock_timestamp)을 문자열로 반환</td></tr><tr><td>current_date</td><td>date</td><td colspan="3">현재 date. 트랜잭션 시작 기준</td></tr><tr><td>current_time</td><td>timetz</td><td colspan="3">현재 time. 트랜잭션 시작 기준. CURRENT_TIME(precision) 가능</td></tr><tr><td>current_timestamp</td><td>timestamptz</td><td colspan="3">현재 timestamp. 트랜잭션 시작 기준. CURRENT_TIMESTAMP(precision) 가능</td></tr><tr><td>localtime</td><td>time</td><td colspan="3">현재 time. 트랜잭션 시작 기준. LOCALTIME(precision) 가능</td></tr><tr><td>localtimestamp</td><td>timestamp</td><td colspan="3">현재 timestamp. 트랜잭션 시작 기준. LOCALTIMESTAMP(precision) 가능</td></tr><tr><td>now()</td><td>timestamptz</td><td colspan="3">현재 timestamp. 트랜잭션 시작 기준</td></tr><tr><td>statement_timestamp()</td><td>timestamptz</td><td colspan="3">현재 timestamp. 현재 문장 실행 기준</td></tr><tr><td>transaction_timestamp()</td><td>timestamptz</td><td colspan="3">현재 timestamp. 트랜잭션 시작 기준</td></tr><tr><td>make_date(year int, month int, day int)</td><td>date</td><td>date 생성</td><td>make_date(2013, 7, 15)</td><td>2013-07-15</td></tr><tr><td>make_interval(years int DEFAULT 0, months int DEFAULT 0, weeks int DEFAULT 0, days int DEFAULT 0, hours int DEFAULT 0, mins int DEFAULT 0, secs double precision DEFAULT 0.0)</td><td>interval</td><td>interval 생성</td><td>make_interval(days => 10)</td><td>10 days</td></tr><tr><td>make_time(hour int, min int, sec double precision)</td><td>time</td><td>time 생성</td><td>make_time(8, 15, 23.5)</td><td>08:15:23.5</td></tr><tr><td>make_timestamp(year int, month int, day int, hour int, min int, sec double precision)</td><td>timestamp</td><td>timestamp 생성</td><td>make_timestamp(2013, 7, 15, 8, 15, 23.5)</td><td>2013-07-15 08:15:23.5</td></tr><tr><td>make_timestamptz(year int, month int, day int, hour int, min int, sec double precision, [timezone text])</td><td>timestamptz</td><td>timestamp 생성. timezone 생략시 현재 설정 사용</td><td>make_timestamptz(2013, 7, 15, 8, 15, 23.5)</td><td>2013-07-15 08:15:23.5+01</td></tr><tr><td>to_timestamp(double precision)</td><td>timestamptz</td><td>Convert Unix epoch (seconds since 1970-01-01 00:00:00+00) to timestamp</td><td>to_timestamp(1284352323)</td><td>2010-09-13 04:32:03+00</td></tr><tr><td>at time zone</td><td>timestamptz</td><td>Convert timestamp to timestamptz<a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">wiki/List_of_tz</a></td><td>timestamp '2000-01-01 00:00:00' at time zone 'Asia/Seoul'</td><td>1999-12-31 07:00:00-08</td></tr><tr><td>age(timestamp,timestamp)</td><td>interval</td><td>연월일로 표기되는 두 시각 사이의 차이. 부정확</td><td>age(timestamp '2001-04-10', timestamp '1957-06-13')</td><td>43 years 9 mons 27 days</td></tr><tr><td>age(timestamp)</td><td>interval</td><td>현재 date로부터 뺀다. = age(current_date::timestamp, from)</td><td>age(timestamp '1957-06-13')</td><td>43 years 8 mons 3 days</td></tr><tr><td>date_part(text,timestamp)</td><td>float8</td><td>= extract</td><td>date_part('hour', timestamp '2001-02-16 20:38:40')</td><td>20</td></tr><tr><td>date_part(text,interval)</td><td>float8</td><td>= extract</td><td>date_part('month', interval '2 years 3 months')</td><td>3</td></tr><tr><td>extract(field from timestamp)</td><td>float8</td><td>Get subfield</td><td>extract(hour from timestamp '2001-02-16 20:38:40')</td><td>20</td></tr><tr><td>extract(field from interval)</td><td>float8</td><td>Get subfield</td><td>extract(month from interval '2 years 3 months')</td><td>3</td></tr><tr><td>extract, date_part field</td><td colspan="4">century, day, decade, dow(day of the week), doy(day of the year), epoch(number of seconds sinse 1970-01-01 00:00:00 UTC), hour, isodow(day of the week), isoyear(ISO 8601 week-numbering), microseconds, millenium, milliseconds, minute, month, quarter, second, timezone, timezone_hour, timezone_minute, week(ISO 8601 week-numbering), year</td></tr><tr><td>isfinite(date)</td><td>boolean</td><td>Test for finite date (not +/-infinity)</td><td>isfinite(date '2001-02-16')</td><td>true</td></tr><tr><td>isfinite(timestamp)</td><td>boolean</td><td>Test for finite time stamp (not +/-infinity)</td><td>isfinite(timestamp '2001-02-16 21:28:30')</td><td>true</td></tr><tr><td>isfinite(interval)</td><td>boolean</td><td>Test for finite interval</td><td>isfinite(interval '4 hours')</td><td>true</td></tr><tr><td>date_trunc(text,timestamp)</td><td>timestamp</td><td>Truncate to specified precision</td><td>date_trunc('hour', timestamp '2001-02-16 20:38:40')</td><td>2001-02-16 20:00:00</td></tr><tr><td>date_trunc(text,interval)</td><td>interval</td><td>Truncate to specified precision</td><td>date_trunc('hour', interval '2 days 3 hours 40 minutes')</td><td>2 days 03:00:00</td></tr><tr><td>date_trunc field</td><td colspan="4">microseconds, milliseconds, second, minute, hour, day, week, month, quarter, year, decade, century, millenium</td></tr><tr><td>justify_days(interval)</td><td>interval</td><td>Adjust interval so 30-day time periods are represented as months</td><td>justify_days(interval '35 days')</td><td>1 mon 5 days</td></tr><tr><td>justify_hours(interval)</td><td>interval</td><td>Adjust interval so 24-hour time periods are represented as days</td><td>justify_hours(interval '27 hours')</td><td>1 day 03:00:00</td></tr><tr><td>justify_interval(interval)</td><td>interval</td><td>Adjust interval using justify_days and justify_hours, with additional sign adjustments</td><td>justify_interval(interval '1 mon -1 hour')</td><td>29 days 23:00:00</td></tr></table></div><h2>JSON Functions and Operators</h2><div><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="http://postgresql.kr/docs/current/functions-json.html">functions-json.html</a><h3>json and jsonb Operators</h3><table class="no-sort"><tr><th>Operator</th><th>Right Operand Type</th><th>Description</th><th>Example</th><th>Example Result</th></tr><tr><td>-></td><td>int</td><td>Get JSON array element(인덱스는 0부터 시작. 음수면 뒤에서부터)</td><td>'[{"a":"foo"},{"b":"bar"},{"c":"baz"}]'::json->2</td><td>{"c":"baz"}</td></tr><tr><td>-></td><td>text</td><td>Get JSON object field by key</td><td>'{"a": {"b":"foo"}}'::json->'a'</td><td>{"b":"foo"}</td></tr><tr><td>->></td><td>int</td><td>Get JSON array element as text</td><td>'[1,2,3]'::json->>2</td><td>3</td></tr><tr><td>->></td><td>text</td><td>Get JSON object field as text</td><td>'{"a":1,"b":2}'::json->>'b'</td><td>2</td></tr><tr><td>#></td><td>text[]</td><td>Get JSON object at specified path</td><td>'{"a": {"b":{"c": "foo"}}}'::json#>'{a,b}'</td><td>{"c": "foo"}</td></tr><tr><td>#>></td><td>text[]</td><td>Get JSON object at specified path as text</td><td>'{"a":[1,2,3],"b":[4,5,6]}'::json#>>'{a,2}'</td><td>3</td></tr></table></div><h2>Sequence Manipulation Functions</h2><ol><li>currval(regclass) : 지정된 sequence의 가장 최근 반환된 nextval</li><li>lastval() : 가장 최근 반환된 임의 sequence의 nextval</li><li>nextval(regclass) : sequence를 증가시키고 반환</li><li>setval(regclass, bigint) : sequence의 현재값 설정</li><p>regclass는 pg_class 시스템 카탈로그에 저장된 sequence의 OID며, 이를 직접 찾을 필요는 없다. '' 사이에 식별자를 넣어주면 알아서 변환해준다</p></ol><h2>Conditional Expressions</h2><ol><li>case</li><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">case when condition then result [when ...] [else result] end</div><li>coalesce</li><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">coalesce(value [, ...])</div><p>처음으로 등장하는 non-null값을 반환한다. 모두 null이면 최종적으로 null이 반환된다</p><li>nullif</li><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">nullif(value1, value2)</div><p>value1과 value2가 같으면 null 반환. 다르면 value1 반환</p><li>greatest</li><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">greatest(value [, ...])</div><li>least</li><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">least(value [, ...])</div></ol><h2>Subquery Expressions</h2><ol><li>exists</li><p>exists(subquery) : 서브쿼리가 한 행 이상 반환하면 true, 아니면 false</p><li>in</li><p>expression in (subquery) : expression 판별값이 subquery 결과 중에 있으면 true, 아니면 false</p><li>not in</li><li>any, some</li><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">expression operator any (subquery)
expression operator some (subquery)</div><p>subquery는 하나의 컬럼만 반환해야 한다. expression 판별값이 subquery 결과 중에 하나라도 operator를 만족하면 true</p><li>all</li><p><strong>↓sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">expression operator all (subquery)</div><li>Single-row Comparison</li><p>row_constructor operator (subquery) : subquery는 row_constructor와 같은 개수의 컬럼을 반환해야 한다</p></ol><h2>Series Generating Functions</h2><ol><li>generate_series(start, stop)</li><li>generate_series(start, stop, step)</li><li>generate_series(start, stop interval)</li></ol><h2>System Information Functions</h2><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="http://postgresql.kr/docs/current/functions-info.html">functions-info.html</a></div><h1>동시성 제어</h1><div><h2>소개</h2><ol><li>PostgreSQL은 다중버전 모델 MVCC(Multiversion Concurrency Control)을 이용해서 동시성 처리를 관리한다</li><p>각 트랜잭션의 시작을 기점으로 자료를 각각의 스냅샷(데이터베이스 버전)으로 처리해서 세션이 사용한다. 이렇게 하면 최소한의 잠금을 사용하여 트랜잭션 격리가 이루어진다</p><li>MVCC와 별개로 개발자가 이용할 수 있는 테이블, 행 단위 잠금 기능을 제공한다</li></ol><h2>트랜잭션 격리</h2><ul><li>SQL 표준 트랜잭션 격리 수준; Transaction Isolation Level</li><ul><li>dirty read : 다른 트랜잭션이 아직 커밋하지 않은 자료도 읽을 수 있다</li><li>nonrepeatable read : 다른 트랜잭션이 커밋한 자료를 읽을 수 있다. 다음 읽기 시도시 해당 트랜잭션이 값을 변경했다면 변경된 값을 읽는다</li><li>phantom read : 다른 트랜잭션이 커밋한 자료를 읽을 수 있다. 다음 읽기 시도 시, 최초 읽은 값 그대로 보여준다</li><li>serialization anomaly</li><ol><li>let result ::= 트랜잭션 그룹에 대한 최종 실행 성공 상태</li><li>let possibleResults ::= 각 트랜잭션을 하나씩 순서대로 실행하는 모든 경우에 대해, 각 실행 성공 상태 리스트</li><li>직렬화 이상 == result not in possibleResults</li></ol></ul><li class="marker">PostgreSQL 트랜잭션 격리 수준</li><p>트랜잭션 격리 수준을 설정하려면 SET TRANSACTION 명령을 이용한다. PostgreSQL은 MVCC 모델을 이용하기 때문에, Read uncommitted는 Read committed처럼 작동한다</p><table class="no-sort"><tr><th>격리 수준</th><th>Dirty Read</th><th>Nonrepeatable Read</th><th>Phantom Read</th><th>Serialization Anomaly</th></tr><tr><td>Read uncommitted</td><td>허용, PG에서는 없음</td><td>가능</td><td>가능</td><td>가능</td></tr><tr><td>Read committed</td><td>불가능</td><td>가능</td><td>가능</td><td>가능</td></tr><tr><td>Repeatable read</td><td>불가능</td><td>불가능</td><td>허용, PG에서는 없음</td><td>가능</td></tr><tr><td>Serializable</td><td>불가능</td><td>불가능</td><td>불가능</td><td>불가능</td></tr></table></ul><div><h3>Read Committed 격리 수준</h3><ol><li>PostgreSQL 기본 격리 수준</li><li>for update/share 절 없는 select 쿼리는 쿼리 실행 전 마지막으로 커밋된 자료를 읽는다</li><p>다른 트랜잭션과 분리된 스냅샷을 이용하므로, select 쿼리 실행 중 다른 트랜잭션이 변경하여 커밋한 자료는 읽을 수 없다. 이때, 같은 select 쿼리가 다시 호출되는 경우 변경 커밋된 자료를 가져온다</p><p>현재 트랜잭션에서 업데이트한 자료는 커밋되지 않았더라도 다시 읽을 때 갱신된 값으로 가져온다</p><li>update, delete, select for update/share 쿼리는 타깃 행을 찾는 것까지는 select 쿼리와 동일하다</li><p>실행 시각을 기준으로 발견한 타깃 행이 변경/삭제/잠금 중인 경우 커밋이나 롤백되기를 기다린다. 행이 변경된 경우 where 절이 재평가되고 갱신된 행을 대상으로 쿼리 실행, 삭제된 경우 무시, 롤백된 경우 기존 행을 대상으로 쿼리가 실행된다</p></ol><h3>Repeatable Read 격리 수준</h3><ol><li>트랜잭션 실행 전 마지막으로 커밋된 자료만을 본다</li><p>물론 현재 트랜잭션에서 업데이트한 자료는 커밋되지 않았더라도 다시 읽을 때 갱신된 값으로 가져온다</p><li>update, delete, select for update/share 쿼리는 타깃 행을 찾는 것까지는 select 쿼리와 동일하다</li><p>실행 시각을 기준으로 발견한 타깃 행이 변경/삭제/잠금 중인 경우 커밋이나 롤백되기를 기다린다. 롤백된 경우 기존 행에 대해 쿼리가 실행되고, 변동이 있다면 에러를 발생하고 롤백한다. ← Repeatable Read 트랜잭션은 트랜잭션 시작 이후 다른 트랜잭션에 의해 변경된 행을 갱신하거나 잠글 수 없다</p><li>따라서 update 트랜잭션은 응용 수준에서 트랜잭션 직렬화 실패에 대한 대응이 필요하다</li><p>읽기만 하는 트랜잭션은 직렬화 실패가 일어날 수 없다</p><li>트랜잭션 시작 시각을 기준으로 DB에 대한 엄격한 정적 뷰를 보장하지만, 동시 실행되는 트랜잭션에 의해 일부 불일치가 발생할 수 있다</li><p>예를 들어 다른 트랜잭션에서 여러 연관 테이블의 행들을 순차적으로 업데이트하는 와중에 읽기를 수행하는 경우, 시간적으로는 일관적이지만, 논리적으로는 일관적이지 않은 데이터를 읽게될 수 있다</p></ol><h3>Serializable 격리 수준</h3><ol><li>커밋된 모든 트랜잭션들을 하나씩 순차적으로 실행한다</li><li>이걸로 모든 이상 발생 가능성이 차단되는 것이 아니기 떄문에, 여전히 트랜잭션 직렬화 실패에 대한 대응이 필요하다</li><li>성능을 위한 유의사항</li><ul><li>가능한 경우 READ ONLY 명시</li><li>기본으로 잠금을 제공하므로 select for update/share 구문은 필요없다</li><li>페이지 수준 predicate 잠금이 여러 개 필요하지만 메모리 부족으로 릴레이션 수준의 잠금이 걸리는 경우, 최대 잠금 수 설정을 조정한다</li><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="http://postgresql.kr/docs/current/runtime-config-locks.html#GUC-MAX-PRED-LOCKS-PER-TRANSACTION">GUC-MAX-PRED-LOCKS-PER-TRANSACTION</a><li>릴레이션 수준 잠금이 설정되는 것을 방지하기 위해 인덱스 스캔을 이용한다</li></ul></ol></div><h2>Explicit Locking</h2><ol><li>Table-level Locks</li><p>아래 표는 테이블 수준 잠금의 종류와, 각 요청된 잠금 수준에 대해 이미 설정된 잠금으로 인해 요청이 처리되지 않는 경우를 보여준다. 테이블 잠금은 LOCK 명령어로 획득할 수 있다</p><table class="w3-centered no-sort"><tr><th rowspan="2">Requested Lock Mode</th><th colspan="8">Current Lock Mode</th></tr><tr><th>ACCESS SHARE</th><th>ROW SHARE</th><th>ROW EXCLUSIVE</th><th>SHARE UPDATE EXCLUSIVE</th><th>SHARE</th><th>SHARE ROW EXCLUSIVE</th><th>EXCLUSIVE</th><th>ACCESS EXCLUSIVE</th></tr><tr><td>ACCESS SHARE</td><td colspan="7"></td><td>X</td></tr><tr><td>ROW SHARE</td><td colspan="6"></td><td>X</td><td>X</td></tr><tr><td>ROW EXCLUSIVE</td><td colspan="4"></td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td>SHARE UPDATE EXCLUSIVE</td><td colspan="3"></td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td>SHARE</td><td colspan="2"></td><td>X</td><td>X</td><td></td><td>X</td><td>X</td><td>X</td></tr><tr><td>SHARE ROW EXCLUSIVE</td><td colspan="2"></td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td>EXCLUSIVE</td><td></td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td>ACCESS EXCLUSIVE</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td></tr></table><ol><li>ACCESS SHARE</li><p>select 명령이 이 잠금을 필요로 한다. 테이블을 읽기만 하는 쿼리들은 보통 이 잠금 수준에서 동작한다</p><li>ROW SHARE</li><p>select for update, select for share 명령이 이 잠금을 필요로 한다</p><li>ROW EXCLUSIVE</li><p>update, delete, insert 명령이 이 잠금을 필요로 한다. 테이블 데이터를 수정하는 쿼리들은 보통 이 잠금 수준에서 동작한다</p><li>SHARE UPDATE EXCLUSIVE</li><p>Acquired by VACUUM (without FULL), ANALYZE, CREATE INDEX CONCURRENTLY, CREATE STATISTICS and ALTER TABLE VALIDATE and other ALTER TABLE variants</p><li>SHARE</li><p>Acquired by CREATE INDEX (without CONCURRENTLY)</p><li>SHARE ROW EXCLUSIVE</li><p>Acquired by CREATE COLLATION, CREATE TRIGGER, and many forms of ALTER TABLE</p><li>EXCLUSIVE</li><p>Acquired by REFRESH MATERIALIZED VIEW CONCURRENTLY</p><li>ACCESS EXCLUSIVE</li><p>Acquired by the DROP TABLE, TRUNCATE, REINDEX, CLUSTER, VACUUM FULL, and REFRESH MATERIALIZED VIEW (without CONCURRENTLY) commands</p></ol><li class="marker">Row-level Lock Modes</li><p>행 수준 잠금은 자동적으로 설정되고 해제된다</p><ol><li>FOR UPDATE</li><p>select한 행들을 변경을 위해 잠근다. 다른 트랜잭션의 잠금, 변경, 삭제를 막는다</p><li>FOR NO KEY UPDATE</li><p>FOR UPDATE와 비슷. select for key share 명령은 막지 않는다</p><li>FOR SHARE</li><p>FOR NO KEY UPDATE와 비슷. 공유된 잠금을 설정하며, select for share, select for key share 명령은 막지 않는다</p><li>FOR KEY SHARE</li><p>FOR SHARE와 비슷. select for no key update 명령은 막지 않는다</p></ol></ol></div><h1>Performance Tips</h1><ul><li>Populating a Database</li><ol><li>여러 insert 명령이 순차적으로 실행되는 경우, autocommit 기능을 끄고 마지막에 한꺼번에 커밋하는 것이 좋다</li><p>SQL 명령문에서 BEGIN, COMMIT 명령으로 트랜잭션을 수행하는 것과 동일하다</p><li>여러 행 데이터를 입력하는 경우, COPY 명령을 이용하는 것이 좋다</li><li>테이블을 최초로 생성하면서 데이터를 입력하는 경우, 인덱스를 제거하고 나중에 다시 만드는 것이 좋다</li><li>일시적으로 maintenance_work_mem, max_wal_size 설정을 높인다</li><li>pg_dump는 위에 적힌 것을 비롯한 여러 성능 향상 기법들을 이용한다</li></ol><li>Non-Durable Settings</li><p>데이터베이스의 안정성이 필요없는 경우 아래와 같이 성능 위주의 설정이 가능하다</p><ol><li>DB 클러스터를 RAM 디스크에 둔다</li><li>fsync, synchronous commit, full page writes 설정을 끈다</li><li>max_wal_size, checkpoint_timeout 설정을 높인다</li><li>테이블 생성 시 UNLOGGED를 설정한다</li></ol></ul></div></article><hr><script id="google-analytics" src="https://www.googletagmanager.com/gtag/js?id=UA-143098403-1" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-143098403-1');</script><script id="highlight-js" src="/source/highlight.pack.js" defer></script><script id="default-js" src="/source/default.min.js" defer></script></body></html>