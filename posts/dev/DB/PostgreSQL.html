<!DOCTYPE html><html lang="ko-KR"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes"><title>PostgreSQL 설명서</title><link rel="stylesheet" href="/source/default.css"><meta name="google-site-verification" content="aH-DyzdytYQ0NPHNQFcs5dVoiu5YNs6CEEHYgqDmAFM"><meta name="author" content="Donggi Kim &lt;hi.donggi@gmail.com&gt;"><meta name="description" content="PostgreSQL 공식 문서 중 일부 발췌"><link rel="icon" href="/imgs/favicon.png"><script id="highlight-js" src="/source/highlight.pack.js" async></script><script id="default-js" src="/source/default.min.js" defer></script><script id="google-analytics" src="https://www.googletagmanager.com/gtag/js?id=UA-143098403-1" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-143098403-1');
</script></head><body><aside class="w3-animate-left" id="sidebar"><hr><div id="marker-list"></div><hr><div id="post-list"></div><hr><details class="w3-small"><summary>LICENSE</summary><table class="w3-table-all w3-card w3-small"><tr><td>Author</td><td>License</td></tr><tr><td>&copy; <a href="mailto:hi.donggi@gmail.com">Donggi Kim</a></td><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/Dong-gi/Dong-gi.github.io/blob/master/LICENSE">MIT</a></td></tr><tr><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://www.w3schools.com/w3css">w3css</a></td><td>No license</td></tr><tr><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://highlightjs.org/">highlight.js</a></td><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/highlightjs/highlight.js/blob/main/LICENSE">BSD-3-Clause</a></td></tr><tr><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/mathjax/MathJax">MathJax</a></td><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/mathjax/MathJax/blob/master/LICENSE">Apache-2.0</a></td></tr><tr><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/davidshimjs/qrcodejs">QRCode.js</a></td><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/davidshimjs/qrcodejs/blob/master/LICENSE">MIT</a></td></tr><tr><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/terrastruct/d2">D2</a></td><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/terrastruct/d2/blob/master/LICENSE.txt">MPL-2.0</a></td></tr></table></details><hr></aside><main id="main"><nav class="w3-bar w3-blue" id="nav"><button class="w3-bar-item w3-button w3-hover-theme" id="nav-toggle-btn" type="button" aria-label="Toggle navigation menu" title="Toggle navigation menu">&#9776;</button><form role="search"><input class="w3-bar-item" id="query" type="search" placeholder="search" style="max-width:35%"></form><a class="w3-bar-item w3-button w3-hover-theme" href="/">Home</a></nav><article id="contents"><h1><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://www.postgresql.org/docs/current/legalnotice.html">Legal Notice; 법적 고지</a></h1><p>PostgreSQL Database Management System (also known as Postgres, formerly known as Postgres95)</p><p>Portions Copyright © 1996-2025, PostgreSQL Global Development Group</p><p>Portions Copyright © 1994, The Regents of the University of California</p><p>Permission to use, copy, modify, and distribute this software and its documentation for any purpose, without fee, and without a written agreement is hereby granted, provided that the above copyright notice and this paragraph and the following two paragraphs appear in all copies.</p><p>IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p><p>THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON AN “AS-IS” BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.</p><h1>시작하기 전에</h1><ul><li>최신 공식 문서 : <a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://www.postgresql.org/docs/current/index.html">index</a></li><li>별도 표기가 없다면, 이 문서는 PostgreSQL 18 문서 내용임</li><li>출시 노트 : <a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://www.postgresql.org/docs/release/">release</a></li><li>PostgreSQL은 캘리포니아 대학교 버클리 컴퓨터과학부에서 개발한 POSTGRES 버전 4.2를 기반으로 개발되고, 오픈소스로 관리 중인 객체-관계형 데이터베이스 관리 시스템(ORDBMS)이다. 뛰어난 성능과 확장성으로 여러 분야에서 애용하고 있다</li></ul><h1>SQL</h1><div><h2>구문</h2><div><h3>어휘 구조</h3><ul><li>키워드 : 고정된 의미를 갖는 토큰</li><li>식별자 : 명령에 따라 테이블, 열, 객체 이름을 나타내는 토큰. 단순히 이름(name)이라고 부르기도 한다<ul><li>키워드로 예약된 토큰을 식별자로 사용하려면 ""로 감쌀 필요가 있다</li><li>식별자 크기 제한은 기본 63바이트</li><li>""로 감싼 식별자는 대소문자를 구별한다 -- 이 안에서 "를 나타내려면 ""를 사용</li></ul></li><li>주석 : 입력에 포함된 주석은 공백처럼 취급된다<ul><li>-- 한 줄 주석</li><li>/* 여러 줄 주석 */</li></ul></li><li>상수<ul><li>문자열 : '임의 문자열' -- 이 안에서 '를 나타내려면 ''를 사용</li><li>C 스타일 이스케이프 문자열 : e'임의 문자열' 또는 E'임의 문자열' -- 이 안에서 \를 나타내려면 \\를 사용<ul><li>\n : 줄바꿈</li><li>\t : 탭</li></ul></li><li>유니코드 이스케이프 문자열 : u&amp;'임의 문자열' 또는 U&amp;'임의 문자열'<ul><li>유니코드 지정 : \xxxx, \+xxxxxx</li><li>\ 외의 이스케이프 문자 지정 예 : U&amp;'d!0061t!+000061' UESCAPE '!'</li></ul></li><li>$로 감싼 문자열 : $$임의 문자열$$ 또는 $tag_name$임의 문자열$tag_name$</li><li>비트열 : b'0101' 또는 B'0101' 또는 x'xxxx' 또는 X'xxxx'</li><li>숫자 : 소수점이나 지수가 없는 정수는 크기가 맞는 경우 integer 또는 bigint로 간주된다. 그 외 모든 숫자는 numeric 타입으로 간주된다<ul><li>소수점 허용 : 123.456</li><li>지수 표기 허용 : 0.123e3</li><li>정수에 한하여 2, 8, 16진수 표기 허용 : 0b101, 0o101, 0x101</li><li>구분자 허용 : 123_456.123_456</li></ul></li><li>임의 유형 상수 : 이는 형 변환이 아니라, 문자열로 표현된 리터럴에 대해 처음으로 타입을 할당하는 것<ul><li>type 'string'</li><li>'string'::type</li><li>cast('string' as type)</li></ul></li></ul></li></ul><h3>값 표현식</h3><ul><li>열 참조 : table_name.column_name</li><li>위치 매개변수 : SQL 함수 또는 준비된 쿼리에서 $n으로 n번째 인자 참조</li><li>배열 원소 선택 : expression[i], expression[start:end]</li><li>필드 선택 : expression.field_name</li><li>연산자 호출 : expression operator expression 또는 operator expression</li><li>함수 호출 : function_name([expression [, expression ... ]])</li><li>형 변환 : cast(expression as type) 또는 expression::type</li><li>정렬 방식 지정 : expression COLLATE collation</li><li>스칼라 서브쿼리 : 괄호 안의 SELECT 쿼리로, 정확히 한 개 행, 한 개 열을 반환                </li></ul><div><h4>집계 표현식</h4><div><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">aggregate_name (expression [ , ... ] [ order_by_clause ] ) [ FILTER ( WHERE filter_clause ) ]
aggregate_name (DISTINCT expression [ , ... ] [ order_by_clause ] ) [ FILTER ( WHERE filter_clause ) ]
aggregate_name ( * ) [ FILTER ( WHERE filter_clause ) ]
aggregate_name ( [ expression [ , ... ] ] ) WITHIN GROUP ( order_by_clause ) [ FILTER ( WHERE filter_clause ) ]</div><ul><li>집계 함수는 여러 입력 행들을 (그룹 당) 하나의 행으로 줄인다</li><li>별도 명시가 없는 한 집계 함수는 null을 집계에서 제외한다</li><li>입력 행 순서가 결과에 중요한 경우를 위해 선택적으로 order by 절을 지원한다</li><li>한편 최빈값, 중앙값을 찾는 것과 같은 ordered-set 집계는 order by 절이 필수다<p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql"># with guild_player (guild_id, coin) as ( values
    (1, 10),
    (1, 50),
    (1, 20),
    (2, 10),
    (2, 40)
)
select
    guild_id,
    percentile_cont(0.5) within group (order by coin) as median_coin
from guild_player
group by 1;

 guild_id | median_coin 
----------+-------------
        1 |          20
        2 |          25
(2 rows)</div></li></ul></div><h4>윈도 함수 호출</h4><div><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">function_name ([expression [, expression ... ]]) [ FILTER ( WHERE filter_clause ) ] OVER window_name
function_name ([expression [, expression ... ]]) [ FILTER ( WHERE filter_clause ) ] OVER ( window_definition )
function_name ( * ) [ FILTER ( WHERE filter_clause ) ] OVER window_name
function_name ( * ) [ FILTER ( WHERE filter_clause ) ] OVER ( window_definition )
</div><p><strong>↓ window_definition</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">[ existing_window_name ]
[ PARTITION BY expression [, ...] ]
[ ORDER BY expression [ ASC | DESC | USING operator ] [ NULLS { FIRST | LAST } ] [, ...] ]
[ frame_clause ]
</div><p><strong>↓ frame_clause</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">{ RANGE | ROWS | GROUPS } frame_start [ frame_exclusion ]
{ RANGE | ROWS | GROUPS } BETWEEN frame_start AND frame_end [ frame_exclusion ]
</div><p><strong>↓ frame_start 또는 frame_end</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">UNBOUNDED PRECEDING
offset PRECEDING
CURRENT ROW
offset FOLLOWING
UNBOUNDED FOLLOWING
</div><p><strong>↓ frame_exclusion</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">EXCLUDE NO OTHERS   -- 기본 동작. 아무 행도 제외하지 않음
EXCLUDE CURRENT ROW -- 현재 행만 제외
EXCLUDE GROUP       -- 현재 행 + 피어 행 제외
EXCLUDE TIES        -- 피어 행들 제외
</div><ul><li>윈도 함수는 집계 함수와 달리 입력 행들을 하나의 출력 행으로 축소하지 않는다. 각 행은 결과행에 유지되고, 지정한 파티션과 프레임에 한정한 집계 결과를 추가로 포함한다</li><li>윈도 함수는 다른 절들이 모두 처리된 후 실행되기 때문에 SELECT 또는 ORDER BY 절에서만 사용할 수 있다. 이로 인해 윈도 함수 안에 집계 함수를 포함하는 것이 가능하다 -- 그 반대는 불가능</li><li>OVER (window_name ...)은 정의를 복사하여 수정하는 것을 의미한다</li><li>PARTITION BY 절이 없는 경우, 모든 행을 포함하는 단일 파티션으로 처리된다</li><li>프레임을 지정해 각 입력 행마다 얼마큼의 행들을 집계에 이용할 지 지정할 수 있다<ul><li>피어 행 : 정렬키가 동일한 행</li><li>ROWS 모드<ul><li>프레임 크기는 정확히 행 단위로 계산</li><li>피어 행을 자동으로 포함하는 일은 없다</li><li>offset을 이용하는 경우 : 음이 아닌 정수로 행 개수를 지정</li></ul></li><li>RANGE 모드<ul><li>프레임 크기는 정렬키 구간에 따라 가변적</li><li>구간 내 피어 행 자동 포함</li><li>offset을 이용하는 경우 : ORDER BY 절이 지정한 단일 컬럼에 대하여, 음이 아닌 값으로 최대 차이를 지정</li></ul></li><li>GROUPS 모드<ul><li>프레임 크기는 피어 그룹 단위로 계산</li><li>피어 행 자동 포함</li><li>offset을 이용하는 경우 : 음이 아닌 정수로 피어 그룹 개수를 지정</li></ul></li><li>프레임 정의가 생략된 경우, RANGE UNBOUNDED PRECEDING이 이용된다</li><li>frame_end가 생략된 경우, CURRENT ROW로 설정된다</li><li>ORDER BY 절이 없는 경우, 파티션 내 모든 행들은 서로의 피어다</li></ul><p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">create temp table nums (n) as
values (1), (5), (10), (1), (5), (10);</div><p><strong>↓ order by 없음 + 프레임 정의 없음</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql"># select n, sum(n) over () from nums;
 n  | sum 
----+-----
  1 |  32
  5 |  32
 10 |  32
  1 |  32
  5 |  32
 10 |  32
(6 rows)</div><p><strong>↓ order by 있음 + 프레임 정의 없음</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql"># select n, sum(n) over (order by n) from nums;
 n  | sum 
----+-----
  1 |   2
  1 |   2
  5 |  12
  5 |  12
 10 |  32
 10 |  32
(6 rows)</div><p><strong>↓ ROWS 모드</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql"># select n, sum(n) over (order by n rows 2 preceding) from nums;
 n  | sum 
----+-----
  1 |   1
  1 |   2
  5 |   7
  5 |  11
 10 |  20
 10 |  25
(6 rows)</div><p><strong>↓ RANGE 모드</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql"># select n, sum(n) over (order by n range 4 preceding) from nums;
 n  | sum 
----+-----
  1 |   2
  1 |   2
  5 |  12
  5 |  12
 10 |  20
 10 |  20
(6 rows)</div><p><strong>↓ GROUPS 모드</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql"># select n, sum(n) over (order by n groups 1 preceding) from nums;
 n  | sum 
----+-----
  1 |   2
  1 |   2
  5 |  12
  5 |  12
 10 |  30
 10 |  30
(6 rows)</div></li></ul></div><h4>배열 생성자</h4><ul><li>array[1, 2, 3]</li><li>array[1, 2, 3]::bigint[]</li><li>array[array[array[1, 2, 3]]]::bigint[] -- 형 변환은 내부에 자동 전파</li><li>array[array[1, 2, 3], array[4, 5, 6]] -- 다차원 배열의 경우, 각 차원의 내부 배열들은 모두 동일한 크기를 가져야 한다</li><li>array(select n from generate_series(1, 3) as x(n)) -- 단일 열을 반환하는 서브쿼리로부터 배열 생성 가능</li></ul><h4>행 생성자</h4><ul><li>row value (composite value라고도 함)를 생성하는 표현식</li><li>row 키워드와 0개 이상의 표현식으로 구성된다 : row(1, true, 'text')</li><li>목록에 표현식이 2개 이상 있으면 키워드는 생략 가능하다 : (1, true, 'text')</li><li>행 생성자는 row_value.* 구문을 포함할 수 있다<p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">select (row_number() over (), t.*) from pg_stat_activity t;</div></li><li>행 생성자는 다른 행 값을 포함할 수 있다<p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">select (t, row(t.*)) from pg_stat_activity t;</div></li><li>기본적으로 생성된 값은 익명 레코드 형식이지만, 필요한 경우 명명된 타입으로 변환 가능<p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">create table my_table(f1 int, f2 text);

create function get_f1(my_table) returns int as 'select $1.f1' language sql;

select get_f1((1, 'text'));

create type my_row_type as (f1 int, f2 text);

create function get_f1(my_row_type) returns int as 'SELECT $1.f1' language sql;

select get_f1((1, 'text')); -- ERROR:  function get_f1(record) is not unique
select get_f1((1, 'text')::my_table);
select get_f1((1, 'text')::my_row_type);
</div></li></ul><h4>표현식 평가 규칙</h4><ul><li>표현식이 평가되는 순서는 정의되지 않았고, 쿼리 실행 계획에 따라 얼마든지 변경될 수 있다. 이는 가장 간단한 사례에서도 발생하는데, true or func()와 func() or true 양쪽 모두에서 func()는 실행되지 않을 수 있다</li><li>예외적으로 case 구문은 표현식들을 순차적으로 평가함이 강제되지만, 그럼에도 불구하고 문제가 발생하는 경우들이 있다<ul><li>상수 평가에서 에러 발생하는 경우 : case when x > 0 then x else 1/0 end</li><li>집계 함수에서 에러 발생하는 경우 : case when min(employees) > 0 then avg(expenses / employees) end</li></ul></li></ul></div><h3>함수 호출</h3><ul><li>위치 표기법 : func(val1, val2)</li><li>이름 표기법 : func(arg1 => val1, arg2 => val2)<p>"=>" 대신 이전 버전의 ":="도 지원됨</p></li><li>혼합 표기법 : func(val1, val2, arg3 => val3)</li></ul></div><h2>데이터 정의</h2><div><h3>ID 열</h3><ul><li>값이 암묵적인 시퀀스로부터 자동 생성되는 열<p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql"># create temp table order_history (
    order_no    bigint generated always as identity primary key,
    created_at  timestamptz default current_timestamp
);

# insert into order_history values (default, default) returning *;

 order_no |          created_at           
----------+-------------------------------
        1 | 2026-01-02 13:53:42.781017+09
(1 row)</div></li><li>ID 열은 자동적으로 not null</li><li>테이블 상속에서 자식 테이블의 ID 열은 부모의 것을 상속하지 않는다</li><li>개별 파티션은 파티션된 테이블의 ID 열을 상속한다</li></ul><h3>생성된 열</h3><ul><li>다른 열들로부터 파생되는 열. 단, 이미 파생된 열을 정의에 사용할 수는 없다</li><p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql"># create temp table player (
    purchase_amount int not null,
    vip_level       int generated always as (case
                        when purchase_amount > 10000 then 3
                        when purchase_amount > 5000 then 2
                        when purchase_amount > 1000 then 1
                        else 0
                    end)
);

# insert into player values (5555, default) returning *;

 purchase_amount | vip_level 
-----------------+-----------
            5555 |         2
(1 row)

INSERT 0 1</div><li>기본적으로는 열을 읽을 떄마다 새로 계산되지만 (virtual), 실제로 디스크에 저장하도록 할 수도 있다 (stored)</li><li>테이블 상속에서 부모 열이 생성된 열이면 자식 열도 동일한 유형이어야 하지만, 표현식은 다를 수 있다</li><li>create table ... partition of로 생성하는 경우, 정의는 자동으로 복사된다</li><li>alter table ... attach partition으로 붙이는 경우엔 표현식이 다를 수 있다</li><li>생성된 열은 별도 접근 권한을 가질 수 있다</li><li>before 트리거가 실행된 후에 업데이트되고, before 트리거 안에서는 접근이 허용되지 않는다</li></ul><h3>시스템 열</h3><ul><li>tableoid : 행이 속한 테이블의 oid. pg_class와 조인하여 파티션된 테이블이나 상속 계층 상의 테이블을 쉽게 식별 가능</li><li>xmin : 이 행을 삽입한 트랜잭션 ID</li><li>cmin : 삽입 트랜잭션 내 명령 ID</li><li>xmax : 이 행에 대한 삭제 트랜잭션 ID. 0인 경우 행이 삭제되지 않음이 확실하지만, 삭제 트랜잭션이 커밋되지 않았거나 롤백된 경우에도 0이 아닌 값으로 남는다</li><li>ctid : 현재 물리적 위치</li></ul><h3>행 보안</h3><ul><li>BYPASSRLS 속성을 가진 슈퍼유저와 역할은 항상 행 보안을 우회한다</li><li>테이블 소유자도 기본적으로 행 보안을 우회하지만, 명령 실행 시 force row level security를 지정하면 행 보안을 적용받을 수 있다</li><li>기본키, 고유키 등의 무결성 검사는 항상 행 보안을 우회한다</li></ul><h3>테이블 상속</h3><ul><li>상속 관계는 나중에 추가할 수도 있다</li><li>only 키워드를 지원하는 명령어들은 이를 이용하여 자식 테이블들은 제외하고 지정한 테이블에만 명령을 적용할 수 있다</li><li>기본키, 고유키 등의 제약사항은 자식 테이블들을 고려하지 않는다</li></ul><h3>테이블 파티셔닝</h3><ul><li>파티셔닝을 테이블을 물리적으로 쪼갠다</li><li>일반적으로 파티셔닝의 효과적이려면 테이블 크기가 서버의 물리적 메모리 용량을 초과해야 한다</li><li>일반 테이블을 나중에 파티션 테이블로 바꾸거나, 그 반대로 변환하는 것은 지원되지 않는다. 한편 파티션을 붙였다 떼는 건 자유롭게 가능하다<p>파티션을 나중에 추가할 때, 이미 행이 많이 있다면 성능을 위해 다음 사항들을 미리 만들어두는 게 좋다<ul><li>파티션 조건과 일치하는 check 제약 조건</li><li>파티션 테이블에 정의된 인덱스 정의와 일치하는 인덱스</li></ul></p></li><li>파티션된 테이블에 기본 파티션이 있는 경우, 앞으로 연결될 파티션들을 제외하는 check 제약 조건을 생성하는 것이 성능상 좋다</li><li>범위를 이용해 파티션을 정의하는 경우, 상한은 배타적으로 적용된다<p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">create table xxx_2404 partition of xxx for values from ('2024-04-01') to ('2024-05-01');
create table xxx_2405 partition of xxx for values from ('2024-05-01') to ('2024-06-01');</div></li><li>파티션 자체를 파티션 테이블로 정의해 추가로 쪼갤 수도 있다</li><li>파티션된 테이블에 대해 인덱스를 생성할 때 concurrently 한정자를 사용할 수 없다<ol><li>create index on only 구문을 이용해 인덱스가 유효하지 않은 상태로 생성</li><li>개별 파티션들에 대해 create index ... concurrently 실행</li><li>alter index ... attach partition을 이용해 인덱스 연결</li><li>모든 파티션 인덱스가 연결되면 부모 인덱스는 자동으로 유효한 것으로 간주</li></ol><p>이 기법은 unique, primary key 제약 조건에도 사용할 수 있다: alter table only ... add unique</p></li><li>파티션 수가 많다고 항상 좋지도 않고, 파티션 수가 적다고 항상 나쁜 것도 아니다 -- 사용 사례에 맞는 설계를 해야 한다</li></ul></div><h2>데이터 조작</h2><div><h3>INSERT</h3><ul><li>모든 열을 기본값으로 설정해 행을 삽입하는 경우 다음과 같은 쿼리를 이용할 수 있다<p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">insert into table_name default values;</div></li><li>쿼리 결과를 삽입에 이용할 수 있다<p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">insert into table_name (col1, col2) select ...</div></li></ul><h3>조작한 행 데이터 반환</h3><ul><li>insert, update, delete, merge에 대해 선택적으로 returning 절을 이용해 수정 직후 select 가능<p>트리거가 있는 경우, returning이 조회하는 데이터는 트리거가 수정 완료한 행</p></li><li>merge의 경우 원본 행, 삽입/업데이트/삭제한 행 데이터 모두 획득 가능</li><li>어떤 경우든 old.col_name으로 이전 버전 데이터 획득 가능</li></ul></div><h2>쿼리</h2><div><h3>Table expression</h3><div><h4>Joined table</h4><ul><li>구문<p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">T1 cross join T2
T1         { [inner] | { left | right | full } [outer] } join T2 on boolean_expression
T1         { [inner] | { left | right | full } [outer] } join T2 using ( join_column_list )
T1 natural { [inner] | { left | right | full } [outer] } join T2</div><ul><li>괄호를 이용하여 조인 순서를 제어할 수 있다. 괄호가 없는 경우 왼쪽에서 오른쪽으로 중첩된다</li><li>using을 이용하는 경우, 출력은 중복되는 열을 제거한다 : 공통 열, 나머지 T1 열, 나머지 T2 열</li><li>natural은 using의 축약형으로, 두 테이블에서 공통적으로 나타나는 모든 열 이름으로 구성된 using과 동일하다</li><li>조인 조건은 조인 대상을 필터링하기 위한 것으로 조인 전에 처리된다</li></ul></li><li>cross join<ul><li>T1과 T2의 모든 행 조합(데카르트 곱) 포함</li><li>from t1 cross join t2는 다음 표현들과 동일하다<ul><li>from t1 inner join t2 on true</li><li>from t1, t2</li></ul></li></ul><p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql"># create temp table a (a) as values ('a1'), ('a2');

# create temp table b (b) as values ('b1'), ('b2'), ('b3');

# create temp table c ( c text );

# select * from a cross join b;
 a  | b  
----+----
 a1 | b1
 a1 | b2
 a1 | b3
 a2 | b1
 a2 | b2
 a2 | b3
(6 rows)

# select * from a, c;
 a | c 
---+---
(0 rows)
</div></li><li>(inner) join : 조인 조건을 만족하는 T1, T2의 행 조합<p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql"># with
# a (a) as ( values ('a1'), ('a2'), ('a4') ),
# b (b) as ( values ('b1'), ('b1+'), ('b2'), ('b3') )
# select * from a join b on regexp_match(a, $$\d+$$) = regexp_match(b, $$\d+$$);
 a  | b  
----+----
 a1 | b1
 a1 | b1+
 a2 | b2
(3 rows)
</div></li><li>left (outer) join : 조건을 만족하지 않는 T1 행도 포함<p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql"># \pset null '(null)'
# with
# a (a) as ( values ('a1'), ('a2'), ('a4') ),
# b (b) as ( values ('b1'), ('b1+'), ('b2'), ('b3') )
# select * from a left join b on regexp_match(a, $$\d+$$) = regexp_match(b, $$\d+$$);
 a  |  b  
----+-----
 a1 | b1
 a1 | b1+
 a2 | b2
 a4 | (null)
(4 rows)
</div></li><li>right (outer) join : 조건을 만족하지 않는 T2 행도 포함<p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql"># \pset null '(null)'
# with
# a (a) as ( values ('a1'), ('a2'), ('a4') ),
# b (b) as ( values ('b1'), ('b1+'), ('b2'), ('b3') )
# select * from a right join b on regexp_match(a, $$\d+$$) = regexp_match(b, $$\d+$$);
   a    |  b  
--------+-----
 a1     | b1
 a1     | b1+
 a2     | b2
 (null) | b3
(4 rows)
</div></li><li>full (outer) join : 조건을 만족하지 않는 T1, T2 행 각각 포함<p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql"># \pset null '(null)'
# with
# a (a) as ( values ('a1'), ('a2'), ('a4') ),
# b (b) as ( values ('b1'), ('b1+'), ('b2'), ('b3') )
# select * from a full join b on regexp_match(a, $$\d+$$) = regexp_match(b, $$\d+$$);
   a    |   b    
--------+--------
 a1     | b1
 a1     | b1+
 a2     | b2
 (null) | b3
 a4     | (null)
(5 rows)
</div></li></ul><h4>Table and column alias</h4><p>별칭 정의 후엔 쿼리에서 원래 이름으로 참조할 수 없다</p><h4>Subquery</h4><ul><li>파생 테이블을 지정하는 서브쿼리는 괄호로 감싸야 한다</li><li>select 명령 대신 values 목록으로 서브쿼리를 구성할 수도 있다<p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql"># select * from (values ('a', 1), ('a', 2)) as x(a, b);
 a | b 
---+---
 a | 1
 a | 2
(2 rows)
</div></li></ul><h4>Table function</h4><ul><li>테이블 함수는 행 집합을 생성하는 함수</li><li>구문<p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">function_call                       [with ordinality] [[as] table_alias [(column_alias, [, ...])]]
rows from( function_call [, ... ] ) [with ordinality] [[as] table_alias [(column_alias, [, ...])]]</div></li><li>with ordinality : 마지막에 bigint 타입의 ordinality 열이 추가되어 행 번호를 표시한다</li><li>특수 테이블 함수 unnest는 임의 개수의 배열 매개변수로 호출할 수 있는데, 개별 배열에 대해 unnest가 호출되고 rows from 구문으로 결합한 것처럼 동작한다<p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql"># \pset null '(null)'
# select * from unnest('{1, 2, 3}'::int[], '{a, b}'::text[]) with ordinality as x (a, b);
 a |   b    | ordinality 
---+--------+------------
 1 | a      |          1
 2 | b      |          2
 3 | (null) |          3
(3 rows)

# select * from rows from(
#     unnest('{1, 2, 3}'::int[]),
#     unnest('{a, b}'::text[])
# ) with ordinality as x (a, b, c);
 a |   b    | c 
---+--------+---
 1 | a      | 1
 2 | b      | 2
 3 | (null) | 3
(3 rows)</div></li><li>테이블 및 열 별칭을 지정하지 않으면, 함수 이름이 이용된다</li><li>호출 방식에 따라 다른 열 집합을 반환하는 경우, 출력 행 구조를 쿼리에 지정해야 한다<p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">create extension dblink;

select *
from dblink('dbname=wiz', 'select pid, usename, query from pg_stat_activity')
    as x(pid int, usename text, query text)
where query != '';</div><p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql"># \pset null '(null)'
# select *
# from rows from (
#     json_to_recordset('[{"a":40,"b":"foo"},{"a":"100","b":"bar"}]') as (a int, b text),
#     generate_series(1, 3)
# ) as x(x, y, z)
# order by 3;
   x    |   y    | z 
--------+--------+---
     40 | foo    | 1
    100 | bar    | 2
 (null) | (null) | 3
(3 rows)
</div></li></ul><h4>lateral 서브쿼리</h4><ul><li>기본적으로 서브쿼리는 독립적으로 평가되므로 from 절의 다른 테이블을 참조할 수 없다</li><li>from 절의 서브쿼리 앞에 lateral 키워드를 붙이는 경우, from 절에서 해당 서브쿼리보다 앞에 있는 테이블의 열을 참조할 수 있다</li><li>테이블 함수는 항상 그보다 앞에 있는 테이블의 열을 참조할 수 있으므로 lateral 키워드 명시는 선택 사항이다</li></ul><h4>where 절</h4><p>from 절 처리가 완료된 후, 생성된 가상 테이블의 각 행이 검색 조건과 일치하는지 검사한다 -- 결과가 false거나 null이면 출력 테이블에서 삭제된다</p><h4>group by, having 절</h4><ul><li>where 필터를 통과한 뒤의 테이블을 group by 절을 이용해 그룹화할 수 있다<p>한편 전체 테이블이 한 개 그룹이라면 group by 생략 가능</p></li><li>having 절을 이용해 그룹에 대한 필터링을 수행할 수 있다</li><li>grouping sets : group by를 여러 번 수행하고 이어붙인 것과 같다<p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql"># \pset null '(null)'
# with tmp (a, b) as ( values ('a', 'b') )
# select a, b
# from tmp
# group by grouping sets (a, b);
   a    |   b    
--------+--------
 a      | (null)
 (null) | b
(2 rows)</div></li><li>cube : 가능한 모든 부분집합(멱집합; power set)에 대해 질의한 것과 같다<p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">-- cube(a, b) = grouping sets((), (a), (b), (a, b))
# \pset null '(null)'
# with tmp (a, b) as ( values ('a', 'b') )
# select a, b
# from tmp
# group by cube (a, b);
   a    |   b    
--------+--------
 (null) | (null)
 a      | b
 a      | (null)
 (null) | b
(4 rows)</div></li><li>rollup : 공집합부터 요소들을 순서대로 추가한 집합들에 대해 질의한 것과 같다<p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">-- rollup(a, b) = grouping sets((), (a), (a, b))
# \pset null '(null)'
# with tmp (a, b) as ( values ('a', 'b') )
# select a, b
# from tmp
# group by rollup (a, b);
   a    |   b    
--------+--------
 (null) | (null)
 a      | b
 a      | (null)
(3 rows)</div></li><li>cube, rollup의 요소로 리스트를 지정할 수 있다<p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">-- rollup(a, (b, c)) == grouping sets((), (a), (a, b, c))
# \pset null '(null)'
# with tmp (a, b, c) as ( values ('a', 'b', 'c') )
# select a, b, c
# from tmp
# group by rollup (a, (b, c));
   a    |   b    |   c    
--------+--------+--------
 (null) | (null) | (null)
 a      | b      | c
 a      | (null) | (null)
(3 rows)</div></li><li>grouping sets의 요소로 cube, rollup을 사용할 수 있다</li><li>distinct를 이용해 그룹 집합에 대한 중복을 제거할 수 있다<p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql"># \pset null '(null)'
# with tmp (a, b, c) as ( values ('a', 'b', 'c') )
# select a, b, c
# from tmp
# group by distinct grouping sets (cube(a, b), rollup(b, c))
# order by 1, 2, 3;
   a    |   b    |   c    
--------+--------+--------
 a      | b      | (null)
 a      | (null) | (null)
 (null) | b      | c
 (null) | b      | (null)
 (null) | (null) | (null)
(5 rows)</div></li><li>하나의 group by에 여러 그룹화 항목이 나열되는 경우, 최종 목록은 각 항목들에 대한 곱집합이다<p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql"># \pset null '(null)'
# with tmp (a, b, c, d) as ( values ('a', 'b', 'c', 'd') )
# select a, b, c, d
# from tmp
# group by cube (a, b), cube (c, d)
# order by 1, 2, 3, 4;
   a    |   b    |   c    |   d    
--------+--------+--------+--------
 a      | b      | c      | d
 a      | b      | c      | (null)
 a      | b      | (null) | d
 a      | b      | (null) | (null)
 a      | (null) | c      | d
 a      | (null) | c      | (null)
 a      | (null) | (null) | d
 a      | (null) | (null) | (null)
 (null) | b      | c      | d
 (null) | b      | c      | (null)
 (null) | b      | (null) | d
 (null) | b      | (null) | (null)
 (null) | (null) | c      | d
 (null) | (null) | c      | (null)
 (null) | (null) | (null) | d
 (null) | (null) | (null) | (null)
(16 rows)
</div></li></ul><h4>윈도 함수 처리</h4><ul><li>윈도 함수는 위 그룹화와 having 필터링이 모두 수행된 후 실행된다</li><li>쿼리 결과는 윈도 함수에 정의된 순서에 따라 정렬되긴 하지만, 이에 의존하는 것은 권장되지 않는다. 정렬된 결과가 필요한 경우 최상위 order by 절을 명시하는 것이 권장된다</li></ul></div><h3>Select list</h3><ul><li>컬럼 이름 대신 *를 이용해 모든 컬럼을 순서대로 선택 가능</li><li>열 이름에 지정한 별칭은 후속 처리 -- order by 절 포함 -- 에 사용 가능</li><li>select distinct를 이용해 중복 행 제거 가능. 이때 null도 하나의 고윳값으로 취급</li><li>(비표준) select distinct on (expression [, ...])를 이용해 사용자 정의 기준으로 중복 행 제거 가능</li></ul><h3>쿼리 결합</h3><ul><li>query1 union [all] query2 : 합집합</li><li>query1 intersect [all] query2 : 교집합</li><li>query1 except [all] query2 : 차집합</li><li>all을 지정하지 않는 경우 distinct와 마찬가지로 중복된 행을 제거한다</li><li>괄호 없이 나열되는 경우, intersect가 union/except보다 먼저 평가된다</li></ul><h3>order by</h3><p>null은 기본적으로 null이 아닌 값보다 큰 것처럼 정렬된다</p><h3>values list</h3><ul><li>디스크에 쓰지 않고 사용할 수 있는 상수 테이블을 생성한다</li><li>기본적으로 column1, column2, ... 이름을 할당하지만, 이는 SQL 표준이 아니므로 호환을 위해 재정의하는 것이 좋다</li><li>구문적으로 <span class="as-code code-span" lan="sql">values (expression [, ...]) [, ...]</span>는 <span class="as-code code-span" lan="sql">select select_list from table_expression</span>과 동일하게 취급된다<ul><li>select가 나타날 수 있는 모든 곳에 사용될 수 있다</li><li>뒤에 order by, limit 등을 붙일 수 있다</li></ul><p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql"># values (1), (3), (2) order by 1 limit 2;
 column1 
---------
       1
       2
(2 rows)

# create table table_name (num) as values (1), (3), (2);
SELECT 3

# insert into table_name values (1), (2), (3);
INSERT 0 3

# select * from (values (1), (3), (2)) as x(num);
 num 
-----
   1
   3
   2
(3 rows)

# with tmp(num) as (values (1), (2), (3))
# (select * from tmp) union
# (values (1), (4));
 num 
-----
   1
   3
   4
   2
(4 rows)
</div></li></ul><h3>with 쿼리 (CTE; Common Table Expression)</h3><ul><li>하나의 쿼리 실행 중에만 존재하는 임시 테이블을 정의하는 방법을 제공한다</li><li>select, insert, update, delete, merge 명령을 with 절의 보조문으로 사용할 수 있다<p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">with temp_name as (
    보조문
)
부모_쿼리</div></li><li>recursive 한정자를 이용하면 쿼리가 직접 출력을 참조하는 반복 연산이 가능하다<ol><li>non-recursive 부분을 계산한다. UNION을 위해 (not UNION ALL) 중복되는 행을 제거한다. 남은 행들을 결과에 포함시키고, 임시 작업 테이블로 설정한다</li><li>작업 테이블이 빌 때까지 아래를 반복한다<ol><li>recursive 부분을 계산하고, 작업 테이블 내용을 덮어쓴다. UNION을 위해 (not UNION ALL) 중복된 행(이전 결과와도 비교)들을 제거한다. 남은 행들을 결과에 포함시키고, 임시 중간 테이블로 설정한다</li><li>작업 테이블의 내용을 중간 테이블 내용으로 대체한다. 중간 테이블은 비운다</li></ol></li></ol><p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">-- 10 ~ 100의 합계
with recursive t(n) as (
    (values (10))
    union all
    (select n+1 from t where 100 > n)
)
select sum(n) from t;</div><table class="w3-table-all w3-card w3-small"><tr><th>t</th><th>working_table</th></tr><tr><td>empty</td><td>empty</td></tr><tr><td>10</td><td>10</td></tr><tr><td>10, 11</td><td>11</td></tr><tr><td>10, 11, 12</td><td>12</td></tr><tr><td>...</td><td>...</td></tr><tr><td>10, 11, 12, 13, ..., 100</td><td>100</td></tr><tr><td>10, 11, 12, 13, ..., 100</td><td>empty</td></tr></table></li><li>일반적으로 with 쿼리는 이후 몇 번 참조되든지 한 번만 평가되는 대신, 메인 쿼리의 제약 조건이 최적화에 고려되지 않는다<ul><li>하지만 with 쿼리가 재귀적이지 않고, 부작용이 없고, 한 번만 참조된다면 메인 쿼리와 통합되어 동시에 최적화된다</li><li>not materialized를 지정하면 with 쿼리가 메인 쿼리에 통합되어 동시에 최적화되도록 할 수 있다<p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">with x as not materialized (
    select * from big_table
)
select * from x as t1 join x as t2 on t1.id = t2.parent
where t2.id = 123;
</div></li></ul></li></ul></div><h2>데이터 유형</h2><div><h3>숫자</h3><table class="w3-table-all w3-card w3-small"><tr><th>name</th><th>storage size</th><th>description</th><th>range</th></tr><tr><td>smallint</td><td>2 바이트</td><td>정수</td><td>-32768 ~ +32767</td></tr><tr><td>integer</td><td>4 바이트</td><td>정수</td><td>-2147483648 ~ +2147483647</td></tr><tr><td>bigint</td><td>8 바이트</td><td>정수</td><td>-9223372036854775808 ~ +9223372036854775807</td></tr><tr><td>decimal, numeric</td><td>가변</td><td>사용자 지정 정밀도. 유리수</td><td>소수점 앞 최대 131072자리, 소수점 뒤 최대 16383자리</td></tr><tr><td>real</td><td>4 바이트</td><td>부동 소수</td><td>소수점 6자리 정밀도</td></tr><tr><td>double precision</td><td>8 바이트</td><td>부동 소수</td><td>소수점 15자리 정밀도</td></tr></table><ul><li>numeric(precision, scale=0) : 최대 precision(1 ~ 1000)개 유효숫자, 최대 scale개 소수점 자릿수(-1000 ~ 1000)<p>SQL 표준은 scale 값으로 0 ~ precision만 허용함에 유의</p></li><li>numeric : precision, scale 모두 지정하지 않으면 표에 기재된 최대 제약 조건을 갖는다<p>제약 조건 없는 numeric은 무한대('Infinity', '-Infinity')를 저장할 수 있다</p></li><li>가까운 짝수로 반올림하는 real, double precision과 다르게 numeric은 0에서 멀어지는 방향으로 이루어진다</li></ul><h3>이진 데이터</h3><p>SQL 표준의 BLOB과 유사한 타입을 bytea로 지원한다</p><h3>날짜/시간</h3><ul><li>time, timestamp, interval은 초 단위 소수점 정밀도(0~6) 지정 가능</li><li>유효한 타임스탬프 입력 : 날짜 + 시간 + [시간대] + [AD|BC]<ul><li>timestamp 타입에 대해선 입력의 시간대 표시를 무시한다</li><li>timestamptz 타입에 대해선 시각을 UTC로 변환하여 저장한다</li></ul></li><li>특수 날짜/시간 입력 문자열<p>'now', 'today' 등을 사용한 저장된 쿼리는 해당 시각을 계속 재사용하기 때문에, SQL 함수를 이용하는 것이 권장된다. 예. 'tomorrow'::date 대신 CURRENT_DATE + 1</p><table class="w3-table-all w3-card w3-small"><tr><th>input string</th><th>valid types</th><th>description</th></tr><tr><td>epoch</td><td>date, timestamp</td><td>Unix time zero</td></tr><tr><td>infinity</td><td>date, timestamp, interval</td><td>다른 모든 타임스탬프보다 나중</td></tr><tr><td>-infinity</td><td>date, timestamp, interval</td><td>다른 모든 타임스탬프보다 이전</td></tr><tr><td>now</td><td>date, time, timestamp</td><td>트랜잭션 시작 시각</td></tr><tr><td>today</td><td>date, timestamp</td><td>오늘 자정</td></tr><tr><td>tomorrow</td><td>date, timestamp</td><td>내일 자정</td></tr><tr><td>yesterday</td><td>date, timestamp</td><td>어제 자정</td></tr><tr><td>allballs</td><td>time</td><td>00:00:00.00 UTC</td></tr></table></li><li>interval 입력 : '[@] quantity unit [quantity unit...] [ago]'<ul><li>@ : 장식 옵션</li><li>quantity : 음수 허용</li><li>unit : microsecond, millisecond, second, minute, hour, day, week, month, year, decade, century, millennium</li><li>ago : 지정 시 모든 quantity 부호를 뒤집는다</li><li>일부 간략한 표기 지원 : '일 시간:분:초', '년-월'</li></ul></li></ul><h3>열거형</h3><p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">CREATE TYPE enum_name AS ENUM ('value1', 'value2')
ALTER TYPE enum_name ADD VALUE [ IF NOT EXISTS ] 'new value' [ { BEFORE | AFTER } 'neighbor value' ]
ALTER TYPE enum_name RENAME VALUE 'old value' TO 'new value'

# select * from pg_enum;
  oid  | enumtypid | enumsortorder | enumlabel 
-------+-----------+---------------+-----------
 16566 |     16564 |             1 | value1
 16568 |     16564 |             2 | value2
 16569 |     16564 |           1.5 | value3
(3 rows)
</div><h3>텍스트 검색</h3><ul><li>tsvector : 정렬된 어휘소 목록. 정렬과 중복 제거는 자동으로 수행되지만, 정규화는 자동으로 수행되지 않는다<p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql"># select 'SQL 표준의 BLOB과 유사한 타입을 bytea로 지원한다'::tsvector;
                            tsvector                            
----------------------------------------------------------------
 'BLOB과' 'SQL' 'bytea로' '유사한' '지원한다' '타입을' '표준의'
(1 row)

# select to_tsvector('SQL 표준의 BLOB과 유사한 타입을 bytea로 지원한다');
                                 to_tsvector                                  
------------------------------------------------------------------------------
 'blob과':3 'bytea로':6 'sql':1 '유사한':4 '지원한다':7 '타입을':5 '표준의':2
(1 row)</div></li><li>tsquery : 어휘소 검색 정보<ul><li>a &amp; b : a and b</li><li>a | b : a or b</li><li>!a : not a</li><li>a &lt;-&gt; b : a followed by b</li><li>a &lt;N&gt; b : a followed by b within N distance</li><li>접두어 매칭 : 'xxx:*'::tsquery</li><li>정규화 : to_tsquery('original query')<p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql"># SELECT to_tsvector( 'postgraduate' ) @@ to_tsquery( 'postgres:*' );
 ?column? 
----------
 t
(1 row)

# SELECT to_tsvector( 'postgraduate' ), to_tsquery( 'postgres:*' );
  to_tsvector  | to_tsquery 
---------------+------------
 'postgradu':1 | 'postgr':*
(1 row)
</div></li></ul></li></ul><h3>JSON</h3><ul><li>json : 입력 텍스트 그대로 저장. JSON 연산 시 매번 파싱 필요</li><li>jsonb : 바이너리로 저장. JSONB 연산 매우 빠름<p>전용 인덱스 지원</p><ul><li>create index ... using gin (jsonb_col) : 키-존재 연산자 ?, ?|, ?&amp;, 포함 연산자 @>, jsonpath 일치 연산자 @?, @@ 연산자 지원</li><li>using gin (jsonb_col jsonb_path_ops) : @>, @?, @@ 연산자만 지원하지만, 크기가 훨씬 작고 검색 성능도 더 좋다(지원하는 연산자에 한해)</li><li>using gin ((jsonb_col -> 'prop')) : 보다 좋은 성능을 위해 인덱스 범위를 좁힐 수 있다</li></ul></li><li>jsonb 첨자를 이용한 할당 시, 경로가 정의되지 않은 경우 첨자가 암시하는 유형의 빈 값인 것처럼 진행된다<p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql"># create temp table test (x) as ( values (null::jsonb), ('{}'::jsonb) );
SELECT 2

# update test set x['a'][1]['b'] = '1' returning *;
            x            
-------------------------
 {"a": [null, {"b": 1}]}
 {"a": [null, {"b": 1}]}
(2 rows)

UPDATE 2</div></li><li>jsonpath (SQL/JSON path)<ul><li>variable<ul><li>$ : 쿼리 대상 객체</li><li>$varname : 함수 인자로 설정한 변수</li><li>@ : 경로 매칭 후 필터 표현식에서 참조하는 결과 객체</li></ul></li><li>accessor<ul><li>.key, ."$varname" : 특정 속성 접근</li><li>.* : 전체 멤버 접근</li><li>.** : 재귀적으로 전체 멤버 접근<p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql"># select jsonb_path_query('{"a":{"b":{"c":1}}}', '$.*');
 jsonb_path_query 
------------------
 {"b": {"c": 1}}
(1 row)

# select jsonb_path_query('{"a":{"b":{"c":1}}}', '$.**');
    jsonb_path_query    
------------------------
 {"a": {"b": {"c": 1}}}
 {"b": {"c": 1}}
 {"c": 1}
 1
(4 rows)

# select jsonb_path_query('[1,[2,[3]]]', '$.*');
 jsonb_path_query 
------------------
(0 rows)

# select jsonb_path_query('[1,[2,[3]]]', '$.**');
 jsonb_path_query 
------------------
 [1, [2, [3]]]
 1
 [2, [3]]
 2
 [3]
 3
(6 rows)</div></li><li>.**{level}, .**(start to end) : 지정 레벨(0부터 시작) 순회 결과만 반환</li><li>[subscript, ...] : 배열 요소 접근<p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql"># select jsonb_path_query('[1,2,3,4,5]', '$[0, last, 2 to last-1]');
 jsonb_path_query 
------------------
 1
 5
 3
 4
(4 rows)</div></li><li>[*] : 배열 모든 요소 접근</li></ul></li><li>operator and method<p>jsonpath 평가 결과에 대해 추가 연산을 수행할 수 있다</p><ul><li>JavaScript 산술 연산 : +, -, *, /, %</li><li>value.type() : JSON 타입 반환</li><li>value.size() : 배열이 아니어도 1 반환됨에 유의<p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql"># select jsonb_path_query('[]', '$.size()'), jsonb_path_query('[1,2,3]', '$.size()'), jsonb_path_query('{}', '$.size()');
 jsonb_path_query | jsonb_path_query | jsonb_path_query 
------------------+------------------+------------------
 0                | 3                | 1
(1 row)</div></li><li>value.boolean() : boolean, string, numeric에 한해 boolean 변환<p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql"># select jsonb_path_query('[0, 1, false, true, "FalsE", "TruE"]', '$[*].boolean()');
 jsonb_path_query 
------------------
 false
 true
 false
 true
 false
 true
(6 rows)</div></li><li>value.string() : boolean, number, string, datetime을 string으로 변환</li><li>value.double() : number, string을 number로 변환. 기타 bigint(), decimal(), integer(), numeric() 지원</li><li>number값 전용 함수 : ceiling(), floor(), abs()</li><li>string값 전용 함수 : date(), timestamp(), timestamp_tz() 등</li><li>object.keyvalue() : 키-값 쌍 해체<p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql"># select jsonb_path_query('[{"a":1},{"a":1},{"b":{"c":2}}]', '$[*].keyvalue()');
             jsonb_path_query              
-------------------------------------------
 {"id": 16, "key": "a", "value": 1}
 {"id": 40, "key": "a", "value": 1}
 {"id": 64, "key": "b", "value": {"c": 2}}
(3 rows)</div></li></ul></li><li>filter ::= ? (condition)<ul><li>SQL/JSON은 부울 대수로 3상태를 가진다 : true, false, unknown</li><li>동등 비교 : ==, !=, &lt;&gt;</li><li>대소 비교 : &lt;, &lt;=, &gt;, &gt;=</li><li>부울 대수 연산 : &amp;&amp;, ||, !, is unknown<p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql"># select jsonb_path_query('[-1,1,"a"]', '$[*] ? ((@ > 0) is unknown)');
 jsonb_path_query 
------------------
 "a"
(1 row)</div></li><li>패턴 매칭<ul><li>정규표현식 : string_value like_regex pattern_string [flag flag_string]</li><li>접두 문자열 검사 : string_value starts with prefix_string</li><li>jsonpath 검사 : exists(path_expression)</li></ul></li></ul></li><li>필터는 조건을 만족하는 항목들을 반환하며, 일반 표현식으로 연결될 수 있다<p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql"># select jsonb_path_query('[
#   { "ISBN": "ISBN1", "title": "title1", "authors": ["author1", "author2"], "publishAt": "2000-01-01T00:00:00Z"},
#   { "ISBN": "ISBN2", "title": "title2", "authors": ["author3"], "publishAt": "2010-01-01T00:00:00Z"},
#   { "ISBN": "ISBN3", "title": "title1", "authors": ["author2"], "publishAt": "2020-01-01T00:00:00Z"}
# ]', '$[*] ? (@.publishAt.timestamp_tz() > "2009-12-31 18:00:00+09".timestamp_tz()) ? (exists(@.authors[*] ? (@ == "author3"))).ISBN');
 jsonb_path_query 
------------------
 "ISBN2"
(1 row)</div></li><li>PostgreSQL은 필터에서만 predicate을 이용할 수 있는 SQL/JSON과 다르게, path 자체에서도 허용한다. 이 경우 path 매칭 결과는 단일 boolean 값이다<p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql"># select jsonb_path_query('[1,2,3]', '$[*] > 2'), jsonb_path_query('[1,2,3]', '$[*] > 4'), jsonb_path_query('{}', '$[*] > 2');
 jsonb_path_query | jsonb_path_query | jsonb_path_query 
------------------+------------------+------------------
 true             | false            | null
(1 row)
</div></li></ul></li></ul><h3>배열</h3><ul><li>create table에서 지정한 배열의 길이, 차원 수는 현재 구현에서 무시된다</li><li>배열 입력 : '{ val1 delimiter val2 delimiter ... }'<ul><li>delimiter : box 형식에는 ';', 그 외 형식에는 ',' 사용</li><li>개별 값은 ""로 감쌀 수 있다</li></ul></li><li>배열 첨자는 1부터 시작<p>실제 배열 크기를 벗어나는 경우, 오류 대신 null 반환</p></li><li>[lower-bound:upper-bound]의 범위 접근(slice)도 가능하다<ul><li>연속되는 첨자 중 하나라도 slice면, 모든 첨자를 slice로 취급한다</li><li>lower-bound, upper-bound는 생략 가능</li></ul></li><li>첨자가 1부터 시작하지 않는 배열도 허용된다<p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql"># create temp table test (x) as (values ('{}'::int[]), ('{1,2}'::int[]), ('[-3:-2]={1,2}'::int[]) );
SELECT 3

# update test set x[3:4] = '{3,4}'::int[] returning *, x[-3:4];
                  x                   |               x               
--------------------------------------+-------------------------------
 [3:4]={3,4}                          | {3,4}
 {1,2,3,4}                            | {1,2,3,4}
 [-3:4]={1,2,NULL,NULL,NULL,NULL,3,4} | {1,2,NULL,NULL,NULL,NULL,3,4}
(3 rows)

UPDATE 3</div></li><li>배열 연결<span class="pos-span" id="pos-1241758052"></span><ul><li>N차원 배열에 N-1차원 요소를 연결하는 경우, N차원 배열의 lower bound는 유지된다</li><li>N차원 배열 2개를 연결하는 경우, 왼쪽 배열의 lower bound가 유지된다</li></ul><p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql"># select 1 || '[0:1]={2,3}'::int[] || 4;
    ?column?     
-----------------
 [0:3]={1,2,3,4}
(1 row)

# select '[3:4]={3,4}'::int[] || '[0:1]={0,1}'::int[];
    ?column?     
-----------------
 [3:6]={3,4,0,1}
(1 row)</div><p>미묘한 차이점</p><p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql"># select array_cat('[2:3]={1,2}'::int[], null);
  array_cat  
-------------
 [2:3]={1,2}
(1 row)

# select array_append('[2:3]={1,2}'::int[], null);
   array_append   
------------------
 [2:4]={1,2,NULL}
(1 row)

# select '[2:3]={1,2}'::int[] || null;
  ?column?   
-------------
 [2:3]={1,2}
(1 row)

# select '[2:3]={1,2}'::int[] || null::int;
     ?column?     
------------------
 [2:4]={1,2,NULL}
(1 row)
</div></li></ul><h3>복합 타입</h3><ul><li>기존 타입들을 결합하여 새로운 타입을 만들 수 있다. not null 같은 제약조건을 포함할 수 없다<p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql"># create type complex as ( r float, i float );
CREATE TYPE

# select (row(1, null)::complex).*;
 r |   i    
---+--------
 1 | (null)
(1 row)</div></li><li>테이블을 만들면 기본적으로 동일 이름의 복합 타입이 만들어진다. not null 같은 제약조건은 무시된다<p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql"># \pset null '(null)'
# create table test ( a int primary key, b boolean not null );
CREATE TABLE

# select (row(null, null)::test).*;
   a    |   b    
--------+--------
 (null) | (null)
(1 row)

# insert into test values (1, false);
INSERT 0 1

# select test from test;
 test  
-------
 (1,f)
(1 row)</div></li><li>복합 타입 참조는 테이블 참조와의 모호함을 피하기 위해 항상 ()를 사용하는 것이 좋다<p>행 수정 시 set 뒤의 열 이름에서는 불필요하다(넣을 수도 없다)</p></li><li>비용이 비싼 함수는 쿼리 당 1번만 호출하도록 해야 한다<p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql"># \pset null '(null)'
# create table test ( a int primary key, b boolean not null );
CREATE TABLE

# insert into test values (1, false);
INSERT 0 1

# create or replace function func(t test) returns test as $$
# begin
#     raise notice using message = 'func called';
#     t.a = t.a + 1;
#     t.b = not(t.b);
#     return t;
# end;
# $$ language plpgsql;
CREATE FUNCTION

# select (func(test)).* from test;
-- 또는 select (func(test.*)).* from test;
-- 또는 select (test.func).* from test;
NOTICE:  func called
NOTICE:  func called
 a | b 
---+---
 2 | t
(1 row)

# select (x).* from test, lateral func(test) as x;
NOTICE:  func called
 a | b 
---+---
 2 | t
(1 row)
</div></li></ul><h3>범위 타입</h3><ul><li>모든 범위 타입은 대응하는 다중 범위 타입이 있다 : 연속하지 않는 범위 목록</li><li>integer에 대한 범위 : int4range, int4multirange</li><li>bigint에 대한 범위 : int8range, int8multirange</li><li>numeric에 대한 범위 : numrange, nummultirange</li><li>timestamp에 대한 범위 : tsrange, tsmultirange</li><li>timestamptz에 대한 범위 : tstzrange, tstzmultirange</li><li>date에 대한 범위 : daterange, datemultirange</li><li>상/하한을 명시하지 않으면 +/-무한대를 의미한다</li><li>아무것도 포함하지 않는 빈 범위 예. 'empty'::int4range</li></ul><p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql"># select '[1, 4)'::int4range @> 1, '[1, 4)'::int4range @> 4;
 ?column? | ?column? 
----------+----------
 t        | f
(1 row)</div><p><strong>↓ 범위에 대한 제약 조건</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">CREATE TABLE reservation (
    during tsrange,
    EXCLUDE USING GIST (during WITH &&)
);

CREATE EXTENSION btree_gist;
CREATE TABLE room_reservation (
    room text,
    during tsrange,
    EXCLUDE USING GIST (room WITH =, during WITH &&)
);
</div><h3>도메인 타입</h3><p>다른 기본 타입에 대한 부분 집합으로 정의하는 사용자 정의 형식</p><p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">CREATE DOMAIN posint AS integer CHECK (VALUE > 0);</div><h3>의사 타입</h3><p>열 타입으로 사용할 순 없지만 함수 인자 또는 반환 타입으로 사용 가능</p><ul><li>any : 임의 유형</li><li>anyarray : 임의 배열</li><li>record : 임의 행</li><li>trigger : 트리거 함수의 반환 타입</li><li>void : 반환 없음</li><li>unknown : 타입이 정해지지 않은 리터럴</li><li>등등</li></ul></div><h2>함수와 연산자</h2><div><h3>논리 연산자</h3><p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql"># with tmp1 (x) as ( values (true), (false), (null) ),
# tmp2 as ( select t1.x, t2.x y from tmp1 t1, tmp1 t2 )
# select x, y, x and y as "x and y", x or y as "x or y", not x as "not x"
# from tmp2 order by x desc nulls last, y desc nulls last;
   x    |   y    | x and y | x or y | not x  
--------+--------+---------+--------+--------
 t      | t      | t       | t      | f
 t      | f      | f       | t      | f
 t      | (null) | (null)  | t      | f
 f      | t      | f       | t      | t
 f      | f      | f       | f      | t
 f      | (null) | f       | (null) | t
 (null) | t      | (null)  | t      | (null)
 (null) | f      | f       | (null) | (null)
 (null) | (null) | (null)  | (null) | (null)
(9 rows)
</div><h3>비교 함수 및 연산자</h3><ul><li>null을 비교 가능한 값으로 취급하지 않는 경우, 비교 연산자는 두 피연산자 중 하나라도 null이면 null을 반환</li><li>&lt;&gt;는 같지 않음을 비교하는 SQL 표준 표기로, !=는 구문 분석 단계에서 &lt;&gt;로 변환된다</li><li>비교 술어<ul><li>a between b and c : a &gt;= b and a &lt; c와 동일하다</li><li>a not between b and c</li><li>a between symmetric b and c : a가 b와 c 사이의 중간값인지? b와 c의 대소 관계는 결과와 무관하다</li><li>a not between symmetric b and c</li><li>a is distinct from b : a와 b가 같은지? null도 비교 가능한 값으로 처리</li><li>a is not distinct from b</li><li>a is [not] null</li><li>boolean is [not] true, is [not] false, is [not] unknown</li></ul></li></ul><h3>수학 함수 및 연산자</h3><ul><li>a / b, div(a, b) : 정수에 대한 나눗셈 결과는 0에 가깝게 소수점이 버려진다</li><li>a % b, mod(a, b) : 정수 modulo 연산</li><li>a ^ b, power(a, b) : a의 b 제곱</li><li>|/a, sqrt(a) : 제곱근</li><li>||/a, cbrt(a) : 세제곱근</li><li>@a, abs(a) : 절댓값</li><li>a &amp; b : 비트 and</li><li>a | b : 비트 or</li><li>a # b : 비트 xor</li><li>~a : 비트 not</li><li>a &lt;&lt; b : 비트 shift left</li><li>a &gt;&gt; b : 비트 shift right</li><li>ceil(a) : a 이상의 최소 정수</li><li>gcd(a, b) : 최대공약수</li><li>등등</li></ul><h3>문자열 함수 및 연산자</h3><ul><li>a || b : 문자열 연결</li><li>concat(val1[, val2 ...]) : null을 제외한 모든 인자의 텍스트 표현 연결</li><li>concat_ws(seperator, val1[, val2 ...]) : with seperator</li><li>a ^@ b, starts_with(a, b) : a는 b로 시작하는지?</li><li>a like pattern : 전체 a가 pattern과 일치하는지? 패턴에 %(임의 길이 문자열), _(임의 1개 문자) 사용 가능<ul><li>a ~~ b, a like b</li><li>a !~~ b, a not like b</li><li>a ~~* b, a ilike b</li><li>a !~~* b, a not ilike b</li></ul></li><li>regexp_like(a, pattern[, flags]) : POSIX 패턴이 매칭되는지?<ul><li>a ~ b, regexp_like(a, b)</li><li>a ~* b, regexp_like(a, b, 'i')</li><li>a !~ b, not(regexp_like(a, b))</li><li>a !~* b, not(regexp_like(a, b, 'i'))</li></ul></li><li>regexp_match, regexp_matches(a, pattern[, flags]) : 패턴 매칭 결과 반환</li><li>trim([leading | trailing | both] [characters] from string) : 공백(또는 지정 characters) 제거</li><li>string is [not] [NFC | NFD | NFKC | NFKD] normalized : UTF-8 유니코드 정규화 테스트</li><li>substring(string [from start] [for count]) : [시작 위치]와 [문자 개수]로 부분 문자열 추출</li><li>left(string, n), right(string, n) : n에 음수 사용 가능</li><li>substring(string from pattern) : POSIX 정규표현식에 일치하는 첫 번째 문자열 반환</li><li>등등</li></ul><h3>날짜/시간 함수 및 연산자</h3><ul><li>+, * 연산자는 교환 법칙이 성립한다<ul><li>date + integer → date</li><li>date - date → integer</li><li>date + interval → timestamp</li><li>date + time → timestamp</li><li>interval + interval → interval</li><li>timestamp + interval → timestamp</li><li>timestamp - timestamp → interval</li><li>time + interval → time</li><li>time - time → interval</li><li>-interval → interval</li><li>interval * double precision → interval</li></ul></li><li>isfinite( date | timestamp | interval )</li><li>make_date / interval / time / timestamp / timestamptz</li><li>to_timestamp(double) : 초 단위 Unix 타임스탬프를 timestamptz로 변환</li><li>일광 절약 시간제가 적용되는 시간대에 대해 '1 day'::interval, '24 hour'::interval을 더하고 뺀 결과는 다를 수 있다</li><li>extract(field from source)<ul><li>day : day of the month (1~31)</li><li>dow : day of the week 일요일(0) ~ 토요일(6)</li><li>isodow : 월요일(1) ~ 일요일(7)</li><li>doy : day of the year (1~366)</li><li>epoch : 초 단위 Unix timestamp</li><li>timezone : 초 단위 offset</li><li>등등</li></ul></li><li>date_trunc(field, source[, timezone]) : 지정한 정밀도 미만의 값 버림</li><li>at time zone<ul><li>timestamp at time zone x → timestamptz : 벽시계 값에 시간대 부여</li><li>timestamptz at time zone x → timestamp : 동일한 시각을 지정한 시간대에서 볼 때 읽히는 벽시계 값 반환</li></ul></li><li>현재 날짜/시간<ul><li>현재 트랜잭션 시작 시각 : current_date / time / time(precision) / timestamp /timestamp(precision)</li><li>current_timestamp = transaction_timestamp() = now()</li><li>statement_timestamp() : 명령 수신 시각</li><li>clock_timestamp() : 현재 시각</li></ul></li></ul><h3>enum 함수</h3><ul><li>enum_range(x) : 정의된 순서대로 값 배열 반환</li><li>enum_range(x, y) : 정의된 순서대로, x ~ y 사이 값 배열 반환. x/y에 null을 설정하면 lower/upper bound 없는 걸로 간주</li></ul><h3>기하 함수 및 연산자</h3><p>평행 이동, 충돌 감지, 특성값 추출 등</p><h3>네트워크 주소 함수 및 연산자</h3><p>서브넷 마스크 평가 등</p><h3>텍스트 검색 함수 및 연산자</h3><ul><li>tsvector @@ tsquery, tsquery @@ tsvector : 벡터가 쿼리에 매칭되는지?</li><li>text @@ tsquery : to_tsvector(text)가 쿼리에 매칭되는지?</li><li>ts_rank, ts_rank_cd(vector, query) : 벡터가 쿼리에 얼마나 매칭되는지?</li><li>tsvector || tsvector : 벡터 결합</li><li>tsquery &amp;&amp; tsquery : 쿼리 and</li><li>tsquery || tsquery : 쿼리 or</li><li>!!tsquery : 쿼리 not</li><li>tsquery &lt;-&gt; tsquery, tsquery_phrase(query1, query2) : query1 바로 뒤에 query2가 이어지는 쿼리 반환</li><li>tsquery_phrase(query1, query2, distance) : query1과 query2 거리가 distance인 쿼리 반환</li><li>tsquery @&gt; tsquery : 후자의 모든 어휘소가 전자에 존재하는지?</li><li>tsquery &lt;@ tsquery : 전자의 모든 어휘소가 후자에 존재하는지?</li><li>array_to_tsvector(text[]) : 입력 문자열을 별도 처리 없이 그대로 어휘소로 사용</li><li>to_tsquery([ config regconfig, ] query text) : 입력 문자열을 정규화하여 tsquery로 변환</li><li>to_tsvector([ config regconfig, ] document text) : 입력 문자열을 정규화하고 위치 정보를 포함한 tsvector로 변환</li><li>tsvector_to_array(tsvector) → text[] : 어휘소 배열 반환</li><li>unnest(tsvector) → setof record( lexeme text, positions smallint[], weights text )</li></ul><h3>JSON 함수 및 연산자</h3><ul><li>json/jsonb -> integer : 배열 요소 추출. 음수 인덱스 지원</li><li>json/jsonb ->> integer : text로 추출</li><li>json/jsonb -> text : 객체 필드 추출</li><li>json/jsonb ->> text : text로 추출</li><li>json/jsonb #> text[] : 지정 경로의 값 추출</li><li>json/jsonb #>> text[] : text로 추출</li><li>jsonb @> jsonb : 전자가 후자를 모두 포함하는지?</li><li>jsonb &lt;@ jsonb : 후자가 전자를 모두 포함하는지?<ul><li>스칼라 : 값이 같은지?</li><li>배열 : 모든 원소를 갖는지?</li><li>객체 : 모든 키-값 쌍을 가지는지?</li></ul></li><li>jsonb ? text : 해당 텍스트를 객체의 키 또는 배열 요소로 갖는지?</li><li>jsonb ?| text[] : 텍스트 배열 중 하나라도 객체의 키 또는 배열 요소로 존재하는지?</li><li>jsonb ?&amp; text[] : 텍스트 배열의 모든 텍스트가 객체의 키 또는 배열 요소로 존재하는지?</li><li>jsonb || jsonb : 객체의 경우 Object.assign(전자, 후자). 그 외의 경우 배열 접합으로 처리</li><li>jsonb - text : 객체의 경우 해당하는 키-값 쌍 삭제. 배열의 경우 일치하는 요소 전부 삭제</li><li>jsonb - text[] : 배열 각 텍스트에 대해 jsonb - text 수행한 것과 동일</li><li>jsonb - integer : 배열의 지정 인덱스(음수 가능) 요소 삭제</li><li>jsonb #- text[] : 지정 경로의 필드 또는 배열 요소 삭제</li><li>json/jsonb 생성<ul><li>to_json, to_jsonb(any) : 일부 타입에 대해선 에러가 발생하는 형변환과 달리, 타입이 정해진 모든 값에 대해 성공</li><li>json_array(any[, ...]) : JSON 배열 생성</li><li>json_array(query) : 단일 열을 반환하는 SELECT 쿼리 결과로부터 JSON 배열 생성</li><li>json_build_object, jsonb_build_object(key, value[, key, value ...]) : 키-값 쌍으로 객체 생성</li><li>json_object(key {value|:} value[, ...]) : 키-값 쌍으로 객체 생성<p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">select json_object(1 value 2,3:4)</div></li><li>json_object, jsonb_object(text[]) : 키-값 쌍으로 객체 생성</li><li>json_object, jsonb_object(keys text[], values text[]) : 키-값 쌍으로 객체 생성</li></ul></li><li>json/jsonb 처리<ul><li>json[b]_typeof(json[b]) : JSON 값 유형 반환</li><li>jsonb_set(target jsonb, path text[], new_value jsonb[, create_if_missing boolean]) : jsonb 변경</li><li>json[b]_to_record(json[b]) as x(col type[, ...]) → record : 객체를 행으로 변환</li><li>json[b]_array_elements(json[b]) → setof json[b] : 배열을 행집합으로 확장</li><li>json[b]_array_elements_text(json[b]) → setof text : 배열을 text 행집합으로 확장</li><li>json[b]_array_length(json) : 배열 길이</li><li>json[b]_each(json) → setof record(key text, value json[b]) : 객체를 키-값 행집합으로 확장</li><li>json[b]_each_text(json) → setof record(key text, value text) : 객체를 키-값(text) 행집합으로 확장</li><li>등등</li></ul></li><li>jsonpath 관련<ul><li>jsonb_path_query(target jsonb, path jsonpath[, vars jsonb]) → setof jsonb : 경로 매칭 결과 행집합으로 반환</li><li>jsonb_path_query_array(target jsonb, path jsonpath[, vars jsonb]) → jsonb : 경로 매칭 결과 jsonb 배열로 반환</li><li>jsonb_path_query_first(target jsonb, path jsonpath[, vars jsonb]) → jsonb : 첫 번째 경로 매칭 결과 반환</li><li>json_query(json[b], jsonpath [passing value as varname [, ...]][ returning data_type ][생략]) : 경로 매칭 결과 jsonb 또는 지정 타입으로 반환</li><li>json_value(json[b], jsonpath [passing value as varname [, ...]][ returning data_type ][생략]) : 경로 매칭 결과가 단일 스칼라 값이라면 text 또는 지정 타입으로 반환<p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql"># select jsonb_path_query('[1,2,3,4,5]', '$[*] ? ($min &lt;= @ &amp;&amp; @ &lt;= $max)', '{"min":2, "max":4}');
 jsonb_path_query 
------------------
 2
 3
 4
(3 rows)

# select jsonb_path_query_array('[1,2,3,4,5]', '$[*] ? ($min &lt;= @ &amp;&amp; @ &lt;= $max)', '{"min":2, "max":4}');
 jsonb_path_query_array 
------------------------
 [2, 3, 4]
(1 row)

# select jsonb_path_query_first('[1,2,3,4,5]', '$[*] ? ($min &lt;= @ &amp;&amp; @ &lt;= $max)', '{"min":2, "max":4}');
 jsonb_path_query_first 
------------------------
 2
(1 row)

# select json_query('[1,2,3,4,5]'::json, '$[*] ? ($min &lt;= @ &amp;&amp; @ &lt;= $max)' passing 2 as min, 4 as max with conditional wrapper);
 json_query 
------------
 [2, 3, 4]
(1 row)

# select json_value('[1,2,3,4,5]'::json, '$[2]');
 json_value 
------------
 3
(1 row)</div></li><li>json_exists(json[b], jsonpath [passing value as varname [, ...]]) : 지정 경로에 해당하는 항목이 있는지?<p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql"># select n, json_exists('[1,2,3]'::json, '$[*] ? (@ >= $x)' passing n as x) from generate_series(1, 5) as tmp (n);
 n | json_exists 
---+-------------
 1 | t
 2 | t
 3 | t
 4 | f
 5 | f
(5 rows)</div></li><li>jsonb @? jsonpath : 지정 경로에 해당하는 항목이 있는지? SQL/JSON 표준 jsonpath 이용</li><li>jsonb @@ jsonpath : 지정 경로에 해당하는 항목이 있는지? PostgreSQL 전용 predicate jsonpath 이용<p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql"># select '[1,2,3]'::jsonb @? '$[*] ? (@ > 0)', '[1,2,3]'::jsonb @? '$[*] ? (@ > 3)';
 ?column? | ?column? 
----------+----------
 t        | f
(1 row)

# select '[1,2,3]'::jsonb @@ '$[*] > 0', '[1,2,3]'::jsonb @@ '$[*] > 3';
 ?column? | ?column? 
----------+----------
 t        | f
(1 row)</div></li><li>jsonb_path_exists(target jsonb, path jsonpath[, vars jsonb]) : 지정 경로에 해당하는 항목이 있는지? SQL/JSON 표준 jsonpath 이용</li><li>jsonb_path_match(target jsonb, path jsonpath[, vars jsonb]) : 지정 경로에 해당하는 항목이 있는지? PostgreSQL 전용 predicate jsonpath 이용</li></ul></li></ul><h3>시퀀스 함수</h3><ul><li>nextval(regclass) : 시퀀스를 진행시키고 값을 반환</li><li>currval(regclass) : 현재 세션에서 nextval을 호출한 적이 있는 경우, 마지막으로 획득한 값 반환</li><li>lastval() : 현재 세션에서 마지막으로 호출한 nextval 반환값 그대로 반환</li><li>setval(regclass, bigint) : 시퀀스 현재 값 변경</li></ul><h3>조건 표현문</h3><ul><li>case when condition then result [when ...] [else result] end</li><li>coalesce(value[, ...]) : null이 아닌 첫 번째 매개변수 반환</li><li>nullif(value1, value2) : value1 = value2면 null 반환. 아니면 value1 반환</li><li>greatest(value[, ...]) : 가장 큰 값 반환</li><li>least(value[, ...]) : 가장 작은 값 반환</li></ul><h3>배열 함수 및 연산자</h3><ul><li>unnest(arr[, arr [...]]) : 배열을 행 집합으로 확장</li><li>arr @> arr : 후자의 모든 원소가 전자에서도 등장하는지?</li><li>arr &lt;@ arr</li><li>arr &amp;&amp; arr : 두 배열 중 공통 원소가 하나라도 존재하는지?</li><li><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos-1241758052" target="_self">배열 연결</a> : x || x, array_cat(x, x), array_append(arr, x), array_prepend(x, arr)</li><li>array_fill(x, lengthArr[, lowerBoundArr]) : 주어진 상수로 채운 배열 생성</li><li>cardinality(arr) : 전체 요소 개수 반환</li><li>array_dims(arr) : 배열 차원에 대한 text 표기 반환</li><li>array_ndims(arr) : 차원 수 반환</li><li>array_length(arr, dim) : 지정 차원의 길이 반환. 지정 차원에 해당하는 원소가 없으면 null</li><li>array_lower(arr, dim) : 지정 차원의 lower bound 반환</li><li>array_upper(arr, dim)</li><li>array_position(arr, x[, start]) : 1차원 배열에서, 지정 값이 발견되는 최초 subscript 반환(비교는 is not distinct from으로 수행)</li><li>array_positions(arr, x) : 1차원 배열에서, 지정 값이 발견되는 모든 subscript 배열 반환(비교는 is not distinct from으로 수행)</li><li>array_remove(arr, x) : 1차원 배열에서, 지정 값 모두 제거(비교는 is not distinct from으로 수행)</li><li>array_replace(arr, x, y) : n차원 배열에서, 지정 값 모두 교체</li><li>array_reverse(arr) : 첫 번째 차원을 뒤집은 배열 반환</li><li>array_sample(arr, n) : 비복원 추출 수행</li><li>array_shuffle(arr)</li><li>array_to_string(arr, delimiter[, null_string])</li></ul><h3>range/multirange 함수 및 연산자</h3><ul><li>range @> range, range @> x : 전자가 후자를 포함하는지?</li><li>range &lt;@ range, x &lt;@ range</li><li>range &amp;&amp; range : 겹치는 원소가 하나라도 존재하는지?</li><li>range &lt;&lt; range : 전자가 엄격하게 후자의 왼쪽에 있는지?</li><li>range >> range</li><li>range &amp;&lt; range : 전자의 상한이 후자보다 크지 않으면 true</li><li>range &amp;> range : 전자의 하한이 후자보다 작지 않으면 true<p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql"># select '(1, 10]'::numrange &amp;> '[1, 10]'::numrange;
 ?column? 
----------
 t
(1 row)

# select '[1, 10]'::numrange &amp;> '(1, 10]'::numrange;
 ?column? 
----------
 f
(1 row)</div></li><li>range -|- range : 두 범위가 빈틈없이 이어지는지?<p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql"># select '(3, 10]'::numrange -|- '[1, 3]'::numrange;
 ?column? 
----------
 t
(1 row)

# select '[3, 10]'::numrange -|- '[1, 3]'::numrange;
 ?column? 
----------
 f</div></li><li>range + range : 범위 합치기. 두 범위 사이에 간격이 있으면 에러 발생</li><li>range_merge(range, range) : 두 범위를 모두 포함하는 최소 범위 반환</li><li>range * range : 공통 범위 추출</li><li>range - range : 전자에서 공통 범위 제거</li><li>isempty(range) : 빈 범위인지?</li><li>lower(range) : 하한 반환</li><li>lower_inc(range) : lower(range)가 범위에 포함되는지?<p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql"># select lower('(1, 3)'::int4range), lower_inc('(1, 3)'::int4range);
 lower | lower_inc 
-------+-----------
     2 | t
(1 row)

# select lower('(1, 3)'::numrange), lower_inc('(1, 3)'::numrange);
 lower | lower_inc 
-------+-----------
     1 | f
(1 row)</div></li><li>lower_inf(range) : 하한이 무한대인지?</li><li>unnest(multirange) : range 행집합으로 확산</li><li>등</li></ul><h3>집계 함수</h3><ul><li>any_value(x) : non-null인 값 하나</li><li>max(x) : 최댓값</li><li>min(x) : 최솟값</li><li>mode() within group (order by x) : 최빈값</li><li>avg(x) : 모든 non-null값에 대한 산술 평균</li><li>percentile_disc(percent or percent_agg) within group (order by x) : 지정 백분율의 자료 검색 -- 없으면 가장 가까운 자료</li><li>percentile_cont(percent or percent_agg) within group (order by x) : 지정 백분율의 자료 검색 -- 없으면 보간<p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql"># select percentile_disc('{0.3,0.6,0.9}'::float[]) within group (order by n)
# from (values (1), (3), (10), (100)) as x(n);
 percentile_disc 
-----------------
 {3,10,100}
(1 row)

# select percentile_cont('{0.3,0.6,0.9}'::float[]) within group (order by n)
# from (values (1), (3), (10), (100)) as x(n);
 percentile_cont 
-----------------
 {2.8,8.6,73}
(1 row)</div></li><li>rank(y) within group (order by x) : y가 x들 중에선 몇 등인지? 동점이 존재하는 경우, 피어 그룹의 첫 번째 행 번호와 같다</li><li>dense_rank(y) within group (order by x) : y가 x들 중에선 몇 등인지? 피어 그룹 단위로 카운트</li><li>percent_rank(y) within group (order by x) : (rank() - 1) / (전체 행 개수 - 1)</li><li>cume_dist(y) within group (order by x) : (y이하 행 개수) / (전체 행 개수)<p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql"># select
#   n1,
#   rank(n1) within group (order by n2),
#   dense_rank(n1) within group (order by n2),
#   percent_rank(n1) within group (order by n2),
#   cume_dist(n1) within group (order by n2)
# from
#   (values (0), (10), (20), (30)) as x1(n1),
#   (values (10), (20), (10)) as x2(n2)
# group by n1;
 n1 | rank | dense_rank |    percent_rank    | cume_dist 
----+------+------------+--------------------+-----------
  0 |    1 |          1 |                  0 |      0.25
 10 |    1 |          1 |                  0 |      0.75
 20 |    3 |          2 | 0.6666666666666666 |         1
 30 |    4 |          3 |                  1 |         1
(4 rows)</div></li><li>corr(y, x) : 상관 계수</li><li>stddev(x) : 표준 편차</li><li>variance(x) : 분산</li><li>count(*) : 행 개수</li><li>count(x) : non-null인 행 개수</li><li>bit_and, bit_or, bit_xor(x) : 모든 non-null 값에 대해 한 번씩 비트 연산 수행</li><li>bool_and(x) : 모든 non-null 값이 true면 true</li><li>bool_or(x) : non-null 값이 하나라도 true면 true</li><li>string_agg(x, delimiter) : 문자열 하나로 축약</li><li>array_agg(x [order by sort_columns]) : 모든 값을 담은 배열</li><li>json[b]_agg(x [order by sort_columns]) : 모든 값을 담은 JSON[B] 배열</li><li>json[b]_agg_strict(x [order by sort_columns]) : 모든 non-null 값을 담은 JSON[B] 배열</li><li>json[b]_object_agg(key, value [order by sort_columns]) : 모든 행을 하나의 JSON[B] 객체로 축약 -- 키는 null 비허용(에러)</li><li>json[b]_object_agg_strict(key, value [order by sort_columns]) : value가 non-null인 모든 행을 하나의 JSON[B] 객체로 축약 -- 키는 null 비허용(에러)</li><li>json[b]_object_agg_unique[_strict] : 중복 키 발견 시 에러 발생</li><li>grouping (group_by_expression) : 복잡한 grouping sets을 이용하는 경우, 어떤 그룹에 대한 집계인지 쉽게 식별 가능하도록 전용 컬럼 추가<p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql"># select grouping(a, b, c), a, b, c
# from (values ('a', 'b', 'c')) as x(a, b, c)
# group by cube (a, b, c)
# order by 1;
 grouping | a | b | c 
----------+---+---+---
        0 | a | b | c
        1 | a | b | 
        2 | a |   | c
        3 | a |   | 
        4 |   | b | c
        5 |   | b | 
        6 |   |   | c
        7 |   |   | 
(8 rows)</div></li><li>등</li></ul><h3>윈도 함수</h3><ul><li>row_number() : 행 번호</li><li>rank() : 순위. 동점이 존재하는 경우, 피어 그룹의 첫 번째 행 번호</li><li>dense_rank() : 피어 그룹 단위 순위</li><li>percent_rank() : (rank - 1) / (전체 행 개수 - 1)</li><li>cume_dist() : (동점 이하의 모든 행 개수) / (전체 행 개수)</li><li>ntile(n) : 정렬된 파티션을 크기가 균일한 n개 버킷으로 나눌 때, 행이 할당된 버킷 번호</li><li>lag(value[, offset[, default]]) : offset 전의 행 참조</li><li>lead(value[, offset[, default]]) : offset 후의 행 참조<p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql"># select n, lag(n, 1, 0) over win, lead(n, 1, 0) over win
# from (values (1),(3),(2)) as t(n)
# window win as (order by n);
 n | lag | lead 
---+-----+------
 1 |   0 |    2
 2 |   1 |    3
 3 |   2 |    0
(3 rows)</div></li><li>first_value(value) : 첫 번째 행 참조</li><li>last_value(value) : 마지막 행 참조</li><li>nth_value(value, n) : n번째 행 참조</li></ul><h3>merge 지원 함수</h3><ul><li>merge_action() : merge 명령 returning 절에서 사용하면 'INSERT' | 'UPDATE' | 'DELETE' 설정</li></ul><h3>서브쿼리 표현</h3><ul><li>exists(subquery) : 서브쿼리가 행을 하나라도 발견하는지?</li><li>expression [not] in (subquery) : expression 평가값이 서브쿼리 결과에 포함 [안] 하는지?</li><li>expression operator {any | some} (subquery) : 주어진 연산자가 true를 반환하는 행이 하나라도 있는지?</li><li>expression operator all (subquery) : 주어진 연산자가 모든 행에 대해 true를 반환하는지?</li><li>row_constructor operator (subquery) : 행이 일치하는지?</li></ul><h3>행, 배열을 이용한 비교</h3><ul><li>expression [not] in (value[, ...]) : expression 평가값이 나열된 값 중에 존재 [안] 하는지?</li><li>expression operator {any | some} (array) : 주어진 연산자가 true를 반환하는 배열 요소가 하나라도 있는지?</li><li>expression operator all (array) : 주어진 연산자가 모든 배열 요소에 대해 true를 반환하는지?</li><li>row_constructor operator row_constructor : 컬럼 순서대로 operator 평가(short-circuit)</li></ul><h3>집합 반환 함수</h3><ul><li>generate_series(start, stop[, step]) → setof (integer | bigint | numeric | timestamp | timestamptz)</li><li>with ordinality : 행 번호 부여<p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql"># select * from generate_series(
#   '2025-11-01 00:00:00 America/Los_Angeles',
#   '2025-11-04 00:00:00 America/Los_Angeles',
#   '1 day'::interval,
#   'America/Los_Angeles'
# ) with ordinality as tmp(t, n);
           t            | n 
------------------------+---
 2025-11-01 16:00:00+09 | 1
 2025-11-02 16:00:00+09 | 2
 2025-11-03 17:00:00+09 | 3
 2025-11-04 17:00:00+09 | 4
(4 rows)
</div></li></ul><h3>시스템 함수</h3><ul><li>current_query() : 현재 실행 중인 쿼리</li><li>current_user : 현재 실행 유저</li><li>pg_backend_pid() : 쿼리 실행 pid</li><li>has_column_privilege([user, ]table, column, privilege)</li><li>pg_typeof(x) : 타입 반환</li><li>to_regclass(text), to_regtype(text) 등 : 테이블 등의 이름을 이용해 관련 OID 반환</li><li>pg_cancel_backend(pid) : 쿼리 실행 취소</li><li>pg_terminate_backend(pid) : 쿼리 실행 종료</li><li>등</li></ul></div><h2>인덱스</h2><ul><li>B-tree 인덱스를 정의하면서 고유성을 강제할 수 있다. 예를 들어<p><strong>↓ sql</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="sql">create unique index test_lower_col1_idx on test1 (lower(col1))</div>는 col1 값이 대소문자 구별 없이 동일한 행이 2개 이상 존재하는 걸 효율적으로 방지할 수 있다</li><li>가능하다면 부분 인덱스 조건은 쿼리 where 조건에서 그대로 등장해야 한다. 그렇지 않으면 인덱스가 사용되지 않을 수 있다<ul><li>PostgreSQL에는 서로 다른 형태로 작성된 표현식이 수학적으로 동등한지 인식하는 기능은 없다</li><li>조건식 매칭은 쿼리 실행 시간이 아니라 쿼리 계획 시간에 이루어지기 때문에, x > ? 같은 준비된 쿼리는 실제 매개변수가 2여도 x > 2 조건의 인덱스를 사용하지 않는다</li></ul></li><li>부분 인덱스는 파티셔닝 대용으로 적합하지 않다 : 시스템이 부분 인덱스 간 관계를 따로 이해하고 있지 않으므로, 쿼리에 적용 가능한지 여부를 일일이 검사해야 한다</li><li>인덱스 정의에만 존재하는 컬럼을 SELECT하는 경우, 인덱스 정보만으로 결과를 구성하는 index-only scan이 발생할 수 있다.<p>단, 행이 실제로 유효하다는 것을 확인하기 때문에 행이 빈번히 수정되는 경우엔 표준 인덱스 스캔에 비해 성능 이점이 없다</p></li></ul><h2>전문 검색</h2><div></div><h2>동시성 제어</h2><div></div><h2>성능 팁</h2><div></div><h2>병렬 쿼리</h2><div></div></div><h1>서버 관리</h1><div><h2>복제</h2></div><h1>서버 프로그래밍</h1><div><h2>PL/pgSQL</h2></div><h1>참고자료</h1><div><h2>SQL 명령</h2></div><h1>내부 구조</h1><div><h2>시스템 카탈로그</h2></div><h1>부록</h1><div><h2>Date/Time 지원</h2></div></article></main></body></html>