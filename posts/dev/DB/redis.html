<!DOCTYPE html><html lang="ko-KR"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Redis</title><link rel="stylesheet" href="/source/default.css"><meta name="google-site-verification" content="aH-DyzdytYQ0NPHNQFcs5dVoiu5YNs6CEEHYgqDmAFM"><meta name="author" content="Donggi Kim &lt;hi.donggi@gmail.com&gt;"><meta name="description" content="Redis 정리"><link rel="icon" href="/imgs/favicon.png"><script id="google-analytics" src="https://www.googletagmanager.com/gtag/js?id=UA-143098403-1" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-143098403-1');</script><script id="highlight-js" src="/source/highlight.pack.js" defer></script><script id="default-js" src="/source/default.min.js" defer></script></head><body><aside class="w3-animate-left" id="sidebar"><hr><div id="marker-list"></div><hr><div id="post-list"></div><hr><details class="w3-small file-list"><summary>LICENSE</summary><table><tr><td>Author</td><td>License</td></tr><tr><td>&copy; <a href="mailto:hi.donggi@gmail.com">Donggi Kim</a></td><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/Dong-gi/Dong-gi.github.io/blob/master/LICENSE">MIT</a></td></tr><tr><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://www.w3schools.com/w3css">w3css</a></td><td>No license</td></tr><tr><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://highlightjs.org/">highlight.js</a></td><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/highlightjs/highlight.js/blob/main/LICENSE">BSD-3-Clause</a></td></tr><tr><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/mathjax/MathJax">MathJax</a></td><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/mathjax/MathJax/blob/master/LICENSE">Apache-2.0</a></td></tr><tr><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/davidshimjs/qrcodejs">QRCode.js</a></td><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/davidshimjs/qrcodejs/blob/master/LICENSE">MIT</a></td></tr><tr><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/terrastruct/d2">D2</a></td><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/terrastruct/d2/blob/master/LICENSE.txt">MPL-2.0</a></td></tr></table></details><hr></aside><main id="main"><nav class="w3-bar w3-blue" id="nav"><button class="w3-bar-item w3-button w3-hover-theme" id="nav-toggle-btn">&#9776;</button><form role="search"><input class="w3-bar-item" id="query" type="search" placeholder="search" style="max-width:35%"></form><a class="w3-bar-item w3-button w3-hover-theme" href="/">Home</a></nav><article id="contents"><h1>참고자료</h1><ul><li><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://redis.io/documentation">공식 문서</a></li><li><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="http://redisgate.kr/">레디스 엔터프라이즈 버전</a></li><li><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/redis-essentials/book">Redis Essentials</a></li></ul><h1>Redis</h1><ul><li>인메모리 저장소 + 물리 장치 백업 지원</li><li>메시지 브로커 기능 보유 : Pub/Sub</li><li>BSD 라이선스</li></ul><div><h2>redis-server/<a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://redis.io/topics/rediscli">redis-cli</a></h2><ol><li>서버 실행</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ redis-server --port 27017</div><li>서버 접속</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ redis-cli -p 27017</div><li>help</li><p><strong>↓ redis-cli</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">> help
> help @&lt;group>      # Redis 명령어들은 연관성에 따라 그룹에 묶여있다
> help &lt;command></div><li>여러 키 삭제</li><p><strong>↓ shell</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ redis-cli --scan --pattern '*' | xargs redis-cli DEL</div><li>키 공간 이벤트 구독 가능</li><p>키 공간 이벤트는 기본적으로 발행되지 않으므로, 서버 설정을 변경해야 한다.<a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://redis.io/docs/manual/keyspace-notifications/">참고 자료</a></p></ol><h2>Data type</h2><ol><li>Binary-safe string : 임의 이진 문자열(최대 512MB)</li><li>List : 기본적으로 삽입 순으로 유지되는 string 연결 리스트(최대 길이 2^32 - 1)</li><p>블로킹 vs 논-블로킹 = 처리(e.g. 삭제) 후 반환 vs 반환 후 처리</p><li>Set : 순서 없는 string 집합(최대 크기 2^32 - 1)</li><li>Sorted set : 각 string 원소는 score라 불리는 실수 가중치(정렬키)를 가짐</li><p>같은 score 사이에서는 value를 기준으로 정렬된다</p><li>Hash : field -&gt; value 매핑(최대 크기 2^32 - 1). 각 field, value는 모두 string</li><li>Bit array : string을 비트열로 다룰 수 있다</li><li>HyperLogLog : 집합 크기 추정에 이용되는 확률 자료형</li><li>Stream : append만 가능한 유사 hash</li><ul><li>stream entry는 1개 이상의 field-value 쌍으로 구성된다</li><li>stream entry의 선후 관계는 ID로 구분한다. ID가 이전보다 작으면 추가 실패. ID를 *로 지정하는 경우, 서버에서 자동으로 millisecondsTime-sequenceNumber로 할당</li><ul><li>현재 시각이 이전 entry의 시각보다 작은 경우, 이전 entry의 시각을 사용하고 sequenceNumber만 증가한다</li><li>123-* 처럼 sequenceNumber만 자동 할당할 수도 있다</li></ul><li>3가지 방식으로 entry를 획득할 수 있다</li><ul><li>ID 범위를 이용해 질의 :<a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos-1697859643" target="_self">XRANGE</a><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos387417810" target="_self">XREVRANGE</a></li><li>새로 도착하는 entry 질의 :<a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos83781102" target="_self">XREAD</a><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos1567169841" target="_self">XREADGROUP</a></li><ul><li>블로킹 list 연산과 달리, 새로 도착한 entry는 기본적으로 모든 대기 중인 클라이언트에 전달된다</li><li>발송 후 즉시 삭제하는 Pub/Sub 서비스와 달리, entry는 명시적인 삭제 요청이 없는 한 영구적으로 스트림에 남는다</li><li>소비자 그룹을 이용해 그룹 내 소비자들이 서로 다른 entry를 독립적으로 처리할 수 있다</li></ul></ul></ul></ol></div><h1>Commands</h1><p>참고 자료 : <a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://redis.io/commands">commands</a>. Redis 명령어들은 연관성에 따라 하나의 그룹에 속해있다</p><div><h2>Generic</h2><div><h3>COPY since 6.2.0</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">COPY source destination [DB destination-db-index] [REPLACE]</div><ul><li>source 키의 값을 destination 키로 복사</li><li>복사됐으면 1, 아니면 0 반환</li><li>DB : 내부 논리적 DB index</li><li>REPLACE : 덮어쓰기</li></ul><h3>DEL</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">DEL key [key ...]</div><p>키를 삭제하고, 삭제된 개수 반환</p><h3>DUMP</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">DUMP key</div><ul><li>값을 Redis 포맷(내부 RDB 버전에 따라 인코딩 방식 결정됨)으로 직렬화하여 반환</li><p>expire time은 포함되지 않음</p><li><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos1815502446" target="_self">RESTORE</a>로 역직렬화 가능</li><p><strong>↓ redis-cli</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">127.0.0.1:6379> set key1 'Hello World!'
OK
127.0.0.1:6379> dump key1
"\x00\x0cHello World!\t\x00\xda\xe7D\xea/\xa2\xe6\xc7"
127.0.0.1:6379> restore key2 0 "\x00\x0cHello World!\t\x00\xda\xe7D\xea/\xa2\xe6\xc7"
OK
127.0.0.1:6379> get key2
"Hello World!"
</div></ul><h3>EXISTS</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">EXISTS key [key ...]</div><p>존재하는 키의 개수 반환. 중복된 키는 중복 카운트 됨에 유의</p><h3>EXPIRE</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">EXPIRE key seconds [NX|XX|GT|LT]</div><ul><li>지정 시간(초) 후 키 삭제</li><li>설정됐으면 1, 아니면 0반환</li><li>값을 덮어쓰지 않는 명령(INCR, LPUSH, HSET)과 RENAME은 ttl 정보에 영향을 미치지 않음에 유의</li><li>NX : No expiry; 키에 ttl이 설정되지 않은 경우에만 설정</li><li>XX : Exists expiry; 키에 ttl이 설정된 경우에만 설정</li><li>GT : Greater than; 기존 ttl보다 큰 경우에만 설정</li><li>LT : Less than; 기존 ttl보다 작은 경우에만 설정</li><li>ttl이 없는 경우 GT, LT에서 무한으로 간주</li></ul><h3>PEXPIRE</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">PEXPIRE key milliseconds [NX|XX|GT|LT]</div><p>밀리초 단위 EXPIRE</p><h3>EXPIREAT</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">EXPIREAT key unix-timestamp-seconds [NX|XX|GT|LT]</div><ul><li>지정 시각 이후 키 삭제</li><li>설정됐으면 1, 아니면 0반환</li><li>값을 덮어쓰지 않는 명령(INCR, LPUSH, HSET)과 RENAME은 ttl 정보에 영향을 미치지 않음에 유의</li><li>NX : No expiry; 키에 ttl이 설정되지 않은 경우에만 설정</li><li>XX : Exists expiry; 키에 ttl이 설정된 경우에만 설정</li><li>GT : Greater than; 기존 ttl보다 큰 경우에만 설정</li><li>LT : Less than; 기존 ttl보다 작은 경우에만 설정</li><li>ttl이 없는 경우 GT, LT에서 무한으로 간주</li></ul><h3>PEXPIREAT</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">PEXPIREAT key unix-time-milliseconds [NX|XX|GT|LT]</div><p>밀리초 단위 EXPIREAT</p><h3>EXPIRETIME Since 7.0.0</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">EXPIRETIME key</div><ul><li>키가 만료되는 시각 - Unix timestamp in seconds을 반환한다</li><li>-1 : ttl 설정 안 된 경우</li><li>-2 : 키가 존재하지 않는 경우</li></ul><h3>PEXPIRETIME Since 7.0.0</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">PEXPIRETIME key</div><p>밀리초 단위 EXPIRETIME</p><h3>KEYS</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">KEYS pattern</div><ul><li><span class="hover-content" template-id="glob-style-pattern">GLOB style pattern</span>에 일치하는 키 배열 반환</li><li>KEYS 명령은 사용중인 저장소가 클수록 큰 성능 저하를 발생하므로 각별히 주의</li></ul><h3>MIGRATE</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">MIGRATE host port key|"" destination-db timeout-ms [COPY] [REPLACE] [AUTH password] [AUTH2 username password] [KEYS key [key ...]]</div><ul><li>데이터를 다른 서버로 옮긴다. DUMP + DEL + RESTORE의 조합</li><li>timeout-ms : MIGRATE 명령이 제한시간 안에 수행함을 의미하는 것이 아니라, 어느 단계에서든 해당 지연 시간 이상 블록되는 일이 없음을 보장</li><p>시간초과가 발생하더라도 목적지에 복사된 상태일 수 있음에 유의. 반면 그 외의 에러 상황에서는 목적지에 복사되지 않은 상태임을 보장</p><li>COPY : 원본을 지우지 않는다</li><li>KEYS : 여러 개를 이동할 때, 앞부분 key를 ""로 하고 사용</li><li>AUTH, AUTH2 모두 목적지 서버 연결 정보로써, 필요한 것 하나만 사용</li></ul><h3>MOVE</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">MOVE key db-index</div><ul><li>키를 다른 DB로 옮긴다. 이미 목적지에 key가 존재하면 옮기지 않는다 -- 이 성질을 이용하여 락을 구현할 수도 있다</li><li>옮겼으면 1, 그 외엔 0 반환</li></ul><h3>OBJECT</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">OBJECT subcommand arg ... arg</div><ul><li>키에 대한 정보 획득</li><li>OBJECT ENCODING key : 상세 데이터 타입 반환</li><li>OBJECT FREQ key : 참조 빈도 반환. 메모리 정책에 따라 추적 여부가 결정됨</li><li>OBJECT IDLETIME key : 참조하지 않은 시간(초) 반환</li><li>OBJECT REFCOUNT key : 키가 참조하는 값의 개수 반환</li></ul><h3>PERSIST</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">PERSIST key</div><ul><li>ttl 삭제</li><li>삭제했으면 1, 아니면 0 반환</li></ul><h3>RANDOMKEY</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">RANDOMKEY</div><p>현재 DB에서 임의 키 반환. 없으면 nil</p><h3>RENAME</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">RENAME key newkey</div><ul><li>key가 존재하지 않는 경우 에러 반환</li><li>기존 newkey는 덮어씌어진다(암시적 DEL 수행)</li><li>기존 ttl 정보는 그대로 옮겨진다</li><li>클러스터 모드에서, key와 newkey는 같은 해시 슬롯에 존재해야</li><li>성공 시 "OK" 반환</li></ul><h3>RENAMENX</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">RENAMENX key newkey</div><ul><li>newkey가 존재하지 않는 경우만 RENAME</li><li>성공했으면 1, 아니면 0 반환</li></ul><h3>RESTORE</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">RESTORE key ttl-milliseconds serialized-value [REPLACE] [ABSTTL] [IDLETIME seconds] [FREQ frequency]</div><ul><li>Redis 포맷 문자열로부터 역직렬화</li><li>ttl : 0이면 무기한</li><li>ABSTTL : 설정한 경우, ttl을 Unix timestamp로 해석한다</li><li>IDLETIME, FREQ : OBJECT 명령과 관계된 초기값 설정</li></ul><h3>SCAN</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">SCAN cursor [MATCH pattern] [COUNT count] [TYPE type]</div><ul><li>cursor가 가리키는 지점부터 약 count개의 키 중, <span class="hover-content" template-id="glob-style-pattern">GLOB style pattern</span>에 일치하는 목록을 반환한다</li><li>COUNT : 유저가 원하는 페이지 크기에 대한 힌트로 사용된다(기본값 10) -- 반드시 count 개가 반환되는 것이 아님. 또, 연속 순회 시 count는 자유롭게 변경해도 된다</li><li>cursor : 0을 지정하여 순회 시작. 응답 첫 번째 원소로 0이 아닌 cursor가 반환되고, 이를 이용해 나머지를 순회할 수 있다</li><p><strong>↓ redis-cli</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">127.0.0.1:6379> keys *
1) "key2"
2) "key"
3) "hello"
127.0.0.1:6379> scan 0 count 1
1) "2"
2) 1) "key2"
   2) "key"
127.0.0.1:6379> scan 2 count 1
1) "1"
2) 1) "hello"
127.0.0.1:6379> scan 1 count 1
1) "0"
2) (empty array)</div><li>MATCH : 패턴 매칭은 페이지가 구성된 후 클라이언트에 응답하기 직전에 수행되므로, 순회가 종료되지 않더라도 키 목록이 비어있을 수 있다</li><li>TYPE : 값이 type에 해당하는 키만 검색.<a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos2590522" target="_self">TYPE</a></li><li>서버는 순회와 관련하여 상태를 저장하지 않으므로, 동시 순회 클라이언트 개수에 제한이 없고, 중간에 언제든 순회를 그만둬도 된다</li><li>순회의 종료를 판단하는 기준 : 지정 cursor로부터 남은 키의 개수가 count보다 작은가?</li><li>일부 복합 타입들은 특정 크기를 초과하지 않는 한 해시 테이블이 아닌 하나의 값으로 저장되므로, count보다 많은 목록이 응답될 수도 있다</li></ul><h3>SORT</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">SORT key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern ...]] [ASC|DESC] [ALPHA] [STORE destination]</div><ul><li>list, set, sorted set 데이터를 정렬하여 획득 or 저장한다</li><li>기본적으로 값의 두배 정밀도 실수 표현을 정렬 키로 한다</li><li>ALPHA : 문자열 정렬을 수행하고 싶은 경우</li><li>offset : 0부터 시작</li><li>BY pattern : 정렬 키 지정</li><li>GET # : 원소 자체도 반환</li><li>GET pattern : 조회 키 지정</li><p><strong>↓ redis-cli</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell"># 학생 이름 5개 저장
127.0.0.1:6379> sadd student-name name5 name1 name2 name3 name4
(integer) 5

# 점수 저장
127.0.0.1:6379> mset name5-score 3 name1-score 10 name2-score 0 name3-score 7
OK

# 각 학생의 점수 획득(이름순)
127.0.0.1:6379> sort student-name get *-score alpha
1) "10"
2) "0"
3) "7"
4) (nil)
5) "3"

# 각 학생의 점수 획득(점수순)
127.0.0.1:6379> sort student-name by *-score get *-score desc
1) "10"
2) "7"
3) "3"
4) (nil)
5) "0"

# 원소도 같이 반환
127.0.0.1:6379> sort student-name by *-score get # get *-score desc
1) "name1"
2) "10"
3) "name3"
4) "7"
5) "name5"
6) "3"
7) "name4"
8) (nil)
9) "name2"
10) "0"</div><li>해시 필드에 대하여, 아래와 같이 -> 표기를 이용해 BY, GET 옵션을 사용할 수 있다</li><p><strong>↓ e.g.</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">SORT mylist BY weight_*->fieldname GET object_*->fieldname</div></ul><h3>SORT_RO Since 7.0.0</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">SORT_RO key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern ...]] [ASC|DESC] [ALPHA]</div><p>읽기 전용 SORT : SORT 명령은 STORE 옵션으로 인해 쓰기 명령으로 분류되고, 이로 인해 읽기 전용 복제본에서 마스터 인스턴스로 명령이 항상 리디렉션되었는데, 이를 방지할 목적으로 추가되었다.</p><h3>TOUCH</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">TOUCH key [key ...]</div><ul><li>마지막 접근 시각을 현재로 설정</li><li>설정한 개수 반환</li></ul><h3>TTL</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">TTL key</div><p>남은 유효 시간(초) 반환. 삭제됐으면 -2, ttl 없으면 -1</p><h3>PTTL</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">PTTL key</div><p>밀리초 단위 TTL</p><h3>TYPE</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">TYPE key</div><p>데이터 타입 반환; string, list, set, zset, hash, stream, none</p><h3>UNLINK</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">UNLINK key [key ...]</div><ul><li>키 공간에서 키를 삭제한 개수를 반환</li><li><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos67563" target="_self">DEL</a>과 다르게 메모리 해제를 별도 스레드에서 진행(논-블로킹)하기 때문에, 지울 개수가 많을수록 UNLINK가 더 빠르다</li></ul><h3>WAIT</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">WAIT numreplicas timeout-milliseconds</div><ul><li>이전 모든 write 명령이 numreplicas개의 복제본에 도달하기까지 최대 timeout 밀리초 대기</li><li>도달한 복제본 개수 반환</li><li>timeout == 0이면 무기한 대기 가능</li></ul></div><h2>String</h2><div><h3>APPEND</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">APPEND key value</div><ul><li>키가 존재하고 값이 문자열이면 append</li><li>키가 존재하고 값이 문자열이 아니면 에러</li><li>키가 없으면 set</li><li>연산 후의 문자열 길이 반환</li></ul><h3>DECR</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">DECR key</div><ul><li>주어진 키의 정수 1 감소 후 반환</li><p>키가 없으면 0으로 간주</p><li>값이 signed 64bit 범위 밖이면 에러</li></ul><h3>DECRBY</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">DECRBY key decrement</div><ul><li>주어진 키의 정수 decrement 감소 후 반환</li><p>키가 없으면 0으로 간주</p><li>값이 signed 64bit 범위 밖이면 에러</li></ul><h3>GET</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">GET key</div><ul><li>key가 없으면 nil 반환</li><li>key의 값이 문자열이면 해당 값 반환</li><li>그 외는 에러</li></ul><h3>GETDEL</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">GETDEL key</div><ul><li>GET 실행 후 DEL(key가 존재하고, 값이 string일 경우) 실행</li><li>GET 실행 결과 반환</li></ul><h3>GETEX</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">GETEX key [EX seconds|PX milliseconds|EXAT unix-time-seconds|PXAT unix-time-milliseconds|PERSIST]</div><ul><li>GET 실행 후 ttl 변경. GET 실행 결과 반환</li><li>EX, PX : ttl(상대 시간)</li><li>EXAT, PXAT : ttl(절대 시각)</li><li>PERSIST : ttl 제거</li></ul><h3>GETRANGE</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">GETRANGE key start end</div><ul><li>key에 대하여, 문자열의 부분 문자열 [start, end] 반환</li><li>음수 인덱스 가능. 문자열 길이를 초과하는 구간은 무시</li></ul><h3>GETSET; Deprecated since 6.2.0</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">GETSET key value</div><ul><li>SET 실행 후, 이전 값 반환</li><li>Since 6.2.0 : SET 명령의 GET 옵션 사용</li></ul><h3>INCR</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">INCR key</div><ul><li>주어진 키의 정수 1 증가 후 반환</li><p>키가 없으면 0으로 간주</p><li>값이 signed 64bit 범위 밖이면 에러</li></ul><h3>INCRBY</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">INCRBY key increment</div><ul><li>주어진 키의 정수 increment 증가 후 반환</li><p>키가 없으면 0으로 간주</p><li>값이 signed 64bit 범위 밖이면 에러</li></ul><h3>INCRBYFLOAT</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">INCRBYFLOAT key increment</div><ul><li>주어진 키의 실수 increment(음수 가능) 증가 후 반환</li><p>키가 없으면 0으로 간주</p><li>값이 double 범위 밖이면 에러</li></ul><h3>LCS Since 6.0.0 or 7.0.0</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text"># Since 6.0.0
STRALGO LCS [KEYS ...] [STRINGS ...] [LEN] [IDX] [MINMATCHLEN len] [WITHMATCHLEN]
# Since 7.0.0
LCS key1 key2 [LEN] [IDX] [MINMATCHLEN len] [WITHMATCHLEN]</div><ul><li>두 문자열의 LCS(Longest common subsequence)를 구한다</li><p><strong>↓ redis-cli</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">127.0.0.1:6379> set key1 humble-bundle
OK
127.0.0.1:6379> set key2 bundle-humble
OK
127.0.0.1:6379> stralgo lcs keys key1 key2
"ble-ule"
127.0.0.1:6379> stralgo lcs strings humble-bundle bundle-humble
"ble-ule"</div><li>LEN : 길이만을 원하는 경우</li><li>IDX : LCS 각 부분 시퀀스의 [시작, 종료] 위치를 역순으로 반환</li><li>IDX MINMATCHLEN : LCS 부분 시퀀스 중, 최소 길이를 만족하는 것만 반환</li><li>IDX WITHMATCHLEN : LCS 각 부분 시퀀스의 길이도 반환</li><p><strong>↓ redis-cli</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">127.0.0.1:6379> stralgo lcs strings humble-bundle xbundle-humble idx minmatchlen 2
1) "matches"
2) 1) 1) 1) (integer) 11
         2) (integer) 12
      2) 1) (integer) 12
         2) (integer) 13
   2) 1) 1) (integer) 4
         2) (integer) 6
      2) 1) (integer) 5
         2) (integer) 7
3) "len"
4) (integer) 7

// 2) 1) 1) : "humble-bundle"의 "le"
// 2) 1) 2) : "xbundle-humble"의 "le"
</div></ul><h3>MGET</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">MGET key [key ...]</div><p>각 키에 대해 get 하여 배열로 반환</p><p><strong>↓ redis-cli</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">127.0.0.1:27017> mget k1 k2 not_exists_key
1) "v1"
2) "v2"
3) (nil)
</div><h3>MSET</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">MSET key value [key value ...]</div><p>원자적으로 주어진 키-값 쌍들을 모두 설정한다</p><h3>MSETNX</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">MSETNX key value [key value ...]</div><p>모든 키가 신규인 경우 mset 실행하고 1 반환. 그 외엔 0 반환</p><h3>PSETEX</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">PSETEX key milliseconds value</div><p>밀리초 단위<a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos78790773" target="_self">SETEX</a></p><h3>SET</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">SET key value [EX seconds|PX milliseconds|EXAT unix-time-seconds|PXAT unix-time-milliseconds|KEEPTTL] [NX|XX] [GET]</div><ul><li>원자적으로 key에 대하여 value를 할당한다. 이전에 설정한 값, 유효 기간을 덮어쓴다</li><li>EX, PX : ttl(상대 시각)</li><li>EXAT, PXAT : ttl(절대 시각)</li><li>NX : 신규 키일 때만 설정</li><li>XX : 중복 키일 때만 설정</li><li>KEEPTTL : 이전 ttl 유지</li><li>GET : 이전 값 반환(없으면 nil)</li></ul><h3>SETEX</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">SETEX key seconds value</div><p>"SET key value EX seconds"와 동일</p><h3>SETNX</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">SETNX key value</div><ul><li>key가 존재하지 않을 경우에만 value 설정</li><li>설정했으면 1, 아니면 0 반환</li></ul><h3>SETRANGE</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">SETRANGE key offset value</div><ul><li>key에 대하여, offset(0부터 시작) 위치부터 value의 길이만큼 value로 덮어쓴다</li><li>offset이 기존 문자열을 초과하는 경우 빈 자리는 \x00으로 채워진다</li><li>key가 존재하지 않는 경우, 값을 빈 문자열로 간주하고 실행한다</li><li>설정 후 문자열 길이를 반환한다</li><li><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos-1518682201" target="_self">GETRANGE</a>와 함께 O(1) 접근 가능한 공유 배열로 이용할 수 있다</li></ul><p><strong>↓ redis-cli</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">127.0.0.1:27017> set msg hello
OK
127.0.0.1:27017> setrange msg 8 hello
(integer) 13
127.0.0.1:27017> get msg
"hello\x00\x00\x00hello"
</div><h3>STRLEN</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">STRLEN key</div><ul><li>문자열 길이 반환</li><li>key가 존재하지 않으면 0</li><li>값이 문자열이 아니면 에러</li></ul></div><h2>Bitmap</h2><div><h3>BITCOUNT</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">BITCOUNT key [start end [BYTE|BIT]]</div><ul><li>문자열 내 set bit 개수 반환</li><li>start, end : 음수를 허용하는 두 인덱스로 표현되는 닫힌 구간 [start, end]으로 탐색 구간 지정 가능</li><li>BYTE, BIT : 탐색 구간에 사용되는 start, end의 단위 지정</li></ul><h3>BITFIELD</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">BITFIELD key [GET encoding offset] [SET encoding offset value] [INCRBY encoding offset increment] [OVERFLOW WRAP|SAT|FAIL]</div><ul><li>문자열을 비트열로 간주하여 GET, SET, INCRBY 연산들을 수행한다</li><p>GET 서브 명령 실행 시, 문자열을 벗어난 구간의 비트열은 0으로 간주한다</p><li>encoding : 부호 있는 64비트, 부호 없는 63비트까지 가능</li><p>e.g. i5(부호 있는 5비트), u4(부호 없는 4비트)</p><li>offset : 0부터 시작하는 시작 위치. 정수만 이용하는 경우 bit단위, #를 붙이면 encoding 크기 단위</li><li>OVERFLOW : WRAP(default, 오버/언더플로우 비트 무시), SAT(오버/언더플로우 시 최대/최소값으로), FAIL(실패, nil 반환)</li><p>OVERFLOW 이후 등장하는 INCRBY 서브 명령에만 영향을 미침에 유의</p><li>반환 : SET(이전 값), GET(현재 값), INCRBY(신규 값)</li></ul><p><strong>↓ redis-cli</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">127.0.0.1:27017> bitfield time SET u6 #0 11 SET u6 #1 33 SET u6 #2 55 GET u6 #0 GET u6 #1 GET u6 #2 INCRBY u6 #0 1 INCRBY u6 #1 1 INCRBY u6 #2 1
1) (integer) 0
2) (integer) 0
3) (integer) 0
4) (integer) 11
5) (integer) 33
6) (integer) 55
7) (integer) 12
8) (integer) 34
9) (integer) 56
</div><h3>BITFIELD_RO Since 6.2.0</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">BITFIELD_RO key GET encoding offset</div><p>읽기 전용 복제본에서 마스터로 명령이 리디렉션되는 것을 방지하기 위한 읽기 전용 BITFIELD</p><h3>BITOP</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">BITOP operation destkey key [key ...]</div><p>소스 키들의 값에 대한 AND, OR, XOR, NOT 결과를 destkey에 저장한다</p><p><strong>↓ redis-cli</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">127.0.0.1:6379> set key1 "humble-bundle"
OK
127.0.0.1:6379> set key2 "bundle-humble"
OK
127.0.0.1:6379> bitop and key3 key1 key2
(integer) 13
127.0.0.1:6379> get key3
"`ul`le-`ul`le"
</div><h3>BITPOS</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">BITPOS key bit [start [end [BYTE|BIT]]]</div><ul><li>bit와 일치하는 인덱스를 닫힌 구간 [start, end] 사이(음수 인덱스 가능)에서 구한다</li><li>BYTE, BIT : 탐색 구간에 사용되는 start, end의 단위 지정</li><li>Set bit을 못찾은 경우 -1 반환</li><li>구간 지정 없이 Clear bit을 못찾은 경우 비트열 길이 반환</li><p>문자열을 초과하는 부분을 0 비트열로 간주하기 때문</p><li>구간 지정했지만 Clear bit을 못찾은 경우 -1 반환</li></ul><p><strong>↓ redis-cli</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">127.0.0.1:6379> set key "\x00\xff"
OK
127.0.0.1:6379> bitpos key 0
(integer) 0
127.0.0.1:6379> bitpos key 0 1
(integer) 16
127.0.0.1:6379> bitpos key 0 1 1
(integer) -1
127.0.0.1:6379> bitpos key 1
(integer) 8
127.0.0.1:6379> bitpos key 1 1
(integer) 8
</div><h3>GETBIT</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">GETBIT key offset</div><p>offset(0부터 시작)번째 비트 반환. 문자열을 넘어선 구간은 0으로 간주</p><h3>SETBIT</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">SETBIT key offset value</div><p>offset(0부터 시작)번째 비트를 value(0 | 1)로 변경. 이전 비트값 반환</p></div><h2>List</h2><div><h3>BLMOVE Since 6.2.0</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">BLMOVE source destination LEFT|RIGHT LEFT|RIGHT timeout-seconds</div><ul><li><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos407572915" target="_self">LMOVE Since 6.2.0</a>의 블로킹 버전</li><li>source 리스트가 비어있는 경우, 최대 timeout만큼 대기한다</li><p>timeout == 0이면 무기한 대기 가능</p></ul><h3>BLMPOP Since 7.0.0</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">BLMPOP timeout-seconds numkeys key [key ...] LEFT|RIGHT [COUNT count]</div><ul><li><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos-2067443675" target="_self">LMPOP Since 7.0.0</a>의 블로킹 버전</li><li>모든 리스트가 비어있는 경우, 최대 timeout만큼 대기한다</li><p>timeout == 0이면 무기한 대기 가능</p></ul><h3>BLPOP</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">BLPOP key [key ...] timeout-seconds</div><ul><li><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos2343525" target="_self">LPOP</a>의 블로킹 버전</li><p>지정한 리스트들을 순회하여, 최초로 비어있지 않은 리스트의 왼쪽 값 삭제 후 반환</p><li>모든 리스트가 비어있는 경우, 최대 timeout만큼 대기</li><p>timeout == 0이면 무기한 대기 가능</p><li>BLPOP 경합 시 처리 우선순위에 대해서는 공식 문서 참고 :<a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://redis.io/commands/blpop/">blpop</a></li></ul><h3>BRPOP</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">BRPOP key [key ...] timeout-seconds</div><ul><li><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos2522271" target="_self">RPOP</a>의 블로킹 버전</li><li>기타 설명은<a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos63295911" target="_self">BLPOP</a>과 동일</li></ul><h3>BRPOPLPUSH; Deprecated since 6.2.0</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">BRPOPLPUSH source destination timeout-seconds</div><ul><li><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos314547509" target="_self">RPOPLPUSH; Deprecated since 6.2.0</a>의 블로킹 버전</li><li>source 리스트가 비어있는 경우, 최대 timeout만큼 대기한다</li><p>timeout == 0이면 무기한 대기 가능</p><li>Since 6.2.0 :<a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos-974692943" target="_self">BLMOVE Since 6.2.0</a></li></ul><h3>LINDEX</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">LINDEX key index</div><p>index(음수 가능) 번째 값 반환</p><h3>LINSERT</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">LINSERT key BEFORE|AFTER pivot element</div><ul><li>pivot 전|후에 element를 삽입</li><li>삽입 후 리스트 크기 반환. key가 존재하지 않는 경우 0. pivot을 찾지 못한 경우 -1</li></ul><h3>LLEN</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">LLEN key</div><p>리스트 크기 반환. key가 존재하지 않는 경우 0</p><h3>LMOVE Since 6.2.0</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">LMOVE source destination LEFT|RIGHT LEFT|RIGHT</div><p>원자적으로 source의 LEFT|RIGHT 원소를 반환한 다음 삭제하고, destination의 LEFT|RIGHT에 추가한다</p><p><strong>↓ redis-cli</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">127.0.0.1:6379> lpush list1 x1 x2 x3
(integer) 3
127.0.0.1:6379> lpush list2 y1 y2 y3
(integer) 3
127.0.0.1:6379> lmove list1 list2 left right
"x3"
</div><h3>LMPOP Since 7.0.0</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">LMPOP numkeys key [key ...] LEFT|RIGHT [COUNT count]</div><p>비어있지 않은 최초 리스트의 왼쪽|오른쪽에서 최대 count개 원소를 반환하고 제거</p><h3>LPOP</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">LPOP key [count]</div><p>리스트 왼쪽 값 count(기본 1)개 삭제 후 반환</p><h3>LPOS Since 6.0.6</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">LPOS key element [RANK rank] [COUNT num-matches] [MAXLEN len]</div><ul><li>리스트에서 element의 위치 반환. 없으면 nil</li><li>RANK : rank번째(1부터 시작)로 찾은 위치 반환</li><p>rank로 음수도 가능하며, '-'는 탐색 순서가 반대(tail to head)임을 지시한다</p><li>COUNT : 최대 num-matches개의 위치 반환</li><ul><li>탐색 순서를 반대로 하고 싶다면 rank -1 지정</li><li>num-matches가 0이면 구간 전체 탐색</li><li>하나도 못 찾은 경우, nil이 아니라 빈 배열 반환</li></ul><li>MAXLEN : 최대 len개의 원소만 비교</li></ul><h3>LPUSH</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">LPUSH key element [element ...]</div><p>왼쪽에 값 추가. 이후 리스트 크기 반환</p><h3>LPUSHX</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">LPUSHX key element [element ...]</div><p>리스트가 존재하면 왼쪽에 값 추가. 이후 리스트 크기 반환</p><h3>LRANGE</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">LRANGE key start stop</div><p>[start, stop] 구간의 값 반환(음수 인덱스 가능)</p><h3>LREM</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">LREM key count element</div><ul><li>element를 count개 삭제, count == 0이면 전부 삭제, count &lt; 0이면 오른쪽부터 삭제</li><li>삭제한 개수 반환</li></ul><h3>LSET</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">LSET key index element</div><p>index(음수 가능) 번째 값을 element로 교체</p><h3>LTRIM</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">LTRIM key start stop</div><p>[start, stop] 구간(음수 인덱스 가능)만 남기고 나머지 삭제</p><h3>RPOP</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">RPOP key [count]</div><p>리스트 오른쪽 값 count개(기본 1) 삭제 후 반환</p><h3>RPOPLPUSH; Deprecated since 6.2.0</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">RPOPLPUSH source destination</div><ul><li>원자적으로 rpop + lpush 실행</li><li>Since 6.2.0 :<a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos407572915" target="_self">LMOVE Since 6.2.0</a></li></ul><h3>RPUSH</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">RPUSH key element [element ...]</div><p>오른쪽에 값 추가. 이후 리스트 크기 반환</p><h3>RPUSHX</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">RPUSHX key element [element ...]</div><p>리스트가 존재하면 오른쪽에 값 추가. 이후 리스트 크기 반환</p></div><h2>Set</h2><div><h3>SADD</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">SADD key member [member ...]</div><p>집합에 원소 추가. 실제 추가된 개수 반환</p><h3>SCARD</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">SCARD key</div><p>집합 크기 반환</p><h3>SDIFF</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">SDIFF key [key ...]</div><p>차집합 반환; SDIFF s1 s2 s3 ... == s1 - s2 - s3 - ...</p><h3>SDIFFSTORE</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">SDIFFSTORE destination key [key ...]</div><p><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos78750424" target="_self">SDIFF</a>결과 destination에 저장(덮어쓰기)</p><h3>SINTER</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">SINTER key [key ...]</div><p>교집합 반환</p><h3>SINTERCARD Since 7.0.0</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">SINTERCARD numkeys key [key ...] [LIMIT limit]</div><p><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos-1848924087" target="_self">SINTER</a>의 크기 반환</p><h3>SINTERSTORE</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">SINTERSTORE destination key [key ...]</div><p><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos-1848924087" target="_self">SINTER</a>결과 destination에 저장(덮어쓰기)</p><h3>SISMEMBER</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">SISMEMBER key member</div><p>집합에 포함되면 1, 아니면 0</p><h3>SMEMBERS</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">SMEMBERS key</div><p>전체 원소 반환</p><h3>SMISMEMBER Since 6.2.0</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">SMISMEMBER key member [member ...]</div><p>각 원소에 대하여<a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos1600159127" target="_self">SISMEMBER</a>를 실행한 결과 배열 반환</p><h3>SMOVE</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">SMOVE source destination member</div><p>member가 source에 포함된다면 destination으로 이동하고 1 반환. 아니면 0</p><h3>SPOP</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">SPOP key [count]</div><p>무작위로 count(기본 1)개 삭제 후 반환</p><h3>SRANDMEMBER</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">SRANDMEMBER key [count]</div><p>무작위로 count(기본 1)개 원소 반환. 음수를 지정한 경우, 중복이 허용된다</p><h3>SREM</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">SREM key member [member ...]</div><p>집합에서 원소 삭제. 실제 제거된 개수 반환</p><h3>SSCAN</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">SSCAN key cursor [MATCH pattern] [COUNT count]</div><p>집합에 대한<a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos2539133" target="_self">SCAN</a></p><h3>SUNION</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">SUNION key [key ...]</div><p>합집합 반환</p><h3>SUNIONSTORE</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">SUNIONSTORE destination key [key ...]</div><p><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos-1837852100" target="_self">SUNION</a>결과 destination에 저장(덮어쓰기)</p></div><h2>Sorted Set</h2><div><h3>BZMPOP Since 7.0.0</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">BZMPOP timeout-seconds numkeys key [key ...] MIN|MAX [COUNT count]</div><ul><li><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos-300977101" target="_self">ZMPOP Since 7.0.0</a>의 블로킹 버전</li><li>모든 sorted set이 비어있는 경우, 최대 timeout만큼 대기</li><p>timeout == 0이면 무기한 대기 가능</p></ul><h3>BZPOPMAX</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">BZPOPMAX key [key ...] timeout</div><ul><li><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos636702285" target="_self">ZPOPMAX</a>의 블로킹 버전</li><li>비어있지 않은 최초의 sorted set에서 가장 높은 score를 가진 원소 반환</li><li>모든 sorted set이 비어있는 경우, 최대 timeout만큼 대기</li><p>timeout == 0이면 무기한 대기 가능</p><li>경합 시 처리 우선순위에 대해서는 BLPOP 문서 참고 :<a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://redis.io/commands/blpop/">blpop</a></li></ul><h3>BZPOPMIN</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">BZPOPMIN key [key ...] timeout</div><ul><li><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos636702523" target="_self">ZPOPMIN</a>의 블로킹 버전</li><li>비어있지 않은 최초의 sorted set에서 가장 낮은 score를 가진 원소 반환</li><li>모든 sorted set이 비어있는 경우, 최대 timeout만큼 대기</li><p>timeout == 0이면 무기한 대기 가능</p><li>경합 시 처리 우선순위에 대해서는 BLPOP 문서 참고 :<a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://redis.io/commands/blpop/">blpop</a></li></ul><h3>ZADD</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">ZADD key [NX|XX] [GT|LT] [CH] [INCR] score member [score member ...]</div><ul><li>기본 동작 : 원소가 이미 존재하는 경우, 지정된 score로 새로 삽입한다. 새로 추가된 원소의 개수를 반환한다</li><p>score로 -inf, +inf 가능</p><li>NX : 원소가 이미 존재하는 경우 스킵</li><li>XX : 원소가 존재하지 않는 경우 스킵</li><li>LT : 기존 score &lt;= 새 score인 경우 스킵</li><li>GT : 기존 score &gt;= 새 score인 경우 스킵</li><li>CH : score가 갱신된 원소 개수를 포함하여 반환한다</li><li>INCR : score를 덮어쓰지 않고, 값만큼 증가</li><p>갱신된 score를 반환한다. 없으면 nil</p></ul><h3>ZCARD</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">ZCARD key</div><p>집합 크기 반환</p><h3>ZCOUNT</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">ZCOUNT key min max</div><p><span class="hover-content" template-id="zset-score-range">score 구간</span>에 포함되는 원소 개수 반환</p><h3>ZDIFF Since 6.2.0</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">ZDIFF numkeys key [key ...] [WITHSCORES]</div><ul><li>차집합 반환; ZDIFF 3 s1 s2 s3 == s1 - s2 - s3</li><li>WITHSCORES : 반환 배열의 각 원소 뒤에 score가 포함된다</li></ul><h3>ZDIFFSTORE Since 6.2.0</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">ZDIFFSTORE destination numkeys key [key ...]</div><ul><li><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos1224103925" target="_self">ZDIFF Since 6.2.0</a>결과를 destination에 저장한다(덮어쓰기)</li><li>결과 집합 크기를 반환한다</li></ul><h3>ZINCRBY</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">ZINCRBY key increment member</div><ul><li>score를 increment만큼 증가한 뒤 반환</li><li>원소가 존재하지 않는 경우, increment를 score로 하여 원소 추가</li><li>키가 존재하지 않는 경우, 새 sorted set 생성</li></ul><h3>ZINTER Since 6.2.0</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">ZINTER numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX] [WITHSCORES]</div><ul><li>교집합 반환</li><li>WEIGHTS : 각 집합 score 가중치(기본 1)</li><li>AGGREGATE : score 집계 함수(기본 SUM)</li><li>WITHSCORES : 반환 배열의 각 원소 뒤에 score가 포함된다</li></ul><h3>ZINTERCARD Since 7.0.0</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">ZINTERCARD numkeys key [key ...] [LIMIT limit]</div><ul><li><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos22993080" target="_self">ZINTER Since 6.2.0</a>결과 집합 크기를 반환한다</li><li>LIMIT : 결과 집합 크기가 limit(기본 0; 무제한)에 도달하면 더 계산하지 않음</li></ul><h3>ZINTERSTORE</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]</div><ul><li><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos22993080" target="_self">ZINTER Since 6.2.0</a>결과를 destination에 저장한다(덮어쓰기)</li><li>결과 집합 크기를 반환한다</li></ul><h3>ZLEXCOUNT</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">ZLEXCOUNT key min max</div><p><span class="hover-content" template-id="zset-lexicographical-range">사전적 구간</span> 안에 있는 원소 개수 반환</p><h3>ZMPOP Since 7.0.0</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">ZMPOP numkeys key [key ...] MIN|MAX [COUNT count]</div><ul><li>주어진 key 중 처음으로 비어있지 않은 sorted set으로부터 최대 count(기본 1)개의 원소를 제거하고, score와 함께 반환한다</li><li>MIN|MAX : score 낮은|높은 순으로 제거</li></ul><h3>ZMSCORE Since 6.2.0</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">ZMSCORE key member [member ...]</div><p>각 원소에 대해<a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos-1639616936" target="_self">ZSCORE</a>실행한 결과 배열 반환</p><h3>ZPOPMAX</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">ZPOPMAX key [count]</div><p>score가 큰 원소부터 제거하여 score와 함께 반환</p><h3>ZPOPMIN</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">ZPOPMIN key [count]</div><p>score가 작은 원소부터 제거하여 score와 함께 반환</p><h3>ZRANDMEMBER Since 6.2.0</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">ZRANDMEMBER key [count [WITHSCORES]]</div><ul><li>임의 원소 count(기본 1)개 반환</li><li>count가 음수인 경우, 중복이 허용된다</li><li>WITHSCORES : score가 함께 반환된다</li></ul><h3>ZRANGE</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">ZRANGE key min max [BYSCORE|BYLEX] [REV] [LIMIT offset count] [WITHSCORES]</div><ul><li>지정한 구간에 포함되는 원소를 오름차순으로 반환</li><li><b>모든 원소의 score가 동일하지 않으면, BYLEX 결과가 제대로 정렬되지 않음</b></li><p><strong>↓ redis-cli</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">127.0.0.1:6379> zrange ss1 0 -1 withscores
1) "m3"
2) "1"
3) "m6"
4) "123"
5) "m1"
6) "124"
127.0.0.1:6379> zrange ss1 - + bylex
1) "m3"
2) "m6"
3) "m1"
127.0.0.1:6379> zrange ss1 + - bylex rev
1) "m1"
2) "m6"
3) "m3"</div><li>(미지정)|BYSCORE|BYLEX : rank(==index, 음수 허용) 구간|<span class="hover-content" template-id="zset-score-range">score 구간</span>|<span class="hover-content" template-id="zset-lexicographical-range">사전적 구간</span></li><li>REV : 내림차순 탐색</li><p><b>주의</b>. BYSCORE, BYLEX에서는 min, max의 위치가 변경돼야 한다...</p><li>LIMIT : SQL의 LIMIT limit OFFSET offset과 유사한 옵션. count가 음수인 경우, offset 이후 모든 원소를 반환한다</li></ul><h3>ZRANGEBYLEX; Deprecated Since 6.2.0</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">ZRANGEBYLEX key min max [LIMIT offset count]</div><p>Since 6.2.0 :<a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos-1640601341" target="_self">ZRANGE</a>with BYLEX</p><h3>ZRANGEBYSCORE; Deprecated Since 6.2.0</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</div><p>Since 6.2.0 :<a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos-1640601341" target="_self">ZRANGE</a>with BYSCORE</p><h3>ZRANGESTORE Since 6.2.0</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">ZRANGESTORE dst src min max [ BYSCORE | BYLEX] [REV] [LIMIT offset count]</div><p><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos-1640601341" target="_self">ZRANGE</a>결과를 dst에 저장한다(덮어쓰기)</p><h3>ZRANK</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">ZRANK key member</div><p>원소의 index(0부터 시작, 오름차순) 반환. 없으면 nil</p><h3>ZREM</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">ZREM key member [member ...]</div><p>원소 삭제. 삭제된 개수 반환</p><h3>ZREMRANGEBYLEX</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">ZREMRANGEBYLEX key min max</div><p><span class="hover-content" template-id="zset-lexicographical-range">사전적 구간</span>의 원소 삭제. 삭제된 개수 반</p><h3>ZREMRANGEBYRANK</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">ZREMRANGEBYRANK key start stop</div><p>rank(==index, 음수 허용) 구간의 원소 삭제. 삭제된 개수 반환</p><h3>ZREMRANGEBYSCORE</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">ZREMRANGEBYSCORE key min max</div><p><span class="hover-content" template-id="zset-score-range">score 구간</span>의 원소 삭제. 삭제된 개수 반</p><h3>ZREVRANGE; Deprecated Since 6.2.0</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">ZREVRANGE key start stop [WITHSCORES]</div><p>Since 6.2.0 :<a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos-1640601341" target="_self">ZRANGE</a>with REV</p><h3>ZREVRANGEBYLEX; Deprecated Since 6.2.0</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">ZREVRANGEBYLEX key max min [LIMIT offset count]</div><p>Since 6.2.0 :<a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos-1640601341" target="_self">ZRANGE</a>with BYLEX REV</p><h3>ZREVRANGEBYSCORE; Deprecated Since 6.2.0</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]</div><p>Since 6.2.0 :<a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos-1640601341" target="_self">ZRANGE</a>with BYSCORE REV</p><h3>ZREVRANK</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">ZREVRANK key member</div><p>원소의 index(0부터 시작, 내림차순) 반환. 없으면 nil</p><h3>ZSCAN</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">ZSCAN key cursor [MATCH pattern] [COUNT count]</div><p>sorted set에 대한<a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos2539133" target="_self">SCAN</a></p><h3>ZSCORE</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">ZSCORE key member</div><p>원소의 score 반환. 없으면 nil</p><h3>ZUNION Since 6.2.0</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">ZUNION numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM | MIN | MAX] [WITHSCORES]</div><ul><li>합집합 반환</li><li>WEIGHTS : 각 집합 score 가중치(기본 1)</li><li>AGGREGATE : score 집계 함수(기본 SUM)</li><li>WITHSCORES : 반환 배열의 각 원소 뒤에 score가 포함된다</li></ul><h3>ZUNIONSTORE</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]</div><ul><li><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos92632619" target="_self">ZUNION Since 6.2.0</a>결과를 destination에 저장한다(덮어쓰기)</li><li>결과 집합 크기를 반환한다</li></ul></div><h2>Hash</h2><div><h3>HDEL</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">HDEL key field [field ...]</div><p>지정한 field 제거. 제거된 개수 반환</p><h3>HEXISTS</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">HEXISTS key field</div><p>field를 포함하면 1, 그 외엔 0 반환</p><h3>HGET</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">HGET key field</div><p>지정한 field의 value 반환. 없으면 nil</p><h3>HGETALL</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">HGETALL key</div><p>전체 field-value 목록 반환</p><h3>HINCRBY</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">HINCRBY key field increment</div><p>value += increment, 값이 없으면 value = increment로 신규 설정. 변경된 value 반환</p><h3>HINCRBYFLOAT</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">HINCRBYFLOAT key field increment</div><p>value += increment, 값이 없으면 value = increment로 신규 설정. 변경된 value 반환</p><h3>HKEYS</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">HKEYS key</div><p>전체 field 목록 반환</p><h3>HLEN</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">HLEN key</div><p>전체 field-value 쌍 개수 반환</p><h3>HMGET</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">HMGET key field [field ...]</div><p>지정 field들에 대해<a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos2215406" target="_self">HGET</a>실행한 결과 배열 반환</p><h3>HRANDFIELD Since 6.2.0</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">HRANDFIELD key [count [WITHVALUES]]</div><ul><li>최대 count개의 임의 field 반환</li><li>count가 음수인 경우, 중복이 허용된다</li><li>WITHVALUES : value를 함께 반환한다</li></ul><h3>HSCAN</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">HSCAN key cursor [MATCH pattern] [COUNT count]</div><p>hash에 대한<a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos2539133" target="_self">SCAN</a></p><h3>HSET</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">HSET key field value [field value ...]</div><p>key에 field-value 쌍 추가. 기존 value는 덮어씌어진다. 추가된 쌍의 개수 반환</p><h3>HSETNX</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">HSETNX key field value</div><p>field가 없는 경우에만 field-value 쌍 추가하고 1 반환. 그 외 0 반환</p><h3>HSTRLEN</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">HSTRLEN key field</div><p>value의 바이트 길이 반환</p><h3>HVALS</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">HVALS key</div><p>전체 value 목록 반환</p></div><h2>Stream</h2><div><h3>XACK</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">XACK key group id [id ...]</div><p>소비자 그룹에서 특정 entry들을 소비 완료했음을 지시</p><h3>XADD</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">XADD key [NOMKSTREAM] [MAXLEN | MINID [=|~] threshold [LIMIT count]] *|id field value [field value ...]</div><ul><li>새 entry 추가. field-value 쌍은 순서를 유지하여 저장되고, 클라이언트에도 동일한 순서로 전달된다</li><li>추가된 entry의 id를 반환한다</li><li>NOMKSTREAM : key에 스트림이 존재하지 않으면 무시</li><li>나머지 옵션은<a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos83853434" target="_self">XTRIM</a>참고</li></ul><h3>XAUTOCLAIM Since 6.2.0</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">XAUTOCLAIM key group consumer min-idle-time start [COUNT count] [JUSTID]</div><p>개념적으로 XPENDING 후 XCLAIM을 호출한 것과 동일하다</p><h3>XCLAIM</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">XCLAIM key group consumer min-idle-time id [id ...] [IDLE ms] [TIME unix-time-milliseconds] [RETRYCOUNT count] [FORCE] [JUSTID]</div><ul><li>지정한 id들에 대하여, min-idle-time 밀리초 이상 소비 완료 대기 중인 entry를 획득한다</li><li>IDLE : 대기 시간 재설정. 기본값은 0이며, 따라서 동일 명령으로 다른 소비자가 동일 entry를 가져가지 못하게 된다</li><li>TIME : 절대값(마지막 entry 배달 시각)을 이용해 대기 시간 재설정</li><li>RETRYCOUNT : 배달 카운터 재설정</li><li>FORCE : 소비 완료 대기 중이지 않은 entry도 처리</li><li>JUSTID : entry의 id만 반환. 배달 카운터를 증가하지 않는다</li></ul><h3>XDEL</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">XDEL key id [id ...]</div><ul><li>지정 entry 삭제. 삭제된 개수 반환</li><li>현재까지는 entry 삭제가 즉시 메모리 반환을 의미하지 않는다 -> macro-node의 모든 entry가 삭제 상태가 될 때 정리</li></ul><h3>XGROUP</h3><div><h4 class="fake">CREATE</h4><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">XGROUP CREATE key groupname id|$ [MKSTREAM] [ENTRIESREAD entries_read]</div><ul><li>소비자그룹 생성. 이미 동일 이름의 그룹이 존재하면 에러</li><li>id|$ : 지정 id 다음 엔트리부터 소비|그룹 생성 직후 엔트리부터 소비</li><li>MKSTREAM : key에 스트림이 없으면 생성</li></ul><h4 class="kafe">CREATECONSUMER Since 6.2.0</h4><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">XGROUP CREATECONSUMER key groupname consumername</div><p>소비자 명시적으로 생성</p><h4 class="fake">DELCONSUMER</h4><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">XGROUP DELCONSUMER key groupname consumername</div><p>소비자 삭제</p><h4 class="fake">DESTROY</h4><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">XGROUP DESTROY key groupname</div><p>소비자그룹 삭제</p><h4 class="fake">HELP</h4><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">XGROUP HELP</div><p>도움말 반환</p><h4 class="fake">SETID</h4><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">XGROUP SETID key groupname id|$ [ENTRIESREAD entries_read]</div><p>소비 기준 id 재설정</p></div><h3>XINFO</h3><div><h4 class="fake">CONSUMERS</h4><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">XINFO CONSUMERS key groupname</div><ul><li>소비자 정보 반환</li><li>name : 이름</li><li>pending : 소비 완료 대기 entry 개수</li><li>idle : 마지막 통신 이후 ms</li></ul><h4 class="fake">GROUPS</h4><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">XINFO GROUPS key</div><ul><li>소비자 그룹 정보 반환</li><li>name : 이름</li><li>consumers : 소비자 수</li><li>pending 전체 소비 완료 대기 entry 개수</li><li>last-delivered-id : 마지막으로 배달된 entry의 id</li><li>entries-read : 그룹이 읽은 entry 개수(부정확)</li><li>lag : 배달 대기 중인 entry 개수, 아래의 경우 일반 연산이 처리되기 전까지 nil이 반환될 수 있다</li><ul><li>그룹이 임의 last-delivered-id로 생성된 경우</li><li>그룹의 last-delivered-id와 스트림의 last-generated-id 사이의 entry가 삭제된 경우</li></ul></ul><h4 class="fake">HELP</h4><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">XINFO HELP</div><p>도움말 반환</p><h4 class="fake">STREAM</h4><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">XINFO STREAM key [FULL [COUNT count]]</div><ul><li>스트림 정보 반환</li><li>length : entry 개수</li><li>radix-tree-keys : 하위 데이터 구조에 존재하는 키의 수</li><li>radix-tree-nodes : 하위 데이터 구조에 존재하는 노드 수</li><li>groups : 그룹 개수</li><li>last-generated-id : 마지막으로 추가된 entry의 id</li><li>max-deleted-entry-id : 삭제된 entry 중 최대 id</li><li>entries-added : 스트림에 현재까지 추가된 entry 개수</li><li>first-entry : 첫 번째 entry의 id</li><li>last-entry : 마지막 entry의 id</li><li>FULL : entries, groups 정보 포함. count 기본값은 10</li></ul></div><h3>XLEN</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">XLEN key</div><p>entry 개수 반환. key가 없어도 0</p><h3>XPENDING</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">XPENDING key group [[IDLE min-idle-time] start end count [consumer]]</div><ul><li>key group만 지정한 경우</li><p>[소비 완료 대기 entry 개수, 최소 id, 최대 id, [소비 완료 대기 중인 소비자, 해당 소비자에 대해 대기 중인 entry 개수] ...] 반환</p><li>그 외의 경우</li><p>[[소비 완료 대기 중인 entry id, 소비자 이름, 배달 완료 후 시간(ms), 배달 횟수] ...] 반환</p></ul><h3>XRANGE</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">XRANGE key start end [COUNT count]</div><ul><li>id가 [start, end] 내에 있는 엔트리 반환</li><li>열린 구간을 지시하려면 '('를 접두에 붙이면 된다</li><li>전체를 가져오려면 start, end로 -, + 각각 이용</li><li>COUNT : 최대 count 개만 반환</li></ul><h3>XREAD</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] id [id ...]</div><ul><li>각 스트림에서 지정한 id보다 큰 entry를 count(기본 1)개 반환</li><li>BLOCK : 모든 스트림이 비어있는 경우, 최대 milliseconds 만큼 대기</li><li>BLOCK ... $ : 명령 이후 도착하는 것만 반환</li></ul><h3>XREADGROUP</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] id [id ...]</div><ul><li>소비자로써 엔트리 소비 지시</li><li><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos83781102" target="_self">XREAD</a>와 겹치는 옵션은 동일한 의미를 가진다</li><li>NOACK : XACK가 필요없다 -> 메시지 전달 즉시 소비 완료한 걸로 간주한다</li><li>entry id로 '>'를 이용하면 알아서 다음 entry를 획득한다</li></ul><h3>XREVRANGE</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">XREVRANGE key end start [COUNT count]</div><p><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos-1697859643" target="_self">XRANGE</a>의 역순</p><h3>XTRIM</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">XTRIM key MAXLEN|MINID [=|~] threshold [LIMIT count]</div><ul><li>필요한 경우 오래된 entry들을 삭제</li><li>MAXLEN : 크기가 threshold를 초과하는 경우 삭제</li><li>MINID : threshold보다 작은 id의 entry 삭제</li><p>XTRIM mystream MINID 649085820 -> id가 649085820-0보다 작은 entry들을 삭제한다</p><li>MAXLEN ~ : 다른 입출력에 지장이 없도록 어느 정도의 오차를 허용</li><li>LIMIT : 최대 count개만 제거</li></ul></div><h2>Pub/Sub</h2><div><h3>PSUBSCRIBE</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">PSUBSCRIBE pattern [ pattern ...]</div><p><span class="hover-content" template-id="glob-style-pattern">GLOB style pattern</span>에 일치하는 채널들 구독</p><h3>PUBLISH</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">PUBLISH channel message</div><p>메시지 발행</p><h3>PUBSUB</h3><div><h4 class="fake">CHANNELS</h4><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">PUBSUB CHANNELS [pattern]</div><p>채널 목록 반환</p><h4 class="fake">HELP</h4><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">PUBSUB HELP</div><p>도움말 반환</p><h4 class="fake">NUMPAT</h4><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">PUBSUB NUMPAT</div><p><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos465258202" target="_self">PSUBSCRIBE</a>로 구독 중인 패턴 개수 반환</p><h4 class="fake">NUMSUB</h4><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">PUBSUB NUMSUB [channel [channel ...]]</div><p>구독자 수 반환</p><h4 class="fake">SHARDCHANNELS Since 7.0.0</h4><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">PUBSUB SHARDCHANNELS [pattern]</div><p>샤드 채널 목록 반환</p><h4 class="fake">SHARDNUMSUB Since 7.0.0</h4><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">PUBSUB SHARDNUMSUB [channel [channel ...]]</div><p>샤드 채널 구독자 수 반환</p></div><h3>PUNSUBSCRIBE</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">PUNSUBSCRIBE [pattern [pattern ...]]</div><p>구독 취소</p><h3>SPUBLISH Since 7.0.0</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">SPUBLISH channel message</div><p>샤드 채널에 메시지 발행</p><h3>SSUBSCRIBE Since 7.0.0</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">SSUBSCRIBE channel [channel ...]</div><p>샤드 채널 구독</p><h3>SUBSCRIBE</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">SUBSCRIBE channel [channel ...]</div><p>채널 구독</p><h3>SUNSUBSCRIBE Since 7.0.0</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">SUNSUBSCRIBE [channel [channel ...]]</div><p>샤드 채널 구독 취소</p><h3>UNSUBSCRIBE</h3><p><strong>↓ syntax</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">UNSUBSCRIBE [channel [channel ...]]</div><p>구독 취소</p></div></div><h1>Redis Stack</h1><p>레디스 서버에 여러 모듈이 추가되어 아래와 같은 기능을 지원한다</p><ul><li>RediSearch : 추가 인덱싱, 쿼리 지원, 전문 검색 등 지원</li><li>RedisJSON : JSON 모델 지원</li><li>RedisGraph : 그래프 모델 지원</li><li>RedisTimeSeries : 기간을 이용한 쿼리, 집계 쿼리 등 지원</li></ul><div class="w3-container w3-leftbar w3-border-green w3-white hover-template" id="glob-style-pattern"><ul><li>* : 임의 길이 임의 문자열</li><li>? : 임의 문자 1개</li><li>[abc] : 문자 집합 중 1글자</li><li>[^abc] : 여집합 중 1글자</li><li>[a-z] : 문자 집합 중 1글자</li></ul></div><div class="w3-container w3-leftbar w3-border-green w3-white hover-template" id="zset-score-range"><ul><li>기본적으로 min max는 닫힌 구간 [min, max]를 의미한다</li><li>열린 구간 표현을 위해 '('를 이용할 수 있다</li><p>e.g. (10 (20</p><li>-inf, +inf를 min, max로 이용할 수 있다</li></ul></div><div class="w3-container w3-leftbar w3-border-green w3-white hover-template" id="zset-lexicographical-range"><ul><li>구간 표현 시 min, max 앞에 [ 또는 (를 명시해야한다</li><p>e.g. [hello (world</p><li>특별히 -, +를 무한대 표현으로 이용할 수 있다</li><p>e.g. - (world</p></ul></div></article></main></body></html>