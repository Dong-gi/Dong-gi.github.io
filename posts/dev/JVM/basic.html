<!DOCTYPE html><html lang="ko-KR"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Java</title><link rel="stylesheet" href="/source/default.css"><meta name="google-site-verification" content="aH-DyzdytYQ0NPHNQFcs5dVoiu5YNs6CEEHYgqDmAFM"><meta name="author" content="Donggi Kim &lt;hi.donggi@gmail.com&gt;"><meta name="description" content="Java 튜토리얼"><link rel="icon" href="/imgs/favicon.png"><script id="google-analytics" src="https://www.googletagmanager.com/gtag/js?id=UA-143098403-1" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-143098403-1');</script><script id="highlight-js" src="/source/highlight.pack.js" defer></script><script id="default-js" src="/source/default.min.js" defer></script></head><body><aside class="w3-animate-left" id="sidebar"><hr><div id="marker-list"></div><hr><div id="post-list"></div><hr><details class="w3-small file-list"><summary>LICENSE</summary><table><tr><td>Author</td><td>License</td></tr><tr><td>&copy; <a href="mailto:hi.donggi@gmail.com">Donggi Kim</a></td><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/Dong-gi/Dong-gi.github.io/blob/master/LICENSE">MIT</a></td></tr><tr><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://www.w3schools.com/w3css">w3css</a></td><td>No license</td></tr><tr><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://highlightjs.org/">highlight.js</a></td><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/highlightjs/highlight.js/blob/main/LICENSE">BSD-3-Clause</a></td></tr><tr><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/mathjax/MathJax">MathJax</a></td><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/mathjax/MathJax/blob/master/LICENSE">Apache-2.0</a></td></tr><tr><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/davidshimjs/qrcodejs">QRCode.js</a></td><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/davidshimjs/qrcodejs/blob/master/LICENSE">MIT</a></td></tr><tr><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/terrastruct/d2">D2</a></td><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/terrastruct/d2/blob/master/LICENSE.txt">MPL-2.0</a></td></tr></table></details><hr></aside><main id="main"><nav class="w3-bar w3-blue" id="nav"><button class="w3-bar-item w3-button w3-hover-theme" id="nav-toggle-btn">&#9776;</button><form role="search"><input class="w3-bar-item" id="query" type="search" placeholder="search" style="max-width:35%"></form><a class="w3-bar-item w3-button w3-hover-theme" href="/">Home</a></nav><article id="contents"><h1>개발 환경 구성</h1><ol><li>JDK 설치</li><ul><li>2019년 1월부로 오라클 JDK SE 버전이 전면 유료화되므로, OpenJDK를 설치한다<a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="http://openjdk.java.net/install/">install</a></li><li>또는 다른 벤더를 이용해도 괜찮다<a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://sdkman.io/jdks">jdks</a></li><li>Microsoft가 관리하는 빌드도 존재한다 <a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://www.microsoft.com/openjdk">www.microsoft.com/openjdk</a></li></ul><li>환경변수 설정</li><ul><li>JAVA_HOME, JRE_HOME 예시 » C:\Program Files\Java\jdk-10.0.2</li><li>Path » %JAVA_HOME%\bin</li></ul><li>IDE 설치</li><p>Eclipse, IntelliJ Community, VS Code 등 취향에 맞게 설치한다</p></ol><div><h2>Eclipse 환경 설정 : Window » Preferences</h2><ul><li>Content Assist 단축키 설정</li><p>General - Keys - Content Assist</p><li>폰트 설정</li><p>General - Appearance - Colors and Fonts : Basic - Text Font 및 기타 폰트를 시력에 맞게 설정</p><li>포매터 설정</li><p>General - Editors - Text Editors : Insert spaces for tabs 체크, Show line numbers 체크</p><p>Java → Code Style → Formatter → New → Indentation → Tab Policy = Space Only</p><p>기존 파일에 Formatter 적용하고자 하는 경우 : 적용할 소스 or 프로젝트 우클릭 → Source → Format</p><li>인코딩 설정</li><p>General - Workspace : Text file encoding을 UTF-8로 설정</p><p>Web - CSS Files, HTML Files, JSP Files : Encoding을 UTF-8로 설정</p><li>JDK 설정</li><p>Java - Installed JREs : jre가 아닌 jdk로 설정</p></ul></div><h1>이클립스 HelloWorld 프로젝트</h1><ol><li>프로젝트 생성</li><p>"File" 메뉴 클릭, 또는 "Package Explorer"에서 우클릭 - New - Java Project<br>없으면 New - Other... - Java - Java Project를 선택<br><figure class="w3-center w3-margin-bottom"><img class="w3-round" src="/imgs/20180826_213734.png" alt="Can't load image" loading="lazy"><figcaption>&lt;20180826_213734.png></figcaption></figure></p><li>Main 클래스 생성</li><p>"Package Explorer"의 해당 프로젝트에서 우클릭 - New - Class<br><figure class="w3-center w3-margin-bottom"><img class="w3-round" src="/imgs/20180826_214148.png" alt="Can't load image" loading="lazy"><figcaption>&lt;20180826_214148.png></figcaption></figure><br>Name에는 "HelloWorld"(공백 없음에 유의)를 적고, public static void main(String[] args)를 체크</p><li>실행</li><p><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Single/tutorial/HelloWorld.java" lan="java">HelloWorld.java</button> 와 같이 코드를 작성하고 Run<br>콘솔 결과창이 보이지 않는다면 Window - Show View - Console 선택</p></ol><h1>개발 과정</h1><ol>"»" 우측은 산출물<li>코딩 » .java 소스 코드</li><li>컴파일 by 컴파일러 » .class 바이트 코드 = 중간 언어</li><p>javac.exe가 담당. javap.exe는 그 반대(역어셈블러).</p><li>해석 by JVM 인터프리터 » 기계어</li><p>java.exe가 담당<br>JIT(Just-In-Time) : 한 번 해석한 바이트 코드를 다시 해석하지 않고, 이전에 해석된 기계어를 가져다 이용</p><li>실행 by CPU</li><li>참고</li><p>javadoc.exe : 주석 html 문서 생성<br>jar.exe : Java ARchive. 프로그램 실행에 관련된 파일들을 .jar파일로 압축</p></ol><h1>주석</h1><ol><li>주석(Comment)은 프로그래머를 위한 것으로, 컴파일러는 무시하는 문장들이다</li><li>// : '//'부터 줄의 끝까지 무시한다</li><li>/* */ : '/*'와 '*/' 사이의 모든 텍스트를 무시한다<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Single/tutorial/Comment.java" lan="java">Comment.java</button></li></ol><h1>식별자</h1><ul><li>식별자(Identifier)는 의미 있는 코드에 붙이는 이름을 의미한다. 의미 있는 코드에는 변수(Variable), 상수(Constant), 메서드, 클래스 등이 있다</li><li>자바 식별자는 '_', '$'의 사용을 허용한다. 단, '_' 단독으로는 사용할 수 없다</li><li>식별자 관례 : 상수는 SNAKE_CASE, 상수를 제외한 식별자는 camelCase 이용. 클래스는 CamelCase<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Single/tutorial/Identifier.java" lan="java">Identifier.java</button></li></ul><h1>자료형, 연산</h1><ul><li>자료형은 메모리 상에서 값이 표현되는 형식을 정의한다</li><li>기본 자료형(Base Type; Primitive Type)</li><p>참조 자료형이 아닌 자바의 8가지 기본 자료형은 메모리 상에 값이 그대로 존재한다. boolean, char, byte, short, int, long, float, double<br>식별자 없이 값 자체를 나타내는 코드를 리터럴(Literal)이라 부른다. 각 자료형의 리터럴과 적용되는 연산은 아래의 예시 코드 참고<br><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Single/tutorial/BooleanExample.java" lan="java">BooleanExample.java</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Single/tutorial/CharExample.java" lan="java">CharExample.java</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Single/tutorial/NumberExample.java" lan="java">NumberExample.java</button></p><li>참조 자료형(Reference Type)</li><p>메모리의 주소를 통해 값에 접근한다. C/C++의 포인터와 같지만, 자바는 포인터 연산을 지원하지는 않는다<br><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Single/tutorial/StringExample.java" lan="java">StringExample.java</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Single/tutorial/ArrayExample.java" lan="java">ArrayExample.java</button></p><li>변수 할당</li><p>기본 자료형 변수는 정적 할당, 참조 자료형 변수는 동적 할당된다. 동적 할당된 객체들은 자동으로 GC 대상이 된다</p><ul><li>정적 할당</li><p>컴파일러가 메모리 점유를 정확하게 예측할 수 있는 (지역)변수를 생성하는 방법으로, 선언과 동시에 스택 영역에 할당되어 코드 블록이 끝나는 순간 해제된다<br>클로저 Closure : 동적 할당되어 유지되는 객체 안에 정적 할당되는 변수를 선언하여 정적 변수의 소멸 시기를 스코프 밖으로 지연시키는 것</p><li>동적 할당</li><p>동적으로 할당되는 객체들은 힙 영역에 생성되며, 그 참조가 유지되는 한 프로그램 종료시까지 유지된다</p></ul><li>형변환 Type Casting</li><ul><li>묵시적 형변환</li><p>자식 타입 변수는 부모 타입 변수에 그냥 할당 가능. 산술 연산시에도 자동으로 이루어진다</p><li>명시적 형변환 - (clazz)</li><p>부모 타입 변수를 자식 타입 변수에 할당하는 경우, (clazz) 명시 필요. 경우에 따라 경고가 표시된다</p><li>Checked Casting</li><p>경고 없이 명시적으로 형변환하는 것. clazz.cast(object)를 이용한다</p></ul></ul><h1>구문</h1><p>if, for, while, do-while, switch, try-catch, try-with-resource</p><ul><li>switch 조건식에 정수(char 포함), String, Enum이 허용된다</li><li>반복문에 label을 설정해 중첩된 루프들 중 어느 것이든 break/continue시킬 수 있다</li><li>Iterable하면 향상된 for 구문을 이용할 수 있다</li><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Single/tutorial/Switch.java" lan="java">Switch.java</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Single/tutorial/LabelFor.java" lan="java">LabelFor.java</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Single/tutorial/EnhancedFor.java" lan="java">EnhancedFor.java</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Single/tutorial/TryWithResource.java" lan="java">TryWithResource.java</button></ul><h1>Varargs</h1><ul><li>가변 길이 매개변수 선언 : Type... 배열명</li><p>나열된 매개변수들이 하나의 배열로 넘겨지며, 배열 자체를 넘길 수 있다<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Single/tutorial/VarArgs.java" lan="java">VarArgs.java</button></p></ul><h1>제한자(Modifier)</h1><ol><li>접근 제한자 : 부모의 것보다 접근 범위를 넓힐 수는 있지만, 축소할 수는 없다</li><ul><li>private : 해당 클래스 내부에서만 접근 가능</li><li>생략(default) : 같은 패키지 내부에서만 접근 가능</li><li>protected : 같은 패키지 or 하위 클래스에서만 접근 가능</li><li>public : 어디서든지 접근 가능</li></ul><li>그 외</li><ul><li>static : 클래스 로드시 하나만 생성. 클래스 이름을 통해 접근</li><li>final : 재정의 불가, 상속 불가, 수정 불가; 메서드의 매개변수도 final일 수 있다</li><li>abstract : 인스턴스화 불가(클래스, 인터페이스). body를 가질 수 없음(메서드). 추상 클래스만 추상 메서드를 정의할 수 있다</li><li>native : JNI로 구현한 메서드</li><li>transient : 직렬화 제외</li><li>synchronized : LOCK 객체에 동기화(스레드 수준 동기화)</li><li>volatile : 값을 CPU 캐시를 사용하지 않고 메인 메모리에 직접 읽고/쓴다(코어 수준 동기화). 컴파일러에 의해 volatile 변수가 이용되는 문장의 실행 순서가 재배치되지 않는다</li></ul><li>요소별 접근 제한자 목록 : java.lang.reflect.Modifier</li><ul><li>Outer Class : abstract, final, public, default</li><li>Inner Class : abstract, final, private, protected, public, static, default</li><li>Outer Interface : abstract, public, default</li><li>Inner Interface : abstract, private, protected, public, static, default</li><li>Constructor : private, protected, public, default</li><li>Method : All</li><li>Variable : final, private, protected, public, static, default</li></ul></ol><h1>클래스</h1><ul><li>자바 코드의 기본 단위는 클래스(Enum, Interface도 클래스임에 유의)이며, 파일 이름과 파일 내 클래스 이름 중 하나는 동일해야 한다. 이 이름이 동일한 클래스만 파일 내부에서 public으로 정의될 수 있다</li><li>객체 지향 3원리</li><ol><li>캡슐화 : 코드와 데이터를 함께 묶고 외부의 불필요한 접근을 제한</li><li>상속 : 상위 클래스의 속성들을 하위 클래스에서 그대로 이용</li><li>다형성(Polymorphism) : 상위 타입 참조 변수로 하위 타입 객체를 참조할 수 있고, 이를 통해 호출하는 메서드는 실제로 참조하는 객체의 타입에 따라 나중에 결정된다</li></ol><li>초기화 블록</li><ul><li>class initializer : 클래스 내의 static {} 블록으로, 클래스 로드시 한 번 호출된다</li><li>instance initializer : 클래스 내의 {} 블록으로, 객체 생성시 한 번 호출된다<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Single/tutorial/ClassExample.java" lan="java">초기화 블록, 상속, 다형성 예시 »</button></li></ul><li>this : 객체 자신을 가리키는 키워드. this()를 통해 다른 생성자 호출, this.methodName()을 통해 다른 메서드 호출, ClassName.this를 통해 가려진 영역의 객체 참조</li><li>super : 부모 클래스를 가리키는 키워드. super()를 통해 부모 메서드 호출, super.methodName()을 통해 다른 메서드 호출</li><li>자바는 오버라이드를 명시하지 않아도 재정의한 메서드를 호출해준다.(= Dynamic method dispatch)</li><li>instanceof 연산자로 호환 여부 확인 가능</li><li>{}를 이용해 간단하게 익명클래스를 작성할 수 있다<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Single/tutorial/AnonymousClass.java" lan="java">익명클래스 객체 예시 »</button></li></ul><h1>인터페이스</h1><ul><li>인터페이스 내부의 모든 요소는 기본적으로 public이다. JDK 9에서 private 메서드 지원 추가</li><li>인터페이스는 final 멤버 변수를 가질 수 있다</li><li>인터페이스의 메서드는 기본적으로 body가 없지만, default method는 가질 수 있다</li><li>인터페이스 구현 : implements</li><li>추상클래스는 인터페이스를 부분적으로 구현해도 된다</li><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Single/tutorial/InterfaceExample.java" lan="java">InterfaceExample.java</button><li>여러 인터페이스를 동시에 구현할 수 있다</li><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">public class Test implements I1, I2 {
    public static void main(String[] args) {
        var test = new Test();
        test.method();          // I1 I2 Override
        ((I1) test).method();   // I1 I2 Override
        ((I2) test).method();   // I1 I2 Override
    }
    @Override
    public void method() {
        I1.super.method();
        I2.super.method();
        System.out.println(" Override");
    }
}
interface I1 {
    default public void method() {
        System.out.print(" I1");
    }
}
interface I2 {
    default public void method() {
        System.out.print(" I2");
    }
}
</div></ul><h1>중첩 클래스</h1><ul><li>Static Nested Class : 외부 클래스 이름으로 접근</li><li>Non-Static Nested Class : 외부 클래스 객체로 접근</li><li>Inner Interface : 외부 클래스 이름으로 접근</li><li>Anonymous Class : 외부 클래스 final 멤버 접근 가능</li><li>Local Class : 외부 클래스 final 멤버 접근 가능</li><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Single/tutorial/Nested.java" lan="java">Nested.java</button></ul><h1>람다</h1><ul><li>@FunctionalInterface</li><ul><li>미구현 메서드가 1개만 있는 인터페이스</li><li>java.util.function 패키지에 유용한 FunctionalInterface들이 정의되어 있다</li><li>기존의 인터페이스에 static 메서드가 추가되었다. 예) Comparator.comparing</li></ul><li>익명 메서드 Lambda : FunctionalInterface의 메서드만을 명시함으로써 익명 객체를 생성한다</li><p>시그니처를 간소화하는 것은 어디까지나 정의가 분명할 때뿐이다<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Single/tutorial/Lambda2.java" lan="java">Lambda2.java</button></p><li>메서드 참조를 이용해 기정의된 메서드를 람다로 이용할 수 있다. '::' 연산자를 이용한다</li><li>생성자 참조 » "::new". 배열 생성자 int[]::new도 가능<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Single/tutorial/Lambda.java" lan="java">Lambda.java</button></li></ul><h1>Object 클래스</h1><ol><li>Object는 모든 참조 자료형의 부모로, 가장 기본적인 클래스다</li><li>protected Object clone()</li><ol><li>객체의 복사본을 생성하여 반환한다.(얕은 복사)</li><li>Object.clone()의 접근제한자는 protected이다. 이는 얕은 복사본의 이용으로 원본 객체까지 변경되는 것을 막기 위함이다</li><li>clone()을 재정의할 때, Cloneable 마커 인터페이스를 구현하는데, 마커 인터페이스는 추상 메소드 없이, 클래스가 단순히 해당 기능을 가짐을 나타낸다</li><p>implements Cloneable 지정하지 않으면 super.clone() 호출 시 CloneNotSupportedException 발생</p></ol><li>boolean equals(Object obj)</li><p>Object 클래스의 equals 구현 : return this == obj;<br>equals()를 오버라이드할 경우 non-null 참조 변수들에 대해 아래의 원칙을 만족해야 한다</p><ol><li>x.equals(null) == false</li><li>Reflexive : x.equals(x) == true</li><li>Symmetric : x.equals(y) == y.equals(x)</li><li>Transitive : x.equals(y) == true AND y.equals(z) == ture IMPLIES x.equals(z) == true</li><li>Consistence : 객체의 참조가 변하지 않는 한 equals()는 항상 같은 값을 반환해야 한다</li></ol><li>String toString() : 객체의 문자열 표현 반환</li><li>Class&lt;?> getClass() : 객체의 Class를 반환</li><li>int hashCode() : 객체의 hash code 반환 // HashSet, HashMap 등에서 이용</li><li>void notify() : 해당 객체에 대해 대기하는 스레드를 깨운다</li><li>void notifyAll() : 해당 객체에 대해 대기하는 모든 스레드를 깨운다</li><li>void wait() : 해당 객체에 대해 스레드를 대기</li><li>void wait(long timeout) : 깨워질 때까지 최대 timeout ms동안 대기</li><li>void wait(long timeout, int nanos) : timeout ms + nanos ns</li><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Single/tutorial/ObjectExample.java" lan="java">예시 : clone, equals, hashCode, toString, compareTo »</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Single/tutorial/Notify.java" lan="java">예시 : notify, wait »</button><li>@Deprecated(since="9") protected void finalize()</li><p>객체 폐기 메서드였던 것<br>대안 : Non-heap 리소스를 갖는 객체들에 대하여 명시적인 자원 해제 메서드를 지원해야 하며, 가능하면 AutoCloseable을 구현한다
java.lang.ref.Cleaner, java.lang.ref.PhantomReference는 참조되지 않는 객체를 해제하는 데 유연한 방법을 <a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/lang/ref/Cleaner.html">제공한다</a></p></ol><h1>패키지</h1><ul><li>패키지는 네임스페이스와 비슷한 역할을 하며, 클래스들을 구분해준다. 파일시스템 상에서 디렉터리(폴더)로 표현된다</li><li>일반적으로 패키지 이름은 도메인의 역순으로 구성하고, 소문자만을 이용한다</li><li>패키지 내부에 패키지를 가질 수 있다. package package1.sub1;</li><li>import 패키지.(이름 or *); 이름 충돌이 발생할 때는 패키지 이름을 명시한다</li><li>정적 멤버 임포트 : import static package . className . ( staticMemberName | * );</li></ul><h1>Enum</h1><ul><li>모든 enum은 Enum&lt;E>를 상속하므로, 추가로 다른 클래스를 상속할 수 없다</li><li>enum은 여타 클래스와 같이 멤버 변수, 메서드를 가질 수 있으며, private 생성자와 abstract method도 가질 수 있다</li><li>enum은 로드시 한번만 생성되므로 싱글톤을 간단하게 구현할 수 있다</li><li>Enum&lt;E> :: name, toString, ordinal, compareTo, valueOf</li><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Single/tutorial/EnumExample.java" lan="java">EnumExample.java</button></ul><h1>예외</h1><ul><li>Throwable « Exception(Checked Exception) « RuntimeException(Unchecked Exception)</li><li>Error : 프로그램 내부에서 해결할 수 없어 종료됨</li><li>Unchecked Exception은 따로 처리하지 않아도 프로그램이 계속 실행된다</li><li>Chained Exceptions : 하나의 예외로 인해 다른 예외들이 발생할 수 있다. JDK 1.4부터 근원적인 예외를 알아올 수 있는 방법이 추가되었다</li><ol><li>Throwable(Throwable causeExc), Throwable(String msg, Throwable causeExc) : 보다 근본적인 원인을 인자로 하여 새로운 예외 생성</li><li>Throwable initCause(Throwable causeExc) : 예외의 근원을 설정하며, 생성자를 통해 호출되거나 이미 호출된 경우 다시 호출 불가</li><li>Throwable getCause() : 현재 예외의 근원을 얻는다. 없으면 null</li></ol><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Single/tutorial/ExceptionExample.java" lan="java">ExceptionExample.java</button><li>부모보다 많은 종류의 예외를 공표할 수 없다</li></ul><h1>옵션 타입</h1><p>Optional&lt;T> : T 타입의 존재 여부를 포함하는 T타입 컨테이너<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Single/tutorial/OptionalExample.java" lan="java">OptionalExample.java</button></p><h1>제네릭</h1><ul><li>여러 타입을 기본 요소로 할 수 있는 범용 클래스/인터페이스 작성을 위한 문법</li><li>A가 B의 서브타입일 때, A[]는 B[]의 서브타입이지만, G&lt;A>는 G&lt;B>의 서브타입이 아니다</li><p>Erasure : 컴파일 시 제네릭 타입을 모두 지우고 바운드 타입으로(명시되지 않았다면 Object) 변경한다. javap를 통해 이를 확인할 수 있다<br>자식 메서드의 Erasure가 부모와 다를 때 부모 메서드는 bridge 메서드가 되어 자식의 Erasure를 이용하는 메서드를 호출한다. 이 과정에서 리턴 타입만 다른 메서드들이 생성될 수 있지만, 바이트 코드 단계기 때문에 에러가 발생되지 않고 잘 처리된다</p><li>메서드에서는 와일드카드 '?'를 이용하여 임의 제네릭 타입을 매개변수로 받을 수 있다</li><li>제네릭을 통한 객체 생성 불가. 제네릭을 static 요소에서 이용하는 데 제한</li><li>제네릭 타입의 선언, 제네릭 리스트 일부 구현, 바운드된 타입 매개변수 선언<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Single/tutorial/Generic.java" lan="java">Generic.java</button></li><li>비제네릭 클래스의 제네릭 생성자 선언, 비제네릭 클래스 - 제네릭 클래스 상속<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Single/tutorial/Generic2.java" lan="java">Generic2.java</button></li></ul><h1>컬렉션</h1><ul><li>동형 객체들을 저장하는 자료구조; 스택, 큐, 리스트, Set, Map 등</li><li>사용 시 스레드 동기화에 유의</li><li>복사본을 사용/반환하도록 방어적으로 구현하는 것이 도움이 될 수 있다</li></ul><h1>JUnit</h1><p>단위 테스트에 사용되는 라이브러리<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Gradle/JUnit-Example/src/test/java/x/AppTest.java" lan="java">AppTest.java</button></p><p><strong>↓ 실행 결과</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="shell">$ ./gradlew test -i
> Task :test

AppTest STANDARD_OUT
    Before All

AppTest > timeout() STANDARD_OUT
    Before Each
    After Each

AppTest > asserts() STANDARD_OUT
    Before Each
    After Each

AppTest > appHasAGreeting() STANDARD_OUT
    Before Each
    After Each

AppTest > exception() STANDARD_OUT
    Before Each
    After Each

AppTest STANDARD_OUT
    After All
Finished generating test XML results (0.002 secs) into: D:\Dong-gi.github.io\Repositories\Gradle\JUnit-Example\build\test-results\test
Generating HTML test report...
Finished generating test html results (0.003 secs) into: D:\Dong-gi.github.io\Repositories\Gradle\JUnit-Example\build\reports\tests\test
:test (Thread[Execution worker for ':',5,main]) completed. Took 1.483 secs.

BUILD SUCCESSFUL in 3s
3 actionable tasks: 2 executed, 1 up-to-date</div></article></main></body></html>