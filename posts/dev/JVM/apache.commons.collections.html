<!DOCTYPE html><html lang="ko-KR"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Apache Commons Collections 4.4</title><link rel="stylesheet" href="/source/default.css"><meta name="google-site-verification" content="aH-DyzdytYQ0NPHNQFcs5dVoiu5YNs6CEEHYgqDmAFM"><meta name="author" content="Donggi Kim &lt;hi.donggi@gmail.com&gt;"><meta name="description" content="Apache Commons Collections 정리"><link rel="icon" href="/imgs/favicon.png"><script id="highlight-js" src="/source/highlight.pack.js" async></script><script id="default-js" src="/source/default.min.js" defer></script><script id="google-analytics" src="https://www.googletagmanager.com/gtag/js?id=UA-143098403-1" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-143098403-1');
</script></head><body><aside class="w3-animate-left" id="sidebar"><hr><div id="marker-list"></div><hr><div id="post-list"></div><hr><details class="w3-small"><summary>LICENSE</summary><table class="w3-table-all w3-card w3-small"><tr><td>Author</td><td>License</td></tr><tr><td>&copy; <a href="mailto:hi.donggi@gmail.com">Donggi Kim</a></td><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/Dong-gi/Dong-gi.github.io/blob/master/LICENSE">MIT</a></td></tr><tr><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://www.w3schools.com/w3css">w3css</a></td><td>No license</td></tr><tr><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://highlightjs.org/">highlight.js</a></td><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/highlightjs/highlight.js/blob/main/LICENSE">BSD-3-Clause</a></td></tr><tr><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/mathjax/MathJax">MathJax</a></td><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/mathjax/MathJax/blob/master/LICENSE">Apache-2.0</a></td></tr><tr><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/davidshimjs/qrcodejs">QRCode.js</a></td><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/davidshimjs/qrcodejs/blob/master/LICENSE">MIT</a></td></tr><tr><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/terrastruct/d2">D2</a></td><td><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/terrastruct/d2/blob/master/LICENSE.txt">MPL-2.0</a></td></tr></table></details><hr></aside><main id="main"><nav class="w3-bar w3-blue" id="nav"><button class="w3-bar-item w3-button w3-hover-theme" id="nav-toggle-btn" type="button">&#9776;</button><form role="search"><input class="w3-bar-item" id="query" type="search" placeholder="search" style="max-width:35%"></form><a class="w3-bar-item w3-button w3-hover-theme" href="/">Home</a></nav><article id="contents"><h1>org.apache.commons.collections4</h1><p>참고 자료 : <a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black" href="https://commons.apache.org/proper/commons-collections/javadocs/api-4.4/index.html">index</a></p><div><h2>컬렉션 자료형 인터페이스</h2><div><h3>BoundedCollection&lt;E></h3><ol><li>크기 제한을 갖는 컬렉션</li><li>isFull(), maxSize()</li></ol><h3>Bag&lt;E></h3><ol><li>컬렉션이 보유한 객체에 대한 개수를 유지한다</li><li>예를 들어, Bag {a, b, c, a} 인스턴스에 대해 getCount(a) == 2, uniqueSet() == {a, b, c}</li><li>Bag의 일부 메서드는 Collection API와 다르게 작동하므로, Collection으로 참조하지 않을 것을 권장하고 있다</li></ol><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">boolean add(E object)
    // uniqueSet()에 있다면 카운트만 1 증가하고 false 반환
    // uniqueSet()에 없다면 사본 추가 → 카운트 1 설정 → true 반환
boolean remove(Object object)
    // object를 모두 제거하고, 컬렉션의 변동이 있다면 true를 반환한다
boolean remove(Object object, int nCopies)

boolean containsAll(Collection&lt;?> coll)
    // coll의 모든 요소가 uniqueSet()에 존재하고, 각 요소에 대한 getCount(Object)가 coll에 존재하는 개수보다 크거나 같은 경우 true 반환
boolean removeAll(Collection&lt;?> coll)
    // coll의 모든 요소에 대해 한 번씩 remove(Object)를 호출한 것과 같다
boolean retainAll(Collection&lt;?> coll)
    // coll에 포함된 요소만 Bag에 유지하되, coll에 존재하는 개수만큼만 최대로 유지한다
</div><h3>SortedBag&lt;E></h3><p>Comparator&lt;? super E>를 이용해 원소 정렬</p><h3>MultiSet&lt;E></h3><p>Bag과 유사하지만, Collection API를 좀 더 적절하게 따른다</p><h3>IterableMap&lt;K, V></h3><p>엔트리 집합을 만들지 않고 MapIterator를 지원</p><h3>IterableSortedMap&lt;K, V></h3><p><a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="java.base.html#pos1997071679" target="_blank">SortedMap</a> + <a class="w3-padding w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos273478074" target="_self">OrderedMap&lt;K, V&gt;</a></p><h3>BoundedMap&lt;K, V></h3><p>크기 제한이 있는 맵</p><h3>BidiMap&lt;K, V></h3><ol><li>키와 값이 일대일 대응을 만족하도록 강제하여, 값을 통한 키의 탐색이 가능하게 한다</li><li>값을 통한 키의 탐색은 키를 통한 값의 탐색과 동일한 성능으로 이루어져야 한다</li><li>키와 값의 위치를 뒤집은 BidiMap을 반환하는 inverseBidiMap() 연산도 지원한다</li></ol><h3>SortedBidiMap&lt;K, V></h3><p>키, 값 모두에 대한 Comparator를 갖고 있어, inverseBidiMap() 또한 SortedBidiMap</p><h3>MultiValuedMap&lt;K, V></h3><ol><li>키에 대한 값들을 컬렉션에 보관하는 맵을 정의한다</li><li>키를 통해 얻은 컬렉션의 변경 가능 여부는 구현에 따라 다를 수 있다</li><li>ListValuedMap&lt;K, V> + SetValuedMap</li></ol><h3>OrderedMap&lt;K, V></h3><p>키를 정렬하여 보존하고, 앞뒤로 순회 가능한 맵</p><h3>OrderedBidiMap&lt;K, V></h3><p>inverseBidiMap() 또한 OrderedBidiMap</p><h3>Trie&lt;K, V></h3><p>Prefix tree에 대해 정의한다<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" type="button" title="/Repositories/Eclipse/apache-commons-collections-example/src/test/java/TrieTest.java" displayRange="[13,32]" lan="java">TrieTest.java</button><figure class="w3-center w3-margin-bottom"><img class="w3-round" src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/be/Trie_example.svg/1024px-Trie_example.svg.png" alt="Can't load image" loading="lazy" style="max-width:300px;"/><figcaption>&lt;1024px-Trie_example.svg.png></figcaption></figure></p></div><h2>컬렉션 연산 인터페이스</h2><div><h3>Unmodifiable</h3><p>컬렉션 변경 연산이 제공되지 않음을 표시하는 마커 인터페이스</p><h3>Get&lt;K, V></h3><p>Map 인터페이스의 읽기 기능에 대한 정의를 담고 있다. 라고 적혀있지만 remove(Object) 메서드는 여기에 있다</p><h3>IterableGet&lt;K, V></h3><p>이 인터페이스를 구현한 Map은 mapIterator() 메서드를 통해 MapIterator&lt;K, V>를 제공한다</p><h3>Put&lt;K, V></h3><p>Map 인터페이스의 쓰기 기능에 대한 정의를 담고 있다.  Put(K, V)는 V가 아닌 Object를 반환함에 유의</p><h3>FluentIterable&lt;E></h3><p>Stream과 유사한 기능을 제공하는 Iterable </p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">FluentIterable&lt;E> eval() // 독립적인 새로운 뷰 반환
FluentIterable&lt;E> append(E... elements)
FluentIterable&lt;E> collate(Iterable&lt;? extends E> other[, Comparator&lt;? super E> comparator])
    // 현재 뷰 + other로 구성된 새로운 뷰를 정렬하여 반환
    // comparator 지정하지 않은 경우 ComparatorUtils.NATURAL_COMPARATOR 사용

FluentIterable&lt;E> loop()
FluentIterable&lt;E> reverse()
FluentIterable&lt;E> skip(long elementsToSkip)
&lt;O> FluentIterable&lt;O> transform(Transformer&lt;? super E, ? extends O> transformer)
FluentIterable&lt;E> unique()
FluentIterable&lt;E> zip(Iterable&lt;? extends E> others...)

boolean contains(Object object)
E get(int position)
</div><h3>OrderedIterator&lt;E></h3><p>역방향 순회를 추가로 지원한다</p><h3>MapIterator&lt;K, V></h3><ol><li>이 인터페이스를 제공하는 Map은 내부에서 데이터를 Entry 객체로 유지하지 않는다(불필요한 객체 생성 방지).</li><p>Entry 대신 키를 이용해 순회</p><li>remove(), setValue() 연산은 구현에 따라 지원하지 않을 수 있다</li></ol><h3>OrderedMapIterator&lt;K, V></h3><p>OrderedMap에 대한 MapIterator</p><h3>ResettableIterator&lt;E> ResettableListIterator</h3><p>reset() : Iterator가 생성됐을 때 초기 위치로 돌아간다</p></div><h2>유틸리티 클래스</h2><div><h3>BagUtils</h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static &lt;E> Bag&lt;E> collectionBag(Bag&lt;E> bag)
    // Collection API를 따르는 백

// 아래의 함수들에 대하여, SortedBag 버전이 존재한다
static &lt;E> Bag&lt;E> synchronizedBag(Bag&lt;E> bag)                                         // 스레드-안전
static &lt;E> Bag&lt;E&Gt; unmodifiableBag(Bag&lt;? extends E> bag)                            // 변경 불가능한 뷰
static &lt;E> Bag&lt;E> predicatedBag(Bag&lt;E> bag, Predicate&lt;? super E> predicate)        // 아이템 추가 전 테스트 추가
static &lt;E> Bag&lt;E> transformingBag(Bag&lt;E> bag, Transformer&lt;? super E, ? extends E>) // 아이템 추가 전 변환기 추가
</div><h3>CollectionUtils</h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static &lt;T> Collection&lt;O> union(Iterable&lt;? extends O> a, Iterable&lt;? extends O> b)
    // a, b의 합집합(Multiset; Bag) 표현을 반환한다. + intersection, disjunction(대칭 차집합), subtract
    // subtract에 한하여 3번째 인자로 Predicate을 받는 함수가 존재한다

    // 각 원소의 cardinality
    // union : a, b중 큰 쪽과 같다
    // intersection : a, b중 작은 쪽과 같다
    // disjunction : cardinality_of_union - cardinality_of_intersection
    // subtract : cardinality_of_a - cardinality_of_b

static boolean containsAny(Collection&lt;?> coll1, Collection&lt;?> coll2)
static boolean containsAll(Collection&lt;?> coll1, Collection&lt;?> coll2)
    // coll1이 coll2의 모든 원소를 포함하는지 여부를 반환한다. 각 원소에 대한 cardinality는 고려 대상이 아니다

static &lt;?O> Map&lt;O, Integer> getCardinalityMap(Iterable&lt;? extends O> coll)
static boolean isSubCollection(Collection&lt;?> a, Collection&lt;?> b)
    // a가 b의 부분 컬렉션인지(cardinality 고려) 여부 반환
static boolean isProperSubCollection(Collection&lt;?> a, Collection&lt;?> b)
    // isSubCollection() && cardinality_of_b > cardinality_of_a를 만족하는 원소가 적어도 하나 존재
static boolean isEqualCollection(Collection&lt;?> a, Collection&lt;?> b)

static &lt;E> Collection&lt;List&lt;E>> permutations(COllection&lt;E> collection)
    // 구성 요소들에 대한 순열을 반환한다. 사이즈가 큰 경우, PermutationIterator를 이용

static &lt;C> Collection&lt;C> retainAll(Collection&lt;C> collection, Collection&lt;?> retain)
    // retain에 담긴 요소들만으로 구성된 컬렉션을 반환한다. 반환된 컬렉션 각 요소의 cardinality는 기존과 동일하다. retain 컬렉션의 탐색 속도가 빠를수록 함수 완료가 빨라진다

static &lt;C> Collection&lt;C> predicatedCollection(Collection&lt;C> collection, Predicate&lt;? super C> predicate)
    // 삽입 제약 추가
</div><h3>IterableUtils</h3><p>+ IteratorUtils. 접합, 변환, 순회 관련 다양한 유틸리티 제공</p><h3>ListUtils</h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static &lt;T> List&lt;T> intersection(List&lt;? extends E> list1, List&lt;? extends E> list2)
    // + subtract, union, sum(union - intersection)

static &lt;T> List&lt;T> longestCommonSubsequence(List&lt;T> a, List&lt;T> b)

static &lt;T> List&lt;T> lazyList(List&lt;E> list, Factory&lt;? extends E> factory)
    // 요청된 인덱스에 한해서만 객체를 생성한다. 빈 구역은 null로 채워진다

static &lt;T> List&lt;List&lt;T>> partition(List&lt;T> list, int size)
</div><h3>MapUtils</h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static &lt;K> String getString(Map&lt;? super K, ?> map, K key)
    // 조회된 객체에 대하여 toString() 호출. map이 null이면 null 반환. key가 map에 없어도 null 반환
    // + Boolean, Number, Byte, Short, Integer, Long, Float, Double, Map, Object

static &lt;K, V> Properties toProperties(Map&lt;K, V> map)
static Map&lt;String, Object> toMap(ResourceBundle resourceBundle)

static &lt;K, V> Map&lt;K, V> invertMap(Map&lt;K, V> map)
    // 키-값 위치를 바꾼 새 HashMap 반환

static void verbosePrint(PrintStream out, Object label, Map&lt;?, ?> map)
    // + debugPrint
</div><h3>MultiMapUtils</h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static &lt;K, V> ListValuedMap&lt;K, V> newListValuedHashMap()
    // + newSetValuedHashMap
</div><h3>SetUtils</h3><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">static &lt;E> SetUtils.SetView&lt;E> difference(Set&lt;? extends E> a, Set&lt;? extends E> b)
    // 차집합 a-b
    // + disjunction(대칭 차집합), intersection(교집합), union(합집합)
</div></div></div><h1>...bag</h1><ol><li>HashBag&lt;E></li><p>저장소로 HashMap을 이용하는 표준 Bag 구현을 제공한다</p><li>TreeBag&lt;E></li><p>저장소로 TreeMap을 이용하는 표준 SortedBag 구현을 제공한다</p><li>CollectionBag&lt;E> CollectionSortedBag</li><p>Bag 인스턴스가 Collection API에 맞게 동작하도록 래핑하는 생성자를 제공한다</p><li>UnmodifiableBag&lt;E> UnmodifiableSortedBag</li><p>Bag 인스턴스가 변경되지 않도록 래핑하는 장식자 메서드를 제공한다</p><li>PredicatedBag&lt;E> PredicatedSortedBag</li><p>Bag 인스턴스에 요소 추가 제약을 거는 장식자 메서드를 제공한다. 요소 추가에 실패하는 경우 IllegalArgumentException 발생</p><li>SynchronizedBag&lt;E> SynchronizedSortedBag</li><p>Bag 인스턴스가 스레드-안전하도록 래핑하는 장식자 메서드를 제공한다</p><li>TransformedBag&lt;E> TransformedSortedBag</li><p>Bag 인스턴스의 요소 변환 제약을 거는 장식자 메서드를 제공한다. 기존 요소를 포함하여 변환하는 경우 transformedBag(...), 신규 요소들만 변환하는 경우 transformingBag(...)</p></ol><h1>...bidimap</h1><ol><li>DualHashBidiMap&lt;K, V></li><p>2개의 HashMap 인스턴스를 이용한 BidiMap 구현을 제공한다</p><li>TreeBidiMap&lt;K</li><p>키, 값이 모두 정렬 가능할 때, red-black 트리를 이용한 BidiMap 구현을 제공한다</p><li>UnmodifiableBidiMap&lt;K, V> UnmodifiableOrderedBidiMap, UnmodifiableSortedBidiMap</li><p>인스턴스가 변경되지 않도록 래핑하는 장식자 메서드를 제공한다</p></ol><h1>...collection</h1><ol><li>CompositeCollection&lt;E></li><p>다른 컬렉션(들)에 대해 하나의 뷰를 제공하는 장식자 컬렉션 구현. 뷰에 대한 add/remove 연산이 기저 컬렉션에 적용돼야 한다면 CompositeCollection.CollectionMutator를 제공해야 한다</p><li>IndexedCollection&lt;K, C></li><p>컬렉션에 대해 맵과 비슷한 뷰를 제공하는 장식자 컬렉션 구현. 뷰에 대한 변경은 키와 기저 컬렉션에 자동으로 반영되지만, 기저 컬렉션이 직접 변경된 경우 reindex()를 통해 직접 동기화해야 한다</p><li>PredicatedCollection&lt;E></li><p>컬렉션에 대해 삽입 제약을 거는 장식자 컬렉션 구현. Builder 팩터리 클래스도 제공한다</p><li>SynchronizedCollection&lt;E></li><p>컬렉션이 스레드-안전하도록 래핑하는 장식자 메서드를 제공한다</p><li>TransformedCollection&lt;E></li><p>컬렉션에 요소 변환 제약을 거는 장식자 메서드를 제공한다. 기존 요소를 포함하여 변환하는 경우 transformedCollection(...), 신규 요소들만 변환하는 경우 transformingCollection(...)</p><li>UnmodifiableCollection&lt;E> UnmodifiableBoundedCollection</li><p>컬렉션이 변경되지 않도록 래핑하는 장식자 메서드 제공</p></ol><h1>...iterators</h1><ol><li>ArrayIterator&lt;E></li><p>배열에 대한 이터레이터 제공</p><li>ArrayListIterator&lt;E></li><p>배열에 대한 ListIterator 프로토콜 제공)</p><li>ListIteratorWrapper&lt;E></li><p>요소들을 캐싱하여 Iterator를 ResettableIterator로 래핑</p><li>PeekingIterator&lt;E></li><li>LoopingIterator&lt;E> LoopingListIterator</li><li>SingletonIterator&lt;E> SingletonListIterator</li><li>ReverseListIterator&lt;E></li><li>PushbackIterator&lt;E></li><p>next()를 취소할 수 있다. next()에서 반환하지 않은 객체도 pushback()으로 넣을 수 있으며, 래핑된 실제 iterator에는 영향을 끼치지 않는다</p><li>EnumerationIterator&lt;E></li><p>Enumeration이 이터레이터로 동작하도록 하는 어댑터 제공 + IteratorEnumeration, IteratorIterable</p><li>TransformIterator&lt;I, O></li><li>EntrySetMapIterator&lt;K, V></li><p>맵의 entrySet을 이용한 MapIterator 구현 제공</p><li>EmptyIterator&lt;E></li><p>+ EmptyListIterator, EmptyMapIterator, EmptyOrderedIterator, EmptyOrderedMapIterator, UnmodifiableIterator, UnmodifiableListIterator, UnmodifiableMapIterator, UnmodifiableOrderedMapIterator</p><li>BoundedIterator&lt;E></li><p>다른 이터레이터의 특정 범위만 조회하는 래퍼를 제공. + SkippingIterator</p><li>FilterIterator&lt;E> FilterListIterator, UniqueFilterIterator</li><li>CollatingIterator&lt;E></li><p>여러 이터레이터들을 특정 순서대로 소비하는 래퍼를 제공. + ZippingIterator(각 이터레이터 1개씩 순회 조회), IteratorChain(넘겨진 순서대로 소비), LazyIteratorChain</p><li>PermutationIterator&lt;E></li><p>순열을 순회하는 이터레이터를 제공한다</p></ol><h1>...keyvalue</h1><ol><li>MultiKey&lt;K></li><p>여러 키 값을 하나의 키로 이용할 수 있게 해준다. 이를 통해 다중 맵을 이용하지 않고 문제를 해결할 수 있다</p><li>DefaultKeyValue&lt;K, V></li><p>Map.Entry를 구현하지 않는 키-값 쌍 기능 제공. 키와 값이 null일 수 있다. + DefaultMapEntry</p><li>TiedMapEntry&lt;K, V></li><p>맵과 결합된 Map.Entry. 값을 변경하면 기저 맵에 반영된다</p><li>UnmodifiableMapEntry&lt;K, V></li></ol><h1>...list</h1><ol><li>CursorableLinkedList&lt;E></li><p>ListIterator를 통한 동시 수정이 가능한 리스트 구현을 제공한다. listIterator(), cursor() 메서드로 Cursor 객체를 얻을 수 있다</p><li>FixedSizeList&lt;E></li><p>기저 리스트 크기 고정 &lt;- 추가/제거 거부</p><li>GrowthList&lt;E></li><p>리스트의 크기를 벗어난 인덱스에 대한 add/set 호출이 있을 때, 빈 영역을 자동으로 null로 채운다. 음수 인덱스에 대해서는 IndexOutofBoundsException 발생</p><li>LazyList&lt;E></li><p>리스트의 크기를 벗어난 인덱스에 대한 get 요청에 대해, 빈 영역은 null로 채우고, 특정 인스턴스를 할당하고 반환한다. 리스트 내 get 반환하려는 요소가 null인 경우, 새로 할당 시도한다</p><li>PredicatedList&lt;E> TransformedList</li><li>SetUniqueList&lt;E></li><li>TreeList&lt;E></li><p>임의 인덱스 삽입/제거에 최적화된 리스트 구현 제공. add, get, iterator만 이용한다면 ArrayList가 좋다</p><li>UnmodifiableList&lt;E></li></ol><h1>...map</h1><ol><li>CaseInsensitiveMap&lt;K, V></li><p>키의 삽입, 비교 시 모두 소문자로 변환되어 연산</p><li>CompositeMap&lt;K, V></li><p>여러 맵들에 대해 하나의 뷰를 제공하는 장식자 맵 제공. 뷰에 대한 삽입/삭제 연산이 기저 맵에 적용되야 한다면 CompositeMap.MapMutator를 제공하면 된다</p><li>DefaultedMap&lt;K, V> LazyMap, LazySortedMap</li><p>기저 맵에 존재하지 않는 키에 대한 대체값 제공</p><li>FixedSizeMap&lt;K, V> FixedSizeSortedMap</li><p>기저 맵 크기 고정 &lt;- 추가/제거 거부</p><li>Flat3Map&lt;K, V></li><p>요소가 3개 이하일 때 최적으로 동작하는 맵 제공</p><li>HashedMap&lt;K, V></li><p>HashMap + MapIterator + Cloneable</p><li>LinkedMap&lt;K, V></li><p>LinkedHashMap + MapIterator + Cloneable</p><li>ListOrderedMap&lt;K, V></li><p>삽입 순서를 List에 보존</p><li>LRUMap&lt;K, V></li><p>임계 크기를 초과하면 가장 오래 전 사용(get/put)된 entry 제거. DEFAULT_MAX_SIZE == 100</p><li>MultiKeyMap&lt;K, V></li><li>PassiveExpiringMap&lt;K, V></li><p>맵에 entry를 유지할 시간을 정의. 각 시간이 지나면 맵에서 제거된다</p><li>PredicatedMap&lt;K, V> PredicatedSortedMap, TransformedMap, TransformedSortedMap</li><li>ReferenceIdentityMap&lt;K, V></li><p>키, 값의 GC를 허용(선택적)하고, equals() 대신 ==로 일치를 판별하는 맵을 제공한다. + ReferenceMap</p><li>StaticBucketMap&lt;K, V></li><p>주어진 한도 내에서는 고성능의 스레드-안전한 java.util.Map 구현을 제공한다. 크기가 한도를 벗어나면 O(n)에 가까워진다</p><li>SingletonMap&lt;K, V></li><li>UnmodifiableEntrySet&lt;K, V></li><p>변결할 수 없는 entry 집합을 반환하는 장식자 메서드 제공 + UnmodifiableMap, UnmodifiableOrderedMap, UnmodifiableSortedMap</p><li>EntrySetToMapIteratorAdapter&lt;K, V></li></ol><h1>...multimap</h1><ol><li>ArrayListValuedHashMap&lt;K, V></li><li>HashSetValuedHashMap&lt;K, V></li><li>TransformedMultiValuedMap&lt;K, V></li><li>UnmodifiableMultiValuedMap&lt;K, V></li></ol><h1>...multiset</h1><ol><li>HashMultiSet&lt;E></li><li>PredicatedMultiSet&lt;E></li><li>SynchronizedMultiSet&lt;E></li><li>UnmodifiableMultiSet&lt;E></li></ol><h1>...queue</h1><ol><li>CircularFifoQueue&lt;E></li><p>고정 크기 큐. 가득 찬 상태에서 add() 시 가장 마지막 요소가 null이면 덮어쓴다</p><li>PredicatedQueue, SynchronizedQueue, TransformedQueue, UnmodifiableQueue</li></ol><h1>...set</h1><ol><li>CompositeSet&lt;E></li><p>여러 셋에 대한 하나의 뷰를 제공. 뷰에 대한 연산이 기저 셋에 적용돼야 한다면 CompositeSet.SetMutator를 제공해야 한다</p><li>ListOrderedSet&lt;E></li><p>원소 삽입 순서를 보존한다. 같은 원소에 대해 2번째 add 호출이 있는 경우, 1번째 위치를 유지한다</p><li>MapBackedSet&lt;E, V></li><p>Map을 Set처럼 이용하게 해준다</p><li>PredicatedSet, PredicatedSortedSet, PredicatedNavigableSet, TransformedSet, TransformedSortedSet, TrnasformedNavigableSet, UnmodifiableSet, UnmodifiableSortedSet, UnmodifiableNavigableSet</li></ol></article></main></body></html>