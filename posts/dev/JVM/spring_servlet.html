<!DOCTYPE html><html lang="ko-KR"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Spring Servlet</title><link rel="stylesheet" href="/source/default.css"><meta name="google-site-verification" content="aH-DyzdytYQ0NPHNQFcs5dVoiu5YNs6CEEHYgqDmAFM"><meta name="author" content="Donggi Kim &lt;hi.donggi@gmail.com&gt;"><meta name="description" content="Spring Servlet 정리"><link rel="icon" href="/imgs/favicon.png"></head><body><div class="w3-bar-block w3-sidebar w3-animate-left" id="sidebar"><hr><div id="marker-list"></div><hr><div id="post-list"></div><hr><details class="w3-small file-list"><summary>LICENSE</summary><table><tr><td>Author</td><td>License</td></tr><tr><td>&copy; <a href="mailto:hi.donggi@gmail.com">Donggi Kim</a></td><td><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/Dong-gi/Dong-gi.github.io/blob/master/LICENSE">MIT</a></td></tr><tr><td><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="https://www.w3schools.com/w3css">w3css</a></td><td>No license</td></tr><tr><td><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="https://highlightjs.org/">highlight.js</a></td><td><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/highlightjs/highlight.js/blob/main/LICENSE">BSD-3-Clause</a></td></tr><tr><td><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/mathjax/MathJax">MathJax</a></td><td><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/mathjax/MathJax/blob/master/LICENSE">Apache-2.0</a></td></tr><tr><td><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/davidshimjs/qrcodejs">QRCode.js</a></td><td><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/davidshimjs/qrcodejs/blob/master/LICENSE">MIT</a></td></tr><tr><td><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/terrastruct/d2">D2</a></td><td><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/terrastruct/d2/blob/master/LICENSE.txt">MPL-2.0</a></td></tr></table></details><hr></div><article id="main"><div class="w3-bar w3-blue w3-large" id="nav" style="position:-webkit-sticky;position:sticky;top:0px;vertical-align:middle"><button class="w3-bar-item w3-button w3-hover-theme" onclick="toggleSidebar()">&#9776;</button><input class="w3-bar-item" id="query" type="text" placeholder="search" style="max-width:35%"><a class="w3-bar-item w3-button w3-hover-theme" href="/">Home</a></div><div class="w3-padding" id="contents"><h1>Spring Web MVC</h1><ul><li>Servlet API 기반으로 빌드하고 Servlet container로 배포하는 웹 애플리케이션 개발 프레임워크</li><li>리액티브 스트림 기반의 Spring WebFlux가 Spring Framework 5.0에 추가되었다</li></ul><h1>DispatcherServlet</h1><ul><li>DispatcherServlet은 클라이언트 요청을 받아 다른 컴포넌트로 처리를 넘긴다</li><li>각 DispatcherServlet은 하나의 WebApplicationContext를 갖는다</li><li>여타 서블릿과 마찬가지로 자바 설정이나 web.xml로 선언해야 한다</li></ul><div><h2>자바 설정 Since 3.0 - WebApplicationInitializer 정의 예</h2><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java1/src/main/java/io/github/donggi/mvc/config/Initializer.java" displayRange="[9]" lan="java">Initializer.java</button><p>정상적으로 완료되면 실행 시 로그에 "INFO: 1 Spring WebApplicationInitializers detected on classpath"처럼 기록된다. 자동으로 스캔되지 않는 경우 /META-INF/services/javax.servlet.ServletContainerInitializer 파일에 해당 클래스 명시</p><h2>web.xml 기술 예</h2><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-xml2/src/main/webapp/WEB-INF/web.xml" lan="xml">web.xml</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-xml2/src/main/webapp/WEB-INF/app-servlet.xml" lan="xml">app-servlet.xml</button><ul><li>기본적으로 {서블릿_이름}-servlet.xml 설정을 읽어온다</li><p>{서블릿_이름}-servlet == default namespace</p><li>다른 파일(들)을 로드하고 싶거나, 아예 로드하고 싶지 않은 경우 contextConfigLocation 조정</li><p>각 경로들은 ','로 구분하면 된다. 클래스패스에 있는 파일은 classpath:conf.xml처럼 지정하면 된다</p><p><strong>↓ 추가 로드 x</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="xml">&lt;servlet>
    &lt;servlet-name>app&lt;/servlet-name>
    &lt;servlet-class>org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class>
    &lt;init-param>
        &lt;param-name>contextConfigLocation&lt;/param-name>
        &lt;param-value>&lt;/param-value>
    &lt;/init-param>
&lt;/servlet></div><li>xml에서 ConfigurableWebApplicationContext 구현 클래스를 지정하고 싶은 경우, contextClass 조정</li><p>기본값은 XmlWebApplicationContext</p><p><strong>↓ xml</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="xml">&lt;servlet>
    &lt;servlet-name>app&lt;/servlet-name>
    &lt;servlet-class>org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class>
    &lt;init-param>
        &lt;param-name>contextClass&lt;/param-name>
        &lt;param-value>org.springframework.web.context.support.AnnotationConfigWebApplicationContext&lt;/param-value>
    &lt;/init-param>
    &lt;init-param>
        &lt;param-name>contextConfigLocation&lt;/param-name>
        &lt;param-value>package..ClassName&lt;/param-value>
    &lt;/init-param>
&lt;/servlet>
</div></ul><h2>Context Hierarchy</h2><ul><li>일반적으로 하나의 WebApplicationContext로 충분하지만, 루트 WebApplicationContext를 DispatcherServlet들이 공유하고, 각각은 자식 WebApplicationContext를 갖는 계층 구조로도 구성 가능하다</li><li>루트 WebApplicationContext는 전형적으로 Repository, Service 등 여러 Servlet 사이에서 공유될 빈들을 갖는다</li><p>이들은 자식 WebApplicationContext로 상속되며, 필요에 따라 재정의(override)할 수 있다</p><li>자바 구성 예 <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java2/src/main/java/io/github/donggi/mvc/config/App1Initializer.java" displayRange="[5]" lan="java">App1Initializer.java</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java2/src/main/java/io/github/donggi/mvc/config/App2Initializer.java" displayRange="[5]" lan="java">App2Initializer.java</button></li><li>web.xml 예 <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-xml3/src/main/webapp/WEB-INF/web.xml" lan="xml">web.xml</button></li></ul><h2>Special Bean Types</h2><p>DispatcherServlet이 요청을 처리하도록 전달하는 빈들을 Special Bean이라고 하며, 정의하지 않은 경우 <a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/resources/org/springframework/web/servlet/DispatcherServlet.properties">기본값</a>이 사용된다</p><table><tr><th>타입</th><th>설명</th></tr><tr><td>HandlerMapping</td><td>요청 URI -&gt; 핸들러 매핑. @RequestMapping, @GetMapping, ...</td></tr><tr><td>HandlerAdapter</td><td>핸들러의 구현에 상관없이 DispatcherServlet이 호출할 수 있도록 래퍼 제공</td></tr><tr><td>HandlerExceptionResolver</td><td>예외 발생 시 처리 전략</td></tr><tr><td>ViewResolver</td><td>핸들러가 렌더링할 View 이름을 반환하면 적절한 View를 선택</td></tr><tr><td>LocaleResolver, LocaleContextResolver</td><td>클라이언트 Locale 선택</td></tr><tr><td>MultipartResolver</td><td>Multi-part 요청 처리 api 제공</td></tr><tr><td>FlashMapManager</td><td>요청 간 FlashMap 인스턴스 공유 기능 제공</td></tr></table><h2>Processing; 요청 처리 절차</h2><ol><li>요청에 맞는 WebApplicationContext가 검색되어 바운딩</li><li>LocaleResolver 바운딩</li><li>ThemeResolver 바운딩</li><li>Multi-part 요청이라면 MultipartHttpServletRequest로 래핑</li><li>요청에 대한 핸들러 호출</li></ol><h2>Interception</h2><p>핸들러 요청에 대한 전/후 처리를 추가할 수 있다 <a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos63735001" target="_self">MVC config - Interceptors</a></p><p><strong>↓ interface HandlerInterceptor</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">default boolean preHandle(request, response, handler);
    // DispatcherServlet이 핸들러를 결정하고, 아직 HandlerAdapter가 핸들러를 호출하지 않은 시점에 실행된다
    // 다음 처리로 진행한다면 true. false를 반환한 경우, DispatcherServlet은 여기서 response로 모든 응답을 했다고 간주한다
default void postHandle(request, response, handler, @Nullable modelAndView);
    // HandlerAdapter가 핸들러를 호출하고, 아직 DispatcherServlet이 뷰를 렌더링하지 않은 시점에 실행된다
    // 전달된 modelAndView에 다른 모델 객체들을 추가해도 된다
default void afterCompletion(request, response, handler, @Nullable ex)
    // 모든 처리가 완료되었으므로 자원 정리 등의 작업을 수행해도 된다
    // preHandle()이 성공적으로 true를 반환한 경우에도 실행된다
</div><h2>Exceptions</h2><div><h3>HandlerExceptionResolver 종류</h3><ul><li>SimpleMappingExceptionResolver</li><p>예외 클래스 -> 뷰 이름 매핑</p><p><strong>↓ xml</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="xml">&lt;bean id="exceptionResolver"
    class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver">
    &lt;property name="exceptionMappings">
        &lt;props>
            &lt;prop key="MaxUploadSizeExceededException"> error &lt;/prop>
        &lt;/props>
    &lt;/property>
&lt;/bean></div><li>DefaultHandlerExceptionResolver</li><p>예외 -> HTTP 상태 코드 매핑</p><li>ResponseStatusExceptionResolver</li><p>예외 발생 메서드 또는 발생한 예외 클래스의 @ResponseStatus -> HTTP 상태 코드 매핑</p><li>ExceptionHandlerExceptionResolver</li><p>@Controller 또는 @ControllerAdvice 클래스의 @ExceptionHandler 메서드가 예외 처리 <a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos1895376872" target="_self">Annotated Controllers - Exceptions</a></p></ul><h3 class="fake">Chain of Resolvers</h3><p>여러 HandlerExceptionResolver 빈을 정의하면 order 및 정의된 순서에 따라 호출되는 체인을 구성할 수 있다</p><h3 class="fake">Container Error Page</h3><p>예외가 처리되지 않았고, 응답 상태가 에러(4xx, 5xx)인 경우를 위해 기본 에러 페이지를 지정할 수 있다</p><p><strong>↓ web.xml</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="xml">&lt;error-page>
    &lt;exception-type>java.lang.Throwable&lt;/exception-type> // 옵션
    &lt;location>/path/url&lt;/location>
&lt;/error-page></div></div><h2>View Resolution</h2><div><h3>ViewResolver 종류</h3><ul><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos701800517" target="_self">View Technologies</a><li>AbstractCachingViewResolver</li><p>뷰 인스턴스를 캐시하여 이용한다. cache 속성을 이용해 전체 캐시를 끄거나, removeFromCache()로 일부 뷰만 캐시에서 제거할 수 있다</p><li>XmlViewResolver, BeanNameViewResolver</li><p>현재 컨텍스트에서 뷰 이름과 일치하는 빈을 뷰로 이용한다. XmlViewResolver은 따로 지정하지 않으면 기본으로 /WEB-INF/views.xml를 로드한다</p><li>ResourceBundleViewResolver</li><p>ResourceBundle(기본 리소스 파일 : views.properties)에 저장된 빈 정보로 뷰를 찾는다. 정확히는 [viewname].(class) 속성을 뷰 클래스로, [viewname].url 속성을 뷰 url로 이용한다</p><li>UrlBasedViewResolver</li><ul><li>Url 경로에 대응하는 파일을 뷰로 이용한다</li><li>setContentType()으로 기본 Content-Type 헤더 설정 가능 ─ JVM 기본 인코딩이 잘못된 경우 이걸로 수정 가능</li><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">@ComponentScan(basePackages = "io.github.donggi.mvc.controller, io.github.donggi.mvc.service")
@EnableWebMvc
@Configuration
public class AppConfig implements WebMvcConfigurer {
    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) {
        var resolver = new FreeMarkerViewResolver("", ".ftl");
        resolver.setContentType("text/html;charset=UTF-8");
        registry.viewResolver(resolver);
    }
}</div></ul><li>InternalResourceViewResolver</li><p>UrlBasedViewResolver의 서브클래스로, InternalResourceView(Servlet, JSP) 파일을 뷰로 이용한다. 그 외 서브클래스 ─ TilesViewResolver, XsltViewResolver, FreeMarkerViewResolver ─ 들도 존재</p><p><strong>↓ xml</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="xml">&lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
    &lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/> // ← JSTL 이용하는 경우
    &lt;property name="prefix" value="/WEB-INF/view/" />
    &lt;property name="suffix" value=".jsp" />
&lt;/bean></div><li>ContentNegotiatingViewResolver</li><p>컨텐츠 협상이 가능한 ViewResolver. 다른 ViewResolver들이 고른 View 중, contentType이 요청과 일치하는 것을 선택한다</p></ul><h3 class="fake">Handling</h3><ul><li>여러 ViewResolver를 이용 가능</li><p>order 속성으로 순서를 제어할 수 있다</p><li>null을 반환하면 뷰를 찾지 못했음을 의미한다</li><p>InternalResourceViewResolver는 마지막에 동작해야 한다</p></ul><h3>Redirecting</h3><ul><li>UrlBasedViewResolver 및 서브클래스를 이용하는 경우, 뷰 이름 앞에 redirect:를 붙이면 리다이렉션을 수행한다</li><p>예. redirect:/myapp/some/resource</p><li>redirect:https://myhost.com/some 처럼 외부 절대경로 이용 가능</li></ul><h3>Forwarding</h3><ul><li>UrlBasedViewResolver 및 서브클래스를 이용하는 경우, 뷰 이름 앞에 forward:를 붙이면 포워딩을 수행한다</li><li>RequestDispatcher.forward()를 호출하는 InternalResourceView 인스턴스를 생성하므로 JSP만 사용하는 경우는 유용하지 않음</li><p>다른 종류의 뷰를 이용하지만 서블릿/JSP로 포워딩이 필요한 경우에 적합</p></ul></div><h2>Multipart Resolver</h2><p>Multi-part 요청을 처리하려면 DispatcherServlet에 "multipartResolver" 이름의 MultipartResolver 빈을 정의해야 한다</p><ul><li>commons-fileupload</li><ul><li>JavaConfig 예 <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java5/src/main/java/io/github/donggi/mvc/config/AppConfig.java" displayRange="[13]" lan="java">AppConfig.java</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java5/src/main/java/io/github/donggi/mvc/controller/FileController.java" displayRange="[16]" lan="java">FileController.java</button></li><li>xml 예 <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-xml5/src/main/webapp/WEB-INF/app-servlet.xml" lan="xml">app-servlet.xml</button></li></ul><li>Since Servlet 3.0</li><ol><li>Initializer에서 MultipartConfigElement 추가, 또는 web.xml에 multipart-config 추가</li><li>StandardServletMultipartResolver 빈 정의</li></ol><ul><li>JavaConfig 예 <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java6/src/main/java/io/github/donggi/mvc/config/Initializer.java" displayRange="[10]" lan="java">Initializer.java</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java6/src/main/java/io/github/donggi/mvc/config/AppConfig.java" displayRange="[13]" lan="java">AppConfig.java</button></li><li>xml 예 <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-xml6/src/main/webapp/WEB-INF/web.xml" lan="xml">web.xml</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-xml6/src/main/webapp/WEB-INF/app-servlet.xml" lan="xml">app-servlet.xml</button></li></ul><li>@RequestParam으로 Map&lt;String, MultipartFile>, MultiValueMap&lt;String, MultipartFile>도 가능</li><li>Since Servlet 3.0 : MultipartFile 대신 javax.servlet.http.Part 이용 가능</li></ul><h2>Logging - Sensitive Data</h2><p>기본적으로 요청 인자와 헤더는 로깅하지 않는다. 로깅하려면 DispatcherServlet의 enableLoggingRequestDetails를 true로 설정하면 된다</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">public class Initializer extends AbstractAnnotationConfigDispatcherServletInitializer {
    @Override
    protected void customizeRegistration(ServletRegistration.Dynamic registration) {
        registration.setInitParameter("enableLoggingRequestDetails", "true");
    }
}</div><p><strong>↓ xml</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="xml">&lt;servlet>
    &lt;servlet-class>org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class>
    &lt;init-param>
        &lt;param-name>enableLoggingRequestDetails&lt;/param-name>
        &lt;param-value>true&lt;/param-value>
    &lt;/init-param>
&lt;/servlet>
</div></div><h1>Filters</h1><div><h2 class="fake">OncePerRequestFilter 서브클래스</h2><p>AbstractRequestLoggingFilter, CharacterEncodingFilter, CorsFilter, FormContentFilter, ForwardedHeaderFilter, HiddenHttpMethodFilter, HttpPutFormContentFilter, MultipartFilter, OpenEntityManagerInViewFilter, OpenSessionInViewFilter, RelativeRedirectFilter, RequestContextFilter, ShallowEtagHeaderFilter</p><div><h3>Default Encoding</h3><p>CharacterEncodingFilter는 HttpServletRequest 변수 request에 대하여 아래를 수행한다</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">if (isForceRequestEncoding() || request.getCharacterEncoding() == null) {
    request.setCharacterEncoding(encoding);
}</div><h3>Form Data</h3><p>FormContentFilter를 이용하면 HTTP PUT, PATCH, DELETE 요청으로 온 application/x-www-form-urlencoded 내용을 ServletRequest.getParameter*()로 접근할 수 있다</p><h3>Forwarded Headers</h3><ul><li>프록시 서버를 거치는 경우 실제 클라이언트의 주소는 Forwarded 헤더 ─ X-Forwarded-Host, X-Forwarded-Port, ... ─ 로 옮겨진다</li><li>ForwardedHeaderFilter를 이용하면 요청의 주소를 Forwarded 헤더의 것으로 변경하고 Forwarded 헤더를 지운다</li><p>요청을 래핑해야 하므로, 가장 먼저 실행될 필요가 있다</p><li>Forwarded 헤더가 공격자로부터 삽입된 것이라면 이를 사용하지 않고 삭제만 해야한다</li><p>ForwardedHeaderFilter의 removeOnly 속성을 true로 설정하면 된다</p><li>AbstractAnnotationConfigDispatcherServletInitializer를 이용하는 경우, DispatcherType.REQUEST, ASYNC, ERROR 모두에 대해 실행된다</li><p>그 외의 경우 DispatcherType.REQUEST에 대해서만 동작한다</p></ul><h3>CORS</h3><p>Controller 클래스에 애너테이션을 붙여 CORS 설정을 할 수 있지만, Spring Security를 이용하는 경우 CorsFilter를 이용해 Security보다 먼저 실행되도록 설정할 것이 권장된다 <a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos2074541" target="_self">CORS</a></p></div></div><h1>Annotated Controllers</h1><div><h2>Declaration</h2><ul><li>@Controller : WebApplicationContext에서 웹 요청 처리자로 간주된다</li><li>@RestController : @Controller + 클래스 수준 @ResponseBody</li></ul><h2>Request Mapping</h2><ul><li>컨트롤러 클래스 및 메서드에 @RequestMapping을 붙여 어떤 요청을 처리하는지 명시</li><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">@RequestMapping("/file/*")
public class FileController {
    @RequestMapping(value = "/upload", method = RequestMethod.GET)
    public String upload() { }
}</div><li>HTTP 요청에 따라 @GetMapping, @PostMapping, @PutMapping, @DeleteMapping, @PatchMapping 존재</li></ul><div><h3>URI Patterns</h3><span class="pos-span" id="pos-1092929705"></span><table><tr><th>Pattern</th><th>Description</th></tr><tr><td>?</td><td>임의 1글자</td></tr><tr><td>*</td><td>1개 경로 조각 내의 임의 0개 이상 글자</td></tr><tr><td>**</td><td>0개 이상의 연속적인 경로 조각</td></tr><tr><td>{name}</td><td>1개 경로 조각을 name 변수로 획득</td></tr><tr><td>{name:regex}</td><td>경로가 정규식에 일치하면 해당 부분을 name 변수로 획득</td></tr></table><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">@GetMapping("/owners/{ownerId}/pets/{petId}")
public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId);
    // 컴파일된 클래스에 매개변수 이름이 그대로 남아있다면 @PathVariable에 이름 설정 불필요</div><ul><li>기본 타입과 Date 등 일부 클래스로는 자동으로 변환이 가능하다. 전역적인 변환기를 등록하려면 <a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos87617553" target="_self">MVC config - Type Conversion</a>, @Controller, @ControllerAdvice에만 적용되는 변환기를 등록하려면 <a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos-1521490412" target="_self">DataBinder</a> 참고</li><li><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos114384251" target="_self">property-placeholder</a>와 같은 ${...} 표현식 사용 가능. 앱 시작 시 평가된다</li></ul><h3 class="fake">Pattern Comparison</h3><p>URL 하나가 여러 패턴에 매칭되는 경우, 가장 일반적이지 않은 패턴이 선택된다. 우선순위는 <a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="https://docs.spring.io/spring-framework/docs/5.2.8.RELEASE/javadoc-api/org/springframework/util/AntPathMatcher.AntPatternComparator.html">AntPathMatcher</a> 참고</p><h3>Suffix Match</h3><ul><li>Before 5.3 : 기본적으로 .* 접미사 매칭이 수행된다. 예를 들어 패턴 "/person"은 "/person.pdf" 같은 URL도 매칭한다. </li><li>기능을 끄려면 PathMatchConfigurer.useSuffixPatternMatching(false) <a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos993156397" target="_self">MVC config - Path Matching</a>, ContentNegotiationConfigurer.favorPathExtension(false) <a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos935569767" target="_self">MVC config - Content Types</a>를 호출해야 한다</li><li>브라우저의 Accept 헤더를 일관적으로 해석하지 못하던 때에는 필수적이었지만, 요즘은 그렇지 않다. 5.3 버전부터는 기본적으로 false로 설정된다</li><li>RFD 공격을 예방하기 위해, 아래를 모두 만족하는 경우 응답 헤더에 Content-Disposition:inline;filename=f.txt를 설정한다</li><ol><li>URL에 파일 확장자가 존재</li><li>확장자가 안전하지 않고 컨텐츠 협상 대상도 아닌 경우</li></ol></ul><h3>Media Types</h3><ul><li>Content-Type:application/json만 처리</li><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">@PostMapping(path = "/pets", consumes = "application/json")</div><li>Content-Type:application/json만 처리 안 함</li><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">@PostMapping(path = "/pets", consumes = "!application/json")</div><li>Accept:application/json만 처리</li><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">@GetMapping(path = "/pets/{petId}", produces = "application/json")</div><li>Accept:application/json만 처리 안 함</li><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">@GetMapping(path = "/pets/{petId}", produces = "!application/json")</div><li>클래스 수준의 consumes, produces 가능</li><p>클래스와 메서드 모두에 적용하는 경우, 메서드의 것만 적용</p><li>MediaType 클래스에 APPLICATION_JSON_UTF8_VALUE 등 상수 존재</li></ul><h3>Parameters, Headers</h3><ul><li>요청 파라미터에 myParam이 존재하는 경우만 처리</li><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">@GetMapping(path = "/pets/{petId}", params = "myParam")</div><li>요청 파라미터에 myParam이 존재하지 않는 경우만 처리</li><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">@GetMapping(path = "/pets/{petId}", params = "!myParam")</div><li>요청 파라미터에 myParam 값이 "myValue"인 경우만 처리</li><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">@GetMapping(path = "/pets/{petId}", params = "myParam=myValue")</div><li>헤더의 경우 params 대신 headers 이용</li></ul></div><h2>Handler Methods</h2><div><h3>Method Arguments</h3><ol>아래 조건을 모두 만족하는 경우, java.util.Optional을 결합하여 사용할 수 있다<li>required 속성이 있는 @RequestParam, @RequestHeader 등의 애너테이션이 적용됨</li><li>required=false임</li></ol><table><tr><th>Argument</th><th>Description</th></tr><tr><td>WebRequest, NativeWebRequest</td><td>서블릿 API를 직접 사용하지 않고 요청에 대한 일반적인 접근 제공</td></tr><tr><td>ServletRequest, ServletResponse</td><td>HttpServletRequest, MultipartRequest 등 임의 서브클래스 사용 가능</td></tr><tr><td>HttpSession</td><td>세션이 반드시 존재하도록 한다. 동시성이 필요한 경우 RequestMappingHandlerAdapter 인스턴스의 synchronizeOnSession를 true로 설정</td></tr><tr><td>PushBuilder</td><td>HTTP/2 리소스 푸시를 위한 Servlet 4.0 push builder API 제공. 클라이언트가 HTTP/2를 지원하지 않으면 null</td></tr><tr><td>Principal</td><td>현재 인증 유저</td></tr><tr><td>HttpMethod</td><td>HTTP 요청 타입</td></tr><tr><td>Locale, TimeZone, ZoneId</td><td>현재 로캐일, 타임존</td></tr><tr><td>InputStream, Reader</td><td>Raw 요청 접근</td></tr><tr><td>OutputStream, Writer</td><td>응답을 직접 쓰려는 경우 사용</td></tr><tr><td>@PathVariable</td><td>URI 경로 획득 <a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos-1092929705" target="_self">URI Patterns</a></td></tr><tr><td>@MatrixVariable</td><td>URI 상의 이름-값 쌍 획득 <a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos1654759384" target="_self">Matrix Variables</a></td></tr><tr><td>@RequestParam</td><td>서블릿 요청 파라미터(URL query, Form data 모두 해당) 획득. Multi-part 파일도 가능</td></tr><tr><td>@RequestHeader</td><td>요청 헤더 획득</td></tr><tr><td>@CookieValue</td><td>쿠키 획득</td></tr><tr><td>@RequestBody</td><td>HTTP 요청 body 획득. HttpMessageConverter를 통해 지정 타입으로 변환된다</td></tr><tr><td>HttpEntity&lt;B&gt;</td><td>요청 헤더(HttpHeaders) + body(B) 획득. body는 HttpMessageConverter를 통해 지정 타입으로 변환된다</td></tr><tr><td>@RequestPart</td><td>multipart/form-data 요청 획득. 각 part는 HttpMessageConverter를 통해 지정 타입으로 변환된다</td></tr><tr><td>Map, Model, ModelMap</td><td>렌더링에 사용할 모델</td></tr><tr><td>RedirectAttributes</td><td>리다이렉션 쿼리에 덧붙일 속성<a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos2051435547" target="_self">Redirect Attributes</a>, 리다이렉션 이후 요청까지 임시로 저장할 속성<a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos-1676026937" target="_self">Flash Attributes</a></td></tr><tr><td>@ModelAttribute</td><td>기저 모델에 존재하는 객체 획득(없으면 생성). 기저와 바인딩되며, 존재하는 검증도 수행된다. <a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos406104531" target="_self">@ModelAttribute</a>. 바인딩을 원하지 않는 경우 @ModelAttribute(binding=false) 설정</td></tr><tr><td>Errors, BindingResult</td><td>@ModelAttribute 인자의 검증 및 바인딩 수행 시 발생한 예외 획득. @RequestBody 또는 @RequestPart 검증 시 발생한 예외 획득. 각 Errors, BindingResult 인자는 검증 대상 바로 다음에 위치해야 한다<br>예 <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java18/src/main/java/io/github/donggi/mvc/config/AppConfig.java" lan="java">AppConfig.java</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java18/src/main/java/io/github/donggi/mvc/controller/Login.java" displayRange="[21]" lan="java">Login.java</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java18/src/main/java/io/github/donggi/mvc/validator/LoginRequestValidator.java" lan="java">LoginRequestValidator.java</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java18/src/main/resources/i18n/msg.properties" lan="properties">msg.properties</button></td></tr><tr><td>SessionStatus + class-level @SessionAttributes</td><td>Form 처리가 완료되면 @SessionAttributes로 저장 중인 값을 정리하기 위한 SessionStatus 획득 <a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos-2103470842" target="_self">@SessionAttribute</a></td></tr><tr><td>UriComponentsBuilder</td><td>요청 host, port, scheme, context path, servlet mapping으로 구성된 builder 획득</td></tr><tr><td>@SessionAttribute</td><td>세션에 저장된 임의 인스턴스 접근 <a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos-2103470842" target="_self">@SessionAttribute</a></td></tr><tr><td>@RequestAttribute</td><td>임의 요청 속성 접근 <a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos-1461908179" target="_self">@RequestAttribute</a></td></tr><tr><td>임의 타입</td><td>위 타입 중 어느 것에도 일치하지 않는 단순 타입은 @RequestParam, 그 외에는 @ModelAttribute<br><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java8/src/main/java/io/github/donggi/mvc/controller/Controller.java" displayRange="[98,102,74,82]" lan="java">예1</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java8/src/main/java/io/github/donggi/mvc/controller/Controller2.java" displayRange="[30,34,45,53]" lan="java">예2</button></td></tr></table><h3>Return Values</h3><table><tr><th>Return Type</th><th>Description</th></tr><tr><td>@ResponseBody</td><td>HttpMessageConverter 인스턴스가 반환값을 적절히 응답에 쓴다 <a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos5090787" target="_self">@ResponseBody</a></td></tr><tr><td>HttpEntity&lt;B&gt;, ResponseEntity&lt;B&gt;</td><td>HTTP 헤더(HttpHeaders)와 바디(B)를 포함한 전체 응답을 반환하면 HttpMessageConverter가 적절히 응답에 쓴다<a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos-1311327324" target="_self">ResponseEntity</a></td></tr><tr><td>HttpHeaders</td><td>응답 헤더 반환. body는 empty</td></tr><tr><td>String</td><td>뷰 이름을 반환하면 ViewResolver가 적절히 뷰를 선택한다</td></tr><tr><td>View</td><td>렌더링할 뷰</td></tr><tr><td>Map, Model, @ModelAttribute AnyType</td><td>묵시적 모델에 추가될 속성</td></tr><tr><td>ModelAndView</td><td>뷰 + 모델</td></tr><tr><td>void</td><td>void 리턴, null 리턴이 아래 상황에서 이루어졌다면 응답이 완료됐다고 간주한다<ul><li>ServletResponse, OutputStream 인자를 메서드로 받은 경우</li><li>@ResponseStatus를 갖는 경우</li><li>컨트롤러가 ETag, lastModified를 설정한 경우</li></ul>그 외의 경우 "no response body"(REST 컨트롤러), 기본 뷰(HTTP 컨트롤러)를 의미한다</td></tr><tr><td>DeferredResult&lt;V&gt;, ListenableFuture&lt;V&gt;, CompletionStage&lt;V&gt;, CompletableFuture&lt;V&gt;</td><td>위 임의 타입을 임의 스레드에서 비동기적으로 반환 <a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos-297540356" target="_self">DeferredResult</a></td></tr><tr><td>Callable&lt;V&gt;</td><td>위 임의 타입을 Spring MVC 관리 스레드에서 비동기적으로 반환 <a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos-107604776" target="_self">Callable</a></td></tr><tr><td>ResponseBodyEmitter, SseEmitter</td><td>비동기적으로 객체를 전달하면 HttpMessageConverter가 변환하여 쓴다. ResponseEntity의 body로 이용 가능. <a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos-990817622" target="_self">HTTP Streaming</a></td></tr><tr><td>StreamingResponseBody</td><td>비동기적으로 OutputStream에 쓴다. ResponseEntity의 body로 이용 가능. <a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos-990817622" target="_self">HTTP Streaming</a></td></tr><tr><td>Reactive types — Reactor, RxJava, or others through ReactiveAdapterRegistry</td><td>한 번에 여러 값을 전송하는 경우 DeferredResult 대안</td></tr></table><h3>Type Conversion</h3><p>문자열로 표현되는 요청 인자 ─ @RequestParam, @RequestHeader, @PathVariable, @MatrixVariable, @CookieValue ─ 들을 String 외의 타입으로 받으려면 변환이 필요하다<br>기본 타입과 Date 등 일부 클래스는 자동으로 변환이 가능하다. 전역적인 변환기를 등록하려면 <a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos87617553" target="_self">MVC config - Type Conversion</a>, @Controller, @ControllerAdvice에만 적용되는 변환기를 등록하려면 <a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos-1521490412" target="_self">DataBinder</a> 참고</p><h3>Matrix Variables<span class="pos-span" id="pos1654759384"></span></h3><ul><li>Java Config <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java7/src/main/java/io/github/donggi/mvc/config/AppConfig.java" displayRange="[10]" lan="java">AppConfig.java</button></li><li>XML Config <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-xml7/src/main/webapp/WEB-INF/app-servlet.xml" lan="xml">app-servlet.xml</button></li><li>Matrix Variable 예 <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java7/src/main/java/io/github/donggi/mvc/controller/MatrixController.java" displayRange="[18,29]" lan="java">MatrixController.java</button></li><li>각 path part 모두 matrix variable을 가질 수 있다 <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java7/src/main/java/io/github/donggi/mvc/controller/MatrixController.java" displayRange="[32,44]" lan="java">MatrixController.java</button></li><li>각 path part 별로 matrix variable을 모아 받을 수 있다<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java7/src/main/java/io/github/donggi/mvc/controller/MatrixController.java" displayRange="[47,65]" lan="java">MatrixController.java</button></li></ul><h3>@RequestParam, @RequestBody</h3><ul><li>Get 요청 query 예 <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java8/src/main/java/io/github/donggi/mvc/controller/Controller.java" displayRange="[22,32]" lan="java">Controller.java</button></li><li>배열 또는 리스트를 이용해 동일 이름의 파라미터들을 모을 수 있다 <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java8/src/main/java/io/github/donggi/mvc/controller/Controller.java" displayRange="[35,45]" lan="java">Controller.java</button></li><li>Map&lt;String, String&gt;, MultiValueMap&lt;String, String&gt;로 전체 파라미터를 모을 수 있다 <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java8/src/main/java/io/github/donggi/mvc/controller/Controller.java" displayRange="[48,58,61,71]" lan="java">Controller.java</button></li><li>Post 요청 Jackson JSON 예 <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java8/build.gradle" displayRange="[31,31]" lan="gradle">build.gradle</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java8/src/main/java/io/github/donggi/mvc/controller/Controller.java" displayRange="[98,102,85,94]" lan="java">Controller.java</button></li></ul><h3>@RequestHeader</h3><p>특정 이름의 헤더, 또는 전체 헤더 ─ Map&lt;String, String&gt;, MultiValueMap&lt;String, String&gt;, HttpHeaders ─ 획득 가능 <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java8/src/main/java/io/github/donggi/mvc/controller/Controller2.java" displayRange="[21,27]" lan="java">Controller2.java</button></p><h3>@ModelAttribute<span class="pos-span" id="pos406104531"></span></h3><ol>@ModelAttribute로 선언된 인자는 아래 순서에 따라 획득된다<li>이미 Model에 추가된 객체</li><li>@SessionAttribute로 저장된 객체<a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos-2103470842" target="_self">@SessionAttribute</a></li><li>URI path variable로부터 변환(Converter) <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java8/src/main/java/io/github/donggi/mvc/controller/Controller2.java" displayRange="[30,34,35,43]" lan="java">Controller2.java</button></li><li>기본생성자 호출</li><li>Primary 생성자 호출. 생성 인자는 서블릿 요청으로부터 결정</li></ol><h3>@SessionAttributes, @SessionAttribute<span class="pos-span" id="pos-2103470842"></span></h3><ul><li>@SessionAttributes는 자동으로 세션에 객체를 저장하고, 완료 시 제거하는 기능을 제공한다 <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java8/src/main/java/io/github/donggi/mvc/controller/Controller3.java" displayRange="[15,40,41,56]" lan="java">Controller3.java</button></li><li>@SessionAttribute로 세션 객체를 획득할 수 있다 <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java8/src/main/java/io/github/donggi/mvc/controller/Controller4.java" displayRange="[13,35,36,45]" lan="java">Controller4.java</button></li></ul><h3>@RequestAttribute<span class="pos-span" id="pos-1461908179"></span></h3><p>Filter, HandlerInterceptor 등에 의해 추가된 속성을 획득할 수 있다 <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java8/src/main/java/io/github/donggi/mvc/interceptor/Controller5Interceptor.java" displayRange="[9,15]" lan="java">Controller5Interceptor.java</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java8/src/main/java/io/github/donggi/mvc/controller/Controller5.java" displayRange="[14,31]" lan="java">Controller5.java</button></p><h3>Redirect Attributes<span class="pos-span" id="pos2051435547"></span></h3><ul><li>기본적으로 Model의 속성들은 리다이렉트 URL에 포함된다 <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java8/src/main/java/io/github/donggi/mvc/controller/Controller6.java" displayRange="[38,44,21,26,46,50,27,31,52,56]" lan="java">Controller6.java</button></li><li>속성의 자동 추가를 원하지 않는다면, @RequestMapping 메서드에서 RedirectAttributes 매개변수를 명시적으로 이용하면 된다<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java8/src/main/java/io/github/donggi/mvc/controller/Controller6.java" displayRange="[38,44,32,37,58,62]" lan="java">Controller6.java</button></li><li>전역적으로 설정을 변경하려면 RequestMappingHandlerAdapter의 ignoreDefaultModelOnRedirect 속성을 true로 변경하면 된다</li><p>하위 호환을 위해 false가 기본값이다</p></ul><h3>Flash Attributes<span class="pos-span" id="pos-1676026937"></span></h3><ul><li>Flash attribute는 다음 요청에서 소비하기 위해 일시적으로 세션에 저장하는 데이터다. 주로 리다이렉션 처리에 이용된다</li><li>임시 속성을 담는 데 FlashMap이 이용되고, FlashMapManager이 FlashMap을 관리한다</li><li>FlashMap은 이전 요청으로부터 전달되는 input, 다음 요청으로 전달할 output으로 구분된다</li><li>@RequestMapping 메서드에서는 input-output FlashMap을 직접 이용하지 않고 RedirectAttributes를 획득하여 사용하면 된다 <a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos2051435547" target="_self">Redirect Attributes</a></li><li>RedirectView는 FlashMap 인스턴스에 대해 리다이렉트 URL과 시각을 기록함으로써, 실제 리다이렉트된 요청에 임시 속성을 전달하게 한다</li><p>그럼에도 불구하고 비동기적으로 빈번하게 요청이 들어오는 경우, 실제로 전달되어야 할 곳이 아닌 다른 요청에 임시 속성을 전달될 가능성이 있다</p></ul><h3>@ResponseBody<span class="pos-span" id="pos5090787"></span></h3><ul><li>메서드에 @ResponseBody가 적용된 경우 반환 객체를 HTTP 응답으로(HttpMessageConverter) 전송한다. AJAX에 유용</li><li>Jackson JSON 예 <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java8/build.gradle" displayRange="[31,31]" lan="gradle">build.gradle</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java8/src/main/java/io/github/donggi/mvc/controller/Controller7.java" displayRange="[9]" lan="java">Controller7.java</button></li></ul><h3>ResponseEntity<span class="pos-span" id="pos-1311327324"></span></h3><p>예 <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java8/src/main/java/io/github/donggi/mvc/controller/Controller8.java" displayRange="[10]" lan="java">Controller8.java</button></p></div><h2>Model</h2><ul><li>@Controller 또는 @ControllerAdvice 클래스의 메서드에 @ModelAttribute를 적용하면 @RequestMapping 전에 호출되어 모델을 구성한다 <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java8/src/main/java/io/github/donggi/mvc/controller/Controller9.java" displayRange="[12]" lan="java">Controller9.java</button></li><li>@ControllerAdvice 안에서 이용하는 경우 여러 컨트롤러에 공유하는 효과가 있다</li><li>@ModelAttribute 메서드는 @RequestMapping 메서드가 사용하는 매개변수 타입들을 사용할 수 있다 ─ @ModelAttribute, 요청 body 관련 부분 제외</li></ul><h2>DataBinder<span class="pos-span" id="pos-1521490412"></span></h2><ul><li>@Controller, @ControllerAdvice 클래스는 @InitBinder 메서드에서 WebDataBinder 인스턴스를 초기화할 수 있다</li><p>이를 통해 PropertyEditor, Converter, Formatter를 등록할 수 있다 <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java8/src/main/java/io/github/donggi/mvc/aop/Controller10Advice.java" displayRange="[12]" lan="java">Controller10Advice.java</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java8/src/main/java/io/github/donggi/mvc/controller/Controller10.java" displayRange="[12]" lan="java">Controller10.java</button></p><li>@InitBinder 메서드는 @RequestMapping 메서드가 사용하는 매개변수 타입들을 사용할 수 있다 ─ @ModelAttribute 제외</li><li>전역적인 변환기 등록은 <a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos87617553" target="_self">MVC config - Type Conversion</a> 참고</li></ul><h2>Exceptions<span class="pos-span" id="pos1895376872"></span></h2><ul><li>@Controller, @ControllerAdvice 클래스는 예외 처리를 위한 @ExceptionHandler 메서드를 가질 수 있다</li><li>발생한 최상위 예외 또는 가장 가까운 원인 예외 타입을 기준으로 매칭된다 <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java4/src/main/java/io/github/donggi/mvc/controller/HelloController.java" displayRange="[10]" lan="java">HelloController.java</button></li><li>둘 이상의 예외 타입을 처리하려는 경우, 공통 부모 클래스를 인자로 하면 된다</li><li>value 속성으로 특정 예외들을 명시 가능</li><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">@ExceptionHandler({FileSystemException.class, RemoteException.class})</div><li>@ControllerAdvice 예 <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/Eclipse/spring-mvc/src/main/java/io/github/donggi/advice/UnhandledExceptionAdvice.java" displayRange="[6]" lan="java">UnhandledExceptionAdvice.java</button></li></ul><div><h3 class="fake">Method Arguments</h3><table><caption>가능한 메서드 인자</caption><tr><td>Argument</td><td>Description</td></tr><tr><td>Exception</td><td>발생 예외. 임의 서브클래스 사용 가능</td></tr><tr><td>HandlerMethod</td><td>예외 발생 메서드</td></tr><tr><td>WebRequest, NativeWebRequest</td><td>서블릿 API를 직접 사용하지 않고 요청에 대한 일반적인 접근 제공</td></tr><tr><td>ServletRequest, ServletResponse</td><td>HttpServletRequest, MultipartRequest 등 임의 서브클래스 사용 가능</td></tr><tr><td>HttpSession</td><td>세션이 반드시 존재하도록 한다. 동시성이 필요한 경우 RequestMappingHandlerAdapter 인스턴스의 synchronizeOnSession를 true로 설정</td></tr><tr><td>Principal</td><td>현재 인증 유저</td></tr><tr><td>HttpMethod</td><td>HTTP 요청 타입</td></tr><tr><td>Locale, TimeZone, ZoneId</td><td>현재 로캐일, 타임존</td></tr><tr><td>OutputStream, Writer</td><td>응답을 직접 쓰려는 경우 사용</td></tr><tr><td>Map, Model, ModelMap</td><td>예외 응답을 위한 모델. 항상 비어있음</td></tr><tr><td>RedirectAttributes</td><td>리다이렉션 쿼리에 덧붙일 속성<a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos2051435547" target="_self">Redirect Attributes</a>, 리다이렉션 이후 요청까지 임시로 저장할 속성<a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos-1676026937" target="_self">Flash Attributes</a></td></tr><tr><td>@SessionAttribute</td><td>세션에 저장된 임의 인스턴스 접근 <a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos-2103470842" target="_self">@SessionAttribute</a></td></tr><tr><td>@RequestAttribute</td><td>임의 요청 속성 접근 <a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos-1461908179" target="_self">@RequestAttribute</a></td></tr></table><h3 class="fake">Return Values</h3><table><caption>가능한 반환값</caption><tr><td>Return</td><td>Description</td></tr><tr><td>@ResponseBody</td><td>HttpMessageConverter 인스턴스가 반환값을 적절히 응답에 쓴다 <a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos5090787" target="_self">@ResponseBody</a></td></tr><tr><td>HttpEntity&lt;B>, ResponseEntity&lt;B></td><td>HTTP 헤더와 바디를 포함한 전체 응답을 반환하면 HttpMessageConverter가 적절히 응답에 쓴다 <a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos-1311327324" target="_self">ResponseEntity</a></td></tr><tr><td>String</td><td>뷰 이름을 반환하면 ViewResolver가 적절히 뷰를 선택한다</td></tr><tr><td>View</td><td>렌더링할 뷰</td></tr><tr><td>Map, Model, @ModelAttribute AnyType</td><td>묵시적 모델에 추가될 속성</td></tr><tr><td>ModelAndView</td><td>뷰 + 모델</td></tr><tr><td>void</td><td>void 리턴, null 리턴이 아래 상황에서 이루어졌다면 응답이 완료됐다고 간주한다<ul><li>ServletResponse, OutputStream 인자를 메서드로 받은 경우</li><li>@ResponseStatus를 갖는 경우</li><li>컨트롤러가 ETag, lastModified를 설정한 경우</li></ul>그 외의 경우 "no response body"(REST 컨트롤러), 기본 뷰(HTTP 컨트롤러)를 의미한다</td></tr></table><h3 class="fake">REST API 전역 예외 처리</h3><p>@ControllerAdvice 클래스가 ResponseEntityExceptionHandler를 상속함으로써 스프링 내부 예외를 자동으로 처리하고 ResponseEntity로 반환할 수 있다</p></div><h2>Controller Advice</h2><ul><li>@ExceptionHandler, @InitBinder, @ModelAttribute 메서드는 @Controller 뿐만 아니라 @ControllerAdvice, @RestControllerAdvice 클래스도 가질 수 있다</li><p>적용 범위를 제한하지 않은 경우(default) 모든 요청에 적용된다</p><li>@RestControllerAdvice = @ControllerAdvice + @ResponseBody로, @ExceptionHandler 메서드가 응답을 반환함을 의미한다</li><li>@ExceptionHandler 메서드는 @Controller의 것이 먼저 실행되고, @InitBinder, @ModelAttribute 메서드는 @Controller의 것이 나중에 실행된다</li></ul></div><h1>Functional Endpoints</h1><div><h2>Overview</h2><ul><li>WebMvc.fn에서 HTTP 요청은 HandlerFunction을 통해 처리된다</li><p><strong>↓ @FunctionalInterface HandlerFunction</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">// org.springframework.web.servlet.function Since 5.2
T handle(ServerRequest request)
// org.springframework.web.reactive.function.server Since 5.0
Mono&lt;T&gt; handle(ServerRequest request)</div><li>HTTP 요청에 대한 HandlerFunction의 선택은 RouterFunction을 통해 이루어진다</li><p><strong>↓ @FunctionalInterface RouterFunction</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">// org.springframework.web.servlet.function Since 5.2
Optional&lt;HandlerFunction&lt;T>> route(ServerRequest request)
// org.springframework.web.reactive.function.server Since 5.0
Mono&lt;HandlerFunction&lt;T>> route(ServerRequest request)</div><li>정의된 RouterFunction 빈들은 RouterFunction#andOther()를 통해 합쳐진다</li><li>RouterFunctions.route()가 RouterFunction 빌더를 제공한다 <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java9/src/main/java/io/github/donggi/mvc/config/AppConfig.java" lan="java">AppConfig.java</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java9/src/main/java/io/github/donggi/mvc/handler/Handler1.java" displayRange="[9]" lan="java">Handler1.java</button></li></ul><h2>HandlerFunction</h2><ul><li>ServerRequest</li><p>HTTP 요청에 대한 불변 객체. HTTP 요청 방식, URI, 헤더, 쿼리 인자, 요청 본문(body)을 제공한다 <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java9/src/main/java/io/github/donggi/mvc/handler/Handler2.java" displayRange="[19]" lan="java">Handler2.java</button></p><li>ServerResponse</li><p>HTTP 응답에 대한 불변 객체. <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java9/src/main/java/io/github/donggi/mvc/handler/Handler2.java" displayRange="[19]" lan="java">Handler2.java</button></p></ul><h2>RouterFunction</h2><ul><li>RequestPredicates 유틸리티 클래스가 유용한 RequestPredicate들을 제공한다</li><p>RequestPredicate#and, or을 이용해 여러 predicate을 조합할 수 있다</p><li>각 라우터는 순서대로 평가되고, 가장 처음으로 매칭되는 핸들러가 요청을 처리한다</li><li>중첩 경로에 대한 라우팅 예</li><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">import static org.springframework.web.servlet.function.RouterFunctions.route;

route()
    .path("/person", builder -> builder
        .GET("/{id}", accept(APPLICATION_JSON), handler::getPerson)
        .GET("", accept(APPLICATION_JSON), handler::listPeople)
        .POST("/person", handler::createPerson))
    .build();

route()
    .path("/person", b1 -> b1
        .nest(accept(APPLICATION_JSON), b2 -> b2
            .GET("/{id}", handler::getPerson)
            .GET("", handler::listPeople))
        .POST("/person", handler::createPerson))
    .build();</div></ul><h2>Filtering Handler Functions</h2><p>before, after, filter를 이용해 사전/사후 작업을 정의할 수 있다</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">route()
    .path("/person", b1 -> b1
        .nest(accept(APPLICATION_JSON), b2 -> b2
            .GET("/{id}", handler::getPerson)
            .GET("", handler::listPeople)
            .before(request -> ServerRequest.from(request).header("X-RequestHeader", "Value").build()))
        .POST("/person", handler::createPerson))
    .after((request, response) -> logResponse(response)) 
    .build();</div></div><h1>URI Links</h1><div><h2>UriComponents</h2><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">var uriComponents = UriComponentsBuilder
                        .fromUriString("https://example.com/hotels/{hotel}")
                        .queryParam("q", "{q}").encode().build();
URI uri = uriComponents.expand("Westin", "123").toUri();</div><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">URI uri = UriComponentsBuilder
            .fromUriString("https://example.com/hotels/{hotel}?q={q}")
            .build("Westin", "123");</div><h2>UriBuilder</h2><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">var baseUrl = "https://example.com";
var uriBuilderFactory = new DefaultUriBuilderFactory(baseUrl);
URI uri = uriBuilderFactory.uriString("/hotels/{hotel}")
            .queryParam("q", "{q}").build("Westin", "123");</div><h2>URI Encoding</h2><ul><li>UriComponentsBuilder#encode()</li><p>URI 템플릿을 먼저 인코딩. URI 변수들은 할당되는대로 인코딩</p><li>UriComponents#encode()</li><p>URI 변수들이 할당된 후 전체 인코딩</p><li>DefaultUriBuilderFactory#setEncodingMode()</li><ul><li>EncodingMode.TEMPLATE_AND_VALUES Since 5.0.8 : URI 템플릿을 먼저 인코딩. URI 변수들은 할당되는대로 인코딩</li><li>EncodingMode.URI_COMPONENT : URI 변수들이 할당된 후 전체 인코딩</li><li>EncodingMode.VALUES_ONLY : URI 변수만 UriUtils#encodeUriVariables()으로 인코딩</li><li>EncodingMode.NONE : 인코딩 안 함</li></ul></ul><h2>Relative Servlet Requests</h2><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">HttpServletRequest request;
// Re-uses host, scheme, port, path and query string...
var builder = ServletUriComponentsBuilder.fromRequest(request)
                .replaceQueryParam("accountId", "{id}")
                .build().expand("123").encode();</div><h2>Links in Controllers</h2><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">@Controller
@GetMapping("/path1/{val1}")
public class C {
    @GetMapping("/path2/{val2}")
    public ModelAndView methodName() { }
}

var uriComponents = MvcUriComponentsBuilder
                        .fromMethodName(C.class, "methodName", "value2")
                        .buildAndExpand("value1");</div><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">UriComponentsBuilder base = ServletUriComponentsBuilder.fromCurrentContextPath().path("/en");
MvcUriComponentsBuilder builder = MvcUriComponentsBuilder.relativeTo(base);</div></div><h1>Asynchronous Requests</h1><div><h2>Configuration</h2><p>요청 비동기 처리를 위해 서블릿 컨테이너 수준의 옵션을 설정해야 한다</p><div><h3 class="fake">Servlet Container</h3><ul><li>Java Config</li><p>AbstractAnnotationConfigDispatcherServletInitializer를 이용하면 된다</p><li>web.xml</li><ul><li>DispatcherServlet, Filter 정의에 &lt;async-supported>true&lt;/async-supported></li><li>필터 매핑에 &lt;dispatcher>ASYNC&lt;/dispatcher></li></ul></ul><h3 class="fake">Spring MVC</h3><ul><li>Java Config</li><p>WebMvcConfigurer의 configureAsyncSupport 재정의</p><li>XML Config</li><p>&lt;mvc:annotation-driven> 안에 &lt;async-support> 정의</p></ul><ul>↓ 설정 가능한 옵션들<li>timeout : 설정하지 않으면 서블릿 컨테이너의 것이 적용된다</li><p>timeout은 DeferredResult, ResponseBodyEmitter, SseEmitter, WebAsyncTask 각각에서도 설정 가능하다</p><li>AsyncTaskExecutor : 설정하지 않으면 SimpleAsyncTaskExecutor가 이용된다</li><li>DeferredResultProcessingInterceptor, CallableProcessingInterceptor</li></ul></div><h2>DeferredResult<span class="pos-span" id="pos-297540356"></span></h2><p>별개 스레드에서 값을 쓴다 <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java10/src/main/java/io/github/donggi/mvc/controller/Controller1.java" displayRange="[9]" lan="java">Controller1.java</button></p><h2>Callable<span class="pos-span" id="pos-107604776"></span></h2><p>Callable에서 값을 반환한다 <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java10/src/main/java/io/github/donggi/mvc/controller/Controller2.java" displayRange="[7]" lan="java">Controller2.java</button></p><h2>Processing</h2><div><h3>Interception</h3><ul><li>WebMvcConfigurer 예 <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java10/src/main/java/io/github/donggi/mvc/config/AppConfig.java" displayRange="[12]" lan="java">AppConfig.java</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java10/src/main/java/io/github/donggi/mvc/interceptor/DeferredResultInterceptor.java" displayRange="[8]" lan="java">DeferredResultInterceptor.java</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java10/src/main/java/io/github/donggi/mvc/interceptor/CallableInterceptor.java" displayRange="[9]" lan="java">CallableInterceptor.java</button></li><li>DeferredResult#onTimeout 예 <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java10/src/main/java/io/github/donggi/mvc/controller/Controller3.java" displayRange="[9]" lan="java">Controller3.java</button></li><li>WebAsyncTask 예 <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java10/src/main/java/io/github/donggi/mvc/controller/Controller4.java" displayRange="[7]" lan="java">Controller4.java</button></li></ul><h3>Compared to WebFlux</h3><ul><li>Servlet 3.0에 추가된 비동기 처리는 Filter-Servlet 체인에서 벗어나 ─ 컨테이너 스레드는 해제된다 ─ 결과를 대기한다</li><p>응답을 쓰기 위해 별도 스레드가 이용되며, IO 자체는 blocking이다</p><li>반면 WebFlux는 Servlet API를 따르지 않으며, 최초 설계부터 비동기적이다</li><p>요청 처리에 대한 모든 단계가 비동기적으로 처리될 수 있다. IO는 non-blocking이다</p></ul></div><h2>HTTP Streaming<span class="pos-span" id="pos-990817622"></span></h2><div><h3>ResponseBodyEmitter</h3><p>각 객체들은 HttpMessageConverter를 통해 변환된다. <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java10/src/main/java/io/github/donggi/mvc/controller/Controller5.java" displayRange="[9]" lan="java">Controller5.java</button></p><h3>SseEmitter</h3><p>ResponseBodyEmitter의 서브클래스로, Server-Sent Events를 지원한다. <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java10/src/main/java/io/github/donggi/mvc/controller/Controller6.java" displayRange="[10]" lan="java">Controller6.java</button></p><h3>StreamingResponseBody</h3><p>Converter를 거치지 않고 OutputStream에 직접 쓴다<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java10/src/main/java/io/github/donggi/mvc/controller/Controller7.java" displayRange="[7]" lan="java">Controller7.java</button></p></div><h2>Disconnects</h2><p>Servlet API는 클라이언트 연결 종료를 통지하지 않음에 유의</p></div><h1>CORS<span class="pos-span" id="pos2074541"></span></h1><div><h2>@CrossOrigin</h2><ul>↓ 기본 설정<li>모든 origin 허용</li><li>모든 header 허용</li><li>매핑에 일치하는 모든 HTTP method 허용</li><li>allowedCredentials 비허용</li><li>maxAge 30분</li></ul><h2>Global Configuration</h2><ul><li>Java Configuration</li><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/api1/**")...;
        registry.addMapping("/api2/**")...;
    }
}</div><li>XML Configuration</li><p><strong>↓ xml</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="xml">&lt;mvc:cors>
    &lt;mvc:mapping path="/api/**"
        allowed-origins="https://domain1.com, https://domain2.com"
        allowed-methods="GET, PUT"
        allowed-headers="header1, header2, header3"
        exposed-headers="header1, header2" allow-credentials="true"
        max-age="123" />
    &lt;mvc:mapping path="/resources/**"
        allowed-origins="https://domain1.com" />
&lt;/mvc:cors></div></ul><h2>CorsFilter</h2><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">var config = new CorsConfiguration();
config.setAllowCredentials(true);
config.addAllowedOrigin("https://domain1.com");
config.addAllowedHeader("*");
config.addAllowedMethod("*");

var source = new UrlBasedCorsConfigurationSource();
source.registerCorsConfiguration("/**", config);

var filter = new CorsFilter(source);</div></div><h1>HTTP Caching</h1><div><h2>CacheControl</h2><p>Cache-Control 헤더 정보를 의미한다</p><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">// Cache for an hour - "Cache-Control: max-age=3600"
CacheControl.maxAge(1, TimeUnit.HOURS);
// Prevent caching - "Cache-Control: no-store"
CacheControl.noStore();</div><h2>Controllers</h2><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">@RequestMapping(...)
public ResponseEntity&lt;Something> method(...) {
    return ResponseEntity
            .ok()
            .cacheControl(CacheControl.maxAge(30, TimeUnit.DAYS))
            ...;
}</div></div><h1>View Technologies<span class="pos-span" id="pos701800517"></span></h1><div><h2>Thymeleaf</h2><p>Spring MVC 연동은 Thymeleaf 프로젝트가 관리한다. 다음 빈들이 필요하다 ─ ServletContextTemplateResolver, SpringTemplateEngine, ThymeleafViewResolver</p><h2>FreeMarker</h2><p>예 <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java11/src/main/java/io/github/donggi/mvc/config/AppConfig.java" displayRange="[12]" lan="java">AppConfig.java</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java11/src/main/java/io/github/donggi/mvc/controller/MyController.java" displayRange="[7]" lan="java">MyController.java</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java11/src/main/webapp/WEB-INF/freemarker/hello.ftl" lan="html">hello.ftl</button></p><h2>JSP, JSTL</h2><div><h3 class="fake">View Resolvers</h3><p>ResourceBundleViewResolver 예 <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java12/src/main/java/io/github/donggi/mvc/config/AppConfig.java" displayRange="[13]" lan="java">AppConfig.java</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java12/src/main/webapp/WEB-INF/classes/my_views.properties" lan="ini">my_views.properties</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java12/src/main/java/io/github/donggi/mvc/controller/Controller1.java" displayRange="[7]" lan="java">Controller1.java</button><br>InternalResourceViewResolver 예 <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java13/src/main/java/io/github/donggi/mvc/config/AppConfig.java" displayRange="[13]" lan="java">AppConfig.java</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java13/src/main/java/io/github/donggi/mvc/controller/Controller1.java" displayRange="[7]" lan="java">Controller1.java</button></p><h3 class="fake">JSPs versus JSTL</h3><p>JSTL(JSP Standard Tag Library)을 이용할 때에는 뷰 클래스로 JstlView를 이용해야 한다 <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java12/build.gradle" displayRange="[31,31]" lan="gradle">build.gradle</button></p><h3 class="fake">Spring’s JSP Tag Library</h3><p>spring-webmvc.jar 안의 spring.tld에 스프리이 제공하는 태그 정의가 담겨 있다. 또는 <a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="https://docs.spring.io/spring-framework/docs/5.2.8.RELEASE/javadoc-api/org/springframework/web/servlet/tags/package-summary.html#package.description">package-summary.html#package.description</a> 참고</p></div></div><h1>MVC Config</h1><div><h2>MVC 구성 켜기</h2><ol><li>Java Configuration</li><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">@Configuration
@EnableWebMvc
public class WebConfig { }</div><li>XML Configuration</li><p><strong>↓ xml</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="xml">&lt;mvc:annotation-driven></div></ol><h2>Type Conversion<span class="pos-span" id="pos87617553"></span></h2><ul><li>@Controller, @ControllerAdvice에만 적용되는 변환기를 등록하려면 <a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos-1521490412" target="_self">DataBinder</a> 참고</li><li>전역 Java Configuration 예 <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java14/src/main/java/io/github/donggi/mvc/config/AppConfig.java" displayRange="[10]" lan="java">AppConfig.java</button></li><li>XML에서는 FormattingConversionServiceFactoryBean 빈을 정의하면 된다</li></ul><h2>Validation</h2><ul><li><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black goto" href="#pos98300649" target="_self">Bean Validation</a>(예. Hibernate Validator)가 클래스패스에 존재한다면 LocalValidatorFactoryBean이 전역적으로 등록되어 @Valid, Validated를 컨트롤러 메서드에서 사용할 수 있다</li><p>직접 LocalValidatorFactoryBean를 정의하는 경우, @Primary를 붙여 충돌을 피해야 한다</p><li>전역 Validator 설정</li><ul><li>Java Configuration</li><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {
    @Override
    public Validator getValidator() { }
}</div><li>XML Configuration</li><p><strong>↓ xml</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="xml">&lt;mvc:annotation-driven validator="globalValidator"/></div></ul><li>컨트롤러 수준 Validator 설정</li><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">@Controller
public class MyController {
    @InitBinder
    protected void initBinder(WebDataBinder binder) { }
}</div></ul><h2>Interceptors<span class="pos-span" id="pos63735001"></span></h2><ol><li>Java Configuration 예 <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java3/src/main/java/io/github/donggi/mvc/config/AppConfig.java" displayRange="[19]" lan="java">AppConfig.java</button></li><p>addInterceptors(InterceptorRegistry)를 재정의하여 추가</p><li>XML Configuration 예 <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-xml4/src/main/webapp/WEB-INF/app-servlet.xml" lan="xml">app-servlet.xml</button></li><p>mvc:interceptors 태그 안에 작성</p></ol><h2>Content Types<span class="pos-span" id="pos935569767"></span></h2><ul><li>ContentNegotiationConfigurer를 이용해 확장자별 응답 Content-Type을 조정할 수 있다 <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java15/src/main/java/io/github/donggi/mvc/config/AppConfig.java" displayRange="[10]" lan="java">AppConfig.java</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java15/src/main/java/io/github/donggi/mvc/controller/Controller1.java" displayRange="[7]" lan="java">Controller1.java</button></li><li>XML Configuration</li><p>ContentNegotiationManagerFactoryBean 빈 정의</p></ul><h2>Message Converters</h2><ul><li>WebMvcConfigurer#configureMessageConverters() 재정의</li><p>이 메서드에서 컨버터를 추가하는 경우, Spring MVC 기본 컨버터들은 등록되지 않는다</p><li>WebMvcConfigurer#extendMessageConverters() 재정의</li><p>Spring MVC 기본 컨버터 등록 후 호출되어 사용자 컨버터 등록, 컨버터 수정 등 작업 가능</p><li>Spring MVC 기본 컨버터</li><ul><li>StringHttpMessageConverter, FormHttpMessageConverter 등 기본 등록</li><li>클래스패스에 존재하는 라이브러리에 맞춰 MappingJacksonHttpMessageConverter 등 등록</li></ul></ul><h2>Static Resources</h2><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">@Configuration
@EnableWebMvc
public class AppConfig implements WebMvcConfigurer {
    @Override
    public void addResourceHandlers(final ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/img/**").addResourceLocations("file:static/img/","classpath:/static/img/").setCachePeriod(31556926);
        registry.addResourceHandler("/css/**").addResourceLocations("classpath:/static/css/");
        registry.addResourceHandler("/js/**").addResourceLocations("classpath:/static/js/");
    }
}</div><p><strong>↓ xml</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="xml">&lt;mvc:resources mapping="/resources/**" location="/public, classpath:/static/" cache-period="31556926" /></div><h2>Default Servlet</h2><ul><li>DispatcherServlet이 "/" ─ 즉, 모든 요청을 받으면서도 static 리소스 또한 처리할 수 있다</li><li>Java Configuration</li><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {
    @Override
    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
        configurer.enable("myCustomDefaultServlet");
    }
}</div><li>XML Configuration</li><p><strong>↓ xml</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="xml">&lt;mvc:default-servlet-handler default-servlet-name="myCustomDefaultServlet"/></div></ul><h2>Path Matching<span class="pos-span" id="pos993156397"></span></h2><ul><li><a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="https://docs.spring.io/spring-framework/docs/5.2.8.RELEASE/javadoc-api/org/springframework/web/servlet/config/annotation/PathMatchConfigurer.html">PathMatchConfigurer</a>를 이용해 여러 옵션을 설정할 수 있다</li><li>Java Configuration</li><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {
    @Override
    public void configurePathMatch(PathMatchConfigurer configurer) {
        configurer
            .setUseTrailingSlashMatch(false)
            .setUseRegisteredSuffixPatternMatch(true);
    }
}</div><li>XML Configuration</li><p><strong>↓ xml</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="xml">&lt;mvc:annotation-driven>
    &lt;mvc:path-matching trailing-slash="false" registered-suffixes-only="true"/>
&lt;/mvc:annotation-driven></div></ul><h2>Advanced Java Config</h2><p>@EnableWebMvc는 DelegatingWebMvcConfiguration를 임포트하며, 이는 아래 작업을 수행한다</p><ul><li>Spring MVC 기본 설정</li><li>WebMvcConfigurer 탐지 후 각 설정 메서드 호출</li></ul><p>고급 설정을 원하는 경우 @EnableWebMvc를 제거하고 DelegatingWebMvcConfiguration를 직접 상속하면 된다</p></div><h1>REST Clients</h1><div><h2>RestTemplate</h2><p>동기적인 HTTP 요청을 수행한다. Spring 5.0부터는 WebClient를 대신 이용할 것이 권장된다</p><h2>WebClient Since 5.0</h2><ul><li>Non-blocking, 리액티브 HTTP 클라이언트</li><p>동기적인 요청도 가능</p><li>함수형 스타일로, Java 8 람다 사용 가능</li><li>테스트를 위한 WebTestClient도 존재</li></ul></div><h1>WebSockets</h1><div><h2>Introduction to WebSocket</h2><ul><li>WebSocket 프로토콜은 1개의 클라이언트-서버 TCP 연결 위에서 전이중, 양방향 통신 채널을 수립하는 표준을 제공한다</li><li>저수준 전송 프로토콜로, 클라이언트-서버 상호 합의된 임의 형태의 데이터 전송이 가능하다</li><p>Sec-WebSocket-Protocol 헤더로 미리 전송 형태를 합의할 수 있다</p><li>HTTP/1.1 업그레이드 기능을 이용해 기존 HTTP/HTTPS를 웹 소켓 연결 WS/WSS로 그대로 전환</li><p>사용하던 80/443포트 그대로 연결하므로 방화벽의 차단에도 안전. 프록시 서버가 HTTP 업그레이드를 처리하지 않는다면 WSS를 이용</p><li>WebSocket 서버 앞에 Nginx와 같은 웹서버가 존재하는 경우, 업그레이드 요청을 전달하도록 설정 필요</li><p>마찬가지로 클라우드 환경에서도 별도 설정이 필요할 수 있다</p><li>외부 프록시가 장기간 idle한 연결을 강제로 끊을 수도 있음에 유의</li></ul><h2>WebSocket API Since JavaEE 7</h2><div><h3 class="fake">javax.websocket : 클라이언트/서버 공통 기능</h3><ul><li>WebSocketContainer</li><p>웹소켓 클라이언트 기능. connectToServer()</p><li>ContainerProvider</li><p>WebSocketContainer 인스턴스 획득을 위한 getWebSocketContainer()</p><li>@ClientEndpoint</li><p>POJO가 클라이언트측 웹소켓임을 나타낸다. @OnOpen, @OnClose, @OnError, @OnMessage 메서드를 가질 수 있다</p><li>@OnOpen, @OnClose</li><p>선택적 Session 매개변수, 선택적 EndpointConfig 매개변수, 0 ~ n개 @PathParam String 매개변수를 가질 수 있다</p><li>@OnError</li><p>선택적 Session 매개변수, Throwable 매개변수, 0 ~ n개 @PathParam String 매개변수를 가질 수 있다</p><li>@interface OnMessage</li><p>선택적 Session 매개변수, 0 ~ n개 @PathParam String 매개변수, 아래 중 하나의 메시지 매개변수를 가질 수 있다</p><ol><li>텍스트 메시지 처리</li><ul><li>전체 메시지 String</li><li>메시지로부터 변환되는 Java primitive or class</li><li>메시지 청크 String and boolean pair : 마지막 메시지는 true</li><li>전체 메시지 Reader</li><li>Decoder.Text or Decoder.TextStream</li></ul><li>이진 메시지 처리</li><ul><li>전체 메시지 byte[] or ByteBuffer</li><li>메시지 청크 (byte[] or ByteBuffer) and boolean pair : 마지막 메시지는 true</li><li>전체 메시지 InputStream</li><li>Decoder.Binary or Decoder.BinaryStream</li></ul><li>퐁 메시지 처리 : PongMessage</li></ol></ul><h3 class="fake">javax.websocket.server : 서버 전용 기능</h3><ul><li>ServerContainer extends WebSocketContainer</li><p>ServerEndpointConfig 인스턴스 또는 @ServerEndpoint 클래스 등록</p></ul></div><h2>Spring WebSocket API</h2><div><h3>WebSocketHandler</h3><ul><li>서버측 WebSocket을 생성하려면 WebSocketHandler, TextWebSocketHandler, BinaryWebSocketHandler를 상속하면 된다</li><li>WebSocketHandler 등록 - Java Configuration</li><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {
    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry.addHandler(myHandler, "/myHandler");
    }
}</div><li>WebSocketHandler 등록 - XML Configuration</li><p><strong>↓ xml</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="xml">&lt;websocket:handlers>
    &lt;websocket:mapping path="/myHandler" handler="myHandler"/>
&lt;/websocket:handlers></div><li>동시성이 요구되는 경우, ConcurrentWebSocketSessionDecorator를 이용해 한 번에 한 스레드만 WebSocketSession를 이용해 전송하게 할 수 있다</li><li>WebSocketHandlerDecorator를 이용해 WebSocketHandler를 장식할 수 있다</li><p>ExceptionWebSocketHandlerDecorator는 임의 WebSocketHandler 메서드에서 처리되지 않은 예외 발생 시 1011 상태로 세션을 종료한다</p></ul><h3>WebSocket Handshake</h3><ul><li>HandshakeInterceptor를 이용해 WebSocket 연결 수립 전후 작업을 정의할 수 있다</li><li>HttpSessionHandshakeInterceptor 등록 - Java Configuration</li><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {
    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry.addHandler(myHandler, "/myHandler").addInterceptors(new HttpSessionHandshakeInterceptor());
    }
}</div><li>HttpSessionHandshakeInterceptor 등록 - XML Configuration</li><p><strong>↓ xml</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="xml">&lt;websocket:handlers>
    &lt;websocket:mapping path="/myHandler" handler="myHandler"/>
    &lt;websocket:handshake-interceptors>
        &lt;bean class="org.springframework.web.socket.server.support.HttpSessionHandshakeInterceptor"/>
    &lt;/websocket:handshake-interceptors>
&lt;/websocket:handlers></div><li>연결 수립 자체에 참여해야 한다면 DefaultHandshakeHandler를 상속하면 된다</li></ul><h3>Deployment</h3><p>Spring MVC를 사용하지 않더라도, WebSocketHttpRequestHandler를 이용해 웹소켓 요청을 처리할 수 있다</p><h3>Server Configuration</h3><ul><li>버퍼 사이즈, idle timeout 등의 설정이 가능하다</li><li>Tomcat, WildFly, GlassFish 설정을 위해 ServletServerContainerFactoryBean를 정의할 수 있다</li><li>Jetty 설정을 위해 WebSocketServerFactory 인스턴스를 DefaultHandshakeHandler에 삽입할 수 있다</li><p><strong>↓ java</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {
    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry.addHandler(echoWebSocketHandler(), "/echo").setHandshakeHandler(handshakeHandler());
    }
    @Bean
    public DefaultHandshakeHandler handshakeHandler() {
        WebSocketPolicy policy = new WebSocketPolicy(WebSocketBehavior.SERVER);
        policy.setInputBufferSize(8192);
        policy.setIdleTimeout(600000);
        return new DefaultHandshakeHandler(new JettyRequestUpgradeStrategy(new WebSocketServerFactory(policy)));
    }
}</div><li>클라이언트 설정을 위해 WebSocketContainerFactoryBean (XML) 또는 ContainerProvider.getWebSocketContainer() (Java configuration)를 사용할 수 있다</li></ul><h3>Allowed Origins</h3><ul><li>Since 4.1.5 : 기본적으로 같은 origin 요청만 허용</li><p>X-Frame-Options 헤더가 SAMEORIGIN으로 설정된다</p><li>모든 origin 허용 : *로 설정</li><li>일부 origin 허용 : http://, https://로 시작하는 origin들을 설정</li><p><strong>↓ Java Configuration</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {
    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry.addHandler(myHandler(), "/myHandler").setAllowedOrigins("https://mydomain.com");
    }
}</div><p><strong>↓ XML Configuration</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="xml">&lt;websocket:handlers allowed-origins="https://mydomain.com">
    &lt;websocket:mapping path="/myHandler" handler="myHandler" />
&lt;/websocket:handlers></div></ul></div><h2>SockJS Fallback</h2><div><h3>Overview</h3><p>SockJS는 웹소켓 연결에 실패하더라도 HTTP 기반의 에뮬레이션을 통해 애플리케이션 API를 지원한다</p><ul>SockJS의 구성<li>SockJS Protocol</li><li>SockJS JavsScript client</li><li>SockJS server implementation : spring-websocket이 이에 해당</li><p>spring-websocket 4.1부터는 SockJS Java client도 포함</p></ul><p>SockJS 클라이언트는 GET /info 요청으로 서버 정보를 획득한 후, 전송 수단을 선택한다 가능한 경우 WebSocket을 사용하고, 그 외엔 브라우저 별로 지원되는 HTTP 스트리밍, 최후에는 HTTP (long) polling을 이용한다<br>각 브라우저별 지원 사항은 <a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="https://github.com/sockjs/sockjs-client/#supported-transports-by-browser-html-served-from-http-or-https">#supported-transports-by-browser</a> 참고. 각 전송 방법의 차이는 <a class="w3-btn w3-round-xlarge w3-small w3-border w3-hover-black" href="https://spring.io/blog/2012/05/08/spring-mvc-3-2-preview-techniques-for-real-time-updates/">spring-mvc-3-2-preview-techniques-for-real-time-updates</a> 참고</p><p>모든 요청 URL은 아래의 꼴을 따른다</p><p><strong>↓ text</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">https://host:port/myApp/myEndpoint/{server-id}/{session-id}/{transport}</div><ul><li>server-id : 요청을 클러스터로 묶을 경우에만 사용</li><li>session-id : SockJS 세션</li><li>transport : 전송 타입(websocket, xhr-streaming)</li></ul><p>서버는 세션 수립 후 'o'(open frame), 25초(default) 동안 idle이면 'h'(heartbeat frame), 종결 시 'c'(close frame)를 전송한다</p><h3>Enabling SockJS</h3><p><strong>↓ Java Configuration</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {
    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry.addHandler(myHandler(), "/myHandler").withSockJS();
    }
}</div><p><strong>↓ XML Configuration</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="xml">&lt;websocket:handlers>
    &lt;websocket:mapping path="/myHandler" handler="myHandler"/>
    &lt;websocket:sockjs/>
&lt;/websocket:handlers></div><p>Spring MVC를 사용하지 않더라도, SockJsHttpRequestHandler를 이용해 SockJS를 이용할 수 있다</p><h3>SockJS and CORS</h3><p>CORS가 이미 허용된 경우, CORS를 허용하지 않는 경우(AbstractSockJsService#setSuppressCors(true)) 아래 설정을 하지 않는다</p><ul><li>Access-Control-Allow-Origin : 요청 Origin 헤더로 설정</li><li>Access-Control-Allow-Credentials : true</li><li>Access-Control-Request-Headers : 요청 헤더 값으로 설정</li><li>Access-Control-Allow-Methods : 지원 타입(TransportType)으로 설정</li><li>Access-Control-Max-Age : 31536000(1년)</li></ul><p>CORS 설정에서 WebSocket endpoint prefix를 제외하여 SockJsService가 처리하도록 하는 걸 고려해볼 것</p><h3>SockJsClient</h3><p>브라우저 없이 직접 WebSocket 서버에 연결하는 클라이언트를 제공한다. 지원 타입은 websocket, xhr-streaming, xhr-polling</p><ul><li>websocket : Transport 이용</li><p>WebSocketTransport의 생성에는 StandardWebSocketClient(JSR-356), JettyWebSocketClient(Jetty 9+), 임의 WebSocketClient 구현체 사용 가능</p><li>xhr : XhrTransport 이용</li><ul><li>RestTemplateXhrTransport : HTTP 요청에 Spring RestTemplate 사용</li><li>JettyXhrTransport : HTTP 요청에 Jetty HttpClient 사용</li></ul><p><strong>↓ SockJsClient 생성 및 연결</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="java">var transports = new ArrayList&lt;Transport>(2);
transports.add(new WebSocketTransport(new StandardWebSocketClient()));
transports.add(new RestTemplateXhrTransport());

var sockJsClient = new SockJsClient(transports);
sockJsClient.doHandshake(new MyWebSocketHandler(), "ws://example.com:8080/sockjs");</div></ul></div><h2>STOMP</h2><p>WebSocket 통신은 text 또는 binary 메시지 전송으로 이루어지며, 원활한 통신을 위해 sub-protocol을 이용할 수 있다</p><div><h3>Overview</h3><p>STOMP(Simple Text Oriented Messaging Protocol)는 양방향 네트워크 상에서 메시지 전송을 위한 최소 규격을 정의한다</p><p><strong>↓ STOMP Frame</strong></p><div class="as-code code-div w3-leftbar w3-border-green" lan="text">COMMAND
header1:value1
header2:value2

Body^@</div><ul>Command 종류<li>SEND : 클라이언트 -> 서버 전송</li><li>SUBSCRIBE : 클라이언트 -> 서버 구독</li><li>MESSAGE : 서버 -> 클라이언트 브로드캐스트</li></ul><p>이하 생략 - 사용하게 되면 정리</p></div><h2>Spring WebSocket 예</h2><ul><li>javax.websocket-api, spring-websocket 필요 <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java16/build.gradle" displayRange="[27,27,35,35]" lan="gradle">build.gradle</button></li><li>@EnableWebSocket + WebSocketHandler 예 <button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java16/src/main/java/io/github/donggi/mvc/config/AppConfig.java" displayRange="[15]" lan="java">AppConfig.java</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java16/src/main/java/io/github/donggi/mvc/ws/Echo.java" displayRange="[10]" lan="java">Echo.java</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java16/src/main/webapp/static/ws.html" lan="html">ws.html</button></li><li>@ServerEndpoint 예<button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java17/src/main/java/io/github/donggi/mvc/ws/Echo.java" displayRange="[20]" lan="java">Echo.java</button><button class="w3-btn w3-round-xxlarge w3-small w3-teal btn-code" title="/Repositories/STS/mvc-java17/src/main/webapp/static/ws.html" lan="html">ws.html</button></li></ul></div></div></article><hr><script id="google-analytics" src="https://www.googletagmanager.com/gtag/js?id=UA-143098403-1" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-143098403-1');</script><script id="highlight-js" src="/source/highlight.pack.js" defer></script><script id="default-js" src="/source/default.min.js" defer></script></body></html>