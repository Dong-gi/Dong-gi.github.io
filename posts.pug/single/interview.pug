include ../../source/skeleton.pug

+post('개발자 면접 준비', '개발자, 면접, 이력서, 자기소개서, 코딩 테스트, 준비', '개발자 면접 준비 도움말', true)
    h1 참고 도서 정보
    .w3-row
        .w3-col.s2.w3-center
            +w3img(src='https://www.hanbit.co.kr/data/books/B7155705626_l.jpg', '도서 이미지')&attributes({style: 'max-height:210px'})
        .w3-col.s10
            table.no-sort
                +tds('제목', '(JAVA) 프로그래밍 면접 이렇게 준비한다')
                +tds('저자', '지은이: 노엘 마크엄 옮긴이: 정원천')
                +tds('ISBN', '978-89-6848-152-9 [93000]')
                +tds('발행일', '2015년 02월 01일')
                +tds('발행처', '한빛미디어')
        h2 책의 오류
        ul
            li 80p 정수 타입 배열에는 final 키워드를 사용할 수 없다
            p -> 배열 원소의 타입과 무관하게 final 키워드 사용 가능하며, 해당 변수 초기화 이후 재할당은 불가하다
    .w3-row
        .w3-col.s2.w3-center
            +w3img(src='https://www.hanbit.co.kr/data/books/B9005920688_l.jpg', '도서 이미지')&attributes({style: 'max-height:210px'})
        .w3-col.s10
            table.no-sort
                +tds('제목', '프로그래밍 면접 이렇게 준비한다')
                +tds('저자', '존 몽건,노아 킨들러,에릭 기게리 지음 서환수 옮김')
                +tds('ISBN', '979-11-6224-199-8 [93000]')
                +tds('발행일', '2019년 07월 04일')
                +tds('발행처', '한빛미디어')
    .w3-row
        .w3-col.s2.w3-center
            +w3img(src='https://image.yes24.com/goods/44305533/800x0', '도서 이미지')&attributes({style: 'max-height:210px'})
        .w3-col.s10
            table.no-sort
                +tds('제목', '코딩 인터뷰 완전 분석')
                +tds('저자', '게일 라크만 맥도웰 지음 이창현 옮김')
                +tds('ISBN', '978-89-6626-308-0 [13560]')
                +tds('발행일', '2017년 08월 14일')
                +tds('발행처', '인사이트')

    h1 이력서
    ol
        li 전문성과 기술을 어필
        li 2p 이내로 요약하는 것이 좋다
        +asCode().
            # 지원 동기와 현재까지 경력을 요약한 첫 문단

            # 경력 사항
            - 업무 기간, 장소, 수행 역할, 성과
            관리자, 숙련 개발자라면 기술 목록보다는 관리 성과가 중점이 되야 한다
            - 한 일을 정량적으로 기술하는 것이 좋다 : X를 구현하여 Y를 성취했고, 그 결과 Z를 이루었다
            예. MySQL DB 스키마를 설계하고, 자바 멀티스레딩과 JDBC를 이용해 통신하는 프로그램 구현
            예. 분산 캐시를 구현하여 렌더링 시간을 75% 줄였고, 그 결과 로그인 시간을 10% 단축했습니다
            - 이직 사유를 적는 것은 지양

            # 최종 학력

            # 기술 역량
            개발 가능 언어 : Java, C#, JavaScript, Python
            데이터베이스 : MySQL, PostgreSQL, MongoDB
            운영체제 : Windows(7↑), Linux, Android
            프레임워크 : WPF, Spring Boot, Node Express
            템플릿 엔진 : FreeMarker, Pug(구 Jade)


    h1 자기소개서
    ol
        li 팀(회사)에 어울리는 사람임을 어필
        ul
            li 이력서의 내용 중 지원하는 역할과 관련 있는 내용을 강조
            li 구체적인 지원 동기
        li 1p 이내로 작성
        li 이력 사이의 공백에 대해 설명

    h1 면접
    ul
        li 인력 풀이 좋은 회사일수록 면접이 까다로워지는 이유는 false positive 오류를 피하려고 하기 때문
        li 어떤 사업을 하는 회사인지, 무료 상용 서비스가 있다면 직접 체험할 필요도 있다
        li 스타트업 같은 소규모 회사는 CET, CTO 등의 SNS를 통해 동향 파악 가능
        li 면접관이 질문이 있는지 물었을 때, 없다고 답하면 부정적으로 보일 수 있음
        ul
            li 순수한 질문 : 실제로 궁금한 사항
            li 통찰력을 보일 수 있는 질문
            p 예. X라는 기술을 사용하시는 것 같은데, Y 문제는 어떻게 해결하시나요?
            li 열정을 보일 수 있는 질문
            p 예. 회사 내에서 X에 대해 배울 기회가 있나요?

    h1 면접관의 입장
    ul
        li 힌트나 조언 하나로 지원자의 성적에 큰 차이를 만들어 낸다면 좋은 면접 문제는 아니다
        li 알기 어려운 지식이 아닌, 풀기 어려운 문제가 좋다
        p 컴퓨터공학을 전공했더라도 대부분은 다익스트라 알고리즘, AVL의 동작을 기억하지 못할 것이다
        li 지원자를 긍정적으로 대하라
        li 질문의 종류
        ul
            li Sanity check : 문제 해결 능력의 최소를 평가하기 위한 문제
            li Quality check : 치밀하게 설계되고, 생각하게끔 만들어진 어려운 문제
            li Specialist questions : 특정 분야의 전문지식과 관련된 문제
            li Proxy knowlege : 지원자의 레벨에서 알고 있을법한 지식과 관련된 문제

    h1 일반 질문
    ul
        li 입사하여 무엇을 하고 싶은지? / 이 회사에서 일하고 싶은 이유는?
        li 자신의 단점이 무엇인지?
        p → 자신의 진짜 단점을 설명하고, 극복을 위해 어떻게 하고 있는지 강조
        li 인생의 목표가 무엇인지?
        li 희망 연봉은?
        ul
            li 성급하게 부르지 말고 먼저 얼마나 제시할 수 있는지 물어보기
            li 연봉을 움직이기 어려운 경우, 사이닝 보너스, 성과급, 휴가 등 복지 요구 시도

    h1 경력 질문
    ul
        li 경력에 대해 얘기해보세요
        p 전에 했던 일에 대한 객관적 사실 + 무엇을 배웠는지, 어떤 문제가 있었는지
        table
            +ths('질문', '프로젝트 1', '프로젝트 n')
            +tds('도전적이었던 것', '?', '?')
            +tds('실수 또는 실패', '?', '?')
            +tds('즐거웠던 것', '?', '?')
            +tds('리더십', '?', '?')
            +tds('팀원과의 갈등', '?', '?')
            +tds('남들과 다르게 한 것', '?', '?')
        li 이직하는 이유가 무엇인지?
        li 가장 고치기 어려웠던 버그는 무엇이었는지?

    h1 알고리즘/코딩 질문
    div
        h2 big-O 표기법
        ul
            li 아래 코드의 시간복잡도는?
            +asCode('java').
                void print(int[] arr1, int[] arr2) {
                    for (var i = 0; i &lt; arr1.length; ++i) {
                        for (var j = 0; j &lt; arr2.length; ++j) {
                            if (arr1[i] &lt; arr2[j])
                                System.out.print("Found");
                        }
                    }
                }
            p ↓ if 블록은 상수 시간에 수행되므로,
            +asCode('java').
                for (var i = 0; i &lt; arr1.length; ++i)
                    for (var j = 0; j &lt; arr2.length; ++j)
                        /* O(1) 작업 */
            p 따라서 답은 O(NM)
            li 문자열 배열이 주어졌을 때, 문자열 각각을 정렬한 뒤, 배열을 정렬하는 시간복잡도는?
            p → 배열 크기를 N, 가장 긴 문자열의 길이를 L이라고 할 때, 각 문자열을 정렬하는 시간은 O(N*LlogL)이면 충분하다. 배열을 정렬하는 데에 O(NlogN) 번의 비교가 필요하고, 각 비교에 O(L) 시간이 소요되므로, 총 소요 시간은 O(N*LlogL + L*NlogN) = O(NL(logL + logN))
            li 순열을 모두 출력하는 아래 코드의 시간복잡도는?
            +asCode('java').
                void permutation(String str) {
                    permutation(str, "");
                }
                void permutation(String str, String prefix) {
                    if (str.length() == 0)
                        System.out.println(prefix);
                    else {
                        for (var i = 0; i &lt; str.length(); ++i) {
                            var remain = str.substring(0, i) + str.substring(i+1);
                            permutation(remain, prefix + str.charAt(i));
                        }
                    }
                }
            ol
                li permutation(String, String) 호출 트리를 그려보면, 총 n!개의 단말 노드가 존재한다
                li 호출 트리의 깊이는 O(n)이므로, 총 노드의 개수는 O(n*n!)
                li 각 단말 노드는 출력 작업 O(n), 내부 노드들은 문자열 연결 작업 O(n)을 수행한다
                li 따라서 총 수행 시간은 식[O(n^2 \cdot n!)]식을 넘지 않는다

        h2 코드 작성 시 유의 사항
        ul
            li 발생 가능한 예외, 경계조건에서의 동작 확인
            li 단위 테스트 꼭 작성

    h1 Java 질문
    ol
        li Comparable, Comparator 인터페이스의 차이?
        p Comparable은 클래스의 자연스러운 정렬 순서를, @FunctionalInterface Comparator는 필요에 따른 임의 정렬 순서를 의미한다

        li 서로 다른 키 객체의 hashCode() 결과가 동일한데도 HashSet, HashMap이 여전히 잘 작동하는 이유?
        p hashCode()에 대응하는 버킷 리스트의 각 버킷은 여전히 키 객체를 저장하고 있으므로 2차적인 비교를 통해 구별이 가능하기 때문

        li String interning?
        p 서로 다른 위치에 존재하는 같은 내용의 String 리터럴이 상수 풀의 단일 String 객체를 참조하는 것

        li Vector, Hashtable 클래스가 이미 있는데 ArrayList, HashMap이 추가된 이유?
        ul
            li Vector, Hashtable은 동기화되어 병렬 처리에 적합하지만, 병렬 처리할 일이 없다면 불필요한 오버헤드만 발생한다
            li 따라서 스레드-안전할 필요가 없다면 각각 ArrayList, HashMap를 이용하는 것이 좋다
            li 추가적으로, 높은 병렬성이 요구된다면 ConcurrentHashMap을 이용하는 것이 좋다

        li 병렬로 실행되는 코드를 테스트하려면?
        ul
            li 방법1. 모든 작업이 테스트 스레드에서 실행되도록 Executor 변경
            +asCode('java').
                @Test
                void test() {
                    final var executor = new Executor() {
                        @Override
                        public void execute(final Runnable command) {
                            command.run();
                        }
                    }
                    // ...
                }
            li 방법2. 병렬 스레드가 종료되기를 기다림
            ol
                li 모든 작업을 등록한 뒤 ExecutorService의 shutdown()을 호출하여 추가 작업을 받지 않도록 한다
                li isTerminated() 또는 awaitTermination()으로 종료 확인
