include ../../source/skeleton.pug
+post('com.sun.nio.sctp', 'com.sun.nio.sctp', 'com.sun.nio.sctp 정리')
    h1 Package Detail
    ol
        li 자바 SCTP; Stream Control Transport Protocol 구현을 제공한다
        +codeBtn('/Repositories/Eclipse/JavaSE/src/nio/sctp/SctpChannelTest.java', 'java') 나중에 다시...
        li SCTP는 전송 계층 프로토콜로써, TCP처럼 연결-지향적이며, UDP처럼 메시지-지향적이다
        li SCTP는 multi-homing을 지원한다 : 연결의 Primary 주소가 비가용 상태가 되더라도 Sub 주소를 통해 연결을 지속할 수 있다
        li 연결에서 데이터 교환은 논리적인 스트림들로 나뉘며, 각 스트림은 메시지들의 이동 경로가 된다. 스트림 내부적으로 메시지의 순서를 관리한다.
        li One-to-one 스타일 구현체 : SctpServerChannel, SctpChannel
        p TCP와 유사한 인터페이스를 제공하며, 하나의 SCTP association만 관리한다
        li One-to-many 스타일 구현체 : SctpMultiChannel
        p UDP와 유사한 인터페이스를 제공하며, 여러 SCTP association을 관리할 수 있다.

    h1 Association
    ol
        li Association은 두 SCTP 종단점 사이의 연결을 의미한다.
        p 각 종단점은 전송 계층 주소의 리스트를 가지며, 따라서 Association은 두 주소의 카티션 곱만큼 존재할 수 있다
        li 각 Association은 ID를 가지며, association이 유효한 동안 채널 안에서 유일하게 존재한다
        li SCTP가 Dynamic Address Reconfiguration(RFC5061)을 구현한 경우, Association의 종단점 주소는 변경될 수 있다
        li final int associationId() + maxInboundStreams, maxOutboundStreams

    h1 Notification 연관
    div
        h2 Notification
        +asCode('java') Association association() // 관련 Association을 반환한다

        h2 NotificationHandler&lt;T>
        +asCode('java') HandlerResult handleNotification(Notification notification, T attachment)

        h2 HandlerResult
        +asCode('java').
            CONTINUE // 다른 메시지나 알림을 대기
            RETURN   // 다른 데이터를 기다리지 말고 반환

        h2 AbstractNotificationHandler&lt;T>
        p NotificationHandler 스켈레톤을 제공한다. handleNotification 메서드는 CONTINUE를 반환하도록 구현됐다

        h2 AssociationChangeNotification
        div
            h3 AssociationChangeNotification.AssocChangeEvent
            +asCode('java').
                COMM_UP    // 새 association 준비 완료
                COMM_LOST  // Association 실패. 이후 송신한 메시지만큼 실패 알림이 도착한다
                RESTART    // 피어의 재시작을 감지
                SHUTDOWN   // Association 정상 종료
                CANT_START // 새 association 수립 실패

        h2 PeerAddressChangeNotification
        div
            h3 PeerAddressChangeNotification.AddressChangeEvent
            +asCode('java').
                ADDR_AVAILABLE    // 주소가 도달 가능해졌음
                ADDR_UNREACHABLE  // 주소에 도달 불가능해짐. 도달 가능해질 때까지 대체 주소로 reroute
                ADDR_REMOVED      // 이 주소는 이제 association의 일부가 아님
                ADDR_ADDED        // 이 주소는 이제 association의 일부임
                ADDR_MADE_PRIMARY // 이 주소는 이제 association의 primary 주소임
                ADDR_CONFIRMED    // 이 주소는 유효하다고 확인됨

        h2 SendFailedNotification
        +asCode('java').
            abstract SocketAddress address() // 피어 primary 주소 반환
            abstract ByteBuffer buffer()     // 보내려던 버퍼 반환
            abstract int errorCode()         // SCTP 에러 코드(RFC2960 section 3.3.10)
            abstract int streamNumber()      // 보내려던 스트림 번호

        h2 ShutdownNotification
        p 피어가 SHUTDOWN한다고 알려왔을 때, 로컬 SCTP 스택으로부터 전달된다

    h1 SCTP 소켓 옵션
    div
        h2 SocketOption&lt;T>

        h2 SctpStandardSocketOptions
        ol
            li static final SctpSocketOption&lt;Boolean> SCTP_DISABLE_FRAGMENTS
            p 메시지 파편화를 사용할 지 여부. 파편화를 사용하지 않으면 PMTU보다 큰 메시지의 송신에는 에러가 발생한다
                br
                | PMTU : Path MTU : 경로 중 가장 작은 MTU값
            li static final SctpSocketOption&lt;Boolean> SCTP_EXPLICIT_COMPLETE
            p 메시지 종결을 명시적으로 할 지 여부. 사용하는 경우, 메시지의 마지막 송신은 MessageInfo#isComplete가 true를 반환해야 한다.
                | 기본값은 false며 이는 각 전송을 완결로 간주된다. 옵션의 지원 여부는 자바 구현체에 달렸다
            li static final SctpSocketOption&lt;Integer> SCTP_FRAGMENT_INTERLEAVE
            ul
                li 메시지 파편의 조합 수준을 제어한다. 이 옵션의 지원 여부는 자바 구현체에 달렸다
                li Level 0 : 스트림에서 메시지 파편을 받기 시작했다면, 해당 스트림에서는 해당 메시지의 파편만을 허용한다. 모든 파편이 도착할 때까지 블록한다
                li Level 1 : Association 당 하나의 메시지 파편화를 허용한다. SctpChannel은 하나의 association만 가능하므로 Level 0와 동일하다.
                li Level 2 : Association + 스트림 당 하나의 메시지 파편화를 허용한다. 즉, "association X 스트림 Y", "association X 스트림 Z"를 동시에 수신할 수 있다
            li static final SctpSocketOption&lt;SctpStandardSocketOptions.InitMaxStreams> SCTP_INIT_MAXSTREAMS
            p 실제 협상 결과는 연관된 Association 객체로부터 알아낼 수 있다. Association 객체는 AssociationChangeEvent#COMM_UP 이벤트의 AssociationChangeNotification으로부터 얻을 수 있다.
            li static final SctpSocketOption&lt;Boolean> SCTP_NODELAY
            p 지연없이 송신할 지 여부. 기본적으로 SCTP는 TCP의 Nagle 알고리즘과 유사한 기법을 이용한다.
            li static final SctpSocketOption&lt;SocketAddress> SCTP_PRIMARY_ADDR
            p 로컬 SCTP 스택에서 association primary 피어 주소로 이용할 값을 지정한다.
            li static final SctpSocketOption&lt;SocketAddress> SCTP_SET_PEER_PRIMARY_ADDR
            p 피어가 association primary 주소로 이용했으면 하는 값을 지정한다.
            li static final SctpSocketOption&lt;Integer> SO_SNDBUF
            p SctpChannel에서 이 값은 한 번의 send로 보낼 수 있는 최대 크기가 된다. SctpMultiChannel에서도 같은 의미로 모든 association에 적용되고, 각 window size에 영향을 미친다.
            li static final SctpSocketOption&lt;Integer> SO_RCVBUF
            p SctpChannel에서 이 값은 수신측 window size에 영향을 미친다. SctpMultiChannel에서 이 값은 각 association에 묶인 수신측 버퍼의 크기, 또는 전체 수신 버퍼의 크기에 영향을 미칠 수 있다
            li static final SctpSocketOption&lt;Integer> SO_LINGER
            p 초 단위의 linger interval : 소켓이 닫힐 때, 아직 못 보낸 데이터를 보내거나, 보낼 수 없다고 판단하기까지 대기하는 timeout
                br
                | 음수면 이 옵션을 사용하지 않으며, 기본값은 음수다. 최댓값은 시스템 종속적이며, 그보다 큰 값을 설정하면 시스템 최댓값이 설정된다.
        div
            h3 SctpStandardSocketOptions.InitMaxStreams
            ol
                li Association 수립 협상에 사용되는 inbound/outbound 스트림 최대 개수를 정의한다
                li static SctpStandardSocketOptions.InitMaxStreams create(int maxInStreams, int maxOutStreams)
                li int maxInStreams() + maxOutStreams

    h1 MessageInfo
    ol
        li 메시지에 대한 부가 정보를 제공한다. 메시지 전송 시 createOutgoing 메서드를 이용해 부가 정보를 제공함이 바람직하다
        li static MessageInfo createOutgoing(SocketAddress address, int streamNumber)
        p streamNumber : 메시지를 보낼 스트림 번호
            br
            | address : SctpChannel에서는 적절한 피어 주소, 또는 primary 주소를 의미하는 null. SctpMultiChannel에서는 association을 결정하기 위한 피어 주소이며, association이 없으면 하나 수립된다
            br
            | 초기화 : isUnordered() == true, timeToLive() == 0, isComplete() == true, payloadProtocolID() == 0
        li static MessageInfo createOutgoing(Association association, SocketAddress address, int streamNumber)
        p SctpMultiChannel에서 기존에 수립된 association에 대해 MessageInfo를 만들 때 사용한다
        li abstract SocketAddress address()
        p 메시지를 받은 경우 : 송신 소켓 주소, 그 외의 경우 : 목적지 주소
        li abstract Association association()
        p 메시지를 받은 경우 : 메시지가 전달된 association, 그 외의 경우 : 메시지를 보낼 association
        li abstract int bytes()
        p 메시지를 받은 경우 : 읽은 메시지의 바이트 크기, 그 외의 경우 : 의미없음
        li abstract boolean isComplete() + setter 메서드
        p 메시지의 종결 여부. SCTP_EXPLICIT_COMPLETE 옵션에 따라 작동이 달라진다
        li abstract boolean isUnordered() + setter 메서드
        p 메시지가 순서적인지 여부.
        li abstract int payloadProtocolID() + setter 메서드
        p 패킷 본문을 어떻게 처리할 지 여부. SCTP에서는 사용하지 않으며(= 0), 응용 계층에서 알아서 사용하면 된다
        li abstract int streamNumber() + setter 메서드
        li abstract long timeToLive() + setter 메서드

    h1 채널 관련
    div
        h2 SctpServerChannel
        ol
            li 스레드-안전, 메시지-지향, 수신 SCTP 소켓 selectable 채널
            li 지원하는 소켓 옵션 : SCTP_INIT_MAXSTREAMS
            li static SctpServerChannel open()
            li final SctpServerChannel bind(SocketAddress local, int backlog) + 오버로딩
            p backlog는 대기하는 association의 최대 개수로, 지정하지 않으면 0이 사용되고, 이는 기본값을 의미한다
            li abstract SctpServerChannel bindAddress(InetAddress address) + unbindAddress
            p 이 채널의 소켓에 바인드 주소를 추가한다
            li abstract Set&lt;SocketAddress> getAllLocalAddresses()
            p 바인드된 모든 주소를 반환한다
            li abstract &lt;T> getOption(SctpSocketOption&lt;T> name) + setOption
            li abstract Set&lt;SctpSocketOption&lt;?>> supportedOptions()
            li final int validOps() : SelectionKey.OP_ACCEPT

        h2 SctpChannel
        ol
            li 스레드-안전. 메시지-지향 SCTP 소켓 selectable 채널
            li 채널이 연결됐는지 여부는 getRemoteAddresses()로 확인할 수 있다
            li 논-블로킹 모드로 동작할 수 있다. 연결하기 전에 AbstractSelectableChannel#configureBlocking으로 설정
            p 논-블로킹 모드에서 connect 메서드로 연결을 시작하면 즉시 반환되며, 연결 대기 중인지는 isConnectionPending 메서드로, 완료됐는지는 finishConnect 메서드로 확인 가능
            li 지원하는 소켓 옵션 : SCTP_DISABLE_FRAGMENTS, SCTP_EXPLICIT_COMPLETE, SCTP_FRAGMENT_INTERLEAVE, SCTP_INIT_MAXSTREAMS, SCTP_NODELAY, SCTP_PRIMARY_ADDR, SCTP_SET_PEER_PRIMARY_ADDR, SO_SNDBUF, SO_RCVBUF, SO_LINGER
        div
            h3 Method Detail
            ol
                li static SctpChannel open(SocketAddress remote, int maxOutStreams, int maxInStreams) + 오버로딩
                p 인자 없는 오버로딩 메서드는 단순히 채널을 열기만 하지만, 인자 있는 메서드는 열고 연결까지 진행한다
                li abstract SctpChannel bind(SocketAddress local) + bindAddress, unbindAddress, getAllLocalAddresses
                p SctpServerChannel의 설명과 동일
                li abstract boolean connect(SocketAddress remote, int maxOutStreams, int maxInStreams) + 오버로딩
                p maxOutStreams, maxInStreams 매개변수는 65536까지 가능하며, 지정되지 않거나 0이면 기본값을 사용한다. 다음의 긴 옵션 설정을 편리하게 대신해준다.
                p setOption(SctpStandardSocketOptions.SCTP_INIT_MAXSTREAMS, SctpStandardSocketOptions.InitMaxStreams.create(maxInStreams, maxOutStreams))
                li abstract boolean isConnectionPending()
                li abstract boolean finishConnect()
                p 이미 연결에 실패했다면 예외 발생 + 채널 닫힘, 이미 연결됐다면 즉시 true 반환, 논-블로킹 모드에서 연결되지 않은 경우 즉시 false를 반환, 블로킹 모드에서 연결되지 않은 경우 연결되거나 실패하기까지 블록
                li abstract Set&lt;SocketAddress> getRemoteAddresses()
                p 연결된 원격지의 주소들을 반환한다
                li abstract Association association()
                li abstract SctpChannel shutdown()
                p 채널은 닫지 않고, 연결 종료만 한다. 종료 신호를 피어에게 전달하여 추가적인 쓰기를 방지한다
                li abstract &lt;T> T getOption(SctpSocketOption&lt;T> name) + setOption, supportedOptions
                li final int validOps() : SelectionKey.OP_CONNECT | SelectionKey.OP_READ | SelectionKey.OP_WRITE
                li abstract &lt;T> MessageInfo receive(ByteBuffer dst, T attachment, NotificationHandler&lt;T7gt; handler)
                p 논-블로킹 모드에서는 메시지나 알림이 아직 가용상태가 아니라면 즉시 null이 반환된다
                    br
                    | dst에 공간이 부족하거나, 기저 input 버퍼가 완결된 메시지를 갖고 있지 않다면 반환된 MessageInfo의 isComplete 메서드는 false를 반환한다. 이 상태에서 이 메서드를 한 번 더 호출하면 메시지를 완전히 소비한다.
                    br
                    | 임의 스트림에서 단 하나의 메시지만 파편화되어 전달될 수 있다. 이를 변경하려면 SCTP_FRAGMENT_INTERLEAVE를 변경해야 한다
                    br
                    | 알림을 받고 적절한 핸들러 메서드가 존재하면 호출된다. 해당 메서드가 CONTINUE를 반환하면 이 메서드에서 계속하여 다른 메시지나 알림을 받는다. 핸들러 메서드가 RETURN을 반환하면 이 메서드는 null을 반환한다. 핸들러의 처리되지 않은 예외는 계속하여 전달된다.
                    br
                    | 이 메서드는 임의 시점에 호출될 수 있다. 다른 스레드가 이미 받기를 시작했다면 해당 연산이 종료되기까지 블록된다
                li abstract int send(ByteBuffer src, MessageInfo messageInfo)
                p 기저 output 버퍼에 충분한 공간이 있다면 src는 하나의 메시지로 전송된다. SCTP_EXPLICIT_COMPLETE 옵션이 켜 있지 않다면, 메시지의 전송은 원자적이다.
                    br
                    | 메시지는 messageInfo.streamNumber()로 정의된 스트림 번호로 전송된다. 이 메서드는 임의 시점에 호출될 수 있다. 다른 스레드가 이미 전송을 시작했다면 해당 연산이 종료되기까지 블록된다
                    br
                    | 논-블로킹 모드면서 기저 output 버퍼에 충분한 공간이 없다면 0이 반환된다.

        h2 SctpMultiChannel
        ol
            li 스레드-안전, 메시지-지향 SCTP 소켓 Selectable 채널
            li 바인드되지 않은 채널에 대해 send 메서드를 호출하면 먼저 bind 메서드가 호출된다. 이때 묶이는 주소는 getAllLocalAddresses()의 반환값 중 하나다
            li 피어에 대해 association을 명시하지 않아도 send, receive가 작동한다. 없으면 알아서 구축한다
            li 새로운 association이 구축될 때마다 AssociationChangeEvent.COMM_UP AssociationChangeNotification을 받는다
            li 지원하는 소켓 옵션 : SCTP_DISABLE_FRAGMENTS, SCTP_EXPLICIT_COMPLETE, SCTP_FRAGMENT_INTERLEAVE, SCTP_INIT_MAXSTREAMS, SCTP_NODELAY, SCTP_PRIMARY_ADDR, SCTP_SET_PEER_PRIMARY_ADDR, SO_SNDBUF, SO_RCVBUF, SO_LINGER
        div
            h3 Method Detail
            ol
                li static SctpMultiChannel open()
                li abstract Set&lt;Association> associations()
                li abstract SctpMultiChannel bind(SocketAddress local, int backlog) + 오버로딩 + bindAddress, unbindAddress, getAllLocalAddresses
                p SctpServerChannel 설명과 동일
                li abstract Set&lt;SocketAddress> getRemoteAddresses(Association association)
                p 연결된 소켓의 바인드된 주소들을 반환한다. 소켓은 주어진 association으로 식별된다
                li abstract SctpMultiChannel shutdown(Association association)
                p 채널은 닫지 않고 association을 종료한다
                li abstract &lt;T> T getOption(SctpSocketOption&lt;T> name, Association association) + setOption, supportedOptions
                p 채널 레벨 설정은 association 매개변수를 무시한다
                li final int validOps() : SelectionKey.OP_READ | SelectionKey.OP_WRITE
                li abstract &lt;T> MessageInfo receive(ByteBuffer buffer, T attachment, NotificationHandler&lt;T> handler)
                p SctpChannel 설명과 동일
                li abstract int send(ByteBuffer buffer, MessageInfo messageInfo)
                p 채널이 바인드되지 않았다면 먼저 bind(null, 0)을 호출. 피어와 수립된 association이 없으면 자동으로 하나 수립. 새로운 association이 수립되면 AssociationChangeEvent.COMM_UP AssociationChangeNotification 알림이 도착한다
                    br
                    | 기저 output 버퍼에 충분한 공간이 있다면 하나의 메시지로 전송된다. SCTP_EXPLICIT_COMPLETE 옵션이 없다면 전송은 원자적이다
                    br
                    | 논-블로킹 모드에서 어떤 이유로든 메시지 전송에 실패했다면 AssociationChangeEvent.CANT_START AssociationChangeNotification을 받는다
                li abstract SctpChannel branch(Association association)
                p 특정 association을 전담하는 SctpChannel을 반환한다. 이 association은 더 이상 SctpMultiChannel에서 관리하지 않는다.
