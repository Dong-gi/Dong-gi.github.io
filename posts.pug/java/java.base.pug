include ../../source/skeleton.pug
+post('java.base 모듈 16', 'Java, java.base, JDK16', 'JDK16 java.base 모듈 정리')
    h1 java.io
    div
        h2 Closeable
        ol
            li 데이터의 출발지나 목적지를 닫을 수 있으면 Closeable하다.
            li void close()
            p.
                스트림 및 이와 관련된 시스템 자원을 해제한다. 이미 호출되었다면 아무 일도 하지 않는다.<br>
                close() 실패했을 때, 예외를 던지는 대신 사용하던 자원을 모두 포기하고 Closeable 객체 내부적으로 '닫혔다(closed)'고 마크하길 권장한다.

        h2 Flushable
        ol
            li Flush할 수 있는 데이터 목적지는 Flushable하다.
            li void flush()
            p 버퍼에 저장된 데이터를 스트림에 모두 써 보낸다.

        h2 Console
        ol
            li JVM이 컨트롤할 수 있는 문자 기반 콘솔에 대한 접근 제공. 콘솔 존재 여부는 하위 플랫폼에 의존적이며, 싱글톤으로 System.console()을 통해 얻을 수 있다. 만일 가용한 콘솔이 없다면 null이 반환된다.
                +codeBtn('/Repositories/Eclipse/JavaSE/src/io/ConsoleExample.java', 'java')
            li 콘솔에 대한 읽기/쓰기 작업은 모두 원자적으로 이루어지며, 따라서 다른 스레드가 대기할 가능성이 있다.
            li 콘솔에 대한 close()는 실제로 아무런 영향을 미치지 않는다.
            li 유닉스의 Ctrl+D, 윈도우의 Ctrl+Z와 같은 종료 문자를 만나면 읽기 메서드는 null을 반환한다.
            li 보안 유의 : 패스워드와 같은 중요한 데이터를 읽어들일 때, readPassword(), readPassword(String, Object...) 메서드를 이용하고, 반환된 char[]를 수동으로 0 초기화한다.
        +asCode('java').
            PrintWriter writer() // 유니크한 PrintWriter 객체 반환
            Reader reader()      // 유니크한 Reader 객체 반환
            char[] readPassword(String fmt, Object... args)

        h2 바이트 단위 IO 관련
        div
            h3 DataInput
            ol
                li binary stream으로부터 바이트들을 읽고, 또 이를 자바 기본 타입 또는 String으로 만들어 반환하는 기능을 제공한다.
                li 읽기는 1바이트 단위로 이루어진다.
                li.marker Modified UTF-8
                p DataInput과 DataOutput 인터페이스는 수정된 UTF-8을 이용한다.
                ul
                    li '\u0001' ~ '\u007F'는 1바이트(0???????)로 표현한다.
                    li null('\u0000'), '\u0080' ~ '\u07FF'는 2바이트(110????? 10??????)로 표현한다.
                    li '\u0800' ~ '\uFFFF'는 3바이트(1110??? 10?????? 10??????)로 표현한다.
            +asCode('java').
                int skipBytes(int n)
                    // 입력 스트림의 n바이트를 무시한다. 실제로 무시한 바이트 길이가 반환된다.

                String readLine()
                    // 줄의 끝이나 파일 끝을 만나기까지의 문자열을 반환한다.
                    // 각 바이트들을 0 패딩하여 char로 변환하므로, 유니코드를 읽기는 부적합하다.
                    // 아무것도 읽지 못한 경우, 빈 문자열이 아닌 null이 반환된다.

                String readUTF()
                    // 먼저 readUnsignedShort()와 같은 방법으로 2개 바이트를 읽어와 UTF 길이를 구한다.
                    // 구한 길이만큼의 바이트를 읽으면서 상기한 Modified UTF-8에 맞춰 String을 만든다.
                    // 길이만큼의 바이트를 다 읽기 전에 EOF를 만나면 예외를 던진다.

            h3 DataOutput
            p DataInput과 대칭

            h3 InputStream
            ol
                li 바이트 단위 읽기에 대한 최상위 추상 클래스
                li 작업이 끝날 때까지 스레드가 블록되며, 스트림이 비동기적으로 닫히거나, 인터럽트가 발생하는 경우에 대해 대처하지 않는다.
            +asCode('java').
                static InputStream nullInputStream()
                    // 아무것도 읽지 않는 InputStream을 반환한다. 반환된 스트림은 처음부터 열려 있고, 마치 스트림의 끝에 도달한 것처럼 작동한다. 일반 InputSteram과 마찬가지로 close()를 통해 닫는다.

                long transferTo(OutputStream out)
                    // 입력 스트림의 모든 바이트를 읽어들여 out에 쓴다. 총 전송 바이트 수를 반환하며, 스트림을 닫는 작업을 하진 않는다.
                byte[] readAllBytes()
                byte[] readNBytes(int len)

                long skip(long n)
                    // 실제로 건너뛴 바이트 수를 반환. 음수 매개변수에 대해 0을 반환한다. 서브클래스들의 구현은 이와 다를 수 있다.
                int available()
                    // 막힘 없이 한 번에 읽어올 수 있는 바이트 수 예상값을 반환. InputStream 구현에 따라 전체 바이트 수를 반환하기도, 그렇지 않기도 하다. InputStream 자체는 항상 0을 반환하며, 서브클래스에서 재정의해야 한다.

                // 마킹 관련
                boolean markSupported()    // mark, reset 메서드를 지원하는지 여부 반환. 기본 false
                void mark(int readlimit)   // 현재 위치 마킹
                void reset()               // 마지막 마킹 위치로 이동

            h3 OutputStream
            ol
                li 바이트 단위 쓰기에 대한 최상위 추상 클래스
            +asCode('java').
                static OutputStream nullOutputStream()
                    // 실제로 데이터를 쓰지는 않는 OutputStream 객체를 반환한다.

            h3 FilterInputStream
            p 다른 InputStream에 대한 필터 장식자 정의 클래스로, 추가적인 메서드는 없다.

            h3 FilterOutputStream
            p 다른 OutputStream에 대한 필터 장식자 정의 클래스로, 추가적인 메서드는 없다.

            h3 ByteArrayInputStream
            p 내부 버퍼 byte[] buf에 대한 읽기 연산을 지원하는 InputStream

            h3 ByteArrayOutputStream
            p 내부 버퍼 byte[] buf에 대해 쓰기 연산을 지원하는 OutputStream. 버퍼 크기는 자동으로 확장된다.
            +asCode('java').
                void writeTo(OutputStream out)
                    // 버퍼를 out에 모두 쓴다. == out.write(buf, 0, count)

                byte[] toByteArray() // buf 복사본 반환.
                void reset() // 지금까지 쓴 것을 무시하고 처음부터 재활용.
                int size()
                String toString(String charsetName)

            h3 BufferedInputStream
            p 다른 입력 스트림에 버퍼를 제공하여 mark와 reset이 가능하게 해준다.
            +asCode('java').
                protected byte[] buf
                protected int count // 마지막 유효 바이트 인덱스 + 1
                protected int marklimit, markpos, pos
                    // |pos - markpos| &lt; marklimit면 markpos는 -1(기본값)이 된다.

            h3 BufferedOutputStream
            p 다른 출력 스트림에 버퍼를 제공하여, 시스템 쓰기 작업이 빈번하게 일어나지 않게 해준다.

            h3 DataInputStream
            p 플랫폼 독립적인 자바 기본 타입 읽기를 정의한 DataInput을 구현한 장식자 클래스(FilterInputStream).
            +asCode('java').
                static final String readUTF(DataInput in)
                    // Modified UTF-8을 이용하여 in 스트림으로부터 String을 해석해 반환한다.
            h3 DataOutputStream
            p 플랫폼 독립적인 자바 기본 타입 쓰기를 정의한 DataOutput을 구현한 장식자 클래스(FilterOutputStream)
            +asCode('java').
                protected int written
                    // 현재까지 쓴 바이트 수. 오버플로될 경우 Integer.MAX_VALUE로 설정된다.
                final int size() == return written;
            h3 PrintStream
            p OutputStream, File에 기본 타입 및 각종 문자열을 쓰는 기능을 제공한다.
            p autoFlush : 바이트 배열을 다 쓰거나, 새 줄 문자, '\n'을 쓰면 자동으로 flush()
            +asCode('java').
                    boolean checkError()
                        // flush()한 다음 오류 상태를 검사한다. 예외를 던지지 않으므로 이 메서드로 확인해야 한다. 스트림에 InterruptedIOException이 발생하면 Thread.currentThread().interrupt()를 실행한다.
            h3 PipedInputStream
            p PipedOutputStream과 연결되어 바이트들을 받는 InputStream. PipedOutputStream과 별개의 스레드에서 동작해야 한다.
                +codeBtn('/Repositories/Eclipse/JavaSE/src/io/PipedStreamExample.java', 'java')
            h3 PipedOutputStream
            p 연결된 PipedInputStream으로 바이트들을 보내는 OutputStream. PipedInputStream과 별개의 스레드에서 동작해야 한다.
                +codeBtn('/Repositories/Eclipse/JavaSE/src/io/PipedStreamExample.java', 'java')
            h3 SequenceInputStream
            p 여러 InputStream을 이어붙인듯이 활용하는 InputStream.
            h3 PushbackInputStream
            p 이미 읽은 것을 취소하고 다시 읽을 수 있는 기능을 지원한다. 이전에 읽은 내용을 저장하지는 않으므로, 덮어쓰기처럼 이용할 수 있다.
                +codeBtn('/Repositories/Eclipse/JavaSE/src/io/PushBackExample.java', 'java')
            h3 FileInputStream
            p: +codeBtn('/Repositories/Eclipse/JavaSE/src/io/SerializableExample.java', 'java')
            +asCode('java').
                FileChannel getChannel()
                    // 유니크한 FileChannel을 반환하며, 채널에서의 위치는 스트림에서 읽어들인 만큼과 같다.
            h3 FileOutputStream
            p: +codeBtn('/Repositories/Eclipse/JavaSE/src/io/SerializableExample.java', 'java')
            +asCode('java').
                FileChannel getChannel()
                    // 유니크한 FileChannel을 반환하며, 채널에서의 위치는 스트림에서 쓴 바이트 수와 같다(append 모드가 아닐 경우). append 모드에서는 파일의 크기와 채널의 위치가 동일하다.
        h2 객체 IO(직렬화) 관련
        div
            h3 ObjectInput
            p DataInput을 통해 기본 자료형을 읽어오고, 추가적으로 객체를 읽어오는 작업을 지원한다.

            h3 ObjectOutput
            p DataOutput에 추가로 객체 쓰기 작업을 지원한다.

            h3 Serializable
            ol
                li 직렬화와 역질렬화를 지원하는 마커 인터페이스. ObjectInputStream, ObjectOutputStream의 메서드들을 이용해 알아서 저장/복구한다.
                    +codeBtn('/Repositories/Eclipse/JavaSE/src/io/SerializableExample.java', 'java')
                li 직렬화하지 않을 멤버는 transient 키워드로 표시한다.
                li 직접 구현하고 싶다면 Externalizable 인터페이스를 구현하거나, 다음의 메서드들을 작성한다.
                +asCode('java').
                    private void writeObject(java.io.ObjectOutputStream out) # out에 알아서 객체 표현 바이트들을 쓰면 된다.
                    private void readObject(java.io.ObjectInputStream in)    # in에서 바이트들을 읽어와 알아서 객체를 생성하면 된다.
                    private void readObjectNoData()                          # 객체들의 버전이 다르거나, 기타 이유로 객체를 초기화할 필요가 있는 경우 사용.
                li 대체 객체를 이용해 저장 : ANY-ACCESS-MODIFIER Object writeReplace()
                li 대체 객체를 이용해 복구 : ANY-ACCESS-MODIFIER Object readResolve()
                li 클래스 버전
                +asCode('java').
                    // 정의되지 않은 경우 기본값을 사용하지만, 명시할 것을 권장하고 있다.
                    ANY-ACCESS-MODIFIER static final long serialVersionUID = (version number)L;

            h3 Externalizable
            ol
                li 객체 직렬화/역직렬화를 직접 구현하고자 할 때 이를 구현한다. 객체 직렬화는 빈 객체를 만든 뒤 각 속성의 값을 쓰므로 기본 생성자가 필요하다.
                    +codeBtn('/Repositories/Eclipse/JavaSE/src/io/ExternalizableExample.java', 'java')
            +asCode('java').
                void writeExternal(ObjectOutput out) # 객체를 out에 쓴다.
                void readExternal(ObjectInput in)    # in으로 객체를 생성한다.

            h3 ObjectInputStream
            p 객체 읽기에 관한 InputStream.
                +codeBtn('/Repositories/Eclipse/JavaSE/src/io/SerializableExample.java', 'java')

            h3 ObjectOutputStream
            p 객체 쓰기에 관한 OutputStream.
                +codeBtn('/Repositories/Eclipse/JavaSE/src/io/SerializableExample.java', 'java')

            h3 ObjectInputFilter
            ul
                li 객체 역직렬화 사전 검사
                li ObjectInputStream::setObjectInputFilter​

        h2 문자 단위 IO 관련
        div
            h3 Reader
            ol
                li char 단위 읽기에 대한 최상위 추상 클래스
                li 서브클래스들은 read(char[], int, int)와 close()만 구현해도 된다.
            +asCode('java').
                static Reader nullReader()
                    // 아무 것도 읽지 않는 Reader 객체를 반환한다.

                int read()
                    // char 하나를 읽고 int로 반환. 스트림의 끝이라면 -1을 반환한다.
                int read(char[] cbuf)
                abstract int read(char[] cbuf, int off, int len)
                    // 실제로 읽은 글자 수를 반환.

                long skip(long n)
                    // 실제로 건너 뛴 글자 수(바이트 수x) 반환

                boolean ready()
                    // 다음 read()가 블록되지 않음을 보장하면 true, 보장하지 못하면 false

                // 마킹 관련 : InputStream과 유사

                long transterTo(Writer out)
                    // 모든 글자를 읽어 out에 쓴다. 전송한 글자 수를 반환한다.
            h3 Writer
            ol
                li char 단위 쓰기에 대한 취상위 추상 클래스
                li Appendable하므로 편리함이 크다.
            +asCode('java').
                static Writer nullWriter()
                    // 아무것도 쓰지 않는 Writer 객체를 반환한다.

                void write(int c)
                    // 하위 16비트만 쓴고 나머지는 무시한다.
            h3 InputStreamReader
            p InputStream에 대해 Reader 작업을 지원해주는 bridge 클래스.
                +codeBtn('/Repositories/Eclipse/JavaSE/src/io/BufferedReaderExample.java', 'java')
            h3 OutputStreamWriter
            p OutputStream에 Writer 작업을 지원해주는 bridge 클래스.
            h3 FilterReader
            p 다른 Reader에 대한 필터 장식자 정의 클래스로, 추가적인 메서드는 없다.
            h3 FilterWriter
            p 다른 Writer에 대한 필터 장식자 정의 클래스로, 추가적인 메서드는 없다.
            h3 CharArrayReader
            p 내부 버퍼 char[] buf에 대한 읽기 연산을 지원하는 Reader
            h3 CharArrayWriter
            p 내부 버퍼 char[] buf에 대해 쓰기 연산을 지원하는 Writer. 버퍼 크기는 자동으로 확장된다.
            +asCode('java').
                void writeTo(Writer out)
                    // out에 버퍼의 모든 내용을 쓴다.
                void reset()
                    // 버퍼를 비우고 재활용한다.
                char[] toCharArray()
            h3 StringReader
            p String에 대해 읽기 연산을 수행하는 Reader.
            h3 StringWriter
            p 내부 StringBuffer에 쓰기 연산을 지원하는 Writer.
            h3 BufferedReader
            p 다른 Reader에 대한 버퍼를 제공하여, 시스템 읽기 작업이 빈번하게 일어나지 않게 해준다.
                +codeBtn('/Repositories/Eclipse/JavaSE/src/io/BufferedReaderExample.java', 'java')
            +asCode('java').
                String readLine()         // EOF도 줄의 끝으로 간주
                Stream&lt;String> lines()
            h3 BufferedWriter
            p Writer에 버퍼를 제공하여 시스템 쓰기 작업이 빈번하게 일어나지 않도록 한다.
            +asCode('java').
                void newLine() // 줄 바꿈 문자열은 시스템 속성 line.separator로 결정된다.
            h3 LineNumberReader
            p Reader가 줄 끝을 만날때마다 라인을 카운트하는 클래스. 처음 시작은 0.
            +asCode('java').
                void setLineNumber(int lineNumber) // 읽기 위치가 이동하는 건 아니다
                int getLineNumber()
            h3 PrintWriter
            p PrintStream의 Writer 버전. 텍스트 출력 스트림에 객체들을 정형화된 텍스트로 쓰는 기능을 제공한다.
            h3 PipedReader
            p PipedInputStream과 유사.
                +codeBtn('/Repositories/Eclipse/JavaSE/src/io/PipedReaderExample.java', 'java')
            h3 PipedWriter
            p PipedOutputStream과 유사.
                +codeBtn('/Repositories/Eclipse/JavaSE/src/io/PipedReaderExample.java', 'java')
            h3 PushbackReader
            p PushbackInputStream과 비슷.
                +codeBtn('/Repositories/Eclipse/JavaSE/src/io/PushBackExample.java', 'java')
            h3 FileReader
            | 특별한 내용 없음
            h3 FileWriter
            | 특별한 내용 없음

        h2 파일 관련
        div
            h3 FileFilter
            p 파일 경로 필터링에 사용되며 File#listFiles의 매개변수로 객체가 넘겨진다.
                +codeBtn('/Repositories/Eclipse/JavaSE/src/io/FileFilterExample.java', 'java')
            h3 FilenameFilter
            p 특정 디렉터리에서의 파일명 필터링에 사용되며 FileDialog#setFilenameFilter, File#list, File#listFiles의 매개변수로 객체가 넘겨진다.
                +codeBtn('/Repositories/Eclipse/JavaSE/src/io/FilenameFilterExample.java', 'java')
            h3 File
            ol
                li 추상화된 파일 및 디렉터리 경로에 대한 추상화된 표현 제공.(물리적 저장 장치 » 경로 문자열 » File 객체)
                li 경로 문자열은 절대 경로, 상대 경로 둘 다 허용된다. 상대 경로의 기준 위치는 System속성 "user.dir"로 얻을 수 있다.
                li 보다 많은 기능을 제공하는 java.nio.file 패키지가 존재한다.
            +asCode('java').
                public static final char separatorChar, String separator
                    // 시스템 속성 "file.separator", UNIX : '/', Windows : '\\'
                public static final char pathSeparatorChar, String pathSeparator
                    // 시스템 속성 "path.separator", UNIX : ':', Windows : ';'

                URI toURI(), java.nio.file.Path toPath()
                String getPath(), getAbsolutePath(), getParent() // ...
                File getAbsoluteFile(), getParentFile()          // ...

                boolean canRead(), exists(), isDirectory()          // ...
                boolean setReadOnly(), setWritable(), setReadable() // ...

                long lastModified(), length() // ...
                long getTotalSpace(), getFreeSpace(), getUsableSpace()

                boolean createNewFile(), delete(), renameTo() // ...
                boolean mkdirs() // 경로상 필요한 모든 디렉터리들 생성

                String[] list()
                File[] listFiles()

                int hashCode() : 추상 경로이름과 1234321 사이의 xor 연산

                static File[] listRoots()
                static File createTempFile(String prefix, String suffix)
                    // (특정) 디렉터리에 새로운 빈 파일을 만들어 반환한다. 이 메서드는 오직 임시 파일 작업을 위해 만들어졌으며, deleteOnExit()을 통해 자동으로 정리되어야 한다.
                    // prefix : 의미 있는 접두어, suffix : null이면 ".tmp"
            p
                +codeBtn('/Repositories/Eclipse/JavaSE/src/io/FileFilterExample.java', 'java') FileFilter 예
                +codeBtn('/Repositories/Eclipse/JavaSE/src/io/FilenameFilterExample.java', 'java') FilenameFilter 예
                +codeBtn('/Repositories/Eclipse/JavaSE/src/io/FileExample.java', 'java') File 예
            h3 FilePermission
            p 파일 및 디렉터리에 관한 권한을 표현하는 클래스.
                +codeBtn('/Repositories/Eclipse/JavaSE/src/io/FilePermissionExample.java', 'java')
            ul
                li "/*"로 끝나는 경로는 해당 디렉터리 내부 모든 파일 및 디렉터리를 가리킨다. "*"는 현재 디렉터리 내부.
                li "/-"로 끝나는 경로는 해당 디렉터리 내부 모든 파일 및 모든 서브디렉터리를 가리킨다. "-"는 현재 디렉터리 내부.
                li "&lt;&lt;ALL FILES>>"로 표현된 경로는 임의 파일과 대응한다.
                li 권한 리스트는 콤마로 구분한 문자열로 표현한다.
                p 가능한 키워드는 "read", "write", "execute"(Runtime.exec 메서드 호출 관련), "delete"(File.delete 메서드 호출 관련), "readlink"(java.nio.file.Files.readSymbolicLink 메서드와 관련)
                li 주의 : 임의 파일에 대한 권한은 보안상 위험하다. 기본적으로 코드가 포함된 디렉터리는 읽기가 가능하므로 굳이 권한을 부여할 필요 없다.
            +asCode('java').
                boolean implies(Permission p)
                    // 객체의 권한이 인자의 권한을 내포하는지 여부 반환
                PermissionCollection newPermissionCollection()
                    // 예. 컬렉션에 다음 두 가지 권한─("/tmp/-", "read"), ("/tmp/scratch/foo", "write")─들이 있을 때, 이에 대한 implies메서드에 권한 ("/tmp/scratch/foo", "read,write")을 넘겨준 결과는 true를 반환해야 한다.
            h3 RandomAccessFile
            p 읽기/쓰기 가능한 임의 접근 파일. 읽기/쓰기의 기준 위치 file pointer가 존재.
                br
                | 읽기로 예정된 바이트들을 모두 읽기 전에 EOF를 만나면 EOFException 발생.
            +asCode('java').
                RandomAccessFile(String name, String mode)
                    // mode : "r", "rw", "rws"(파일 내용 및 메타데이터 변경을 곧바로 반영), "rwd"(파일 내용 변경을 곧바로 반영)

                int read() // InputStream.read()와 동일

                long getFilePointer()
                void seek(long pos) // file pointer 설정

                long length()
                void setLength(long newLength)
                    // 기존 크기 > newLength && getFilePointer() > newLength
                    //     → 자르고, file pointer = newLength
                    // 기존 크기 &lt; newLength
                    //     → 확장. 확장한 영역의 데이터는 초기화되지 않는다.

    h1 java.lang
    div
        h2 Appendable
        p 유니코드 CharSequence 또는 char 값을 덧붙일 수 있는 객체를 표현한다.
        h2 AutoCloseable
        p 자동으로 자원을 해제하는 객체를 표현한다. try-with-resources 블록에 사용되면 close()가 자동으로 호출된다. IO 작업이 없는 것들을 try-with-resources 블록에 이용하는 것은 불필요한 일이다.
            +codeBtn('/Repositories/Eclipse/Basic/src/io/github/donggi/TryWithResources.java', 'java')
        h2 Cloneable
        p Object#clone()을 재정의했음을 나타내는 마커 인터페이스.
        h2 Comparable&lt;T>
        ol
            li 자연스러운 순서로 클래스의 모든 객체를 정렬할 수 있음을 표현.
            li 이를 구현한 클래스 객체들의 List, array는 Collections.sort, Arrays.sort로 각각 정렬할 수 있다.
            li 이를 구현한 클래스 객체들은 Comparator 정의 없이 SortedMap, SortedSet의 키로 이용할 수 있다.
            li null은 객체가 아니므로 equals(null)이 false를 리턴하는 것과 달리 compareTo(null)은 NullPointerException을 내보내는 것이 바람직하다.
            li 다음 성질을 만족하도록 구현함이 권장된다.
            +asCode('java') (e1.compareTo(e2) == 0) == e1.equals(e2)
        +asCode('java').
            int compareTo(T o) {
                return this - o;
                // o보다 앞서면(작으면) 음수, 같으면 0, 뒤면(크면) 양수 반환.
            }
        h2 Iterable&lt;T>
        p 이를 구현한 클래스 객체는 enhanced for statement의 순회 대상이 될 수 있다.
            +codeBtn('/Repositories/Eclipse/JavaSE/src/lang/IterableExample.java', 'java')
        +asCode('java').
            Iterator&lt;T> iterator()
                // 구현한 클래스 인스턴스를 반환하면 된다.
            default void forEach(Consumer&lt;? super T> action)
                // 순회하면서 action을 적용한다.
                // 기본 구현 : for(T t : this) action.accept(t);
            default Spliterator&lt;T> spliterator()
                // 기본 구현은 Sliterator의 모든 사항을 구현하지 않으므로 재정의하는 것이 더 좋은 성능을 보인다.
        h2 ProcessHandle
        ol
            li native process들에 대한 제어 제공. 프로세스 생애 모니터링, 자식 프로세스 나열, 프로세스 정보 얻기, 프로세스 종료 등.
                +codeBtn('/Repositories/Eclipse/JavaSE/src/lang/ProcessHandleExample.java', 'java')
            li 프로세스 ID는 OS가 할당한 것으로, 값의 범위는 OS에 의존적이다.
            li ProcessHandle 객체는 다음 팩터리 메서드로 반환된다.
            +asCode('java').
                current(), of(long), children(), descendants(), parent(), allProcesses()
                parent() // zombie 상태의 프로세스는 보통 parent가 없다.
            li SecurityManager의 RuntimePermission("manageProcess")만큼의 제어 권한을 갖는다.
            li ProcessHandle 객체들을 비교할 때는 equals, compareTo 메서드를 이용해야 한다.
        +asCode('java').
            ProcessHandle.Info info()

            boolean supportsNormalTermination()
                // destroy() 메서드가 정상적으로 프로세스를 종료하는지 여부. false면 프로세스를 강제로 즉시 종료함을 의미.
            CompletableFuture&lt;ProcessHandle> onExit()
                // onExit().get()을 호출하면 프로세스가 종료되는 것을 기다린다.
                // supportsNormalTermination()이 false일 경우 onExit()에 등록한 후처리들이 진행되지 않을 수 있음.

            boolean destroy()
                // 프로세스 종료에 시간이 걸릴 수 있으므로, isAlive()가 얼마간 true를 반환할 수 있다.
                // 성공적으로 프로세스를 종료하면 true, 아니면 false를 반환한다.
            boolean destroyForcibly() // 강제 종료

            long pid()
            boolean isAlive() // PID가 유효하면 alive로 간주
        div
            h3 ProcessHandle.Info
            +asCode('java').
                Optional&lt;String> command()            // 실행가능한 경로 반환
                Optional&lt;String> commandLine()        // command()와 arguments()의 결과를 공백으로 구분한 결과 반환
                Optional&lt;String[]> arguments()        // 프로세스의 인자 반환
                Optional&lt;Instant> startInstant()      // 프로세스의 시작 시각 반환
                Optional&lt;Duration> totalCpuDuration() // CPU 사용 시간 반환
                Optional&lt;String> user()               // 프로세스 유저 반환
        h2 Readable
        p Readable은 문자들에 대한 소스다.
            +codeBtn('/Repositories/Eclipse/JavaSE/src/lang/ReadableExample.java', 'java')
        +asCode('java').
            int read(CharBuffer cb)
                // 문자들을 그대로 cb에 put()을 통해 저장한다. cb에 대한 어떠한 사전처리도 없다. 저장한 char 개수를 반환하며, 소스의 끝이면 -1을 반환한다.
        h2 Runnable
        p Runnable은 한 스레드로서 실행되도록 구현돼야 한다. Thread의 run()만을 재정의할 때 사용한다.
            +codeBtn('/Repositories/Eclipse/JavaSE/src/lang/RunnableExample.java', 'java')
        h2 SecurityManager
        ol
            li 보안 정책을 구현할 수 있는 클래스. 전형적인 확인 절차는 아래와 같다.
            +asCode('java').
                SecurityManager security = System.getSecurityManager();
                if (security != null) {
                    security.checkXXX(argument, . . . );
                }
        +asCode('java').
            Object getSecurityContext()           // 현재 실행 환경을 캡슐화한 객체 반환.
            ThreadGroup getThreadGroup()          // 새로운 스레드를 생성할 수 있는 스레드그룹 반환
            void checkPermission(Permission perm) // checkXXX()
        h2 Math, StrictMath
        +asCode('java').
            static double IEEEremainder(double f1, double f2)

            static double rint(double d) // rount to even

            // 오버플로우되면 예외
            addExact, substractExact, multiplyExact, incrementExact, decrementExact, negateExact, toIntExact

            static long multiplyFull(int x, int y)
            static long multiplyHigh(long x, long y) // 상위 64개 비트를 반환

            floorDiv(x, y)
                // x/y에 가장 가까운 최대 정수를 반환
                // Integer.MIN_VALUE, Long.MIN_VALUE를 -1로 나누는 경우는 오버플로우가 발생하고, 각각 Integer.MIN_VALUE, Long.MIN_VALUE를 반환한다.
            floorMod(x, y)
                // x - (floorDiv(x, y) * y)를 반환한다. 부호는 y와 같다.
            fma(a, b, c)
                // a * b + c에 가장 가까운 float, double을 반환
        h2 공유 변수 관련
        div
            h3 ClassValue&lt;T>
            p 임의 타입에 대하여, 필요할 때에 연산된 값을 가져오도록 지원. 해당 값은 해당 타입에 대해 일관성을 갖는다.
            +asCode('java').
                protected abstract T computeValue(Class&lt;?> type)
                    // type에 대하여, 최초 get 메서드 호출 시 한 번만 호출되며, 이후 remove 메서드 호출이 없으면 더 이상 불리지 않는다.
                T get(Class&lt;?> type)
                    // 값이 계산되지 않은 상태에서 여러 스레드들이 경합을 벌일 경우, 임의 스레드의 결과값을 모두에 반환한다.
                void remove(Class&lt;?> type)
                    // 다음 get 호출 시 값을 새로 계산하도록 한다
            h3 ThreadLocal&lt;T>
            p 스레드 단위의 지역 변수를 제공한다. 호출 지점과 관계없이 한 스레드 내부에서 변수를 공유한다.
            +asCode('java').
                protected T initialValue()
                    // 초기값이 설정되지 않은 상태에서 최초 get() 호출에 의해 불린다. remove() 호출 후의 get() 요청으로 다시 불린다.
                static &lt;S> ThreadLocal&lt;S> withInitial(Supplier&lt;? extends S> supplier)
                    // supplier로 초기값이 설정되는 ThreadLocal 반환.
            h3 InheritableThreadLocal&lt;T>
            p ThreadLocal에 상속성을 부여. 자식 스레드는 부모의 thread-local 변수들을 모두 상속받고 시작한다. childValue 메서드를 재정의함으로써 부모의 값과 다르게 설정할 수도 있다.

        h2 타입 관련
        div
            h3 CharSequence
            p 일련의 char 값들을 표현한다. equals(), hashCode()에 대한 규약이 없어, 두 CharSequence 객체를 비교하는 결과는 정의되어 있지 않으며, 따라서 set이나 map의 키로 이용하기에 부적절하다.
                +codeBtn('/Repositories/Eclipse/JavaSE/src/lang/CharSequenceExample.java', 'java')
            +asCode('java').
                static int compare(CharSequence cs1, CharSequence cs2)
                    // 두 CharSequence를 사전순으로 비교한다.

                default IntStream chars()
                    // char들을 int로 0패딩하여 스트림 생성. 두 char로 쪼개진 유니코드 보충 평면의 문자를 하나로 합치진 않는다.
                default IntStream codePoints()
                    // 유니코드 값들을 스트림으로 생성. 보충 평면의 문자는 Character.toCodePoint 메서드를 통해 하나의 int 값으로 형성.
            h3 Boolean
            p 원시 타입 boolean의 wrapper 클래스. 람다 활용을 위한 static 메서드들을 제공한다.
            +asCode('java').
                static boolean parseBoolean(String s)
                    // s가 null이 아니고 대소문자 구분없이 "true"와 일치하면 true 반환.
                static Boolean valueOf(String s)
                    // == valueOf(parseBoolean(s))

                static boolean getBoolean(String name)
                    // name에 해당하는 system property가 존재하고, 대소문자 구분없이 "true"와 일치하면 true 반환

                int compareTo(Boolean b)
                    // TRUE.compareTo(FALSE) > 0, FALSE.compareTo(TRUE) &lt; 0
            h3 Number
            p 수에 관한 최상위 추상 wrapper 클래스
            h3 Byte
            p 기본 타입 byte에 대한 wrapper 클래스. 람다 활용을 위한 static 메서드들을 제공한다.
            +asCode('java').
                static byte parseByte(String s, int radix)
                    // 예외 : s가 null이거나 길이가 0일 때. s에 radix진수가 아닌 문자가 포함될 때(단, s가 2글자 이상일 때 첫 '-', '+'는 가능). radix가 [Character.MIN_RADIX, Character.MAX_RADIX] 범위를 벗어날 때, 값이 byte를 벗어날 때.
                static Byte valueOf(String s, int radix)
                static Byte decode(String nm)
                    // 다음 문법으로 표현된 10진수, 16진수, 8진수를 parseByte()를 이용해 디코딩한다. 공백을 허용하지 않는다.
                    //     (Sign?)(10진수)
                    //     (Sign?)(0x | 0X | #)(16진수)
                    //     (Sign?)0(8진수)
                    //     Sign: '-', '+'

                static int compare(byte x, byte y)
                static int compareUnsigned(byte x, byte y)
                static int toUnsignedInt(byte x)
                static long toUnsignedLong(byte x)
            h3 Character
            ol
                li 기본타입 char에 대한 wrapper 클래스. 추가적으로 문자 집합(소문자, 숫자 등) 정의, 변환 기능을 갖는다.
                li 유니코드 표준 8.0.0을 따른다.(JDK 9 기준)
                ul
                    li 16비트 고정폭으로 값을 표현하며, 유효한 범위는 U+0000 부터 U+10FFFF까지(= Unicode scalar value).
                    ol
                        li [U+0000, U+FFFF] == 기본 문자 평면(BMP; Basic Multilingual Plane)
                        li (U+FFFF, ~) == 보충 문자 평면(supplementary characters)
                    li 자바 플랫폼은 보충 평면의 문자들은 2개의 char의 쌍으로 표현한다.
                    li 하위 21개 비트를 이용하여 int 하나로 모든 유니코드 code point를 표현할 수 있다.
                li int를 받는 메서드는 모든 유니코드를 처리할 수 있지만, char만을 받는 메서드는 보충 평면 문자를 처리하지 못한다.
                +codeBtn('/Repositories/Eclipse/JavaSE/src/lang/CharacterExample.java', 'java')
            +asCode('java').
                static final char MIN_HIGH_SURROGATE          // \uD800
                static final char MAX_HIGH_SURROGATE          // \uDBFF
                static final char MIN_LOW_SURROGATE           // \uDC00
                static final char MAX_LOW_SURROGATE           // \uDFFF
                static final int MIN_SUPPLEMENTARY_CODE_POINT // U+10000
                static final int MIN_CODE_POINT               // U+0000
                static final int MAX_CODE_POINT               // U+10FFFF

                static String getName(int codePoint)
                    // 이름 반환 : Character.UnicodeBlock.of(codePoint).toString().replace('_', ' ') + " " + Integer.toHexString(codePoint).toUpperCase(Locale.ROOT);
                    // 정의되어 있지 않으면 null 반환
                static int codePointOf(String name)
                    // 정의되어 있지 않으면 예외

                static boolean isValidCodePoint(int codePoint)
                static int getType(int codePoint)
                static byte getDirectionality(char ch)
                    // 문자 표시 순서를 반환한다. DIRECTIONALITY_UNDEFINED, DIRECTIONALITY_LEFT_TO_RIGHT 등
                static boolean isMirrored(char ch)
                    // 좌우 대칭되는 문자가 존재하는지 여부

                static boolean isDigit(char ch)
                    // getType(ch) == DECIMAL_DIGIT_NUMBER
                static boolean isLetter(char ch)
                    // getType(ch) == *_LETTER, isLetterOrDigit
                static boolean isAlphabetic(int codePoint)
                    // UPPERCASE_LETTER, LOWERCASE_LETTER, TITLECASE_LETTER, MODIFIER_LETTER, OTHER_LETTER, LETTER_NUMBER, 및 기타 알파벳 문자인지 여부
                static boolean isSpaceChar(char ch)
                    // getType(ch) == *_SEPARATOR
                static boolean isWhitespace(char ch)
                    // 공백 문자 '\t', '\n', 'u000B', '\f', '\r', '\u001C', '\u001D', '\u001E', '\u001F'
                    // 단, non-breaking space('\u00A0', '\u2007', '\u202F') 제외

                static int charCount(int codePoint)
                    // 표현에 필요한 char 수(1 or 2)
                static char[] toChars(int codePoint)
                static String toString(int codePoint)

                static char reverseBytes(char ch)
                static int toCodePoint(char high, char low)
                static int codePointAt(CharSequence seq, int index)
                    // + codePointBefore, highSurrogate, lowSurrogate
                static int codePointCount(CharSequence seq, int beginIndex, int endIndex)
                    // [beginIndex, endIndex) 사이의 유니코드 문자 수 반환
                static int offsetByCodePoints(CharSequence seq, int index, int codePointOffset)
                    // 지정된 index로부터 offset 개수만큼 유니코드를 건너뛴 위치. +일 경우 index 포함, -인 경우 index 미포함(예시 코드 참고)

                static int toLowerCase(int codePoint)
                    // + toUpperCase, toTitleCase
                    // isLowerCase(toLowerCase(x))가 항상 true는 아니다.

                static int digit(int codePoint, int radix)
                static char forDigit(int digit, int radix)
                static int getNumericValue(int codePoint)
            div
                h4 Character.Subset
                p 이 클래스의 객체는 유니코드 문자 집합을 표현한다. Character 클래스 내부에서 정의한 문자 집합은 Character.UnicodeBlock뿐이다.
                +asCode('java') final String toString() // name 반환
                h4 Character.UnicodeBlock
                p 유니코드 문자 블록. 각 문자들은 최대 하나의 유니코드 블록에 포함된다.
                +asCode('java').
                    static Character.UnicodeBlock ARABIC, GREEK, HANGUL // 등

                    static Character.UnicodeBlock of(char c)            // c가 속한 유니코드 블록 반환
                    static final Character.UnicodeBlock forName(String blockName)
                        // 블록 이름이 변경된 경우, 변경 전/후 이름 둘 다 사용할 수 있다.
                h4 Character.UnicodeScript
                p 유니코드 표준 스크립트 이름 정의를 표현. 모든 문자는 하나의 스크립트(각 언어|INHERITED|COMMON|UNKNOWN)에 할당된다.
                +asCode('java').
                    ARABIC, GREEK, HANGUL // 등

                    static Character.UnicodeScript of(int codePoint)
            h3 Double
            p 기본 타입 double에 대한 wrapper 클래스. 람다 활용을 위한 static 메서드들을 제공한다.
            +asCode('java').
                public static final double POSITIVE_INFINITY // Double.longBitsToDouble(0x7ff0000000000000L)
                public static final double NEGATIVE_INFINITY // Double.longBitsToDouble(0xfff0000000000000L)
                public static final double NaN               // Double.longBitsToDouble(0x7ff8000000000000L)
                public static final double MAX_VALUE         // Double.longBitsToDouble(0x7fefffffffffffffL), 0x1.fffffffffffffP+1023
                public static final double MIN_NORMAL        // Double.longBitsToDouble(0x0010000000000000L), 0x1.0p-1022
                    // 진수가 1 이상인 가장 작은 양수 표현.
                public static final double MIN_VALUE         // Double.longBitsToDouble(0x1L), 0x0.0000000000001P-1022
                    // 가장 작은 양수 표현

                static Double valueOf(String s) // + parseDouble
                static String toHexString(double d)

                static long doubleToLongBits(double value)
                    // double 표현 그대로 long으로 전환. 63번 비트는 부호, 62-52번 비트는 지수, 51-0번 비트는 진수
                static long doubleToRawLongBits(double value)
                    // NaN의 경우 각각의 NaN에 대응하는 값으로 반환.
                static double longBitsToDouble(long bits)
                    // NaN : [0x7ff0000000000001L, 0x7fffffffffffffffL] or [0xfff0000000000001L, 0xffffffffffffffffL]

                int compareTo(Double anotherDouble)
                    // Double.NaN > Double.POSITIVE_INFINITY
                    // 0.0d > -0.0d
            h3 Integer
            p 기본 타입 int에 대한 wrapper 클래스. 람다 활용을 위한 static 메서드들을 제공한다.
            +asCode('java').
                static String toString(int i, int radix)
                    // + toUnsignedString, toBinaryString, toOctalString, toHexString
                    // radix in [Character.MIN_RADIX, Character.MAX_RADIX]
                static int parseInt(CharSequence s, int beginIndex, int endIndex, int radix)
                    // [beginIndex, endIndex)
                    // + parseUnsignedInt, valueOf
                    // 파싱 중 CharSequence 변경에 대한 조치를 하지 않음
                static Integer decode(String nm) // Byte#decode 참고

                static Integer getInteger(String nm, int val)
                    // 시스템 속성값을 decode 메서드로 변환하여 반환.
                    // nm : property name, val : 기본값

                // unsigned 연산
                static int compareUnsigned(int x, int y)
                static long toUnsignedLong(int x)
                static int divideUnsigned(int dividend, int divisor)
                static int remainderUnsigned(int dividend, int divisor)

                // bit 연산
                static int highestOneBit(int i)            // + lowestOneBit
                static int numberOfLeadingZeros(int i)     // + numberOfTrailingZeros
                static int bitCount(int i)
                static int rotateLeft(int i, int distance) // + rotateRight
                static int reverse(int i)
                static int reverseBytes(int i)             // 바이트 단위로 뒤집기
            h3 String
            ol
                li 유니코드 보충 평면 문자는 surrogate pairs로써 2자리를 차지한다.
                li 로캐일을 고려한 문자열 비교는 Collator 클래스를 이용.
                li 람다 활용을 위한 static 메서드들을 제공한다
            +asCode('java').
                static final Comparator&lt;String> CASE_INSENSITIVE_ORDER
                    // 대소문자 구분없는 비교자. 직렬화 가능.

                static String format(String format, Object... args)
                static String valueOf(Object obj) : obj.toString()

                boolean isEmpty() // 길이가 0인지 여부
                boolean isBlank() // 비거나 공백 문자로만 이루어졌는지 여부

                byte[] getBytes(Charset charset)
                    // 문자셋이 지정되지 않은 경우, 플랫폼 기본 문자셋을 이용한다. 기본 문자셋을 변경하려면 JVM 옵션을 조정하면 된다.

                // 비교
                boolean contentEquals(StringBuffer sb)
                boolean equalsIgnoreCase(String anotherString)
                int compareToIgnoreCase(String str)
                boolean regionMatches(int tooffset, String other, int ooffset, int len)
                    // 부분 문자열이 일치하는지 여부 반환. t(his's)offset, o(ther's)offset
                boolean startsWith(String prefix, int toffset)
                boolean endsWith(String suffix)

                // 검색
                int indexOf(String str, int fromIndex) // + lastIndexOf
                boolean matches(String regex)          // == Pattern.matches(regex, str)
                boolean contains(CharSequence s)
                String replaceAll(String regex, String replacement) // + replaceFirst
                String replace(CharSequence target, CharSequence replacement)

                String[] split(String regex, int limit)
                    // limit이 음수인 경우, 제한 없이 분리. 0인 경우 빈 문자열로 끝나지 않음.
                static String join(CharSequence delimiter, CharSequence... elements)

                String trim()             // 시작과 끝의 공백(&lt;= U+0020) 제거
                String strip()            // + stripLeading, stripTrailing. 공백 제거
                Stream&lt;String> lines() // 줄 끝(\n, \r, \r\n) 기준으로 분리
                String indent(int n)      // 각 줄이 n개의 공백으로 시작하도록 조정하고, 줄 끝을 \n로 정규화한다. n이 음수인 경우, 최대 n개의 앞선 공백을 제거한다.

                &lt;R> R transform(Function&lt;? super String, ? extends R> f)
                String repeat(int count)
            h3 StringBuffer
            p 스레드-안전한 변경 가능한 문자열.
            +asCode('java').
                void trimToSize()
                    // 버퍼 크기를 줄여 문자열 크기에 맞춘다
                void setLength(int newLength)
                    // 새로운 크기의 문자열에 기존 문자열을 복사. 남는 부분은 '\u0000'(null)로 채워진다.
                void ensureCapacity(int minimumCapacity)
                StringBuffer reverse()
            h3 StringBuilder
            p StringBuffer의 비동기화 버전.

        h2 클래스 관련
        +codeBtn('/Repositories/Eclipse/JavaSE/src/lang/ClassExample.java', 'java')
        div
            h3 Class&lt;T>
            div
                h4 Nest
                p Nest는 같은 런타임 패키지 안의, private member에 접근 가능한 클래스와 인터페이스의 집합.
                    | Nest에 속한 클래스, 인터페이스를 nestmate라 부르고, 하나의 nest에서 하나의 nestmate는 host 역할을 하고 나머지 nestmate 목록을 갖는다.
                +asCode('java').
                    Class&lt;?> getNestHost()
                    Class&lt;?>[] getNestMembers()
            +asCode('java').
                // ClassLoader 관련
                ClassLoader getClassLoader()
                InputStream getResourceAsStream(String name)
                URL getResource(String name)
                static Class&lt;?> forName(String className)
                    // 로드된 클래스는 초기화가 진행된다.
                static Class&lt;?> forName(Module module, String name)
                    // 주어진 모듈에서 binary name을 가진 클래스를 반환한다.
                    // 클래스를 초기화하지 않으며, 클래스를 찾을 수 없으면 null을 반환한다.
                    // 참고 : https://docs.oracle.com/javase/9/docs/api/java/lang/ClassLoader.html#name

                // 타입 관련
                T cast(Object obj)
                    // obj를 호출한 Class 객체와 같은 타입으로 변환
                boolean isInstance(Object obj)
                    // instanceof 연산자의 동적인 형태. 원시타입 클래스 객체는 false만 반환한다.
                boolean isAssignableFrom(Class&lt;?> cls)
                    // cls 타입 객체를 현재 클래스의 참조 변수로 참조할 수 있는지 여부 반환.
                boolean isInterface()
                    // + isArray, isPrimitive, isAnnotation, isEnum, isAnonymousClass, isLocalClass, isMemberClass
                    // wrapper 클래스는 원시타입이 아님에 유의 : Integer.class != Integer.TYPE, Integer.TYPE == int.class
                boolean isSynthetic()
                    // Synthetic class : 명시적/암시적으로 생성자가 정의되지 않은 채 생성된 클래스
                boolean isNestmateOf(Class&lt;?> c)

                // 클래스 이름 관련
                String toGenericString()
                    // 접근한정자 및 타입 포함하여 반환
                String getName()
                    // 배열의 경우 차원마다 '['를 붙이며, 배열 원소 타입을 아래와 같이 인코딩한다.
                    // boolean : Z, byte : B, char : C, class or interface : L{className};, double : D, float : F, int : I, long : J, short : S
                String getSimpleName()
                    // 익명 클래스면 빈 문자열 반환
                String getCanonicalName()
                    // Local class, 익명 클래스, 또는 이들의 배열은 canonical name이 없어 null을 반환한다.

                // 리플렉션 관련
                Module getModule()
                Package getPackage()
                String getPackageName()
                    // 익명 패키지면 빈 문자열 반환. 배열 클래스의 경우 원소 타입이 속한 패키지 이름 반환. 원시 타입 또는 void의 경우 "java.lang" 반환.
                Class&lt;?>[] getClasses()
                    // public 멤버로 정의된 클래스, 인터페이스 Class 객체 배열 반환.
                    // + getFields, getMethods, getConstructors
                    // + getField(String name), getMethod, getConstructor
                Class&lt;?>[] getDeclaredClasses() + getDeclaredFields, getDeclaredMethods, getDeclaredConstructors
                    // 상속된 것을 제외하고, 호출하는 클래스 내부에 정의된 public, protected, default, private 클래스와 인터페이스들을 반환한다.
                    // + getDeclaredField, getDeclaredMethod, getDeclaredConstructor
                T[] getEnumConstants()

                Class&lt;?> getComponentType()
                    // 배열 원소 타입 클래스 객체 반환. 배열이 아닌 경우 null 반환
                Method getEnclosingMethod()
                    // 이 클래스가 메서드 내부에서 정의된 경우, 해당 메서드를 반환한다.
                    // + getEnclosingConstructor, getDeclaringClass, getEnclosingClass
                boolean isAnnotationPresent(Class&lt;? extends Annotation> annotationClass)
            h3 ClassLoader
            ol
                li 전형적으로, 로드할 클래스 이름을 파일명으로 변환하여 ".class"파일을 읽어온다.
                li 모든 Class 객체들은 ClassLoader에 대한 참조를 갖고 있다.
                li 배열의 경우 런타임에 Class 객체가 생성되며, 이때 Class.getClassLoader()는 원소의 것과 동일하다.
                li 클래스를 로드하는 것 외에, 자원(.class 파일, 구성 파일, 이미지 등)을 배치하는 책임도 진다.
                li Delegation model : ClassLoader 객체들은 각기 parent class loader를 갖는다. 클래스나 자원을 찾기 전에 parent를 먼저 조사하게 된다.
                li 동시 로딩을 지원하는 parallel capable class loader들은 클래스 초기화 시 registerAsParallelCapable()를 통해 등록해야 한다. ClassLoader 클래스는 기본적으로 등록되나, 서브클래스들도 자신을 등록해야 한다.
                li 계층구조가 약한 delegation model의 경우 클래스 로더들이 parallel capable하지 않으면 deadlock 발생 가능성이 있다.
                li Run-time Built-in Class Loaders
                ul
                    li Bootstrap class loader : JVM 내장 클래스 로더. 보통 null이며, parent가 없다.
                    li Platform class loader : Java SE APIs, JDK-specific run-time classes
                    li System class loader, a.k.a Application class loader : Used to define classes on the application class path, module path, and JDK-specific tools
                li 파일이 아닌 네트워크 같은 다른 소스로부터 클래스를 로드할 경우, defineClass()를 통해 Class 객체를 얻고 Constructor.newInstance()를 통해 클래스 객체를 생성하면 된다.
                li 네트워크 클래스 로더는 findClass(), loadClassData() 메서드를 반드시 작성해야 한다.
                +asCode('java').
                    public Class findClass(String name) {
                        byte[] b = loadClassData(name);
                        return defineClass(name, b, 0, b.length);
                    }
                    private byte[] loadClassData(String name) { /**/ }
                li Binary names
                p ClassLoader 메서드에 전달하는 String 타입 클래스 이름은 아래와 같은 형식을 따라야 한다.
                    br
                    | "java.lang.String", "javax.swing.JSpinner$DefaultEditor", "java.security.KeyStore$Builder$FileBuilder$1", "java.net.URLClassLoader$3$1"
            +asCode('java').
                protected ClassLoader(String name, ClassLoader parent)
                    // parent가 null일 경우, 해당 클래스 로더가 모든 플랫폼 클래스를 볼 수 있다는 보장은 없다.
                    // name : class loader's name; or null if not named
                String getName()
                    // 클래스 로더 이름 반환. 없으면 null

                Class&lt;?> loadClass(String name) // == loadClass(name, false)
                protected Class&lt;?> loadClass(String name, boolean resolve)
                     // 1. findLoadedClass(String)로 이미 로드됐나 확인
                     // 없으면 : parent 혹은 VM의 클래스 로더의 loadClass를 호출
                     // 없으면 : findClass(String) 호출
                     // 2. 위를 통해 클래스를 찾았고, resolve가 true면 resolveClass(Class) 호출.
                     // 3. ClassLoader의 서브클래스들은 이 메서드가 아닌 findClass(String)을 재정의하면 된다.
                     // 4. 재정의되지 않은 이상, getClassLoadingLock()을 통해 메서드는 동기화된다.
                protected final void resolveClass(Class&lt;?> c) : 클래스를 링크한다.

                static ClassLoader getPlatformClassLoader()
                static ClassLoader getSystemClassLoader()
                    // 시스템 클래스 로더를 반환하며, 이는 새롭게 정의되는 클래스 로더들의 default delegation parent다.

                // 리소스 관련
                URL getResource(String name)
                Enumeration&lt;URL> getResources(String name)
                Stream&lt;URL> resources(String name)
                static URL getSystemResource(String name)
                static Enumeration&lt;URL> getSystemResources(String name)
                InputStream getResourceAsStream(String name)
                static InputStream getSystemResourceAsStream(String name)
            h3 Module
            p 이름 있는 모듈에 속하지 않은 모든 타입은 각 클래스 로더의 익명 모듈에 속한다.
            +asCode('java').
                InputStream getResourceAsStream(String name)
                    // 해당 모듈의 리소스를 스트림으로 반환. name은 '/'으로 구분된 경로

        h2 프로그램 실행 단위
        div
            h3 Thread
            ol
                li 스레드는 실행 우선순위를 가지며, 그 초깃값은 스레드를 생성한 스레드의 것과 같다. 데몬 스레드로부터 생성된 스레드도 데몬 스레드다.
                li JVM이 시작되면 하나의 non-daemon 스레드가 존재하며, 전형적으로 main 메서드를 호출한다. JVM은 다음의 상황 중 하나라도 일어나기 전까지 실행을 계속한다.
                ul
                    li Runtime 클래스의 exit 메서드 호출, 또는 SecurityManager의 exit 허용
                    li 모든 데몬 스레드가 아닌 스레드들의 종료 : run 메서드의 반환이든 예외 발생이든 관계없이
            +asCode('java').
                public static final int MIN_PRIORITY
                public static final int NORM_PRIORITY
                public static final int MAX_PRIORITY

                final void setDaemon(boolean on)
                    // 스레드를 daemon 또는 user 스레드로 변경. 스레드가 시작되기 전에 호출돼야한다.
                    // user 스레드가 하나도 없으면 프로그램은 종료된다.

                void start() // JVM이 run() 호출. 스레드를 재시작하는 것은 허용되지 않는다.
                void run()   // 관련된 Runnable의 run() 호출
                void interrupt()
                    // 1. checkAccess()가 호출된다. wait, join, sleep으로 블록된 경우 인터럽트 상태가 초기화되고, InterruptedException 발생.
                    // 2. InterruptibleChannel로 I/O 작업 중 블록된 경우, 인터럽트 상태가 설정되고 채널은 닫힌다. ClosedByInterruptException 발생.
                    // 3. Selector에서 블록된 경우, 인터럽트 상태가 설정되고 selection 연산에서 즉시 반환된다. 그 외의 경우 인터럽트 상태가 설정된다.

                static Thread currentThread()
                ClassLoader getContextClassLoader()

                long             getId()
                Thread.State     getState()
                static boolean   interrupted()     // 현재 스레드가 인터럽드됐는지 여부. 스레드의 인터럽트 상태는 이 메서드로 인해 초기화된다.
                boolean          isInterrupted()   // 스레드의 인터럽트 상태를 변경하지 않고 반환한다.
                final boolean    isAlive()
                final void       join(long millis) // 이 스레드가 중지되기까지 일시 대기. 0이면 무기한 대기. 지정 되지 않은 경우 0

                static void dumpStack()
                    // 현재 스레드의 스택 추적을 표준 에러 출력
                final void checkAccess()
                    // 현재 스레드가 이 스레드를 변경할 수 없으면 SecurityException 발생
                static boolean holdsLock(Object obj)
                    // 특정 객체를 lock으로 갖는지 확인

                static void setDefaultUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)
                void        setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)
            div
                h4 static void onSpinWait()
                p Spin-wait 루프에서 조건이 충족되어 루프를 벗어나기를 기다린다.
                +asCode('java').
                    class EventHandler {
                        volatile boolean eventNotificationNotReceived;
                        void waitForEventAndHandleIt() {
                            while ( eventNotificationNotReceived ) {
                                java.lang.Thread.onSpinWait();
                            }
                            readAndProcessEvent();
                        }

                        void readAndProcessEvent() {
                            // Read event from some source and process it
                             . . .
                        }
                    }
                h4 Thread.State
                p NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED
                h4 Thread.UncaughtExceptionHandler
                ol
                    li 처리되지 않은 예외로 인해 스레드가 종료되는 상황을 대비한 핸들러. 그러한 상황에서, 먼저 Thread.getUncaughtExceptionHandler()를 통해 얻은 핸들러에 해당 스레드와 예외 객체를 전달한다.
                    li 만일 스레드에 핸드러가 설정되지 않은 경우, ThreadGroup의 핸들러를 이용하며, ThreadGroup에도 없는 경우 default 핸들러를 이용할 수 있다.

            h3 ThreadGroup
            +asCode('java').
                final void setDaemon(boolean daemon)
                    // 데몬 스레드 그룹은 마지막 스레드나 스레드 그룹이 파괴되면 자동으로 파괴된다.

                int activeCount()
                int enumerate(...)

                final void interrupt() // 그룹의 모든 스레드에 인터럽트
                final void destroy()   // 그룹과 하위 모든 그룹을 파괴

            h3 Process
            p ProcessBuilder.start, Runtime.exec으로 시작된 native process들에 대한 제어 제공.
            +asCode('java').
                abstract OutputStream getOutputStream()
                    // + getInputStream, getErrorStream

                abstract int waitFor()
                    // 현재 스레드가 이 프로세스의 종료를 기다린다. 프로세스의 종료 값을 반환.
                boolean waitFor(long timeout, TimeUnit unit)
                    // 시간 내에 프로세스가 종료되었다면 true 반환

                abstract int exitValue()
                abstract void destroy()   // 정상 종료.
                Process destroyForcibly() // 강제, 즉시 종료.
                boolean isAlive()

                long pid()
                boolean supportsNormalTermination()
                CompletableFuture&lt;Process> onExit()
                ProcessHandle toHandle()
                ProcessHandle.Info info()
                Stream&lt;ProcessHandle> children()
                Stream&lt;ProcessHandle> descendants()

            h3 ProcessBuilder
            p 이 클래스는 스레드-안전하지 않다.
            +asCode('java').
                ProcessBuilder command(String... command)
                ProcessBuilder directory(File directory)
                ProcessBuilder redirectInput(ProcessBuilder.Redirect source)
                    // + redirectOutput, redirectError
                ProcessBuilder inheritIO()
                ProcessBuilder redirectErrorStream(boolean redirectErrorStream)
                    // true면 서브프로세스들의 에러 출력이 표준 출력으로 나온다.

                Process start()

                static List&lt;Process> startPipeline(List&lt;ProcessBuilder> builders)
                    // 프로세스들의 표준 출력을 다음 프로세스의 표준 입력으로 연결한다.
            div
                h4 abstract static class ProcessBuilder.Redirect
                p 서브프로세스의 입력 소스 또는 출력 방향을 표현한다.
                +asCode('java').
                    public static final ProcessBuilder.Redirect PIPE    // 현재 프로세스와 파이프로 연결
                    public static final ProcessBuilder.Redirect INHERIT // 현재 프로세스의 것과 동일
                    public static final ProcessBuilder.Redirect DISCARD // 출력 버림

                    static ProcessBuilder.Redirect from(File file)
                    static ProcessBuilder.Redirect to(File file) // file의 이전 내용은 새로운 쓰기 작업에 의해 버려진다.
                    static ProcessBuilder.Redirect appendTo(File file)
                div
                    h5 ProcessBuilder.Redirect.Type
                    +asCode('java').
                        APPEND, // Redirect.appendTo(File)
                        INHERIT,
                        PIPE,
                        READ, // Redirect.from(File)
                        WRITE // Redirect.to(File)

            h3 Runtime
            p 모든 Java 애플리케이션은 하나의 Runtime 인스턴스를 가진다.
            +asCode('java').
                static Runtime getRuntime()

                void exit(int status)
                    // 현재 실행중인 JVM을 종료
                void addShutdownHook(Thread hook)
                    // + removeShutdownHook
                    // JVM이 종료 절차에 진입하면 등록된 모든 hook를 실행
                void halt(int status)
                    // 강제종료
                Process exec(String[] cmdarray, String[] envp, File dir)

                int availableProcessors()
                long freeMemory()
                    // + totalMemory, maxMemory
                void gc()
                void runFinalization()
                    // 소멸 대기중인 모든 객체 소멸

            h3 System
            +asCode('java').
                public static final InputStream in // + out, err
                static void setIn(InputStream in)  // + setOut, setErr

                static long currentTimeMillis() // + nanoTime
                static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)
                static int identityHashCode(Object x)

                static String lineSeparator()
                static void setProperties(Properties props) // getProperties
                static String setProperty(String key, String value)
                static String clearProperty(String key)
                static String getenv(String name) // 환경변수
                static System.Logger getLogger(String name)
                static void exit(int status)
            div
                h4 System.Logger
                +asCode('java').
                    String getName()
                    boolean isLoggable(System.Logger.Level level)
                    default void log(System.Logger.Level level, String msg)
                div
                    h5 System.Logger.Level
                    +asCode('java') ALL(Integer.MIN_VALUE), TRACE(400), DEBUG(500), INFO(800), WARNING(900), ERROR(1000), OFF(Integer.MAX_VALUE)

                h4 System.LoggerFinder
                ul
                    li 로거의 생성, 관리, 구성에 관한 서비스 제공.
                    li 기본 구현 : java.logging 모듈이 있는 경우 java.util.logging이용. 없으면 INFO 수준으로 표준 에러 출력

            h3 StackWalker
            p 현재 스레드의 StackFrame에 대한 스트림을 열고 특정 작업을 수행한다. 스트림은 실행 지점인 맨 위 frame부터 아래로 내려가면서 작업한다.
            +asCode('java').
                static StackWalker getInstance(...)
                    // 기본 설정 : 숨겨진 프레임 생략. 클래스 정보 미포함.

                &lt;T> T walk(Function&lt;? super Stream&lt;StackWalker.StackFrame>, ?
                    // 예. 현재 스레드의 상위 10개 스택 프레임 가져오기.
                    StackWalker.getInstance().walk(s -> s.limit(10).collect(Collectors.toList()));
                void forEach(Consumer&lt; super StackWalker.StackFrame> action)

                Class&lt;&?> getCallerClass()
                    // 이 메서드를 호출하는 호출자의 클래스 객체를 반환.
                    // Util#getResourceBundle 메서드는 이 메서드를 통해 얻은 호출자의 클래스로부터 클래스 로더를 얻고, 클래스 로더를 통해 리소스를 로드한다.
            div
                h4 StackWalker.Option
                +asCode('java').
                    RETAIN_CLASS_REFERENCE // StackFrame에 클래스 정보 유지
                    SHOW_HIDDEN_FRAMES     // 숨겨진 프레임 표시.
                    SHOW_REFLECT_FRAMES    // reflection 프레임 표시

                h4 StackWalker.StackFrame
                p 각 StackFrame 객체는 StackWalker로부터 반환된, 메서드 호출을 표현한다.
                +asCode('java').
                    String            getMethodName()       // 메서드 이름 반환.
                    String            getClassName()        // 메서드가 정의된 클래스의 binary name 반환
                    Class&lt;?>       getDeclaringClass()   // 메서드가 정의된 클래스 객체 반환. Option.RETAIN_CLASS_REFERENCE 설정 필요
                    StackTraceElement toStackTraceElement() // 프레임에 관한 StackTraceElement 반환.

            h3 StackTraceElement
            +asCode('java').
                String  getFileName()
                int     getLineNumber()
                String  getMethodName()
                String  getClassName()
                String  getClassLoaderName()
                String  getModuleName()

    h1 java.lang.annotation
    div
        h2 Annotation
        p 이 인터페이스를 구현하는 것으로 새로운 애너테이션을 정의할 순 없다.

        h2 ElementType
        p 애너테이션이 적용되는 요소를 표현한다.
        +asCode('java') TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VALIABLE, ANNOTATION_TYPE, PACKAGE, TYPE_PARAMETER, MODULE

        h2 RetentionPolicy
        p 애너테이션 유지 정책.
        +asCode('java').
            SOURCE  // 컴파일러가 제거
            CLASS   // 컴파일러가 클래스 파일에 기록(default)
            RUNTIME // 클래스 파일에 기록하고 JVM 런타임에도 유지. 따라서 리플렉션 가능.

        h2 @Documented @Retention(RUNTIME) @Target(ANNOTATION_TYPE) @interface Documented
        p @Documented가 다른 애너테이션 타입 A에 존재하면, @A로 꾸며진 요소의 공개적인 서명으로 인식하여 JavaDoc에 포함된다.

        h2 @Documented @Retention(RUNTIME) @Target(ANNOTATION_TYPE) @interface Inherited
        p Superclass의 애너테이션을 상속함을 표시. 클래스에만 유효한 애너테이션이다.

        h2 @Documented @Retention(RUNTIME) @Target(ANNOTATION_TYPE) @interface Repeatable
        p 애너테이션을 반복적으로 정의할 수 있음을 표현.
            +asA('https://docs.oracle.com/javase/tutorial/java/annotations/repeating.html', '참고자료')

        h2 @Documented @Retention(RUNTIME) @Target(ANNOTATION_TYPE) @interface Retention
        p 애너테이션을 얼마나 유지할 지 표현. value ← RetentionPolicy

        h2 @Documented @Retention(RUNTIME) @Target(ANNOTATION_TYPE) @interface Target
        p 애너테이션을 적용할 요소들을 표현한다. 여러 개(또는 0개)일 경우 배열 리터럴 표기 {}를 이용한다. value ← ElementType[]

    h1 java.lang.module
    div
        h2 ModuleFinder
        ol
            li Module Resolution : 모듈들의 연관 관계를 계산하는 작업. 각 모듈의 필요(requires) 모듈들을 반복적으로 찾아내고 관계 그래프를 구한다.
            li ModuleFinder는 module resolution과 service binding(Configuration#resolveAndBind)에서 모듈을 찾는 데 이용된다.

        h2 ModuleReader
        p 모듈 내용에 대한 접근 제공.
        +asCode('java').
            Optional&lt;URI> find(String name)
            default Optional&lt;InputStream> open(String name)
            default Optional&lt;ByteBuffer> read(String name)
            Stream&lt;String> list()

    h1 java.lang.ref
    div
        h2 Package Summary
        ol
            li
                +asA('https://web.archive.org/web/20061130103858/http://weblogs.java.net/blog/enicholas/archive/2006/05/understanding_w.html', 'java.net 포스트')
                +asA('https://d2.naver.com/helloworld/329631', 'NAVER 개발 포스트')
            li 다른 객체(referent)를 참조하는 reference object를 이용해 GC 절차 일부와 상호작용할 수 있다
            li 3단계의 참조 레벨을 제공한다 : Soft > Weak > Phantom
            li 객체 참조 레벨
            ol
                li Strongly reachable
                ul
                    li Reference object 없이 객체에 직접 접근 가능한 스레드가 존재
                    p e.g. 객체를 생성한 스레드, 객체를 매개변수로 받아 실행 중인 스레드 등
                li Softly reachable
                ul
                    li Not strongly reachable && Soft reference object가 객체를 참조 중
                    li 마지막으로 strongly reachable한 이후 기간, 여유 힙 크기, JVM 옵션(-XX:SoftRefLRUPolicyMSPerMB)에 따라 GC 여부가 결정된다
                    li 지정한 경우, GC 대상으로 판별된 즉시(약간의 지연은 있을 수 있다) ReferenceQueue에 등록된다
                li Weakly reachable
                ul
                    li Not strongly reachable && Not softly reachable && Weak reference object가 객체를 참조 중
                    li Referent는 GC 대상이며, 따라서 get()은 null을 반환할 수 있다
                    li 지정한 경우, GC 대상으로 판별된 즉시(약간의 지연은 있을 수 있다) ReferenceQueue에 등록된다
                li Phantom reachable
                ul
                    li Not strongly reachable && Not softly reachable && Not weakly reachable && 객체는 소멸(finalize)됐지만 Phantom reference object가 참조 중
                    li Finalization 이후 ReferenceQueue에 등록된다
                    li 객체 소멸 감지를 위해 존재하므로, get()은 항상 null을 반환한다
                    li ReferenceQueue에서 꺼낸 뒤, 메모리 해제를 위해 clear()를 호출해야 한다
                li Unreachable
                p 참조 불가능하며, 따라서 GC 대상이 된다.

        h2 Cleaner
        ol
            li 객체 참조와 관련 정리 작업을 관리한다.
            p 객체가 phantom reachable 상태로 변했음을 통지받으면 정리 작업이 실행된다. 참조 레벨의 변경을 통지받기 위해 PhantomReference와 ReferenceQueue를 이용한다.
            li 객체 참조와 정리 작업을 등록하면 Cleanable 인스턴스가 반환된다
            p 가장 효과적인 사용법은 객체의 close() 메서드나, 객체가 필요없는 시점에 명시적으로 clean()을 호출하는 것.
            li 등록하는 객체를 객체 정리 작업이 참조하면 안 된다
            p 참조하는 경우, 객체는 Phantom reachable 레벨에 도달할 수 없고, 따라서 자동으로 정리 작업이 호출될 수 없다.
            li 정리 작업은 Runnable이며, 실행 중 발생하는 모든 예외는 무시된다. 발생한 예외는 Cleaner와 다른 정리 작업에 영향을 미치지 않는다.
                |  Cleaner 인스턴스와 관계된 스레드가 정리 작업을 실행하며, 모든 정리 작업이 실행된 후엔 Cleaner 인스턴스가 GC에 의해 정리된다
            li System.exit 도중의 정리 작업의 실행은 정의되지 않는다
        +asCode('java').
            static Cleaner create()
            Cleaner.Cleanable register(Object obj, Runnable action)
        div
            h3 Cleaner.Cleanable
            +asCode('java').
                void clean()
                    // cleanable을 등록 취소하고 정리 작업을 실행한다. 반복 호출되도 정리 작업은 최대 1번만 실행된다.

        h2 ReferenceQueue&lt;T>
        p 참조 큐. 참조 레벨 변화를 감지하면 GC가 reference object를 큐에 추가한다
        +asCode('java').
            Reference&lt;?
                // reference object가 즉시 사용 가능하면 큐에서 제거하고 반환한다. 그 외의 경우 즉시 null을 반환한다.
            Reference&lt;?
                // 다음 reference object를 규에서 제거하고 반환한다. 그 다음 reference object가 사용 가능해질 때까지 최대 timeout 만큼 대기한다

        h2 Reference&lt;T>
        p GC와 상호작용하기 위한 메서드들을 정의한다. 이 클래스를 직접 상속하지 않아야 한다
        +asCode('java').
            T get()
                // 참조하는 객체를 반환한다
            void clear()
            boolean enqueue()
                // reference object를 정리하고 등록된 큐에 넣는다
                // + isEnqueued
        div
            h3 Sub Classes
            +asCode('java').
                class SoftReference&lt;T> extends Reference&lt;T>
                class WeakReference&lt;T> extends Reference&lt;T>
                class PhantomReference&lt;T> extends Reference&lt;T>

    h1 java.lang.reflect
    div
        h2 자바 제네릭 제약사항
        ol
            li 자바의 제네릭은 컴파일 과정에서 모두 Object 또는 바운드된 클래스로 교체된다.
            li 따라서 List&lt;T> 참조 변수만 가지고 T가 어떤 타입인지 런타임에 알아내는 방법은 없다.
            p 다만, 원소가 존재한다면 instanceof, Class#isInstanse, Class#isAssignableFrom을 이용한 판별은 가능하다.
            li 따라서 제네릭 타입에 대한 직접적인 연산은 모두 무효하다.

        h2 Array
        p 동적으로 자바 배열을 생성하고 접근하는 static 메서드들을 제공.
        +asCode('java').
            static Object newInstance(Class&lt;?> componentType, int length)
            static Object get(Object array, int index)
                // + getBoolean, getByte, ..., + set...

        h2 Modifier
        +asCode('java').
            public static final int PUBLIC, PRIVATE, PROTECTED, STATIC, FINAL, SYNCHRONIZED, VOLATILE, TRANSIENT, NATIVE, INTERFACE, ABSTRACT, STRICT
            static int classModifiers()
                // 사용할 수 있는 제한자들을 OR하여 반환
                // + interfaceModifiers, constructorModifiers, ...

        h2 지원 타입 종류
        +asCode('java').
            interface Type                           // 모든 타입의 공통 super interface.
            interface ParameterizedType extends Type // Collection&lt;String>처럼 파라미터화된 타입을 표현.
            interface GenericArrayType extends Type  // 원소 타입이 parameterized type 또는 type 변수인 배열 타입을 표현.
            interface WildcardType extends Type      // ?, ? extends Number, ? super Integer와 같은 와일드카드 타입을 표현.
            interface AnnotatedElement               // 애너테이트된 요소를 표현
            interface AnnotatedType extends AnnotatedElement {
                default AnnotatedType getAnnotatedOwnerType();
                    // 이 타입이 멤버로 속해있는, 애너테이트된 타입 반환. 예를 들어 이 타입이 @TA O&lt;T>.I&lt;S>라면, @TA O&lt;T>를 반환.
                    // null이 반환되는 경우 ↓
                    //     타입이 top-level이거나 local 클래스, 익명 클래스, 기본 자료형, void인 경우.
                    //     타입이 AnnotatedArrayType, AnnotatedTypeVariable, AnnotatedWildcardType의 인스턴스인 경우.
                Type getType();
                    // 이 애너테이트된 타입의 기저 타입
            }
            interface AnnotatedArrayType extends AnnotatedType         // 원소가 애너테이트된 배열을 표현.
            interface AnnotatedParameterizedType extends AnnotatedType // 타입 인자들이 애너테이트된 parameterized type을 표현.
            interface TypeVariable&lt;D extends GenericDeclaration> extends Type, AnnotatedElement // 타입 변수에 관한 공통 superinterface.
            interface GenericDeclaration extends AnnotatedElement      // 모든 타입 변수 정의들에 대한 공통 인터페이스.
            interface AnnotatedTypeVariable extends AnnotatedType      // 애너테이트된 바운드를 가진 타입 변수를 표현.
            interface AnnotatedWildcardType extends AnnotatedType      // 애너테이트된 upper 또는 lower 바운드들에 대한 와일드카드 타입을 표현

        h2 클래스 멤버 관련
        div
            h3 Member
            p 하나의 멤버(필드나 메서드) 또는 생성자를 가리킨다.
            +asCode('java') boolean isSynthetic() // 컴파일러에 의해 만들어진 멤버인지 여부

            h3 AccessibleObject
            p Field, Method, Constructor의 base 클래스. 리플렉트된 객체를 사용하기 전에 suppressing check 표시한다.
            +asCode('java').
                void setAccessible(boolean flag)
                static void setAccessible(AccessibleObject[] array, boolean flag)
                    // 배열의 각 원소들을 setAccessible(boolean)으로 설정할 수 있을 때, 한번에 하기 위한 메서드

                final boolean canAccess(Object obj)
                final boolean trySetAccessible()
                    // accessible flag 값을 반환한다. 실패할 경우 예외를 발생하지 않고 false를 반환.

            h3 Field
            +asCode('java').
                boolean isEnumConstant()
                void set(Object obj, Object value)
                    // + get, setBoolean, getBoolean, ...

            h3 Executable
            p Method, Constructor의 공통 기능
            +asCode('java').
                abstract Class&lt;?>[] getParameterTypes()
                Parameter[] getParameters()

            h3 Method
            +asCode('java').
                Class&lt;&?> getReturnType()
                Object invoke(Object obj, Object... args)

            h3 Constructor&lt;T>
            +asCode('java') T newInstance(Object... initargs)

            h3 Parameter
            p 메서드 인자에 관한 정보.

            h3 InvocationHandler
            p Proxy 인스턴스의 invocation handler에서 구현하는 인터페이스.
            +asCode('java') Object invoke(Object proxy, Method method, Object[] args)

            h3 Proxy
            ul
                li Proxy는 인터페이스 익명 객체처럼 행동하면서 사용자 정의 메서드를 호출할 수 있는 객체를 생성하는 static 메서드를 제공한다.
                +asCode('java').
                    // 예. 인터페이스 Foo의 프록시 인스턴스 생성
                    InvocationHandler handler = new MyInvocationHandler(...);
                    var f = (Foo) Proxy.newProxyInstance(Foo.class.getClassLoader(), new Class&lt;?>[] { Foo.class }, handler);
                li 프록시 클래스 속성
                p "$Proxy"로 이름이 시작. final and non-abstract. java.lang.reflect.Proxy를 상속. 생성시 주어진 인터페이스들을 차례대로 구현. ProtectionDomain은 bootstrap 클래스 로더가 로드한 시스템 클래스들과 동일.
            +asCode('java').
                static Object newProxyInstance(ClassLoader loader, Class&lt;?>[] interfaces, InvocationHandler h)
                static boolean isProxyClass(Class&lt;?> cl)
                static InvocationHandler getInvocationHandler(Object proxy)

    h1 java.math
    div
        h2 BigDecimal
        p 임의 정밀도의 변경할 수 없는 10진 정수와 32비트 정수인 지수로 십진수를 표현한다.
        +asCode('java').
            public static final BigDecimal ZERO, ONE, TEN

            public BigDecimal(String val)
                // val   ::= (부호)?(진수부)(지수부)?
                // 진수부 ::= 정수부.(소수부) or .소수부 or 정수부
                // 지수부 ::= (e|E)정수

            BigDecimal add(BigDecimal augend) // + subtract, multiply, divide
            BigDecimal divideToIntegralValue(BigDecimal divisor) // 몫
            BigDecimal remainder(BigDecimal divisor)             // 나머지
            BigDecimal[] divideAndRemainder(BigDecimal divisor)
            // + sqrt, pow, abs, negate, scale, precision, unscaledValue, round, movePointRight, scaleByPowerOfTen, ...

        h2 BigInteger
        p 변경할 수 없는 임의 길이의 정수. -2^(Integer.MAX_VALUE) ~ 2^(Integer.MAX_VALUE)
        +asCode('java').
            public static final BigInteger ZERO, ONE, TWO, TEN

            public BigInteger(int signum, byte[] magnitude, int off, int len)
            public BigInteger(String val, int radix)
            public BigInteger(int numBits, Random rnd) : [0 ~ 2^numBits) 사이 난수
            public BigInteger(int bitLength, int certainty, Random rnd)
                // rnd를 통해 난수를 생성하고, 특정 비트 길이의 양의 정수(아마도 소수) 반환. 소수일 확률은 (1 - 0.5^certainty) 초과.

            static BigInteger probablePrime(int bitLength, Random rnd)
                // 합성수일 가능성은 2^(-100)을 넘지 않는다.
            BigInteger nextProbablePrime()
                // 이 BigInteger보다 큰 첫 소수(아마도)를 반환한다. 합성수일 가능성은 2^(-100)을 넘지 않는다.

            // BigDecimal에는 없는 메서드
            sqrtAndRemainder(), gcd(BigInteger), modPow(BigInteger, BigInteger), shiftLeft(int), and(BigInteger), testBit(int), setBit(n), flipBit(int)

        h2 MathContext
        p 정밀도, 반올림 모드를 캡슐화한 변경 불가능한 객체.
        +asCode('java').
            public static final MathContext UNLIMITED
                // precision=0 && roundingMode=HALF_UP
            public static final MathContext DECIMAL32, DECIMAL64, DECIMAL128
                // 각각 7/16/34digits && roundingMode=HALF_EVEN

            int getPrecision()
            RoundingMode getRoundingMode()

        h2 RoundingMode
        ul
            li CEILING, FLOOR, UP : 0에서 멀어지도록 선택
            li DOWN : 0에 가까워지도록 선택
            li HALF_UP, HALF_DOWN, HALF_EVEN : 가장 인접한 두 이웃들이 같은 거리에 있는 경우(*5인 경우), 각각 큰/작은/짝수 이웃을 선택.
            li UNNECESSARY : 올림이나 내림이 필요없는 상태. 그 외엔 ArithmeticException 발생.

    h1 java.net
    div
        h2 Address
        div
            h3 InetAddress
            p IP 주소를 표현하며, IPv4, IPv6 각각에 대응하는 서브 클래스가 있다. 서브 클래스를 직접 이용하는 일은 별로 없을 거라고 한다.
                +codeBtn('/Repositories/Eclipse/JavaSE/src/net/InetAddressTest.java', 'java')
            +asCode('java').
                static InetAddress getLoopbackAddress() // 127.0.0.1(127.*.*.*) or ::1
                static InetAddress getByAddress(byte[] addr)
                static InetAddress getByName(String host)
                static InetAddress[] getAllByName(String host)
                byte[] getAddress()

            h3 SocketAddress
            p 프로토콜과 무관한 소켓 주소를 의미.

            h3 InetSocketAddress
            p IP 소켓 주소[(IP 주소 or 호스트 이름) + 포트]를 표현.
            +asCode('java').
                public InetSocketAddress(int port)                   // port가 0이면 바인드시 자동 할당.
                public InetSocketAddress(InetAddress addr, int port) // addr이 null이면 와일드카드 할당
                public InetSocketAddress(String hostname, int port)

            h3 InterfaceAddress
            ol
                li IPv4 : IP 주소 + 서브넷 마스크 + 브로드캐스트 주소
                li IPv6 : IP 주소 + network prefix length

        h2 Connection
        div
            h3 URLConnection
            ol
                p URL이 지정하는 원격지와의 연결을 정의하며, 일반적으로 아래 단계에 따라 사용된다
                li openConnection 메서드를 통해 연결 객체 획득
                li 구성 인자 및 요청 속성 설정
                p setAllowUserInteraction, setDoInput, setDoOutput, setIfModifiedSince, setUseCaches
                li connect 메서드로 연결 시도
                li 연결 성공하면 헤더와 컨텐츠에 접근할 수 있다
                p getContent, getHeaderField, getInputStream, getOutputStream
                    +codeBtn('/Repositories/Eclipse/JavaSE/src/net/HttpURLConnectionTest.java', 'java')
                    br
                    | 자주 사용되는 헤더 필드 접근 메서드 : getContentEncoding, getContentLength, getContentType, getDate, getExpiration, getLastModified

            h3 HttpURLConnection
            ol
                li HttpURLConnection은 요청을 1회만 하지만, 기저 네트워크 연결은 다른 인스턴스가 공유할 수 있다
                li public static final int HTTP_OK, HTTP_BAD_REQUEST, HTTP_NOT_FOUND, ...
                li int getResponseCode()
                    +codeBtn('/Repositories/Eclipse/JavaSE/src/net/HttpURLConnectionTest.java', 'java')

            h3 JarURLConnection
            ol
                li 원격지 jar에 대한 연결을 제공한다
                li JarEntry 표기 : jar:http://www.foo.com/bar/baz.jar!/COM/foo/Quux.class
                li JarFile 표기 : jar:http://www.foo.com/bar/baz.jar!/
                li Jar directory 표기 : jar:http://www.foo.com/bar/baz.jar!/COM/foo/

        h2 Socket
        div
            h3 SocketOptions
            +asCode('java').
                @Native static final int SO_REUSEPORT
                    // 여러 소켓이 같은 주소와 포트를 listen할 수 있는지 여부.
                @Native static final int SO_LINGER
                    // TCP 소켓 linger-on-close timeout 설정. 0이면 즉시 강제 종료. 양수면 최대 65,535까지 종료 대기. 그 외엔 일반적인 종료 절차.
                @Native static final int SO_TIMEOUT
                    // ServerSocket#accept, SocketInputStream#read, DatagramSocket#receive에 대한 timeout 설정. 사용하기 전에 미리 설정돼야 한다.
                @Native static final int SO_SNDBUF
                    // 전송 버퍼 크기에 대한 힌트 + SO_RCVBUF
                @Native static final int SO_KEEPALIVE
                    // TCP 연결에서 2시간(실제와 다를 수 있음) 동안 아무 교환이 없으면 keepalive probe를 보낸다. 응답이 ACK면 정상, RST면 상대가 리셋(리부트)되었으므로 연결 종료, 응답 없는 경우에도 연결 종료.
                @Native static final int SO_OOBINLINE
                    // TCP 소켓에 설정되면 input stream을 통해 긴급 데이터(1바이트)를 받을 수 있다. 설정되지 않으면(기본) 버려진다.
                void setOption(int optID, Object value)
                    // + getOption, ...

            h3 Socket
            p TCP 클라이언트 소켓
                +codeBtn('/Repositories/Eclipse/JavaSE/src/net/SocketTest.java', 'java')
            +asCode('java').
                void connect(SocketAddress endpoint, int timeout)
                void bind(SocketAddress bindpoint)

                SocketChannel getChannel()
                    // SocketChannel#open 또는 ServerSocketChannel#accept로 생성된 경우에만 존재.
                InputStream getInputStream() + getOutputStream

                &lt;T> Socket setOption(SocketOption&lt;T> name, T value)
                &lt;T> T getOption(SocketOption&lt;T> name)
                Set&lt;SocketOption&lt;?>> supportedOptions()

            h3 ServerSocket
            p TCP 서버 소켓
                +codeBtn('/Repositories/Eclipse/JavaSE/src/net/SocketTest.java', 'java')
            +asCode('java').
                public ServerSocket(int port)
                    // port 0은 자동 할당. 들어오는 연결 큐의 크기(backlog)는 50.

                void bind(SocketAddress endpoint)
                Socket accept()
                ServerSocketChannel getChannel()
                    // ServerSocketChannel#open으로 생성된 경우에만 존재.

                static void setSocketFactory(SocketImplFactory fac)
                void setPerformancePreferences(int connectionTime, int latency, int bandwidth)

                &lt;T> ServerSocket setOption(SocketOption&lt;T> name, T value)
                &lt;T> T getOption(SocketOption&lt;T> name)
                Set&lt;SocketOption&lt;?>> supportedOptions()

            h3 DatagramSocket
            p UDP 소켓을 정의한다
            +asCode('java').
                void bind(SocketAddress addr)
                void connect(InetAddress address, int port)
                    // 기본적으로 UDP 데이터그램 소켓은 연결이 없다. 이 메서드로 원격지에 연결하는순간, 소켓은 해당 원격지와만 통신할 수 있다.
                    // 원격지와 연결하면 다음 메서드들이 동작한다. getInetAddress(), getPort(), getRemoteSocketAddress()

                void send(DatagramPacket p)
                void receive(DatagramPacket p)

                void setTrafficClass(int tc) + getTrafficClass
                    // 0&lt;=tc&lt;=255. IPv4에서, 하위 8개 비트를 IP 패킷의 TOS에 쓴다.
                    // IPv6에서, IP 헤더의 sin6_flowinfo 필드에 들어간다.
                    // RRC 1349의 TOS 값 정의
                    //     IPTOS_LOWCOST(0x02), IPTOS_RELIABILITY(0x04), IPTOS_THROUGHPUT(0x08), IPTOS_LOWDELAY(0x10)

                DatagramChannel getChannel()
                    // DatagramChannel#open으로 생성된 경우에만 존재.

                static void setDatagramSocketImplFactory(DatagramSocketImplFactory fac)

                &lt;T> DatagramSocket setOption(SocketOption&lt;T> name, T value)
                    // + getOption, 각종 옵션 setter/getter
                Set&lt;SocketOption&lt;?>> supportedOptions()

            h3 MulticastSocket
            ol
                li 멀티캐스트 데이터그램 소켓을 제공한다.
                li 멀티캐스트 그룹 ::= Class D IP 주소 + UDP 포트
                p Class D ::= (224.0.0.0, 239.255.255.255]
                li 멀티캐스트 그룹에 데이터그램을 보내면 모든 구독자들이 받게 된다
                p 멀티캐스트 그룹의 멤버가 아니라도 멀티캐스트 데이터그램을 보내는 것은 가능하다
            +asCode('java').
                // JavaDoc 예시
                var group = InetAddress.getByName("228.5.6.7");
                var s = new MulticastSocket(6789);
                s.joinGroup(group);
                var msg = "hello".getBytes();
                s.send(new DatagramPacket(msg, msg.length, group, 6789));
                var buf = new byte[1000];
                s.receive(new DatagramPacket(buf, buf.length));
                s.leaveGroup(group);

            h3 DatagramPacket
            ol
                li UDP 패킷을 정의한다. 송신용 생성자는 byte[]와 길이 정보가 필요하고, 수신용 생성자는 주소 정보가 추가로 필요하다.
                li 패킷 데이터, 길이, 주소 각각에 대한 getter/setter 제공

        h2 URI
        div
            h3 URI
            div
                h4 URI syntax and components
                ol
                    li syntax : [scheme:]scheme-specific-part[#fragment]
                    li Absolute URI : 스킴을 명시한 URI
                    li Relative URI : Not absolute URI
                    li Opaque URI : scheme-specific-part가 '/'로 시작하지 않는 absolute URI
                    p 예: "mailto:java-net@java.sun.com", "urn:isbn:096139210x"
                    li Hierarchical URI : scheme-specific-part가 '/'로 시작하는 absolute or relative URI
                    p [scheme:][//authority][path][?query][#fragment]
                        br
                        | 예: "http://example.com/languages/java", "sample/a/index.html#28", "../../demo/b/index.html"
                    li Server-based authority : [user-info@]host[:port]
                    li Registry-based authority : not server-based authority

                h4 Operations on URI instances
                ol
                    li Normalization : "."과 ".."을 제거
                    li Resolution : 상대 URI와 base URI를 이용해 단일 URI를 찾는 작업
                    li Relativization : Resolution의 역.
                    p 임의의 정규화된 두 URI u, v에 대하여, u.relativize(u.resolve(v)).equals(v)와 u.resolve(u.relativize(v)).equals(v)는 항상 성립한다.

            h3 URL
            p 인스턴스 생성 시, URI와 다르게 정의된 scheme에 대한 핸들러를 찾기 때문에, 핸들러를 찾지 못하면 예외가 발생한다
                +codeBtn('/Repositories/Eclipse/JavaSE/src/net/HttpURLConnectionTest.java', 'java')
            +asCode('java').
                boolean sameFile(URL other) : fragment(#) 제외하고 같은 파일인지 여부
                URI toURI()

                URLConnection openConnection()
                final InputStream openStream() // == openConnection().getInputStream()
                final Object getContent()      // == openConnection().getContent()

            h3 URLDecoder
            +asCode('java') static String decode(String s, Charset charset)

            h3 URLEncoder
            +asCode('java') static String encode(String s, Charset charset)

            h3 URLClassLoader
            p URL을 이용한 클래스 로더를 제공한다

        h2 NetworkInterface
        p 이름과 할당된 IP 주소들로 구성된 Network Interface 표현.
            +codeBtn('/Repositories/Eclipse/JavaSE/src/net/NetworkInterfaceTest.java', 'java')
        +asCode('java').
            static Stream&lt;NetworkInterface> networkInterfaces()
                // + getNetworkInterfaces

            Stream&lt;InetAdress> inetAddresses()
                // + getInetAddresses
            byte[] getHardwareAddress()
                // 보통 MAC 주소

    h1 java.nio
    div
        h2 버퍼 관련
        div
            h3 Buffer
            ol
                li 버퍼는 일련의 유한한 기본 자료형 원소들의 나열.
                ul
                    li Capacity : 저장하고 있는 원소들의 개수
                    li Limit : 읽거나 쓸 수 없는 최초의 인덱스. 0보다 작거나 capacity보다 클 수 없다.
                    li Position : 다음에 읽거나 쓸 대상의 인덱스. 0보다 작거나 limit보다 클 수 없다.
                    li 0&lt;=mark&lt;=position&lt;=limit&lt;=capacity // 마킹은 지원되지 않을수도 있다.
                li get/put 연산의 Relative/Absolute 구분
                ul
                    li Relative : 버퍼의 현재 Position에 대한 연산
                    li Absolute : 버퍼의 특정 위치를 지정한 연산
                li Additional operations
                ul
                    li clear() : 새로운 채널-읽기 또는 relative put 연산을 준비; limit을 capacity로, position을 0으로.
                    li flip() : 새로운 채널-쓰기 또는 relative get 연산을 준비; limit을 position으로, position을 0으로.
                    li rewind() : 이미 읽은 것을 다시 읽도록; limit은 그대로, position을 0으로.
                    li slice() : 기존 버퍼의 부분 시퀀스 생성.
                    li duplicate() : 기존 버퍼의 얕은 복사본 생성.
            +asCode('java').
                abstract boolean hasArray()
                    // 기저 배열의 존재 유무. true면 array()와 arrayOffset() 사용가능
                abstract boolean isDirect()
                    // Direct 버퍼(즉시 읽기/쓰기)인지 여부

                abstract Buffer slice()
                    // 현재 버퍼의 현재 위치부터 시작하는 부분 버퍼 생성(내용 공유). direct, read-only 속성을 공유.
                abstract Buffer duplicate()
                    // 복사본(내용 공유) 반환.

            h3 ByteBuffer
            ol
                li 다음 연산을 정의.
                ul
                    li 바이트 하나에 대한 absolute/relative get/put
                    li 바이트 시퀀스에 대한 bulk get/put
                    li 다른 원시 타입에 대한 absolute/relative get/put
                    li 다른 원시 타입으로 읽기 가능한 view 버퍼 생성
                    li compact : 인덱스 [0, position) 사이의 데이터가 버려진다(Optional operation)
                li Direct 버퍼
                p 읽기/쓰기 연산이 직접적으로 이루어지며, 별개의 복사본을 이용하는 non-direct 버퍼에 비해 할당/제거 비용이 크다. Direct 버퍼는 allocateDirect 팩토리 메서드로 생성된다.
                li Access to binary data
                p 버퍼의 byte order는 해당 버퍼에 대한 연산의 기준이 된다. 기본값은 ByteOrder.BIG_ENDIAN.
                li 인덱싱
                p ByteBuffer인덱스를 지정하는 absolute get/put의 인덱스는 바이트 단위다. 뷰 버퍼의 인덱스는 해당 타입 크기 단위다.
                +codeBtn('/Repositories/Eclipse/JavaSE/src/nio/ByteBufferExample.java', 'java')
            +asCode('java').
                abstract byte get(int index)
                ByteBuffer get(byte[] dst, int offset, int length)
                ByteBuffer put(ByteBuffer src)

                abstract CharBuffer asCharBuffer() // + short, int, long, float, double

                final int alignmentOffset(int index, int unitSize)
                    // index % unitSize를 반환한다. 0이 아니면 unitSize 단위로 자르기 부적합하다는 의미. unitSize는 2의 거듭제곱이어야 한다.
                final ByteBuffer alignedSlice(int unitSize)
                    // 현재 버퍼를 unitSize 크기씩 잘라 view 버퍼를 생성(BIG_ENDIAN)한다.
                    // 현재 위치가 unitSize의 배수가 아니라면 바로 다음 배수 위치부터 포함하며, limit도 unitSize 배수에 맞춰 끊는다.

                int mismatch(ByteBuffer that)
                    // 두 바이트 버퍼의 현재 읽기 위치들을 시작 위치로 하여, 바이트 값이 다른 최초 index를 반환한다.

            h3 MappedByteBuffer
            p FileChannel#map 메서드로 생성되는 direct 바이트 버퍼. 기저 파일이 (외부에서) 변경되면 버퍼 내용도 변경된다. 역도 성립
            +asCode('java').
                final BappedByteBuffer load()  // 파일 내용을 메모리에 적재한다
                final MappedByteBuffer force() //강제로 버퍼 변경 내용을 파일에 쓴다.

            h3 CharBuffer
            ol
                li + ShortBuffer, DoubleBuffer
                li 다음 연산을 정의
                ul
                    li 단일 char에 대한 absolute/relative get/put
                    li char 시퀀스에 대한 bulk get/set
                    li compact : ByteBuffer의 설명과 동일

        h2 ByteOrder
        +asCode('java').
            public static final ByteOrder BIG_ENDIAN, LITTLE_ENDIAN
            static ByteOrder nativeOrder()

    h1 java.nio.channels
    div
        h2 채널 인터페이스
        div
            h3 Channel
            p 채널이란 독립적인 IO를 수행할 수 있는 개체에 대한 연결이다.
            +asCode('java') boolean isOpen()

            h3 ReadableByteChannel
            +asCode('java').
                int read(ByteBuffer dst)
                    // dst.remaining()만큼 읽어 dst에 저장. 읽은 바이트 개수를 반환. 스트림의 끝이면 -1.

            h3 WritableByteChannel
            +asCode('java').
                int write(ByteBuffer src)
                    // src.remaining() 부분을 채널에 쓴다.

            h3 ByteChannel
            p 바이트 단위 읽기/쓰기 모두 가능한 채널.

            h3 AsynchronousChannel
            p 비동기 I/O를 지원하는 채널. close()도 비동기적으로 수행되며, 도중/이후 작업은 AsynchronousCloseException 발생시키면 된다

            h3 InterruptibleChannel
            p "instanceof InterruptibleChannel" IFF "비동기적으로 close() 메서드를 통해 인터럽트되고 닫을 수 있는 채널"

            h3 AsynchronousByteChannel
            p 비동기 IO를 지원하는 바이트 채널
            +asCode('java').
                &lt;A> void read(ByteBuffer dst, A attachment, CompletionHandler&lt;Integer, ? super A> handler)
                    // 기본 동작은 ReadableByteChannel#read와 동일. 쓰기가 완료(실패)되면 handler가 호출된다. handler에 전달될 첫 인자는 읽은 바이트 수.
                Future&lt;Integer> read(ByteBuffer dst)
                    // 반환된 Future#get 메서드로 읽은 바이트 수를 얻을 수 있다.

            h3 ScatteringByteChannel
            p 채널의 바이트들을 여러 버퍼에 순서대로 저장. 네트워크 헤더나 파일 메타데이터처럼 고정 길이의 헤더를 읽는 데 유용.
            +asCode('java').
                long read(ByteBuffer[] dsts, int offset, int length)
                    // dsts[offset]부터 length개의 버퍼가 각각의 remaining()만큼씩 바이트를 읽어 가져간다.

            h3 GatheringByteChannel
            +asCode('java').
                long write(ByteBuffer[] srcs, int offset, int length)
                    // srcs[offset]부터 length개의 버퍼의 remaining() 부분을 채널에 쓴다.

            h3 SeekableByteChannel
            p 현재 위치를 기억하는 바이트 채널.
            +asCode('java').
                SeekableByteChannel truncate(long size)
                    // 채널에 연결된 개체의 크기를 size로 조정. size가 현재보다 작은 경우 나머지는 버려진다(position이 size보다 큰 경우 size로 조정된다). size가 현재 이상인 경우 아무 변경 없다.

            h3 NetworkChannel
            p 네트워크 소켓에 대한 채널

            h3 MulticastChannel
            p IP 계층 멀티캐스팅 가능한 채널

        h2 비동기 채널 관련
        div
            h3 CompletionHandler&lt;V, A>
            p 비동기 I/O 작업의 결과를 소비하는 소비자
            +asCode('java').
                void completed(V result, A attachment)   // 성공시 호출
                void failed(Throwable exc, A attachment) // 실패시 호출

            h3 AsynchronousChannelGroup
            p 그룹 지정되지 않은 비동기 채널들은 시스템 기본 그룹에 묶인다.
            p 시스템 속성에 따라 생성된 ThreadFactory가 비동기 작업을 실행할 데몬 스레드들을 만든다.
            +asCode('java').
                static AsynchronousChannelGroup withFixedThreadPool(int nThreads, ThreadFactory threadFactory)
                    // 최대 nThreads의 스레드만 동시에 실행된다. 시스템 기본 AsynchronousChannelProvider 객체의 openAsynchronousChannelGroup(int, ThreadFactory) 메서드를 통해 만들어진다
                static AsynchronousChannelGroup withCachedThreadPool(ExecutorService executor, int initialSize)
                    // 시스템 기본 AsynchronousChannelProvider 객체의 openAsynchronousChannelGroup(ExecutorService, int) 메서드를 통해 만들어진다.
                    // 채널 그룹의 종료(shutdown)는 ExecutorService의 shutdown()으로 이어진다. 따라서 ExecutorService가 외부에서 닫히는 경우엔 무슨 일이 일어날 지 모른다

                abstract void shutdown()
                    // 순차적 종료 절차에 진입한다.
                abstract void shutdownNow()
                    // shutdown() + 모든 열린 채널들을 닫는다. 실행 중인 CompletionHandler들은 끝날 때까지 기다린다. 도중에 다른 스레드에서 이 메서드를 호출하는 경우, 현재 작업이 완료될 때까지 블록된다; 더 불러도 추가 작업은 없다.
                abstract boolean awaitTermination(long timeout, TimeUnit unit)

            h3 AsynchronousFileChannel
            ol
                li 파일에 대한 비동기 채널. I/O의 기준이 되는 현재 위치를 갖고 있지 않으며, 메서드에서 지정한다
                li 생성된 채널들은 스레드-안전하며, 완료 핸들러들은 별개의 스레드에서 실행됨이 보장된다.
                p 연산에 사용되는 ByteBuffer 자체는 스레드-안전하지 않음에 유의
            +asCode('java').
                static AsynchronousFileChannel open(Path file, Set&lt;? extends OpenOption> options, ExecutorService executor, FileAttribute&lt;?>... attrs)
                    // 파일을 열거나 생성한 뒤 비동기 채널을 하나 반환한다. options에는 java.nio.file.StandardOpenOption을 이용하면 된다.

                abstract AsynchronousFileChannel truncate(long size)
                    // size() > size인 경우 파일을 자른다. return this;

                abstract void force(boolean metaData)
                    // 메서드 호출 시점부터 true면 StandardOpenOption.SYNC를, false면 StandardOpenOption.DSYNC를 적용하는 것과 같다. 기저 파일이 로컬에 존재하는 경우에만 유효하다.

                abstract &lt;A> void lock(long position, long size, boolean shared, A attachment, CompletionHandler&lt;FileLock, ? super A> handler)
                    // 기저 파일 일부에 대한 잠금을 얻는다. handler는 잠금을 얻는 데 성공/실패하면 호출된다. 잠금 size는 고정이므로, 파일 크기가 커질 것도 고려하여 필요한 만큼 신청해놔야 한다.
                abstract FileLock tryLock(long position, long size, boolean shared)
                    // 스레드를 블록하지 않는다. OverlappingFileLockException에 해당하는 상황에는 null이 반환된다

                abstract &lt;A> void read(ByteBuffer dst, long position, A attachment, CompletionHandler&lt;Integer, ? super A> handler)
                    // handler에 전달되는 Integer는 읽은 바이트 길이, 또는 -1(position > size())
                abstract &lt;A> void write(ByteBuffer src, long position, A attachment, CompletionHandler&lt;Integer, ? super A> handler)
                    // position > size()인 경우, 그 사이 바이트 값은 쓰레기 값이다.

            h3 AsynchronousServerSocketChannel
            ol
                li 스트림 지향 읽기 소켓 채널
                    +codeBtn('/Repositories/Eclipse/JavaSE/src/nio/AsynchronousSocketChannelTest.java', 'java')
                li 스레드-안전하지만 최대 accept 가능한 스레드는 하나 뿐이며, accept 도중 중복되는 요청은 AcceptPendingException
                li 지원하는 소켓 옵션 : SO_RCVBUF(수신 버퍼 크기), SO_REUSEADDR(주소 재사용); 구현에 따라 추가될 수도 있다
            +asCode('java').
                static AsynchronousServerSocketChannel open(AsynchronousChannelGroup group)
                    // group을 지정하지 않거나 null로 설정하는 경우 시스템 기본 그룹이 이용된다

                final AsynchronousServerSocketChannel bind(SocketAddress local, int backlog)
                    // backlog는 소켓에 대한 최대 pending connection 수. 0이나 음수로 설정하면 구현체의 기본값을 이용한다. return this;

                abstract &lt;A> void accept(A attachment, CompletionHandler&lt;AsynchronousSocketChannel, ? super A> handler)
                    // 신규 연결된 AsynchronousSocketChannel은 현재 채널과 동일한 채널 그룹에 묶인다. 그룹이 닫힌 경우, 신규 연결도 닫히고 ShutdownChannelGroupException

            h3 AsynchronousSocketChannel
            ol
                li 스트림 지향 소켓 채널. open 팩터리 메서드로 직접 열거나(Unbound), AsynchronousServerSocketChannel#accept로 열 수(Bound) 있다.
                    +codeBtn('/Repositories/Eclipse/JavaSE/src/nio/AsynchronousSocketChannelTest.java', 'java')
                li 스레드-안전하지만 최대 하나의 읽기/쓰기만 각각 동시에 존재할 수 있다.
                p 도중에 중복되는 요청은 각각 ReadPendingException, WritePendinException 발생
                li 지원하는 소켓 옵션 : SO_SNDBUF(전송 버퍼 크기), SO_RCVBUF(수신 버퍼 크기), SO_KEEPALIVE(기본 false, keep-alive 작동은 구현체에 의존적이다), TCP_NODELAY(Nagle 알고리즘 비활성)
                li 읽기/쓰기 시 양수의 타임아웃을 지정한 경우, 시간 내에 완료되지 못하면 InterruptedByTimeoutException으로 종료되고, 이후 상태는 비결정적이며, 따라서 사용된 채널, 버퍼들은 버리는 게 낫다
            +asCode('java').
                static AsynchronousSocketChannel open(AsynchronousChannelGroup group)
                    // group이 지정되지 않거나 null인 경우, 시스템 기본 그룹이 이용된다

                abstract AsynchronousSocketChannel shutdownInput()
                    // 채널을 더 이상 읽을 수 없게 한다. 이후의 읽기는 모두 -1을 반환한다. return this;
                abstract AsynchronousSocketChannel shutdownOutput()
                    // 채널을 더 이상 쓸 수 없게 한다. 이후의 쓰기는 모두 ClosedChannelException ─ 읽기는 가능할 수 있다 ─ 으로 종료된다.

                abstract &lt;A> void connect(SocketAddress remote, A attachment, CompletionHandler&lt;Void, ? super A> handler)

                abstract &lt;A> void read(ByteBuffer dst, long timeout, TimeUnit unit, A attachment, CompletionHandler&lt;Integer, ? super A> handler)
                    // ScatteringByteChannel#read와 유사한 메서드도 지원한다
                abstract &lt;A> void write(ByteBuffer src, long timeout, TimeUnit unit, A attachment, CompletionHandler&lt;Integer, ? super A> handler)
                    // GatheringByteChannel#write와 유사한 메서드도 지원한다

        h2 채널 클래스
        div
            h3 Channels
            p 채널과 스트림에 관한 유틸리티 클래스.
            +asCode('java').
                static InputStream newInputStream(ReadableByteChannel ch)
                    // 채널이 논-블로킹 모드면 읽기 시 예외 발생. 버퍼링, mark/reset 미지원. 스레드-안전. 닫으면 채널도 닫힌다
                static OutputStream newOutputStream(WritableByteChannel ch)
                    // 채널이 논-블로킹 모드면 쓰기 시 예외 발생. 버퍼링 미지원. 스레드-안전. 닫으면 채널도 닫힌다
                static InputStream newInputStream(AsynchronousByteChannel ch)
                    // 버퍼링, mark/reset 미지원. 스레드-안전. 닫으면 채널도 닫힌다
                static OutputStream newOutputStream(AsynchronousByteChannel ch)
                    // 버퍼링 미지원. 스레드-안전. 닫으면 채널도 닫힌다

                static ReadableByteChannel newChannel(InputStream in)
                    // 버퍼링 미지원. 닫으면 스트림도 닫힌다
                static WritableByteChannel newChannel(OutputStream out)
                    // 버퍼링 미지원. 닫으면 스트림도 닫힌다
                static Reader newReader(ReadableByteChannel ch, Charset charset)
                    // 채널이 논-블로킹 모드면 읽기 시 예외 발생. 버퍼링 지원. mark/reset 미지원. 닫으면 채널도 닫힌다
                static Writer newWriter(WritableByteChannel ch, Charset charset)
                    // 채널이 논-블로킹 모드면 쓰기 시 예외 발생. 버퍼링 지원. 닫으면 채널도 닫힌다

            h3 FileChannel
            +asCode('java').
                abstract MappedByteBuffer map(FileChannel.MapMode mode, long position, long size)
                    // 매핑 : 파일의 일부분을 메모리에 올려놓고 작업. 큰 파일은 이쪽이 효율이 좋다
                    // READ_ONLY : 변경 불가, READ_WHITE : 변경이 기저 파일에 전파, PRIVATE : 변경이 전파되지 않음

            h3 ServerSocketChannel
            p 스트림-지향 읽기 소켓 채널. AsynchronousServerSocketChannel 참고.

            h3 SocketChannel
            p 스트림-지향 소켓 채널. AsynchronousSocketChannel 참고.

            h3 DatagramChannel
            ol
                li 데이터그램-지향 소켓 채널
                li 기존 데이터그램 소켓에서 채널을 얻는 방법은 없으며, open 팩터리 메서드로 획득해야 한다
                li send/receive 메서드는 연결없이 사용할 수 있지만, read/write 메서드는 connect 메서드를 통해 연결해야 이용할 수 있다
                p 연결된 경우, 송/수신에 불필요한 보안 체크를 하지 않는다
                li 지원하는 소켓 옵션 : SO_SNDBUF, SO_RCVBUF, SO_REUSEADDR, SO_BROADCAST, IP_TOS, IP_MULTICAST_IF, IP_MULTICAST_TTL, IP_MULTICAST_LOOP
            +asCode('java').
                static DatagramChannel open()
                    // IP 멀티캐스팅에 이용하려는 경우, 멀티캐스트 그룹 타입을 ProtocolFamily에 지정해줘야 한다

            h3 SelectableChannel
            ol
                li 스레드-안전. Selector를 통해 멀티플렉싱될 수 있는 채널을 정의한다
                li Selector에 등록함으로써 SelectionKey가 발행된다. 나가는 건 마음대로 할 수 없다.
                p 채널이 닫히면 채널에 대한 모든 SelectionKey들은 cancel된다
                li 각 Selector에는 최대 한 번씩만 등록할 수 있다. Selector가 닫히면 등록된 모든 채널이 내려가고, 각 키들은 즉시 무효하게 된다
                li Non-blocking mode
                p 새로 생성된 SelectableChannel은 블로킹 모드지만, configureBlocking(boolean) 메서드로 모드를 변경할 수 있다. 이 경우, Selector에 등록하기 전에 논-블로킹으로 설정해야 하며, 한 번 등록되면 등록 취소되기 전까지 논-블로킹 모드로 작동한다
                    br
                    | 논-블로킹 모드에서는 I/O 연산이 절대 블로킹되지 않지만, 요청보다 적은 데이터가 보내지거나 아예 전송되지 않을 수 있다.
            +asCode('java').
                abstract SelectorProvider provider()
                    // 이 채널을 생성한 provider를 반환한다

                abstract SelectableChannel configureBlocking(boolean block)
                    // 이미 어느 Selector에 등록된 채널이라면 논-블로킹 설정 시 IllegalBlockingModeException 발생

                abstract Object blockingLock()
                    // configureBlocking, register 메서드에서 동기화에 이용되는 객체를 반환한다

        h2 Pipe
        ol
            li 2개 채널로 이루어진 단방향 파이프를 정의한다
            p SinkChannel : 쓰기 전용, SourceChannel : 읽기 전용

        h2 FileLock
        ol
            li Adivisory Lock : 응용 프로그램이 잠금을 직접 확인하고, 알아서 읽기/쓰기를 수행할 지 결정한다.
            li Mandatory Lock : 커널이 잠금을 관리하기 때문에, 관련되지 않은 프로세스는 접근 불가
            p 모든 잠금을 Adivisory Lock으로 간주하여 관리함이 바람직하다
            li On some systems, 잠금의 존재로 인해 매핑(FileChannel#map)이 불가능할 수 있음에 유의
            li On some systems, 채널을 닫으면 해당 파일에 대한 모든 잠금이 해제될 수 있음에 유의
            li Some network filesystems, 잠금 영역 크기가 하드웨어 페이지 크기의 배수인 경우에만 매핑을 지원함에 유의
            li Some network filesystems, 2^30 또는 2^31 이상 크기에 대한 잠금을 지원하지 않음에 유의

        h2 MembershipKey
        p IP 멀티캐스트 그룹에 대한 멤버십을 표현한다
        +asCode('java').
            abstract boolean isValid()
            abstract void drop()
            abstract InetAddress group()
            abstract MulticastChannel channel()
                // 이 멤버십 키를 생성한 채널을 반환한다.
            abstract InetAddress sourceAddress()
                // 특정 소스의 데이터그램만 수신하는 멤버십(Source-specific membership key)인 경우, 유효한 주소를 반환한다
            abstract MembershipKey block(InetAddress source) + unblock
                // OS가 소스 필터링을 적용하지만, 적용되지 않은 멤버십에 대하여 이를 호출하면 특정 소스를 차단할 수 있다
            abstract NetworkInterface networkInterface()

        h2 Selector
        ol
            li SelectableChannel에 대한 멀티플렉서. 스레드-안전
            li SelectableChannel을 등록하면 SelectionKey가 발행되며, 3가지 집합으로 관리된다
            ul
                li Key set : 현재 등록된 채널들에 관한 키. SelectableChannel#register 메서드로 등록. Selector#keys 메서드로 획득.
                li Selected-key set : 선택 연산에 의해, 최소 하나의 연산에 대해 ready 상태로 파악된 키. 자동 등록(수동 삭제만 가능). selectedKeys 메서드로 획득
                li Cancelled-key set : 취소되었지만 채널은 아직 등록되어 있는 키
            li 선택 연산에는 2가지 종류가 있다
            ul
                li select(), select(long), selectNow() : 지정된 연산에 대해 준비된 상태인지 확인하여 selected-key set 업데이트
                ol
                    li Cancelled-key set의 멤버들에 대해, 키 집합에서 제거하고 채널을 등록 취소한다. 결과적으로 cancelled-key set은 비게 된다.
                    p 아래 작업 중 Cacelled-key set에 추가된 키들에 대해서도 추가로 작업한다
                    li Selected-key set에 없는 키에 대해, 키의 interest set의 연산 중 하나라도 준비되었다면 selected-key set으로 추가되고, 키의 ready set이 설정된다
                    li Selected-key set에 있는 키에 대해, 키의 ready set 외의 연산 중 준비된 것들은 ready set으로 추가된다
                li select(Consumer), select(Consumer, long), selectNow(Consumer) : 준비된 채널들에 대해 작업 실행. selected-key set을 업데이트하지 않음
                ol
                    li Cancelled-key set의 멤버들에 대한 작업은 전과 같다
                    p 마찬가지로 아래 작업 중 Cacelled-key set에 추가된 키들에 대해서도 추가로 작업한다
                    li 키의 ready set이 최소 하나의 연산에 대해 준비되었다면, ready set은 준비된 연산들로만 설정되고, 주어진 Consumer가 키를 소비한다.
                    p 키의 ready set이 2개 이상의 연산에 대해 준비되었다면, Consumer는 여러 번 호출될 수 있다. Consumer를 호출하기 전에 ready set에서 해당 연산을 빼기 때문에, 한 번의 선택 연산에서 같은 연산에 대해 2번 호출되지 않는다.
            li 선택 연산에서 사용되는 키의 interest set은 연산의 시작 시점의 것으로, 중간에 변경됐다면 다음 선택 연산에 적용된다
            li 키와 채널은 언제든 닫힐 수 있으므로, 사용 시 다른 스레드에서 키나 채널을 닫는지 유의해야 한다
        +asCode('java').
            abstract int selectNow()
                // 논-블로킹으로 선택한다. 선택 연산으로 ready set이 업데이트된 키의 수를 반환한다. 이전 wakeup()의 영향을 제거한다
            abstract int select(long timeout)
                // 블로킹으로 선택한다. timeout이 지정되지 않은 경우엔 무기한. 적어도 하나의 채널이 선택되면 반환한다.
            int selectNow(Consumer&lt;SelectionKey> action)
                // 논-블로킹으로 키를 소비한다. 소비된 유니크한 키의 개수를 반환한다. 이전 wakeup()의 영향을 제거한다
            int select(Consumer&lt;SelectionKey> action, long timeout)
                // 블로킹으로 키를 소비한다. 소비된 유니크한 키의 개수를 반환한다. 시간 초과 되거나, 적어도 하나의 채널이 선택되면 wakeup()으로 깨어난다
            abstract Selector wakeup()
                // 아직 반환하지 않은 선택 연산이 즉시 반환하도록 한다. 현재 실행 중인 선택 연산이 없다면 다음 선택 연산(selectNow 제외)에 대해 적용된다.

        h2 SelectionKey
        ol
            li SelectableChannel이 Selector에 등록됨을 나타내는 토큰. 채널이나 Selector가 닫히면서 cancel 메서드로 닫히기 전까지 유효
            li 각 SelectionKey는 2가지 연산 집합을 갖는다. 각 집합은 int로 표현되고, 설정된 비트는 채널이 해당 연산을 지원함을 의미한다
            ul
                li Interest set : Selector의 선택 연산에서 ready 상태인지 검사될 연산 집합. 최초 채널 등록 시 제공된 int값이며, interestOps(int)로 변경할 수 있다.
                li Ready set : 키의 채널이 ready 상태인 연산들의 집합. 최초 생성 시 0이며, Selector의 선택 연산으로 변경된다. 직접 변경할 수는 없다.
            li 이 클래스에서 공통적인 지원 연산에 대해 정의하지만, 각 SelectableChannel의 서브 클래스에서 제공하는 validOps()가 정확하다
        div
            h3 Field Detail
            ol
                li static final int OP_READ
                p Selector의 선택 연산 시 interest set에 포함되어 있을 때. 채널이 읽기 가능하거나, end-of-stream에 도달했거나, 원격지에서 닫았거나, 에러 대기 상태면 ready set에 추가
                li static final int OP_WRITE
                p Selector의 선택 연산 시 interest set에 포함되어 있을 때. 채널이 쓰기 가능하거나, 원격지에서 닫았거나, 에러 대기 상태만 ready set에 추가
                li static final int OP_CONNECT
                p Selector의 선택 연산 시 interest set에 포함되어 있을 때, 채널이 연결 완료될 수 있거나, 에러 대기 상태면 ready set에 추가
                li static final int OP_ACCEPT
                p Selector의 선택 연산 시 interest set에 포함되어 있을 때. 서버 채널이 연결을 허용할 수 있거나, 에러 대기 상태면 ready set에 추가

    h1 java.nio.charset
    div
        h2 Charset
        +asCode('java').
            static SortedMap&lt;String, Charset> availableCharsets()
            static boolean isSupported(String charsetName)
            static Charset forName(String charsetName)
            static Charset defaultCharset()

            boolean canEncode()
            abstract CharsetDecoder newDecoder()   // + newEncoder
            final CharBuffer decode(ByteBuffer bb) // + encode

        h2 CharsetDecoder
        p 바이트열을 문자열로 변환.
        +asCode('java').
            final CharBuffer decode(ByteBuffer in)
            final CoderResult decode(ByteBuffer in, CharBuffer out, boolean endOfInput)

            final float averageCharsPerByte() // + maxCharsPerByte

        h2 CharsetEncoder
        p 문자열을 바이트열로 변환.
        +asCode('java').
            final ByteBuffer encode(CharBuffer in)
            final CoderResult encode(CharBuffer in, ByteBuffer out, boolean endOfInput)

            final float averageBytesPerChar() // + maxBytesPerChar

        h3 StandardCharsets
        p 표준 문자집합 : US-ASCII(= ISO646-US), ISO-8859-1(= ISO-LATIN-1), UTF-8, UTF-16BE, UTF-16LE, UTF-16

    h1 java.nio.file
    div
        h2 파일 감시 관련
        div
            h3 Watchable
            p WatchService에 등록되어 그 변화나 이벤트가 감시될 수 있는 객체. 정의된 register 메서드는 등록되었음을 WatchKey 객체로 반환한다.
            +asCode('java') WatchKey register(WatchService watcher, WatchEvent.Kind&lt;?>... events)

            h3 WatchEvent&lt;T>
            +asCode('java').
                WatchEvent.Kind&lt;T> kind()
                int count() // 1보다 크면 반복 이벤트
                T context()
            div
                h4 WatchEvent.Kind&lt;T>
                p 식별을 위한 이벤트 종류

                h4 WatchEvent.Modifier
                p Watchable 객체가 어떻게 등록되었는지

            h3 StandardWatchEventKinds
            ol
                li public static final WatchEvent.Kind&lt;Object> OVERFLOW : 자리가 없어 이벤트가 버려짐.
                li public static final WatchEvent.Kind&lt;Path> ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY : 디렉터리 생성/삭제/변경

            h3 WatchKey
            ol
                li WatchService에 Watchable 객체가 등록되었음을 표현하는 토큰.
                li 처음 생성되면 ready 상태. 이벤트를 감지하면 reset()되기 전까지 signalled 상태가 되고, WatchService 큐에 진입하여 처리된다. reset()되면 다시 ready.

            h3 WatchService
            p 스레드-안전. FileSystem#newWatchService 메서드로 획득한다
            +asCode('java').
                WatchKey poll()
                    // 다음 WatchKey를 제거. 없으면 null.
                WatchKey poll(long timeout, TimeUnit unit)
                    // 다음 WatchKey를 제거. 없으면 대기. timeout 후에도 없으면 null.
                WatchKey take()
                    // 다음 WatchKey를 제거. 없으면 대기.

        h2 파일 순회 관련
        div
            h3 DirectoryStream&lt;T>
            ol
                li Files#newDirectoryStream 메서드로 획득
                li 일회용 이터러블이다. 2번째 호출부터는 IllegalStateException 발생

            h3 SecureDirectoryStream&lt;T>
            ol
                li 열린 디렉터리에 대한 상대 경로를 이용한 연산들을 추가로 지원한다
                li OS에서 이를 지원한다면, Files#newDirectoryStream 메서드로 획득한 DirectoryStream은 SecureDirectoryStream이다
            +asCode('java').
                SecureDirectoryStream&lt;T> newDirectoryStream(T path, LinkOption... options)
                    // path가 절대 경로면 Files#newDirectoryStream과 동일.
                SeekableByteChannel newByteChannel(T path, Set&lt;? extends OpenOption> options, FileAttribute&lt;?>... attrs)
                    // path가 절대 경로면 Files#newByteChannel과 동일. path에 해당하는 파일을 열거나 만든 뒤, 파일에 대한 채널을 반환한다

                void deleteFile(T path)
                    // Files#delete와 다르게 path가 디렉터리인지 확인하지 않는다. 이로써 디렉터리가 실제로 지워지는 지는 시스템에 의존적이다. 심볼릭 링크의 경우 링크 자체만 지운다.
                void deleteDirectory(T path)
                    // Files#delete와 다르게 path가 디렉터리인지 확인하지 않는다. 이로써 일반 파일이 지워지는 지는 시스템에 의존적이다.
                void move(T srcpath, SecureDirectoryStream&lt;T> targetdir, T targetpath)
                    // ATOMIC_MOVE 옵션이 적용된 Files#move와 비슷하게 작업한다. 현재 디렉터리를 기준으로, 파일 하나를 다른 디렉터리에 대한 상대경로가 지정하는 위치에 원자적으로 옮긴다

            h3 FileVisitor&lt;T>
            p Files#walkFileTree 메서드에 사용

            h3 SimpleFileVisitor&lt;T>
            ol
                li preVisitDirectory : CONTINUE 반환
                li visitFile : CONTINUE 반환
                li visitFileFailed : rethrow
                li postVisitDirectory : 예외없으면 CONTINUE, 있으면 rethrows

            h3 FileVisitResult
            ol
                li CONTINUE : 순회 계속.
                li TERMINATE : 순회 종료
                li SKIP_SUBTREE : FileVIsitor#preVisitDirectory에서 반환된 경우, 하위 레벨 트리는 순회하지 않는다
                li SKIP_SIBLINGS : 현재 요소가 포함된 디렉터리 내부에서, 현재 요소와 동일한 레벨의 요소들은 더 이상 순회하지 않는다.
                p FileVIsitor#preVisitDirectory에서 반환된 경우, 현재 디렉터리의 내부 요소들과 postVisitDirectory 모두 건너뛴다

        h2 옵션 관련
        div
            h3 CopyCption
            h3 StandardCopyOption
            +asCode('java') REPLACE_EXISTING, COPY_ATTRIBUTES, ATOMIC_MOVE

            h3 OpenOption
            h3 StandardOpenOption
            ol
                li READ : 읽기
                li WRITE : 쓰기
                li APPEND : TRUNCATE_EXISTING 옵션이 있거나 읽기 전용일 때는 적용되지 않는다
                li TRUNCATE_EXISTING : 파일을 열 때 크기를 0바이트로 줄인다. 읽기 전용으로 열 때는 적용되지 않는다.
                li CREATE : 기존 파일이 존재하면 열고, 없으면 새로 생성한다.
                li CREATE_NEW : 신규 파일을 생성한다. 기존 파일이 존재하면 실패한다.
                li DELETE_ON_CLOSE : close() 호출 시 파일을 지운다(best effort)
                li SPARSE : 파일이 sparse임을 OS에 알려준다. 신규 파일을 생성하는 경우에만 유효하다.
                li SYNC : 파일 내용 및 메타데이터의 변경을 동기적으로 물리 장치에 기록한다
                li DSYNC : 파일 내용 변경을 동기적으로 물리 장치에 기록한다

            h3 FileVisitOption
            p FOLLOW_LINKS : 심볼릭 링크를 따라 들어가는 경우

            h3 LinkOption
            p NOFOLLOW_LINKS : 심볼릭 링크를 따라 들어가지 않는 경우

        h2 파일 시스템 관련
        div
            h3 Path
            p 파일 경로를 가리킨다. 사용자 정의 파일 시스템을 개발하기 위해 만들어짐.
                +codeBtn('/Repositories/Eclipse/JavaSE/src/nio/PathTest.java', 'java')
            +asCode('java').
                static Path of(String first, String... more)
                    // 예. FileSystem#getSeparator == "/"일때, of("/foo", "bar", "gus") → "/foo/bar/gus"

                static Path of(URI uri)
                    // ↔ toUri

                FileSystem getFileSystem()
                    // 이 Path를 만든 FileSystem 반환
                Path getRoot()
                    // + getFileName, getParent, getNameCount, getName, subpath, toAbsolutePath, toRealPath

                Path normalize()
                    // 불필요한 ".", ".." 제거
                Path resolve(Path other)
                    // 호출한 path를 기준 디렉터리로 하여, other가 가리키는 지점을 단일 Path로 반환한다.
                default Path resolveSibling(Path other)
                    // (getParent() == null) ? other : getParent().resolve(other);
                Path relativize(Path other)
                    // 호출한 path를 기준으로, other에 도달하는 상대경로를 반환한다

            h3 Files
            +asCode('java').
                static InputStream newInputStream(Path path, OpenOption... options)
                    // + newOutputStream, newByteChannel, newBufferedReader, newBufferedWriter

                static DirectoryStream&lt;Path> newDirectoryStream(Path dir, String glob)
                    // 예. Files.newDirectoryStream(dir, "*.java"));
                    // 예. Files.newDirectoryStream(dir, "*.{c,h,cpp,hpp,java}"));

                static Path createFile(Path path, FileAttribute&lt;?>... attrs)
                    // + createDirectory, createDirectories(경로 상의 모든 디렉터리 생성), createTempFile, createTempDirectory, createSymbolicLink, createLink(하드 링크)

                static void delete(Path path)
                    // + deleteIfExists, copy, move

                static bolean isSameFile(Path path, Path path2)
                static long mismatch(Path path, Path path2)
                    // 두 파일이 불일치하는 최초의 바이트 위치를 반환한다. 같으면 -1L.

                static byte[] readAllBytes(Path path)
                    // + readString Since 11, lines, readAllLines
                static Path write(Path path, Iterable&lt;? extends CharSequence> lines, OpenOption... options)
                static Path writeString(Path path, CharSequence csq, Charset cs, OpenOption... options) // Since 11

                static boolean isHidden(Path path)
                    // + isDirectory, isSymbolicLink, isRegularFile, exists, notExists, isReadable, isWritable, isExecutable
                static String probeContentType(Path path)
                    // + getFileAttributeView, readAttributes, getAttribute, setAttribute, getLastModifiedTime, setLastModifiedTime, size

                static Stream&lt;Path> list(Path dir)
                static Stream&lt;Path> walk(Path start, int maxDepth, FIleVisitOption... options)
                    // + walkFileTree
                static Stream&lt;Path> find(Path start, int maxDepth, BiPredicate&lt;Path, BasicFileAttributes> matcher, FIleVisitOption... options)

            h3 FileSystems
            p FileSystem 팩터리
            +asCode('java').
                static FileSystem getDefault()
                static FileSystem getFileSystem(URI uri)
                static FileSystem newFileSystem(Path path, ClassLoader loader)

    h1 java.security
    div
        h2 암호적으로 안전한 난수 생성기
        div
            h3 SecureRandomParameters
            p SecureRandom 메서드 인자임을 나타내는 마커 인터페이스

            h3 SecureRandom
            ol
                li 비결정적인 출력을 위해, 전달되는 시드 역시 예측할 수 없어야 한다
                p 시드를 제공하지 않은 경우, 최초 nextBytes 호출 시 구현체에서 정의하는 엔트로피 소스로부터 시드를 선택한다
                li SecureRandom 인스턴스는 스레드-안전하다
                +codeBtn('/Repositories/Eclipse/JavaSE/src/security/SecureRandomTest.java', 'java')
            +asCode('java').
                static SecureRandom getInstance(String algorithm)
                    // https://docs.oracle.com/en/java/javase/12/docs/specs/security/standard-names.html#securerandom-number-generation-algorithms
                static SecureRandom getInstance(String algorithm, SecureRandomParameters params)
                    // SecureRandom.getInstance("DRBG", DrbgParameters.instantiation(128, RESEED_ONLY, null));
                static SecureRandomParameters getInstanceStrong()

                void reseed()
                    // 엔트로피 소스로부터 시드 재선택
                void nextBytes(byte[] bytes)
                    // + generateSeed

            h3 DrbgParameters
            ol
                li DRBG; Deterministic Random Bit Generator 이용을 위한 파라미터
                p 기본 파라미터 외에 직접 지정하고 싶은 경우, 메서드의 SecureRandomParameters 파라미터로 넘기면 된다
                +asCode('java').
                    var drbg = SecureRandom.getInstance("DRBG", DrbgParameters.instantiation(112, NONE, null));
                        // Weak DRBG 인스턴스. 112비트 보안 강도
                    drbg.nextBytes(buffer, DrbgParameters.nextBytes(256, false, "more".getBytes()));
                        // 보안 강도 112비트를 초과하여 실패
                    drbg.nextBytes(buffer, DrbgParameters.nextBytes(112, true, "more".getBytes()));
                        // 예측 저항(PR_AND_RESEED) 없으므로 실패
                li 시스템 속성
                p securerandom.drbg.config → 기본값 : Hash_DRBG with SHA-256
            div
                h4 Nested Classes
                +asCode('java').
                    static final class DrbgParameters.Instantiation implements SecureRandomParameters
                        // DRBG 인스턴스 생성 시 사용.
                    static enum DrbgParameters.Capability {
                        NONE(예측 저항 x, reseed x), PR_AND_RESEED(예측 저항 o, reseed o), RESEED_ONLY(예측 저항 x, reseed o)
                    }
                    static final class DrbgParameters.Reseed implements SecureRandomParameters
                        // DRBG 인스턴스 reseed에 이용
                    static final class DrbgParameters.NextBytes implements SecureRandomParameters
                        // DRBG 인스턴스의 랜덤 비트열 생성에 이용

    h1 java.text
    div
        h2 Format
        ol
            li 자바에서 제공하는 주요 Format 서브 클래스는 DateFormat, MessageFormat, NumberFormat
            li 콘크리트 서브 클래스는 아래 3개 메서드를 반드시 구현해야 한다
            +asCode('java').
                format(Object, StringBuffer, FieldPosition)
                formatToCharacterIterator(Object)
                parseObject(String, ParsePosition)

        h2 Normalizer
        ol
            li 유니코드
                +asA('https://ko.wikipedia.org/wiki/유니코드_정규화', '정규화/역정규화')
                |  관련 기능을 제공한다.
        +asCode('java').
            static enum Normalizer.Form {
                NFC, NFD, NFKC, NFKD
            }

            static String normalize(CharSequence src, Normalizer.Form form)
                // + isNormalized

        h2 NumberFormat
        p: +codeBtn('/Repositories/Eclipse/JavaSE/src/text/NumberFormatTest.java', 'java')
        +asCode('java').
            static enum NumberFormat.Style {
                SHORT, LONG
            }
            static class NumberFormat.Field
                INTEGER(정수부), FRACTION(분수), EXPONENT(지수부), DECIMAL_SEPARATOR(소수 구분 기호), SIGN(부호), GROUPING_SEPARATOR(단위 구분 문자), EXPONENT_SYMBOL, PERCENT, PERMILLE, CURRENCY, EXPONENT_SIGN, PREFIX, SUFFIX
            }

            static final NumberFormat getInstance(Locale inLocale)
                // + getNumberInstance : 범용
                // + getIntegerInstance : 포맷에 HALF_EVEN을 이용하고, 파싱은 정수부만

        h2 SimpleDateFormat
        table
            tr
                th 문자
                th 표현요소
                th 예
            tr
                th G
                td 기원 전/후
                td AD
                    +codeBtn('/Repositories/Eclipse/JavaSE/src/text/SimpleDateFormatTest.java', 'java', '[18,23]') 예
            tr
                th y
                td 년
                td 1996; 96
                    +codeBtn('/Repositories/Eclipse/JavaSE/src/text/SimpleDateFormatTest.java', 'java', '[26,31]') 예
            tr
                th Y
                td Week year
                td 2009; 09
                    +codeBtn('/Repositories/Eclipse/JavaSE/src/text/SimpleDateFormatTest.java', 'java', '[34,43]') 예
            tr
                th M
                td 월(context sensitive)
                td July; Jul; 07
                    +codeBtn('/Repositories/Eclipse/JavaSE/src/text/SimpleDateFormatTest.java', 'java', '[26,31]') 예
            tr
                th L
                td 월 (standalone form)
                td July; Jul; 07
            tr
                th w
                td Week in year
                td 27
                    +codeBtn('/Repositories/Eclipse/JavaSE/src/text/SimpleDateFormatTest.java', 'java', '[34,43]') 예
            tr
                th W
                td Week in month
                td 2
            tr
                th D
                td Day in year
                td 189
            tr
                th d
                td Day in month
                td 10
                    +codeBtn('/Repositories/Eclipse/JavaSE/src/text/SimpleDateFormatTest.java', 'java', '[26,31]') 예
            tr
                th F
                td Day of week in month
                td 2
            tr
                th E
                td Day name in week
                td Tuesday; Tue
                    +codeBtn('/Repositories/Eclipse/JavaSE/src/text/SimpleDateFormatTest.java', 'java', '[34,43]') 예
            tr
                th u
                td Day number of week
                td 1 = Monday, ..., 7 = Sunday
                    +codeBtn('/Repositories/Eclipse/JavaSE/src/text/SimpleDateFormatTest.java', 'java', '[34,43]') 예
            tr
                th a
                td Am/pm
                td PM
                    +codeBtn('/Repositories/Eclipse/JavaSE/src/text/SimpleDateFormatTest.java', 'java', '[46,51]') 예
            tr
                th H
                td Hour in day (0-23)
                td 0
                    +codeBtn('/Repositories/Eclipse/JavaSE/src/text/SimpleDateFormatTest.java', 'java', '[26,31]') 예
            tr
                th k
                td Hour in day (1-24)
                td 24
            tr
                th K
                td Hour in am/pm (0-11)
                td 0
            tr
                th h
                td Hour in am/pm (1-12)
                td 12
                    +codeBtn('/Repositories/Eclipse/JavaSE/src/text/SimpleDateFormatTest.java', 'java', '[46,51]') 예
            tr
                th m
                td Minute in hour
                td 30
                    +codeBtn('/Repositories/Eclipse/JavaSE/src/text/SimpleDateFormatTest.java', 'java', '[26,31]') 예
            tr
                th s
                td Second in minute
                td 55
                    +codeBtn('/Repositories/Eclipse/JavaSE/src/text/SimpleDateFormatTest.java', 'java', '[26,31]') 예
            tr
                th S
                td Millisecond
                td 978
                    +codeBtn('/Repositories/Eclipse/JavaSE/src/text/SimpleDateFormatTest.java', 'java', '[46,51]') 예
            tr
                th z
                td General time zone
                td Pacific Standard Time; PST; GMT-08:00
            tr
                th Z
                td RFC 822 time zone
                td -0800
                    +codeBtn('/Repositories/Eclipse/JavaSE/src/text/SimpleDateFormatTest.java', 'java', '[46,51]') 예
            tr
                th X
                td ISO 8601 time zone
                td -08; -0800; -08:00

        h2 MessageFormat
        +asCode('java').
            MessageFormatPattern ::= String | MessageFormatPattern FormatElement String
            FormatElement        ::= { ArgumentIndex[, FormatType[, FormatStyle]] }
            FormatType           ::= number | date | time | choice
            FormatStyle          ::= short | medium | long | full | integer | currency | percent | SubformatPattern
        ol
            li '' 안의 포맷 문자열은 이스케이프된다
            li 동일 요소에 대한 반복적인 파싱은 마지막 파싱 결과만 유효하다
                +codeBtn('/Repositories/Eclipse/JavaSE/src/text/MessageFormatTest.java', 'java')
        table
            tr
                th FormatType
                th FormatStyle
                th Subformat Created
            tr
                th (none)
                th (none)
                td null
            tr
                th(rowspan='5') number
                th (none)
                td NumberFormat.getInstance(getLocale())
            tr
                th integer
                td NumberFormat.getIntegerInstance(getLocale())
            tr
                th currency
                td NumberFormat.getCurrencyInstance(getLocale())
            tr
                th percent
                td NumberFormat.getPercentInstance(getLocale())
            tr
                th SubformatPattern
                td new DecimalFormat(subformatPattern, DecimalFormatSymbols.getInstance(getLocale()))
            tr
                th(rowspan='6') date
                th (none)
                td DateFormat.getDateInstance(DateFormat.DEFAULT, getLocale())
            tr
                th short
                td DateFormat.getDateInstance(DateFormat.SHORT, getLocale())
            tr
                th medium
                td DateFormat.getDateInstance(DateFormat.DEFAULT, getLocale())
            tr
                th long
                td DateFormat.getDateInstance(DateFormat.LONG, getLocale())
            tr
                th full
                td DateFormat.getDateInstance(DateFormat.FULL, getLocale())
            tr
                th SubformatPattern
                td new SimpleDateFormat(subformatPattern, getLocale())
            tr
                th(rowspan='6') time
                th (none)
                td DateFormat.getTimeInstance(DateFormat.DEFAULT, getLocale())
            tr
                th short
                td DateFormat.getTimeInstance(DateFormat.SHORT, getLocale())
            tr
                th medium
                td DateFormat.getTimeInstance(DateFormat.DEFAULT, getLocale())
            tr
                th long
                td DateFormat.getTimeInstance(DateFormat.LONG, getLocale())
            tr
                th full
                td DateFormat.getTimeInstance(DateFormat.FULL, getLocale())
            tr
                th SubformatPattern
                td new SimpleDateFormat(subformatPattern, getLocale())
            tr
                th choice
                th SubformatPattern
                td new ChoiceFormat(subformatPattern)

    h1 java.time
    div
        h2 Clock
        p 시간대(time-zone)을 이용한 현재의 date와 time 제공. 지정하지 않는 이상, 시계 내부의 시각은 계속 변한다.
            +codeBtn('/Repositories/Eclipse/JavaSE/src/time/ClockTest.java', 'java')
        +asCode('java').
            static Clock system(ZoneId zone)
                // 특정 시간대의 시계 반환
                // systemUTC() == system(ZoneOffset.UTC)
                // systemDefaultZone() == system(ZoneId.systemDefault())

            static Clock tick(Clock baseClock, Duration tickDuration)
                // 지정된 시계의 tick 단위를 조정. 예를 들어 1분이 지정된 경우, 1분 미만의 값은 버려진다.
                // tickMillis(ZoneId zone) == tick(system(zone), Duration.ofMillis(1))

            static Clock fixed(Instant fixedInstant, ZoneId zone)
                // 현재 시각으로 멈춘 시계 반환
            static Clock offset(Clock baseClock, Duration offsetDuration)
                // 시각을 조정한 새로운 시계 반환
            abstract Clock withZone(ZoneId zone)
                // 지정된 시간대에 현재 시계의 복사본을 생성하여 반환한다. 따라서 시각 자체는 조정하지 않는다.

        h2 Duration
        p: +codeBtn('/Repositories/Eclipse/JavaSE/src/time/DurationTest.java', 'java')
        +asCode('java').
            static Duration of(long amount, TemporalUnit unit)
            static Duration from(TemporalAmount amount)
                // amount 그대로 Duration으로 변환
            static Duration parse(CharSequence text)
                // ISO-8601 duration format PnDTnHnMn.nS
                // 추가로 접두 부호 가능
            static Duration between(Temporal startInclusive, Temporal endExclusive)

            Duration withSeconds(long seconds)
                // 나노초 단위만 남기고 seconds로 변경
            Duration withNanos(int nanoOfSecond)
                // 나노초 단위만 nanoOfSecond로 변경

        h2 Instant
        p Epoch(1970-01-01 00:00:00)를 기준으로 한 초(long)와 나노초(int)로 시각을 표현한다. 음수면 epoch 이전
        +asCode('java').
            public static final Instant EPOCH, MIN(아주 먼 옛날), MAX(아주 먼 미래)

            static Instant now()
            static Instant parse(CharSequence text)
                // DateTimeFormatter.ISO_INSTANT
                // 예. 2007-12-03T10:15:30.00Z)

        h2 DayOfWeek
        +asCode('java').
            public static final DayOfWeek MONDAY ~ SUNDAY
            int getValue() // ISO-8601. 1(MONDAY) ~ 7(SUNDAY)

        h2 Month
        +asCode('java').
            public static final Month JANUARY ~ DECEMBER
            int getValue() // ISO-8601. 1(JANUARY) ~ 12(DECEMBER)

    h1 java.time.format
    div
        h2 DateTimeFormatter
        p: +asA('https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/time/format/DateTimeFormatter.html#predefined', 'DateTimeFormatter.html#predefined')
        table
            tr
                th Formatter
                th Description
                th Example
            tr
                th ofLocalizedDate(dateStyle)
                td Formatter with date style from the locale
                td '2011-12-03'
            tr
                th ofLocalizedTime(timeStyle)
                td Formatter with time style from the locale
                td '10:15:30'
            tr
                th ofLocalizedDateTime(dateTimeStyle)
                td Formatter with a style for date and time from the locale
                td '3 Jun 2008 11:05:30'
            tr
                th ofLocalizedDateTime(dateStyle,timeStyle)
                td Formatter with date and time styles from the locale
                td '3 Jun 2008 11:05'
            tr
                th BASIC_ISO_DATE
                td Basic ISO date
                td '20111203'
            tr
                th ISO_LOCAL_DATE
                td ISO Local Date
                td '2011-12-03'
            tr
                th ISO_OFFSET_DATE
                td ISO Date with offset
                td '2011-12-03+01:00'
            tr
                th ISO_DATE
                td ISO Date with or without offset
                td '2011-12-03+01:00'; '2011-12-03'
            tr
                th ISO_LOCAL_TIME
                td Time without offset
                td '10:15:30'
            tr
                th ISO_OFFSET_TIME
                td Time with offset
                td '10:15:30+01:00'
            tr
                th ISO_TIME
                td Time with or without offset
                td '10:15:30+01:00'; '10:15:30'
            tr
                th ISO_LOCAL_DATE_TIME
                td ISO Local Date and Time
                td '2011-12-03T10:15:30'
            tr
                th ISO_OFFSET_DATE_TIME
                td Date Time with Offset
                td '2011-12-03T10:15:30+01:00'
            tr
                th ISO_ZONED_DATE_TIME
                td Zoned Date Time
                td '2011-12-03T10:15:30+01:00[Europe/Paris]'
            tr
                th ISO_DATE_TIME
                td Date and time with ZoneId
                td '2011-12-03T10:15:30+01:00[Europe/Paris]'
            tr
                th ISO_ORDINAL_DATE
                td Year and day of year
                td '2012-337'
            tr
                th ISO_WEEK_DATE
                td Year and Week
                td '2012-W48-6'
            tr
                th ISO_INSTANT
                td Date and Time of an Instant
                td '2011-12-03T10:15:30Z'
            tr
                th RFC_1123_DATE_TIME
                td RFC 1123 / RFC 822
                td 'Tue, 3 Jun 2008 11:05:30 GMT'

    h1 java.util
    div
        h2 Collection API
        div
            h3 컬렉션 자료형 인터페이스
            div
                h4 Collection&lt;E>
                ol
                    li 컬렉션 최소 연산을 정의.
                    li 서브 컬렉션을 작성할 때, 인자없는 생성자와 Collection 인자 하나만 받는 생성자를 각각 작성하도록 권장한다
                    li 정의하지 않아도 되는 선택적 메서드들에 대하여, 구현하지 않는 경우 UnsupportedOperationException을 던져야 한다
                    li 컬렉션이 자기 자신을 요소로 갖는 경우 일부 메서드 실행 중 예외가 발생할 수 있다.
                    p: +codeBtn('/Repositories/Eclipse/JavaSE/src/util/CollectionExample.java', 'java')
                +asCode('java').
                    int size()
                    boolean isEmpty()

                    boolean add(E e)
                    boolean addAll(Collection&lt;? extends E> c)

                    boolean contains(Object o)
                    boolean containsAll(Collection&lt;?> c)

                    boolean retainAll(Collection&lt;?> c)
                        // c에 속한 원소만 남기고 모두 제거한다. 이 연산으로 컬렉션이 변경됐다면 true 반환.
                    boolean remove(Object o)
                    boolean removeAll(Collection&lt;?> c)
                    default boolean removeIf(Predicate&lt;? super E> filter)
                    void clear()

                    Object[] toArray()
                    &lt;T> T[] toArray(T[] a)
                        // 사용 : toArray(new Clazz[0])
                    default &lt;T> T[] toArray(IntFunction&lt;T[]> generator)
                        // 사용 : toArray(Clazz[]::new)

                    default Stream&lt;E> stream()
                    default Stream&lt;E> parallelStream()

                h4 Queue&lt;E>
                +asCode('java').
                    boolean add(E e)   // 추가할 수 없으면 예외 발생. 따라서 반환이 있다면 그 값은 항상 true
                    boolean offer(E e) // 예외 발생하지 않는 add

                    E remove()         // 앞쪽 원소 하나 제거. 없으면 예외.
                    E poll()           // 앞쪽 원소 하나 제거. 없으면 null.

                    E element()        // 앞쪽 원소 하나 제거하지 않고 가져오기. 없으면 예외.
                    E peek()           // 앞쪽 원소 하나 제거하지 않고 가져오기. 없으면 null.

                h4 Deque&lt;E>
                p 양방향 삽입/삭제 가능한 Queue
                +asCode('java').
                    boolean removeFirstOccurrence(Object o)
                        // + removeLastOccurrence
                    Iterator&lt;E> descendingIterator()
                        // iterator()의 역순

                h4 List&lt;E>
                +asCode('java').
                    default void replaceAll(UnaryOperator&lt;E> operator)
                        // 모든 원소를 연산 결과로 대체

                    default void sort(Comparator&lt;? super E> c)

                    int hashCode()
                        // hashCode = 31*hashCode + (e==null ? 0 : e.hashCode());

                    E set(int index, E element) // 이전 값은 반환.

                    int indexOf(Object o)
                        // + lastIndexOf

                    ListIterator&lt;E> listIterator()
                    List&lt;E> subList(int fromIndex, int toIndex)
                p Unmodifiable List
                ul
                    li List#of, List#copyOf는 null 허용하지 않는 변경 불가능한 리스트를 반환한다.
                    li 모든 원소가 serializable하면 반환된 리스트도 그러하다.
                +asCode('java').
                    static &lt;E> List&lt;E> of() // Since 9
                    static &lt;E> List&lt;E> copyOf(Collection&lt;? extends E> coll) // Since 10

                h4 Set&lt;E>
                p Unmodifiable Set
                ul
                    li Set#of, Set#copyOf는 null 허용하지 않는 변경 불가능한 집합을 반환한다.
                    li 모든 원소가 serializable하면 반환된 집합도 그러하다.
                +asCode('java').
                    static &lt;E> Set&lt;E> of() // Since 9
                    static &lt;E> Set&lt;E> copyOf(Collection&lt;? extends E> coll) // Since 10

                h4 SortedSet&lt;E>
                p 원소가 정렬된 Set. 다음 4가지 생성자를 구현할 것을 권장. (void), (Comparator), (Collection), (SortedSet)
                +asCode('java').
                    SortedSet&lt;E> subSet(E fromElement, E toElement)
                        // 부분집합 반환. toElement는 미포함
                        // + headSet, tailSet
                    E first() // + last

                h4 NavigableSet&lt;E>
                +asCode('java').
                    E lower(E e)
                        // e보다 작은 원소들 중 최댓값을 반환. 없으면 null
                        // + floor: &lt;=e, ceiling: >=e, higher: >e

                    NavigableSet&lt;E> descendingSet()
                    Iterator&lt;E> descendingIterator()

                h4 Map&lt;K, V>
                ul
                    li default V getOrDefault(Object key, V defaultValue)
                        +codeBtn('/Repositories/Eclipse/JavaSE/src/util/MapExample.java', 'java', '[12,16]')
                    li V put(K key, V value) : 이전 값은 반환된다.
                    li default V putIfAbsent(K key, V value)
                        +codeBtn('/Repositories/Eclipse/JavaSE/src/util/MapExample.java', 'java', '[18,24]')
                    li default V compute(K key, BiFunction&lt;? super K, ? super V, ? extends V> remappingFunction)
                    p 값을 다시 계산하여 덮어쓴다.
                        +codeBtn('/Repositories/Eclipse/JavaSE/src/util/MapExample.java', 'java', '[26,32]')
                    li default V computeIfAbsent(K key, Function&lt;? super K, ? extends V> mappingFunction) + computeIfPresent
                    p computeIfAbsent : key가 맵에 없거나, 대응하는 값이 null인 경우 새로운 값을 계산하여 넣는다. 계산된 값이 null이면 null 반환. 그 외의 경우 현재값 반환
                        +codeBtn('/Repositories/Eclipse/JavaSE/src/util/MapExample.java', 'java', '[34,56]')
                    p computeIfPresent : key가 존재하고, 대응하는 값이 null이 아닌 경우 새로운 값을 계산하여 넣는다. 키가 존재하면 현재값 반환. 그 외의 경우 null 반환
                    li default V replace(K key, V value) + replaceAll
                    p key가 있을 때만 대체. 없으면 null 반환
                        +codeBtn('/Repositories/Eclipse/JavaSE/src/util/MapExample.java', 'java', '[58,70]')
                    li default V merge(K key, V value, BiFunction&lt;? super V, ? super V, ? extends V> remappingFunction)
                        +codeBtn('/Repositories/Eclipse/JavaSE/src/util/MapExample.java', 'java', '[72,89]')
                    ul
                        li key가 맵에 없거나, 대응하는 값이 null인 경우 : null이 아닌 value로 연결.
                        li 주어진 함수를 통해 새로운 값에 연결
                        li 결과가 null인 경우 맵에서 제거.
                    li Unmodifiable Instance
                    ul
                        li Map#of, Map#ofEntries, Map#copyOf 메서드는 변경 불가능한 맵을 반환한다.
                        p 변경 불가능한 맵은 키와 값 모두 null을 허용하지 않으며, 모든 키와 값이 serializable하면 맵도 그러하다.
                        li Map.Entry#entry 메서드는 변경 불가능한 엔트리를 반환한다.
                div
                    h5 Map.Entry&lt;K, V>
                    +asCode('java').
                        static &lt;K extends Comparable&lt;? super K>, V> Comparator&lt;Map.Entry&lt;K, V>> comparingByKey()
                            // 키를 자연스러운 순서로 비교하는 비교자 반환. 인자 있는 함수의 경우 해당 비교자를 이용.
                            // + comparingByValue

                +pos('SortedMap')
                h4 SortedMap&lt;K, V>
                p 키가 정렬된 Map. 다음 4가지 생성자를 구현할 것을 권장. (void), (Comparator), (Map), (SortedMap)
                +asCode('java').
                    SortedMap&lt;K, V> subMap(K fromKey, K toKey)
                        // 지정된 범위의 키만으로 구성된 서브 맵 반환. toKey는 미포함
                        // + headMap, tailMap

                h4 NavigableMap&lt;K, V>
                +asCode('java').
                    Map.Entry&lt;K, V> lowerEntry(K key)
                        // key보다 작은 키들 중 최댓값에 대한 entry 반환. 없으면 null
                        // + floorEntry: &lt;=key, ceilingEntry: >=key, higherEntry: >key
                    K lowerKey(K key)
                        // key보다 작은 키들 중 최댓값 반환. 없으면 null
                        // + floorKey: &lt;=key, ceilingKey: >=key, higherKey: >key

                    NavigableMap&lt;K, V> descendingMap()
                    NavigableMap&lt;K, V> subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)
                        // + headMap, tailMap

            h3 컬렉션 연산 인터페이스
            div
                h4 Enumeration&lt;E>
                +asCode('java').
                    boolean hasMoreElements()
                    E nextElement()
                    default Iterator&lt;E> asIterator()

                h4 Iterator&lt;E>
                +asCode('java').
                    boolean hasNext()
                    E next()
                    default void remove()
                        // 마지막으로 반환된 원소를 제거. next() 호출 뒤 한 번만 호출 가능.
                    default void forEachRemaining(Consumer&lt;? super E> action)

                h4 ListIterator&lt;E>
                p 양방향으로 이동 가능한 iterator.
                +asCode('java').
                    boolean hasPrevious()
                    E previous()
                    int nextIndex() // + previousIndex
                    void set(E e)   // 마지막으로 반환된 요소를 변경
                    void add(E e)   // next()로 반환될 요소 바로전에 삽입.

                h4 PrimitiveIterator&lt;T, T_CONS>
                ol
                    li 기본 타입의 박싱을 회피하기 위한 이터레이터를 제공한다
                    li OfInt, OfLong, OfDouble이 제공된다
                div
                    h5 PrimitiveIterator.OfInt
                    +asCode('java').
                        int nextInt()
                        default void forEachRemaining(IntConsumer action)

                h4 Spliterator&lt;T>
                ol
                    li Iterator와 마찬가지로 순회를 위한 기능을 제공한다. Iterator와 달리 병렬 순회가 가능하며, 순회 메서드가 hasNext(), next()로 이분화되지 않는다.
                    li 병렬 순회하려는 경우, 동일 Spliterator 객체를 이용하지 말고, 다른 스레드는 trySplit()을 통해 얻은 객체로 순회해야 한다.
                    li 박싱을 피하기 위한 Spliterator를 제공한다. OfInt, OfLong, OfDouble.
                +asCode('java').
                    static int CONCURRENT, DISTINCT, IMMUTABLE, NONNULL, ORDERED, SIZED, SORTED, SUBSIZED

                    boolean tryAdvance(Consumer&lt;? super T> action)
                        // 남은 원소가 존재하면 하나를 소비하고 true 반환. 그 외엔 false
                    default void forEachRemaining(Consumer&lt;? super T> action)

                    Spliterator&lt;T> trySplit()
                        // 이 spliterator를 분리할 수 있다면, 일부분을 분리하여 반환하고, 이 spliterator는 나머지 원소들을 순회한다. 그 외엔 null

                    long estimateSize()
                        // forEachRemaining() 메서드에서 순회할 원소의 수를 예측하여 반환한다. 무한하거나, 알 수 없거나, 계산하는 연산이 비싼 경우 Long.MAX_VALUE를 반환하면 된다.
                    default long getExactSizeIfKnown()
                        // 이 spliterator가 SIZED인 경우 estimateSize()를 반환한다. 그 외엔 -1

                    default Comparator&lt;? super T> getComparator()
                        // 이 spliterator의 소스가 Comparator를 이용해 정렬된(SORTED) 경우, 해당 Comparator를 반환한다. 그 외엔 null, 또는 IllegalStateException
                div
                    h5 Spliterator.OfInt
                    +asCode('java').
                        default boolean tryAdvance(Consumer&lt;? super Integer> action)
                            // action이 IntConsumer 인스턴스면 형변환되어 사용된다.
                            // + forEachRemaining

                h4 RandomAccess
                p 빠른(보통 상수 시간) 임의 접근이 가능한 List를 나타내는 마커 인터페이스

            h3 컬렉션 자료형 콘크리트 클래스
            div
                h4 AbstractMap.SimpleEntry&lt;K, V>
                +asCode('java') public SimpleEntry(K key, V value)

                h4 AbstractMap.SimpleImmutableEntry&lt;K, V>
                +asCode('java') public SimpleImmutableEntry(K key, V value)

                h4 ArrayDeque&lt;E>
                p 가변 길이 배열로 구현한 Deque. 스레드-안전하지 않음.

                h4 ArrayList&lt;E>
                p 가변 길이 배열로 구현한 List. 스레드-안전하지 않음.

                h4 Vector&lt;E>
                p ArrayList와 달리 스레드-안전하다.

                h4 BitSet
                p 각 비트의 기본값은 false. 스레드-안전하지 않음.
                +asCode('java').
                    void andNot(BitSet set)
                        // set에 true로 설정된 모든 index에 대해 false 설정

                    boolean intersects(BitSet set)
                        // 하나라도 true로 일치하는 경우

                    int size()        // 총 비트 수
                    int cardinality() // true 비트 수
                    int length()      // the index of the highest set bit

                h4 EnumMap&lt;K extends Enum&lt;K>, V>
                p Enum을 키로 이용.

                h4 EnumSet&lt;E extends Enum&lt;E>>
                +asCode('java').
                    static &lt;E extends Enum&lt;E>> EnumSet&lt;E> of(E e)
                    static &lt;E extends Enum&lt;E>> EnumSet&lt;E> range(E from, E to)
                    static &lt;E extends Enum&lt;E>> EnumSet&lt;E> noneOf(Class&lt;E> elementType) // 공집합 반환
                    static &lt;E extends Enum&lt;E>> EnumSet&lt;E> allOf(Class&lt;E> elementType)  // 전체 집합 반환
                    static &lt;E extends Enum&lt;E>> EnumSet&lt;E> complementOf(EnumSet&lt;E> s)   // 여집합 반환
                    static &lt;E extends Enum&lt;E>> EnumSet&lt;E> copyOf(Collection&lt;E> c)

                h4 HashMap&lt;K, V>
                p 스레드-안전하지 않음.

                h4 HashSet&lt;E>
                p 스레드-안전하지 않음.

                h4 IdentityHashMap&lt;K, V>
                p 스레드-안전하지 않다. 일반적으로 (k1==null ? k2==null : k1.equals(k2))로 키를 비교하는 것과 달리 (k1==k2)로 비교한다.
                p keySet()으로 반환되는 Set&lt;K>, values()로 반환되는 Collection&lt;V>, entrySet()으로 반환되는 Set&lt;Map.Entry&lt;K, V>> 모두 원소의 비교를 == 연산으로 한다.

                h4 LinkedList&lt;E>
                p List와 Deque을 모두 구현. 스레드-안전하지 않음.

                h4 LinkedHashMap&lt;K, V>
                p 키가 삽입된 순서대로 원소를 유지하는 이중 연결 리스트를 가진다. 키가 존재하는 상황에서 put() 호출로 순서가 변경되지 않는다. 스레드-안전하지 않다.
                +asCode('java').
                    public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder)
                        // accessOrder == true ? 접근 빈도로 정렬 : 삽입 순서로 정렬

                h4 LinkedHashSet&lt;E>
                p 삽입된 순서대로 원소를 유지하는 이중 연결 리스트를 가진다. 원소가 존재하는 상황에서 add() 호출로 순서가 변경되지 않는다. 스레드-안전하지 않다.

                h4 PriorityQueue&lt;E>
                p 우선순위 힙에 기반한 unbounded 우선순위 큐. head가 가장 우선순위가 작은 원소.

                h4 Stack&lt;E>
                p LIFO 스택.
                +asCode('java') int search(Object o) // top으로부터 거리 반환

                h4 TreeMap&lt;K, V>
                p Red-Black tree(이진 탐색 트리의 일종) 기반의 NavigableMap 구현. log(n) 시간의 작업을 보장한다. 스레드-안전하지 않다.

                h4 TreeSet&lt;E>
                p TreeMap 기반의 NavigableSet 구현. 스레드-안전하지 않다.

                h4 WeakHashMap&lt;K, V>
                p key의 존재 여부는 key가 GC 대상이 되는 것에 영향이 없다. key 객체가 유효하지 않게 되면 자동으로 맵에서 삭제한다. key, value 모두에 null을 허용한다. 단, value가 key의 참조를 가지지 않도록 유의해야 한다. 스레드-안전하지 않다.

                h4 Hashtable&lt;K, V&gt;
                p 스레드-안전한 해시 테이블 구현. 스레드-안전할 필요가 없으면 HashMap, 높은 동시성이 요구되는 경우엔 ConcurrentHashMap을 이용하는 것이 좋다.

            h3 유틸리티 클래스
            div
                h4 Collections
                +asCode('java').
                    public static final Set EMPTY_SET   // 변경 불가
                    public static final List EMPTY_LIST // 변경 불가
                    public static final Map EMPTY_MAP   // 변경 불가

                    // 리스트 연산
                    static &lt;T extends Comparable&lt;? super T>> void sort(List&lt;T> list)
                        // T 자체가 Comparable하거나, T에 대한 Comparator를 넘기거나
                    static &lt;T> int binarySearch(List&lt;? extends Comparable&lt;? super T>> list, T key)
                    static void reverse(List&lt;?> list)
                        // + shuffle, swap, fill, rotate
                    static &lt;T> void copy(List&lt;? super T> dest, List&lt;? extends T> src)
                    static &lt;T> boolean replaceAll(List&lt;T> list, T oldVal, T newVal)
                    static int indexOfSubList(List&lt;?> source, List&lt;?> target)
                        // + lastIndexOfSubList
                    static &lt;T> ArrayList&lt;T> list(Enumeration&lt;T> e)

                    // Collection 연산
                    static &lt;T extends Object & Comparable&lt;? super T>> T min(Collection&lt;? extends T> coll)
                    static int frequency(Collection&lt;?> c, Object o)
                    static boolean disjoint(Collection&lt;?> c1, Collection&lt;?> c2)
                        // 공통 원소가 없는지 여부.

                    // 변경 불가능한 Collection Factory
                    static &lt;T> Collection&lt;T> unmodifiableCollection(Collection&lt;? extends T> c)
                        // + ...

                    // Synchronization
                    //     비결정 상태에 빠지는 것을 방지하기 위해, 반환된 컬렉션에 대해 synchronized 제약을 걸고 이용하는 것이 좋다.
                    static &lt;T> Collection&lt;T> synchronizedCollection(Collection&lt;T> c)
                        // + ...

                    // 타입 체킹 추가
                    static &lt;E> Collection&lt;E> checkedCollection(Collection&lt;E> c, Class&lt;E> type)
                        // + ...

                    // Empty Collection(변경 불가)
                    static &lt;T> Iterator&lt;T> emptyIterator()
                        // + ...

                    // Singleton Collection(변경 불가)
                    static &lt;T> Set&lt;T> singleton(T o)
                    static &lt;T> List&lt;T> nCopies(int n, T o)
                    static &lt;T> List&lt;T> singletonList(T o)
                    static &lt;K, V> Map&lt;K, V> singletonMap(K key, V value)

                    // 기타
                    static &lt;T> Comparator&lt;T> reverseOrder()
                        // 자연스러운 비교자의 역 반환.
                    static &lt;T> Comparator&lt;T> reverseOrder(Comparator&lt;T> cmp)
                    static &lt;T> Queue&lt;T> asLifoQueue(Deque&lt;T> deque)
                        // deque에 대한 LIFO view를 Queue로 반환한다.

                h4 Spliterators
                +asCode('java').
                    static &lt;T> Spliterator&lt;T> emptySpliterator()
                        // + emptyIntSpliterator, emptyLongSpliterator, emptyDoubleSpliterator
                    static &lt;T> Spliterator&lt;T> spliterator(Object[] array, int additionalCharacteristics)
                        // Arrays.spliterator()가 제공하는 것에 특성을 추가하고 싶을 때 사용. 전형적으로 IMMUTABLE, ORDERED

                    static &lt;T> Spliterator&lt;T> spliteratorUnknownSize(Iterator&lt;? extends T> iterator, int characteristics)
                        // Spliterator로 래핑한 후에 iterator를 사용하면 안 된다.
                    static &lt;T> Iterator&lt;T> iterator(Spliterator&lt;? extends T> spliterator)
                        // Iterator로 래핑한 후에 spliterator를 사용하면 안 된다.        
                div
                    h5 Spliterators.AbstractSpliterator&lt;T>
                    p estimateSize(), characteristics(), trySplit()을 구현한 추상 클래스

        h2 객체, 배열 관련
        div
            h3 Comparator&lt;T>
            +asCode('java').
                default Comparator&lt;T> reversed()

                default Comparator&lt;T> thenComparing(Comparator&lt;? super T> other)
                    // 이 비교자가 두 객체를 같다고 판단하면, other가 새로 판단한다.
                    // + thenComparingInt, Long, Double

                static &lt;T extends Comparable&lt;? super T>> Comparator&lt;T> naturalOrder()
                    // 자연스러운 비교자를 반환한다.
                    // + reverseOrder

                static &lt;T> Comparator&lt;T> nullsFirst(Comparator&lt;? super T> comparator)
                    // null은 모든 non-null 값보다 작다고 간주한다. null끼리는 서로 같다고 간주한다.
                    // + nullsLast

                static &lt;T, U> Comparator&lt;T> comparing(Function&lt;? super T, ? extends U> keyExtractor, Comparator&lt;? super U> keyComparator)
                    // 정렬에 이용할 키를 생성하는 함수와, 키를 이용해 비교하는 비교자를 넘기면 둘을 포함하는 T타입 비교자를 반환.
                    // + comparingInt, Long, Double

            h3 Arrays
            +asCode('java').
                // 정렬, 검색
                static void sort(int[] a)
                static void parallelSort(byte[] a)
                    // 병합 정렬을 병렬로 수행한다. 모든 병렬 작업은 ForkJoin common pool을 이용해 이루어진다.
                static int binarySearch(long[] a, long key)

                // 변경, 변환
                static void fill(long[] a, long val)
                static &lt;T> void setAll(T[] array, IntFunction&lt;? extends T> generator)
                static &lt;T> void parallelSetAll(T[] array, IntFunction&lt;? extends T> generator)
                static &lt;T> void parallelPrefix(T[] array, BinaryOperator&lt;T> op)
                    // 전체 원소에 순차적으로 연산 적용하여 값 변경. 큰 배열은 루프보다 이게 더 빠르다.

                static String toString(long[] a)
                static String deepToString(Object[] a)
                    // toString(Object[])이 o.toString()을 이용하는 반면 여기서는 String.valueOf(Object)가 이용되고, 원소가 배열인 경우 "[]"를 추가하고 해당 배열의 원소들에 대해 같은 작업을 한다.

                static &lt;T> List&lt;T> asList(T... a)
                static &lt;T> Spliterator&lt;T> spliterator(T[] array)
                    // characteristics()에서 SIZED | SUBSIZED | ORDERED | IMMUTABLE를 반환하는 Spliterator 인스턴스를 반환한다.
                static &lt;T> Stream&lt;T> stream(T[] array)

                // 복사
                static &lt;T, U> T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]> newType)
                static &lt;T> T[] copyOf(T[] original, int newLength)
                static &lt;T, U> T[] copyOfRange(U[] original, int from, int to, Class&lt;? extends T[]> newType)
                static &lt;T> T[] copyOfRange(T[] original, int from, int to)

                // 비교
                static int mismatch(boolean[] a, boolean[] b)  // Since 9
                    // 처음으로 일치하지 않는 인덱스 반환.
                static boolean equals(long[] a, int aFromIndex, int aToIndex, long[] b, int bFromIndex, int bToIndex) // Since 9
                    // Object의 경우, Objects.equals(e1, e2)일 때 같다고 간주한다.
                static boolean deepEquals(Object[] a1, Object[] a2)
                    // null일 수 있는 각 배열의 두 원소 e1, e2에 대하여, 다음 4가지 경우에 대해 둘이 같다고 판단한다.
                    //     1. e1 == e2
                    //     2. 둘 모두 참조변수에 대한 배열이고, Arrays.deepEquals(e1, e2)가 true
                    //     3. 둘 모두 원시타입에 대한 배열이고, Arrays.equals(e1, e2)가 true
                    //     4. e1.equals(e2)가 true

                // 해싱
                static int hashCode(long[] a)
                    // 동일 원소를 가진 List의 해시코드와 동일. null이면 0 반환
                static int deepHashCode(Object[] a)
                    // 원소가 배열인 경우, 해당 원소의 해시를 deepHashCode로 구한다. 자기 자신을 포함하는 배열 등은 적합하지 않다.

            h3 Objects
            +asCode('java').
                // 비교
                static boolean deepEquals(Object a, Object b)
                    // 둘 다 null이면 true. 둘 다 배열이면 Arrays.deepEquals(), 나머진 a.equals(b)
                static &lt;T> int compare(T a, T b, Comparator&lt;? super T> c)

                // hashCode
                static int hash(Object... values)
                    // values가 하나의 배열에 든 것처럼 Arrays.hashCode(Object[])를 이용한다. Object.hashCode()의 간편한 구현으로 이용할 수 있다.
                    // 주의. hashCode(o) != hash(o)

                // toString
                static String toString(Object o, String nullDefault)

                // null
                static boolean isNull(Object obj)
                    // Predicate, filter(Objects::isNull)에 이용
                static &lt;T> T requireNonNull(T obj)
                    // 메서드나 생성자에서 null검사를 하도록 설계되었다.
                static &lt;T> T requireNonNullElse(T obj, T defaultObj) // Since 9
                static &lt;T> T requireNonNullElseGet(T obj, Supplier&lt;? extends T> supplier) // Since 9

                // index
                static int checkIndex(int index, int length)
                    // index가 [0, length)에 존재하면 그대로 반환. 아니면 예외 발생.
                static int checkFromToIndex(int fromIndex, int toIndex, int length)
                    // subrange [fromIndex, toIndex)가 [0, length)에 포함되면 fromIndex 반환. 아니면 예외 발생.
                static int checkFromIndexSize(int fromIndex, int size, int length)
                    // subrange [fromIndex, fromIndex + size)가 [0, length)에 포함되면 fromIndex 반환. 아니면 예외 발생.

            h3 Optional&lt;T> + OptionalInt, OptionalDouble, OptionalLong
            p null을 허용하지 않는 객체에 대한 컨테이너. value-based므로 identity-sensitive한 연산은 피해야 한다.
            +asCode('java').
                static &lt;T> Optional&lt;T> empty()
                static &lt;T> Optional&lt;T> of(T value)
                static &lt;T> Optional&lt;T> ofNullable(T value)
                    // null이면 empty(), 아니면 of(value)

                T get()
                T orElse(T other)
                T orElseGet(Supplier&lt;? extends T> supplier)
                Optional&lt;T> or(Supplier&lt;? extends Optional&lt;? extends T>> supplier)
                    // Since 9, 값이 존재하면 그대로 반환. 없으면 제공되는 값 반환.
                T orELseThrow()
                    // 값이 없으면 NoSuchElementException

                boolean isPresent()
                    // + isEmpty
                void ifPresent(Consumer&lt;? super T> action)
                void ifPresentOrElse(Consumer&lt;? super T> action, Runnable emptyAction)

                Optional&lt;T> filter(Predicate&lt;? super T> predicate)
                    // 값이 존재하고 필터를 통과하면 그대로 반환. 아니면 빈 컨테이너 반환
                Stream&lt;T> stream()
                    // 값이 존재하면 해당 값 하나만 포함하는 스트림 반환. 없으면 빈 스트림 반환.

                &lt;U> Optional&lt;U> map(Function&lt;? super T, ? extends U> mapper)
                &lt;U> Optional&lt;U> flatMap(Function&lt;? super T, ? extends Optional&lt;? extends U>> mapper)
                    // mapper가 반환하는 값 자체가 Optional이므로 map()과 달리 추가적인 Optional로 감싸지 않는다.

        h2 시간 관련
        div
            h3 Date
            +asCode('java').
                long getTime()
                boolean before(Date when)
                static Date from(Instant instant)

            h3 Calendar
            ol
                li 관대함(Leniency) : 범위를 벗어나는 값도 받아들이며, 나중에 정규화한다. 예를 들어 1월 32일은 2월 1일이 된다.
                li add와 roll : add는 오버플로되면 다음 단위가 변하지만, roll은 modulo연산처럼 해당 단위만 변한다.
            div
                h4 Field Detail
                ol
                    li 시간 단위
                    p public static final int ERA, YEAR, MONTH, WEEK_OF_YEAR, WEEK_OF_MONTH_, DATE, ...
                    li 단위 상수
                    p public static final int SUNDAY, ..., JANUARY, ...AM, PM
                    li 스타일
                    p public static final int ALL_STYLES, SHORT, LONG, NARROW_FORMAT, ...
            +asCode('java').
                static Calendar getInstance()
                static Locale[] getAvailableLocales()
                static Set&lt;String> getAvailableCalendarTypes()

                // 달력의 현재 시점을 저장하고 있으므로, 시각 비교, 설정 등의 연산 제공
                final Date getTime()
                int get(int field)
                abstract void add(int field, int amount)
                void roll(int field, int amount)
                abstract void roll(int field, boolean up) // 1 기본단위만큼 up/down

                boolean isLenient()
                int getFirstDayOfWeek()
                int getMinimalDaysInFirstWeek()
                    // 첫 주의 시작이 1월 1일인 경우 1, 그 외의 경우 7
                boolean isWeekDateSupported()
                    // default false
                    // getWeekYear(), setWeekDate(int,int,int), getWeeksInWeekYear() 등을 지원하는지 여부.
            div
                h4 Calendar.Builder
                +asCode('java').
                    Calendar.Builder setInstant(long instant) // 밀리초
                    Calendar.Builder set(int field, int value)
                    Calendar.Builder setFields(int... fieldValuePairs)
                        // 예: setFields(Calendar.YEAR, 2013, Calendar.MONTH, Calendar.DECEMBER, Calendar.DAY_OF_MONTH, 23)
                    Calendar.Builder setTimeZone(TimeZone zone)
                    Calendar.Builder setLenient(boolean lenient) : build()에서 사용된다

            h3 GregorianCalendar
            p GregorianCalendar는 아래 메서드를 지원한다.
            +asCode('java').
                int getWeekYear()
                void setWeekDate(int weekYear, int weekOfYear, int dayOfWeek)
                int getWeeksInWeekYear()
                final Instant toInstant()
                int getActualMaximum(int field)
                int getActualMinimum(int field)

            h3 Timer
            ol
                li 백그라운드 스레드에서 미래에 실행될 작업들을 스케쥴링하는 기능을 제공한다. 작업은 일회용일수도, 일정한 주기를 가지고 반복될 수도 있다. 한 타이머의 모든 작업들은 하나의 백그라운드 스레드를 공유하기 때문에, 작업의 실행은 직렬적이며, 따라서 각 작업들은 가능한 한 빠르게 종료되어야 한다. 그렇지 않은 경우, 뒤에 대기하는 모든 작업이 밀려 제대로 실행되지 않을 수 있다.
                li 스레드-안전하다. 정시성을 보장하지 않는다. 스케쥴은 Object.wait(long) 메서드를 통해 이루어진다. java.util.concurrent 패키지의 ScheduledThreadPoolExecutor가 더 나은 대안으로 이용될 수 있다.
                li 기본적으로 타이머의 백그라운드 스레드는 데몬 스레드가 아니다. 따라서 타이머의 작업이 전체 프로그램의 종료를 지연시킬 수 있다. 백그라운드 스레드는 타이머 임의의 생성자에 의해 시작된다.
            +asCode('java').
                void schedule(TimerTask task, long delay)
                    // delay밀리초 이후 task가 실행되도록 스케쥴.
                void schedule(TimerTask task, Date time)
                    // time에 task가 실행되도록 스케쥴. time이 과거라면 즉시 실행
                void schedule(TimerTask task, long delay, long period)
                    // delay밀리초 이후 period 주기를 갖고 task가 실행되도록 스케쥴.
                void schedule(TimerTask task, Date firstTime, long period)
                    // firstTime 이후 period 주기를 갖고 task가 실행되도록 스케쥴.
                void scheduleAtFixedRate(TimerTask task, long delay, long period)
                    // period가 이전 task 종료가 아닌 최초 실행 시점을 기준으로 작동한다. 따라서 어떤 이유로 이전 작업이 지연된 경우, 시간당 작업률을 맞추기 위해 이후 작업이 연속적으로 실행될 수 있다.
                void cancel()
                    // 타이머를 종료한다. 스케쥴된 모든 작업을 버리고, 현재 실행중인 작업에는 간섭하지 않는다. 타이머 종료 후 백그라운드 스레드도 우아하게 종료되어 GC 대상이 된다. 이후 더 이상의 스케쥴은 불가능하다.
                int purge()
                    // 호출할 일이 거의 없는 메서드. 많은 작업을 한번에 취소한 경우, 취소한 작업들을 제거하여 참조가 없는 경우 GC 대상이 되도록 한다.

            h3 TimerTask
            p Timer 작업으로 사용하기 위한 Runnable
            ol
                li boolean cancel()
                ul
                    li 작업을 취소한다.
                    li 작업이 1회용으로 스케쥴되었지만 아직 실행되지 않은 경우, 또는 아직 스케쥴되지 않은 경우 작업은 결코 실행되지 않는다.
                    li 반복 작업으로 스케쥴된 경우, 작업은 결코 반복되지 않는다.
                    li 작업 도중에 호출된 경우, 작업은 마무리까지 실행된다.
                    li 반복 호출 가능하며 2회째 호출부터는 아무런 영향이 없다.
                    li true 반환 : 1회용으로 스케쥴되었지만 아직 실행되지 않은 경우, 반복 작업으로 스케쥴된 경우
                    li false 반환 : 1회용으로 스케쥴되어 이미 실행된 경우, 아직 스케쥴되지 않은 경우, 이미 취소된 경우
                li long scheduledExecutionTime()
                p 가장 최근에 스케쥴된 ─ 또한 실제로 실행된 ─ 시점을 반환한다. 전형적으로 run 메서드에서, 작업이 너무 길어지는 것을 방지하기 위해 사용된다.

        h2 숫자 관련
        div
            h3 DoubleSummaryStatistics
            ol
                li double에 관한 통계를 모은 상태 객체. 스트림과 함께 사용되도록 설계되었다.
                +asCode('java').
                    var stats = doubleStream.collect(DoubleSummaryStatistics::new, DoubleSummaryStatistics::accept, DoubleSummaryStatistics::combine);
                    var stats = people.stream().collect(Collectors.summarizingDouble(Person::getWeight));
            +asCode('java').
                public DoubleSummaryStatistics()
                    // 개수 0, 합계 0, 최솟값 Double.POSITIVE_INFINITY, 최댓값 Double.NEGATIVE_INFINITY, 평균 0인 객체 생성.
                    // + (long count, double min, double max, double sum)
                void accept(double value)
                    // 요약 정보에 value를 추가

            h3 Random
            +asCode('java').
                public Random()
                    // 의사난수 생성기. 스레드-안전하지만 성능 저하 가능성이 있으므로 ThreadLocalRandom을 고려할 것.

                void nextBytes(byte[] bytes)
                double nextGaussian()
                    // 평균 0, 표준분산 1인 정규분포 난수 반환

                // 난수 스트림 : + Long, Double 버전 존재
                IntStream ints(long streamSize)
                IntStream ints() // == ints(Long.MAX_VALUE)
                IntStream ints(long streamSize, int randomNumberOrigin, int randomNumberBound) // [origin, bound)

            h3 SplittableRandom
            +asCode('java').
                public SplittableRandom()
                    // 분열하는 의사난수 생성기. 스레드-안전하지 않으며, 분열하여 스레드들이 각자 하나씩 갖도록 설계되었다.

                SplittableRandom split()
                    // 분열. 상태를 공유하진 않지만, 생성한 난수는 통계적으로 유사한 속성을 갖는다.

        h2 문자열 및 국제화 관련
        div
            h3 Base64
            p Base64 인코더와 디코더를 반환하는 유틸리티. RFC 2045, 4648
            +asCode('java').
                static Base64.Encoder getEncoder()
                static Base64.Encoder getUrlEncoder()
                static Base64.Encoder getMimeEncoder()
                static Base64.Encoder getMimeEncoder(int lineLength, byte[] lineSeparator)
                static Base64.Decoder getDecoder()
                static Base64.Decoder getUrlDecoder()
                static Base64.Decoder getMimeDecoder()
            div
                h4 Base64.Encoder
                +asCode('java').
                    byte[] encode(byte[] src)
                    String encodeToString(byte[] src)
                        // new String(encode(src), StandardCharsets.ISO_8859_1)
                    OutputStream wrap(OutputStream os)
                    Base64.Encoder withoutPadding()

                h4 Base64.Decoder
                +asCode('java').
                    byte[] decode(byte[] src)
                    InputStream wrap(InputStream is)

            h3 Locale
            p public static final Locale US, ENGLISH, KOREA, KOREAN, ...

            h3 Scanner
            ol
                li 정규 표현식을 통해 원시 타입과 String을 분리해내는 간단한 text scanner.
                li 지정되지 않은 경우, 기본 구분자 패턴은 공백 문자(Character::isWhitespace)
                li 기저 스트림으로부터 입력을 대기하는 동안 스레드가 블록될 수 있다.
                li 기저 Readable의 read()에서 IOException이 발생한 경우 소스의 끝에 도달했다고 판단하며, 가장 최근의 예외는 ioException()을 통해 얻을 수 있다
                li 기저 스트림이 Closeable인 경우, Scanner에 대해 close()가 호출되면 기저 스트림도 닫힌다
            +asCode('java').
                public Scanner(Readable source)
                public Scanner(InputStream source)
                public Scanner(File source)
                public Scanner(Path source)
                public Scanner(String source)
                public Scanner(ReadableByteChannel source)

                Pattern delimiter() // + useDelimiter
                Locale locale()     // + useLocale
                int radix()         // + useRadix

                String findInLine(Pattern pattern)
                    // 구분자를 무시하고 pattern을 검색한다. 줄 바꿈 문자 전에 문자열을 찾으면 해당 문자열을 반환하고 다음 라인으로 넘어간다. 줄 바꿈 문자를 만날 때까지 매칭이 없으면 읽기 위치는 변경없이 null을 반환한다.
                String findWithinHorizon(Pattern pattern, int horizon)
                    // 구분자를 무시하고 pattern을 검색한다. 현재 위치로부터 최대 horizon개의 code point만을 검색에 이용한다. horizon == 0인 경우, 제한없이 검색을 수행한다. 매칭된 문자열이 없으면 읽기 위치 변경없이 null을 반환한다.
                Scanner skip(Pattern pattern)
                    // 구분자를 무시하고 pattern을 검색한다. 매칭된 문자열이 있으면 건너뛰고, 없으면 읽기 위치 변경 없이 NoSuchElementException 발생.
                MatchResult match()
                    // 가장 최근의 매칭 결과를 반환한다. MatchResult는 각종 next, findInLine, findWithinHorizon, skip 메서드의 성공적인 실행으로 설정된다.
                Stream&lt;MatchResult> findAll(Pattern pattern)
                    // 스트림의 MatchResult 순서는 findWithinHorizon(pattern, 0), match()를 반복적으로 호출한 것과 동일하다.

                Stream&lt;String> tokens()
                    // 구분자로 자른 문자열들의 스트림을 반환한다
                Scanner reset()
                    // scanner.useDelimiter("\\p{javaWhitespace}+").useLocale(Locale.getDefault(Locale.Category.FORMAT)).useRadix(10);

        h2 Properties
        p stream을 통해 로드/저장되는 영구적인 속성값들을 표현. 기본값으로 이용하기 위해 다른 Properties를 포함할 수 있다. 스레드-안전하다.
        +asCode('java').
            Object setProperty(String key, String value)
            String getProperty(String key, String defaultValue)

            void list(PrintStream out) // 디버깅에 유용

            void load(Reader reader)
            void store(Writer writer, String comments)
            void loadFromXML(InputStream in)
            void storeToXML(OutputStream os, String comment)

        h2 UUID
        p + com.fasterxml.uuid, com.datastax.cassandra
        +asCode('java').
            public UUID(long mostSigBits, long leastSigBits)
                // 2개 long을 이용해 128비트 UUID 생성
            static UUID randomUUID()
                // version 4 UUID 생성
            static UUID nameUUIDFromBytes(byte[] name)
                // version 3 UUID 생성
            static UUID fromString(String name)

            int version()
                // 1 Time-based UUID
                // 2 DCE security UUID
                // 3 Name-based UUID
                // 4 Randomly generated UUID

            int variant()
                // 0 Reserved for NCS
                // 2 RFC 4122(이 클래스에서 사용)
                // 6 Reserved for Microsoft
                // 7 Reserved for future

            long timestamp()
                // 60비트로 구성된 Time-based UUID의 시각을 반환한다. 1582-10-15 00:00:00 UTC로부터 몇 100ns가 흘렀는지를 의미한다
            long node()
                //Time-based UUID의 48비트 Mac address를 반환한다.

    h1 java.util.concurrent
    div
        h2 Callable&lt;V>
        +asCode('java') V call() // 매개변수 없는, 결과를 반환하는 작업을 정의. Runnable과 달리 checked 예외를 던져도 된다.

        h2 ThreadFactory
        +asCode('java') Thread newThread(Runnable r)

        h2 비동기 자료형 관련
        div
            h3 Future&lt;V>
            p 비동기적 계산의 결과를 표현. 결과는 오직 get 메서드로만 얻을 수 있으며, 필요하다면 결과가 준비될 때까지 블록시킨다.
            +asCode('java').
                boolean cancel(boolean mayInterruptIfRunning)
                    // 작업이 완료됐거나 이미 취소된 경우 false를 반환한다. 이 메서드가 종료된 후의 isDone()은 항상 true.
                boolean isDone()
                V get()
                    // 결과가 준비될 때까지 대기
                V get(long timeout, TimeUnit unit)
                    // 결과가 준비될 때까지 최대 timeout만큼 대기

            h3 RunnableFuture&lt;V>
            p Runnable한 Future. 즉 비동기 연산과 그 결과를 표현한다.
            +asCode('java') void run() // Future로 하여금 결과를 설정하도록 한다.

            h3 FutureTask&lt;V>
            +asCode('java').
                public FutureTask(Callable&lt;V> callable)
                public FutureTask(Runnable runnable, V result)

                protected void done()           // 완료 상태로 천이되면 호출된다
                protected void set(V v)         // 결과 설정
                protected boolean runAndReset() // 반복 실행 목적

            h3 Delayed
            p 객체가 일정 지연 뒤 작동함을 마킹하는 인터페이스. 이를 구현할 땐 compareTo를 반드시 같이 구현해야 한다.

            h3 ScheduledFuture&lt;V>
            p ScheduledExecutorService의 스케쥴링 결과.

            h3 RunnableScheduledFuture&lt;V>
            p Runnable한 ScheduledFuture

            h3 CompletionStage&lt;T>
            ol
                li 비동기적일 수 있는 계산 단계. 다른 CompletionStage가 완료된 뒤 어떠한 동작을 수행하거나 값을 계산한다.
                p Stage에서 수행되는 연산은 Function, Consumer, Runnable로 표현되어야 한다. 각각은 apply, accept, run 메서드로 stage에 제공된다.
                    br
                    | 연산에 넘겨지는 인자는 트리거 stage의 결과이며, 이를 통해 연산의 pipeline을 만들 수 있다.
                    +codeBtn('/Repositories/Eclipse/JavaSE/src/concurrent/CompletionStageTest.java', 'java')
                li 아래 각 메서드들은 async 버전이 존재한다
            +asCode('java').
                // 이전 연산이 완료되면 그 결과로 fn, action 호출
                &lt;U> CompletionStage&lt;U> thenApply(Function&lt;? super T, ? extends U> fn)
                CompletionStage&lt;Void> thenAccept(Consumer&lt;? super T> action)
                CompletionStage&lt;Void> thenRun(Runnable action)

                // this와 other 모두가 종료되면 그 결과로 fn, action 호출
                &lt;U, V> CompletionStage&lt;V> thenCombine(CompletionStage&lt;? extends U> other, BiFunction&lt;? super T, ? super U, ? extends V> fn)
                &lt;U> CompletionStage&lt;Void> thenAcceptBoth(CompletionStage&lt;? extends U> other, BiConsumer&lt;? super T, ? super U> action)
                CompletionStage&lt;Void> runAfterBoth(CompletionStage&lt;?> other, Runnable action)

                // this나 other 둘 중 하나라도 종료되면 그 결과로 fn, action 호출
                &lt;U> CompletionStage&lt;U> applyToEither(CompletionStage&lt;? extends T> other, Function&lt;? super T, U> fn)
                CompletionStage&lt;Void> acceptEither(CompletionStage&lt;? extends T> other, Consumer&lt;? super T> action)
                CompletionStage&lt;Void> runAfterEither(CompletionStage&lt;?> other, Runnable action)

                // this의 결과를 인자로 fn이 반환하는 CompletionStage가 실행되고, 실행된 결과와 같은 값으로 종료되는 CompletionStage를 반환한다
                &lt;U> CompletionStage&lt;U> thenCompose(Function&lt;? super T, ? extends CompletionStage&lt;U>> fn)

                // this가 종료되면 결과와 예외를 인자로 fn을 실행하고, fn의 결과로 반환된 stage를 종료한다.
                &lt;U> CompletionStage&lt;U> handle(BiFunction&lt;? super T, Throwable, ? extends U> fn)

                // this가 종료되면 결과와 예외를 인자로 action을 실행하고, action이 종료되면 반환된 stage도 종료된다.
                CompletionStage&lt;T> whenComplete(BiConsumer&lt;? super T, ? super Throwable> action)

                // this가 예외를 발생하면 그것을 인자로 fn 실행하는 CompletionStage 반환. 예외 발생이 없는 경우, this의 결과와 같은 값으로 반환된 stage가 종료된다.
                CompletionStage&lt;T> exceptionally(Function&lt;Throwable, ? extends T> fn) // Since 12

                // this가 예외를 발생하면 fn이 반환하는 CompletionStage로 구성된다.
                default CompletionStage&lt;T> exceptionallyCompose(Function&lt;Throwable, ? extends CompletionStage&lt;T>> fn) // Since 12

                CompletableFuture&lt;T> toCompletableFuture()

            h3 CompletableFuture&lt;T>
            ol
                li CompletionStage로 이용될 수 있는, 명시적으로 종료(값과 상태를 설정)되는 Future.
                li 둘 이상의 스레드가 complete, completeExceptionally, cancel을 호출할 경우, 하나만 성공한다.
                li non-async 메서드로 등록된 작업은 현재 CompletableFuture가 완료된 스레드 또는 호출자에서 실행된다.
                li 명시적인 Executor 없이 async 메서드로 등록된 작업은 ForkJoinPool#commonPool에서 수행.
                li CompletionStage 메서드들을 독립적으로 구현했기 때문에, 하나를 재정의해도 다른 메서드에 영향이 없다.
                li CompletionStage 메서드들만 이용하도록 하려면 minimalCompletionStage()를, future를 변경하지 못하도록 하려면 copy()를 이용.
                li 전반적인 계산에 대한 직접적인 제어를 할 수 없어서 cancel()의 호출은 completeExceptionally(new CancellationException()) 호출과 동일하다
                li 서브클래스들은 각자의 클래스 인스턴스를 반환하도록 newIncompletableFuture 메서드를 재정의해야 한다
            +asCode('java').
                static &lt;U> CompletableFuture&lt;U> supplyAsync(Supplier&lt;U> supplier)
                    // supplier의 결과를 가지고 비동기 종료되는 CompletableFuture 반환
                static CompletableFuture&lt;Void> runAsync(Runnable runnable)
                    // runnable을 실행하고 비동기 종료되는 CompletableFuture 반환
                static &lt;U> CompletableFuture&lt;U> completedFuture(U value)
                    // 이미 특정 값으로 종료된 CompletableFuture 반환
                static CompletableFuture&lt;Void> allOf(CompletableFuture&lt;?>... cfs)
                    // 모든 cfs가 종료되면 완료되는 새로운 CompletableFuture 객체 반환. 하나라도 예외 종료되면 반환된 CompletableFuture도 그러하다. cfs가 빈 경우, null로 종료된다
                static CompletableFuture&lt;Object> anyOf(CompletableFuture&lt;?>... cfs)
                    // 하나라도 종료되면, 그 결과와 같은 값으로 종료되는 CompletableFuture 객체 반환. cfs가 빈 경우, 완료되지 않는다

                T join()
                    // 종료되면 결과 값 반환, 또는 발생한 예외 던지기. 예외는 CompletionException이고, 기저 예외를 cause로 설정한다
                T getNow(T valueIfAbsent)
                    // 종료되었다면 결과 값 반환, 또는 발생한 예외 던지기. 아니면 valueIfAbsent 반환.
                boolean complete(T value)
                    // 종료되지 않았다면 get()과 연관 메서드들의 반환값을 value로 설정. 이 호출로 CompletableFuture가 완료 상태로 천이되었다면 true 반환.
                boolean completeExceptionally(Throwable ex)
                    // 종료되지 않았다면 get()과 연관 메서드들이 주어진 예외를 던지도록 한다. 이 호출로 CompletableFuture가 완료 상태로 천이되었다면 true 반환.

                boolean isCompletedExeptionally()
                void obtrudeValue(T value)
                    // 강제로 get()과 연관 메서드들의 반환값 설정. 에러 복구를 위해 설계됨.
                    // + obtrudeException
                int getNumberOfDependents()
                    // 종료 대기중인 CompletableFuture의 개수 추정. 동기화가 아닌 시스템 모니터링을 위해 설계됨.

                static Executor delayedExecutor(long delay, TimeUnit unit)
                    // 주어진 딜레이 이후에 executor로 작업을 제출하는 새로운 Executor 반환.
                static &lt;U> CompletionStage&lt;U> completedStage(U value)
                    // 주어진 value로 이미 종료된 새로운 CompletionStage 반환.
                static &lt;U> CompletableFuture&lt;U> failedFuture(Throwable ex)
                    // 주어진 예외로 이미 종료된 새로운 CompletableFuture 객체 반환.
                static &lt;U> CompletionStage&lt;U> failedStage(Throwable ex)
                    // 주어진 예외로 이미 종료된 새로운 CompletionStage 반환.
                &lt;U> CompletableFuture&lt;U> newIncompletableFuture()
                    // 완료되지 않은 새로운 CompletableFuture 객체를 반환한다. 서브클래스들은 각자의 클래스 인스턴스를 반환하도록 newIncompletableFuture 메서드를 재정의해야 한다
                Executor defaultExecutor()

                CompletableFuture&lt;T> copy()
                    // 정상적으로 종료되었다면, 같은 값을 갖는 종료된 CompletableFuture 반환.
                    // 예외 종료되었다면, 해당 예외를 원인으로 한 CompletionException으로 예외 종료된 CompletableFuture 반환. 동작은 thenApply(x -> x)와 같다.
                CompletionStage&lt;T> minimalCompletionStage()
                    // CompletionStage에 정의된 메서드만 이용 가능. 재정의되지 않았다면 toCompletableFuture() 메서드를 통해 그 외의 메서드에 접근 가능하다.

                CompletableFuture&lt;T> completeAsync(Supplier&lt;? extends T> supplier)
                    // 이 CompletableFuture를 supplier의 결과값으로 종료한다.
                CompletableFuture&lt;T> orTimeout(long timeout, TimeUnit unit)
                    // 이 CompletableFuture가 주어진 시간 내에 종료되지 않은 경우, TimeoutException으로 예외 종료한다.
                CompletableFuture&lt;T> completeOnTimeout(T value, long timeout, TimeUnit unit)
                    // 이 CompletableFuture가 주어진 시간 내에 종료되지 않은 경우, value로 종료한다.
            div
                h4 CompletableFuture.AsynchronousCompletionTask
                p 비동기 메서드에서 생성된 비동기 작업을 나타내는 마커 인터페이스

            h3 ForkJoinTask&lt;V>
            ol
                li ForkJoinPool의 실행 단위. 일반적인 스레드보다 훨씬 가벼운 유사-스레드
                li 메인 ForkJoinTask가 존재하여 다른 subtask들을 실행한다
                li 전형적으로는 fork, join 메서드 쌍만 이용하며, a.fork(); b.fork(); b.join(); a.join();처럼 join 순서에 유의
                li RecursiveAction : 반환이 필요없는 경우
                    br
                    | RecursiveTask : 반환이 필요한 경우
                    br
                    | CountedCompleter : 작업의 완료가 다른 작업의 트리거가 되는 경우
            +asCode('java').
                final ForkJoinTask&lt;V> fork()
                    // 작업 시작
                final V join()
                    // 종료 대기 후 결과 반환. 비정상 종료 시 RuntimeException 또는 Error 발생
                final V invoke()
                    // fork + join

                static ForkJoinTask&lt;?> adapt(Runnable runnable)
                static void invokeAll(ForkJoinTask&lt;?>... tasks)
                    // 모든 작업을 시작. 모두 완료되면 반환. 하나라도 예외가 발생하면 rethrow. 예외 종료된 경우 각 작업의 상태는 직접 획득해야 한다.

                final boolean isCompleteNormally()
                    // + isCompletedAbnormally
                final Throwable getException()

            h3 RecursiveAction
            p 재귀적이며 결과없는 ForkJoinTask
                +codeBtn('/Repositories/Eclipse/JavaSE/src/concurrent/RecursiveActionTest.java', 'java')
                br
                | 코드 출처 : https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/concurrent/RecursiveAction.html

            h3 RecursiveTask&lt;V>
            p 재귀적이며 결과가 있는 ForkJoinTask
                +codeBtn('/Repositories/Eclipse/JavaSE/src/concurrent/RecursiveTaskTest.java', 'java')
                br
                | 코드 출처 : https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/concurrent/RecursiveTask.html

            h3 CountedCompleter&lt;T>
            ol
                li 다른 작업들을 기다린 뒤 트리거로 작업을 시작하는 ForkJoinTask
                li Concrete 서브클래스들은 compute() 메서드를 반드시 재정의해야 하며, 되도록이면 반환하기 전에 tryComplete()을 호출해야 한다
                li 일반적으로 CountedCompleter는 결과를 갖지 않겠지만, 결과가 필요한 경우 getRawResult() 메서드를 재정의하면 된다
                li
                    +codeBtn('/Repositories/Eclipse/JavaSE/src/concurrent/CountedCompleterTest.java', 'java', '[14,34,75,85]') 예시 : setPendingCount + tryComplete
                    +codeBtn('/Repositories/Eclipse/JavaSE/src/concurrent/CountedCompleterTest.java', 'java', '[36,54,75,85]') 예시 : addToPendingCount + propagateCompletion
                    +codeBtn('/Repositories/Eclipse/JavaSE/src/concurrent/CountedCompleterTest.java', 'java', '[56,73,75,85]') 예시 : 생성자에서 pendingCount 설정
                    +codeBtn('/Repositories/Eclipse/JavaSE/src/concurrent/CountedCompleterTest.java', 'java', '[87,130]') 예시 : quietlyCompleteRoot
                    +codeBtn('/Repositories/Eclipse/JavaSE/src/concurrent/CountedCompleterTest.java', 'java', '[132,168]') 예시 : compute 사용없이 트리거로만 이용
                    br
                    | 출처 ; https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/concurrent/CountedCompleter.html
            +asCode('java').
                abstract void compute()
                    // 메인 작업

                void onCompletion(CountedCompleter&lt;?> caller)
                    // tryComplete()이 호출되고, 남은 pendingCount가 0이면 호출된다. 또는 complete(T)가 호출된 경우에도 실행된다
                boolean onExceptionalCompletion(Throwable ex, CountedCompleter&lt;?> caller)
                    // compute()에서 예외가 발생했거나, ForkJoinTask#completeExceptionally가 호출된 경우 실행된다. 기본 구현은 return true;
                    // true를 반환하였고, caller가 아직 완료되지 않은 경우, caller도 같은 예외로 종료된다

                final CountedCompleter&lt;?> getCompleter()
                    // 생성자에서 지정한 부모 completer 반환 + getRoot
                final void tryComplete()
                    // pendingCount가 0이 아니면 1 감소시킨다. 0인 경우 onCompletion 메서드를 호출하고, parent completer에 대해서도 tryComplete()을 호출한다
                final void propagateCompletion()
                    // tryComplete()와 같지만, onCompletion 메서드는 호출하지 않는다

                final CountedCompleter&lt;?> firstComplete()
                    // pendingCount가 0이면 return this; 그 외엔 pendingCount를 감소시키고 return null;
                final CountedCompleter&lt;?> nextComplete()
                    // parent completer가 없는 경우, ForkJoinTask#quietlyComplete 호출하고 return null; pendingCount가 0이 아니면 감소시키고 return null;
                    // 그 외엔 parent completer 반환
                for(var c = firstComplete(); c != null; c = c.nextComplete()) { ... }

                final void helpComplete(int maxTasks)
                    // 이 작업이 완료되지 않았다면, completion path 상의 최대 maxTasks개 만큼의 시작되지 않은 작업을 진행시킨다

        h2 Executor 관련
        div
            h3 Executor
            ol
                li 전달받은 Runnable을 실행하는 객체. Executor 자체가 스레드의 병행성을 부여하진 않으며, 구현에서 호출자와 다른 스레드 공간을 마련해주어야 한다.
                li void execute(Runnable command)

            h3 ExecutorService
            ol
                li java.util.concurrent 패키지의 기본적인 Executor 구현.
                    +codeBtn('/Repositories/Eclipse/JavaSE/src/concurrent/ExecutorServiceTest.java', 'java')
            +asCode('java').
                void shutdown()
                    // 추가적인 Runnable을 받지 않는다. 이전에 추가된 것은 마저 실행한다.
                List&lt;&Runnable> shutdownNow()
                    // 실행중인 모든 작업을 중지. 실행 대기중이었던 작업들은 반환.

                boolean isTerminated()
                    // shutdown, shutdownNow 호출 이후 모든 작업이 끝났는지 여부
                boolean awaitTermination(long timeout, TimeUnit unit)
                    // shutdown 요청 후 모든 작업이 종료되기를 기다리며 블록한다. timeout 발생한 경우 false 반환.

                &lt;T> Future&lt;T> submit(Callable&lt;T> task)
                    // 결과를 반환하는 작업을 등록한다. 작업이 성공적으로 종료되면 Future#get으로 결과를 확인할 수 있다.
                &lt;T> Future&lt;T> submit(Runnable atask, T result)
                    // 작업을 등록한다. 작업이 성공적으로 종료되면 Future#get으로 result를 얻을 수 있다.
                Futur&lt;?> submit(Runnable task)
                    // 작업을 등록한다. 작업이 성공적으로 종료되면 Future#get은 null을 반환한다.

                &lt;T> List&lt;Future&lt;T>> invokeAll(Collection&lt;? extends Callable&lt;T>> tasks)
                    // 모든 작업이 종료되면 Future 리스트를 반환한다. 따라서 리스트 안의 각 Future#isDone은 true다.
                &lt;T> List&lt;Future&lt;T>> invokeAll(Collection&lt;? extends Callable&lt;T>> tasks, long timout, TimeUnit unit)
                    // 모든 작업이 종료되거나 timeout이 발생하면 반환. 리스트 안의 각 Future#isDone은 true. timeout 발생 시 완료되지 않은 작업들은 취소된다.
                &lt;T> T invokeAny(Collection&lt;? extends Callable&lt;T>> tasks)
                    // 성공적으로 완료된 첫 작업의 결과를 반환한다. 완료되지 않은 작업들은 취소된다.
                &lt;T> T invokeAny(Collection&lt;? extends Callable&lt;>> tasks, long timeout, TimeUnit unit)
                    // timeout되면 TimeoutException 발생

            h3 ScheduledExecutorService
            p 실행 전에 딜레이를 두거나, 주기적으로 실행을 반복할 수 있는 ExecutorService
            +asCode('java').
                ScheduledFuture&lt;?> schedule(Runnable command, long delay, TimeUnit unit)
                    // 주어진 delay 이후 command가 1회 실행되도록 한다
                ScheduledFuture&lt;?> scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)
                    // 반복되는 작업은 반환된 Future를 통해 취소할 수 있다.
                ScheduledFuture&lt;?> scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)
                    // scheduleAtFixedRate와 달리, 이전 작업이 완료된 후 다음 작업이 시작된다.

            h3 AbstractExecutorService
            p submit, invokeAny, invokeAll 메서드 구현. 반환하는 RunnableFuture에는 FutureTask 이용.

            h3 ThreadPoolExecutor
            ol
                li 각 작업들은 스레드풀의 별개 스레드에서 실행된다
                li Core and maximum pool sizes
                p corePoolSize에 도달할 때까지 신규 작업에 대해 신규 스레드를 할당한다. 대기 중인 스레드가 없으면 maxPoolSize에 도달할 때까지 신규 작업에 대해 신규 스레드를 할당한다
                li On-demand construction
                p 처음부터 corePoolSize만큼의 스레드를 만들어놓을 지를 설정할 수 있다
                li Creating new threads
                p 지정되지 않으면 Executors#defaultThreadFactory로부터 신규 스레드를 생성한다. 동일 스레드그룹 + NORM_PRIORITY + non-daemon
                li Keep-alive times
                p corePoolSize를 초과한 스레드들은 대기 상태가 keepAliveTime을 초과하면 종료된다. allowCoreThreadTimeOut 메서드로 코어 스레드에도 적용할 지 설정 가능
                li Queuing
                ul
                    li 처리를 기다리는 작업들은 BlockingQueue에서 대기한다.
                    li corePoolSize 이상의 스레드가 활성 상태라면 작업은 우선 큐에 진입된다. 큐에 자리가 없으면 신규 스레드가 생성되어 작업을 처리한다.
                    li 큐에 자리도 없고 활성 스레드 수가 maximumPoolSize와 같다면 추가 작업은 거부된다
                    li 큐잉 전략 1. Direct handoff
                    p SynchronousQueue. 작업 가능한 스레드가 없으면 신규로 생성한다. 제한없는 maximumPoolSize 필요
                    li 큐잉 전략 2. Unbounded queue
                    p 무제한으로 큐에 작업을 추가하므로, 활성 스레드의 수는 항상 corePoolSize 이하다
                    li 큐잉 전략 3. Bounded queue
                    p 큐의 크기와 maxPoolSize의 적절한 trade off 필요
                li Rejected tasks
                ul
                    li 거부된 작업에 대하여 RejectedExecutionHandler#rejectedExecution 메서드가 실행된다
                    li 기본 정책. ThreadPoolExecutor.AbortPolicy : 핸들러가 RejectedExecutionException 발생
                    li ThreadPoolExecutor.CallerRunsPolicy : 작업을 제출한 스레드가 직접 작업을 실행한다
                    li ThreadPoolExecutor.DiscardPolicy : 거부된 작업은 버려진다
                    li ThreadPoolExecutor.DiscardOldestPolicy : 신규 작업이 아닌, 큐에서 가장 오래된 작업이 버려진다. 신규 작업은 다시 시도된다
                li Hook methods
                p beforeExecute, afterExecute, terminated 메서드를 재정의하여 작업 전후에 필요한 부분을 실행할 수 있다
            +asCode('java').
                void execute(Runnable command)
                    // command를 언젠가 실행한다. 작업 스레드가 실행하지 못하면, RejectedExecutionHandler가 처리한다
                    // ↔ remove

                void shutdown()
                    // 순차적 종료 절차에 진입한다. 추가 작업은 받지 않고, 이미 제출된 작업들은 마저 처리한다
                List&lt;Runnable> shutdownNow()
                    // 대기 중인 작업에 더해 실행 중인 작업들도 모두 중지한다. 대기중이었던 작업들은 리스트로 반환한다. 실행 중인 작업들에 유예 시간을 주고 싶다면 ExecutorService#awaitTermination 이용
                boolean isTerminating()
                    // shutdown 또는 shutdownNow 메서드가 호출되었지만, 아직 중지가 완료되지는 않았다면 true

                void setThreadFactory(ThreadFactory threadFactory)
                    // + set/getRejectedExecutionHandler, set/getCorePoolSize, set/getMaximumPoolSize, set/getKeepAliveTime
                void allowCoreThreadTimeOut(boolean value)
                    // 코어 스레드에도 keep-alive를 적용할 지 여부

                boolean prestartCoreThread()
                    // 신규 스레드를 하나 생성한다. 이미 corePoolSize 만큼 스레드가 존재한다면 false 반환.
                int prestartAllCoreThreads()
                    // 생성된 스레드의 수가 corePoolSize가 될 때까지 신규 스레드를 생성한다. 신규로 생성된 스레드의 수를 반환한다
                BlockingQueue&lt;Runnable> getQueue()
                               직접 조작하진 말고, 모니터링/디버깅 용도로 이용함이 바람직하다

                int getPoolSize()            // 현재 풀 안의 스레드 수 반환
                int getActiveCount()         // 현재 실행 중인 스레드 수 추정치 반환
                int getLargestPoolSize()     // 풀에 동시에 존재했던 스레드의 최대 개수 반환
                long getTaskCount()          // 실행 스케쥴된 작업의 총 개수의 근사치 반환
                long getCompletedTaskCount() // 실행 완료된 작업의 총 개수의 근사치 반환
            div
                h4 RejectedExecutionHandler
                p ThreadPoolExecutor에서 실행되지 않은 작업에 대한 처리를 위해 사용.

            h3 ScheduledThreadPoolExecutor
            +asCode('java').
                void setContinueExistingPeriodicTasksAfterShutdownPolicy(boolean value)
                    // 기본값 false. true면 shutdownNow가 호출되거나 이 정책이 false가 될 때까지 주기 작업을 계속 실행한다

                void setExecuteExistingDelayedTasksAfterShutdownPolicy(boolean value)
                    // 기본값 true. true면 shutdownNow가 호출되거나 종료 후 이 정책이 false가 되기 전까지는 지연 작업을 실행한다

                void setRemoveOnCancelPolicy(boolean value)
                    // 기본값 false. 취소된 작업을 즉시 큐에서 제거할 것인지, 또는 해당하는 딜레이 후 제거할 것인지 설정.

            h3 CompletionService&lt;V>
            p 생산자가 작업들을 추가하면, 소비자는 그것이 완료된 순서대로 이용할 수 있다.
            +asCode('java').
                Future&lt;V> submit(Callable&lt;V> task)
                Future&lt;V> submit(Runnable task, V result)
                Future&lt;V> take()
                    // 완료된 작업을 가져온다. 없으면 대기한다.
                Future&lt;V> poll()
                    // 완료된 작업을 가져온다. 없으면 null.
                Futur&lt;V> poll(long timeout, TimeUnit unit)

            h3 ExecutorCompletionService&lt;V>
            p CompletionService 구현. 주어진 Executor를 실행에 이용한다. 완료되는 순서대로 작업을 take 메서드로 접근할 수 있는 큐에 배치한다.

            h3 ForkJoinWorkerThread
            p ForkJoinPool에서 ForkJoinTask를 실행하는 스레드
            +asCode('java').
                int getPoolIndex()
                    // 풀 안에서 이 스레드의 번호(Unique)

            h3 ForkJoinPool
            ol
                li ForkJoinTask에 관한 ExecutorService. Non-ForkJoinTask 호출자도 이용할 수 있는 메서드를 제공한다
                p execute(ForkJoinTask), invoke(ForkJoinTask), submit(ForkJoinTask)
                li 모든 ForkJoinWorkerThread는 데몬 스레드로 초기화된다
                li Common pool 튜닝에 관한 시스템 속성
                +asCode('java').
                    java.util.concurrent.ForkJoinPool.common.parallelism
                        // parallelism level. 기본값은 프로세서 수
                    java.util.concurrent.ForkJoinPool.common.threadFactory
                        // class name of a ForkJoinPool.ForkJoinWorkerThreadFactory
                    java.util.concurrent.ForkJoinPool.common.exceptionHandler
                        // class name of a Thread.UncaughtExceptionHandler
                    java.util.concurrent.ForkJoinPool.common.maximumSpares
                        // maximum number of allowed extra threads to maintain target parallelism (default 256).
            +asCode('java').
                static ForkJoinPool commonPool()

                &lt;T> T invoke(ForkJoinTask&lt;T> task)
                void execute(ForkJoinTask&lt;?> task)
                &lt;T> ForkJoinTask&lt;T> submit(ForkJoinTask&lt;T> task)
            div
                h4 ForkJoinPool.ForkJoinWorkerThreadFactory
                +asCode('java') ForkJoinWorkerThread newThread(ForkJoinPool pool)

                h4 ForkJoinPool.ManagedBlocker
                +asCode('java').
                    boolean block()
                        // 필요한 만큼 현재 스레드를 블록시킨다. 추가적인 블로킹이 필요하지 않으면 true 반환
                    boolean isReleasable
                        // 블로킹이 필요없으면 true 반환

            h3 Executors
            +asCode('java').
                // ExecutorService 관련
                static ExecutorService newFixedThreadPool(int nThreads)
                    // 최대 동시 실행 가능한 스레드 수 제한. 나머지 스레드는 큐에서 대기. 스레드들은 명시적으로 shutdown되기 전까지 풀에 존재한다.
                static ExecutorService newWorkStealingPool()
                    // 사용 가능한 프로세서 수를 parallelism level로 이용. 반환되는 객체는 ForkJoinPool 인스턴스
                static ExecutorService newSingleThreadExecutor()
                    // 하나의 워커 스레드만 사용한다. 예기지 않게 워커가 종료되면 새로운 스레드가 나머지 작업을 위해 그 자리를 대신할 수 있다.
                    // 같은 특징을 갖는 newFixedThreadPool(1)과 다르게, 반환된 ExecutorService가 추가적인 워커 스레드를 이용하도록 설정할 수 없다.
                static ExecutorService newCachedThreadPool()
                    // 이전에 종료된 스레드를 재사용. 60초 동안 이용되지 않으면 풀에서 삭제된다.
                static ExecutorService unconfigurableExecutorService(ExecutorService executor)
                    // ExecutorService에 정의된 메서드들은 executor에 연결하고, 그 외 캐스트를 통해 이용할 수 있는 메서드들은 호출하지 못하도록 한다.

                // ScheduledExecutorService 관련
                static ScheduledExecutorService newSingleThreadScheduledExecutor()
                static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)
                static ScheduledExecutorService unconfigurableScheduledExecutorService(ScheduledExecutorService executor)
                    // ScheduledExecutorService에 정의된 메서드들은 executor에 연결하고, 그 외 캐스트를 통해 이용할 수 있는 메서드들은 호출하지 못하도록 한다.

                // ThreadFactory 관련
                static ThreadFactory defaultThreadFactory()
                    // 모든 스레드들을 같은 ThreadGroup으로 생성한다. 스레드의 우선순위는 Threa.NORM_PRIORITY와 그룹의 최대 허용치 중 작은 것으로 설정된다.
                    // 각 스레드들은 non-daemon으로 생성되며, Thread.getName()을 통해 얻을 수 있는 "pool-N-thread-M" 꼴의 이름으로 접근할 수 있다.
                static ThreadFactory privilegedThreadFactory()
                    // 호출하는 스레드와 같은 권한으로 새로운 스레드를 생성하는 ThreadFactory 반환.

                // Callable 관련
                static &lt;T> Callable&lt;T> callable(Runnable task, T result)
                static Callable&lt;Object> callable(Runnable task)
                    // 작업이 완료되면 null을 반환하는 Callable 반환
                static Callable&lt;Object> callable(PrivilegedAction&lt;?> action)
                    // 호출되면 action#run을 실행하고 그 결과를 반환하는 Callable 반환
                static Callable&lt;Object> callable(PrivilegedExceptionAction&lt;?> action)
                static &lt;T> Callable&lt;T> privilegedCallable(Callable&lt;T> callable)
                    // 호출되면 callable을 현재 access control context에서 실행. AccessController.doPrivileged에서 호출되어야 한다.
                static &lt;T> Callable&lt;T> privilegedCallableUsingCurrentClassLoader(Callable&lt;T> callable)

        h2 리액티브 스트림
            +pos('reactive-stream')
        p https://github.com/reactive-streams/reactive-streams-jvm
        +asCode('java').
            final class Flow { // Since 9
                static int defaultBufferSize() // 256
            }
            @FunctionalInterface static interface Flow.Publisher&lt;T> {
                void subscribe(Flow.Subscriber&lt;? super T> subscriber)
            }
        div
           h3 Publisher 규칙
           ol
               li Publisher가 Subscriber에 onNext로 신호를 보낸 횟수 &lt;= Subscriber가 Subscription으로 보낸 request의 횟수
               p 이 규칙은 onNext의 호출에 대하여, 선행되는 request가 항상 존재함을 함의한다
               li Publisher가 onNext로 신호를 보낸 횟수가 request보다 적은 경우, Subscription을 onComplete 또는 onError로 종결한다
               p 이 규칙은 request에 대한 onNext가 항상 존재하지는 않음을 명시한다
               li onSubscribe, onNext, onError, onComplete 신호는 직렬적이어야 한다
               p 결코 다른 신호와 중첩되는 시점이 있어서는 안 된다
               li Publisher의 실패는 반드시 onError로 보내야 한다
               li 스트림이 정상적으로 종결된 경우 Publisher는 반드시 onComplete 신호를 보내야 한다
               li Publisher가 onError, onComplete 신호를 보낸 경우, Subscription은 반드시 취소된 것으로 간주되야 한다
               li 종료 상태(onError, onCompletion)에서 추가적인 신호의 발생은 절대 없다
               li Subscription이 취소된 경우, 추가적인 신호 전달은 절대 없다
               li Publisher.subscribe 안에서 onSubscribe를 반드시 호출해야 하며, 반드시 다른 신호를 보내기 전에 선행되어야 한다. 또, 이 경우 메서드는 반드시 정상 종결되어야 한다
               p Subscriber.onSubscribe 호출 시 null 검사는 필요없다. NullPointerException이 발생하게 내버려두면 된다.
               li Publisher.subscribe는 여러 번 호출될 수 있지만, 하나의 Subscriber로부터는 최대 한 번만 호출되어야 한다
               li Publisher는 여러 Subscriber들에 대한 멀티캐스트를 지원할 수 있다
        +asCode('java').
            static interface Flow.Subsbriber&lt;T> {
                void onSubscribe(Flow.Subscription)
                onNext(T)
                onError(Throwable)
                onComplete(Void)
            }
        div
            h3 Subscriber 규칙
            ol
                li Subscriber는 onNext 신호를 받고 싶다면 반드시 먼저 request 신호를 보내야 한다
                li 신호를 보낼 때, Publisher의 완료를 기다리지 말고 비동기적으로 전달함이 권장된다
                li onComplete, onError 메서드는 절대 Subscription, Publisher 어느쪽의 메서드도 호출해선 안 된다
                li onComplete, onError 신호를 받은 이후부터, Subscription은 반드시 취소로 간주되어야 한다
                li 유효한 Subscription이 존재한다면, 추가적인 onSubscribe 신호에 대해 반드시 cancel을 호출해야 한다
                p 하나의 Subscriber는 둘 이상의 Publisher를 동시에 구독하지 않아야 한다
                li 더 이상 필요없다면 반드시 Subscription.cancel을 호출해야 한다
                li Subscription으로 보내는 신호들은 반드시 직렬적이어야 한다
                p 결코 동시에 두 신호를 보내는 순간은 없어야 한다
                li cancel의 호출은 대기 중인 작업의 취소를 보장하지 않는다. cancel 이후 추가적인 onNext 신호에 대해 준비되어야 한다
                li 아무런 request를 보내지 않았더라도, onComplete, onError 신호에 대해 준비되어야 한다
                li onSubscribe, onNext, onError, onComplete는 인자가 null이 아닌 이상 반드시 정상 종료되어야 한다
                p Subscriber의 실패는 Subscription.cancel로만 통지할 수 있다. 이 규칙이 지켜지지 않은 경우, Subscription은 반드시 취소로 간주되어야 한다
        +asCode('java').
            static interface Flow.Subscription {
                void request(long)
                cancel(Void)
            }
        div
            h3 Subscription 규칙
            ol
                li request, cancel은 반드시 Subscriber가 호출해야 한다
                li onNext, onSubscribe 안에서 동기적으로 request를 호출하는 것은 허용된다
                li cancel의 호출은 멱등이어야 하고, 그 실행은 스레드-안전해야 한다
                li Subscription이 취소됐다면, 이후의 request, cancel의 호출은 아무 작업도 하지 않아야 한다
                li 0이하에 대한 request 호출은 onError로 IllegalArgumentException을 보내야 한다
                li Subscription이 취소됐다면, Publisher는 Subscriber에 대한 모든 참조를 제거해야 한다
                li request, cancel은 항상 정상 종료되어야 한다
                li Subscription은 반드시 무제한적인 request 호출을 허용해야 한다. n == Long.MAX_VALUE

        div
            h3 SubmissionPublisher&lt;T>
            +asCode('java').
                public SubmissionPublisher(Executor executor, int maxBufferCapacity, BiConsumer&lt;? super Flow.Subscriber&lt;? super T>, ? super Throwable> handler)
                    // executor : 비동기적으로 구독자에게 전달하는 데 쓰일 Executor
                    // maxBufferCapacity : 각 구독자에 대한 버퍼의 한도. 실제 한도는 getMaxBufferCapacity()로 확인
                    // handler : null이 아니면 onNext에서 발생한 예외를 처리
                public SubmissionPublisher()
                    // executor = ForkJoinPool.commonPool()
                    // maxBufferCapacity = Flow.defaultBufferSize()
                    // handler = null

                int submit(T item)
                    // 각 구독자에게 비동기적으로 item을 보낸다(onNext). lag(배포된 item 중에 아직 소비되지 않은 개수) 추정치를 반환한다.
                int offer(T item, BiPredicate&lt;Flow.Subscriber&lt;? super T>, ? super T> onDrop)
                    // 가능하다면 각 구독자에게 비동기적으로 item을 보낸다(onNext). 리소스 초과(버퍼가 가득 찼다던지)로 실패한 경우 onDrop이 실행된다. onDrop이 true를 반환하면 onNext를 다시 시도한다.
                    // 반환값이 음수인 경우 drop된 구독자 수를 의미하고, 그 외의 경우 lag(배포된 item 중에 아직 소비되지 않은 개수) 추정치를 의미한다

                long estimateMinimumDemand()
                    // 각 구독자들이 요청한 아이템 수 중, 아직 공급되지 않은 수의 최소값(추정치) 반환
                int estimateMaximumLag()
                    // 각 구독자들에 보낸 아이템 중 아직 소비되지 않은 수의 최대값(추정치) 반환
                CompletableFuture&lt;Void> consume(Consumer&lt;? super T> consumer)
                    // 배포된 모든 아이템에 대해 consumer 실행. 정상적으로 모두 실행되면 onComplete가 호출되고, CompletableFuture도 정상 종료된다

        h2 Blocking 컬렉션
        div
            h3 BlockingQueue&lt;E>
            ol
                li 기본적으로 스레드-안전하지만, addAll 따위의 bulk 연산은 특별히 표시되지 않는 한 그렇지 않다.
                li 요소를 획득할 때, 큐가 비어있는 경우 블로킹. 요소를 추가할 때, 큐에 빈 자리가 있을 때까지 블로킹
            table
                tr
                    th
                    th 예외 발생
                    th 특별값 반환
                    th 블로킹
                    th 시간 제한
                tr
                    th Insert
                    td add(E)
                    td offer(E)
                    td put(E)
                    td offer(E,long,TimeUnit)
                tr
                    th Remove
                    td remove()
                    td poll()
                    td take()
                    td poll(long,TimeUnit)
                tr
                    th Examine
                    td element()
                    td peek()
                    td -
                    td -
            +asCode('java').
                int remainingCapacity()
                    // 블로킹없이 삽입 가능한 요소의 수. 오차가 있을 수 있다
                int drainTo(Collection&lt;? super E> c)
                    // 모든 원소를 c로 옮긴다

            h3 ArrayBlockingQueue&lt;E>
            ol
                li 크기가 고정된 기저 배열을 이용한 BlockingQueue
                li 기본적으로 삽입을 기다리는 스레드들 사이의 처리 순서는 보장되지 않지만, fairness를 설정하면 FIFO 순으로 처리된다
                li Collection, Iterator의 모든 선택적 연산을 구현했다.

            h3 LinkedBlockingQueue&lt;E>
            ol
                li 크기를 고정할 수 있는 연결된 BlockingQueue
                li Collection, Iterator의 모든 선택적 연산을 구현했다

            h3 PriorityBlockingQueue&lt;E>
            ol
                li 크기 제한 없고, PriorityQueue와 비슷한 정렬을 이용한 BlockingQueue
                li Collection, Iterator의 모든 선택적 연산을 구현했다
                p 다만 iterator(), spliterator()로 제공되는 인스턴스들은 순회하는 순서를 보장하지 않는다. 순차적인 순회를 원한다면 Arrays.sort(queue.toArray())를 고려할 것
                li 같은 우선순위의 원소 사이의 정렬은 정의되지 않았다

            h3 SynchronousQueue&lt;E>
            ol
                li 서로 연관된 삽입 연산과 삭제 연산 한 쌍이 동시에 존재할 때까지 연산을 블로킹한다
                li Collection, Iterator의 모든 선택적 연산을 구현했지만, 빈 컬렉션처럼 동작한다
            +asCode('java').
                public SynchronousQueue(boolean fair)
                    // fair : 대기하는 스레드들이 순서대로 처리된다. 지정되지 않으면 false

            h3 DelayQueue&lt;E extends Delayed>
            ol
                li Delayed 요소들로 구성된, 크기 제한없는 BlockingQueue. 요소의 지연 시간이 만료되어야 큐로부터 획득 가능하다
                p 요소가 만료됐음은 getDelay(TimeUnit.NANOSECONDS) 리턴값이 0 이하일 때로 판정
                li Collection, Iterator의 모든 선택적 연산을 구현했다

            h3 BlockingDeque&lt;E>
            p 요소를 획득할 때, 덱이 비어있는 경우 블로킹. 요소를 추가할 때, 덱에 빈 자리가 있을 때까지 블로킹
            table
                tr
                    th
                    th 예외 발생
                    th 특별값 반환
                    th 블로킹
                    th 시간 제한
                tr
                    th Insert
                    td addFirst(E)
                        br
                        | addLast(E)
                    td offerFirst(E)
                        br
                        | offerLast(E)
                    td putFirst(E)
                        br
                        | putLast(E)
                    td offerFirst(E,long,TimeUnit)
                        br
                        | offerLast(E,long,TimeUnit)
                tr
                    th Remove
                    td removeFirst()
                        br
                        | removeLast()
                    td pollFirst()
                        br
                        | pollLast()
                    td takeFirst()
                        br
                        | takeLast()
                    td pollFirst(long,TimeUnit)
                        br
                        | pollLast(long,TimeUnit)
                tr
                    th Examine
                    td getFirst()
                        br
                        | getLast()
                    td peekFirst()
                        br
                        | peekLast()
                    td -
                    td -

            h3 LinkedBlockingDeque&lt;E>
            ol
                li 크기를 제한할 수 있는 BlockingDeque.
                li Collection, Iterator의 모든 선택적 연산을 구현했다

            h3 TransferQueue&lt;E>
            ol
                li 생산자가 소비자가 소비할 때까지 대기할 수 있는 BlockingQueue.
                li 기존의 BlockingQueue와 SynchronousQueue 기능 모두를 선택적으로 이용할 수 있다
            +asCode('java').
                void transfer(E e)
                    // 소비자에게 e를 전달한다. 소비자가 소비할 때까지 대기한다
                boolean tryTransfer(E e)
                    // 대기 중인 소비자에게 e를 전달한다. 대기 중인 소비자가 없다면 즉시 false를 반환한다
                boolean tryTransfer(E e, long timeout, TimeUnit unit)
                    // timeout이 지나도록 대기 중인 소비자가 없다면 false를 반환한다

            h3 LinkedTransferQueue&lt;E>
            ol
                li 크기 제한없고 연결된 TransferQueue.
                li size 계산에 순회가 필요하므로 정확하지 않을 수 있다
                li addAll 따위의 bulk 연산은 원자적으로 실행되지 않을 수 있다
                li Collection, Iterator의 모든 선택적 연산을 구현했다

        h2 Non-Blocking 컬렉션
        div
            h3 CopyOnWriteArrayList&lt;E>
            ol
                li 스레드-안전한 ArrayList
                li add, set 등의 연산마다 새로운 배열을 만든다. 따라서 일반적인 용도로는 매우 나쁘다
                li iterator는 생성된 시점의 snapshot을 순회함이 보장되지만, iterator를 통한 요소의 변경은 불가하다

            h3 CopyOnWriteArraySet&lt;E>
            p 모든 연산에 CopyOnWriteArrayList를 사용하는 Set

            h3 ConcurrentLinkedQueue&lt;E>
            ol
                li 크기 제한 없고, 스레드-안전한 연결된 Queue
                li size 계산에 순회가 필요하므로, 오차가 있을 수 있다
                li addAll 따위의 bulk 연산은 원자적으로 실행되지 않을 수 있다
                li Collection, Iterator의 모든 선택적 연산을 구현했다.

            h3 ConcurrentlinkedDeque&lt;E>
            ol
                li 크기 제한 없고, 스레드-안전한 연결된 Deque
                li size 계산에 순회가 필요하므로, 오차가 있을 수 있다
                li addAll 따위의 bulk 연산은 원자적으로 실행되지 않을 수 있다
                li Collection, Iterator의 모든 선택적 연산을 구현했다.

            h3 ConcurrentMap&lt;K, V>
            ol
                li 스레드-안전, 작업의 원자성 보장
                p Map의 각 연산, Map이 반환하는 컬렉션들의 연산 모두 재정의해야 한다

            h3 ConcurrentNavigableMap&lt;K, V>
            p NavigableMap 연산을 지원하는 ConcurrentMap

            h3 ConcurrentHashMap&lt;K, V>
            ol
                li 읽기 연산에 대해서는 완전한 동시성을, 갱신 연산에 대해서는 높은 수준의 동시성을 제공
                p Hashtable의 모든 연산을 구현했다. 읽기 연산에 대해 원소를 잠그지는 않으며, 테이블 전체를 잠기는 기능 또한 없다. 가져간 원소를 사용하려고 하는 시점에는 맵에서 제거됐을 수도 있다.
                li 카운터로 사용할 수 있다. 예. map.computeIfAbsent(key, x -> new LongAdder()).increment();
                li Map, Iterator의 모든 선택적 연산을 구현했다
                li 3가지 Bulk 연산을 지원한다 : forEach, search, reduce
                p 인자로 받은 parallelismThreshold보다 맵이 작다고 판단되면 순차적으로 원소를 소비, 그 외엔 병렬로 소비. 1이면 최대 병렬성, Long.MAX_VALUE면 병렬 X
                li 모든 작업 메서드의 매개변수는 non-null이어야 한다
            +asCode('java').
                long mappingCount()
                    // 크기가 매우 큰 경우, Map.size() 대신 이용

                void forEach(long parallelismThreshold, BiConsumer&lt;? super K, ? super V> action)
                    // + forEachKey, forEachValue, forEachEntry
                &lt;U> U search(long parallelismThreshold, BiFunction&lt;? super K, ? super V, ? extends U> searchFunction)
                    // 찾는 원소에 대해서는 non-null 반환
                    // + searchKeys, searchValues, searchEntries
                &lt;U> U reduce(long parallelismThreshold, BiFunction&lt;? super K, ? super V, ? extends U> transformer, BiFunction&lt;? super U, ? super U, ? extends U> reducer)
                    // + reduceToDouble ~ Int, reduceKeys, reduceKeysToDouble ~ Int, reduceValues, reduceValuesToDouble ~ Int, reduceEntries, reduceEntriesToDouble ~ Int

            h3 ConcurrentSkipListMap&lt;K,V>
            ol
                li ConcurrentNavigableMap 구현체. 평균 log(n) 시간이 소요되는, 스레드-안전한
                    +asA('http://en.wikipedia.org/wiki/Skip_list', 'SkipList')
                    |  구현을 이용
                li 오름차순 정렬된 뷰와 이터레이터가 내림차순보다 빠르다
                li putAll과 같은 bulk 연산은 원자적으로 종료되지 않을 수 있다
                li Map, Iterator의 모든 선택적 연산을 구현했다
            +asCode('java').
                public ConcurrentSkipListMap(Comparator&lt;? super K> comparator)
                    // 지정하지 않은 경우, 자연스러운 정렬을 이용한다

            h3 ConcurrentSkipListSet&lt;E>
            p ConcurrentSkipListMap을 이용한 NavigableSet
            +asCode('java').
                public ConcurrentSkipListSet(Comparator&lt;? super E> comparator)
                    // 지정하지 않은 경우, 자연스러운 정렬을 이용한다

        h2 실행 기법
        div
            h3 Semaphore
            ol
                li 제한된 수의 접근 권한을 acquire()로 획득, release()로 반환.
                p fairness : acquire()호출 순서대로 권한 획득.
                li public Semaphore(int permits, boolean fair)
                p fair : 지정하지 않은 경우 false
            +asCode('java').
                void acquire()
                    // 권한을 하나 요구한다. 권한을 얻을 때까지 대기하며, 대기 중인 스레드는 인터럽트될 수 있다.
                void acquireUninterruptibly()
                    // 대기 중일 때 인터럽트되더라도 계속 대기한다. 인터럽트되지 않았을 경우와 권한을 얻는 시기가 달라질 수 있다
                boolean tryAcquire()
                void release()
                int availablePermits()
                int drainPermits()
                    // 가용한 모든 권한을 얻는다. 만약 음수라면 release하여 0으로 맞춘다.
                boolean isFair()

                final boolean hasQueuedThreads()
                final int getQueueLength()

            h3 CountDownLatch
            p count가 0일 될때까지(원하는 작업들이 완료될 때까지), 1개 이상의 스레드가 대기하는 동기화 제공.
            +asCode('java').
                public CountDownLatch(int count)

                void await()
                    // count가 0이 될때까지 대기한다. 대기 중에 인터럽트될 수 있다
                boolean await(long timeout, TimeUnit unit)
                    // 대기 중에 timeout을 넘으면 즉시 false 반환
                void countDown()
                    // --count, count가 0이면 대기하는 모든 스레드를 깨운다

            h3 CyclicBarrier
            p 스레드들이 공통의 목적이 달성되기까지 함께 대기. 그 목적을 barrier라고 하며, barrier를 재사용할 수 있어 cyclic하다.
            +asCode('java').
                public CyclicBarrier(int parties, Runnable barrierAction)
                    // barrierAction : barrier를 넘을 때 실행. 지정하지 않은 경우, 대기하던 스레드를 깨우기만 한다

                int getParties()
                int await()
                    // 마지막 스레드가 await을 호출할 때까지 대기한다. 대기 중에 인터럽트될 수 있다. 현재 스레드의 대기 순번 반환. getParties() - 1이 첫 번째, 0이 마지막 스레드.
                int await(long timeout, TimeUnit unit)
                    // timeout을 초과하여 대기하면 barrier는 부서진다
                boolean isBroken()
                void reset()
                    // barrier를 초기 상태로 재설정한다. 이미 대기 중인 스레드가 있다면 BrokenBarrierException 발생. 부서진 barrier를 재사용하려면 별도의 동기화가 필요하므로, 차라리 새로 하나 만들자
                int getNumberWaiting()

            h3 Exchanger&lt;V>
            p 두 스레드가 같은 시점에 값을 서로 교환하도록 해준다.
            +asCode('java').
                V exchange(V x) throws InterruptedException
                    // 다른 스레드가 같은 지점에 도달하기까지 기다렸다가, 서로 값을 교환한다.
                V exchange(V x, long timeout, TimeUnit unit) throws InterruptedException, TimeoutException
                    // timeout 초과 시 TimeoutException 발생

            h3 Phaser
            ol
                li 재사용 가능한 동기화 barrier. CyclicBarrier, CountDownLatch 기능에 더해 보다 유연한 메서드 제공
                li CyclicBarrier와 다르게 각 회전마다 총 대기하는 스레드 수가 다를 수 있다
                p 현재 phase가 완료되기 전에 미리 이후의 phase(들)을 등록할 수 있다. 각 phase는 0부터 시작하는 번호를 가진다(Integer.MAX_VALUE에 도달하면 다음은 다시 0)
                li 계층 구조를 구성할 수 있다. 자식 Phaser의 parties가 0이 아니게 되는 순간 parent에 등록되고, 0이 되는 순간 parent에서 제거된다
            +asCode('java').
                public Phaser(int parties)
                    // parties : 다음 phase로 넘어가기 위해 필요한 수
                public Phaser(Phaser parent, int parties)
                    // parties : 다음 phase로 넘어가기 위해 필요한 수. 지정하지 않으면 0

                int register()
                    // 새로운 phase를 등록한다
                    // + bulkRegister

                int arrive()
                    // 현재 phaser에 도착한다. 다른 스레드의 도착을 기다리지는 않는다. 현재 phase 번호를 반환한다(종료됐다면 음수)
                int arriveAndDeregister()
                    // 현재 phaser에 도착하고, 이후 phase에서는 자신이 빠짐을 알린다
                int arriveAndAwaitAdvance()
                    // 현재 phaser에 도착하고, 현재 phase의 모든 구성원이 도착할 때까지 기다린다 == awaitAdvance(arrive())
                int awaitAdvance(int phase) + awaitAdvanceInterruptibly
                    // 지정한 번호의 phase의 모든 구성원이 도착할 때까지 기다린다. 현재 phase의 번호와 다르거나, phaser가 종료된 경우엔 즉시 반환한다.

                void forceTermination()
                    // 계층 구조에 속해있다면, 모든 phaser가 종료된다
                final int getPhase()
                    // 현재 phase 번호를 반환한다. Phaser가 종료됐다면 음수(마지막 phase 번호 + Integer.MAX_VALUE)를 반환한다

        h2 ThreadLocalRandom
        p 현재 스레드에 격리된 난수 생성기
        +asCode('java') static ThreadLocalRandom current()

        h2 TimeUnit
        +asCode('java').
            NANOSECONDS, MICROSECONDS, MILLISECONDS, SECONDS, MINUTES, HOURS, DAYS

            long convert(long sourceDuration, TimeUnit sourceUnit)

            void timeWait(Object obj, long timeout)
                // timeout만큼 obj.wait()
            void timedJoin(Thread thread, long timeout)
                // timeout만큼 Thread.join()
            void sleep(long timeout)

    h1 java.util.concurrent.atomic
    div
        h2 Package Summary
        ol
            li 변수 하나에 대한 잠금 없는 스레드-안전성을 제공한다
            li VarHandle을 통해 변수를 원자적으로 접근한다
            li AtomicBoolean, AtomicInteger 등은 일반적인 Boolean, Integer 등을 대신할 수 없다
            li 메모리 장벽을 만나면 CPU 코어의 캐시값이 RAM으로 반영된다

        h2 VarHandle
        ol
            li java.lang.invoke 패키지 멤버임
            li 하나의 변수, 매개변수, 필드 등에 대한 동적인 타입 참조. plain 읽기/쓰기, volatile 읽기/쓰기, compare-and-set 접근을 지원한다
        +asCode('java').
            final Object get(Object... args)
                // 변수가 non-volatile인 것처럼 읽는다(= plain read). 모든 VarHandle 인스턴스에서 지원된다
            final void set(Object... args)
                // 변수가 non-volatile, non-final인 것처럼 쓴다(= plain write). 메서드 시그니처는 (CT1 ct1, ..., CTn ctn, T newValue)void.

            final Object getVolatile(Object... args)
                // 변수가 volatile인 것처럼 읽는다.
            final void setVolatile(Object... args)
                // 변수가 volatile인 것처럼 쓴다. 메서드 시그니처는 (CT1 ct1, ..., CTn ctn, T newValue)void.

            final Object getOpaque(Object... args)
                // Opaque : Program order 순서대로 접근한다. 다른 스레드와의 조율은 없다
                // + setOpaque

            final Object getAcquire(Object... args)
                // 같은 변수에 대해 이어지는 load/store 연산이 이 접근보다 먼저 발생하지 않는다
            final void setRelease(Object... args)
                // 같은 변수에 대한 이전의 load/store 연산이 이 접근보다 나중에 발생하지 않는다

            final boolean compareAndSet(Object... args)
                // 원자적으로 다음이 실행된다. getVolatile과 동일한 문맥으로 가져온 값(witness value)이 expectedValue와 동일(==)하면 setVolatile과 동일한 문맥으로 newValue 설정 후 true 반환, 그 외엔 false 반환
                // 메서드 시그니처는 (CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)boolean
            final Object compareAndExchange(Object... args)
                // 원자적으로 다음이 실행된다. getVolatile과 동일한 문맥으로 가져온 값(witness value)이 expectedValue와 동일(==)하면 setVolatile과 동일한 문맥으로 newValue 설정. 반환값은 witness value
            final Object compareAndExchangeAcquire(Object... args)
                // 원자적으로 다음이 실행된다. getAcquire와 동일한 문맥으로 가져온 값(witness value)이 expectedValue와 동일(==)하면 set와 동일한 문맥으로 newValue 설정. 반환값은 witness value
            final Object compareAndExchangeRelease(Object... args)
                // 원자적으로 다음이 실행된다. get와 동일한 문맥으로 가져온 값(witness value)이 expectedValue와 동일(==)하면 setRelease와 동일한 문맥으로 newValue 설정. 반환값은 witness value

            final boolean weakCompareAndSetPlain(Object... args)
                // 다음이 실행된다. get과 동일한 문맥으로 가져온 값(witness value)이 expectedValue와 동일(==)하면 set과 동일한 문맥으로 newValue 설정 후 true 반환. 그 외엔 false
            final boolean weakCompareAndSet(Object... args) + ~Acquire, ~Release
                // 다음이 실행된다. getVolatile과 동일한 문맥으로 가져온 값(witness value)이 expectedValue와 동일(==)하면 setVolatile과 동일한 문맥으로 newValue 설정 후 true 반환. 그 외엔 false

            final Object getAndSet(Object... args) + ~Acquire, ~Release
                // 원자적으로 다음이 실행된다. getVolatile과 동일한 문맥으로 값(witness value)을 가져오고, setVolatile과 동일한 문맥으로 newValue 설정 후 witness value 반환
            final Object getAndAdd(Object... args) + ~Acquire, ~Release
                // 원자적으로 값을 더한 후 이전 값 반환. 메서드 시그니처는 (CT1 ct1, ..., CTn ctn, T value)T
            final Object getAndBitwiseOr(Object... args)
                // 원자적으로 OR 연산 수행 후 이전 값 반환. 메서드 시그니처는 (CT1 ct1, ..., CTn ctn, T mask)T
                // + ~Acquire, ~Release, getAndBitwiseAnd~, getAndBitwiseXor~

            static void acquireFence()
                // 장벽 이전의 load 연산이 장벽 이후의 load/store 뒤로 재배치되지 않음
            static void fullFence()
                // 장벽 이전의 load/store 연산이 장벽 이후의 load/store 뒤로 재배치되지 않음
            static void releaseFence()
                // 장벽 이전의 load/store 연산이 장벽 이후의 store 뒤로 재배치되지 않음
            static void loadLoadFence()
                // 장벽 이전의 load 연산이 장벽 이후의 load 뒤로 재배치되지 않음
            static void storeStoreFence()
                // 장벽 이전의 store 연산이 장벽 이후의 store 뒤로 재배치되지 않음
        div
            h3 VarHandle.AccessMode
            table
                tr
                    th GET
                    td VarHandle.get
                tr
                    th SET
                    td VarHandle.set
                tr
                    th GET_VOLATILE
                    td VarHandle.getVolatile
                tr
                    th SET_VOLATILE
                    td VarHandle.setVolatile
                tr
                    th GET_ACQUIRE
                    td VarHandle.getAcquire
                tr
                    th SET_RELEASE
                    td VarHandle.setRelease
                tr
                    th GET_OPAQUE
                    td VarHandle.getOpaque
                tr
                    th SET_OPAQUE
                    td VarHandle.setOpaque
                tr
                    th COMPARE_AND_SET
                    td VarHandle.compareAndSet
                tr
                    th COMPARE_AND_EXCHANGE
                    td VarHandle.compareAndExchange
                tr
                    th COMPARE_AND_EXCHANGE_ACQUIRE
                    td VarHandle.compareAndExchangeAcquire
                tr
                    th COMPARE_AND_EXCHANGE_RELEASE
                    td VarHandle.compareAndExchangeRelease
                tr
                    th WEAK_COMPARE_AND_SET_PLAIN
                    td VarHandle.weakCompareAndSetPlain
                tr
                    th WEAK_COMPARE_AND_SET
                    td VarHandle.weakCompareAndSet
                tr
                    th WEAK_COMPARE_AND_SET_ACQUIRE
                    td VarHandle.weakCompareAndSetAcquire
                tr
                    th WEAK_COMPARE_AND_SET_RELEASE
                    td VarHandle.weakCompareAndSetRelease
                tr
                    th GET_AND_SET
                    td VarHandle.getAndSet
                tr
                    th GET_AND_SET_ACQUIRE
                    td VarHandle.getAndSetAcquire
                tr
                    th GET_AND_SET_RELEASE
                    td VarHandle.getAndSetRelease
                tr
                    th GET_AND_ADD
                    td VarHandle.getAndAdd
                tr
                    th GET_AND_ADD_ACQUIRE
                    td VarHandle.getAndAddAcquire
                tr
                    th GET_AND_ADD_RELEASE
                    td VarHandle.getAndAddRelease
                tr
                    th GET_AND_BITWISE_OR
                    td VarHandle.getAndBitwiseOr
                tr
                    th GET_AND_BITWISE_OR_RELEASE
                    td VarHandle.getAndBitwiseOrRelease
                tr
                    th GET_AND_BITWISE_OR_ACQUIRE
                    td VarHandle.getAndBitwiseOrAcquire
                tr
                    th GET_AND_BITWISE_AND
                    td VarHandle.getAndBitwiseAnd
                tr
                    th GET_AND_BITWISE_AND_RELEASE
                    td VarHandle.getAndBitwiseAndRelease
                tr
                    th GET_AND_BITWISE_AND_ACQUIRE
                    td VarHandle.getAndBitwiseAndAcquire
                tr
                    th GET_AND_BITWISE_XOR
                    td VarHandle.getAndBitwiseXor
                tr
                    th GET_AND_BITWISE_XOR_RELEASE
                    td VarHandle.getAndBitwiseXorRelease
                tr
                    th GET_AND_BITWISE_XOR_ACQUIRE
                    td VarHandle.getAndBitwiseXorAcquire

        h2 AtomicBoolean
        +asCode('java').
            public AtomicBoolean(boolean initialValue)
                // 지정하지 않으면 false

            final boolean get()                                                     // VarHandle#getVolatile
            final boolean compareAndSet(boolean expectedValue, boolean newValue)    // VarHandle#compareAndSet
            boolean weakCompareAndSetPlain(boolean expectedValue, boolean newValue) // VarHandle#weakCompareAndSetPlain
            final void set(boolean newValue)                                        // VarHandle#setVolatile
            final void lazySet(boolean newValue)                                    // VarHandle#setRelease
            final boolean getAndSet(boolean newValue)                               // VarHandle#getAndSet
            final boolean getPlain()                                                // VarHandle#get
            final void setPlain(boolean newValue)                                   // VarHandle#set
            final boolean getOpaque()                                               // VarHandle#getOpaque
            final void setOpaque(boolean newValue)                                  // VarHandle#setOpaque
            final boolean getAcquire()                                              // VarHandle#getAcquire
            final void setRelease(boolean newValue)                                 // VarHandle#setRelease
            final boolean compareAndExchange(boolean expectedValue, boolean newValue)
                // 메모리 영향은 VarHandle#compareAndExchange와 같다.
                //  + ~Acquire, ~Release
            final boolean weakCompareAndSetVolatile(boolean expectedValue, boolean newValue)
                // 메모리 영향은 VarHandle#weakCompareAndSet와 같다
                // + ~Acquire, ~Release

        h2 AtomicIntegerArray
        p 인덱스를 추가로 받는 것 외에, 지원하는 메서드들은 AtomicInteger와 같다.

        h2 AtomicIntegerFieldUpdater&lt;T> + AtomicLongFieldUpdater, AtomicReferenceFieldUpdater
        ol
            li 지정된 volatile int 필드를 atomic 연산으로 갱신.
            p 해당 필드를 단일 업데이터로만 접근한다면, compareAndSet 메서드들이 원자적으로 작동됨이 보장된다
            li 지원하는 메서드는 AtomicInteger와 유사하다.

        h2 AtomicMarkableReference&lt;V>
        p 원자적으로 갱신되는 마커 bit와 객체 참조 쌍
        +asCode('java').
            public AtomicMarkableReference(V initialRef, boolean initialMark)

            V getReference()
            V get(boolean[] markHolder)
                //markHolder[0]에 해당하는 참조 반환

            boolean compareAndSet(V expectedReference, V newReference, boolean expectedMark, boolean newMark)
                // 기존 참조와 마커 bit가 모두 예상과 동일(==)하다면 원자적으로 갱신하고 true 반환. 그 외엔 false
                // + weakCompareAndSet
            void set(V newReference, boolean newMark)
            boolean attemptMark(V expectedReference, boolean newMark)
                // 기존 참조가 예상과 동일(==)하다면, 마커 bit를 원자적으로 갱신하고 true 반환. 그 외엔 false

        h2 AtomicStampedReference&lt;V>
        p 원자적으로 갱신되는 index와 참조 쌍
        +asCode('java').
            public AtomicStampedReference(V initialRef, int initialStamp)

            V getReference()
            V get(int[] stampHolder)
                // stampHolder[0]에 해당하는 참조 반환

            boolean compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp)
                // 기존 참조와 인덱스가 예상과 동일(==)하다면 원자적으로 갱신하고 true 반환. 그 외엔 false
                // + weakCompareAndSet
            void set(V newReference, int newStamp)
            boolean attempStamp(V expectedReference, int newStamp)
                //기존 참조가 예상과 동일(==)하다면, 인덱스를 원자적으로 갱신하고 true 반환. 그 외엔 false

        h2 LongAdder
        ol
            li 초깃값 0으로 시작하는 스레드-안전한 합계.
            p 합의 순서는 정의되지 않으므로 순서에 상관 없는 경우에 이용해야 한다.
        +asCode('java').
            void add(long x)
            void increment()
            void decrement()
            long sum() // 현재 합계
            void reset()
            long sumThenReset()

        h2 LongAccumulator
        ol
            li 특정 값과 특정 함수로 갱신되는 long 값 유지.
            p 주어진 accumulatorFunction은 부작용이 없어야 한다.
        +asCode('java').
            void accumulate(long x)
            long get()
            void reset()
            long getThenReset()

    h1 java.util.function
    div
        h2 Consumer
        div
            h3 Consumer&lt;T>
            p 인자를 하나 먹고 아무것도 반환하지 않는 소비자.
            +asCode('java').
                void accept(T t)
                default Consumer&lt;T> andThen(Consumer&lt;? super T> after)
                    // 이 소비자 다음에 after가 소비하는 병합된 소비자 반환.

            h3 DoubleConsumer + int, long

            h3 BiConsumer&lt;T, U>
            p 인자 두개를 먹고 아무것도 뱉지 않는 소비자.
            +asCode('java').
                void accept(T t, U u)
                default BiConsumer&lt;T, U> andThen(BiConsumer&lt;? super T, ? super U> after)
                    // 현재 소비자가 작업을 마치면 after가 실행되는 새로운 소비자 반환.

            h3 ObjDoubleConsumer&lt;T> + int, long

        h2 Supplier
        div
            h3 Supplier&lt;T>
            +asCode('java') T get()

            h3 BooleanSupplier + int, double, long
            +asCode('java') boolean getAsBoolean()

        h2 Function, Operator
        div
            h3 Function&lt;T, R>
            p 인자 하나를 먹고 결과 하나를 뱉는 함수.
            +asCode('java').
                R apply(T t)
                default &lt;V> Function&V, R> compose(Function&lt;? super V, ? extends T> before)
                default &lt;V> Function&lt;T, V> andThen(Function&lt;? super R, ? extends V> after)
                static &lt;T> Function&lt;T, T> identity()
                    // 입력 인자 그대로 반환하는 함수.

            h3 IntFunction&lt;R> + double, long
            +asCode('java') R apply(int value)

            h3 DoubleToIntFunction + double, int, long 간의 모든 상호 변환
            +asCode('java') int applyAsInt(double value)

            h3 UnaryOperator&lt;T>
            +asCode('java') static &lt;T> UnaryOperator&lt;T> identity()

            h3 DoubleUnaryOperator + int, long
            +asCode('java').
                double applyAsDouble(double operand)
                default DoubleUnaryOperator compose(DoubleUnaryOperator before)
                default DoubleUnaryOperator andThen(DoubleUnaryOperator after)
                static DoubleUnaryOperator identity()
                    // 항상 입력값 그대로 반환하는 단항 연산자 반환.

            h3 ToDoubleFunction&lt;T>
            +asCode('java') double applyAsDouble(T value) // + int, long

            h3 BiFunction&lt;T, U, R>
            p 인자 두개를 먹고 값을 반환하는 함수.
            +asCode('java').
                default &lt;V> BiFunction&lt;T, U, V> andThen(Function&lt;? super R, ?
                    // 함수가 실행되고 난 결과를 after가 처리하는 새로운 함수 반환.

            h3 ToDoubleBiFunction&lt;T, U>
            details double applyAsDouble(T t, U u) // + int, long

            h3 BinaryOperator
            p 같은 타입의 인자 두개를 먹고 같은 타입의 값을 반환하는 함수.
            +asCode('java').
                static &lt;T> BinaryOperator&lt;T> minBy(Comparator&lt;? super T> comparator)
                    // 주어진 comparator에 따라 둘 중 작은 것을 반환하는 함수를 생성.
                    // + maxBy

            h3 DoubleBinaryOperator
            +asCode('java').
                double applyAsDouble(double left, double right)
                    // double 두개를 먹고 double 하나를 반환하는 함수. + int, long

        h2 Predicate
        div
            h3 Predicate&lt;T>
            +asCode('java').
                boolean test(T t)
                default Predicate&lt;T> and(Predicate&lt;? super T> other)
                default Predicate&lt;T> or(Predicate&lt;? super T> other)

                static &lt;T> Predicate&lt;T> isEqual(Object targetRef)
                    // Object.equals(Object, Object)를 이용해 비교하는 Predicate 반환

            h3 DoublePredicate + int, long
            +asCode('java').
                default DoublePredicate negate()

            h3 BiPredicate&lt;T, U>
            p 인자 두개를 먹고 가부를 판단하는 함수.
            +asCode('java').
                default BiPredicate&lt;T, U> and(BiPredicate&lt;? super T, ? super U> other)
                    // A short-circuiting logical AND of this predicate and other.
                    // + or
                default BiPredicate&lt;T, U> negate()

    h1 java.util.regex
    div
        h2 MatchResult
        p 정규표현식 매칭 결과. group의 의미에 대해선 Pattern 참고.
            +codeBtn('/Repositories/Eclipse/JavaSE/src/regex/MatchResultExample.java', 'java')
        +asCode('java').
            int start()             // 매치된 결과의 시작 인덱스 반환
            int start(int group)    // group번째 매치된 결과의 시작 인덱스 반환
            int end()               // 매치된 결과의 마지막 글자 다음 인덱스 반환
            int end(int group)      // group번째 매치된 결과의 마지막 글자 다음 인덱스 반환
            String group()          // 이전 매치된 결과 반환
            String group(int group) // group번째 매치된 결과 반환
            int groupCount()        // 매치된 group 개수 반환

        h2 Pattern
        +asCode('java').
            public static final int UNIX_LINES       // 줄끝 '\n'만 ., ^, $에서 동작. (?d) 플래그도 같은 의미.
            public static final int CASE_INSENSITIVE // 대소문자 구분 없음. (?i) 플래그도 같은 의미.
            public static final int COMMENTS         // 공백과 주석 허용. 공백과 #부터 줄 끝까지의 주석이 무시된다. (?x) 플래그도 같은 의미.
            public static final int MULTILINE        // ^, $이 각 줄의 끝을 기준으로도 작동; 기본 동작은 입력 시작과 끝에서만 작동. (?m) 플래그도 같은 의미.
            public static final int LITERAL          // 표현식 전체를 상수 문자열 취급.
            public static final int DOTALL           // .이 줄 끝도 포함하여 매치; 기본 동작은 줄 끝 문자는 미포함. (?s) 플래그도 같은 의미.
            public static final int UNICODE_CASE     // CASE_INSENSITIVE 플래그가 유니코드 표준 상에서 동작한다; 기본은 US-ASCII에서만 동작. (?u) 플래그도 같은 의미.


            static Pattern compile(String regex)
            static boolean matches(String regex, CharSequence input) // 1회용
            static String quote(String s) // s를 매칭할 수 있는 정규표현식 리터럴 문자열 표현을 반환.
            Predicate&lt;String> asPredicate()
            Stream&lt;String> splitAsStream(CharSequence input)
        div
            h3 Line terminator
            +asCode('java').
                "\n", "\r\n", "\r", "\u0085", "\u2028", "\u2029"
                // UNIX_LINES 모드에서는 "\n"만 줄 끝으로 인식
            h3 Groups and capturing
            ul
                li Group : 괄호로 감싸인 정규표현식 (X)
                li Capturing group : 괄호 순서에 따라 그룹에 ID가 매겨지며, 이는 나중에 참조(backreference)될 수 있다
                p 0번 그룹은 항상 전체 표현을 가리킨다.
                    +codeBtn('/Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java', 'java', '[16,26]') 예를 들어
                    |  (A)(B(C))에 대하여,
                table.no-sort
                    tr
                        th Group ID
                        th Pattern
                    tr
                        td 0
                        td (A)(B(C))
                    tr
                        td 1
                        td (A)
                    tr
                        td 2
                        td (B(C))
                    tr
                        td 3
                        td (C)
                li Non-capturing group : (?:X)는 후참조(backreference)할 수 없다
                    +codeBtn('/Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java', 'java', '[28,37]')
            h3 Character expression
            ul
                li x, \\ : 각각 x, \에 대응
                    +codeBtn('/Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java', 'java', '[39,39]')
                li \0n, \0nn, \0nnn : 8진수 아스키 코드[0,255] == [00, 0377]
                    +codeBtn('/Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java', 'java', '[40,40]')
                li \xhh : 16진수 아스키 코드[0,255]
                    +codeBtn('/Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java', 'java', '[41,41]')
                li \uhhhh, \u{h...h} : 16진수 유니코드[Character.MIN_CODE_POINT, Character.MAX_CODE_POINT]
                    +codeBtn('/Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java', 'java', '[42,42]')
                li \N{name} : 유니코드 이름
                    +codeBtn('/Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java', 'java', '[43,43]')
                li \t(tab \u0009), \n(newline \u000A), \r(carriage-return \u000D), \f(form-feed \u000C), \a(alert \u0007), \e(escape \u001B), \cx(x에 관한 제어 문자)
            h3 Character class
            ul
                li [abc] : 단순 집합
                    +codeBtn('/Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java', 'java', '[44,44]')
                li [^abc] : 여집합
                    +codeBtn('/Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java', 'java', '[45,45]')
                li [a-z] : 유니코드 Range(inclusive)
                    +codeBtn('/Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java', 'java', '[46,46]')
                li [a-d[m-p]] == [a-dm-p] : 합집합
                    +codeBtn('/Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java', 'java', '[47,47]')
                li [a-z&&[def]] : 교집합
                    +codeBtn('/Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java', 'java', '[48,48]')
                li [a-z&&[^bc]] : 차집합(A and not(B) == A - B)
                    +codeBtn('/Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java', 'java', '[49,49]')
            h3 Predefined character classe
            ul
                li . : 임의 문자. DOTALL 플래그가 있으면 line terminator도 매칭
                li \d : [0-9], \D : [^\d]
                li \s : 공백 문자 [ \t\n\x0B\f\r], \S : [^\s]
                li \h : 수평 공백 [ \t\xA0\u1680\u180e\u2000-\u200a\u202f\u205f\u3000], \H : [^\h]
                li \v : 수직 공백 [\n\x0B\f\r\x85\u2028\u2029], \V : [^\v]
                li \w : Word character, \W : [^w]
            h3 java.lang.Character class
            ul
                li \p{javaLowerCase} : Character.isLowerCase()
                li \p{javaUpperCase} : Character.isUpperCase()
                li \p{javaWhitespace} : Character.isWhitespace()
                li \p{javaMirrored} : Character.isMirrored()
            h3 Unicode class
            ul
                li \R : 임의 줄바꿈 문자열 \u000D\u000A|[\u000A\u000B\u000C\u000D\u0085\u2028\u2029]
                li \X : Any Unicode extended grapheme cluster
                li \b{g} : A Unicode extended grapheme cluster boundary
                li \P{expr} == [^\p{expr}]
                | \p{IsLatin} : Latin
                strong script
                | , \p{InGreek} : Greek
                strong block
                | , \p{Lu} : Uppercase letter(
                strong category
                | ), \p{IsAlphabetic} :
                strong binary property
                | , \p{Sc} : Currency symbol
            h3 Boundary matcher
            ul
                li ^ : 줄 시작, $ : 줄 끝
                li \b : 단어 경계, \B : 비단어 경계
                li \A : The beginning of the input
                li \G : The end of the previous match
                li \z » The end of the input
            h3 Greedy quantifier
            ul
                p 처음에 매치할 수 있는 만큼 최대한 매치. 그 다음 요소의 매칭이 없으면 백트래킹.
                    +asA('https://stackoverflow.com/questions/5319840/greedy-vs-reluctant-vs-possessive-quantifiers', '참고자료')
                li X? : X, once or not at all
                li X* : X, zero or more times
                li X+ : X, one or more times
                li X{n} : X, exactly n times
                li X{n,} : X, at least n times
                li X{n,m} : X, at least n but not more than m times
            h3 Reluctant quantifier
            p 처음에 최소한만 매치. 그 다음 요소의 매칭이 없으면 백트래킹.
                | X??, X*?, X+?, X{n}?, X{n,}?, X{n,m}?
            h3 Possessive quantifier
            p Greedy quantifier와 같지만, 백트래킹은 없다.
                | X?+, X*+, X++, X{n}+, X{n,}+, X{n,m}+
            h3 Logical operation
            ul
                li XY : X followed by Y
                li X|Y : Either X or Y
                li (X) : X, as a capturing group
            h3 Backreference
            ul
                li \n : The n-th capturing group matched
                li \k&lt;name> : Tthe named-capturing group "name" matched
                p ↑ 정규표현식 내에서는 위 두 가지 backreference가 가능하며, replace()에서는 $0, $1, $2, ...로 표기한다
                    +codeBtn('/Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java', 'java', '[51,57,59,71,73,85]')
            h3 Quotation
            ul
                li \ : Nothing, but quotes the following character
                li \Q : Nothing, but quotes all characters until \E
                li \E : Nothing, but ends quoting started by \Q
            h3 Special construct
            ul
                li (?&lt;name>X) : X, as a named-capturing group
                    +codeBtn('/Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java', 'java', '[59,71]')
                li (?:X) : X, as a non-capturing group
                li (?idmsuxU-idmsuxU) : 각 플래그를 켜거나 끈다
                li (?idmsux-idmsux:X) : 주어진 플래그로 non-capturing group X를 매칭한다
                li (?=X) : Positive lookahead, (?!X) : Negative lookahead
                +codeBtn('/Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java', 'java', '[51,57]')
                +codeBtn('/Repositories/Eclipse/Basic/src/io/github/donggi/RegexExample.java', 'java', '[87,102]') 금칙어 판별
                li (?&lt;=X) : Positive lookbehind, (?&lt;!X) : Negative lookbehind
                li (?>X) : Non-capturing group + Possessive

        h2 Matcher
        p Pattern으로부터 만들어지는 매칭 엔진으로, 아래 세 가지 작업을 수행한다.
        ol
            li matches() : 전체 입력에 대해 패턴 매칭
            li lookingAt() : 입력 시작부분 패턴 매칭
            li find() : 입력의 다음 부분 패턴 매칭
        +asCode('java').
            MatchResult toMatchResult()
            Stream&lt;MatchResult> results()

            Matcher usePattern(Pattern newPattern)
            Matcher reset()

            int start(String name) // 주어진 식별자에 해당하는 그룹의 시작 인덱스 반환
            int end(String name)
            String group(String name)

            static String quoteReplacement(String s)
                // appendReplacement 메서드의 replacement로 사용될 s의 리터럴 표기를 반환.
            Matcher appendReplacement(StringBuffer sb, String replacement)
                // 1. 입력 소스의 append position부터 start() 전까지 sb에 추가.
                // 2. replacement를 sb에 추가.
                // 3. 현재 matcher의 append position을 end()로 설정.
            StringBuffer appendTail(StringBuffer sb)
                // 입력 소스의 append position부터를 sb에 추가.
                // appendReplacement 메서드를 호출한 뒤에 이를 호출하여 남머지 부분을 복사할 목적으로 만들어짐.

            String replaceAll(String replacement)
                // 입력 소스의 모든 매칭되는 부분을 replacement로 변경.
            String replaceAll(Function&lt;MatchResult, String> replacer)
            String replaceFirst(String replacement)

            Matcher region(int start, int end)
                // 입력 소스의 특정 구간을 매칭 대상으로 하도록 초기화한다. transparency, anchoring 속성에 따라 동작이 다르다.
            Matcher useTransparentBounds(boolean b)
                // region의 경계 너머를 패턴 매칭에 보이도록 할지 여부
            Matcher useAnchoringBounds(boolean b)
                // region의 경계에서 ^, $를 작동하게 할지 여부


    h1 java.util.stream
    div
        h2 BaseStream&lt;T, S
        +asCode('java').
            Iterator&lt;T> iterator()
            Spliterator&lt;T> spliterator()
            boolean isParallel()
            S sequential() // 순차적인 스트림 반환(어쩌면 자기 자신)
            S parallel()   // 병렬적인 스트림 반환(어쩌면 자기 자신)
            S unordered()  // 순서 없는 스트림 반환(어쩌면 자기 자신)
            S onClose(Runnable closeHandler)

        h2 DoubleStream
        +asCode('java').
            double sum()
            OptionalDouble min(), max(), average(), findFirst(), findAny()
            DoubleSummaryStatistics SummaryStatistics()
            Stream&lt;Double> boxed()

        h2 IntStream
        +asCode('java').
            static IntStream range(int startInclusive, int endExclusive)
            static IntStream rangeClosed(int startInclusive, int endInclusive)

        h2 Stream&lt;T>
        ol
            li 2가지 스트림 연산
            ul
                li Terminal Operation
                p 종결 연산. 스트림 연산 파이프라인의 마지막으로, 더 이상 스트림 연산을 수행할 수 없다.
                li Intermediate Operation
                p 중간 연산. 새로운 스트림을 반환한다.
            li 2가지 중간 연산
            ul
                li Stateless Operation
                p 요소의 연산 과정에 상태의 보존이 필요 없는 경우. filter, map 등
                li Stateful Operation
                p 요소의 연산 과정에 상태의 보존이 필요한 경우. sorted, distinct 등.
                    br
                    | 이러한 연산을 사용하기 위해선 스트림 전체 인풋이 필요할 수 있으며, 병렬 스트림에서는 요구되는 버퍼의 크기가 늘어나게 된다.
            +codeBtn('/Repositories/Eclipse/JavaSE/src/util/FlatMapExample.java', 'java')
        +asCode('java').
            // 팩터리 메서드
            static &lt;T> Stream.Builder&lt;T> builder()
            static &lt;T> Stream&lt;T> empty()
            static &lt;T> Stream&lt;T> of(T t)
            static &lt;T> Stream&lt;T> ofNullable(T t)
            @SafeVarargs static &lt;T> Stream&lt;T> of(T... values)
            static &lt;T> Stream&lt;T> iterate(T seed, UnaryOperator&lt;T> f)
            static &lt;T> Stream&lt;T> iterate(T seed, Predicate&lt;? super T> hasNext, UnaryOperator&lt;T> next) // Since 9
            static &lt;T> Stream&lt;T> generate(Supplier&lt;? extends T> s)
            static &lt;T> Stream&lt;T> concat(Stream&lt;? extends T> a, Stream&lt;? extends T> b)


            // 중간 연산
            Stream&lt;T> filter(Predicate&lt;? super T> predicate)
                // predicate이 true인 요소만 남긴다.

            &lt;R> Stream&lt;R> map(Function&lt;? super T, ? extends R> mapper)
                // mapper : 하나의 T 변수에서 하나의 R 변수로 대응하는 변환
            IntStream mapToInt(ToIntFunction&lt;? super T> mapper)
                // + long, double
            &lt;R> Stream&lt;R> flatMap(Function&lt;? super T, ? extends Stream&lt;? extends R>> mapper)
                // mapper : 하나의 T 변수에서 여러 R 변수(R 스트림)로 대응하는 변환.
                // mapper를 이용해 만들어진 여러 R 스트림을 일렬로 펴서(flattening) 하나의 R 스트림으로 변환. mapper가 null을 반환하면 빈 스트림을 대신 이용된다.
                // 최종적으로 반환되는 스트림 외의 모든 중간 스트림은 닫힌다.
            IntStream flatMapToInt(Function&lt;? super T, ? extends IntStream> mapper )
                // + long, double

            Stream&lt;T> distinct()
                // Object.equals(Object)를 이용해 유일한 것들만으로 구성. stateful 중간 연산.
            Stream&lt;T> sorted()
                // 자연스러운 방향으로 정렬. T가 Comparable하지 않으면 예외 발생할 수 있음. stateful 중간 연산.
            Stream&lt;T> sorted(Comparator&lt;? super T> comparator)

            Stream&lt;T> peek(Consumer&lt;? super T> action)
                // forEach와 유사한 기능을 하는 중간 연산. 다른 중간 연산 전후의 값을 살펴보는 디버깅 용도로 만들어짐.

            Stream&lt;T> limit(long maxSize)
                // 스트림의 크기가 maxSize 이하가 되도록 한다. short-circuiting stateful 중간 연산.
            Stream&lt;T> skip(long n)
                // n개를 버린 나머지로 스트림을 구성해 반환한다. 더 없으면 빈 스트림이 반환된다.
            default Stream&lt;T> takeWhile(Predicate&lt;? super T> predicate)
                // 요소들을 하나씩 검사하여, predicate을 만족하지 않는 요소가 나오기 전까지로 구성된 스트림을 반환한다.
                // 순서 있는 스트림에 대하여는 조건을 만족하는 최장 길이 접두 요소들을 얻게 되며, 순서 없는 스트림은 조건을 만족하는 부분 집합을 얻게 된다.
                // short-circuiting stateful 중간 연산.
                // 일반적으로 연산이 저렴하지만, 순서 있는 병렬 스트림에 대하여는 최장 길이 접두 요소들을 찾기 위해 연산이 비싸지므로, 허용된다면 순서 없는 스트림 소스(generate(Supplier))를 이용하거나, BaseStream.unordered()를 이용해 순서를 없애는 것이 성능에 도움이 될 것이다.
            default Stream&lt;T> dropWhile(Predicate&lt;? super T> predicate)
                // stateful 중간 연산.


            // 종결 연산
            void forEach(Consumer&lt;? super T> action)
            void forEachOrdered(Consumer&lt;? super T> action
                // 순서 있는 스트림의 경우, 이를 이용하면 요소의 순서대로 소비자가 실행된다.

            Object[] toArray()
            &lt;A> A[] toArray(IntFunction&lt;A[]> generator)
                // generator : 배열 크기를 먹고 배열을 뱉는 함수. 예: A[]::new.

            T reduce(T identity, BinaryOperator&lt;T> accumulator)
                // 하나의 T 변수로 축약하는 종결 연산. 아래와 동치다.
            {
                var result = identity;
                for(T element : stream)
                    result = accumulator.apply(result, element);
                return result;
            }
            Optional&lt;T> reduce(BinaryOperator&lt;T> accumulator
                // 하나의 T로 축약하는 종결 연산. 처음 연산 결과는 null이며, 스트림 첫 번째 요소를 만나면 치환된다. 이후는 reduce(T, BinaryOperator)와 같다.
            &lt;U> U reduce(U identity, BiFunction&lt;U, ? super T, U> accumulator, BinaryOperator&lt;U> combiner)
                // 하나의 U 변수로 축약하는 종결 연산. 연산은 reduce(T, BinaryOperator)와 동일한데, identity 값은 combiner 연산에 대한 항등원이어야 한다.
                // 다시 말해, 임의의 U 타입 변수 u에 대하여 u == combiner(identity, u)를 만족해야 한다.
                // 이는 연산 과정에서 다음의 검사를 통해 검증된다. combiner.apply(u, accumulator.apply(identity, t)) == accumulator.apply(u, t)
                // 이렇게 복잡하게 하는 것보다는 map과 reduce를 쪼개 이용하는 것이 훨씬 간결하므로 유념.

            &lt;R> R collect(Supplier&lt;R> supplier, BiConsumer&lt;R, ? super T> accumulator, BiConsumer&lt;R, R> combiner)
                // 하나의 R 변수로 축약하는 종결 연산. reduce와 다르게 R 자체가 결과값에 대한 가변적인 컨테이너(ArrayList, String 등)가 되어야 한다. 아래와 동치다.
                // 여기서는 combiner를 사용하지 않는 것처럼 보이지만, combiner는 병렬 스트림 연산을 위해 존재하는 것이므로, 연산 결과 자체는 아래와 동치가 맞다.
            {
                var result = supplier.get();
                for(T element : stream)
                    accumulator.accept(result, element);
                return result;
            }
                // 메서드 참조 예.
            {
                collect(ArrayList::new, ArrayList::add, ArrayList::addAll);
                collect(StringBuilder::new, StringBuilder::append, StringBuilder::append);
            }
            &lt;R, A> collect(Collector&lt;? super T, A, R> collector)
                // collect(Supplier, BiConsumer, BiConsumer)의 매개변수를 캡슐화한 Collector를 이용.
                // Collectors 유틸리티 클래스에 이미 정의된 Collector들이 있으니 편하게 이용 가능.

            Optional&lt;T> min(Comparator&lt;? super T> comparator) // + max
            long count()
                // 개수를 반환하는 종결 연산.
            boolean anyMatch(Predicate&lt;? super T> predicate)
                // short-circuiting 종결 연산.
                // + allMatch, noneMatch
            Optional&lt;T> findFirst()
                // short-circuiting 종결 연산.
                // + findAny
        div
            h3 Stream.Builder&lt;T>
            +asCode('java').
                void accept(T t)
                default Stream.Builder&lt;T> add(T t)
                Stream&lt;T> build()

        h2 StreamSupport
        +asCode('java').
            static &lt;T> Stream&lt;T> stream(Spliterator&lt;T> spliterator, boolean parallel)
            static &lt;T> Stream&lt;T> stream(Supplier&lt;? extends Spliterator&lt;T>> supplier, int characteristics, boolean parallel)
                // characteristics = supplier.get().characteristics()
            static IntStream intStream(Spliterator.OfInt spliterator, boolean parallel)
                // + long, double
            static IntStream intStream(Supplier&lt;? extends Spliterator.OfInt> supplier, int characteristics, boolean parallel)
                // characteristics = supplier.get().characteristics()

        h2 Collector&lt;T, A, R>
        +asCode('java').
            static enum Collector.Characteristics {
                CONCURRENT, IDENTITY_FINISH, UNORDERED;
            }

            Supplier&lt;A> supplier()
                // 결과 컨테이너인 A를 생성하는 함수 반환.
            BiConsumer&lt;A, T> accumulator()
                // A의 결과에 T 타입 데이터를 축적하는 함수
            BinaryOperator&lt;A> combiner()
                // 두 결과 컨테이너를 받아 하나로 반환하는 함수
            Function&lt;A, R> finisher()
                // 결과 컨테이너로부터 최종 결과 R으로 변환하는 함수 반환
            Set&lt;Collector.Characteristics> characteristics()

            static &lt;T, A, R> Collector&lt;T, A, R> of(Supplier&lt;A> supplier, BiConsumer&lt;A, T> accumulator, BinaryOperator&lt;A> combiner, Function&lt;A, R> finisher, Collector.Characteristics... characteristics)

        h2 Collectors
        +asCode('java').
            static &lt;T, C extends Collection&lt;T>> Collector&lt;T, ?, C> toCollection(Supplier&lt;C> collectionFactory)
                // collectionFactory로 생성한 Collection 객체에 원소들을 만나는 순서대로 집어넣는 Collector 반환.
            static &lt;T> Collector&lt;T, ?, List&lt;T>> toList()
                // 새로운 List 객체에 입력 원소들을 모두 담아 반환하는 Collector. 반환된 List의 타입, 변경 가능 여부, 직렬화, 스레드-안전 그 무엇도 보장하지 않음.
            static &lt;T> Collector&lt;T, ?, List&lt;T>> toUnmodifiableList() // Since 10
            static &lt;T> Collector&lt;T, ? Set&lt;T>> toSet()
                // 새로운 Set 객체에 입력 원소들을 모두 담아 반환하는 Collector. 반환된 Set의 타입, 변경 가능 여부, 직렬화, 스레드-안전 그 무엇도 보장하지 않음.
            static &lt;T> Collector&lt;T, ?, Set&lt;T>> toUnmodifiableSet() // Since 10

            static Collector&lt;CharSequence, ?, String> joining()
                // String에 만나는 순서대로 덧붙이는 Collector.

            static &lt;T, U, A, R> Collector&lt;T, ?, R> mapping(Function&lt;? super T, ? extends U> mapper, Collector&lt;? super U, A, R> downstream)
                // U 타입 원소에 대한 Collector에 T 타입 원소를 mapper를 통해 U 타입으로 변환하여 받아들이는 Collector.
            static &lt;T, U, A, R> Collector&lt;T, ?, R> flatMapping(Function&lt;? super T, ? extends Stream&lt;? extends U>> mapper, Collector&lt;? super U, A, R> downstream) // Since 9
                // Flat mapper는 입력 요소를 0개 이상의 요소를 담은 stream으로 만들어내며, downstream에 투입되면 해당 stream은 닫힌다.(null인 경우 빈 스트림을 대신 이용한다)

            static &lt;T, A, R> Collector&lt;T, ?, R> filtering(Predicate&lt;? super T> predicate, Collector&lt;? super T, A, R> downstream) Since 9
                // 동일한 입력 타입 T 원소를 받아 predicate을 만족하면 downstream에 투입하는 Collector.

            static &lt;T, A, R, RR> Collector&lt;T, A, RR> collectingAndThen(Collector&lt;T, A, R> downstream, Function&lt;R, RR> finisher)

            static &lt;T> Collector&lt;T, ?, Long> counting()
            static &lt;T> Collector&lt;T, ?, Optional&lt;T>> minBy(Comparator&lt;? super T> comparator)
            static &lt;T> Collector&lt;T, ?, Optional&lt;T>> maxBy(Comparator&lt;? super T> comparator)
            static &lt;T> Collector&lt;T, ?, Integer> summingInt(ToIntFunction&lt;? super T> mapper) // + Long, Double
            static &lt;T> Collector&lt;T, ?, Double> averagingInt(ToIntFunction&lt;? super T> mapper) // + Long, Double
            static &lt;T> Collector&lt;T, ?, IntSummaryStatistics> summarizingInt(ToIntFunction&lt;? super T> mapper) // + Long, Double
            static &lt;T> Collector&lt;T, ? T> reducing(T identity, BinaryOperator&lt;T> op)
                // reducing 설명은 DoubleStream 참고

            static &lt;T, K> Collector&lt;T, ?, Map&lt;K, List&lt;T>>> groupingBy(Function&lt;? super T, ? extends K> classifier)
            static &lt;T, K> Collector&lt;T, ?, ConcurrentMap&lt;K, List&lt;T>>> groupingByConcurrent(Function&lt;? super T, ? extends K> classifier)
            static &lt;T> Collector&lt;T, ?, Map&lt;Boolean, List&lt;T>>> partitioningBy(Predicate&lt;? super T> predicate)
            static &lt;T, K, U> Collector&lt;T, ?, Map&lt;K, U>> toMap(Function&lt;? super T, ? extends K> keyMapper, Function&lt;? super T, ? extends U> valueMapper)
            static &lt;T, K, U> Collector&lt;T, ?, Map&lt;K, U>> toUnmodifiableMap(Function&lt;? super T, ? extends K> keyMapper, Function&lt;? super T, ? extends U> valueMapper) // Since 10
            static &lt;T, K, U> Collector&lt;T, ?, ConcurrentMap&lt;K, U>> toConcurrentMap(Function&lt;? super T, ? extends K> keyMapper, Function&lt;? super T, ? extends U> valueMapper)


    h1 java.util.zip
    div
        h2 Checksum
        +asCode('java').
            void update(int b)
            default void update(byte[] b)
            void update(byte[] b, int off, int len)
            default void update(ByteBuffer buffer)
            long getValue()
            void reset()
        ol
            p 구현 클래스
            li class Adler32
            li class CRC32
            li class CRC32C

        h2 ZipInputStream
        +asCode('java').
            public ZipInputStream(InputStream in, Charset charset)

            ZipEntry getNextEntry()
            void closeEntry()
                // 현재 ZipEntry를 닫고 읽기 위치를 다음 entry로 이동.
            int available()
                // EOF를 만났으면 0, 아니면 1

        h2 ZipOutputStream
        +asCode('java').
            public ZipOutputStream(OutputStream out, Charset charset)

            void setComment(String comment)
            void setMethod(int method)
                // ZipEntry에 설정되지 않은 경우 사용하는 압축 방법 : DEFLATED(압축, 기본값), STORED(비압축)
            void setLevel(int level)
                // 압축 레벨 : 0(BEST_SPEED) ~ 9(BEST_COMPRESSION). 기본은 DEFAULT_COMPRESSION(-1)이며, 보통 6.
            void putNextEntry(ZipEntry e)
            void closeEntry()
                // 현재 ZipEntry를 닫고 다음 쓰기 위치로 이동. putNextEntry 메서드는 쓰기 전에 알아서 닫는다.
            void finish()
                // 쓰기를 종료하고 스트림을 닫는다. 동일한 출력 스트림에 여러 필터를 적용한 경우에 사용.

        h2 ZipEntry
        +asCode('java').
            public ZipEntry(String name)
            public ZipEntry(ZipEntry e) // e로 필드를 채운다.

            String getName()
            ZipEntry setLastModifiedTime(FileTime time)
            ZipEntry setLastAccessTime(FileTime time)
            ZipEntry setCreationTime(FileTime time)
            void setSize(long size) // 비압축 크기 설정
            void setCompressedSize(long csize)
            void setCrc(long crc)
            void setMethod(int method)
                // DEFLATED(압축), STORED(비압축), -1(미설정)
            void setExtra(byte[] extra)
            void setComment(String comment)
            boolean isDirectory()
                // 이름이 "/"로 끝나면 디렉터리.
            Object clone()

        h2 ZipFile
        +asCode('java').
            public ZipFile(File file, int mode)
                // UTF-8
                // mode : OPEN_READ | OPEN_DELETE(파일이 close 호출 전까지 삭제됨, 내용은 객체를 통해 계속 접근 가능)
            public ZipFile(File file, int mode, Charset charset)

            ZipEntry getEntry(String name)
            InputStream getInputStream(ZipEntry entry)
                // ZipFile이 닫히면 이 메서드가 반환한 모든 스트림도 같이 닫힌다.
            Enumeration&lt;? extends ZipEntry> entries()
            Stream&lt;? extends ZipEntry> stream()
            int size() // entry 개수


    h1 javax.crypto
    | EMPTY


    h1 javax.net
    div
        h2 SocketFactory
        +asCode('java').
            static SocketFactory getDefault()
            Socker createSocket(String host, int port)

        h2 ServerSocketFactory
        +asCode('java').
            static ServerSocketFactory getDefault()
            ServerSocker createServerSocket(int port)


    h1 javax.net.ssl
    | EMPTY
