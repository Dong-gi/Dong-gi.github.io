include ../../source/skeleton.pug
+post('JPA', 'JPA, Java Persistence API, Hibernate, Spring Data JPA', 'JPA; Java Persistence API 정리')
    h1 JPA?
    div
        h2 정의
        ul
            li
                strong Java Persistence API
                |  ::= Java ORM(Object-Relational Mapping)을 위한 명세
            p 객체지향 설계와 RDB의 설계를 둘 다 해치지 않으면서 둘 사이의 매핑을 지원 ─ 즉, 필요한 SQL을 자동으로 구성
            li SQL과 유사한, 객체를 이용한 JPQL(Java Persistence Query Language) 지원
            li 객체 상속 관계 사용 가능
            li 객체 참조 관계 유지 가능

        h2 JPA 사용
        p Hibernate와 같은 JPA 구현체(JPA Provider)를 이용하거나, 직접 구현하여 이용하면 된다

        h2 Spring Data JPA
        p JPA에 대한 추상화된 모듈을 제공하여 보다 쉬운 사용을 가능하게 한다

    h1 JPA 사용 정리
    div
        h2 예시 코드
        table
            +ths('설명', '링크')
            tr
                td 전체 프로젝트
                td: +asA('https://github.com/Dong-gi/Dong-gi.github.io/tree/master/Repositories/STS/jpa-example')
            tr
                td 예시 코드 - 기본 CRUD
                td
                    +codeBtn('/Repositories/STS/jpa-example/src/main/resources/ddl/jpa_user.sql', 'sql', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/test/java/io/github/donggi/jpa/dao/UserDaoTests.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/User1.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/User2.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/dao/User1Dao.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/dao/User2Dao.java', 'java', null, true)
            tr
                td 예시 코드 - Converter
                td
                    +codeBtn('/Repositories/STS/jpa-example/src/main/resources/ddl/jpa_log.sql', 'sql', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/test/java/io/github/donggi/jpa/dao/ApiLogDaoTests.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/ApiLog.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/enums/ApiResultCode.java', 'java', null, true)
            tr
                td 예시 코드 - Embed
                td
                    +codeBtn('/Repositories/STS/jpa-example/src/main/resources/ddl/jpa_item.sql', 'sql', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/test/java/io/github/donggi/jpa/dao/ItemDaoTests.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/Item1.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/Price.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/Item2.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/Item3.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/PricePair.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/ItemInfo.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/Item4.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/Item5.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/ItemInfo3.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/ItemInfo3Key.java', 'java', null, true)
            tr
                td 예시 코드 - @OneToOne 단방향
                td
                    +codeBtn('/Repositories/STS/jpa-example/src/main/resources/ddl/jpa_user_card.sql', 'sql', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/test/java/io/github/donggi/jpa/dao/UserCard1DaoTests.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/UserCard1.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/User3.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/AbstractUser3.java', 'java', null, true)
            tr
                td 예시 코드 - @OneToOne 양방향
                td
                    +codeBtn('/Repositories/STS/jpa-example/src/main/resources/ddl/jpa_user_card.sql', 'sql', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/test/java/io/github/donggi/jpa/dao/UserCard2DaoTests.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/UserCard2.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/UserWithCard1.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/AbstractUser3.java', 'java', null, true)
            tr
                td 예시 코드 - @ManyToOne 단방향
                td
                    +codeBtn('/Repositories/STS/jpa-example/src/main/resources/ddl/jpa_user_card.sql', 'sql', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/test/java/io/github/donggi/jpa/dao/UserCard3DaoTests.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/UserCard3.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/User3.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/AbstractUser3.java', 'java', null, true)
            tr
                td 예시 코드 - @ManyToOne, @OneToMany 양방향
                td
                    +codeBtn('/Repositories/STS/jpa-example/src/main/resources/ddl/jpa_user_card.sql', 'sql', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/test/java/io/github/donggi/jpa/dao/UserCard4DaoTests.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/UserCard4.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/UserWithCard2.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/AbstractUser3.java', 'java', null, true)
            tr
                td 예시 코드 - @OneToMany 단방향
                td
                    +codeBtn('/Repositories/STS/jpa-example/src/main/resources/ddl/jpa_user_card.sql', 'sql', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/test/java/io/github/donggi/jpa/dao/UserCard5DaoTests.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/UserWithCard3.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/UserCard5.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/AbstractUser3.java', 'java', null, true)
            tr
                td 예시 코드 - @ElementCollection
                td
                    +codeBtn('/Repositories/STS/jpa-example/src/main/resources/ddl/jpa_gacha.sql', 'sql', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/test/java/io/github/donggi/jpa/dao/GachaWithOddsDaoTests.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/GachaOdds.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/GachaWithOdds.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/dao/GachaOddsDao.java', 'java', null, true)
            tr
                td 예시 코드 - @JoinTable
                td
                    +codeBtn('/Repositories/STS/jpa-example/src/main/resources/ddl/jpa_guild.sql', 'sql', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/test/java/io/github/donggi/jpa/dao/GuildWithMemberDaoTests.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/GuildWithMember.java', 'java', null, true)
            tr
                td 예시 코드 - InheritanceType.SINGLE_TABLE
                td
                    +codeBtn('/Repositories/STS/jpa-example/src/main/resources/ddl/jpa_voice.sql', 'sql', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/test/java/io/github/donggi/jpa/dao/Voice1DaoTests.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/Voice1.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/VoiceWithCue1.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/VoiceWithActor1.java', 'java', null, true)
            tr
                td 예시 코드 - InheritanceType.JOINED
                td
                    +codeBtn('/Repositories/STS/jpa-example/src/main/resources/ddl/jpa_voice.sql', 'sql', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/test/java/io/github/donggi/jpa/dao/Voice2DaoTests.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/Voice2.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/VoiceWithCue2.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/VoiceWithActor2.java', 'java', null, true)
            tr
                td 예시 코드 - InheritanceType.TABLE_PER_CLASS
                td
                    +codeBtn('/Repositories/STS/jpa-example/src/main/resources/ddl/jpa_voice.sql', 'sql', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/test/java/io/github/donggi/jpa/dao/Voice3DaoTests.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/Voice3.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/VoiceWithCue3.java', 'java', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/VoiceWithActor3.java', 'java', null, true)

        h2 EntityManager
        div
            h3 Persistence context; 영속 컨텍스트
            ul
                li DB에서 읽어오거나 DB로 삽입하고자 추가한 객체들은 영속 객체(Persistence object)들로, EntityManager가 관리하는 영속 컨텍스트에 보관된다
                p 트랜잭션(@Transactional 포함) 안에서 엔티티 수정 시 트랜잭션 커밋 시점에 자동 반영. 또는 flush()로 즉시 반영
                li 트랜잭션 커밋 시점 또는 명시적인 flush() 호출로 영속 컨텍스트의 변경 사항이 DB에 실제 반영된다
                li 영속 객체는 (타입 + 식별자)를 키로 하는 Map으로 관리된다
                ul
                    li 이를 이용해 조회(find)하려는 엔티티가 이미 컨텍스트에 있다면 DB에 쿼리를 보내지 않고 즉시 컨텍스트의 객체를 반환한다
                    li @Id를 @GeneratedValue(strategy = GenerationType.IDENTITY)로 구성하는 경우, 커밋 전에 식별자를 얻기 위해 미리 insert 쿼리가 실행된다
                li 영속 객체 생애 주기
                +w3img('/imgs/20200731_215700.png', 'Entity Life Cycle')
                ul
                    li Managed : 변경이 존재하면 DB에 반영됨
                    li Detached : EntityManager가 닫혔거나, 롤백되어 분리된 상태. 변경이 DB에 반영되지 않음
                    li Removed : 커밋 또는 flush() 호출 시 DB에서 삭제
            h3 EntityManager를 직접 관리하는 경우
            ol
                li EntityMaganerFactory를 만든다
                li EntityManager가 필요할 때마다 팩터리로부터 하나 생성하고, 사용한 뒤에 직접 닫는다
                li 트랜잭션이 여러 메서드에 걸쳐있는 경우, 동일한 EntityManager를 이용함을 직접 보장해야 한다
                p 메서드 파라미터로 넘기거나 ThreadLocal을 이용하거나... 구현은 자유
            h3 EntityManager를 컨테이너에서 관리하는 경우
            p @PersistenceContext로 현재 EntityManager 인스턴스를 주입받으면 된다. Spring Data JPA 에서는 @Autowired도 가능
            h3 메서드
            ul
                li void persist(Object entity)
                p 객체를 영속 컨텍스트에 등록하여 변경이 DB에 반영되도록 한다
                li &lt;T> T find(class&lt;T> entityClass, ...)
                p 지정 (타입 + 기본키)를 이용해 객체를 조회한다. 영속 컨텍스트에 있다면 DB를 조회하지 않고 해당 객체를 반환한다. DB에도 없으면 null 리턴
                li &lt;T> T getReference(class&lt;T> entityClass, Object primaryKey)
                ul
                    li 쿼리 지연 실행. 우선 T 프록시를 반환. 프록시 최초 사용 시 쿼리 실행되며, DB에 없으면 EntityNotFoundException
                    li 사용하는 EntityManager를 닫기 전에 프록시를 사용해야 쿼리가 실행된다
                    li Hibernate의 경우, final entity class에 대하여 쿼리 즉시 실행
                li void remove(Object entity)
                p 객체를 DB에서 삭제하도록 한다
                li void detach(Object entity)
                p 객체를 영속 컨텍스트로부터 분리한다. 따라서 영속 객체의 변경 사항이 DB에 반영되지 않도록 한다
                li void clear()
                p 영속 컨텍스트를 비우고 모든 객체를 detached 상태로 변경한다
                li &lt;T> T merge(T entity)
                p 객체를 현재 영속 컨텍스트에 등록한다
                li boolean contains(Object entity)
                p 객체가 영속 컨텍스트에 포함됐는지 여부
                li void flush()
                p 영속 컨텍스트를 DB로 동기화한다
                li void refresh(Object entity, ...)
                p 특정 객체를 DB로부터 동기화한다
                li void lock(Object entity, LockModeType lockMode, ...)
                p 영속 컨텍스트의 객체를 잠근다
                //- Query createQuery(String qlString)
                //- https://javaee.github.io/javaee-spec/javadocs/javax/persistence/EntityManager.html
        h2 @Entity
        ul
            li DB 입출력 단위
            li 기본 생성자 필수. @Id 최소 한 개 지정 필수
            li 원활한 프록시 동작을 위해 protected 이상, non-final 클래스로 정의
        +asCode('java', '@Entity 예').
            @Entity
            public class MMonster {}
            @Entity(name = "m_monster_v2")
            public class MMonster {}
        h2 @Table
        ul
            li @Entity 클래스에 name, catalog, index, schema, UniqueConstraint 설정 추가
            li name 속성만 필요하다면 @Entity에 직접 설정 가능
        h2 @Id
        p 기본키 컬럼 명시. 기본 타입 + Wrapper 타입, Date, BigInteger, BigDecimal 타입만(should) 가능
        h2 @GeneratedValue, @SequenceGenerator, @TableGenerator
        ul
            +asCode('java', '기본키 자동 설정').
                @Id
                @GeneratedValue(strategy = GenerationType.IDENTITY)
                private Long userId;
            li strategy = GenerationType.IDENTITY
            p DB 설정(MySQL auto_increment, PostgreSQL serial) 그대로 이용. insert 실행 후 실제 값이 설정된다
            li generator = "gen_name" : 시퀀스 또는 ID 생성 테이블 이용
            +asCode('java', '1. 시퀀스').
                @Id
                @SequenceGenerator(name = "gen_name", sequenceName = "jpa_user2_user_id_seq", allocationSize = 1)
                @GeneratedValue(generator = "gen_name")
                private Long userId;
            +asCode('java', '2. 테이블').
                @Id
                @TableGenerator(
                    name = "gen_name",
                    table = "jpa_id",                    // 테이블 이름
                    pkColumnName = "id_name",            // 테이블 기본키
                    pkColumnValue = "jpa_user2_user_id", // 기준 행을 찾기 위한 기본키 값
                    valueColumnName = "next_id",         // id로 사용할 컬럼 이름
                    initialValue = 0,                    // 테이블에 행이 없는 경우 초기값으로 이용
                    allocationSize = 1
                )
                @GeneratedValue(generator = "gen_name")
                private Long userId;
        h2 @Temporal
        p date, time, timestamp 컬럼 명시. 각각 java.sql.Date, java.sql.Time, java.sql.Timestamp에 매핑
        h2 @Column
        ul 필드 또는 getter 메서드에 대해 컬럼 명시
            li name : 컬럼 이름
            li unique : 이 컬럼만으로 unique key인 경우
            li length : 텍스트 길이
            li precision, scale : decimal 정밀도
            li insertable : insert 포함 여부
            li updatable : update 포함 여부
            +asCode('java').
                @Temporal(TemporalType.TIMESTAMP)
                @Column(insertable = false, updatable = false)
                    // ↑ false면 쿼리 실행 후 컬럼 값이 변경되도 객체에 반영되지 않음
                private Date addDate;
        h2 @Transient 또는 transient 한정자
        p 해당 필드는 persistence 대상에서 제외
        h2 @Enumerated
        p enum 매핑 : EnumType.ORDINAL, STRING 2가지만 가능
        h2 @Convert, @Converter
        p 커스텀 컨버터 지정 
            +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/ApiLog.java', 'java', [19], true)
            +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/enums/ApiResultCode.java', 'java', [9], true)
        h2 @DynamicInsert, @DynamicUpdate
        ul
            li Non-null 컬럼만 insert, update 시 이용
            li 세션 당 최초 1번만 적용된다
            li 쿼리 실행 후 생략된 컬럼 값이 변경되더라도, 객체에 설정되지 않는다
            +codeBtn('/Repositories/STS/jpa-example/src/test/java/io/github/donggi/jpa/dao/UserDaoTests.java', 'java', [35,47], true)
            +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/User1.java', 'java', [19], true)

        h2 다른 엔티티/값 포함
        div
            h3 Value Class
            ul
                li 여타 언어들의 ValueType에 해당하는 클래스
                p 값을 이용해 다른 인스턴스와 비교하며, 자기 자신을 변경하지 않는다
                li 값을 변경하는 연산은 새 인스턴스를 반환한다
                li JPA에서는 @Embeddable 클래스로 Value Class를 정의한다
            h3 유의사항
            ul
                li 엔티티 포함이 많아질수록 코드 결합도가 증가한다
                li 모든 테이블이 엔티티인 것은 아니다
                strong 서로 다른 두 엔티티의 라이프사이클은 독립적이다
                li 포함하려는 대상과의 관계가 엔티티:엔티티인지, 엔티티:밸류인지 명확히 파악해야 한다
                p 엔티티:밸류 관계를 엔티티:엔티티 관계로 사용하면 불필요한 추가 작업이 발생할 수 있다
                li @OneToMany 매핑을 사용하려는 경우, 정말로 모든 연관 엔티티가 필요한 지 고려할 것
                li @ManyToMany 매핑을 사용하려는 경우, JoinTable을 엔티티로 사용하는 게 낫지 않은 지 고려
            div
                h4 Hibernate 컬렉션 자료형
                table
                    +ths('사용 타입', 'Hibernate가 실제로 인스턴스화하는 타입')
                    +tds('List', 'ArrayList')
                    +tds('Set', 'HashSet')
                    +tds('Map', 'HashMap')
                    +tds('SortedSet', 'TreeSet')
                    +tds('SortedMap', 'TreeMap')
                h4 Sorted 자료형의 정렬자 지정
                ul
                    li 요소가 Comparable하면 @org.hibernate.annotations.SortNatural 사용
                    li 그렇지 않으면 @org.hibernate.annotations.SortComparator로 Comparator 지정
                h4 @org.hibernate.annotations.OrderBy
                p JPA의 것과 다르게 JPQL order by 절을 이용해 DBMS가 정렬하도록 한다
                +asCode('java') @OrderBy("score desc")
            h3 @Embedded로 @Embeddable 타입 포함
            ul
                li 엔티티 필드 일부를 하나의 @Embeddable 클래스로 묶을 수 있다. 
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/Price.java', 'java', [9], true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/Item1.java', 'java', [12], true)
                li @AttributeOverride를 이용해 동일 @Embeddable 클래스를 여러 개 이용하는 경우에 대처할 수 있다
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/Item2.java', 'java', [15], true)
                li @Embeddable 클래스의 필드 일부도 다른 @Embeddable 클래스로 묶을 수 있다
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/PricePair.java', 'java', [12], true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/Item3.java', 'java', [12], true)
            h3 @Embeddable 클래스로 복합키 정의
            p 복합키 클래스는 Serializable 인터페이스를 구현하고, equals(), hashCode()를 적절히 재정의해야 한다. 
                +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/ItemInfo3Key.java', 'java', [12], true)
                +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/ItemInfo3.java', 'java', [10], true)
            h3 @SecondaryTable 포함
            ul
                li 포함하는 대상은 secondary table, 포함하는 쪽은 primary table
                li Default로 primary table의 기본키를 그대로 이용하여 조회한다 
                    +codeBtn('/Repositories/STS/jpa-example/src/main/resources/ddl/jpa_item.sql', 'sql', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/ItemInfo.java', 'java', [9], true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/Item4.java', 'java', [17], true)
                li pkJoinColumns으로 secondary table 기본키를 설정할 수 있다 
                    +codeBtn('/Repositories/STS/jpa-example/src/main/resources/ddl/jpa_item.sql', 'sql', null, true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/ItemInfo.java', 'java', [9], true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/Item5.java', 'java', [18], true)
                li Select에 이용되는 쿼리는 left outer join이다
            h3 엔티티 사이의 1:1, 1:N, N:1, M:N 매핑
            div
                h4 @OneToOne
                ul
                    li 1→1 단방향 매핑 
                        +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/UserCard1.java', 'java', [13], true)
                    ul
                        li @JoinColumn으로 기본키를 설정한다. @SecondaryTable과는 다르게 조인 컬럼 자체를 영속 필드로 가질 수는 없고, 대신 매핑된 엔티티 변경에 따라 자동으로 조인 컬럼 값을 변경한다
                        li 두 테이블의 기본키가 동일한 경우 @JoinColumn 대신 @PrimaryKeyJoinColumn을 이용할 수 있다
                        p 이 경우 신규 엔티티 삽입을 위해 식별자가 필요하므로, 참조하는 테이블의 신규 엔티티가 먼저 영속 컨텍스트에 등록되어야 한다
                    li 1→1 단방향 매핑을 그대로 양방향 매핑으로 이용 
                        +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/UserCard2.java', 'java', [13], true)
                        +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/UserWithCard1.java', 'java', [13], true)
                    +asCode('java') @OneToOne(mappedBy = "fieldName")
                h4 @ManyToOne, @OneToMany
                ul
                    li N→1 단방향 매핑 
                        +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/UserCard3.java', 'java', [13], true)
                    p @OneToOne 단방향 매핑과 다를 게 없다. 다만 N:1 관계이므로 두 테이블의 기본키가 동일할 수는 없다
                    li N→1 단방향 매핑을 그대로 양방향 매핑으로 이용 
                        +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/UserCard4.java', 'java', [13], true)
                        +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/UserWithCard2.java', 'java', [15], true)
                    +asCode('java') @OneToMany(mappedBy = "fieldName")
                    li 1→N 단방향 매핑 
                        +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/UserWithCard3.java', 'java', [16], true)
                h4 @JoinTable
                ul
                    li JoinTable? : 검색에 필요한 두 테이블의 키 컬럼만 모은 테이블
                    li 1→N 단방향 매핑 예 
                        +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/GuildWithMember.java', 'java', null, true)
                    li @OneToMany 대신 @ManyToMany 이용 가능
                    li mappedBy를 이용해 양방향 매핑 가능
                h4 fetch 속성 - 쿼리 지연 실행
                p Default로 처음부터 연관 테이블을 함께 조회(left outer join)한다. fetch 속성으로 변경할 수 있다
                +asCode('java') @OneToOne(fetch = FetchType.LAZY)
                h4 cascade 속성 - 영속성 전이 규칙
                ul
                    li 기본값은 {}으로 아무런 추가 작업이 없다
                    li CascadeType.PERSIST : EntityManager::persist 시 연관 엔티티도 추가
                    li CascadeType.REMOVE : EntityManager::remove 시 연관 엔티티도 삭제
                    li CascadeType.DETACH : EntityManager::detach 시 연관 엔티티도 분리
                    li CascadeType.REFRESH : EntityManager::refresh 시 연관 엔티티도 갱신
                    li CascadeType.MERGE : EntityManager::merge 시 연관 엔티티도 추가
                    li CascadeType.ALL

            h3 @ElementCollection으로 프로젝션
            ul
                li Embeddable 클래스도 가져올 수 있다 
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/GachaWithOdds.java', 'java', [18], true)
                li 당연히 JPQL로도 가능하다 
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/dao/GachaOddsDao.java', 'java', [12], true)
                    +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/GachaOdds.java', 'java', [12], true)

        h2 클래스 상속과 테이블 매핑
        div
            h3 InheritanceType.SINGLE_TABLE
            p 클래스 계층 구조가 하나의 테이블을 공유하고, 각각 일부분씩 매핑. 구분을 위한 컬럼(@DiscriminatorColumn) 존재 
                +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/Voice1.java', 'java', [17], true)
                +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/VoiceWithCue1.java', 'java', [10], true)
                +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/VoiceWithActor1.java', 'java', [10], true)
                +codeBtn('/Repositories/STS/jpa-example/src/main/resources/ddl/jpa_voice.sql', 'sql', null, true)
            h3 InheritanceType.JOINED
            p 각 클래스는 키를 공유하는 별개의 테이블에 대응 
                +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/Voice2.java', 'java', [14], true)
                +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/VoiceWithCue2.java', 'java', [11], true)
                +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/VoiceWithActor2.java', 'java', [11], true)
                +codeBtn('/Repositories/STS/jpa-example/src/main/resources/ddl/jpa_voice.sql', 'sql', null, true)
            h3 InheritanceType.TABLE_PER_CLASS
            p 각 클래스는 별개 테이블에 대응 → 키 관리에 유의 
                +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/Voice3.java', 'java', [14], true)
                +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/VoiceWithCue3.java', 'java', [11], true)
                +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/VoiceWithActor3.java', 'java', [11], true)
                +codeBtn('/Repositories/STS/jpa-example/src/main/resources/ddl/jpa_voice.sql', 'sql', null, true)
            h3 @MappedSuperclass - 공유 컬럼 정의
            p add_date, upd_date 같은 일반적인 공유 컬럼을 한 곳에 정의할 수 있다 
                +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/User3.java', 'java', [6], true)
                +codeBtn('/Repositories/STS/jpa-example/src/main/java/io/github/donggi/jpa/entity/AbstractUser3.java', 'java', [17], true)

        h2 트랜잭션
        div
            h3 RESOURCE_LOCAL 타입 트랜잭션
            ul
                li JPA의 EntityTransaction을 이용한 트랜잭션 처리
                li Spring Data JPA는 공유 EntityManager 인스턴스로 직접 트랜잭션 관리하는 것을 허용하지 않는다
                +asCode('java').
                    @Autowired
                    private EntityManager manager;
                    @Test
                    void test() {
                        assertFalse(manager.isJoinedToTransaction());
                        manager.getTransaction().begin();
                        // java.lang.IllegalStateException: Not allowed to create transaction on shared EntityManager - use Spring transactions or EJB CMT instead
                        manager.getTransaction().commit();
                    }
            h3 JTA(Java Transaction API) 타입 트랜잭션
            ul
                li 직접 트랜잭션을 관리하는 경우
                +asCode('java').
                    UserTransaction transaction;
                    EntityManager manager;

                    transaction.begin();
                    manager.joinTransaction();
                        // 트랜잭션에 참여시킨다. isJoinedToTransaction()으로 참여 여부 확인 가능
                        // 트랜잭션 시작 후에 EntityManager가 초기화됐다면 자동으로 참여된다
                    try {
                        transaction.commit();
                    } catch {
                        transaction.rollback();
                    }
                li 외부 컨테이너에서 관리하는 경우 : @Transactional 이용
                ul
                    li @Transactional은 전후에 트랜잭션의 시작, 커밋을 자동으로 진행한다
                    p RuntimeException을 포함하여, 예외를 감지하면 자동으로 롤백한다
                    li 클래스, 메서드 둘 다에 적용 가능하고, 메서드에 붙으면 클래스의 것을 오버라이드한다
                    li @Transactional 메서드가 다른 @Transactional 메서드를 호출하고, 해당 메서드에서 롤백이 발생하면 default로 전역 롤백한다
                    p
                        +asA('https://docs.spring.io/spring/docs/5.2.8.RELEASE/javadoc-api/org/springframework/transaction/support/AbstractPlatformTransactionManager.html#setGlobalRollbackOnParticipationFailure-boolean-')
                        | 로 변경 가능
                +asCode('java').
                    @Test
                    @Transactional
                    @Rollback(false) // 테스트 자동 롤백하지 않도록 설정
                    void updateUser() {
                        assertTrue(manager.isJoinedToTransaction());
                    }
            h3 잠금
            div
                h4 선점 잠금; Pessimistic lock; select for update
                p 트랜잭션 내에서, 차후 수정을 위해 미리 행을 잠근다
                +asCode('java').
                    // 즉시
                    entityManager.find(..., LockModeType.PESSIMISTIC_WRITE);
                    // timeout
                    hints = new HashMap&lt;String, Object>();
                    hints.put("javax.persistence.lock.timeout", 1234);
                    entityManager.find(..., LockModeType.PESSIMISTIC_WRITE, hints);
                    // JPQL
                    query = entityManager.createQuery(...);
                    query.setLockMode(LockModeType.PESSIMISTIC_WRITE);
                h4 비선점 잠금; Optimistic lock
                p 테이블에 버전 컬럼(정수, timestamp)이 존재하여, 순차적인 update만 허용하도록 강제
                +asCode('java').
                    @Entity
                    public class Something {
                        // ...
                        @Version
                        private Integer ver;
                    }

        h2 하이버네이트 관련 추가 기록
        ul
            li 지연 로딩된 프록시 인스턴스의 실제 클래스 반환
            +asCode('java') HibernateProxyHelper.getClassWithoutInitializingProxy(proxy)
            li 쿼리 생성 설정
            p DBMS 버전에 맞춰 설정 필요
            +asCode('ini') spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQL10Dialect
            li 로깅 관련 설정
            +asCode('ini', 'application.properties').
                spring.jpa.properties.hibernate.show_sql=true           # 실행 sql 출력
                spring.jpa.properties.hibernate.format_sql=true         # sql 보기 좋게 출력
                spring.jpa.properties.hibernate.use_sql_comments=true   # sql 주석 출력
                logging.level.org.hibernate.type.descriptor.sql=trace   # 컬럼 값 출력
            li @Subselect
            p 쿼리 결과를 엔티티로 사용할 수 있게 해준다
            +asCode('java').
                @Entity
                @Immutable // 읽기 전용
                @Subselect("select ...")
                @Synchronize({"Entity1", "Entity2"}) // Subselect 실행 전에 Entity1, Entity2 타입 엔티티 중 변경이 있는 것은 DB에 반영
                public class ClassName {}

    h1 JPA Query
    div
        h2 JPQL; JPA Query Language
        ul
            li SQL과 유사한 쿼리 언어로, 테이블-컬럼 대신 엔티티-속성 이름을 이용한다
            +asCode('sql').
                SELECT ... FROM ...
                [WHERE ...]
                [GROUP BY ... [HAVING ...]]
                [ORDER BY ...]
            li 엔티티 이름 ::= @Entity 적용한 클래스 이름. name 속성을 이용한 경우 해당 값
            +asCode('java').
                query = entityManager.createQuery(query[, ResultType.class]);
                result = query.getResultList();
                result = query.getSingleResult(); // 결과가 1개임이 보장되는 경우
            li 일반적인 SQL 문도 사용할 수 있다
            +asCode('java').
                query = entityManager.createNativeQuery("insert into t_user_12 (id, name) values (?, ?)");
                query.setParameter(1, 123).setParameter(2, "name");
                query.executeUpdate();
            li JPQL은 항상 실행되며, 결과 엔티티가 이미 컨텍스트에 존재하면 버려진다
            li update, delete는 기존 영속 컨텍스트에 반영 안 됨
            +asCode('java').
                query = entityManager.createQuery("update User set level = level + 1");
                query.executeUpdate();
        div
            h3 select 절
            ul
                li select 절은 반환할 매핑에 대한 완전한 정보를 가져야 한다. 따라서 "select *"은 유효한 문법이 아니다
            +asCode('sql').
                select id, name      from Card
                select c.id, c.name  from Card as c
                select c.id, c.name  from Card c
                select c             from Card c

                select distinct name from Card

                select new io.github.donggi.jpa.entity.GachaOdds$Minimal(id.seqNo, objectId, odd) from jpa_gacha_odds
            h3 from 절(조인)
            ul
                li where 절에서 엔티티의 필드가 다른 엔티티를 참조하는 경우, 자동으로 join된다
                li join 명시
                +asCode('sql').
                    from Entity e join e.field f       -- == INNER JOIN
                    from Entity e inner join e.field f

                    from Entity e left join e.field f  -- == LEFT OUTER JOIN
                    from Entity e left outer join e.field f

                    -- 엔티티 정의에 명시된 join 조건은 자동으로 on으로 구성되므로 생략 가능
                    from Entity e join e.field f on f.num > 10
                li join fetch
                ul
                    li Entity의 field가 다른 엔티티의 참조/컬렉션일 때, join은 해당 필드를 프록시/컬렉션 래퍼로 설정한다. 아래와 같이 join fetch로 실행하면 field까지 모두 가져와 설정한다
                    +asCode('sql') select e from Entity e [left [outer] | inner] join fetch e.field
                    li distinct 사용없이 "select e1 from Entity1 e1 join fetch e1.field e2"를 실행한 리스트의 e1과 e2의 개수는 같음에 유의
                    li distinct 사용없이 "select e1 from Entity1 e1 join fetch e1.field e2"를 페이징 실행하면 중복을 제거함에 유의
                    p 데이터가 많은 경우 큰 오버헤드 발생
            h3 where 절
            +asCode('sql').
                where x.field = 0
                where x.field &lt;> 0
                where x.field between 0 and 10
                where x.field in (0, 1, 2)
                where x.field not in (0, 1, 2)
                where x.field like '%ooo%'
                where x.field not like '%ooo%'
                where x.field is null
                where x.field is not null

                where x.collection is empty
                where x.collection is not empty
                where :obj member of x.collection
                where :obj not member of x.collection

                where (condition1 and condition2) or condition3
            +asCode('java').
                query = entityManager.createQuery("... where x.field = ?");
                query.setParameter(0, obj);

                query = entityManager.createQuery("... where x.field = :obj");
                query.setParameter("obj", obj);
            h3 group by 절
            div
                h4 집계함수 없이 사용 == distinct
                +asCode('sql') select x.id from X x group by x.id
                h4 집계함수
                table
                    +ths('함수', '반환 타입')
                    +tds('count', 'Long')
                    +tds('max, min', '대상 타입')
                    +tds('avg', 'Double')
                    +tds('sum', 'Long, Double, BigInteger, BigDecimal')
                h4 집계함수 사용 without group by
                +asCode('sql') select count(u) from User u
                h4 집계함수 사용 with having
                +asCode('sql').
                    select u.type, count(u)
                    from User u
                    where u.addDate > '2020-01-02'
                    group by u.type
                    having count(u) > 100
            h3 order by 절
            ul
                li select 절에 정의한 매핑에 포함되거나, 그로부터 직접 도달할 수 있는 필드만 이용 가능하다
                li 또, 정렬 가능하기 위해 필드의 타입은 Comparable해야 한다
            +asCode('sql').
                order by x.field
                order by x.field1 desc, x.field2
            h3 페이징
            +asCode('java').
                query = entityManager.createQuery(...);
                query.setFirstResult(10); // 10번째부터
                query.setMaxResults(3);   // 최대 3개 획득
            h3 서브쿼리
            p where, having 절에서 사용 가능
            +asCode('sql').
                where exists(select ...)
                where 100 > all(select ...)
                where 100 = any(select ...)
                where x.field in (select ...)
            h3 조건식
            ul
                li case when condition then expr1 else expr2 end
                li case target when expr1 then expr2 else expr3 end
                li coalesce(expr1, expr2[, ...])
                p 최초로 null이 아닌 것 반환. SQL의 IFNULL 대신 사용 가능
                li nullif(expr1, expr2)
                p 두 값이 같으면 null. 다르면 expr1
            h3 리터럴
            table
                +ths('타입', '표기')
                tr
                    td 문자열
                    td 'string', 'It''s good'
                tr
                    td 수
                    td 123, 123L, 123D, 123F
                tr
                    td 시각
                    td DATE {d '2000-01-01'}
                        br
                        | TIME {t '12:34:56'}
                        br
                        | TIMESTAMP {ts '2000-01-01 12:34:56.789'}
                tr
                    td Boolean
                    td true, false
                tr
                    td Enum
                    td package.EnumName.FIELD_NAME
            h3 함수
            div
                h4 문자열
                ul
                    li concat(str1, str2[, ...])
                    li substring(str, start[, length])
                    li trim([METHOD] [CHAR] from] str)
                    ul
                        li METHOD : LEADING, TRAILING, BOTH(default)
                        li CHAR : default ' '
                    li lower(str), upper(str)
                    li length(str)
                    li locate(search, str[, start])
                    p start부터 search 문자열을 찾아 최초 위치(1부터 시작)를 반환한다. 없으면 0
                h4 수
                ul
                    li abs(math_expression)
                    li sqrt(math_expression)
                    li mod(math_expression1, math_expression2)
                h4 시각
                ul
                    li CURRENT_DATE
                    li CURRENT_TIME
                    li CURRENT_TIMESTAMP
                    | ↓ Hibernate
                    li YEAR(), MONTH(), DAY(), HOUR(), MINUTE(), SECOND()
                h4 컬렉션
                ul
                    li size(collection)
                    li index(collection_alias)
                    p 특정 인덱스의 요소만 가져올 때 사용한다
                    +asCode('sql').
                        select c.name
                        from UserCard uc join uc.cards c
                        where index(c) = 3
                h4 타입
                ul
                    li type(x) : x의 타입
                    li treat(x as Entity) : x를 Entity로 캐스팅
        h2 Criteria
        ul
            li 문자열 대신 Java API로 쿼리 동적 생성
            +asCode('java').
                var builder = entityManager.getCriteriaBuilder();
                var cQuery = builder.createQuery([ResultType.class])
                var root = cQuery.from(RootType.class);
                cQuery.select(root);
                var query = entityManager.createQuery(cQuery);
            li Single selection
            +asCode('java').
                // select distinct name from Card
                cQuery.select(root.get("name")).distinct(true)
            li Multi selection
            +asCode('java').
                // select name, some.extra from Card
                    // return type == Object[]
                cQuery.select(builder.array(root.get("name"), root.get("some").get("extra")))
                cQuery.multiselect(root.get("name"), root.get("some").get("extra"))
                    // return type == Tuple
                cQuery.select(builder.tuple(root.get("name"), root.get("some").get("extra")))
                    // return type == ResultType
                cQuery.select(builder.construct(ResultType.class, root.get("name"), root.get("some").get("extra")))
            li Join
            +asCode('java').
                // select g, o from Gacha g left join g.odds o
                var g = cQuery.from(Gacha.class);
                var o = g.join("odds", JoinType.LEFT);
                    // join fetch를 원한다면 g.fetch(...)
                cQuery.multiselect(g, o);
            li Where
            +asCode('java').
                // select c from Card where id > :x
                var c = cQuery.from(Card.class);
                cQuery.where(builder.gt(c.get("id"), x));
            li Group by
            +asCode('java').
                var c = cQuery.from(Country.class);
                cQuery.multiselect(c.get("currency"), builder.sum(c.get("population")));
                cQuery.where(builder.isMember("Europe", c.get("continents")));
                cQuery.groupBy(c.get("currency"));
                g.having(builder.gt(builder.count(c), 1));
                // builder::count, max, min, avg, asum, sumAsLong, sumAsDouble
            li Order by
            +asCode('java').
                var c = cQuery.from(Country.class);
                cQuery.orderBy(builder.asc(c.get("currency")), builder.desc(c.get("population")))
            li Literal
            +asCode('java') builder.literal(...);
            li Type
            +asCode('java') builder.equal(expression.type(), builder.literal(TargetType.class));
            li Expressions
            +asCode('java').
                builder::and, or, not, isTrue
                builder::gt, greaterThan, lt, lessThan, equal, between, isNull
                builder::sum, diff, prod, quot(/), mod, abs, neg, sqrt
                builder::like, notLike, length, locate, lower, upper, trim, concat, substring
                builder::isEmpty, isMember, in, size
                builder::currentDate, currentTime, currentTimestamp
        div
            h3 @StaticMetamodel
            p 엔티티 필드에 대한 메타데이터를 제공하여 Criteria 이용시 정적인 타입 체크를 강화해준다
            +asCode('java', '엔티티').
                @Entity
                public class Team {
                    @Id
                    private Long id;
                    @OneToMany(mappedBy = "team")
                    private Set&lt;Player> players;
                }
            +asCode('java', '메타 모델').
                @StaticMetamodel(Team.class)
                public class Team_ {
                    public static SingularAttribute&lt;Team, Long> id;
                    public static SetAttribute&lt;Team, Player> players;
                }
            +asCode('java', 'Criteria 사용').
                var team = cQuery.from(Team.class);
                builder.between(team.get(Team_.id), 100L, 1000L);
            div
                h4 메타 모델 자동 생성
                p "jpa model generator" 검색하면 여러 외부 라이브러리 또는 IDE 애드온이 검색되니 참고

    h1 Spring Data JPA 사용
    div
        h2 JpaRepository&lt;Entity, ID>
        ul
            li 이 인터페이스를 상속하면 findAll, findById, save, delete, flush 등의 메서드를 자동으로 구성한다
            p JpaRepository -> PagingAndSortingRepository -> CrudRepository
            li 명명규칙에 맞는 새 메서드들을 자동으로 구현한다
            table
                caption 출처 : 
                    +asA('https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.query-creation')
                tr
                    th Keyword
                    th Sample
                    th JPQL snippet
                tr
                    td And
                    td findByLastnameAndFirstname
                    td … where x.lastname = ?1 and x.firstname = ?2
                tr
                    td Or
                    td findByLastnameOrFirstname
                    td … where x.lastname = ?1 or x.firstname = ?2
                tr
                    td Is, Equals
                    td findByFirstname,findByFirstnameIs,findByFirstnameEquals
                    td … where x.firstname = ?1
                tr
                    td Between
                    td findByStartDateBetween
                    td … where x.startDate between ?1 and ?2
                tr
                    td LessThan
                    td findByAgeLessThan
                    td … where x.age &lt; ?1
                tr
                    td LessThanEqual
                    td findByAgeLessThanEqual
                    td … where x.age &lt;= ?1
                tr
                    td GreaterThan
                    td findByAgeGreaterThan
                    td … where x.age &gt; ?1
                tr
                    td GreaterThanEqual
                    td findByAgeGreaterThanEqual
                    td … where x.age &gt;= ?1
                tr
                    td After
                    td findByStartDateAfter
                    td … where x.startDate &gt; ?1
                tr
                    td Before
                    td findByStartDateBefore
                    td … where x.startDate &lt; ?1
                tr
                    td IsNull, Null
                    td findByAge(Is)Null
                    td … where x.age is null
                tr
                    td IsNotNull, NotNull
                    td findByAge(Is)NotNull
                    td … where x.age not null
                tr
                    td Like
                    td findByFirstnameLike
                    td … where x.firstname like ?1
                tr
                    td NotLike
                    td findByFirstnameNotLike
                    td … where x.firstname not like ?1
                tr
                    td StartingWith
                    td findByFirstnameStartingWith
                    td … where x.firstname like ?1 (parameter bound with appended %)
                tr
                    td EndingWith
                    td findByFirstnameEndingWith
                    td … where x.firstname like ?1 (parameter bound with prepended %)
                tr
                    td Containing
                    td findByFirstnameContaining
                    td … where x.firstname like ?1 (parameter bound wrapped in %)
                tr
                    td OrderBy
                    td findByAgeOrderByLastnameDesc
                    td … where x.age = ?1 order by x.lastname desc
                tr
                    td Not
                    td findByLastnameNot
                    td … where x.lastname &lt;&gt; ?1
                tr
                    td In
                    td findByAgeIn(Collection&lt;Age&gt; ages)
                    td … where x.age in ?1
                tr
                    td NotIn
                    td findByAgeNotIn(Collection&lt;Age&gt; ages)
                    td … where x.age not in ?1
                tr
                    td True
                    td findByActiveTrue()
                    td … where x.active = true
                tr
                    td False
                    td findByActiveFalse()
                    td … where x.active = false
                tr
                    td IgnoreCase
                    td findByFirstnameIgnoreCase
                    td … where UPPER(x.firstame) = UPPER(?1)
        h2 JPQL
        +asCode('java').
            @Query("select new io.github.donggi.jpa.entity.GachaOdds$Minimal(id.seqNo, objectId, odd) from jpa_gacha_odds where id.gachaId = :gachaId")
            public List&lt;GachaOdds.Minimal> findMinimalOdds(@Param("gachaId") Long gachaId);

            // + SpEL
            @Modifying
            @Transactional
            @Query(value = "insert into match_info (accouunt_id, friend_id, match_id) values (:&#x23;{&#x23;me.key.myID}, :&#x23;{&#x23;me.key.frID}, :&#x23;{&#x23;me.matchID}), (:&#x23;{&#x23;fr.key.myID}, :&#x23;{&#x23;fr.key.frID}, :&#x23;{&#x23;fr.matchID})", nativeQuery = true)
            public void createNewMatch(@Param("me") MatchInfo me, @Param("fr") MatchInfo fr);


        h2 페이징
        ul
            li Pageable
            +asCode('java').
                @Query("...")
                public Page&lt;ReturnType> methodName(..., Pageable pageable);
            li findFirst, findTop, findFirstN, findTopN 명명규칙 이용
            +asCode('java').
                public List&lt;Card> findFirst10();
                public List&lt;Card> findFirst10ByName();
        h2 Specification을 이용한 검색 조건 조합
        ol
            li Specification을 인자로 받는 검색 메서드 정의
            +asCode('java').
                @Repository
                public interface ItemDao extends JpaRepository&lt;Item, Long> {
                    public List&lt;Item> findAll(Specification&lt;Item> spec);
                }
            li Specification 정의
            +asCode('java').
                public class ItemSpecs {
                    public static Specification&lt;Item> nameLike(String name) {
                        return (root, criteriaQuery, criteriaBuilder) -> criteriaBuilder.like(root.get("name"), '%' + name + '%');
                    }
                }
            li Specification static 메서드를 이용한 새 조건 생성
            ul
                li not(Specification&lt;T>)
                li where(Specification&lt;T>)
                li and(Specification&lt;T>)
                li or(Specification&lt;T>)
