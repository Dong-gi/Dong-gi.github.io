include ../../source/skeleton.pug
+post('Network', 'Network, TCP/IP, HTTP, HTTP1.1, HTTP2, HTTP3', 'Network 정리')
    h1 TCP/IP 4계층
    ol
        li Application : HTTP, FTP, DNS, SMTP, ...
        li Transport : TCP, UDP
        p 프로세스 간의 통신
        li Internet : IP, ARP, ICMP, ...
        p (가변적인) 논리적 주소를 갖는 두 호스트 간의 통신
        li Link : MAC; CSMA/CD, CSMA/CA, ...
        p 고정적인 물리적 주소를 갖는 두 노드 간의 통신

    h1 IP
    div
        h2 IPv4
        ul
            li 32bit : [0-255].[0-255].[0-255].[0-255]
            li Subnet & CIDR
            ul
                li 주소 소유자는 예약한 특정 접두 주소(subnet mask)를 제외한 나머지 부분을 자유롭게 할당하여 사용할 수 있다
                li A-class : 앞 8비트를 예약하고, 나머지 24비트를 자유롭게 할당. e.g. 123.0.0.0/8
                li B-class : 앞 16비트를 예약하고, 나머지 16비트를 자유롭게 할당. e.g. 123.123.0.0/8
                li 기타 관용적인 사설 네트워크 서브넷 : 10.0.0.0/8, 192.168.0.0/24
                li CIDR; Classless Inter-Domain Routing
                p 클래스없이 주소 블록 할당. e.g. 123.123.123.123/7
        
        h2 IPv6
        ul
            li 128bit : [0-ffff]:[0-ffff]:[0-ffff]:[0-ffff]:[0-ffff]:[0-ffff]:[0-ffff]:[0-ffff]
            li 접두 0은 제거할 수 있다 + 반복 적용 가능; 0123:A:0123 == 123:A:123
            li 0:0(:0)*은 :으로 축약할 수 있다 + 전체 주소에 대해 1회만 적용 가능; A:0:0:B == A::B

    h1 UDP; User Datagram Protocol
    div
        h2 특징
        ul
            li 비연결형
            p 특정 소켓으로의 전송, 임의 소켓으로부터의 수신 기능만 존재. 각 데이터그램은 모두 독립적이며, 65507 바이트보다 큰 메시지를 알아서 쪼개고 합치지 않는다.
            li 신뢰성 없음
            p 확인응답 없음 + 데이터그램 오류 탐지 시 단순 폐기
        h2 Datagram
        p Source port 16비트 | Destination port 16비트 | Total length(최대 65507바이트) 16비트 | Checksum 16비트 | Data


    h1 TCP; Transmission Control Protocol
    div
        h2 특징
        ul
            li 연결 지향
            p 연결 지속되는 채널을 이용해 스트림 전송. 스트림은 패킷들로 나눠지고, 이때 패킷은 IP 계층 전송 단위에 맞게 세그먼트로 표현된다
            li 송신 버퍼 + 수신 버퍼를 이용한 생산/소비 균형 조절
            li 신뢰성 있음
            p 패킷 순서 보장. ack 응답 및 응답 시간제한, 재전송 기능 제공
            li 전이중 통신
            p 동시에 양방향으로 패킷 전송 가능
            
        h2 연결 수립; 3-way handshaking
        ol
            li A -> B : SYN 세그먼트(#seq=a)
            li B -> A : SYN + ACK 세그먼트(#seq=b,#ack=a+1)
            li A -> B : ACK 세그먼트(#seq=a+1,#ack=b+1)
            p 양쪽이 동시에 연결을 요구하더라도 연결은 하나만 수립된다

        h2 연결 종료; 3-way handshaking
        ol
            li A -> B : FIN 세그먼트(#seq=a,#ack=b)
            li B -> A : FIN + ACK 세그먼트(#seq=b,#ack=a+1)
            li A -> B : ACK 세그먼트(#seq=a+1,#ack=b+1)

        h2 연결 종료; 4-way handshaking
        ol
            p 데이터를 보낼 게 남아있다면, FIN 요청은 수락한 뒤, 데이터를 마저 보낸 후 FIN 응답한다
            li A -> B : FIN 세그먼트(#seq=a,#ack=b1)
            li B -> A : FIN + ACK 세그먼트(#seq=b1,#ack=a+1)
            li 남은 데이터 전송
            ul
                li B -> A : 데이터 세그먼트
                li A -> B : ACK 세그먼트
            li B -> A : FIN 세그먼트(#seq=b2,#ack=a+1)
            li A -> B : ACK 세그먼트(#seq=a+1,#ack=b2+1)

        h2 TCP 소켓 상태
        +w3img('https://upload.wikimedia.org/wikipedia/commons/f/f6/Tcp_state_diagram_fixed_new.svg')
        ul
            li CLOSED : 연결 없음
            li LISTEN : Passive open; 서버 소켓 개방 -> SYN 대기
            li SYN SENT : Active open; 클라이언트 SYN 전송 -> ACK 대기
            li SYN RECEIVED : SYN+ACK 전송 -> ACK 대기
            li ESTABLISHED : 연결 수립. 데이터 전송 가능
            li FIN WAIT 1 : 클라이언트가 ESTABLISHED 상태에서 연결 종료하기로 결정 -> 1번째 FIN 전송 -> ACK 대기
            li FIN WAIT 2 : FIN WAIT 1에서 ACK 수신 -> 2번째 FIN 대기
            li CLOSING : FIN WAIT 1 상태에서 FIN 수신 == 동시 종료 결정
            li TIME WAIT : 연결 종료; 일정 시간 후 CLOSED 천이
            li CLOSE WAIT : 서버가 ESTABLISHED 상태에서 1번째 FIN 수신 -> ACK 전송 -> 애플리케이션의 소켓 연결 종료 대기
            li LAST ACK : CLOSE WAIT 상태에서 연결 종료 결정 -> 2번째 FIN 전송 -> ACK 대기

            h3 RST 세그먼트
            ul
                li 연결 요청 거부 -> 즉시 CLOSED 천이
                li 기존 연결 중단 -> 즉시 CLOSED 천이
                li 휴지 상태 연결 종료 -> 즉시 CLOSED 천이
                li RST 세그먼트를 수신한 쪽도 즉시 CLOSED 천이

    h1 SCTP; Stream Control Transport Protocol
    div
        h2 정의
        ul
            li Association ::= 두 SCTP 종단점 사이의 연결
            ul
                li 서버, 클라이언트 각각은 SCTP 헤더의 VT(Verification Tag)에 각자의 association 구별을 위한 32비트 값을 설정한다
                p 즉, 양쪽에서 전송하는 VT는 서로 다를 수 있다
                li 서버, 클라이언트 각각은 수신한 VT와 동일한 값으로 응답 패킷의 VT를 설정한다
                p 따라서, 응답받은 쪽은 응답 VT를 이용해 어떤 association으로 보냈는지 판별 가능
                li 따라서 TCP와 달리, 같은 소켓으로부터 패킷이 오더라도 실제로 유효한 연결(association)에 해당하는 패킷인지 구별할 수 있다
            li Chunk ::= SCTP의 데이터 전송 단위
            p TCP의 스트림과 달리, 단편화가 이뤄지더라도 메시지의 시작과 끝이 명확히 구분된다

        h2 특징
        ul
            li 하나의 association 내에서 다중스트림 지원
            p 스트림 하나가 블록되더라도 다른 스트림들은 전송을 계속할 수 있다
            li Multi-homing 지원
            p Primary 주소가 비가용 상태가 되더라도 alternative 주소를 통해 연결을 지속할 수 있다
            li TCP와 마찬가지로 전이중, 신뢰성 있는 통신 제공
            p + 흐름 제어, 오류 제어, 혼잡 제어 기능 제공
            li TCP는 제어 정보를 헤더로 이용하는 반면, SCTP는 제어 정보 또한 하나의 chunk로 전송한다
            p 따라서 SCTP는 12바이트 고정 헤더를 사용한다
            li 하나의 SCTP 패킷이 여러 chunk들을 포함할 수 있다
            p 이때 각 chunk들은 각각 다른 스트림에 속할 수 있다
            li TCP의 ACK, FIN 세그먼트와 달리, SCTP의 확인 응답 등에 이용되는 제어 chunk는 TSN을 필요로 하지 않는다
            p 제어 chunk는 다른 종류의 제어 chunk에 의해 응답되고, 일부는 아예 응답이 필요하지 않다
            li Numbering
            ul
                li 스트림은 16비트 SI(Stream Identifier)를 갖는다
                li DATA Chunk 전송 순서를 위해 순차적인 32비트 TSN(Transmission Sequence Number)을 사용한다
                li 스트림 내 chunk 순서를 표시하기 위해 SSN(Stream Sequence Number)을 사용한다
                p SI와 SSN을 이용해 chunk가 목적지에 도달하면 적절한 스트림에 전달되어 올바른 순서에 놓인다

        h2 Chunk 종류
        table.no-sort
            +tds('0', 'DATA', 'User data. TSN을 사용하는 유일한 chunk type')
            +tds('1', 'INIT', 'Association 시작. 다른 chunk와 같이 보낼 수 없다')
            +tds('2', 'INIT ACK', 'INIT에 대한 확인응답. 다른 chunk와 같이 보낼 수 없다')
            +tds('10', 'COOKIE ECHO', 'INIT ACK에 포함된 쿠키를 되돌려 보낸다')
            +tds('11', 'COOKIE ACK', 'COOKIE ECHO에 대한 확인응답')
            +tds('3', 'SACK', '데이터 chunk에 대한 확인응답')
            +tds('4', 'HEARTBEAT', '살아있는 지 문의')
            +tds('5', 'HEARTBEAT ACK', 'HEARTBEAT에 대한 확인응답')
            +tds('7', 'SHUTDOWN', 'Association 종료')
            +tds('8', 'SHUTDOWN ACK', 'SHUTDOWN에 대한 확인응답')
            +tds('14', 'SHUTDOWN COMPLETE', 'SHUTDOWN ACK에 대한 확인응답')
            +tds('9', 'ERROR', '수신한 패킷에서 오류를 검출한 경우')
            +tds('6', 'ABORT', '오류로 인해 association을 종결해야 하는 경우')
            +tds('192', 'FORWARD TSN', '누적 TSN을 조정하려는 경우')

        h2 쿠키를 이용한 SYN 플러딩 방지
        ul
            li SCTP는 COOKIE ECHO chunk를 받은 후에야 비로소 리소스를 할당한다
            li COOKIE ECHO가 실제로 INIT -> INIT ACK를 거쳤다는 것을 검증하기 위해, 쿠키에는 서버의 비밀키가 연관된 digest가 담긴다

        h2 상태 천이 다이어그램
        +w3img('/imgs/SCTP-state-diagram.png')
        ul
            li Closed : Association 없음
            li Cookie Wait : INIT 보낸 후 INIT ACK에 포함된 쿠키 대기 중
            li Cookie Echoed : COOKIE ECHO 보낸 후 COOKIE ACK 대기 중
            li Established : COOKIE ACK를 받아 association 수립
            li Shutdown Pending : close 신호를 받아 SHUTDOWN을 보내기 전에, 남은 데이터 chunk를 보내는 중
            li Shutdown Sent : 남은 데이터 chunk가 없어 SHUTDOWN 전송하고 SHUTDOWN ACK 대기; 이후 데이터 chunk는 전송되지 않는다
            li Shutdown Received : SHUTDOWN 수신. 남은 데이터 chunk가 있다면 마저 보낸 뒤 SHUTDOWN ACK 전송; 이후 데이터 chunk는 전송되지 않는다
            li Shutdown Ack Sent : SHUTDOWN ACK를 보내고 SHUTDOWN COMPLETE 대기

    h1 HTTP
    div
        h2 HTTP/0.9
        p GET 메서드(요청 헤더도 없음)로 HTML 텍스트를 가져오는 기능 제공

        h2 HTTP/1.0
        ul
            li PUT 등 다른 요청 메서드 지원
            li 요청 헤더 지원
            li 응답 코드 추가
            li 리다이렉션 지원
            li 컨텐츠 인코딩(압축 포함) 제공
            li 조건부 요청

        h2 HTTP/1.1
        ul
            li Host 헤더 필수 지정
            li 동일 서버에 대한 여러 요청을 하나의 커넥션으로 순차적으로 수행 가능
            li OPTIONS 메서드 지원
            li Upgrade 헤더 지원
            li cacheability 헤더 확장

        h2 HTTP/2 
            +asA('https://datatracker.ietf.org/doc/html/rfc7540')
        ul
            li 요청 헤더 압축 지원
            li 동일 서버에 대해 하나의 커넥션으로 여러 요청 동시 수행 가능
        div
            h3 스트림 & 프레임
            ul
                li 클라이언트와 서버는 하나의 연결 안에서 여러 스트림을 열어 통신을 수행한다
                li 전송 단위는 프레임으로, 기존 텍스트 형식을 버리고 정형화된 바이너리 포맷을 이용한다
                +asCode('HTTP', '기존 HTTP 패킷 예').
                    GET / HTTP/1.1\r\n
                    Host: localhost:8000\r\n
                    User-Agent: Mozilla/5.0 ...\r\n
                    Accept: text/html,application/xhtml+xml,...\r\n
                    ...\r\n
                    Content-Length: 345\r\n
                    \r\n
                    request body...\r\n
                +asCode('text', 'HTTP/2 frame format').
                    +-----------------------------------------------+
                    |                Length (24)                   |
                    +---------------+---------------+---------------+
                    |  Type (8)    |   Flags (8)   |
                    +-+-------------+---------------+-------------------------------+
                    |R|                 Stream Identifier (31)                      |
                    +=+=============================================================+
                    |                  Frame Payload (0...)                      ...
                    +---------------------------------------------------------------+
                ul
                    li Length : 기본 프레임 최대 길이는 2^14바이트로, 더 큰 값을 사용하려면 SETTINGS 프레임으로 협상해야 한다
                    p \r\n을 이용해 끝까지 파싱해야만 포맷 일치 여부를 알 수 있고, \n만 보내는 클라이언트에 대응하고, 미리 알 수 없는 컨텐츠 길이에 대해 걱정하던 부분이 해소되었다
                    li Type
                    table.no-sort
                        +tds('0', 'DATA', '데이터')
                        +tds('1', 'HEADERS', 'HTTP 헤더')
                        +tds('2', 'PRIORITY', '스트림 우선순위')
                        +tds('4', 'SETTINGS', '연결 매개변수 설정')
                        +tds('5', 'PUSH_PROMISE', '서버 푸시')
                        +tds('6', 'PING', '연결 시험')
                        +tds('8', 'WINDOW_UPDATE', '흐름제어')
                        +tds('9', 'CONTINUATION', 'HEADERS, PUSH_PROMISE, CONTINUATION을 한 프레임으로 전송을 끝내지 못하는 경우, 나머지 연장 부분')
                        +tds('3', 'RST_STREAM', '스트림 즉시 종료')
                        +tds('7', 'GOAWAY', '연결 종료')
                    li Stream Identifier : 프레임이 속한 스트림 표시
                li x번 스트림으로 요청된 프레임은 동일한 x번 스트림을 통해 응답받는다

        h2 HTTP/3
        ul
            li TCP 대신 UDP 기반 프로토콜, QUIC(
                +asA('https://datatracker.ietf.org/doc/html/rfc9000')
                |)으로 전환
            p HTTP/2가 애플리케이션 계층의 HOL 문제를 해소했지만, 여전히 TCP 자체의 HOL 문제가 남아있었다
            li TCP가 제공하는 혼잡 제어 등의 기능이 커널 공간에서 동작하는 반면, HTTP/3은 유저 공간에서 실행하는 대신 알고리즘을 자주 업데이트 가능
            li TLS 대신 이에 상응하는 DTLS를 이용해 보안 통신 가능

        h2 성능 최적화
        ul
            li DNS prefetch
            +asCode('html') &lt;link rel="dns-prefetch" href="//...com"&gt;
            li TLS preconnect
            +asCode('html') &lt;link rel="preconnect" href="//...com" crossorigin&gt;
            li 리다이렉션하지 않기
            li 클라이언트에 캐싱하기
            li onload 이벤트 전에 js가 실행되야 하는 경우
            +asCode('html') &lt;script async src="...js"&gt;
            li DOM 로드 후에 js를 실행해도 되는 경우
            +asCode('html') &lt;script defer src="...js"&gt;
            li 디바이스 해상도에 맞추어 이미지 다운로드
