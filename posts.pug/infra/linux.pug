include ../../source/skeleton.pug
+post('Linux', 'Linux, AmazonLinux, CentOS', 'Linux 정리')
    h1 참고자료
    ul
        li: +asA('https://tldp.org/', 'The Linux Documentation Project')
        ul
            li: +asA('https://tldp.org/guides.html', 'LDP Guides')
            ol
                li: +asA('https://tldp.org/LDP/abs/html/index.html', 'Advancd Bash-Scripting Guide; 03/2014')
                p Public Domain. No copyright!
                li: +asA('https://tldp.org/LDP/Bash-Beginners-Guide/html/index.html', 'Bash Guide for Beginners; 12/2008')
                details
                    summary Copyright
                    +asCode('text').
                        * Copyright (c) 2002-2007, Machtelt Garrels
                        * All rights reserved.
                        * Redistribution and use in source and binary forms, with or without
                        * modification, are permitted provided that the following conditions are met:
                        *
                        *     * Redistributions of source code must retain the above copyright
                        *       notice, this list of conditions and the following disclaimer.
                        *     * Redistributions in binary form must reproduce the above copyright
                        *       notice, this list of conditions and the following disclaimer in the
                        *       documentation and/or other materials provided with the distribution.
                        *     * Neither the name of the author, Machtelt Garrels, nor the
                        *       names of its contributors may be used to endorse or promote products
                        *       derived from this software without specific prior written permission.
                        *
                        * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS "AS IS" AND ANY
                        * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
                        * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                        * DISCLAIMED. IN NO EVENT SHALL THE AUTHOR AND CONTRIBUTORS BE LIABLE FOR ANY
                        * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
                        * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
                        * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
                        * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
                        * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
                        * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                li: +asA('https://tldp.org/LDP/intro-linux/html/index.html', 'Introduction to Linux; 06/2008')
                details
                    summary Copyright
                    +asCode('text').
                        * Copyright (c) 2002-2007, Machtelt Garrels
                        * All rights reserved.
                        * Redistribution and use in source and binary forms, with or without
                        * modification, are permitted provided that the following conditions are met:
                        *
                        *     * Redistributions of source code must retain the above copyright
                        *       notice, this list of conditions and the following disclaimer.
                        *     * Redistributions in binary form must reproduce the above copyright
                        *       notice, this list of conditions and the following disclaimer in the
                        *       documentation and/or other materials provided with the distribution.
                        *     * Neither the name of the author, Machtelt Garrels, nor the
                        *       names of its contributors may be used to endorse or promote products
                        *       derived from this software without specific prior written permission.
                        *
                        * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS "AS IS" AND ANY
                        * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
                        * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                        * DISCLAIMED. IN NO EVENT SHALL THE AUTHOR AND CONTRIBUTORS BE LIABLE FOR ANY
                        * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
                        * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
                        * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
                        * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
                        * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
                        * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        li: +asA('https://www.gnu.org/manual/', 'GNU Manual')
        li: +asA('https://www.kernel.org/doc/man-pages/', 'Linux man-pages')
        li: +asA('https://centoshelp.org/resources/commands/linux-system-commands/', 'CentOS - commands')

    h1 Linux History
    ul
        li 표준이 없던 초창기. 크고 비싼 컴퓨터들은 제각기의 운영체제를 갖고 있었고, 한 컴퓨터에서 작동하는 프로그램이 다른 컴퓨터에서 작동할 것이라는 보장도 할 수 없었다.
        li Bell Labs에서 재사용 가능한 C 기반의 운영체제 UNIX를 개발했다.
        li UNIX를 이용함으로써 각 시스템을 위한 전용 코드의 작성을 줄일 수 있게 되었다. <- 이 전용 코드가 바로 커널(kernel)
        li Linux는 리눅스 커널(리누스 토발즈 최초 개발)을 이용하는 UNIX 구현체로, 다수의 GNU tool을 이용한다.

    h1 시스템 ON/OFF
    div
        h2 부팅 과정
        ol
            li BIOS 실행
            li POST 수행 &lt;- 장치 검사, 초기화
            li 부트로더 실행 : 커널 로드. BIOS 종료
            p GRUB : GNU 프로젝트의 부트로더. 대부분 운영 체제의 커널을 불러올 수 있다
            li init 프로세스 실행 : /etc/inittab
            p: strong systemd가 사용되는 경우, inittab은 사용되지 않는다
            li init 프로세스 중에 /etc/rc.d/rc.local 스크립트를 실행한다
            p
                strong 해당 파일은 호환을 위해 아직 남아있지만, 사용자 정의 systemd 서비스나 udev 규칙을 만드는 것이 권장된다
                +goto('service')

        h2 shutdown : 시스템 종료
        p: strong 리눅스는 무정지 목적으로 설계됨에 유의
        +asCode('shell') $ shutdown [OPTIONS...] time [warning-message]
        ol
            li -H : 시스템 종료
            li -P : 시스템 종료 + 전원 차단(하드웨어 지원 필요)
            li -r : 재부팅
            li -c : 대기중인 shutdown 취소
            li time : now | +
                i number
                |  | yymmddhhmm
            p +number 단위(기본: 분)를 지정하려면 접미사 "s", "sec", "m", "min", "h", "hour" 이용
            li warning-message : 로그인한 유저들에게 보낼 브로드캐스팅 메시지

        h2 init : 일시적인 runlevel 변경
        +asCode('shell') $ init runlevel
        ol
            li runlevel : 0(종료), 6(재부팅), 1(복구), 2(multiuser without NFS), 3(multiuser; TUI), 5(X11; GUI)
            li 시스템 기본 runlevel 확인
            +asCode('shell') $ systemctl get-default

    h1 서비스 관리
        +pos('service')
    table
        tr
            th 구분
            th init
            th systemd
        tr
            td 시작
            td /etc/init.d/${service} start
            td systemctl start ${service}
        tr
            td 종료
            td /etc/init.d/${service} stop
            td systemctl stop ${service}
        tr
            td 재시작
            td /etc/init.d/${service} restart
            td systemctl restart ${service}
        tr
            td 상태
            td /etc/init.d/${service} status
            td systemctl status ${service}
        tr
            td 자동 시작 O
            td chkconfig ${service} on
            td systemctl enable ${service}
        tr
            td 자동 시작 X
            td chkconfig ${service} off
            td systemctl disable ${service}
        tr
            td 자동 시작 상태
            td chkconfig --list ${service}
            td systemctl is-enabled ${service}
        tr
            td 서비스 목록
            td ls /etc/init.d
            td systemctl --type service
    div
        h2 init 사용자 정의 서비스
        ol
            li 서비스 작성
            +asCode('bash', '/etc/init.d/my').
                #!/bin/bash
                # chkconfig: 2345 20 30
                # description: My Custom Service
                
                LOG=/var/log/my.log
                
                start() {
                    echo 'Service started...' >> $LOG
                }
                
                stop() {
                    echo 'Service stopped...' >> $LOG
                }
                
                case "$1" in
                    start)
                        start
                        ;;
                    stop)
                        stop
                        ;;
                    restart)
                        stop
                        start
                        ;;
                    status)
                        echo "OK"
                        ;;
                    *)
                        echo "Usage: $0 {start|stop|restart|status}"
                esac
                
                exit 0

            p
                strong chkconfig: 2345 20 30
                |  -> runlevel이 {2, 3, 4, 5} 중 하나면 실행. 시작 우선순위 20, 종료 우선순위 30

            li 실행 권한 부여
            +asCode('shell') $ chmod +x /etc/init.d/my

            li 자동 실행 설정
            +asCode('shell') $ chkconfig my on

        h2 systemd 사용자 정의 서비스
        ol
            li 서비스 작성
            +asCode('bash', '/etc/systemd/system/myd.service').
                [Unit]
                Description=My Daemon
                
                [Service]
                Type=simple
                ExecStart=/root/my.sh
                Restart=on-failure
                
                [Install]
                WantedBy=multi-user.target

            li 최초 서비스 실행
            +asCode('shell') $ systemctl start myd

            li 자동 실행 설정
            +asCode('shell') $ systemctl enable myd
    h1 쉘
    ol
        li 유저의 기본 쉘은 /etc/passwd에 설정된다
        li echo $SHELL : 사용중인 쉘 확인
        li 종류
        ul
            li Login shell
            p 최초 실행 시 유저명과 비밀번호를 묻고 진입하는 쉘.
            li Non login shell
            p 기존 쉘에서 인증없이 새로 시작한 쉘.

    h1 Bash
    div
        h2 Special character
        table.no-sort
            +tds('#', '주석 시작')
            +tds(';', '커맨드 구분자')
            +tds(';;', 'case 옵션 종결자')
            tr
                td ;;&amp;, ;&amp;
                td case 옵션 종결자 Since bash 4
                    +goto('case')
            tr
                td .
                td
                    ul
                        li 커맨드로 사용 : source 커맨드와 동일
                        li 파일명 접두에 위치 : ls에는 보여지지 않음
                        li 정규표현식 : 임의 글자에 매칭
            tr
                td ""
                td partial quoting
                    +goto('quoting')
            tr
                td ''
                td full quoting
                    +goto('quoting')
            tr
                td ,
                td
                    ul
                        li 연산자 : 산술 연산이 순서대로 처리되고, 마지막 결과를 반환
                        li 대소문자 변환 in 
                            +goto('parameter substitution')
                            |  Since bash 4
            +tds('\\', '이스케이프. 바로 뒤의 문자를 리터럴로 취급')
            +tds('/', '파일 경로 구분자')
            tr
                td ``
                td: +goto('command substitution')
            +tds(':', '아무것도 하지않는 null command')
            +tds('*', 'GLOB 패턴 매칭에서, 해당 디렉터리 내 임의 파일명에 매칭')
            +tds('?', 'GLOB 패턴 매칭에서, 임의 1글자에 매칭')
            +tds('(command1; command2; ...)', 'Command group. 새 서브쉘에서 커맨드를 실행한다; 따라서 외부에서 참조 불가')
            tr
                td {x,y,z,...}, {a..z}
                td: +goto('brace expansion')
            tr
                td {}
                td 코드 블록 정의. 컨텍스트는 유지되므로 외부에서도 변수 참조 가능. 코드 블록에 대해 IO 리디렉션 가능
                    +asCode('bash').
                        {
                            echo 'hello'
                            echo 'world'
                        } >> test.log
            tr
                td [ EXPRESSION ], [[ EXPRESSION ]]
                td: +goto('test')
            +tds('$[ EXPRESSION ]', 'Deprecated. 정수 연산')
            +tds('(( EXPRESSION ))', '정수 연산')
            tr
                td 리디렉션
                td: ul
                    li >
                    +asCode('shell').
                        $ script.sh > test.log
                        # STDOUT을 test.log로. 파일이 없다면 생성하고, 있다면 덮어쓴다.
                        
                        $ script.sh >&2
                        # STDOUT을 STDERR(2)로
                        
                        $ script.sh > test.log 2>&1
                        # STDOUT을 test.log로 && STDERR(2)를 STDOUT(1)으로
                    li &amp;>
                    +asCode('shell').
                        $ not_exist.sh &> /dev/null # STDOUT, STDERR 모두 /dev/null로(==버림)
                        $ echo $?                   # non-zero
                    li >>
                    +asCode('shell').
                        $ script.sh >> test.log
                        # STDOUT을 test.log로. 파일이 없다면 생성하고, 있다면 append
                    li &lt; : 파일을 STDIN으로.
                    li &lt;>
                    li: +goto('Process substitution')

        h2 자동 실행 스크립트
        ul
            li Login shell : /etc/profile, ~/.bash_profile or ~/.bash_login or ~/.profile, ~/.bash_logout
            p /etc/profile은 /etc/bash.bashrc, /etc/profile.d/*.sh 들도 실행한다
            li Non login shell : ~/.bashrc
            p ~/.bashrc 파일은 보통 ~/.bash_profile, ~/.profile 등에서도 실행한다

        h2 스크립트 디버깅
        ul
            li 전체 스크립트 : bash -x filename
            li 일부분 : 스크립트 내에서 플래그 조정
            +asCode('bash').
                # ...
                set -x # start debugging
                w
                set +x # stop debugging
            li 현재 쉘에서 직접 플래그 조정
            ul
                li set -f : disable file name generation using metacaracters
                li set -v : print shell input lines
                li set -x : print command traces before executing command
        
        h2 변수
        div
            h3 전역 변수
            ul
                li 모든 쉘에서 접근 가능
                li env 또는 printenv 명령으로 목록 확인 가능
            h3 지역 변수
            ul
                li 현재 쉘에서만 접근 가능
                li 목록 확인
                +asCode('shell').
                    $ (set -o posix; set | sort) > set.sorted
                    $ (printenv | sort) > printenv.sorted
                    $ diff set.sorted printenv.sorted | grep "<" | awk '{ print $2 }'
                li 변수 선언
                +asCode('shell').
                    $ varName="value"
                    $ let varName="value"
                li 변수 전달
                +asCode('shell').
                    # child process에서 사용할 수 있게 된다
                    $ export varName
                    $ export varName="value"
            h3 예약 변수
            table.no-sort
                +ths('name', 'definition')
                +tds('BASH', 'bash의 절대경로')
                +tds('BASH_ENV', '로그인 쉘에서, 파일로 설정된 경우, 쉘 스크립트를 실행하기 전에 먼저 읽는다')
                +tds('BASH_VERSION', 'bash 버전')
                +tds('BASH_VERSINFO', 'bash 버전 정보에 대한 읽기 전용 수열')
                +tds('COLUMNS', '터미널 출력 너비')
                +tds('COMP_CWORD', '$COMP_WORDS에서 현재 커서가 위치하는 단어의 index')
                +tds('COMP_LINE', '현재 커맨드 라인')
                +tds('COMP_POINT', '현재 커맨드에서 커서 상대 위치')
                +tds('COMP_WORDS', '현재 커맨드를 배열로')
                tr
                    td COMPREPLY
                    td 제시할 자동완성 단어 배열
                        +asA('https://devmanual.gentoo.org/tasks-reference/completion/index.html', '예시')
                +tds('EUID', '명령을 실행 중인 현재 유저의 ID')
                +tds('FUNCNAME', '현재 실행 중인 쉘 함수 이름')
                +tds('GROUPS', '현재 유저가 속한 그룹으로 구성된 배열')
                +tds('HISTFILE', '커맨드 이력. 기본값 ~/.bash_history')
                +tds('HISTFILESIZE', '저장할 최대 이력 수')
                +tds('HOME', '현재 유저의 home directory. ~ 기호로도 획득 가능')
                +tds('HOSTFILE', '/etc/hosts와 동일한 포맷의 파일을 지정하면, 호스트 구성에 사용')
                +tds('HOSTNAME', '현재 호스트')
                +tds('HOSTTYPE', '머신 종류; e.g. x86_64')
                +tds('LANG', 'LC_* 변수에서 지정하지 않은 경우, 이 로캐일이 사용된다')
                +tds('LC_ALL', 'LANG 및 다른 모든 LC_* 변수에 우선한다')
                +tds('LC_COLLATE', '파일명, 패턴 비교에 사용하는 로캐일')
                +tds('LC_CTYPE', '파일명, 패턴 등의 문자 로캐일')
                +tds('LC_MESSAGES', '"$" 해석에 사용할 로캐일')
                +tds('LC_NUMERIC', '숫자 표현에 사용할 로캐일')
                +tds('LINENO', '현재 라인 번호')
                +tds('MACHTYPE', 'CPU-COMPANY-SYSTEM')
                +tds('MAIL', 'MAILPATH가 설정되지 않은 경우, MAIL이 가리키는 파일에 신규 메일이 있으면 bash가 알려준다')
                +tds('MAILCHECK', '메일 확인 주기(초)')
                +tds('MAILPATH', ':으로 구별된 MAIL 파일들. 신규 메일이 있으면 bash가 알려준다')
                +tds('OLDPWD', '이전 PWD')
                +tds('OPTARG', 'getopts가 마지막으로 처리한 옵션 인자의 값')
                +tds('OPTIND', 'getopts가 마지막으로 처리한 옵션 인자의 인덱스')
                +tds('OSTYPE', 'e.g. linux-gnu')
                +tds('PATH', ':으로 구별된 디렉터리들. 커맨드가 존재하는지 shell이 찾아본다')
                +tds('PIPESTATUS', '가장 최근 포그라운드에서 종료된 프로세스들의 종료 코드 배열')
                +tds('PPID', '현재 쉘의 PPID')
                +tds('PROMPT_COMMAND', '매 PS1 출력 전에 실행할 명령')
                +tds('PS1', 'Prompt string 1; Primary; default "\\s-\\v\\$ "')
                +tds('PS2', 'Prompt string 2; Secondary; "> "')
                +tds('PS3', 'select 커맨드에 사용되는 prompt. default "#?"')
                +tds('PS4', '-x 옵션으로 커맨드 라인 실행 전에 echo 출력할 때 사용할 prefix; default "+ "')
                +tds('PWD', 'Print Working Directory')
                +tds('RANDOM', '0 ~ 32767 사이 임의 정수; 할당하는 경우 seed로 전달된다')
                +tds('REPLY', 'read로 읽어온 문자열')
                +tds('SECONDS', '쉘 시작 후 ?초')
                +tds('SHELLOPTS', ':으로 구별된, 활성 쉘 옵션들')
                +tds('SHLVL', '부모 bash 인스턴스 수 + 1')
                +tds('TMOUT', 'read 제한 시간(초)')
                +tds('UID', '실제 현재 유저 ID')
            h3 특별 변수
            table.no-sort
                +ths('character', 'definition')
                +tds('$#', '$1~$9, ${10}~로 n번째 실행 인자 획득. $# 자체는 매개변수 개수 획득')
                +tds('$@', "전체 인자를 ' '로 구분된 한 단어로 반환")
                +tds('$?', '마지막 포그라운드 프로세스 종료 상태')
                +tds('$$', '쉘 PID')
                +tds('$!', '가장 최근 백그라운드 PID')
                +tds('$0', '쉘 or 스크립트 이름')
            h3 declare 로 변수 선언
            +asCode('shell') $ declare OPTION(S) VAR_NAME=value
            ul
                li -a : 배열
                li -f : 이름에 해당하는 함수 정의 출력
                li -i : 정수
                li -p : 이름에 해당하는 변수 정의 출력
                li -r : 읽기 전용 변수로 고정
                li -x : export
                li 옵션에 - 대신 +를 쓰면 해당 옵션을 끈다
            h3 Array
            ul
                li 원소 타입 제한 없음
                li 배열 길이 제한 없음
                li 임의 인덱스 할당 가능
                li 배열 선언 + 초기화
                +asCode('shell') $ arr=(value1 value2 valueN)
                li 암시적 배열 변수 선언
                +asCode('shell') $ arr[3]=value
                li 배열 참조
                +asCode('shell').
                    $ echo ${arr[*]}
                    $ echo ${arr[2]}
            h3 변수에 대한 연산
                +pos('parameter substitution')
            ul
                li ${VAR_NAME^} : 첫번째 글자를 대문자로. Since bash 4
                li ${VAR_NAME^^} : 전부 대문자로. Since bash 4
                li ${VAR_NAME,} : 첫번째 글자를 소문자로. Since bash 4
                li ${VAR_NAME,,} : 전부 소문자로. Since bash 4
                li ${#VAR_NAME} | ${#*}, ${#@} | ${#arr[*]}, ${#arr[@]} : 변수 값의 길이 | 인자 개수 | 배열 길이
                li ${VAR_NAME-WORD} : 변수가 없으면 WORD 반환
                li ${VAR_NAME:-WORD} : 변수가 없거나 null이면 WORD 반환
                li ${VAR_NAME=WORD} : 변수가 없으면 WORD 할당 후 반환
                li ${VAR_NAME:=WORD} : 변수가 없거나 null이면 WORD 할당 후 반환
                li ${VAR_NAME?WORD} : 변수가 없으면 실행 위치와 WORD 출력 후 exit code 1로 종료
                li ${VAR_NAME:?WORD} : 변수가 없거나 null이면 실행 위치와 WORD 출력 후 exit code 1로 종료
                li ${VAR_NAME+WORD} : 변수가 존재하면 WORD 반환. 아니면 null
                li ${VAR_NAME:+WORD} : 변수가 존재하고 non-null이면 WORD 반환. 아니면 null
                li ${VAR_NAME:OFFSET:LENGTH} : OFFSET(0 based index)부터 LENGTH(생략 시 끝까지)개 문자 출력
                li ${VAR_NAME#WORD} : 접두 WORD패턴(shortest) 삭제
                li ${VAR_NAME##WORD} : 접두 WORD패턴(longest) 삭제
                li ${VAR_NAME%WORD} : 접미 WORD패턴(shortest) 삭제
                li ${VAR_NAME%%WORD} : 접미 WORD패턴(longest) 삭제
                +asCode('shell').
                    $ arr=(aaab aabb abbb bbbb)
                    $ echo ${arr[*]#a*}
                    aab abb bbb bbbb
                    $ echo ${arr[*]##a*}
                    bbbb
                    $ echo ${arr[*]%*b}
                    aaa aab abb bbb
                    $ echo ${arr[*]%%*b}
                li ${VAR_NAME/PATTERN/REPLACEMENT} : 최초 1회 치환
                li ${VAR_NAME/#PATTERN/REPLACEMENT} : 접두와 일치하는 경우 치환
                li ${VAR_NAME/%PATTERN/REPLACEMENT} : 접미와 일치하는 경우 치환
                li ${VAR_NAME//PATTERN/REPLACEMENT} : 전체 치환
                li ${!prefix*}, ${!prefix@} : 접두가 일치하는 모든 변수 이름 배열 반환

        h2 Quoting
            +pos('quoting')
        ul
            li \ : 다음 글자를 리터럴로 간주
            li '' : 내부 문자열을 리터럴로 간주
            li "" : 내부 문자열을 리터럴로 간주; 단 $, `, \ 제외. 여러줄에 걸쳐 작성 가능.

        h2 Expansion
        ol
            li 각 커맨드 토큰들은 순서대로 해석되며, 모든 해석이 끝난 뒤 quote가 제거된다
            li Brace expansion
                +pos('brace expansion')
            +asCode('shell').
                $ echo ab{c,d,e}fg
                # abcfg abdfg abefg
                $ mv name.{txt,txt.old}
                $ for n in {1..20}; do echo $n; done
                $ for n in log-{100..20}.txt; do echo $n; done
                $ for n in {z..A}; do echo $n; done
            li Tilde expansion
            +asCode('shell').
                $ echo ~          # 현재 유저의 home directory
                $ echo ~USER_NAME # 특정 유저의 home directory
                $ echo ~+         # PWD
                $ echo ~-         # OLDPWD
            li Parameter(and variable) expansion
            ul
                li ${VAR_NAME}, $VAR_NAME
                p {}는 옵션이다. ${INSTALL_DIR}_old/ 처럼 뒤에 곧바로 다른 문자가 오는 경우 구분을 위해 사용
                li ${VAR_NAME:=value}
                p 변수가 존재하지 않으면 초기화하고 반환
                li $0~$9, ${10}~
                p n번째 실행 인자 획득. 2글자 넘어가면 {} 필수
            li Command substitution : $(command), `command`
                +pos('command substitution')
            +asCode('shell').
                # command 실행 결과(STDOUT)로 치환
                $ echo $(echo $(echo abcd))
            li Arithmetic expansion : $(( EXPRESSION )), $[ EXPRESSION ]
            ul
                li EXPRESSION은 "로 감싸인 걸로 간주된다. " 자체는 특별한 의미를 갖지 않는다.
                li EXPRESSION 내부 토큰들도 parameter expansion, command substitution, quote removal을 거친다
                li EXPRESSION은 중첩될 수 있다
                li EXPRESSION 연산은 고정폭 정수로 행해지며, overflow 검사는 하지 않는다.
                li 0으로 시작하는 상수는 8진수, 0x는 16진수로 간주된다.
                li 2#10 ~ 64#12abAB@_ 표기로 2~64진법 표현 가능. 36진법 이하에서 대소문자는 구별되지 않는다.
            table.no-sort
                caption Operators
                +tds('VAR++, VAR--', '단항 연산(후위)')
                +tds('++VAR, --VAR', '단항 연산(전위)')
                +tds('-, +', '단항 연산')
                +tds('!, ~', '논리/비트 NOT')
                +tds('**', '거듭제곱')
                +tds('*, /, %', '곱, 몫, 나머지')
                +tds('+, -', '이항 연산')
                +tds('<<, >>', '비트 이동')
                +tds('<=, >=, <, >', '비교 연산')
                +tds('==, !=', '동등 비교')
                +tds('&', '비트 AND')
                +tds('^', '비트 XOR')
                +tds('|', '비트 OR')
                +tds('&&', '논리 AND')
                +tds('||', '논리 OR')
                +tds('expr ? expr : expr', '삼항 연산')
                +tds('=, *=, /=, %=, +=, -=, <<=, >>=, &=, ^=, |=', '대입 연산')
                +tds(',', '표현식 구별. 가장 마지막 표현식 결과가 리턴된다')
            li Process substitution
                +pos('Process substitution')
            ul
                li x &lt;(COMMAND_LIST) y : COMMAND_LIST대로 프로세스를 실행하고, 그 결과를 갖는 임시 파일(/dev/fd/N)과 y를 순서대로 x의 인자로 전달
                +asCode('shell') $ cat &lt;(ls -a) &lt;(ls -al)
                li x &gt;(COMMAND_LIST) y : x /dev/fd/N y를 실행하고, /dev/fd/N는 다시 COMMAND_LIST 프로세스의 인자로 전달
                +asCode('shell').
                    $ tar -cf >(cat) test.sh tmp.txt
                    # test.sh0000774000000000000000000000002614004476247011101 0ustar  rootroot
                    # Content of 'test.sh'
                    # tmp.txt0000664000000000000000000000002614004476253011122 0ustar  rootroot
                    # Content of 'tmp.txt'
            li Word splitting
            ul
                li Parameter expansion, command substitution, arithmetic expansion의 결과에 대해 단어를 분할한다
                li 단어의 분할은 IFS 변수(Internal Field Separator)에 설정(기본값 ' \t\n')된 문자들을 구분자로 하여 진행된다.
                +asCode('shell').
                    $ echo $IFS
                    
                    $ IFS=123
                    $ str=a1b2c3d4e5
                    $ echo $str
                    a b c d4e5
                    $ echo "$str"
                    a1b2c3d4e5
                    $ echo $IFS
                      
                    $ echo "$IFS"
                    123
                    $ IFS=' \t\n'
                    $ echo $str
                    a1b2c3d4e5
            li File name expansion
            +asCode('shell').
                $ echo t* # 배열로 반환
                test.sh tmp.txt
            +asCode('shell', 'test.sh').
                $ echo $1
                $ echo $#
            +asCode('shell').
                $ cat <("${PWD}/"t*)
                /workspace/donggi-github/tmp.txt
                1
                $ cat <("${PWD}/"t*.sh)
                
                0

        h2 Aliases
        ul
            li 목록 확인 : alias
            li 설정 : alias text='COMMAND_LIST'
            li 해제 : unalias text
            li alias는 자식 프로세스에 상속되지 않는다

        h2 Test
            +pos('test')

        h2 정규표현식
        table.no-sort
            +tds('^', 'line 시작', '$', 'line 끝')
            +tds('\\b', 'word 경계', '\\B', 'not \\b. 즉 2글자 이상의 word 내부')
            +tds('\\<', 'word 시작', '\\>', 'word 끝')
            +tds('[[CLASS]]', 'alnum, alpha, ascii, blank, cntrl, digit, graph, lower, print, punct, space, upper, word, xdigit')

        h2 sed; Stream EDitor
        div
            p sed는 표준 입력 또는 파일로부터 편집을 수행(원본 수정은 없다)하고 표준 출력한다.
            table.no-sort
                caption Commands
                +tds('a\\text', '각 줄 아래에 text를 쓴다')
                +tds('c\\text', '각 줄을 text로 치환')
                +tds('/pattern/d', '패턴이 포함된 줄 지우기')
                +tds('2,4d', '2~4 줄 지우기')
                +tds('2,$d', '2~마지막 줄 지우기')
                +tds('i\\text', '각 줄 위에 text를 쓴다')
                +tds('/pattern/p', 'pattern이 매칭되는 줄만 출력')
                +tds('s/pattern/replacement/', '찾아 바꾸기; 줄당 최초 1회')
                +tds('2,4s/pattern/replacement/', '찾아 바꾸기; 2~4줄에서 각 줄당 최초 1회')
                +tds('2,/pattern1/s/pattern2/replacement/', '찾아 바꾸기; 2줄부터 pattern1이 존재하는 줄까지, 각 줄당 최초 1회')
                +tds('/pattern1/,/pattern2/s/pattern3/replacement/', '찾아 바꾸기; pattern1이 존재하는 줄부터 pattern2가 존재하는 줄까지, 각 줄당 최초 1회')
                +tds('s/pattern/replacement/gi', '찾아 바꾸기; 대소문자 구별없이(i), 해당 줄의 모든 매칭(g)에 대해 변환 수행')
                +tds('3q', '3줄까지만 처리하고 종료')
            table.no-sort
                caption Options
                +tds('-e script', 'script 커맨드들도 실행한다')
                +tds('-f script-file', 'script-file의 커맨드들도 실행한다')
                +tds('-n', '매칭 라인만 출력')

        h2 awk
        div
            h3 개요
            p 스트림 편집 프로그램; 및 프로그래밍 언어
            +asCode('shell').
                $ awk { PROGRAM } inputFile(s)        # 각 파일 모든 라인들에 대해 PROGRAM 실행
                $ awk '/REGEX/(gmi) { PROGRAM } inputFile(s) # 각 파일 REGEX 일치 라인들에 대해 PROGRAM 실행
                $ awk -f programFile inputFile(s)
            
            h3 print
            ul
                li default input field separator ::= [ \t]+
                li $1, $2, ... ::= 라인의 i번째 필드
                li $0 ::= 라인 전체
                +asCode('shell') $ ls -al | awk '{ print $9 }'
                li formatting
                +asCode('shell') $ ls -al | awk '{ print $9 " with formatting -> [" $9 "]" }'
                li 전처리/후처리
                +asCode('shell') $ ls -al | awk 'BEGIN { print "Hello\n" } { print $9 } END { print "Bye\n" }'

            h3 variable
            ul
                li FS : field separator
                +asCode('shell') $ ls -al | awk 'BEGIN { FS="t+" } { print $1 }'
                li OFS : output field separator
                li ORS : output record separator
                li NR : number of record
                +asCode('shell') $ ls -alh | awk 'BEGIN { OFS=" = "; ORS="\n>>> line " } { print NR "\n" $9,$5 "B" }'
                li User defined variable
                +asCode('shell') $ ls -al | awk 'BEGIN { totalSize=0 } { totalSize=totalSize + $5 } END { print "Total size = " totalSize "bytes" }'

            h3 printf

        h2 Conditional statements
        div
            h3 if - General
            ul
                li 가장 단순한 구문
                +asCode('bash').
                    if TEST-COMMANDS; then COMMANDS; fi
                    # TEST-COMMANDS가 성공적으로 종료(exit code==0)하면 then 실행
                    
                    if true; then echo hello; fi
                    if false; then echo hello; fi
                li 조건식
                table
                    +ths('식', 'TRUE')
                    +tds('[ -a FILE ]', 'FILE 존재')
                    +tds('[ -b FILE ]', 'FILE 존재 && block device')
                    +tds('[ -c FILE ]', 'FILE 존재 && character device')
                    +tds('[ -d FILE ]', 'FILE 존재 && directory')
                    +tds('[ -e FILE ]', 'FILE 존재')
                    +tds('[ -f FILE ]', 'FILE 존재 && regular file')
                    +tds('[ -g FILE ]', 'FILE 존재 && SGID bit set')
                    +tds('[ -h FILE ]', 'FILE 존재 && symbolic link')
                    +tds('[ -k FILE ]', 'FILE 존재 && sticky bit set')
                    +tds('[ -p FILE ]', 'FILE 존재 && pipe')
                    +tds('[ -r FILE ]', 'FILE 존재 && redable')
                    +tds('[ -s FILE ]', 'FILE 존재 && size > 0')
                    tr
                        td [ -t FD ]
                        td FD가 터미널에 연결됨
                        +asCode('bash').
                            if [ -t 1 ]; then echo hello; fi
                            if [ -t 2 ]; then echo hello; fi
                    +tds('[ -u FILE ]', 'FILE 존재 && SUID bit set')
                    +tds('[ -w FILE ]', 'FILE 존재 && writable')
                    +tds('[ -x FILE ]', 'FILE 존재 && executable')
                    +tds('[ -O FILE ]', 'FILE 존재 && 현재(effective) 유저가 소유')
                    +tds('[ -G FILE ]', 'FILE 존재 && 현재(effective) 그룹이 소유')
                    +tds('[ -L FILE ]', 'FILE 존재 && symbolic link')
                    +tds('[ -N FILE ]', 'FILE 존재 && 마지막으로 읽은 시점 이후에 수정됨')
                    +tds('[ -S FILE ]', 'FILE 존재 && socket')
                    +tds('[ FILE1 -nt FILE2 ]', 'Newer than ::= FILE1이 FILE2보다 최근에 수정됨 || FILE1은 있지만 FILE2는 없음')
                    +tds('[ FILE1 -ot FILE2 ]', 'Older than ::= FILE1이 FILE2보다 이전에 수정됨 || FILE2는 있지만 FILE1은 없음')
                    +tds('[ -o OPTIONNAME ]', '쉘 옵션이 켜 있음')
                    +tds('[ -z STRING ]', 'STRING 길이 == 0')
                    +tds('[ -n STRING ] or [ STRING ]', 'STRING 길이 > 0')
                    +tds('[ STRING1 == STRING2 ]', '')
                    +tds('[ STRING1 != STRING2 ]', '')
                    +tds('[ STRING1 < STRING2 ]', '현재 로캐일상 STRING1이 앞섬')
                    +tds('[ STRING1 > STRING2 ]', '현재 로캐일상 STRING2가 앞섬')
                    +tds('[ ARG1 OP ARG2 ]', '정수 비교. OP in (-eq, -ne, -lt, -le, -gt, -ge)')
                    +tds('[ ! EXPRESSION ]', 'not EXPRESSION')
                    +tds('[ (EXPRESSION) ]', '연산 우선순위 조정 가능')
                    +tds('[ EXPRESSION1 -a EXPRESSION2 ]', 'EXPRESSION1 and EXPRESSION2')
                    +tds('[ EXPRESSION1 -o EXPRESSION2 ]', 'EXPRESSION1 or EXPRESSION2')
            h3 if - Advanced
            ul
                li [] vs [[]]
                ul
                    li [[]]는 변수 값에 대한 word splitting을 수행하지 않는다
                    li [[]]는 file name expansion을 수행하지 않는다
                    li [[]]는 glob 패턴 매칭 수행
                    +asCode('bash') if [[ "hello" == h* ]]; then echo hello; fi
                li else
                +asCode('bash') if ...; then ... else ... fi
                li elif
                +asCode('bash') if ...; then ... elif ...; then ... fi
                li if 구문 중첩 가능
            h3 case
                +pos('case')
            ul
                li ;; -> case 옵션 종결 &amp;&amp; case 구문 종료.
                li ;;&amp; -> case 옵션 종결 &amp;&amp; 다음 패턴 검사 실행. Since bash 4
                li ;&amp; -> case 옵션 종결 &amp;&amp; 다음 옵션 무조건 실행. Since bash 4
            +asCode('bash').
                case "$1" in
                    start)
                        start
                        ;;
                    restart)
                        stop
                        sleep 5
                        start
                        ;;
                    *)
                        echo "Usage $0 {start|restart}"
                        exit 1
                esac

                case $num in
                    10 | 20 ) echo $num' is 10 or 20';;
                    *) echo $num' is not 10 nor 20';;
                esac

        h2 Repetitive tasks
        div
            h3 for
            +asCode('bash').
                for NAME; do COMMANDS; done         # 실행 인자 순회
                for NAME in LIST; do COMMANDS; done # LIST 순회
                
                # e.g.
                for n in 10 20 30; do echo $n; done
                for n in {1..20}; do echo $n; done
                for n in log-{100..20}.txt; do echo $n; done
                for n in {z..A}; do echo $n; done
                for f in *; do cp "$f" "$f.bak"; done
            h3 select
            +asCode('bash').
                select NAME; do COMMANDS; done         # 실행 인자 중 선택
                select NAME in LIST; do COMMANDS; done # LIST 중 선택
            ol
                li stderr에 목록 출력 -> PS3 출력 -> stdin으로부터 한 줄 입력
                li 입력이 숫자로 구성되었고, 해당하는 항목이 존재하는 경우 : NAME에 항목 설정, REPLY에 입력 라인 설정
                li 입력이 비어있는 경우, goto 1
                li 입력이 EOF인 경우 반복 종료
                li 그 외의 경우 NAME은 null string, REPLY에 입력 라인 설정
            h3 while
            +asCode('bash') while CONTROL-COMMAND; do COMMANDS; done
            h3 until
            +asCode('bash') until TEST-COMMAND; do COMMANDS; done
            h3 break
            p 즉시 반복 중단
            h3 continue
            p 즉시 다음 순회로
            h3 shift
            +asCode('bash').
                shift   # $1 인자 버려짐
                shift 3 # $1, $2 인자 버려짐
                
                while (( "$#" ));
                do
                    echo $1
                    shift
                done

        h2 Function
        +asCode('bash').
            # 선언 1
            function FUNCNAME { COMMANDS; }
            # 선언 2
            FUNCNAME () { COMMANDS; }
            # 호출 1
            FUNCNAME
            # 호출 2
            FUNCNAME param1 param2 # <- 함수 안에서 $1, $2, ...로 접근
            # 호출 3
            test () {
                return 33
            }
            
            test
            echo $?
            val=$?
            
            exit $val

        h2 Catching signal
        div
            h3 Signal
            table.no-sort
                +tds('SIGHUP', '1', 'Hangup')
                +tds('SIGINT', '2', 'Interrupt frmo keyboard; Ctrl+C')
                +tds('SIGKILL', '9', 'Kill; 강제 종료')
                +tds('SIGTERM', '15', 'Termination; 정상 종료')
                +tds('SIGSTOP', '17, 19, 23', 'Stop')
            p SIGKILL, SIGSTOP은 잡거나, 지연시키거나, 무시할 수 없다
            h3 Trap
            +asCode('bash').
                trap COMMANDS SIGNALS
                # e.g.
                trap "{ echo \"Good Bye!\"; exit 255; }" EXIT
                exit 0
            ul
                li SIGNALS 중의 신호를 감지하면 COMMANDS가 실행된다
                li SIGNALS ::= 신호 이름(SIG 접두 생략 가능) 또는 정수

    h1 Commands
    div
        h2 :
        p 아무것도 하지 않는 null 명령.
        h2 echo
        p end-of-line 문자를 덧붙여 stdout으로 단순 출력. 항상 0 종료
        h2 printf
        p 포맷대로 stdout 출력. 처리에 따라 종료 상태 다를 수 있음.
        h2 source == .

    h1 사용자 관리
    ol
        li useradd : 사용자 추가
        +asCode('shell') $ useradd [options] USER_NAME
        p -d(HOME_DIR), -g(group id or name), -p(password), -D(기본값 출력/설정), 등...

        li passwd : 비밀번호 설정
        +asCode('shell') $ passwd [options] USER_NAME
        p -d(삭제), -l(잠금), -u(잠금 해제), -e(강제 만료)

        li usermod : 사용자 수정
        +asCode('shell') $ usermod [options] USER_NAME
        p -d(HOME_DIR), -m(HOME_DIR 변경 시 파일 이동), -L(잠금), -p(password), 등...

        li userdel : 사용자 삭제
        +asCode('shell') $ userdel [options] USER_NAME

        li groupadd : 사용자 그룹 추가
        +asCode('shell') $ groupadd [options] GROUP_NAME
        p -g(수동 GID), -p(password)

        li groupdel : 사용자 그룹 삭제
        +asCode('shell') $ groupdel [options] GROUP_NAME

        li su : 다른 사용자 권한 사용
        +asCode('shell') $ su [options] [-] [USER_NAME [arg]...]
        p 다른 사용자의 권한으로 쉘을 실행한다. USER_NAME이 없으면 root로 간주한다. 단순히 '-'만 있으면 '-l'과 동일하다.

        li 사용자 목록 : /etc/passwd
        +asCode().
            ID:Password(x):UID:GID:Comment:HOME_DIR:SHELL
            root:x:0:0:root:/root:/bin/bash
            dgkim:x:1000:1000:dgkim:/home/dgkim:/bin/bash
        li 비밀번호 목록 : /etc/shadow
        p !!는 비밀번호가 설정되지 않았음을 의미
        li 사용자의 홈디렉터리는 /etc/skel의 파일을 /home/${USER_NAME}에 복사하여 만들어진다

    h1 파일 시스템
    +asCode() UNIX에서 모든 것은 파일이다. 파일이 아닌 것이 있다면, 프로세스다.
    ol
        li 파일 종류
        ul
            li regular file(-) : 일반적인 데이터(텍스트, 바이너리)를 갖는 파일
            li directory(d) : 다른 파일의 목록을 갖는 파일
            li special file(c) : IO에 이용. 대부분 /dev 경로에 존재
            li link(l) : 다른 파일/디렉터리를 가리키는 파일
            li socket(s) : 프로세스 간 통신에 이용. TCP/IP 소켓과 유사
            li named pipe(p) : 프로세스 간 통신에 이용. 네트워크 소켓 semantic를 사용하지 않음
            li block device(b) : 하드디스크, DVD 등 블록/섹터 단위 IO 장치파일

        li 디렉터리 구조
        table
            +ths('디렉터리', '내용')
            +tds('/bin', '시스템, 관리자, 일반 사용가 모두가 공유하는 명령어')
            +tds('/boot', '시동에 필요한 파일')
            +tds('/dev', '주변장치파일')
            +tds('/etc', '환경설정')
            +tds('/home', '유저 개인 파일')
            +tds('/lib', '라이브러리, 커널 모듈')
            +tds('/mnt, /media', '보조기억장치 mount point')
            +tds('/net', '원격 파일 시스템 mount point')
            +tds('/opt', '3rd party 프로그램')
            +tds('/proc', '시스템 리소스 정보')
            +tds('/root', '관리자 전용 홈 디렉터리')
            +tds('/sbin', '시스템 및 관리자용 프로그램')
            +tds('/tmp', '임시 파일. 재부팅 시 삭제되므로 저장용으로 사용하지 말 것')
            +tds('/usr', '응용(not system)프로그램')
            +tds('/var', '자주 변경하는 파일')

        li 자신의 홈 디렉터리 확인 : echo $HOME

        li I-node
        p 파일의 이름을 제외한 모든 정보. ID는 각 파일에 고유하게 부여된다

        li pwd : 작업 디렉터리 절대경로 출력. Print working directory
        +asCode('shell') $ pwd

        li cd : 작업 디렉터리 변경
        +asCode('shell').
            $ cd            # 자신의 HOME_DIR로
            $ cd DIR        # 지정 디렉터리로
            $ cd ~USER_NAME # 유저 HOME_DIR로

        li ls : 파일 목록 출력
        +asCode('shell') $ ls [options] [paths]
        ul
            li options
            p -a(.로 시작하는 경로 포함), -c(with -lt: 시간순, with -l: 이름순), -X(확장자순), -S(크기순), -r(역정렬), -l(자세히), 등...
            li 출력 예
            +asCode().
                d rwx r-x r-x # 디렉터리, 소유자 권한, 그룹 권한, 기타 사용자 권한 755(read, write, execute)
                - rw- r-- r-- # 파일, (상동) 644
                l r-- r-- r-- # 링크, (상동) 444

        li mkdir : 디렉터리 생성
        +asCode('shell') $ mkdir [options] [directories]
        p -m(권한, 기본 755), -p(경로상의 모든 디렉터리 생성)

        li rm : 파일 삭제
        +asCode('shell') $ rm [options] [paths]
        ul
            li options
            p -f(파일이 없으면 무시), -i(각 파일 삭제 확인), -r(재귀 실행), 등...
            li 예. my_dir 디렉터리 및 내부 파일 모두 삭제
            +asCode('shell') $ rm -rf ./my_dir

        li touch : 파일 시각 변경
        +asCode('shell') $ touch [options] [files]
        p 각 파일에 대해 시간 정보를 현재 시각으로 변경한다. 파일이 없으면 생성한다(크기 0).

        li 파일 권한 변경
        +asCode('shell').
            $ chmod [options] 8진수 [paths]
            # 예. 모든 .sh 파일 실행 권한 부여
            $ chmod +x *.sh
            # 예. bin/ 디렉터리 하위 전체에 실행 권한 부여
            $ chmod -R +x ./bin/

            # 예. tmp/ 디렉터리 하위 전체 소유자 변경
            $ chown -R readonly ./tmp/

            # 예. tmp/ 디렉터리 하위 전체 소유 그룹 변경
            $ chgrp -R readonly ./tmp/

        li cp : 파일 복사
        +asCode('shell').
            $ cp [options] source dest_path
            $ cp [options] [sources] [target_directory]
        p -a(파일 속성 유지), -b(목적지에 이미 있으면 백업하고 복사), -r(재귀 실행), -s(심볼릭 링크 생성), 등...

        li mv : cp + 원본 삭제

        li cat : 파일 텍스트 출력
        +asCode('shell') $ cat [options] [files]
        p -n(줄 번호), -E(줄 끝에 $), -s(반복적인 빈 라인 생략), -T(탭을 ^T로 표기)

        li find
        p 파일명 표현에 와일드카드 *, ?가 허용된다. 표현식 앞에 !이나 -not을 붙일 수 있다. 표현식들 사이를 -and, -or로 엮을 수 있다.

        li grep : 텍스트 검색
        +asCode('shell') $ grep [options] pattern [files]
        p -E(ERE), -G(BRE), -P(Perl Regexp), -e(정규표현식), -i(ignore case), -w(패턴에 단어 전체가 매칭되는 경우만), -x(패턴에 줄 전체가 매칭되는 경우만), -m(최대 출력 개수), -n(줄 번호 같이 출력), -o(매칭된 부분만 출력), -l(매칭된 파일들의 이름만 출력), -L(매칭되지 않는 파일들의 이름만 출력), -A(매칭 후 n개 라인도 출력), -B(매칭 전 n개 라인도 출력) 등...

        li | : 파이프라인
        p 프로세스들의 출력과 입력을 잇는 파이프라인을 구성한다.
        +asCode('shell') $ history | grep psql

        li tar : 압축
        +asCode('shell').
            $ tar [options] file       # 압축해제
            $ tar [options] file paths # 압축
        p Main Operation : -A(append), -r(append), -c(create), -d(파일 시스템과의 차분 출력), -t(목록 출력), -u(update), -x(압축해제)
            br
            | 포맷 : --bzip2, --xz, --lzip, --lzma, --gzip
            br
            | -h(링크 자체 대신, 링크가 가리키는 파일을 압축한다)

    h1 패키지 관리
    ol
        li RPM : Redhat Package Manager
        p {package_name}-{version}-{release}.{architecture}.rpm
        +asCode('shell') $ rpm [options]
        p -a(전체 패키지 검증), -i(install), -U(설치 또는 upgrade), -F(기존 패키지 upgrade), -v(verbose), -h(진행과정을 #로), -e(erase), -qa(설치된 패키지 목록), -qi(패키지 상세 정보) 등...
        li yum
        p 인터넷 저장소로부터 패키지를 다운로드하여 설치. 의존 패키지까지 자동 설치한다.
            br
            | Commands : clean(캐시 삭제), check-update, downgrade, erase, info, install, list, reinstall, search, update, version, 등...

    h1 EPEL(Extra Packages for Enterprise Linux) 허용
    ol
        li 서드 파티 패키지를 설치하려면 EPEL을 허용해야 한다
        li RHEL 6.x / CentOS 6.x
        +asCode('shell') $ rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-6.noarch.rpm
        li RHEL 7.x / CentOS 7.x
        +asCode('shell') $ rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm
        p 또는
        +asCode('shell') $ yum install epel-release.noarch

    h1 시간 관련
    ol
        li date : 시각 출력/변경
        +asCode('shell').
            $ date                # 현재 시각 출력
            $ date "+%Y-%m-%d %T" # 포맷 지정

            $ date -s time_string # 시각 변경
            $ date -s "2019-01-01 12:34:56"

        li
            +asA('https://nxmnpg.lemoda.net/8/ntpdate', 'ntpdate')
            |  : 시각 동기화
        +asCode('shell').
            $ ntpdate server    # 동기화
            $ ntpdate -d server # 오차 출력
        p NTP : Network Time Protocol. 시간 동기화를 위한 프로토콜.
        +asA('https://zetawiki.com/wiki/공용_NTP_서버_목록')

    h1 crond : 작업 예약
    +asCode('shell').
        $ systemctl status crond # 상태 확인
        $ crontab -l             # 작업 목록 출력
            # -e : edit
            # -u : 사용자 지정
    ul
        li 유저가 아닌 시스템 단위의 작업은 /etc/crontab 직접 수정
        li crontab path 설정
        +asCode() PATH=/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin

    h1 프로세스 관련
    ol
        li 새 프로세스 실행
        ol
            li fork : 새 프로세스는 기존 프로세스(parent)가 PID만 다른 복제본을 생성함으로써 만들어진다.
            li exec : 새 프로세스의 정보로 주소 공간을 덮어쓴다

        li ps : 프로세스 출력. Process Snapshot
        +asCode('shell') $ ps -ef # -e(전체 프로세스), -f(full-format)

        li w : 로그인한 유저와 무엇을 실행중인지 출력

        li kill : 프로세스 종료
        +asCode('shell') $ kill -9 pid # 15(일반 종료), 2(종료; 무시 가능), 9(강제종료; 무시 불가), 1(구성 파일 다시 읽기; 데몬 프로세스)

        li top : 실행 중인 작업 보기.

        li 백그라운드 작업
        ul
            li %n : 모든 백그라운드 프로세스는 번호를 할당받으며, %n으로 참조할 수 있다
            li Ctrl + Z : 현재 프로세스를 백그라운드로 전환하고 suspend
            li bg : 백그라운드 job으로 계속 실행 ↔ fg %n
            li jobs : 백그라운드 job 리스트
            p 명령행 끝에 &를 붙이면 즉시 백그라운드 job으로 실행시킬 수 있다
                br
                | 현재 터미널 세션이 종료해도 n번 백그라운드 job을 계속하게 하려는 경우 : disown -h %n
            li nohup name.sh &>/dev/null &
            ul
                li nohup : 세션이 종료해도 프로세스는 계속 실행
                li & : 백그라운드로 실행

    h1 메모리 관련
    ol
        li vmstat : Report virtual memory statistics
        +asCode('shell') $ vmstat 1 # 1초마다 출력

        li free : Display amount of free and used memory in the system.
        +asCode('shell').
            $ free -m -w -h -s 1
                # -m : 메가바이트 단위
                # -w : wide output
                # -h : human-readable output
                # -s 1 : 1초마다

    h1 환경변수
    +asCode('shell').
        $ printenv [VAR_NAMES]
        $ echo $VAR_NAME
        $ export VAR_NAME[=value]
        # export PATH="$PATH:/usr/java/jdk-13.0.2/bin

    h1 FTP Server : vsftpd
    ol
        li 설치
        +asCode('shell') $ yum install vsftpd

        li 설정 : /etc/vsftpd/vsftpd.conf
        +asCode('properties').
            anonymous_enable=NO # 익명 차단
            listen_ipv6=NO # IPv4 사용

        li 방화벽 허용
        +asCode('shell').
            $ firewall-cmd --permanent --add-service=ftp
            $ firewall-cmd --permanent --add-port=21/tcp
            $ firewall-cmd --reload
            # ↓ 잘 됐는지 확인
            $ firewall-cmd --zone=public --list-all

        li SELinux 관련 정책 확인
        +asCode('shell').
            $ getsebool -a | grep ftp
            $ setsebool ftp_home_dir on # 필요한 권한은 허용

        li 시스템 시작
        +asCode('shell').
            $ systemctl enable vsftpd
            $ systemctl restart vsftpd
    ul
        li root 로그인 허용
        p /etc/vsftpd/ftpusers, /etc/vsftpd/user_list에서 root 제거

        li 사용자 홈 디렉터리 외부 접근 허용
        p /etc/vsftpd/chroot_list : chroot_list_enable=YES

        li Active Mode 사용 : 20포트
        p /etc/vsftpd/vsftpd.conf : pasv_enable=NO

        li Passive Mode 사용
        ol
            li /etc/vsftpd/vsftpd.conf
            +asCode('properties').
                connect_from_port_20=NO
                pasv_enable=YES
                pasv_min_port=50000
                pasv_max_port=50010
            li 방화벽에서 [pasv_min_port,pasv_max_port]/tcp 허용

    h1 SELinux
    ol
        li SELinux 모드 : enforce, permissive, disable
        p setenforce 1 # enforce로 임시 변경
            br
            | setenforce 0 # permissive로 임시 변경
            br
            | getenforce # 모드 확인
        li 부팅시 사용되는 기본 모드는 /etc/selinux/config에 정의돼있다
        li SELinux 로그 위치 : /var/log/audit/audit.log
        li SELinux 로그 분석 유티릴티 : setroubleshoot
        +asCode('shell').
            $ yum install setroubleshoot
            $ sealert -a /var/log/audit/audit.log

    h1 /etc/hosts
    p: strong address hostname[[ alias1]...]
    +asCode().
        127.0.0.1   localhost localhost4
        ::1         localhost localhost6

    h1 vi
    div
        +asA('https://vim.rtorr.com/lang/ko/', 'Vim Cheat Sheet »')

        h2 모드
        ol
            li 처음 vi를 실행하면 normal mode(command mode)
            p insert mode와 visual mode에서 esc를 누르면 normal mode로 회귀.
            li i를 누르면 insert mode
            li v를 누르면 visual mode
            li :를 누르고 명령어 실행
            ul
                li :set nu # 줄 번호 표시
                li :syn on, :syn enable # 키워드 및 문맥 강조

        h2 저장
        ol
            li :w
            li :w! 덮어쓰기
            li :w 파일명 // 새 파일인 경우
            li :saveas 파일명

        h2 종료
        ol
            li :q
            li :wq : 저장 후 종료
            li :q! : 저장하지 않고 종료

        h2 이동
        div
            img.w3-round(src='http://cfile8.uf.tistory.com/image/141F57474F4732890DE706')

        h2 vim
        ol
            li 열기
            ul
                li :edit 파일명
                li :tabnew 파일명
                li $ vim 파일명1 파일명2 ...
                p :n으로 열린 파일 선택. 파일을 탭으로 열고 싶다면 -p 옵션
            li 복사/붙여넣기
            ul
                li 복사 : Ctrl + Insert
                li 붙여넣기 : Shift + Insert
                p ~/.vimrc 에서
                    br
                    | set mouse=a 로 되어있던게 문제였습니다. set mouse=c 로 변경하니까 vim 에서 텍스트의 복사하기 붙여넣기 잘 되는군요.
                    br
                    | a 는 마우스를 사용하겠다는 것이고 c 는 마우스를 사용치 않겠다는 것 같은데, c 로 해놔도 마우스로 커서 옮기고 스크롤하는 것 등은 잘 되더군요.. 출처 : https://kldp.org/node/129456

        h2 지우기
        ol
            li n dd : 커서로부터 n 줄 삭제
            li n dw : 커서로부터 n 단어 삭제
            li gg -> dG : 첫줄로 이동 -> 끝까지 삭제

    details
        summary 정리 필요
        h2 Quickstart
        div
            h3 Absolute basics
            div
                h4 commands
                p ls, cd, passwd, file filename, cat textfile, pwd, exit, logout, man command, info command, whatis command, apropos string, command --help
                h4 Bash features
                p
                    | Ctrl+A : 커서를 맨 앞으로
                    | C : 실행 중인 프로그램 종료
                    | D : 현재 쉘 로그아웃
                    | E : 커서를 맨 끝으로
                    | H : backspace
                    | L : Clear
                    | R : 히스토리 탐색
                    | Z : 실행 중인 프로그램 일시 정지
                    | ArrowLeft, ArrowRight : 커서 이동
                    | ArrowUp, ArrowDown : 히스토리 탐색
                    | Shift+PageUp/PageDown : 터미널 버퍼 이동
                    | Tab : 자동 완성
                    | Tab Tab : 완성 가능 목록

        h1: +asA('https://tldp.org/HOWTO/HOWTO-INDEX/index.html', 'Linux HOWTO')
        div
            h2: +asA('https://tldp.org/HOWTO/HOWTO-INDEX/os.html', 'The Linux OS')
            div
                h3 Getting Started
