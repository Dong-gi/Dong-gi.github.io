include ../../source/skeleton.pug
+post('Ruby Basic', 'Ruby, Tutorial', 'ë£¨ë¹„ ê¸°ì´ˆ ì •ë¦¬')
    h1 ê°œìš”
    ul
        li ì˜¤í”ˆì†ŒìŠ¤, ê°ì²´ì§€í–¥, ìŠ¤í¬ë¦½íŠ¸ í”„ë¡œê·¸ë˜ë° ì–¸ì–´ì˜ ì¼ì¢…
        li: +asA('https://www.ruby-lang.org/', 'www.ruby-lang.org')
        li ëª¨ë“  ë³€ìˆ˜ëŠ” ê°ì²´ë¡œ ì¡´ì¬í•œë‹¤
        li ì‹¤í–‰
        +asCode('shell').
            $ ruby [filename]
            $ ruby -e 'code line' [[-e 'code line']...]
        li REPL
        +asCode('shell').
            $ irb
            irb(main):001:0> 'hello'
            => "hello"
            irb(main):002:0> %x(ls -al)
        li ì¢…ë¥˜
        ul
            li CRuby, MRI(Matz's Ruby Interpreter) : Ruby ì°¸ì¡° êµ¬í˜„
            li JRuby : JVMì—ì„œ ë™ì‘í•˜ë©°, Java ë¼ì´ë¸ŒëŸ¬ë¦¬ ì´ìš© ê°€ëŠ¥
            +asCode('ruby').
                include Java
                import java.util.List
                # ...
            li MacRuby : Objective-C ëŸ°íƒ€ì„ì—ì„œ ë™ì‘í•˜ë©°, Cocoa í”„ë ˆì„ì›Œí¬ ì´ìš© ê°€ëŠ¥
        li ì½”ë”© ê·œì•½
        table
            +ths('ë¶„ë¥˜', 'Ruby', 'Java')
            tr
                td í´ë˜ìŠ¤, ëª¨ë“ˆ
                td: +asCode('ruby').
                    class MyClass
                    end

                    module MyModule
                    end
                td: +asCode('java') class MyClass {}
            tr
                td ë©”ì„œë“œ
                td: +asCode('ruby').
                    def my_method
                    end

                    def open?
                        true
                    end
                td: +asCode('java').
                    void myMethod() {}
                    boolean isOpen() { return true; }
            tr
                td ë³€ìˆ˜
                td: +asCode('ruby') my_variable = 1
                td: +asCode('java') var myVariable = 1;

    h1 ë¬¸ë²•
    div
        h2 ìŠ¤ì½”í”„
        ul
            li Class level
            li Module level
            li Method level
            li Block level
            li Top level(ì•ì˜ ê²ƒë“¤ ì™¸ ë‚˜ë¨¸ì§€)

        h2 ë¬¸ì¥
        ul
            li ì£¼ì„ : #
            li ë¼ì¸
            p ê¸°ë³¸ì ìœ¼ë¡œ ë¼ì¸ ë‹¹ ì‹ í•˜ë‚˜. ì—¬ëŸ¬ ì‹ì„ í•œ ë¼ì¸ì— ê¸°ìˆ í•˜ë ¤ë©´ ;ë¡œ êµ¬ë¶„
            li ì½”ë“œ ì¸ì½”ë”© ì§€ì •
            +asCode('ruby') # encoding: utf-8
            li í”„ë¡œê·¸ë¨ ë : __END__
            p __END__ ì´í›„ëŠ” ì‹¤í–‰ë˜ì§€ ì•ŠëŠ”ë‹¤
            +asCode('ruby', 'test.rb').
                puts DATA
                puts DATA.fileno
                DATA.each_line do |line|
                    puts line
                end
                __END__
                line1

                line2
            +asCode('shell').
                wiz@DESKTOP-FPFPV4B MINGW64 /d
                $ ruby test.rb
                #&lt;File:0x00000000051e2530>
                3
                line1

                line2

        h2 ì—°ì‚°ì
        ul
            li ë™ë“± ë¹„êµ ==
            p ==ëŠ” ë‚´ìš©ë¬¼ì´ ê°™ìœ¼ë©´ true ë°˜í™˜. ì¸ìŠ¤í„´ìŠ¤ ì£¼ì†Œ ë¹„êµì—ëŠ” equal? ë©”ì„œë“œ ì´ìš©
            li ë™ë“± ë¹„êµ ===
            ul
                li ê¸°ë³¸ì ìœ¼ë¡œ ==ê³¼ ë™ì¼
                li Pattern === value # ë§¤ì¹­ë˜ë©´ true
                li Range === value # rangeì— í¬í•¨ë˜ë©´ true
                li Proc === params # paramsë¥¼ ì¸ìë¡œ ì‹¤í–‰í•œ ê²°ê³¼ ë°˜í™˜
                li Module, Class === value # ì¸ìŠ¤í„´ìŠ¤ê°€ í˜¸í™˜ë˜ë©´ true
            li push ì—°ì‚° &lt;&lt;
            p ë°°ì—´, String, Integers ê°ê°ì— ëŒ€í•´ ì„œë¡œ ë‹¤ë¥¸ ë™ì‘ ìˆ˜í–‰
            li ë¹„êµ ì—°ì‚° a &lt;=> b
            ul
                li 1 : aê°€ bë³´ë‹¤ ë’¤ì— ìˆìŒ(a > b)
                li 0 : aì™€ bëŠ” ë™ì¼ ìˆœì„œ
                li -1 : aê°€ bë³´ë‹¤ ì•ì— ìˆìŒ(a &lt; b)
            li a ||= 10
            p ë³€ìˆ˜ aê°€ ì•„ì§ ì¡´ì¬í•˜ì§€ ì•Šê±°ë‚˜, false, nilì´ë©´ 10ì„ í• ë‹¹
            +asCode('ruby') (defined?(a) &amp;&amp; a) ? a : a = 10
            li ë‹¤ì¤‘ í• ë‹¹
            +asCode('ruby').
                a, b = 1, 2
                a, b = [1, 2, 3]
                a, b, c = [1, 2]    # c == nil
                a, *rest = [1, 2, 3, 4, 5]
            li ë°°ì—´ í•´ì²´ *
            +asCode('ruby').
                def plus(a, b)
                    a + b
                end
                plus *[1, 2]
            li nil safe ì°¸ì¡° ì—°ì‚° &amp;.
            p receiverê°€ nilì´ë©´ ì°¸ì¡°ë¥¼ ìˆ˜í–‰í•˜ì§€ ì•ŠìŒ
            li ì •ê·œì‹ ë§¤ì¹­ text =~ pattern, text !~ pattern
            li ì‚¬ìš©ì ì •ì˜ ì—°ì‚°ì
            p ì •ì˜ ê°€ëŠ¥ ì—°ì‚°ì : | ^ &amp; &lt;=> == =~ &lt;&lt; -@ + - * / % ** ~ [] []= ` != ë“±
            +asCode('ruby').
                class Point
                    attr_accessor :x
                    attr_accessor :y

                    def initialize(x = 0, y = 0)
                        self.x = x
                        self.y = y
                    end
                    def -@      # ë‹¨í•­ ì—°ì‚°ìëŠ” ë’¤ì— @ê°€ ë¶™ëŠ”ë‹¤
                        self.x *= -1
                        self.y *= -1
                        self
                    end
                end
            li ë©”ì„œë“œ í˜¸ì¶œ ì‹œ . ëŒ€ì‹  :: ì‚¬ìš© ê°€ëŠ¥

        h2 ì œì–´ì‹
        ul
            li if
            +asCode('ruby', 'if 1').
                r = if expression1 # false, nil ì™¸ì˜ ëª¨ë“  ê°’ì€ trueë¡œ ê°„ì£¼
                    # ...
                elsif expression2
                    # ...
                else
                    # ...
                end                # ë§ˆì§€ë§‰ í‰ê°€ëœ ì‹ì˜ ê°’ì„ ë°˜í™˜
            +asCode('ruby', 'if 2') ... if expression # trueë©´ ì• ë¬¸ì¥ ì‹¤í–‰
            +asCode('ruby', 'if 3') if expression1 then ... elsif expression2 then ... else ... end

            li unless
            +asCode('ruby', 'unless 1').
                r = unless expression # falseë©´ ì‹¤í–‰
                    # ...
                else                  # elsifì— ëŒ€ì‘í•˜ëŠ” í‚¤ì›Œë“œëŠ” ì—†ë‹¤
                    # ...
                end                   # ë§ˆì§€ë§‰ í‰ê°€ëœ ì‹ì˜ ê°’ì„ ë°˜í™˜
            +asCode('ruby', 'unless 2') ... unless expression # falseë©´ ì• ë¬¸ì¥ ì‹¤í–‰

            li case
            p when ì ˆê³¼ ìµœì´ˆë¡œ ì¼ì¹˜(===)í•˜ëŠ” ë¸”ë¡ë§Œ ì‹¤í–‰
            +asCode('ruby', 'case 1').
                r = case expression # ë§ˆì§€ë§‰ í‰ê°€ê°’ ë°˜í™˜
                when 'value'
                    # ...
                when 'value1', 'value2'
                    # ...
                when /pattern/
                    # ...
                when ClassName
                    # ...
                else
                    # div
                end
            +asCode('ruby', 'case 2').
                case                      # ì‹ì„ ì§€ì •í•˜ì§€ ì•Šì€ ê²½ìš°, ìµœì´ˆë¡œ trueê°€ ë˜ëŠ” when ë¸”ë¡ ì‹¤í–‰
                when expression1 then ... # thenì„ ì´ìš©í•´ í•œ ì¤„ë¡œ í‘œê¸° ê°€ëŠ¥
                when expression2 then ...
                else ...
                end

            li while, until
            +asCode('ruby', 'while').
                while expression
                    # ... trueì¸ ë™ì•ˆ ë°˜ë³µ
                end

                ... while expression # trueì¸ ë™ì•ˆ ì•ë¬¸ì¥ ë°˜ë³µ

                begin
                    # ... ì ì–´ë„ 1ë²ˆì€ ì‹¤í–‰ëœë‹¤
                end while expression
            +asCode('ruby', 'until').
                until expression
                    # ... falseì¸ ë™ì•ˆ ë°˜ë³µ
                end

                ... until expression # falseì¸ ë™ì•ˆ ì•ë¬¸ì¥ ë°˜ë³µ

                begin
                    # ... ì ì–´ë„ 1ë²ˆì€ ì‹¤í–‰ëœë‹¤
                end until expression

            li for
            p each ë©”ì„œë“œë¥¼ ê°€ì§„ ê°ì²´ëŠ” for ìˆœíšŒ ê°€ëŠ¥
            +asCode('ruby', 'for 1').
                for val in %w(word1 word2 word3)
                    # ...
                end

                puts val # ê³„ì† ì‚¬ìš© ê°€ëŠ¥
            +asCode('ruby', 'for 2').
                for item in {a: 1, b: 2}
                    puts item[0], item[1] # ê°ê° í‚¤-ê°’
                end

                for key, val in {a: 1, b: 2}
                    # ...
                end

            li ë°˜ë³µ êµ¬ë¬¸ ëŒ€ì²´ ë©”ì„œë“œ
            +asCode('ruby', 'Kernel#loop').
                loop do
                    # ... ë¬´í•œ ë£¨í”„
                end
            +asCode('ruby', 'Integer#times').
                5.times do
                    # ...
                end

            li ì í”„
            ul
                li break[ expression]
                ol
                    li ë£¨í”„ ì•ˆì—ì„œ : í‘œí˜„ì‹ì˜ ê°’ìœ¼ë¡œ ë£¨í”„ ì¢…ë£Œ
                    li yield í˜¸ì¶œ ì•ˆì—ì„œ : í‘œí˜„ì‹ì˜ ê°’ìœ¼ë¡œ ë©”ì„œë“œ ì¢…ë£Œ
                li next[ expression]
                ol
                    li ë£¨í”„ ì•ˆì—ì„œ : ë‹¤ìŒ ë£¨í”„ ì‹¤í–‰
                    li yield í˜¸ì¶œ ì•ˆì—ì„œ : í‘œí˜„ì‹ì˜ ê°’ìœ¼ë¡œ yield ì¢…ë£Œ
                li catch/throw
                +asCode('ruby').
                    r = catch :label1 do
                        # ...
                        r = catch :label2 do
                            if ?
                                throw label2 return_value # íŠ¹ì • catch ë¸”ë¡ ì¢…ë£Œ
                            else
                                throw label1              # ë°˜í™˜ê°’ ì§€ì • ì—†ìœ¼ë©´ nil
                        end
                    end

            li ì˜ˆì™¸ ì²˜ë¦¬
            p ì˜ˆì™¸ ì²˜ë¦¬ êµ¬ë¬¸ì€ ë©”ì„œë“œ, í´ë˜ìŠ¤, ëª¨ë“ˆ ì •ì˜ ëª¨ë‘ì—ì„œ ì‚¬ìš© ê°€ëŠ¥
            +asCode('ruby', 'rescue 1').
                r = begin                         # begin, rescue, else ì ˆì˜ ë§ˆì§€ë§‰ìœ¼ë¡œ í‰ê°€ëœ ì‹ì˜ ê°’ì„ ë°˜í™˜
                    1 / 0
                    raise 'message'               # RuntimeError
                    raise StandardError 'message' # StandardError
                rescue Class1, Class2 => e
                    retry                         # ì˜ˆì™¸ ë°œìƒ ë¸”ë¡ ì²˜ìŒë¶€í„° ë‹¤ì‹œ ì‹¤í–‰
                rescue                            # í´ë˜ìŠ¤ ì§€ì •ì—†ëŠ” ê²½ìš°, StandardErrorë¡œ ê°„ì£¼
                    raise                         # ë‹¤ì‹œ ì „íŒŒ
                else                              # ì˜ˆì™¸ ë°œìƒí•˜ì§€ ì•Šì€ ê²½ìš° ì‹¤í–‰
                    # ...
                ensure                            # ë‹¤ë¥¸ ì–¸ì–´ì˜ finally ê¸°ëŠ¥
                    # ...
                end
            +asCode('ruby', 'rescue 2').
                expression1 rescue expression2    # expression1 ë„ì¤‘ StandardError ë°œìƒí•œ ê²½ìš°, expression2 í‰ê°€ê°’ ë°˜í™˜

        h2 ë³€ìˆ˜
        ul
            li ì§€ì—­ë³€ìˆ˜ ì„ ì–¸ì— ë³„ë„ í‚¤ì›Œë“œ í•„ìš”ì—†ìŒ
            +asCode('ruby') msg = "Hello World"
            li ì „ì—­ë³€ìˆ˜ prefix : $
            +asCode('ruby').
                $size = 10  # ì „ì—­ë³€ìˆ˜ í• ë‹¹
                $not_exists # ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ì „ì—­ë³€ìˆ˜ ì°¸ì¡°ëŠ” nil ë°˜í™˜
            li ìƒìˆ˜ : SNAKE_CASE
            +asCode('ruby').
                SIZE = 10
                SIZE = 20   # ì‹¤í–‰ë¨. Warning ì¶œë ¥
            li ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ : @
            +asCode('ruby').
                class ClassName
                    def length=(length)
                        @length = length
                    end
                    def length
                        @length
                    end
                end

                class Point
                    attr_accessor :x, :y     # getter, setter ëª¨ë‘ ìƒì„±
                    attr_reader   :readonly  # getterë§Œ ìƒì„±
                    attr_write    :writeonly # setterë§Œ ìƒì„±
                end
            li ë‚´ì¥ ë³€ìˆ˜
            table
                +ths('ì´ë¦„', 'ì„¤ëª…')
                +tds('$stdin', 'í‘œì¤€ ì…ë ¥. default STDIN')
                +tds('$stdout, $>', 'í‘œì¤€ ì¶œë ¥. default STDOUT')
                +tds('$stderr', 'í‘œì¤€ ì—ëŸ¬. default STDERR')
                +tds('$/, $-0', 'ì…ë ¥ì˜ ì¤„ë°”ê¿ˆ ë¬¸ìì—´. default \\n')
                +tds('$SAFE', 'í˜„ì¬ ìŠ¤ë ˆë“œ safe level')
                +tds('$!', 'ë§ˆì§€ë§‰ ë°œìƒí•œ ì˜ˆì™¸ ê°ì²´')
                +tds('$@', 'ë§ˆì§€ë§‰ ë°œìƒí•œ ì˜ˆì™¸ì˜ Backtrace')
                +tds('$$', 'ì‹¤í–‰ ì¤‘ì¸ ë£¨ë¹„ í”„ë¡œì„¸ìŠ¤ PID')
                +tds('$?', 'ë§ˆì§€ë§‰ìœ¼ë¡œ ì¢…ë£Œëœ í”„ë¡œì„¸ìŠ¤ exit code')
                +tds('$:, $LOAD_PATH, $-I', 'ìŠ¤í¬ë¦½íŠ¸ íƒìƒ‰ ë””ë ‰í„°ë¦¬')
                +tds('$LOADED_FEATURES, $"', 'requireë¡œ ì½ì€ íŒŒì¼ë“¤')
                +tds('$DEBUG', 'ë””ë²„ê·¸ ëª¨ë“œë¡œ ì‹¤í–‰ëœ ê²½ìš° true')
                +tds('$VERBOSE', 'nilì´ë©´ ê²½ê³  ì¶œë ¥ x, falseë©´ ì¤‘ìš” ê²½ê³  ì¶œë ¥, trueë©´ ëª¨ë“  ê²½ê³  ì¶œë ¥')
                +tds('$~', 'ë§ˆì§€ë§‰ìœ¼ë¡œ ì •ê·œì‹ì— ë§¤ì¹˜ëœ MatchData')
                +tds('$1, $2, ...', 'ë§ˆì§€ë§‰ìœ¼ë¡œ ì •ê·œì‹ì— ë§¤ì¹˜ëœ ê° ê·¸ë£¹ë“¤')
                +tds('$+', 'ë§ˆì§€ë§‰ìœ¼ë¡œ ì •ê·œì‹ì— ë§¤ì¹˜ëœ ë§ˆì§€ë§‰ ê·¸ë£¹')
                +tds('$&', 'ë§ˆì§€ë§‰ìœ¼ë¡œ ì •ê·œì‹ì— ë§¤ì¹˜ëœ ë¬¸ìì—´')
                +tds('$`', 'ë§ˆì§€ë§‰ìœ¼ë¡œ ì •ê·œì‹ì— ë§¤ì¹˜ëœ ë¬¸ìì—´ ì‹œì‘ ìœ„ì¹˜ ì „ê¹Œì§€ì˜ ë¬¸ìì—´')
                +tds("$'", 'ë§ˆì§€ë§‰ìœ¼ë¡œ ì •ê·œì‹ì— ë§¤ì¹˜ëœ ë¬¸ìì—´ ì¢…ë£Œ ìœ„ì¹˜ í›„ë¶€í„°ì˜ ë¬¸ìì—´')
                tr
                    td $PROGRAM_NAME
                        br
                        |$*
                        br
                        |$FILENAME
                        br
                        |$&lt;
                    td ì‹¤í–‰ ì¤‘ì¸ ìŠ¤í¬ë¦½íŠ¸ ì´ë¦„
                        br
                        |ìŠ¤í¬ë¦½íŠ¸ ì‹¤í–‰ ì¸ì
                        br
                        |$&lt; íŒŒì¼ëª…
                        br
                        |ì‹¤í–‰ ì¸ì ë˜ëŠ” STDINìœ¼ë¡œ ì§€ì •ëœ íŒŒì¼
                        +asCode('ruby', 'test.rb').
                            puts %($PROGRAM_NAME : &#x23;{$PROGRAM_NAME})
                            puts %($*            : &#x23;{$*})
                            puts %($FILENAME     : &#x23;{$FILENAME})
                            puts %($&lt;            : &#x23;{$&lt;})
                            puts %(ARGF read\n-----\n&#x23;{$&lt;.read}\n-----)
                        +asCode('shell').
                            $ ruby test.rb test.rb Games/Breach.exe
                            $PROGRAM_NAME : test.rb
                            $*            : ["test.rb", "Games/Breach.exe"]
                            $FILENAME     : test.rb
                            $&lt;            : ARGF
                            ARGF read
                            -----
                            puts %($PROGRAM_NAME : &#x23;{$PROGRAM_NAME})
                            puts %($*            : &#x23;{$*})
                            puts %($FILENAME     : &#x23;{$FILENAME})
                            puts %($&lt;            : &#x23;{$&lt;})
                            puts %(ARGF read\n-----\n&#x23;{$&lt;.read}\n-----)
                            MZP      ï¿½ï¿½  ï¿½       @
                            -----
            li ë‚´ì¥ ìƒìˆ˜
            table
                +ths('ì´ë¦„', 'ì„¤ëª…')
                +tds('STDIN', '$stdin ê¸°ë³¸ê°’')
                +tds('STDOUT', '$stdout ê¸°ë³¸ê°’')
                +tds('STDERR', '$stderr ê¸°ë³¸ê°’')
                +tds('ARGV', '== $*')
                +tds('ARGF', '== $<')
                +tds('ENV', 'í™˜ê²½ ë³€ìˆ˜')
                +tds('RUBY_VERSION', 'ë£¨ë¹„ ì‹¤í–‰ ë²„ì „')

        h2 ë©”ì„œë“œ
        ul
            li ë©”ì„œë“œ ì •ì˜
            +asCode('ruby').
                def method_name
                    # ë¬´ì¸ì ë©”ì„œë“œ ë³¸ë¬¸
                end
                def method_name(arg1, arg2 = default_value, *arg3, arg4: default_value, **arg5, &amp;arg6)
                    # ìˆœì„œëŒ€ë¡œ ì¼ë°˜ ì¸ì, ê¸°ë³¸ê°’ ì¸ì, ê°€ë³€ ì¸ì, í‚¤ì›Œë“œ ì¸ì, í•´ì‹œ ì¸ì, ë¸”ë¡ ì¸ì
                end
            li í‚¤ì›Œë“œ ì¸ì ì „ë‹¬ ì˜ˆ
            +asCode('ruby').
                def test(n1: 1, n2: 2, **opt)
                    puts %(&#x23;{n1}, &#x23;{n2}, &#x23;{opt})
                end

                test n1: 10, n2: 20                 # 10, 20, {}
                test n1: 11, n2: 22, n3: 33, n4: 44 # 11, 22, {:n3=>33, :n4=>44}
            li ì ‘ê·¼ í•œì •ì
            ul
                li public : ì§€ì •í•˜ì§€ ì•Šì€ ê²½ìš° ì‚¬ìš©ë˜ëŠ” ê¸°ë³¸ê°’
                li private : ì¸ìŠ¤í„´ìŠ¤ ë‚´ì—ì„œë§Œ í˜¸ì¶œ ê°€ëŠ¥
                li protected : ì„œë¸Œ í´ë˜ìŠ¤ ì¸ìŠ¤í„´ìŠ¤ì—ì„œê¹Œì§€ í˜¸ì¶œ ê°€ëŠ¥
            li ë©”ì„œë“œ ì •ì˜ ì·¨ì†Œ
            +asCode('ruby') undef method_name1, method_name2
            li ë©”ì„œë“œ ë³„ëª…
            +asCode('ruby') alias new_name old_name
            li ë°˜í™˜ê°’
            p ê¸°ë³¸ì ìœ¼ë¡œ ë§ˆì§€ë§‰ í‰ê°€ëœ ì‹ì˜ ê°’ì´ ë°˜í™˜ê°’. ë„ì¤‘ì— ë°˜í™˜í•˜ë ¤ë©´ return í‚¤ì›Œë“œ ì´ìš©
            li ë©”ì„œë“œ í˜¸ì¶œ ì‹œ ê´„í˜¸ í•„ìš”ì—†ìŒ
            +asCode('ruby') receiver.method_name arg
            li Top level ë©”ì„œë“œ í˜¸ì¶œ ì‹œ receiver í•„ìš”ì—†ìŒ
            li ë©”ì„œë“œ ë‚´ë¶€ì—ì„œ receiverë¥¼ self í‚¤ì›Œë“œë¡œ ì°¸ì¡° ê°€ëŠ¥
            li ë©”ì„œë“œ ë‚´ë¶€ì˜ receiver ì§€ì •ì—†ëŠ” ë©”ì„œë“œ í˜¸ì¶œì€ selfë¥¼ receiverë¡œ ê°„ì£¼
            li Singleton method
            p íŠ¹ì • ì¸ìŠ¤í„´ìŠ¤ì—ë§Œ ì •ì˜ëœ ë©”ì„œë“œ
            +asCode('ruby').
                def obj.method_name
                    # ...
                end

        h2 ë¸”ë¡
        ul
            li block
            +asCode('ruby', 'block 1 - do~end').
                do |var_name|
                    # ...
                end
            +asCode('ruby', 'block 2 - {}').
                {|var_name1, var_name2, *var_name3|
                    # ...
                }
            li ë¸”ë¡ì˜ ë§¤ê°œë³€ìˆ˜ ê°œìˆ˜ê°€ ì‹¤ì œ í˜¸ì¶œë³´ë‹¤ ë§ê±°ë‚˜ ì ì–´ë„ ì—ëŸ¬ê°€ ì—†ë‹¤
            li ë¸”ë¡ì„ ë°›ëŠ” ë©”ì„œë“œ
            +asCode('ruby', 'code 1').
                def my_method
                    if block_given? # ë©”ì„œë“œì— ë¸”ë¡ì´ ì£¼ì–´ì¡ŒëŠ”ì§€ íŒë³„í•˜ëŠ” ë‚´ì¥ ë©”ì„œë“œ
                        r = yield   # ë¸”ë¡ì„ ì§ì ‘ í˜¸ì¶œ
                    end
                end

                my_method do |var_name|
                    # ...
                end
            +asCode('ruby', 'code 2').
                def my_method(&amp;block)
                    if block            # ë¸”ë¡ì„ Proc ê°ì²´ë¡œ ë°›ìŒ
                        r = block.call  # Proc ê°ì²´ë¥¼ í†µí•´ ë¸”ë¡ ì‹¤í–‰
                    end
                end

                my_method do |var_name|
                    # ...
                end

                # &amp;ë¥¼ ë¶™ì—¬ Proc ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë¸”ë¡ìœ¼ë¡œ ì „ë‹¬í•  ìˆ˜ ìˆë‹¤
                # ëŒ€ìƒì´ Proc ì¸ìŠ¤í„´ìŠ¤ê°€ ì•„ë‹Œ ê²½ìš°, ì¸ìŠ¤í„´ìŠ¤ì˜ to_proc ë©”ì„œë“œ ê²°ê³¼ë¥¼ ë¸”ë¡ìœ¼ë¡œ ì „ë‹¬í•œë‹¤
                my_method &amp;Proc.new {|var_name| ... }

        h2 í´ë˜ìŠ¤
        ul
            li í´ë˜ìŠ¤ ì •ì˜
            +asCode('ruby').
                class ClassName
                    class InnerClass # ê°€ëŠ¥
                    end
                end
            li ìƒì„±ì í˜¸ì¶œ
            +asCode('ruby').
                var_name = ClassName.new
                var_name = ClassName::InnerClass.new
            li ìƒì„±ì ì •ì˜
            +asCode('ruby').
                class ClassName
                    def initialize(arg1, arg2, ...)
                        # ...
                    end
                end
            li í´ë˜ìŠ¤ ë©”ì„œë“œ ì •ì˜
            +asCode('ruby').
                class ClassName
                    def self.method_name(arg1, arg2, ...)
                        # ...
                    end
                end
            li í´ë˜ìŠ¤ ë³€ìˆ˜
            +asCode('ruby').
                class ClassName
                    @@var_name = 10
                end
            li ìƒì†
            p ìƒì† ê´€ê³„ë¥¼ ì§€ì •í•˜ì§€ ì•Šì€ í´ë˜ìŠ¤ëŠ” Objectë¥¼ ìƒì†í•œë‹¤
            +asCode('ruby').
                class SubClass &lt; SuperClass
                    def method_name
                        super   # ë¶€ëª¨ ë©”ì„œë“œ í˜¸ì¶œ
                        # ...
                    end
                end

        h2 ëª¨ë“ˆ
        ul
            li ì¸ìŠ¤í„´ìŠ¤í™” ë¶ˆê°€. ìƒì† ë¶ˆê°€. ë‚´ë¶€ì— ë‹¤ë¥¸ ëª¨ë“ˆ ë° í´ë˜ìŠ¤ ì •ì˜ ê°€ëŠ¥
            +asCode('ruby').
                module MyModule
                    class MyClass
                    end

                    def self.singleton_method # ëª¨ë“ˆ ìˆ˜ì¤€ ì‹±ê¸€í†¤ ë©”ì„œë“œ ê°€ëŠ¥
                    end
                end

                o = MyModule::MyClass.new
                MyModule.singleton_method
            li Mixin : ëª¨ë“ˆ ë©”ì„œë“œë¥¼ í´ë˜ìŠ¤ ì¸ìŠ¤í„´ìŠ¤ ë©”ì„œë“œë¡œ ì¶”ê°€
            +asCode('ruby').
                module MyModule
                    def method_name
                    end
                end

                class MyClass
                    include MyModule

                    def method_name
                        super
                        # ...
                    end
                end

                MyClass.new.method_name
            li ëª¨ë“ˆ ë©”ì„œë“œë¥¼ ì¸ìŠ¤í„´ìŠ¤ì˜ ì‹±ê¸€í†¤ ë©”ì„œë“œë¡œ ì¶”ê°€
            +asCode('ruby') obj.extend ModuleName
            li ëª¨ë“ˆ í•¨ìˆ˜ : ëª¨ë“ˆëª… ì—†ì´ í˜¸ì¶œ ê°€ëŠ¥
            +asCode('ruby').
                module MyModule
                    module_function

                    def test1
                    end
                    def test2
                    end
                end

                MyModule.test1
                MyModule.test2

                include MyModule
                test1
                test2

        h2 ë‚´ì¥ ìë£Œí˜•
        ul
            li ìˆ˜ : Numeric â† Fixnum, Bignum, Float
            p 0b111, 0777, 0o777, 0xfff, 3.14e+3, 1_234 í‘œê¸° ê°€ëŠ¥
            li ë¬¸ìì—´ : String
            ul
                li '', "" ëª¨ë‘ ê°€ëŠ¥í•˜ë©°, ""ëŠ” ì•ˆì— ë³´ê°„ì‹ &#x23;{...} ì‚¬ìš© ê°€ëŠ¥
                li ì—¬ëŸ¬ ì¤„ ë¬¸ìì—´(Heredoc)
                +asCode('ruby').
                    sql = &lt;&lt;SQL  # ì‹ë³„ìëŠ” ì ì ˆíˆ ë³€ê²½ ê°€ëŠ¥
                    select * from table1, table2
                    where
                        table1.col1 = table2.col2 and
                        table1.col2 > &#x23;{size}
                    SQL
                +asCode('ruby').
                    text = &lt;&lt;'TEXT'
                        \ì´ìŠ¤ì¼€ì´í”„ë˜ì§€ ì•ŠìŒ
                        &#x23;{ë³´ê°„ì‹} í‰ê°€í•˜ì§€ ì•ŠìŒ
                    TEXT
                li % String
                ul
                    li ê´„í˜¸ë¡œ (), [], {}, &lt;> ì‚¬ìš© ê°€ëŠ¥
                    p ë˜ëŠ” ì„ì˜ non-alphanumeric ë¬¸ì ì‚¬ìš© ê°€ëŠ¥
                    +asCode('ruby') %|123| == '123'
                    li ì†Œë¬¸ì : ë³´ê°„ì‹ í‰ê°€ x, \ì´ìŠ¤ì¼€ì´í”„ x
                    li %q : ë¬¸ìì—´
                    li %s : ì‹¬ë³¼
                    li %r : ì •ê·œì‹
                    li %x : Shell ëª…ë ¹ ì‹¤í–‰ ê²°ê³¼
                    +asCode('ruby') %x(ls -al)
                    li %i : Array of Symbols
                    li %w : Array of Strings
            li ì‹¬ë³¼
            p :ë¡œ ì‹œì‘í•˜ëŠ” ë³€ê²½ ë¶ˆê°€ëŠ¥í•œ ë¬¸ìì—´. ì‹ë³„ìë¡œ ì‚¬ìš© ë¶ˆê°€ëŠ¥í•œ ë¬¸ìë¥¼ í¬í•¨í•˜ëŠ” ê²½ìš° ë”°ì˜´í‘œ ì‚¬ìš© í•„ìš”
            +asCode('ruby').
                :my_simbol
                :'my-simbol'
            li ë°°ì—´ : []
            +asCode('ruby').
                arr = [0, 1, 2, 3]
                arr[10]      # nil
                arr[-1]      # ìŒìˆ˜ ì¸ë±ìŠ¤ ê°€ëŠ¥
                arr[10] = 10 # ì¤‘ê°„ì€ nilë¡œ ì±„ì›Œì§„ë‹¤

                %w(word1 word2 word3)       # ë¬¸ìì—´ ë°°ì—´
                %i(symbol1 symbol2 symbol3) # ì‹¬ë³¼ ë°°ì—´
            li í•´ì‹œ
            +asCode('ruby').
                scores = {
                    'name1' => 10,
                    'name2' => 20,
                    :symbol1 => 100
                }
                scores['name3'] = 30
                scores['anonymous'] # nil

                symbol_only = {s1: 1, s2: 2, s3: 3}
            li range
            +asCode('ruby').
                (1..5)      # 1, 2, 3, 4, 5
                (1...5)     # 1, 2, 3, 4

                Time.at(from)..Time.at(to)
                ('a'..'f')
            li ì •ê·œì‹; RegExp
            +asCode('ruby').
                pattern = /\d+/
                pattern = %r(/var/log/tomcat/.+) # ë³´ê°„ì‹ ì‚¬ìš© ê°€ëŠ¥
            li Proc : íŠ¹ì • ì§€ì—­ë³€ìˆ˜ë“¤ì— ë°”ìš´ë“œëœ í˜¸ì¶œ ê°€ëŠ¥í•œ ì½”ë“œ ë¸”ë¡
            +asCode('ruby').
                def gen_times(factor)
                    Proc.new {|n| n*factor } # ìƒì„± 1
                    proc {|n| n*factor }     # ìƒì„± 2
                    ->(n) { n*factor }       # ìƒì„± 3
                end

                times3 = gen_times(3)
                times5 = gen_times(5)

                times3.call(3)  # 9
                times5.call(3)  # 15

    h1 í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬
    div
        h2 module Kernel
        div
            h3 IO
            div
                h4 ë¬¸ìì—´ IO
                ul
                    li gets(sep=$/) -> string | nil
                        br
                        |gets(limit) -> string | nil
                        br
                        |gets(sep, limit) -> string | nil
                    ul
                        li ARGVì˜ íŒŒì¼ ë˜ëŠ” $stdinìœ¼ë¡œë¶€í„° ë¬¸ìì—´ì„ ì…ë ¥ë°›ëŠ”ë‹¤
                        li ë°˜í™˜ê°’ì€ $_ ë³€ìˆ˜ì— ì €ì¥ëœë‹¤
                        li limitì„ ì§€ì •í•˜ë©´ ìµœëŒ€ limit ë°”ì´íŠ¸ë§Œ ì½ëŠ”ë‹¤
                        li gets(sep=nil) -> íŒŒì¼ í•œ ê°œë¥¼ ëª¨ë‘ ì½ì–´ ë°˜í™˜
                        li íŒŒì¼ ëì— ë„ë‹¬í•œ ê²½ìš° nil ë°˜í™˜
                    li #p(*obj) -> [obj, ...]
                    p ê° ì¸ìì˜ inspect() ê²°ê³¼ë¥¼ ì¤„ë°”ê¿ˆ ë¬¸ìì™€ í•¨ê»˜ $stdoutìœ¼ë¡œ ì¶œë ¥
                    li #puts(*obj) -> nil
                    p ê° ì¸ìì˜ to_s() ê²°ê³¼ë¥¼ ì¤„ë°”ê¿ˆ ë¬¸ìì™€ í•¨ê»˜ $stdoutìœ¼ë¡œ ì¶œë ¥
                    li #print(*obj) -> nil
                    ul
                        li ê° ì¸ìì˜ to_s() ê²°ê³¼ë¥¼ $stdoutìœ¼ë¡œ ì¶œë ¥
                        li $, != nilì´ë©´ êµ¬ë¶„ìë¡œ ì¶œë ¥
                        li $\ != nilì´ë©´ ë§ˆì§€ë§‰ì— ì¶œë ¥
                        li ì¸ìê°€ ì—†ëŠ” ê²½ìš° $_ ì¶œë ¥
                    li sprintf(format_string, *arguments) -> string
                    +asCode('text', 'Cì–¸ì–´ì™€ ìœ ì‚¬') %[flags][width][.precision]type
                    li printf(io, format_string, *arguments) -> nil
                        br
                        |printf(format_string, *arguments) -> nil
                    +asCode('ruby') (io || $stdout).write(sprintf(format_string, *arguments))
            h3 ì‹¤í–‰/í”„ë¡œì„¸ìŠ¤
            ul
                li eval
                p ë™ì ìœ¼ë¡œ ì½”ë“œ í‰ê°€
                +asCode('ruby').
                    def get_binding(str)
                        binding
                    end
                    str = "hello"
                    eval "str + ' Fred'"                     # "hello Fred"
                    eval "str + ' Fred'", get_binding("bye") # "bye Fred"
                li exit(status=true)
                p SystemExit ì˜ˆì™¸ë¥¼ ë°œìƒí•˜ì—¬ ë£¨ë¹„ í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ ì ˆì°¨ë¥¼ ì‹œì‘í•œë‹¤
                li exit!(status=false)
                p í˜„ì¬ ë£¨ë¹„ í”„ë¡œì„¸ìŠ¤ë¥¼ ì¦‰ì‹œ ì¢…ë£Œí•œë‹¤. ì¢…ë£Œ í•¸ë“¤ëŸ¬ëŠ” í˜¸ì¶œë˜ì§€ ì•ŠëŠ”ë‹¤
                li trap(signal, command) -> obj
                    br
                    |trap(signal) {| | block } -> obj
                ul ì‹œìŠ¤í…œ ì‹ í˜¸ ì²˜ë¦¬ í•¸ë“¤ëŸ¬ ë“±ë¡
                    li signal
                    ol
                        li "SIGALRM", "SIGUSR1" ë“±ì˜ ì‹ í˜¸ ì´ë¦„
                        li ì„ ë‘ "SIG"ëŠ” ìƒëµí•´ë„ ëœë‹¤
                        li :EXIT, "EXIT", 0ì— ëŒ€í•´ ì²˜ë¦¬ë¥¼ ë“±ë¡í•˜ë©´ ë£¨ë¹„ í”„ë¡œì„¸ìŠ¤ ì •ìƒ ì¢…ë£Œ ì „ í˜¸ì¶œëœë‹¤
                    li command
                    ol
                        li "IGNORE", "SIG_IGN" : ì‹ í˜¸ ë¬´ì‹œ
                        li "DEFAULT", "RUBY_DFL" : ë£¨ë¹„ ê¸°ë³¸ í•¸ë“¤ëŸ¬ê°€ ì²˜ë¦¬
                        li "SYSTEM_DEFAULT" : ì‹œìŠ¤í…œ ê¸°ë³¸ í•¸ë“¤ëŸ¬ê°€ ì²˜ë¦¬
                        li ê·¸ ì™¸ì˜ ê²½ìš° command(Proc ì¸ìŠ¤í„´ìŠ¤) ë˜ëŠ” block í˜¸ì¶œ
                +asCode('ruby').
                    trap(0, proc { puts "Terminating: &#x23;{$$}" })
                    trap("CLD")  { puts "Child died" }
                li `cmd` -> string
                ul
                    li cmdë¥¼ ì‹¤í–‰í•˜ì—¬ ê²°ê³¼ë¥¼ ë°˜í™˜í•œë‹¤
                    li %x ë¬¸ìì—´ë„ ì´ ë©”ì„œë“œë¥¼ ì´ìš©í•œë‹¤
                    li ì¢…ë£Œëœ í”„ë¡œì„¸ìŠ¤ëŠ” $?ì— ì €ì¥ëœë‹¤
                li system([**env,] *command [,**opt]) -> true | false | nil
                ul
                    li ëª…ë ¹ì„ ì‹¤í–‰í•˜ì—¬ 0ìœ¼ë¡œ ì¢…ë£Œí•˜ë©´ true, ê·¸ ì™¸ ì¢…ë£ŒëŠ” false, ì‹¤íŒ¨ëŠ” nil
                    li ì¢…ë£Œëœ í”„ë¡œì„¸ìŠ¤ëŠ” $?ì— ì €ì¥ëœë‹¤
                    li command í˜•íƒœ
                    ol
                        li ì‰˜ì—ì„œ ì‹¤í–‰í•  ë¬¸ì¥ ì „ì²´
                        li command_name, arg1, arg2, ... # no shell
                        li [command_name, argv0], arg1, arg2 ... # no shell
                    li env, optë¡œ ì£¼ì–´ì§€ëŠ” í•´ì‹œëŠ” Kernel.exec(), Kernel.spawn()ê³¼ ë™ì¼
                li exec([**env,] *command [,**opt])
                p í˜„ì¬ í”„ë¡œì„¸ìŠ¤ì—ì„œ ì»¤ë§¨ë“œ ì‹¤í–‰ í›„ ì¢…ë£Œ
                li spawn([**env,] *command [,**opt]) -> pid
                ul
                    li ìì‹ í”„ë¡œì„¸ìŠ¤ë¡œ ëª…ë ¹ì„ ì‹¤í–‰í•˜ê³  PIDë¥¼ ë°˜í™˜í•œë‹¤
                    li env
                    ol
                        li key => value : í™˜ê²½ë³€ìˆ˜ ì„¤ì •
                        li key => nil : í™˜ê²½ë³€ìˆ˜ ì‚­ì œ
                    li opt
                    p
                        +asA('https://docs.ruby-lang.org/en/2.0.0/Kernel.html#method-i-spawn')
                        |  ì°¸ê³ 
            h3 ì™¸ë¶€ ì†ŒìŠ¤ ì½”ë“œ ë¡œë“œ
            ul
                li require(path)
                ul
                    li ì ˆëŒ€ê²½ë¡œ ì´ìš© ê°€ëŠ¥
                    li $LOAD_PATH ë‚´ì¥ë³€ìˆ˜ì˜ ë””ë ‰í„°ë¦¬ë¥¼ ê¸°ì¤€ìœ¼ë¡œ í•œ ìƒëŒ€ê²½ë¡œ ì´ìš© ê°€ëŠ¥
                    li ./, ../ ìƒëŒ€ê²½ë¡œëŠ” ì‹¤í–‰ ë””ë ‰í„°ë¦¬ ê¸°ì¤€
                    li íŒŒì¼ì„ ì°¾ì§€ ëª»í•œ ê²½ìš°, ì„¤ì¹˜ëœ gems ì¤‘ ë§¤ì¹­ë˜ëŠ” ê²ƒì´ ìˆëŠ”ì§€ ì°¾ëŠ”ë‹¤
                    li ê°™ì€ pathì— ëŒ€í•´ ì¤‘ë³µìœ¼ë¡œ ì‹¤í–‰í•˜ì§€ ì•ŠëŠ”ë‹¤
                li require_relative(string) -> true | false
                p í˜¸ì¶œí•˜ëŠ” íŒŒì¼ì´ ì¡´ì¬í•˜ëŠ” ë””ë ‰í„°ë¦¬ë¥¼ ê¸°ì¤€ìœ¼ë¡œ í•œ ìƒëŒ€ê²½ë¡œì˜ íŒŒì¼ì„ ì‹¤í–‰í•œë‹¤
                li load(filename, wrap=false) -> true
                ul
                    li ê°™ì€ filenameì— ëŒ€í•´ ë°˜ë³µ í˜¸ì¶œí•˜ë©´, ìŠ¤í¬ë¦½íŠ¸ë„ ë°˜ë³µ ì‹¤í–‰ëœë‹¤
                    li wrap=trueë¡œ ì§€ì •í•˜ë©´ ìµëª… ëª¨ë“ˆ ì•ˆì—ì„œ ì‹¤í–‰í•œë‹¤
                li autoload(module, filename) -> nil
                p module(String or symbol)ì„ ì²˜ìŒìœ¼ë¡œ ì ‘ê·¼í•˜ëŠ” ìˆœê°„ require(filename) ì‹¤í–‰
                li autoload?(name, inherit=true) -> String or nil
                p autoloadë¡œ nameì´ ë“±ë¡ëœ ê²½ìš°, í•´ë‹¹ filename ë°˜í™˜
                +asCode('ruby').
                    autoload(:B, "b")
                    autoload?(:B)     # "b"
            //- ::URI
            //- ::open
            //- ::open_uri_original_open
            //- #Array
            //- #BigDecimal
            //- #Complex
            //- #Float
            //- #Hash
            //- #Integer
            //- #JSON
            //- #Pathname
            //- #Rational
            //- #String
            //- #URI
            //- #__callee__
            //- #__dir__
            //- #__method__
            //- #abort
            //- #at_exit
            //- #binding
            //- #block_given?
            //- #callcc
            //- #caller
            //- #caller_locations
            //- #catch
            //- #chomp
            //- #chop
            //- #fail
            //- #fork
            //- #format
            //- #gem
            //- #gets
            //- #global_variables
            //- #gsub
            //- #iterator?
            //- #j
            //- #jj
            //- #lambda
            //- #local_variables
            //- #loop
            //- #open
            //- #open_uri_original_open
            //- #pretty_inspect
            //- #proc
            //- #putc
            //- #raise
            //- #rand
            //- #readline
            //- #readlines
            //- #scanf
            //- #select
            //- #set_trace_func
            //- #sleep
            //- #srand
            //- #sub
            //- #test
            //- #throw
            //- #trace_var
            //- #untrace_var
            //- #warn
            //- #y